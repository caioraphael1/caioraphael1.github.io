<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Game Developer, Engine Developer, Multithreading, Low-Level Network, Low-Level Systems, Bachelor in Physics - USP" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.04852.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
								<ul>
									<li>
										<a
											href="#color-spaces" >
                                            Color Spaces
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#linear" >
                                            Linear
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#hdr-sdr-ldr" >
                                            HDR, SDR, LDR
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#exposure" >
                                            Exposure
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#tone-mapping" >
                                            Tone Mapping
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#bloom-glow" >
                                            Bloom / Glow
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#lut-look-up-table" >
                                            LUT (Look Up Table)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#brightness-contrast-saturation-bcs" >
                                            Brightness, Contrast, Saturation (BCS)
										</a>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sizes.html" >
                                    Sizes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-fixing-artifacts.html" >
                                    Fixing Artifacts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Post-Processing
					</h1>
					<p>
						<time
							datetime="2025-07-03" >
                            üïí Created: 2025-07-03
						</time>
						<time
							datetime="2026-02-19" >
                            | Updated: 2026-02-19
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<h3
	id="color-spaces" >
    Color Spaces
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=AvgCkHrcj90" 
				class="external-link" 
				target="_blank" >
                Simplified Color Theory
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=FTKP0Y9MVus" 
				class="external-link" 
				target="_blank" >
                Color Theory, Vectorscope
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=texTxhcfEkY" 
				class="external-link" 
				target="_blank" >
                Color Correction: Color Spaces, Contrast, Saturation, Brightness, Gamma Correction
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=wbn5ULLtkHs" 
				class="external-link" 
				target="_blank" >
                Order of Post-Processing Effects, HDR, Tone Mapping
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=fv-wlo8yVhk" 
				class="external-link" 
				target="_blank" >
                Color Spaces, sRGB, HSV, RVL, OKLAB
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://oklch.com/#64.54,0.1422,360,100" 
				class="external-link" 
				target="_blank" >
                OKLAB: Color Picker and Converter
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="linear" >
    Linear
</h3>
<pre><code class="language-glsl" data-lang="glsl">vec3 srgb_to_linear_approx(vec3 srgb) {
¬† ¬† return pow(srgb, vec3(2.2));
}

vec3 linear_to_srgb_approx(vec3 linear) {
¬† ¬† return pow(linear, vec3(1.0 / 2.2));
}
vec3 linear_to_srgb(vec3 color) {
¬† ¬† //if going to srgb, clamp from 0 to 1.
¬† ¬† color = clamp(color, vec3(0.0), vec3(1.0));
¬† ¬† const vec3 a = vec3(0.055f);
¬† ¬† return mix((vec3(1.0f) + a) * pow(color.rgb, vec3(1.0f / 2.4f)) - a, 12.92f * color.rgb, lessThan(color.rgb, vec3(0.0031308f)));
}


vec3 srgb_to_linear(vec3 srgb) {
¬† ¬† vec3 cutoff = step(vec3(0.04045), srgb);
¬† ¬† vec3 low ¬† ¬†= srgb / 12.92;
¬† ¬† vec3 high ¬† = pow((srgb + 0.055) / 1.055, vec3(2.4));
¬† ¬† return mix(low, high, cutoff);
}

vec3 linear_to_srgb(vec3 linear) {
¬† ¬† vec3 cutoff = step(vec3(0.0031308), linear);
¬† ¬† vec3 low ¬†= linear * 12.92;
¬† ¬† vec3 high ¬†= pow(linear, vec3(1.0/2.4)) * 1.055 - 0.055;
¬† ¬† return mix(low, high, cutoff);
}
</code></pre>
<h3
	id="hdr-sdr-ldr" >
    HDR, SDR, LDR
</h3>
<ul>
	<li>
		<p>
            The word 
			<em>
                dynamic
			</em>
            &nbsp;refers to the range of luminance (brightness) values that can be represented and displayed ‚Äî from the darkest blacks to the brightest highlights.
		</p>
	</li>
	<li>
		<p>
			<strong>
                HDR (High Dynamic Range):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    A standard that represents a wide range of brightness and color, preserving details in both dark and bright areas.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Brightness
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Can reach 600‚Äì2000+ nits depending on the display, allowing much brighter highlights.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Color Gamut
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Often uses Rec.2020 or DCI-P3, covering a wider range of colors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Formats
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Multiple formats exist (HDR10, HDR10+, Dolby Vision, HLG), requiring display and content compatibility.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SDR (Standard Dynamic Range):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The traditional display standard with limited brightness and color range, typically around 100 nits and Rec.709 gamut.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Brightness
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Typically limited to around 100 nits peak brightness.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Color Gamut
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Typically uses Rec.709 color space (sRGB).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Formats
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Standardized and widely compatible, but visually limited.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        LDR (Low Dynamic Range):
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            A more generic term for images or rendering with restricted tonal range, often limited to 8-bit precision and prone to clipping in highlights and shadows.
						</p>
					</li>
					<li>
						<p>
                            All LDR fits inside SDR; it's an informal subset.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818075403.png" width="275" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818074643.png" width="275" >
            .
		</p>
	</li>
</ul>
<h3
	id="exposure" >
    Exposure
</h3>
<ul>
	<li>
		<p>
            In most rendering pipelines, exposure is applied as a simple scalar multiplier on the scene-linear color:
		</p>
		<ul>
			<li>
				<p>
                    <code>color_exposed = color_linear * k</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            where 
            <code>k</code>
            &nbsp;is some gain factor.
		</p>
	</li>
	<li>
		<p>
            Many engines define 
            <code>k</code>
            &nbsp;relative to an exposure offset in 
			<strong>
                stops
			</strong>
            &nbsp;(like in photography). Each stop corresponds to doubling or halving the light.
		</p>
	</li>
	<li>
		<p>
            For example:
		</p>
<pre><code class="language-glsl" data-lang="glsl">color *= exp2(ev);
</code></pre>
		<ul>
			<li>
				<p>
                    <code>ev</code>
                    &nbsp;= exposure value in stops.
				</p>
			</li>
			<li>
				<p>
                    <code>exp2(ev)</code>
                    &nbsp;= $2^{ev}$.
				</p>
			</li>
			<li>
				<p>
                    <code>ev = +1.0</code>
                    &nbsp;‚Üí multiply color by 2 (one stop brighter).
				</p>
			</li>
			<li>
				<p>
                    <code>ev = -1.0</code>
                    &nbsp;‚Üí multiply color by 0.5 (one stop darker).
				</p>
			</li>
			<li>
				<p>
                    <code>ev = 0.0</code>
                    &nbsp;‚Üí multiply by 1 (no change).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            See https://google.github.io/filament/Filament.md.html#imagingpipeline/physicallybasedcamera for more information.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// Computes the camera's EV100 from exposure settings
// aperture in f-stops
// shutterSpeed in seconds
// sensitivity in ISO
float exposureSettings(float aperture, float shutterSpeed, float sensitivity) {
&nbsp;&nbsp;&nbsp;&nbsp;return log2((aperture * aperture) / shutterSpeed * 100.0 / sensitivity);
}

// Computes the exposure normalization factor from
// the camera's EV100
float exposure(float ev100) {
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0 / (pow(2.0, ev100) * 1.2);
}

float ev100 = exposureSettings(aperture, shutterSpeed, sensitivity);
float exposure = exposure(ev100);

vec4 color = evaluateLighting();
color.rgb *= exposure;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Material
				</p>
				<ul>
					<li>
						<p>
                            Base color: sRGB 0.81, 0, 0
						</p>
					</li>
					<li>
						<p>
                            Metallic: 0
						</p>
					</li>
					<li>
						<p>
                            Roughness: 0
						</p>
					</li>
					<li>
						<p>
                            Reflectance: 0.5
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Indirect light: IBL
				</p>
				<ul>
					<li>
						<p>
                            256√ó256 cubemap generated by cmgen from office.exr
						</p>
					</li>
					<li>
						<p>
                            Multiplier: 35,000
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Direct light: directional light
				</p>
				<ul>
					<li>
						<p>
                            Linear color: 1.0, 0.96, 0.95
						</p>
					</li>
					<li>
						<p>
                            Intensity: 120,000 lux
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Exposure
				</p>
				<ul>
					<li>
						<p>
                            Aperture: f/16
						</p>
					</li>
					<li>
						<p>
                            Shutter speed: 1/125s
						</p>
					</li>
					<li>
						<p>
                            ISO: 100
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918080857.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="tone-mapping" >
    Tone Mapping
</h3>
<ul>
	<li>
		<p>
            Filament: Perform post-processing on the scene-referred data (linear space, before tone-mapping) as much as possible.
		</p>
	</li>
	<li>
		<p>
			<em>
                Range Compression
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Convert HDR luminance to LDR luminance.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Color Space Conversion
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Convert LDR luminance to the desired color space (RGB, XYZ, CMYK, etc).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Baked as LUT
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    ‚ÄúBakes‚Äù the transform:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        3D LUT:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Encodes the full color mapping (linear ‚Üí display).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        1D LUTs:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Sometimes used for individual transfer functions (e.g., gamma, log encoding).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This is less flexible (changing exposure or dynamic response means regenerating the LUT) but can be faster or simpler.
				</p>
			</li>
			<li>
				<p>
                    This allows both dynamic range compression 
					<em>
                        and
					</em>
                    &nbsp;color grading in one lookup.
				</p>
			</li>
			<li>
				<p>
                    Common in offline workflows (film, photography), less common in real-time engines because:
				</p>
				<ul>
					<li>
						<p>
                            Needs large 3D textures for precision.
						</p>
					</li>
					<li>
						<p>
                            Harder to tweak exposure/gamma without regenerating the LUT.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ACES
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Industry-standard color pipeline used in film/VFX.
				</p>
			</li>
			<li>
				<p>
                    ACES defines a full rendering pipeline:
				</p>
				<ol>
					<li>
						<p>
                            Input color space conversion (scene-linear ‚Üí ACEScg).
						</p>
					</li>
					<li>
						<p>
                            Rendering transform (RRT).
						</p>
					</li>
					<li>
						<p>
                            Output transform (ODT) for the target display (sRGB, Rec.709, HDR10, etc.).
						</p>
						<ul>
							<li>
								<p>
                                    The ODT contains the tone mapping curve that compresses HDR highlights, so the final result isn‚Äôt ‚Äúblown out.‚Äù
								</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    If you‚Äôre implementing ‚ÄúACES without LUT‚Äù and using the standard analytical approximation (often seen in game engines, e.g. the Narkowicz ACES fit), you are applying that curve. That‚Äôs why your results look controlled.
				</p>
			</li>
			<li>
				<p>
                    Core includes a tone-mapping-like step in the RRT+ODT chain.
				</p>
			</li>
			<li>
				<p>
                    The ACES RRT+ODT math is the ‚Äúrecipe.‚Äù If you would bake this into a LUT, the LUT would be a ‚Äúpre-baked version of the recipe‚Äù so software can apply it quickly without recalculating everything.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                AgX
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/EaryChow/AgX" 
						class="external-link" 
						target="_blank" >
                        AgX
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://projects.blender.org/blender/blender/pulls/106355" 
						class="external-link" 
						target="_blank" >
                        AgX in Blender
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        AgX without LUT
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            You‚Äôre skipping its actual rendering transform, so you‚Äôre just doing a color space conversion, not a tonemap.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    AgX is normally delivered and used as a full view transform (shaper + contrast + color transforms) in OCIO configs and as pre-baked LUTs.
				</p>
			</li>
			<li>
				<p>
                    A more recent open-source rendering transform for 3D (often seen in Blender).
				</p>
			</li>
			<li>
				<p>
                    Similar idea to ACES: a defined rendering transform that compresses HDR ‚Üí display space with filmic-like contrast.
				</p>
			</li>
			<li>
				<p>
                    AgX is newer and designed around filmic contrast with a wider shoulder/roll-off.
				</p>
			</li>
			<li>
				<p>
                    The official AgX distribution is often provided as LUTs (for Blender, Nuke, etc.).
				</p>
			</li>
			<li>
				<p>
                    If you apply only the matrix transforms (input ‚Üí working space ‚Üí output primaries) but skip the LUT (the part that encodes the log-like shaper + contrast mapping), you‚Äôre basically just viewing scene-linear ‚Üí display without the tonemapping curve.
				</p>
			</li>
			<li>
				<p>
                    Result: very bright, blown-out highlights.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Luminance visualization for debug
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Implementation of a custom debug tone-mapping operator for luminance visualization:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 Tonemap_DisplayRange(const vec3 x) {
&nbsp;&nbsp;&nbsp;&nbsp;// The 5th color in the array (cyan) represents middle gray (18%)
&nbsp;&nbsp;&nbsp;&nbsp;// Every stop above or below middle gray causes a color shift
&nbsp;&nbsp;&nbsp;&nbsp;float v = log2(luminance(x) / 0.18);
&nbsp;&nbsp;&nbsp;&nbsp;v = clamp(v + 5.0, 0.0, 15.0);
&nbsp;&nbsp;&nbsp;&nbsp;int index = int(floor(v));
&nbsp;&nbsp;&nbsp;&nbsp;return mix(debugColors[index], debugColors[min(15, index + 1)], fract(v));
}

const vec3 debugColors[16] = vec3[](
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // black
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.0, 0.1647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// darkest blue
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.0, 0.3647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// darker blue
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.0, 0.6647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dark blue
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.0, 0.9647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// blue
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.9255, 0.9255),&nbsp;&nbsp; // cyan
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.5647, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dark green
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.0, 0.7843, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// green
&nbsp;&nbsp;&nbsp;&nbsp; vec3(1.0, 1.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // yellow
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.90588, 0.75294, 0.0), // yellow-orange
&nbsp;&nbsp;&nbsp;&nbsp; vec3(1.0, 0.5647, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// orange
&nbsp;&nbsp;&nbsp;&nbsp; vec3(1.0, 0.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bright red
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.8392, 0.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// red
&nbsp;&nbsp;&nbsp;&nbsp; vec3(1.0, 0.0, 1.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // magenta
&nbsp;&nbsp;&nbsp;&nbsp; vec3(0.6, 0.3333, 0.7882),&nbsp;&nbsp; // purple
&nbsp;&nbsp;&nbsp;&nbsp; vec3(1.0, 1.0, 1.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// white
);
</code></pre>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922081941.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="bloom-glow" >
    Bloom / Glow
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/environment_and_post_processing.html#glow" 
				class="external-link" 
				target="_blank" >
                Glow - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The idea of levels is interesting, and the use of a Glow Map is very cool, giving a lens dirt look.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918115611.png" width="750" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Filament Engine code:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec4 surfaceShading() {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 color = evaluateLights();
&nbsp;&nbsp;&nbsp;&nbsp;// rgb = color, w = exposure compensation
&nbsp;&nbsp;&nbsp;&nbsp;vec4 emissive = getEmissive();
&nbsp;&nbsp;&nbsp;&nbsp;color.rgb += emissive.rgb * pow(2.0, ev100 + emissive.w - 3.0);
&nbsp;&nbsp;&nbsp;&nbsp;color.rgb *= exposure;
&nbsp;&nbsp;&nbsp;&nbsp;return color;
}
</code></pre>
<ul>
	<li>
		<p>
            ChatGPT code, I think:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// Note: FBO is FrameBuffer Object (Color Attachment).

// Bright-pass fragment shader (extract bright areas)
#version 330 core
in vec2 vUV;
out vec4 FragColor;

uniform sampler2D sceneTex;&nbsp;&nbsp;&nbsp;&nbsp;// HDR scene texture (RGB, float)
uniform float threshold;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // brightness threshold
uniform float knee;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// soft knee (0..1). 0 = hard threshold

// Convert RGB luminance (sRGB or linear - be consistent with your pipeline)
float luminance(vec3 c) {
&nbsp;&nbsp;&nbsp;&nbsp;// If your sceneTex is linear, use linear luminance.
&nbsp;&nbsp;&nbsp;&nbsp;return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 color = texture(sceneTex, vUV).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;float l = luminance(color);

&nbsp;&nbsp;&nbsp;&nbsp;// smooth threshold (Reinhard-style soft knee)
&nbsp;&nbsp;&nbsp;&nbsp;float t = threshold;
&nbsp;&nbsp;&nbsp;&nbsp;float k = knee * t;
&nbsp;&nbsp;&nbsp;&nbsp;float soft = clamp((l - (t - k)) / (k + 1e-6), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;float contribution = max(l - t, 0.0) / (max(l, 1e-6)) ; // preserves color hue for very bright
&nbsp;&nbsp;&nbsp;&nbsp;// Blend soft and hard:
&nbsp;&nbsp;&nbsp;&nbsp;float mask = max(contribution, soft);

&nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(color * mask, 1.0);
}

// Separable Gaussian blur fragment shader (use twice: horizontal then vertical)
#version 330 core
in vec2 vUV;
out vec4 FragColor;

uniform sampler2D image;
uniform vec2 texelSize;&nbsp;&nbsp; // 1.0 / textureSize (width, height)
uniform vec2 direction;&nbsp;&nbsp; // (1,0) horizontal pass, (0,1) vertical pass

// 9-tap Gaussian weights (can be adjusted). Symmetric kernel.
const float weights[9] = float[](
&nbsp;&nbsp;&nbsp;&nbsp;0.051, 0.0918, 0.12245, 0.1531, 0.1633, 0.1531, 0.12245, 0.0918, 0.051
);

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 result = vec3(0.0);
&nbsp;&nbsp;&nbsp;&nbsp;// center tap
&nbsp;&nbsp;&nbsp;&nbsp;result += texture(image, vUV).rgb * weights[4];

&nbsp;&nbsp;&nbsp;&nbsp;// sample pairs
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= 4; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 offset = direction * texelSize * float(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 t1 = texture(image, vUV + offset).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 t2 = texture(image, vUV - offset).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float w = weights[4 + i]; // symmetric indexing where center is index 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// weights array arranged so index maps: 0..8 with center at 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += (t1 + t2) * w;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(result, 1.0);
}

// Composite fragment shader (add bloom to scene + optional tonemapping)
#version 330 core
in vec2 vUV;
out vec4 FragColor;

uniform sampler2D sceneTex;&nbsp;&nbsp; // original HDR scene (no bright-pass)
uniform sampler2D bloomTex;&nbsp;&nbsp; // blurred bright-pass
uniform float bloomIntensity; // how much bloom to add
uniform float exposure;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // optional exposure for tonemapping
uniform bool&nbsp;&nbsp;applyTonemap;&nbsp;&nbsp; // whether to apply simple tonemap

vec3 acesFilm(vec3 x) {
&nbsp;&nbsp;&nbsp;&nbsp;// small ACES tone curve approximation (optional)
&nbsp;&nbsp;&nbsp;&nbsp;const float a = 2.51;
&nbsp;&nbsp;&nbsp;&nbsp;const float b = 0.03;
&nbsp;&nbsp;&nbsp;&nbsp;const float c = 2.43;
&nbsp;&nbsp;&nbsp;&nbsp;const float d = 0.59;
&nbsp;&nbsp;&nbsp;&nbsp;const float e = 0.14;
&nbsp;&nbsp;&nbsp;&nbsp;return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 hdr = texture(sceneTex, vUV).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 bloom = texture(bloomTex, vUV).rgb;

&nbsp;&nbsp;&nbsp;&nbsp;vec3 combined = hdr + bloom * bloomIntensity;

&nbsp;&nbsp;&nbsp;&nbsp;vec3 mapped = combined;
&nbsp;&nbsp;&nbsp;&nbsp;if (applyTonemap) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapped = acesFilm(combined * exposure);
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// simple exposure clamp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapped = 1.0 - exp(-combined * exposure);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(mapped, 1.0);
}
</code></pre>
<h3
	id="lut-look-up-table" >
    LUT (Look Up Table)
</h3>
<ul>
	<li>
		<p>
            Applies a color transformation by remapping colors according to a precomputed table. Usually for grading, stylization, or fine-tuned color correction.
		</p>
	</li>
	<li>
		<p>
            Takes already tonemapped LDR (or sometimes linear HDR) colors and remaps them for a particular ‚Äúlook.‚Äù
		</p>
	</li>
	<li>
		<p>
			<em>
                1D LUT
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Adjusts a single channel independently (e.g., gamma, exposure).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                3D LUT
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Remaps full RGB triples (commonly used in film and games for grading).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Format
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>.cube</code>
				</p>
			</li>
			<li>
				<p>
                    <code>.png</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=xxlBTiNvYzE" 
				class="external-link" 
				target="_blank" >
                LUT 1D and LUT3D
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Godot LUT Applying
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 apply_bcs(vec3 color, vec3 bcs) {
¬† ¬† color = mix(vec3(0.0f), color, bcs.x);
¬† ¬† color = mix(vec3(0.5f), color, bcs.y);
¬† ¬† color = mix(vec3(dot(vec3(1.0f), color) * 0.33333f), color, bcs.z);
¬† ¬† return color;
}

#ifdef USE_1D_LUT
vec3 apply_color_correction(vec3 color) {
¬† ¬† color.r = texture(source_color_correction, vec2(color.r, 0.0f)).r;
¬† ¬† color.g = texture(source_color_correction, vec2(color.g, 0.0f)).g;
¬† ¬† color.b = texture(source_color_correction, vec2(color.b, 0.0f)).b;
¬† ¬† return color;
}
#else
vec3 apply_color_correction(vec3 color) {
¬† ¬† return textureLod(source_color_correction, color, 0.0).rgb;
}
#endif
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                LUT Generation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Code of 
                    <code>genbrdflut.vert</code>
                    &nbsp;and 
                    <code>genbrdflut.frag</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Vertex Shader
#version 450
layout (location = 0) out vec2 outUV;
void main()
{
&nbsp;&nbsp;&nbsp;&nbsp;outUV = vec2((gl_VertexIndex &lt;&lt; 1) & 2, gl_VertexIndex & 2);
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position = vec4(outUV * 2.0f - 1.0f, 0.0f, 1.0f);
}


// Frag Shader
#version 450
layout (location = 0) in vec2 inUV;
layout (location = 0) out vec4 outColor;
layout (constant_id = 0) const uint NUM_SAMPLES = 1024u;
const float PI = 3.1415926536;
// Based omn http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
float random(vec2 co)
{
&nbsp;&nbsp;&nbsp;&nbsp;float a = 12.9898;
&nbsp;&nbsp;&nbsp;&nbsp;float b = 78.233;
&nbsp;&nbsp;&nbsp;&nbsp;float c = 43758.5453;
&nbsp;&nbsp;&nbsp;&nbsp;float dt= dot(co.xy ,vec2(a,b));
&nbsp;&nbsp;&nbsp;&nbsp;float sn= mod(dt,3.14);
&nbsp;&nbsp;&nbsp;&nbsp;return fract(sin(sn) * c);
}
vec2 hammersley2d(uint i, uint N)
{
&nbsp;&nbsp;&nbsp;&nbsp;// Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
&nbsp;&nbsp;&nbsp;&nbsp;uint bits = (i &lt;&lt; 16u) | (i &gt;&gt; 16u);
&nbsp;&nbsp;&nbsp;&nbsp;bits = ((bits & 0x55555555u) &lt;&lt; 1u) | ((bits & 0xAAAAAAAAu) &gt;&gt; 1u);
&nbsp;&nbsp;&nbsp;&nbsp;bits = ((bits & 0x33333333u) &lt;&lt; 2u) | ((bits & 0xCCCCCCCCu) &gt;&gt; 2u);
&nbsp;&nbsp;&nbsp;&nbsp;bits = ((bits & 0x0F0F0F0Fu) &lt;&lt; 4u) | ((bits & 0xF0F0F0F0u) &gt;&gt; 4u);
&nbsp;&nbsp;&nbsp;&nbsp;bits = ((bits & 0x00FF00FFu) &lt;&lt; 8u) | ((bits & 0xFF00FF00u) &gt;&gt; 8u);
&nbsp;&nbsp;&nbsp;&nbsp;float rdi = float(bits) * 2.3283064365386963e-10;
&nbsp;&nbsp;&nbsp;&nbsp;return vec2(float(i) /float(N), rdi);
}
// Based on http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_slides.pdf
vec3 importanceSample_GGX(vec2 Xi, float roughness, vec3 normal)
{
&nbsp;&nbsp;&nbsp;&nbsp;// Maps a 2D point to a hemisphere with spread based on roughness
&nbsp;&nbsp;&nbsp;&nbsp;float alpha = roughness * roughness;
&nbsp;&nbsp;&nbsp;&nbsp;float phi = 2.0 * PI * Xi.x + random(normal.xz) * 0.1;
&nbsp;&nbsp;&nbsp;&nbsp;float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (alpha*alpha - 1.0) * Xi.y));
&nbsp;&nbsp;&nbsp;&nbsp;float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
&nbsp;&nbsp;&nbsp;&nbsp;// Tangent space
&nbsp;&nbsp;&nbsp;&nbsp;vec3 up = abs(normal.z) &lt; 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 tangentX = normalize(cross(up, normal));
&nbsp;&nbsp;&nbsp;&nbsp;vec3 tangentY = normalize(cross(normal, tangentX));
&nbsp;&nbsp;&nbsp;&nbsp;// Convert to world Space
&nbsp;&nbsp;&nbsp;&nbsp;return normalize(tangentX * H.x + tangentY * H.y + normal * H.z);
}
// Geometric Shadowing function
float G_SchlicksmithGGX(float dotNL, float dotNV, float roughness)
{
&nbsp;&nbsp;&nbsp;&nbsp;float k = (roughness * roughness) / 2.0;
&nbsp;&nbsp;&nbsp;&nbsp;float GL = dotNL / (dotNL * (1.0 - k) + k);
&nbsp;&nbsp;&nbsp;&nbsp;float GV = dotNV / (dotNV * (1.0 - k) + k);
&nbsp;&nbsp;&nbsp;&nbsp;return GL * GV;
}
vec2 BRDF(float NoV, float roughness)
{
&nbsp;&nbsp;&nbsp;&nbsp;// Normal always points along z-axis for the 2D lookup
&nbsp;&nbsp;&nbsp;&nbsp;const vec3 N = vec3(0.0, 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 V = vec3(sqrt(1.0 - NoV*NoV), 0.0, NoV);
&nbsp;&nbsp;&nbsp;&nbsp;vec2 LUT = vec2(0.0);
&nbsp;&nbsp;&nbsp;&nbsp;for(uint i = 0u; i &lt; NUM_SAMPLES; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 Xi = hammersley2d(i, NUM_SAMPLES);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 H = importanceSample_GGX(Xi, roughness, N);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 L = 2.0 * dot(V, H) * H - V;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dotNL = max(dot(N, L), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dotNV = max(dot(N, V), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dotVH = max(dot(V, H), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dotNH = max(dot(H, N), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dotNL &gt; 0.0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float G = G_SchlicksmithGGX(dotNL, dotNV, roughness);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float G_Vis = (G * dotVH) / (dotNH * dotNV);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float Fc = pow(1.0 - dotVH, 5.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LUT += vec2((1.0 - Fc) * G_Vis, Fc * G_Vis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return LUT / float(NUM_SAMPLES);
}
void main()
{
&nbsp;&nbsp;&nbsp;&nbsp;outColor = vec4(BRDF(inUV.s, 1.0-inUV.t), 0.0, 1.0);
}
</code></pre>
	</li>
</ul>
<h3
	id="brightness-contrast-saturation-bcs" >
    Brightness, Contrast, Saturation (BCS)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Brightness, Contrast, Saturation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>bcs.x</code>
                    &nbsp;‚Üí 
					<strong>
                        brightness/contrast scaling
					</strong>
                    &nbsp;(closer to contrast, but with black reference).
				</p>
			</li>
			<li>
				<p>
                    <code>bcs.y</code>
                    &nbsp;‚Üí 
					<strong>
                        bias toward mid-gray
					</strong>
                    &nbsp;(brightness adjustment).
				</p>
			</li>
			<li>
				<p>
                    <code>bcs.z</code>
                    &nbsp;‚Üí 
					<strong>
                        saturation
					</strong>
                    &nbsp;(grayscale ‚Üî color).
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// GODOT
vec3 apply_bcs(vec3 color, vec3 bcs) {
¬† ¬† color = mix(vec3(0.0f), color, bcs.x);
¬† ¬† color = mix(vec3(0.5f), color, bcs.y);
¬† ¬† color = mix(vec3(dot(vec3(1.0f), color) * 0.33333f), color, bcs.z);
¬† ¬† return color;
}
</code></pre>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.04852.js" >
		</script>
	</body>
</html>
