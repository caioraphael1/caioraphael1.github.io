<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.24731.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
>
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering.html" >
                                Font Rendering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Low-Level Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers.html" >
                                Profilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - DOD e COP/Design - DOD e COP.html" >
                                Design - DOD e COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - ECS/Design - ECS.html" >
                                Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Design Patterns/Design - Design Patterns.html" >
                                Design - Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Architecture Patterns.html" >
                                Design - Architecture Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Concepts and Terminology.html" >
                                Design - Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Rules of thumb - Laws - Guidelines and Principles/Design - Rules of thumb - Laws - Guidelines and Principles.html" >
                                Design - Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Paradigms.html" >
                                Design - Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Production Methodologies/Design - Production Methodologies.html" >
                                Design - Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Security.html" >
                                Security
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Game Development
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game AI/Game AI.html" >
                                Game AI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Procedural Animation/Procedural Animation.html" >
                                Procedural Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game Design/Game Design.html" >
                                Game Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Level Design.html" >
                                Level Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Scanning Algorithms.html" >
                                Scanning Algorithms
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Art
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing, Color Theory, Pixel Art/Drawing, Color Theory, Pixel Art.html" >
                                Drawing, Color Theory, Pixel Art
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Low-Poly, PSX.html" >
                                Low-Poly, PSX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Animation.html" >
                                Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Texel Density.html" >
                                Texel Density
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender.html" >
                                Blender
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender - Rigging and Animation.html" >
                                Blender - Rigging and Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench.html" >
                                Blockbench
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench - Source Code.html" >
                                Blockbench - Source Code
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing Softwares.html" >
                                Drawing Softwares
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Aseprite/Aseprite.html" >
                                Aseprite
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Voxel Editors.html" >
                                Voxel Editors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/MagicaVoxel.html" >
                                MagicaVoxel
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 2D/Level Editors 2D.html" >
                                Level Editors 2D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 3D.html" >
                                Level Editors 3D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/LDtk/LDtk.html" >
                                LDtk
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/TrenchBroom.html" >
                                TrenchBroom
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Assets - Sources and References/Assets - Sources and References.html" >
                                Assets - Sources and References
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Frameworks - Libraries
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Frameworks - Libraries/Frameworks - Libraries.html" >
                                Frameworks - Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/RayLib/RayLib.html" >
                                RayLib
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Clay/Clay.html" >
                                Clay
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Physics Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines.html" >
                                Physics Engines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics.html" >
                                Physics Engines - JoltPhysics
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Other Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Other Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Godot Engine
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot/Godot.html" >
                                Godot
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDScript/Godot - GDScript.html" >
                                Godot - GDScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDExtensions.html" >
                                Godot - GDExtensions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - Source Code.html" >
                                Godot - Source Code
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Embedded Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/RaspiberryPi.html" >
                                RaspiberryPi
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Embedded Systems.html" >
                                Embedded Systems
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Platforms
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Windows/Windows.html" >
                                Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Steam/Steam.html" >
                                Steam
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Android/Android.html" >
                                Android
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/iOS/iOS.html" >
                                iOS
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Terminal
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Code Editors
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim/NeoVim.html" >
                                NeoVim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Etc
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Licenses.html" >
                                Licenses
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Unity/Unity.html" >
                                Unity
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Other Engines.html" >
                                Other Engines
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Zig
						</h1>
						<p>
							<time
								datetime="2025-01-09" >
                                ðŸ•’ Created: 2025-01-09
							</time>
							<time
								datetime="2025-12-10" >
                                | Updated: 2025-12-10
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="impressions" >
    Impressions
</h2>
<ul>
	<li>
		<p>
            (2025-03-30)
		</p>
	</li>
</ul>
<h3
	id="negative-points" >
    Negative points
</h3>
<ul>
	<li>
		<p>
			<strong>
                The LSP is TERRIBLE
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250330084131.png" width="725" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            The parameters of 
                            <code>readAllAlloc</code>
                            &nbsp;are: 
                            <code>self</code>
                            , 
                            <code>allocator</code>
                            &nbsp;and 
                            <code>size</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The parameters shown by the inlay hint are wrong, because it considers the first parameter to be 
                            <code>self</code>
                            , when in fact that is passed implicitly since 
                            <code>readAllAlloc</code>
                            &nbsp;is a method of a struct.
						</p>
					</li>
					<li>
						<p>
                            <code>stat</code>
                            &nbsp;wasn't unwrapped in this case, so it will cause an error when trying to do 
                            <code>stat.size</code>
						</p>
						<ul>
							<li>
								<p>
                                    In other words, it never informs me that I'm forgetting to do error handling.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It keeps showing me errors that have already been resolved after compiling and getting an error.
				</p>
				<ul>
					<li>
						<p>
                            Even after fixing the error and even after restarting the LSP, it stays stuck showing old errors and ignoring the new ones.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Zig output messages are horrible and confusing
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Anonymous Structs are unpleasant
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Safety
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I don't like how anonymous structs are called; it always feels like I'm dealing with some Lua object.
						</p>
					</li>
					<li>
						<p>
                            There is NO indicator that I'm forgetting to initialize some required struct parameter.
						</p>
						<ul>
							<li>
								<p>
                                    The LSP doesn't try to infer which anonymous struct I'm referring to, to give me information whether things are correct.
								</p>
							</li>
							<li>
								<p>
                                    Maybe that's very hard, since the struct is completely anonymous and could mean anything.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        I don't like the syntax
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The declaration is done like this:
						</p>
<pre><code class="language-zig" data-lang="zig">const Player = struct {
&nbsp;&nbsp;&nbsp;&nbsp;pos: rl.Vector2,
&nbsp;&nbsp;&nbsp;&nbsp;vel: rl.Vector2 = rl.Vector2.init(0, 0),
&nbsp;&nbsp;&nbsp;&nbsp;aceleracao: f16,
&nbsp;&nbsp;&nbsp;&nbsp;vel_max: f16,
&nbsp;&nbsp;&nbsp;&nbsp;sprite: rl.Texture2D
};
</code></pre>
						<ul>
							<li>
								<p>
                                    I find it confusing where the 
                                    <code>struct</code>
                                    &nbsp;keyword is placed.
								</p>
								<ul>
									<li>
										<p>
                                            I'm creating a TYPE, but the impression I get is that I'm just creating a random 
                                            <code>const</code>
                                            &nbsp;that receives an anonymous struct, but using the 
                                            <code>struct</code>
                                            &nbsp;keyword.
										</p>
										<ul>
											<li>
												<p>
                                                    Maybe deep down that's what is happening, but it's odd. I want a type definition, not something &quot;taken apart&quot; like this.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            In Odin structs are declared the same way, but in Odin the 
                                            <code>keyword</code>
                                            &nbsp;follows the same pattern as the declaration of 
                                            <code>proc</code>
                                            :
										</p>
<pre><code class="language-zig" data-lang="zig">Vector2 :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;x: f32,
&nbsp;&nbsp;&nbsp;&nbsp;y: f32,
}
</code></pre>
										<ul>
											<li>
												<p>
                                                    Proc in odin:
												</p>
<pre><code class="language-zig" data-lang="zig">multiply :: proc(x: int, y: int) -&gt; int {
&nbsp;&nbsp;&nbsp;&nbsp;return x * y
}
</code></pre>
											</li>
											<li>
												<p>
                                                    It follows the same structure 
                                                    <code>name</code>
                                                    &nbsp;+ 
                                                    <code>::</code>
                                                    &nbsp;(const) + 
                                                    <code>keyword</code>
                                                    &nbsp;(proc or struct) + syntax.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Zig seems undecided about it, such that it uses 
                                            <code>var + name</code>
                                            , 
                                            <code>const + name</code>
                                            &nbsp;and 
                                            <code>fn + name</code>
                                            &nbsp;for some things, but decides to invert the syntax for struct: 
                                            <code>const + name + = + struct</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            But instantiation is done like this:
						</p>
<pre><code class="language-zig" data-lang="zig">var player: Player = .{
&nbsp;&nbsp;&nbsp;&nbsp;.pos = rl.Vector2.init(0, 0),
&nbsp;&nbsp;&nbsp;&nbsp;.aceleracao = 100,
&nbsp;&nbsp;&nbsp;&nbsp;.vel_max = 4,
&nbsp;&nbsp;&nbsp;&nbsp;.sprite = player_sprite,
};
</code></pre>
						<ul>
							<li>
								<p>
                                    I don't like how instantiation uses 
                                    <code>.</code>
                                    &nbsp;in front of the names.
								</p>
								<ul>
									<li>
										<p>
                                            I always forget to put them because it's just another small rule.
										</p>
									</li>
									<li>
										<p>
                                            Maybe there is an argument about this, putting structs in a family similar to enums, but still it's annoying the difference between field definition and field access.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        There are a zillion ways to instantiate an object
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Many of these ways result in bad behavior.
						</p>
					</li>
					<li>
						<p>
                            This is described in the Structs section.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Error handling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Tiring
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>try</code>
                            &nbsp;ends up being used in many places, so all allocation operations use 
                            <code>try</code>
                            , since they can return out-of-memory.
						</p>
					</li>
					<li>
						<p>
                            Frequent use of error handling increases the line length to be written, because I always have to:
						</p>
						<ol>
							<li>
								<p>
                                    With try
								</p>
								<ul>
									<li>
										<p>
                                            Use 
                                            <code>try</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Write the huge function name coming from some package.
										</p>
									</li>
									<li>
										<p>
                                            Pass the allocator as a function parameter.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Use catch.
								</p>
								<ul>
									<li>
										<p>
                                            Write the huge function name coming from some package.
										</p>
									</li>
									<li>
										<p>
                                            Pass the allocator as a function parameter.
										</p>
									</li>
									<li>
										<p>
                                            Use a catch with a huge syntax while defining what to do in case of error.
										</p>
									</li>
									<li>
										<p>
                                            Considering this results in the program not crashing: I have to deal with all local memory deallocations using 
                                            <code>errdefer</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            Maybe in Go/Odin it's ok, idk, maybe it's tiring there too.
						</p>
						<ul>
							<li>
								<p>
                                    Though in Go or Odin errors seem more &quot;soft&quot;, since they are just values, but in Zig it's much more &quot;collapsing&quot; and rigid, always feeling like asserts.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            It's necessary that I watch if the function return has 
                            <code>!</code>
                            &nbsp;in Zig.
						</p>
						<ul>
							<li>
								<p>
                                    In Go or Odin I must watch if it's a double return, so the second return can be an error.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Using try everywhere is basically making an assert, but MUCH more confusing
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Under these conditions, 
                            <code>try</code>
                            &nbsp;doesn't actually provide error handling. The 
                            <code>catch</code>
                            &nbsp;provides error handling, in my opinion.
						</p>
					</li>
					<li>
						<p>
                            From what I see, 
                            <code>try</code>
                            &nbsp;is simply annoying.
						</p>
					</li>
					<li>
						<p>
                            Suppose what happens in Godot:
						</p>
						<ul>
							<li>
								<p>
                                    I try an operation that can return an object or null.
								</p>
								<ul>
									<li>
										<p>
                                            If it returns the object, OK.
										</p>
									</li>
									<li>
										<p>
                                            If it returns null, then I may:
										</p>
										<ol>
											<li>
												<p>
                                                    Assert if the object is null, where it should never be null.
												</p>
											</li>
											<li>
												<p>
                                                    Crash the code when trying to access some property or method of that object while it's null.
												</p>
											</li>
											<li>
												<p>
                                                    Check if the object is null, clearly deal with the consequences, returning from the function or assigning a default value to the object.
												</p>
											</li>
										</ol>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    So my options are absolutely clear.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            THO, in Zig I feel there is a fourth option:
                            <br>
                            4. Automatically return the function and propagate that error to a higher function.
                            <br>
                            - Maybe that error is interpreted nicely in the upper functions, which is unlikely.
                            <br>
                            - Maybe that error simply keeps being propagated infinitely up to the main loop, which stops execution by forcing the main function to return with an error code.
                            <br>
                            - That is what happens in the vast majority of cases, since there's simply so much error handling happening in Zig, that 90% of them are 
                            <code>try</code>
                            s, out of laziness.
                            <br>
                            - In that case, it's basically an assert, but without guarantees that it will actually &quot;assert&quot; and stop the code. You need to traverse the whole call stack to find where error handling actually happens.
						</p>
					</li>
					<li>
						<p>
                            <code>try</code>
                            &nbsp;is: &quot;I don't want to deal with this error, I will pass the responsibility to whoever receives my return&quot;.
						</p>
						<ul>
							<li>
								<p>
                                    As mentioned, 
                                    <code>try</code>
                                    &nbsp;is just a shortcut for 
                                    <code>x catch |err| return err</code>
                                    , which describes exactly what I said, which I find confusing to work with.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                The std is terrible to understand
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250330091722.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>ArrayList</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It's a function that returns a type.
								</p>
							</li>
							<li>
								<p>
                                    Calling 
                                    <code>ArrayList</code>
                                    &nbsp;is nothing more than calling 
                                    <code>ArrayListAligned</code>
                                    , but without alignment.
								</p>
								<ul>
									<li>
										<p>
                                            Reflect on that....
										</p>
									</li>
									<li>
										<p>
                                            I'll have to deal with the concept of Alignment, without using any Alignment....
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>ArrayListAligned</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    It's a function that returns a type.
								</p>
							</li>
							<li>
								<p>
                                    It's a public function that returns a type.
								</p>
								<ul>
									<li>
										<p>
                                            It first receives a 
                                            <code>type</code>
                                            &nbsp;T as a parameter and alignment information.
										</p>
									</li>
									<li>
										<p>
                                            It receives a 
											<strong>
                                                comptime
											</strong>
                                            &nbsp;alignment, which is a 
                                            <code>?u29</code>
                                            , that is, 
                                            <code>null</code>
                                            &nbsp;or a 
                                            <code>u29</code>
                                            &nbsp;(29 bytes).
										</p>
										<ul>
											<li>
												<p>
                                                    Why is 
                                                    <code>comptime</code>
                                                    &nbsp;
													<em>
                                                        before
													</em>
                                                    &nbsp;the parameter name? I find that confusing. I prefer something like 
                                                    <code>alignment: comptime ?u29</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Then the logic: if 
                                    <code>alignment</code>
                                    &nbsp;is not null and the alignment equals T's alignment, then call 
                                    <code>ArrayListAligned</code>
                                    &nbsp;again, but this time with alignment equal to null.
								</p>
							</li>
							<li>
								<p>
                                    Then it finally returns a struct containing the type I want to define.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            type 
                            <code>ArrayListAligned(T, alignment)</code>
						</p>
						<ul>
							<li>
								<p>
                                    Has 3 fields with no default value.
								</p>
							</li>
							<li>
								<p>
                                    A 
                                    <code>pub const Slice</code>
                                    &nbsp;that is not accessible outside the struct.
								</p>
								<ul>
									<li>
										<p>
                                            I really have no idea why this field is not accessible.
										</p>
									</li>
									<li>
										<p>
                                            The LSP doesn't give autocomplete and when trying to access ignoring the LSP I receive an error saying that this field doesn't exist, it's really strange.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    A pub fn that returns a type 
                                    <code>SentinelSlice(s)</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    A pub fn that returns a type, where this type is 
                                    <code>ArrayListAligned</code>
                                    &nbsp;itself, that is, a &quot;constructor&quot; function.
								</p>
								<ul>
									<li>
										<p>
                                            This returns the default values of each of the struct fields.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If the 
                            <code>init</code>
                            &nbsp;(constructor) of 
                            <code>ArrayListAligned</code>
                            &nbsp;only does this, why weren't these default values already defined in the struct, instead of needing a constructor?
						</p>
						<ul>
							<li>
								<p>
                                    It sounds like something done only by convention, but at the same time there were moments where this is not necessary or possible:
								</p>
								<ul>
									<li>
										<p>
                                            <img src="assets/image_20250330093021.png" width="500" >
                                            ,
										</p>
									</li>
									<li>
										<p>
                                            DebugAllocator is ultra common to be used, it has a total of 863 lines of code, with 6 fields in the struct.
										</p>
										<ul>
											<li>
												<p>
                                                    It DOES have a 
                                                    <code>deinit()</code>
                                                    , but does not have an 
                                                    <code>init()</code>
                                                    .
												</p>
											</li>
											<li>
												<p>
													<strong>
                                                        THO
													</strong>
                                                    Fun Fact! Reading the comment at the top of the function, it describes that 
                                                    <code>DebugAllocator</code>
                                                    &nbsp;does have an init (lol).
												</p>
												<ul>
													<li>
														<p>
                                                            If you look well at the screenshot, 
                                                            <code>init</code>
                                                            &nbsp;is actually a 
                                                            <code>pub const init: Self = .{}</code>
                                                            .
														</p>
													</li>
													<li>
														<p>
                                                            .................bro what a mess.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Anyway, the way normally used is:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>var debugAllocator = std.heap.DebugAllocator(.{}){};</code>
												</p>
											</li>
											<li>
												<p>
                                                    or 
                                                    <code>var debugAllocator = std.heap.DebugAllocator(.{}).init;</code>
                                                    , if you want to use Zig's &quot;convention&quot;.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The annoying thing is that trying to follow a pattern in Zig always produces these weird things, because of dealing with anonymous structs without LSP.
						</p>
					</li>
					<li>
						<p>
                            Much of the complexity is due to OOP; methods are really a pain.
						</p>
					</li>
					<li>
						<p>
                            All packages I've encountered are written in OOP, using methods for everything. It's simply mega confusing.
						</p>
					</li>
					<li>
						<p>
                            In the end, I never know when I should initialize the struct with default values using anonymous structs, or if I should call some init function that assigns default parameters to the anonymous struct.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                String manipulation is unpleasant
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I find dealing with low-level memory fun. The theory is very interesting and I like having control over these things.
				</p>
			</li>
			<li>
				<p>
                    BUT, I feel Zig makes the whole process a pain, because of how the tools are provided.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250330094107.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            In this small segment, it was necessary to use:
						</p>
						<ul>
							<li>
								<p>
                                    String comparison.
								</p>
<pre><code class="language-zig" data-lang="zig">if (std.mem.eql(u8, info_tileset.get("identifier").?.string, "Internal_Icons")) continue;
</code></pre>
								<ul>
									<li>
										<p>
                                            I mean, wtf, it sounds absurd not being able to do:
										</p>
<pre><code class="language-zig" data-lang="zig">if (u8, info_tileset.get("identifier").?.string == "Internal_Icons") continue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
										<ul>
											<li>
												<p>
                                                    In Odin it's possible to do that.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    String concatenation:
								</p>
<pre><code class="language-zig" data-lang="zig">const pathCompleto: [:0]const u8 = try std.fmt.allocPrintZ(allocator, "{s}{s}", .{cwd, path});
defer allocator.free(pathCompleto);
</code></pre>
								<ul>
									<li>
										<p>
                                            <code>try</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Obviously dealing with error handling
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>std.fmt.allocPrintZ</code>
										</p>
										<ul>
											<li>
												<p>
                                                    What a crappy syntax is that?
												</p>
											</li>
											<li>
												<p>
                                                    I have to access the standard library, the fmt package and use 
                                                    <code>allocPrintZ</code>
                                                    .
												</p>
												<ul>
													<li>
														<p>
                                                            I can't even use 
                                                            <code>allocPrint</code>
                                                            , since I need the string to be null terminated.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>allocator</code>
										</p>
										<ul>
											<li>
												<p>
                                                    I have to pass the allocator everywhere.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>"{s}{s}"</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Pass the string format, including 
                                                    <code>s</code>
                                                    &nbsp;to ensure it is interpreted as a string (as if that wouldn't already be obvious in this case).
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>.{cwd, path}</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Anonymous struct without names (I find that very confusing).
												</p>
												<ul>
													<li>
														<p>
                                                            Anonymous structs are very strange.
														</p>
													</li>
													<li>
														<p>
                                                            Sometimes I interpret them as hashmaps, but in this case I could interpret as an array, or hashmap with unnamed keys.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    Despite the confusion with the struct, this part is OK.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>free</code>
										</p>
										<ul>
											<li>
												<p>
                                                    I have to deallocate the memory.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Damn, it's a lot.
										</p>
									</li>
									<li>
										<p>
                                            This could be simplified a lot.
										</p>
										<ul>
											<li>
												<p>
                                                    The reason it's so long is because function 
                                                    <code>allocPrintZ</code>
                                                    &nbsp;or 
                                                    <code>allocPrint</code>
                                                    &nbsp;returns 
                                                    <code>[:0]u8</code>
                                                    , and not 
                                                    <code>[:0]const u8</code>
                                                    .
												</p>
											</li>
											<li>
												<p>
                                                    I believe if there were a function that returned 
                                                    <code>[:0]const u8</code>
                                                    , then there would be no need to use an allocator as a function parameter, nor to use free after creating the string.
												</p>
												<ul>
													<li>
														<p>
                                                            Memory could be created inside the function, something like that, I don't understand memory well enough, but I believe it's possible to minimize problems by returning a string literal.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Print is annoying
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I have to use 
                    <code>\n</code>
                    &nbsp;every time, which I find annoying.
				</p>
				<ul>
					<li>
						<p>
                            There was never a moment when I didn't need 
                            <code>\n</code>
                            &nbsp;in print, never.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ifs and loops use 
                <code>( )</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's quite annoying to have to write 
                    <code>( )</code>
                    &nbsp;around the expressions of ifs and loops.
				</p>
				<ul>
					<li>
						<p>
                            I always forget and have to go back to fix it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">if (valor != 5) {
&nbsp;&nbsp;&nbsp;&nbsp;return;
}

for (meu_array.items) |item| {
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{any}", .{item});
}

</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Unused parameters being an error is annoying
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Sometimes I just want to test something and see if it works, but every time I have to use 
                    <code>_ = a;</code>
                    &nbsp;or 
                    <code>_ = .{a, b};</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This is annoying after a while.
				</p>
			</li>
			<li>
				<p>
                    It also makes the code cluttered:
				</p>
				<ul>
					<li>
						<p>
                            There will be extra lines of code that do absolutely nothing, they just take up space.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It also makes the code unsafe:
				</p>
				<ul>
					<li>
						<p>
                            I would prefer it to be a warning, but this became NOTHING.
						</p>
					</li>
					<li>
						<p>
                            All information about the problem is lost, once I'm completely ignoring the problem.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In general, I don't like how Zig handles this; it's bad.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                The 
                <code>using</code>
                &nbsp;keyword does nothing and will be removed
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This is not a big problem, since I don't find 
                    <code>using</code>
                    &nbsp;very welcome, but it would still be ok to have this option for helper functions.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Constant breaking changes that make using external libs a headache
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Many libs use incompatible versions among themselves.
				</p>
			</li>
			<li>
				<p>
                    Many libs use nightly versions, on master; others use older versions because they're not being updated.
				</p>
			</li>
			<li>
				<p>
                    Many libs even use dev, unstable versions.
				</p>
			</li>
			<li>
				<p>
                    The problem happens when there are changes in the build system from one version to another, so that it's not possible to use the lib at all unless you download its source code and edit it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                The build.zig and build.zig.zon are extremely confusing and inconvenient
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The LSP doesn't work if all dependencies are not correct in build.zig and build.zig.zon.
				</p>
				<ul>
					<li>
						<p>
                            That's a pain for new projects.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    I tried to learn about build.zig and despite having understood how to configure what I wanted, it's simply very confusing still. It's not friendly for beginners.
				</p>
			</li>
			<li>
				<p>
                    Maybe the configurations are useful when you master what's happening, but it's unpleasant to poke at those files at the beginning.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Doesn't do default initialization to Zero Value
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Doing 
                    <code>const flag: bool;</code>
                    &nbsp;gives the error &quot;Variables must be initialized&quot;.
				</p>
				<ul>
					<li>
						<p>
                            This happens for everything.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Both Odin and GDScript do zero initialization for all types.
				</p>
				<ul>
					<li>
						<p>
                            This is very nice, saves typing and makes the code safer by preventing trying to access an uninitialized property.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Doesn't have a context allocator / default allocator
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This can be seen as an advantage, but also as a disadvantage.
				</p>
			</li>
			<li>
				<p>
                    The disadvantage I see is having to carry the allocator everywhere in the code, leaving the code very loaded, always being &quot;haunted&quot; by memory management.
				</p>
			</li>
			<li>
				<p>
                    The advantage is the reinforcement that the only way to allocate something is by passing the allocator as a function parameter.
				</p>
				<ul>
					<li>
						<p>
                            EXCEPT, that is false. It's possible to create allocators inside functions however you want. The above sentence is just a convention adopted by Zig.
						</p>
					</li>
					<li>
						<p>
                            It's a good convention, but still just a convention.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Anyway, I miss Odin's 
                    <code>context</code>
                    , which saves me the work of dealing with allocators, but allows overriding the allocator used in the function if I want.
				</p>
				<ul>
					<li>
						<p>
                            <code>meu_procedure :: proc(allocator := context.allocator) {}</code>
						</p>
						<ul>
							<li>
								<p>
                                    That's the convention in Odin; the default is the context's allocator, but one can use another allocator if desired.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                I find mandatory 
                <code>;</code>
                &nbsp;slightly annoying
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Odin doesn't force it and I never missed it at any time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Zig's syntax is VERY confusing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    No matter how much I use Zig, I feel like the next day I'm very confused about how the syntax works.
				</p>
			</li>
			<li>
				<p>
                    The entire std is just very confusing and the syntax is full of things I need to have memorized.
				</p>
			</li>
			<li>
				<p>
                    I reached this conclusion after trying Odin and realizing how much easier and more intuitive Odin's syntax is.
				</p>
				<ul>
					<li>
						<p>
                            I have considerably fewer doubts writing Odin, although I barely read Odin's documentation, while I devoured articles and articles about Zig.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It sounds strange how unintuitive Zig can be syntactically.
				</p>
			</li>
			<li>
				<p>
                    I feel Zig has some &quot;fussy bits&quot; that make the syntax one of the most confusing I've used.
				</p>
				<ul>
					<li>
						<p>
                            Rust, Odin, Swift, Jai, etc.; are all syntactically more intuitive than Zig.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="positive-points" >
    Positive points
</h3>
<ul>
	<li>
		<p>
			<strong>
                The return of a JSON parse is ok
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The syntax below is ok:
				</p>
<pre><code class="language-zig" data-lang="zig">const defs = ldtkParsed.get("defs").?.object;
const info_tilesets = defs.get("tilesets").?.array;
const path = info_tileset.get("relPath").?.string;
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Unions for Null Safety and Error Handling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cool.
				</p>
			</li>
			<li>
				<p>
                    <code>?</code>
                    &nbsp;and 
                    <code>!</code>
                    &nbsp;are ok.
				</p>
			</li>
			<li>
				<p>
                    They are aspects of Functional Programming.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Pointers are nice
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The use of 
                    <code>.*</code>
                    &nbsp;to dereference is pretty nice, I liked it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                <code>pub fn</code>
                &nbsp;is nice and simple
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Clarity about what is built-in using 
                <code>@</code>
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                <code>defer</code>
                &nbsp;working in scope is nice
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    I have big doubts about this, though.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Go
					</em>
                    &nbsp;makes 
                    <code>defer</code>
                    &nbsp;work at the end of the current function scope, which may be better for error handling.
				</p>
				<ul>
					<li>
						<p>
                            I found it strange to use 
                            <code>defer</code>
                            &nbsp;inside 
                            <code>if</code>
                            s, as it makes the call happen at the end of the 
                            <code>if</code>
                            &nbsp;scope, which is odd and impractical.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    On the other hand, it's nice to create blocks with internal defers:
				</p>
<pre><code class="language-zig" data-lang="zig">&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//something here
&nbsp;&nbsp;&nbsp;&nbsp;}
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Many things are expressions, instead of only statements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I'm unsure whether I like this so far.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const s = 'a';
const valor: i32 = switch (s) {
&nbsp;&nbsp;&nbsp;&nbsp;'a' =&gt; 1,
&nbsp;&nbsp;&nbsp;&nbsp;'b' =&gt; 20,
&nbsp;&nbsp;&nbsp;&nbsp;'c' =&gt; 5,
&nbsp;&nbsp;&nbsp;&nbsp; _&nbsp;&nbsp;=&gt; 0,
};
</code></pre>
	</li>
</ul>
<h2
	id="about" >
    About
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://learnxinyminutes.com/zig/" 
				class="external-link" 
				target="_blank" >
                LearnXinYminutes
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Good guide, but very concise.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/" 
				class="external-link" 
				target="_blank" >
                Documentation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/std/" 
				class="external-link" 
				target="_blank" >
                Documentation - std lib
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/" 
				class="external-link" 
				target="_blank" >
                Tutorial articles
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=7D__mR1nA2c&list=PLtB7CL7EG7pCw7Xy1SQC53Gl8pI7aDg9t&index=22" 
				class="external-link" 
				target="_blank" >
                Guide
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://zig.guide/getting-started/installation" 
				class="external-link" 
				target="_blank" >
                ZigGuide
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's a confusing and not very explanatory guide, very concise and technical.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://codeberg.org/ziglings/exercises" 
				class="external-link" 
				target="_blank" >
                Exercises
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Primeagen solving the exercises 
					<a
						href="https://www.youtube.com/watch?v=OPuztQfM3Fg" 
						class="external-link" 
						target="_blank" >
                        (pt1)
					</a>
                    &nbsp;/ 
					<a
						href="https://www.youtube.com/watch?v=mCzCFW3QyZ4" 
						class="external-link" 
						target="_blank" >
                        (pt2)
					</a>
                    &nbsp;/ 
					<a
						href="https://www.youtube.com/watch?v=EVzvvJjGJ6U" 
						class="external-link" 
						target="_blank" >
                        (pt3)
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    It's an okay place to test some things, but many times I felt lazy to do the exercise, because the statement is looong and Dora the Explorer style, while other times it's not exactly clear what should be done, or why that was done, or what other options exist.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="style-guidelines" >
    Style Guidelines
</h5>
<ul>
	<li>
		<p>
            snake_case
		</p>
		<ul>
			<li>
				<p>
                    variables.
				</p>
			</li>
			<li>
				<p>
                    namespace.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            camelCase
		</p>
		<ul>
			<li>
				<p>
                    functions.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            PascalCase
		</p>
		<ul>
			<li>
				<p>
                    types.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="http-requests-example" >
    HTTP Requests Example
</h5>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const http = @import("zig-http/http");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = std.heap.page_allocator;

&nbsp;&nbsp;&nbsp;&nbsp;// Create the HTTP server
&nbsp;&nbsp;&nbsp;&nbsp;var server = try http.Server.init(allocator, "0.0.0.0", 8080, handler);

&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("Server running at http://localhost:8080\n", .{});

&nbsp;&nbsp;&nbsp;&nbsp;// Start the server
&nbsp;&nbsp;&nbsp;&nbsp;try server.listen();
}

// Function that handles HTTP requests
fn handler(req: *http.Request, res: *http.Response) !void {
&nbsp;&nbsp;&nbsp;&nbsp;// Process only GET requests
&nbsp;&nbsp;&nbsp;&nbsp;if (req.method != .Get) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.status = .MethodNotAllowed;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try res.send("Method not allowed");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Get the "name" parameter from the URL
&nbsp;&nbsp;&nbsp;&nbsp;const name = req.getQueryParam("name") orelse "world";

&nbsp;&nbsp;&nbsp;&nbsp;// Create the response message
&nbsp;&nbsp;&nbsp;&nbsp;const message = try std.fmt.allocPrint(std.heap.page_allocator, "Hello, {}!", .{name});

&nbsp;&nbsp;&nbsp;&nbsp;// Set status and response body
&nbsp;&nbsp;&nbsp;&nbsp;res.status = .Ok;
&nbsp;&nbsp;&nbsp;&nbsp;try res.send(message);

&nbsp;&nbsp;&nbsp;&nbsp;// Free the memory allocated for the message
&nbsp;&nbsp;&nbsp;&nbsp;std.heap.page_allocator.free(message);
}
</code></pre>
<h2
	id="installation" >
    Installation
</h2>
<h5
	id="version" >
    Version
</h5>
<ul>
	<li>
		<p>
            Use Scoop or download the standalone executable.
		</p>
		<ul>
			<li>
				<p>
                    I placed the downloaded folder in 
                    <code>C:\Users\caior\apps</code>
                    &nbsp;and added it to the user path.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For dev versions, often it only works via the executable.
		</p>
		<ul>
			<li>
				<p>
                    The exercises repo and the gamedev examples repo only use the dev version, so it makes more sense to use master right away.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>I installed via 
            <code>winget</code>
            </s>.
		</p>
	</li>
</ul>
<h5
	id="vscode" >
    VSCode
</h5>
<ul>
	<li>
		<p>
            Installing Zig, the Zig extension in VSCode and the LSP in VSCode was smooth, no problem at all.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250314185225.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Apparently you have to do this for the debugger to work in vscode.
				</p>
			</li>
			<li>
				<p>
                    (2025-03-15) I did this, the same way as in the image.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="build" >
    Build
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Zig-Build-System" 
				class="external-link" 
				target="_blank" >
                Build
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zig.guide/build-system/build-modes" 
				class="external-link" 
				target="_blank" >
                Build
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            I found the 
            <code>build.zig</code>
            &nbsp;file very useful, making it clear what will happen when building the project.
		</p>
	</li>
	<li>
		<p>
            <code>zig build -h</code>
            &nbsp;shows the options created by the 
            <code>build.zig</code>
            &nbsp;file.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=HGlTuDmotnU" 
				class="external-link" 
				target="_blank" >
                Some brief explanations of RayLib in Zig with and without bindings
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    One of the shown options is to use RayLib with 
                    <code>@cImport</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="flags" >
    flags
</h5>
<ul>
	<li>
		<p>
            <code>--prefix</code>
            &nbsp;/ 
            <code>-p</code>
		</p>
	</li>
</ul>
<h5
	id="-zig-cache" >
    .zig-cache
</h5>
<ul>
	<li>
		<p>
            Contains files that will make subsequent builds faster
		</p>
	</li>
	<li>
		<p>
            These files are not intended to be checked into source-control and this directory can be completely deleted at any time with no consequences.
		</p>
	</li>
</ul>
<h5
	id="build-zig-zon" >
    build.zig.zon
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.html" 
				class="internal-link" 
				target="_self" >
                Documentation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            In my understanding, the file contains the pathing of dependencies to be downloaded in order to build the project.
		</p>
	</li>
	<li>
		<p>
            When running
		</p>
	</li>
</ul>
<h5
	id="zig-run" >
    zig run
</h5>
<ul>
	<li>
		<p>
            Compiles the specified source code directly into a temporary binary.
		</p>
	</li>
	<li>
		<p>
            Runs the binary immediately after compilation.
		</p>
	</li>
	<li>
		<p>
            Does not use the build system, that is, it doesn't process the configurations defined there.
		</p>
	</li>
</ul>
<h4
	id="resolving-version-conflicts" >
    Resolving version conflicts
</h4>
<h5
	id="comparisons" >
    Comparisons
</h5>
<ul>
	<li>
		<p>
            0.13.0 -&gt; 0.14.0
		</p>
		<ul>
			<li>
				<p>
                    Introduces problems in the 
                    <code>.name</code>
                    &nbsp;described in the 
                    <code>build.zig.zon</code>
                    &nbsp;file, so that names must be in the format 
                    <code>.my_name</code>
                    , I think.
				</p>
			</li>
			<li>
				<p>
                    Although this can be changed in the project itself, all dependencies end up having this problem as well.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                FunFacts!!
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Some dependencies use a 0.14.0-dev version, so 0.13.0 is incompatible and 0.14.0 introduces problems with 
                    <code>.name</code>
                    Coooool! =)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="running-demos-on-different-versions" >
    Running demos on different versions
</h5>
<ul>
	<li>
		<p>
            Remember to use 
            <code>.</code>
            &nbsp;before the Zig path.
		</p>
	</li>
	<li>
		<p>
            <code>."C:\Users\caior\apps\zig-windows-x86_64-0.14.0\zig.exe" build run</code>
		</p>
	</li>
	<li>
		<p>
            <code>."C:\Users\caior\apps\zig-windows-x86_64-0.13.0\zig.exe" build run</code>
		</p>
	</li>
	<li>
		<p>
            <code>."C:\Users\caior\apps\zig-windows-x86_64-0.12.1\zig.exe" build run</code>
		</p>
	</li>
</ul>
<h2
	id="basics" >
    Basics
</h2>
<h5
	id="operators" >
    Operators
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Operators" 
				class="external-link" 
				target="_blank" >
                List
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="keywords" >
    Keywords
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Keyword-Reference" 
				class="external-link" 
				target="_blank" >
                Reference
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="access-modifiers" >
    Access Modifiers
</h5>
<ul>
	<li>
		<p>
            Chat-gpt: &quot;
			<strong>
                Default:
			</strong>
            &nbsp;There is no native visibility control.&quot;
		</p>
		<ul>
			<li>
				<p>
                    <code>pub</code>
                    &nbsp;is related to code organization and modularity, but 
					<strong>
                        is not tied to dynamic runtime security rules
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    Zig uses modular organization to control access between different parts of the code.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Public (
                        <code>pub</code>
                        )
					</strong>
                    : Used to expose functions, types or variables from a module to other modules.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Private (default)
					</strong>
                    : Items defined without 
                    <code>pub</code>
                    &nbsp;are private to the current scope (file or block).&quot;
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="comments-print-formatting" >
    Comments, Print, Formatting
</h3>
<h5
	id="comments" >
    Comments
</h5>
<pre><code class="language-zig" data-lang="zig">//! Top-level documentation.

/// Documentation comment.

// Simple comment.
</code></pre>
<h5
	id="suppress-warnings" >
    Suppress Warnings
</h5>
<pre><code class="language-zig" data-lang="zig">//suppress unused constant compile error&nbsp;&nbsp;&nbsp;&nbsp;
_ = .{ a, b, c, d };
</code></pre>
<h5
	id="print" >
    Print
</h5>
<ul>
	<li>
		<p>
            No automatic 
            <code>\n</code>
            .
		</p>
	</li>
	<li>
		<p>
            &quot;Prints to stderr (it's a shortcut based on 
            <code>std.io.getStdErr()</code>
            )&quot;.
		</p>
	</li>
	<li>
		<p>
            Part of the standard library (
            <code>std</code>
            ).
		</p>
	</li>
	<li>
		<p>
            Uses 
            <code>std.debug.print()</code>
            .
		</p>
	</li>
	<li>
		<p>
            Writes directly to standard output (
            <code>stdout</code>
            ).
		</p>
	</li>
	<li>
		<p>
            Accepts string formatting, similar to 
            <code>printf</code>
            &nbsp;in C.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const print = std.debug.print

pub fn main() void {
&nbsp;&nbsp;&nbsp;&nbsp;print("Value: {}\n", .{42});
}
</code></pre>
<h5
	id="info" >
    Info
</h5>
<ul>
	<li>
		<p>
            With automatic 
            <code>\n</code>
            .
		</p>
	</li>
	<li>
		<p>
            Part of the 
            <code>std.log</code>
            &nbsp;module.
		</p>
	</li>
	<li>
		<p>
            Uses 
            <code>std.log.info()</code>
            .
		</p>
	</li>
	<li>
		<p>
            Unlike 
            <code>print</code>
            , 
            <code>info</code>
            &nbsp;can be filtered by log levels (like 
            <code>debug</code>
            , 
            <code>warn</code>
            , 
            <code>err</code>
            ).
		</p>
	</li>
	<li>
		<p>
            Output can be redirected or configured depending on the compiler and runtime environment.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() void {
&nbsp;&nbsp;&nbsp;&nbsp;std.log.info("Value: {}", .{42});
}
</code></pre>
<h5
	id="formatting" >
    Formatting
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/std/#std.fmt" 
				class="external-link" 
				target="_blank" >
                <code>std.fmt</code>
			</a>
            &nbsp;provides ways to format data to and from strings.
		</p>
	</li>
	<li>
		<p>
            A basic example of creating a formatted string. The format string must be compile-time known. The 
            <code>d</code>
            &nbsp;here denotes that we want a decimal number.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;
const eql = std.mem.eql;
const test_allocator = std.testing.allocator;

test "fmt" {
&nbsp;&nbsp;&nbsp;&nbsp;const string = try std.fmt.allocPrint(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{d} + {d} = {d}",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.{ 9, 10, 19 },
&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;defer test_allocator.free(string);

&nbsp;&nbsp;&nbsp;&nbsp;try expect(eql(u8, string, "9 + 10 = 19"));
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                std.debug.print
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;it writes to stderr and is protected by a mutex.&quot;
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;
const eql = std.mem.eql;
test "hello world" {
&nbsp;&nbsp;&nbsp;&nbsp;const out_file = std.io.getStdOut();
&nbsp;&nbsp;&nbsp;&nbsp;try out_file.writer().print(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Hello, {s}!\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.{"World"},
&nbsp;&nbsp;&nbsp;&nbsp;);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Format Specifiers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>{s}</code>
                    : strings.
				</p>
			</li>
			<li>
				<p>
                    <code>{d}</code>
                    : decimal.
				</p>
				<ul>
					<li>
						<p>
                            <code>{d:.2}</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>{c}</code>
                    : ascii character.
				</p>
			</li>
			<li>
				<p>
                    <code>{*}</code>
                    : pointer formatting, printing the address rather than the value.
				</p>
			</li>
			<li>
				<p>
                    <code>{any}</code>
                    : default formatting.
				</p>
			</li>
			<li>
				<p>
                    <code>{e}</code>
                    : floats in scientific notation.
				</p>
			</li>
			<li>
				<p>
                    <code>{b}</code>
                    : binary.
				</p>
			</li>
			<li>
				<p>
                    <code>{o}</code>
                    : octal.
				</p>
			</li>
			<li>
				<p>
                    etc.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="functions" >
    Functions
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Functions" 
				class="external-link" 
				target="_blank" >
                Functions
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            All function arguments are immutable - if a copy is desired the user must explicitly make one.
		</p>
	</li>
	<li>
		<p>
            Unlike variables, which are snake_case, functions are camelCase.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">fn addFive(x: u32) u32 {
&nbsp;&nbsp;&nbsp;&nbsp;return x + 5;
}

test "function" {
&nbsp;&nbsp;&nbsp;&nbsp;const y = addFive(0);
}
</code></pre>
<h5
	id="built-in-functions" >
    Built-in Functions
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Builtin-Functions" 
				class="external-link" 
				target="_blank" >
                Built-in Functions
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="control-flow-if-while-for-switch-labelled-iterators" >
    Control Flow (if, while, for, switch, labelled, iterators)
</h3>
<h5
	id="if" >
    If
</h5>
<pre><code class="language-zig" data-lang="zig">const a = true;
var x: u16 = 0;
if (a) {
&nbsp;&nbsp;&nbsp;&nbsp;x += 1;
} else {
&nbsp;&nbsp;&nbsp;&nbsp;x += 2;
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const a = true;
var x: u16 = 0;
x += if (a) 1 else 2;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                &quot;If it exists&quot;
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">// Shortcut for "if (x) x else 0"
var value = x orelse 0;
</code></pre>
<pre><code class="language-zig" data-lang="zig">// Get a pointer to the value (if it exists).
if (a) |*value| { value.* += 1; }
</code></pre>
	</li>
</ul>
<h5
	id="while" >
    While
</h5>
<pre><code class="language-zig" data-lang="zig">var i: u8 = 2;&nbsp;&nbsp;&nbsp;&nbsp;
while (i &lt; 100) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;i *= 2;&nbsp;&nbsp;&nbsp;&nbsp;
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">// Simple "while" loop.
while (i &lt; 10) { i += 1; }

// While loop with a "continue expression"
// (expression executed as the last expression of the loop).
while (i &lt; 10) : (i += 1) { ... }
// Same, with a more complex continue expression (block of code).
while (i * j &lt; 2000) : ({ i *= 2; j *= 3; }) { ... }
</code></pre>
<pre><code class="language-zig" data-lang="zig">var sum: u8 = 0;
var i: u8 = 1;
while (i &lt;= 10) : (i += 1) {
&nbsp;&nbsp;&nbsp;&nbsp;sum += i;
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">var sum: u8 = 0;
var i: u8 = 0;
while (i &lt;= 3) : (i += 1) {
&nbsp;&nbsp;&nbsp;&nbsp;if (i == 2) continue;
&nbsp;&nbsp;&nbsp;&nbsp;sum += i;
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">var sum: u8 = 0;
var i: u8 = 0;
while (i &lt;= 3) : (i += 1) {
&nbsp;&nbsp;&nbsp;&nbsp;if (i == 2) break;
&nbsp;&nbsp;&nbsp;&nbsp;sum += i;
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Loops as Expressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Like 
                    <code>return</code>
                    , 
                    <code>break</code>
                    &nbsp;accepts a value.
				</p>
			</li>
			<li>
				<p>
                    This can be used to yield a value from a loop.
				</p>
			</li>
			<li>
				<p>
                    Loops in Zig also have an 
                    <code>else</code>
                    &nbsp;branch, which is evaluated when the loop is not exited with a 
                    <code>break</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">fn rangeHasNumber(begin: usize, end: usize, number: usize) bool {
&nbsp;&nbsp;&nbsp;&nbsp;var i = begin;
&nbsp;&nbsp;&nbsp;&nbsp;return while (i &lt; end) : (i += 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i == number) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;} else false;
}

test "while loop expression" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(rangeHasNumber(0, 10, 3));
}
</code></pre>
	</li>
</ul>
<h5
	id="for" >
    For
</h5>
<pre><code class="language-zig" data-lang="zig">// We've had to assign values to `_`, as Zig does not allow us to have unused values.
// Character literals are equivalent to integer literals
const string = [_]u8{ 'a', 'b', 'c' };

for (string, 0..) |character, index| {
&nbsp;&nbsp;&nbsp;&nbsp;_ = character;
&nbsp;&nbsp;&nbsp;&nbsp;_ = index;
}

for (string) |character| {
&nbsp;&nbsp;&nbsp;&nbsp;_ = character;
}

for (string, 0..) |_, index| {
&nbsp;&nbsp;&nbsp;&nbsp;_ = index;
}

for (string) |_| {}
</code></pre>
<pre><code class="language-zig" data-lang="zig">// To iterate over a portion of a slice, reslice.
for (items[0..1]) |value| { sum += value; }

// Loop over every item of an array (or slice).
for (items) |value| { sum += value; }

// Iterate and get pointers on values instead of copies.
for (items) |*value| { value.* += 1; }

// Iterate with an index.
for (items) |value, i| { print("val[{}] = {}\n", .{i, value}); }

// Iterate with pointer and index.
for (items) |*value, i| { print("val[{}] = {}\n", .{i, value}); value.* += 1; }
</code></pre>
<pre><code class="language-zig" data-lang="zig">// Break and continue are supported.
for (items) |value| {
&nbsp;&nbsp;&nbsp;&nbsp;if (value == 0)&nbsp;&nbsp;{ continue; }
&nbsp;&nbsp;&nbsp;&nbsp;if (value &gt;= 10) { break;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// ...
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">// For loops can also be used as expressions.
// Similar to while loops, when you break from a for loop,
// the else branch is not evaluated.
var sum: i32 = 0;
// The "for" loop has to provide a value, which will be the "else" value.
const result = for (items) |value| {
&nbsp;&nbsp;&nbsp;&nbsp;if (value != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += value.?; // "result" will be the last "sum" value.
&nbsp;&nbsp;&nbsp;&nbsp;}
} else 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Last value.
</code></pre>
<h5
	id="switch" >
    Switch
</h5>
<ul>
	<li>
		<p>
			<strong>
                Safety
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The types of all branches must coerce to the type which is being switched upon. All possible values must have an associated branch - values cannot be left out. It is exhaustive.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Zig's 
            <code>switch</code>
            &nbsp;works as both a statement and an expression.
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Statement
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "switch statement" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: i8 = 10;
&nbsp;&nbsp;&nbsp;&nbsp;switch (x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1...1 =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = -x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10, 100 =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//special considerations must be made
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//when dividing signed integers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = @divExact(x, 10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else =&gt; {},
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 1);
}
</code></pre>
			</li>
			<li>
				<p>
					<strong>
                        Expression
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "switch expression" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: i8 = 10;
&nbsp;&nbsp;&nbsp;&nbsp;x = switch (x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1...1 =&gt; -x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10, 100 =&gt; @divExact(x, 10),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else =&gt; x,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 1);
}
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Cases cannot fall through to other branches.
		</p>
	</li>
</ul>
<h5
	id="labelled" >
    Labelled
</h5>
<ul>
	<li>
		<p>
			<strong>
                Blocks
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The value of an empty block 
                    <code>{}</code>
                    &nbsp;is a value of the type 
                    <code>void</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "int-float conversion" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: i32 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;const b = @as(f32, @floatFromInt(a));
&nbsp;&nbsp;&nbsp;&nbsp;const c = @as(i32, @intFromFloat(b));
&nbsp;&nbsp;&nbsp;&nbsp;try expect(c == a);
}
</code></pre>
		<ul>
			<li>
				<p>
                    This can be seen as being equivalent to C's 
                    <code>i++</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">blk: {
&nbsp;&nbsp;&nbsp;&nbsp;const tmp = i;
&nbsp;&nbsp;&nbsp;&nbsp;i += 1;
&nbsp;&nbsp;&nbsp;&nbsp;break :blk tmp;
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Loops
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Loops can be given labels, allowing you to 
                    <code>break</code>
                    &nbsp;and 
                    <code>continue</code>
                    &nbsp;to outer loops.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">test "nested continue" {
&nbsp;&nbsp;&nbsp;&nbsp;var count: usize = 0;
&nbsp;&nbsp;&nbsp;&nbsp;outer: for ([_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }) |_| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ([_]i32{ 1, 2, 3, 4, 5 }) |_| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count += 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue :outer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(count == 8);
}
</code></pre>
	</li>
</ul>
<h5
	id="iterators" >
    Iterators
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/iterators" 
				class="external-link" 
				target="_blank" >
                Iterators
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="imports" >
    Imports
</h3>
<ul>
	<li>
		<p>
            The built-in function 
            <code>@import</code>
            &nbsp;takes in a file, and gives you a struct type based on that file.
		</p>
	</li>
	<li>
		<p>
            All declarations labelled as 
            <code>pub</code>
            &nbsp;(for public) will end up in this struct type, ready for use.
		</p>
	</li>
	<li>
		<p>
            <code>@import("std")</code>
            &nbsp;is a special case in the compiler, and gives you access to the standard library.
		</p>
	</li>
</ul>
<h2
	id="types" >
    Types
</h2>
<h3
	id="casting" >
    Casting
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Explicit-Casts" 
				class="external-link" 
				target="_blank" >
                Casting
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.lagerdata.com/articles/an-intro-to-zigs-integer-casting-for-c-programmers" 
				class="external-link" 
				target="_blank" >
                Casting
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="prtcast" >
    @prtCast
</h5>
<ul>
	<li>
		<p>
            We can use 
            <code>@ptrCast</code>
            &nbsp;to create a new variable that points to the same location but as a different type.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

const User = struct {
&nbsp;&nbsp;id: u32,
&nbsp;&nbsp;name: []const u8,
};

const Node = struct {
&nbsp;&nbsp;next: ?*Node,
};

pub fn main() !void {
&nbsp;&nbsp;var user1 = User{.id = 1, .name = "Leto"};
&nbsp;&nbsp;const node1: *Node = @ptrCast(&user1);
&nbsp;&nbsp;node1.next = null;
&nbsp;&nbsp;std.debug.print("{}\n", .{node1});
}
</code></pre>
		<ul>
			<li>
				<p>
                    This code not only compiles, but it also runs. Compiling and running are two distinct aspects we must consider. The code compiles because we told the compiler it was ok to treat the memory as a 
                    <code>*Node</code>
                    . 
                    <code>@ptrCast</code>
                    &nbsp;isn't changing the memory at runtime, it's forcing the compiler to see the memory as a 
                    <code>*Node</code>
                    . In this case, the code runs because there are some truths we can rely on that make it so the memory used to represent a 
                    <code>User</code>
                    &nbsp;can safely be used to represent a 
                    <code>Node</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex2
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

const User = struct {
&nbsp;&nbsp;id: u32,
&nbsp;&nbsp;name: []const u8,
};

const Node = struct {
&nbsp;&nbsp;next: ?*Node,
};

pub fn main() !void {
&nbsp;&nbsp;var node1 = Node{.next = null};
&nbsp;&nbsp;const user: *User = @ptrCast(&node1);

&nbsp;&nbsp;std.debug.print("Id: {d}\n", .{user.id});
&nbsp;&nbsp;std.debug.print("Name: {d}\n", .{user.name});
}
</code></pre>
		<ul>
			<li>
				<p>
                    Now we're creating a 
                    <code>Node</code>
                    &nbsp;and telling the compiler to see the underlying memory as a 
                    <code>User</code>
                    . Again, this code compiles. But what happens when we try to run it? You'll probably get the same thing I did: 
                    <code>Id: 0</code>
                    &nbsp;followed by a segfault.
				</p>
			</li>
			<li>
				<p>
                    Why does it work one way but not the other? Consider the size of a 
                    <code>Node</code>
                    &nbsp;and the size of a 
                    <code>User</code>
                    :
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
pub fn main() !void {
&nbsp;&nbsp;std.debug.print("Node: {d}&nbsp;&nbsp; User: {d}\n", .{@sizeOf(Node), @sizeOf(User)});
}
</code></pre>
		<ul>
			<li>
				<p>
                    Assuming you're on a modern platform, you'll likely see: 
                    <code>Node: 8 User: 24</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This highlights the power and 
					<strong>
                        danger
					</strong>
                    &nbsp;of 
                    <code>@ptrCast</code>
                    : it's obvious that the memory underlying a 
                    <code>Node</code>
                    &nbsp;isn't big enough to represent a whole 
                    <code>User</code>
                    , but 
                    <code>@ptrCast</code>
                    &nbsp;forces the compiler to proceed as though it can.
				</p>
			</li>
			<li>
				<p>
                    But size constraints aren't the only issue. Let's go back to our original example and add 2 more lines at the end:
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

const User = struct {
&nbsp;&nbsp;id: u32,
&nbsp;&nbsp;name: []const u8,
};

const Node = struct {
&nbsp;&nbsp;next: ?*Node,
};

pub fn main() !void {
&nbsp;&nbsp;var user1 = User{.id = 1, .name = "Leto"};
&nbsp;&nbsp;const node1: *Node = @ptrCast(&user1);
&nbsp;&nbsp;node1.next = null;

&nbsp;&nbsp;std.debug.print("{}\n", .{node1});
&nbsp;&nbsp;std.debug.print("{d}\n", .{user1.id});&nbsp;&nbsp;&nbsp;&nbsp;// added
&nbsp;&nbsp;std.debug.print("{s}\n", .{user1.name});&nbsp;&nbsp;// added
}
</code></pre>
		<ul>
			<li>
				<p>
                    The underlying memory for 
                    <code>node1</code>
                    &nbsp;is more than big enough, but the code still crashes. When we write to 
                    <code>user.id</code>
                    &nbsp;or 
                    <code>user1.name</code>
                    , the compiler enforces correctness: 
                    <code>id</code>
                    &nbsp;must be an 
                    <code>u32</code>
                    &nbsp;and 
                    <code>name</code>
                    &nbsp;must be a 
                    <code>[]const u8</code>
                    . Similarly, when we write 
                    <code>null</code>
                    &nbsp;to 
                    <code>node1.next</code>
                    , the code compiles because 
                    <code>null</code>
                    &nbsp;is a valid 
                    <code>?*Node</code>
                    . But when, at runtime, we try to interpret that 
                    <code>null</code>
                    &nbsp;as a part of a 
                    <code>User</code>
                    , the behavior becomes undefined (i.e. we'll most likely crash).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cautions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    One last thing worth pointing out is that, unless a structure is declared as 
                    <code>packed</code>
                    , Zig makes no guarantee about its memory layout.
				</p>
			</li>
			<li>
				<p>
                    In almost all cases, you should not write to memory as one type and read it as another (which is exactly what we've done throughout the post).
				</p>
			</li>
			<li>
				<p>
                    Unless the struct is 
                    <code>packed</code>
                    &nbsp;or the struct is very simple, you cannot predict how those read/writes will be interpreted by different types sharing the same memory.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="primitives" >
    Primitives
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Primitive-Types" 
				class="external-link" 
				target="_blank" >
                List
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="integers" >
    Integers
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Integers" 
				class="external-link" 
				target="_blank" >
                Integers
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const decimal_int: i32 = 98222;
const hex_int: u8 = 0xff;
const another_hex_int: u8 = 0xFF;
const octal_int: u16 = 0o755;
const binary_int: u8 = 0b11110000;
</code></pre>
<pre><code class="language-zig" data-lang="zig">const one_billion: u64 = 1_000_000_000;
const binary_mask: u64 = 0b1_1111_1111;
const permissions: u64 = 0o7_5_5;
const big_address: u64 = 0xFF80_0000_0000_0000;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Coercion / Casting
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "integer widening" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: u8 = 250;
&nbsp;&nbsp;&nbsp;&nbsp;// This is ok, providing that the new type can fit all of the values that the old type can.
&nbsp;&nbsp;&nbsp;&nbsp;const b: u16 = a;
&nbsp;&nbsp;&nbsp;&nbsp;const c: u32 = b;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(c == a);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "@intCast" {
&nbsp;&nbsp;&nbsp;&nbsp;const x: u64 = 200;
&nbsp;&nbsp;&nbsp;&nbsp;const y = @as(u8, @intCast(x));
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf(y) == u8);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Overflow
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Overflows are detectable illegal behaviour.
				</p>
			</li>
			<li>
				<p>
                    Sometimes, being able to overflow integers in a well-defined manner is a wanted behaviour.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250308105105.png" width="296" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Saturation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Values will stick to their lower and upper bounds.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">var i: u8 = 200;&nbsp;&nbsp; // "i" is an unsigned 8-bit integer (values: from 0 to 255)
i&nbsp;&nbsp;+| 100 == 255&nbsp;&nbsp; // u8: won't go higher than 255
i&nbsp;&nbsp;-| 300 == 0&nbsp;&nbsp;&nbsp;&nbsp; // unsigned, won't go lower than 0
i&nbsp;&nbsp;*| 2&nbsp;&nbsp; == 255&nbsp;&nbsp; // u8: won't go higher than 255
i &lt;&lt;| 8&nbsp;&nbsp; == 255&nbsp;&nbsp; // u8: won't go higher than 255
</code></pre>
	</li>
</ul>
<h5
	id="floats" >
    Floats
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Floats" 
				class="external-link" 
				target="_blank" >
                Floats
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const floating_point: f64 = 123.0E+77;
const another_float: f64 = 123.0;
const yet_another: f64 = 123.0e+77;

const hex_floating_point: f64 = 0x103.70p-5;
const another_hex_float: f64 = 0x103.70;
const yet_another_hex_float: f64 = 0x103.70P-5;
</code></pre>
<pre><code class="language-zig" data-lang="zig">const lightspeed: f64 = 299_792_458.000_000;
const nanosecond: f64 = 0.000_000_001;
const more_hex: f64 = 0x1234_5678.9ABC_CDEFp-10;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Coercion / Casting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Floats coerce to larger float types.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "float widening" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: f16 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;const b: f32 = a;
&nbsp;&nbsp;&nbsp;&nbsp;const c: f128 = b;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(c == @as(f128, a));
}
</code></pre>
		<ul>
			<li>
				<p>
                    <code>@floatFromInt</code>
				</p>
				<ul>
					<li>
						<p>
                            Is always safe
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>@intFromFloat</code>
				</p>
				<ul>
					<li>
						<p>
                            Is detectable illegal behaviour if the float value cannot fit in the integer destination type.
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "int-float conversion" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: i32 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;const b = @as(f32, @floatFromInt(a));
&nbsp;&nbsp;&nbsp;&nbsp;const c = @as(i32, @intFromFloat(b));
&nbsp;&nbsp;&nbsp;&nbsp;try expect(c == a);
}
</code></pre>
	</li>
</ul>
<h3
	id="generics" >
    Generics
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/generics/" 
				class="external-link" 
				target="_blank" >
                Using Generics
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="types" >
    types
</h5>
<ul>
	<li>
		<p>
            A function can return any type, not just primitives and arrays.
		</p>
	</li>
	<li>
		<p>
            <code>types</code>
            &nbsp;must always be compile-time known.
		</p>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
			<strong>
                Returns an Array (new array type)
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var arr: IntArray(3) = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;arr[0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;arr[1] = 10;
&nbsp;&nbsp;&nbsp;&nbsp;arr[2] = 100;
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{any}\n", .{arr});
}

fn IntArray(comptime length: usize) type {
&nbsp;&nbsp;&nbsp;&nbsp;return [length]i64;
}
</code></pre>
		<ul>
			<li>
				<p>
                    This code only worked because we declared 
                    <code>length</code>
                    &nbsp;as 
                    <code>comptime</code>
                    . That is, we require anyone who calls 
                    <code>IntArray</code>
                    &nbsp;to pass a compile-time known 
                    <code>length</code>
                    &nbsp;parameter.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Returns a Struct (type)
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var arr: IntArray(3) = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;arr.items[0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;arr.items[1] = 10;
&nbsp;&nbsp;&nbsp;&nbsp;arr.items[2] = 100;
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{any}\n", .{arr.items});
}

fn IntArray(comptime length: usize) type {
&nbsp;&nbsp;&nbsp;&nbsp;return struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items: [length]i64,
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Receives a type and returns a Struct (type)
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">fn List(comptime T: type) type {
&nbsp;&nbsp;&nbsp;&nbsp;return struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos: usize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items: []T,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator: Allocator,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn init(allocator: Allocator) !List(T) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return .{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.pos = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.allocator = allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.items = try allocator.alloc(T, 4),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
	</li>
</ul>
<h3
	id="tuples" >
    Tuples
</h3>
<h5
	id="tuples" >
    Tuples
</h5>
<pre><code class="language-zig" data-lang="zig">// A tuple is a list of elements, possibly of different types.

const foo = .{ "hello", true, 42 };
// foo.len == 3
</code></pre>
<h3
	id="arrays" >
    Arrays
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Arrays" 
				class="external-link" 
				target="_blank" >
                Arrays
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="array-codent-code" >
    Array (
    <code>[N]T</code>
    )
</h5>
<pre><code class="language-zig" data-lang="zig">const a = [5]u8{ 'h', 'e', 'l', 'l', 'o' };
const b = [_]u8{ 'w', 'o', 'r', 'l', 'd' };
const c: [100]u8 = [_]u8{1} ** 100;
</code></pre>
<pre><code class="language-zig" data-lang="zig">const array = [_]u8{ 'h', 'e', 'l', 'l', 'o' };
const length = array.len; // 5
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Multidimensional
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const mat4x4 = [4][4]f32{
&nbsp;&nbsp;&nbsp;&nbsp;.{ 1, 0, 0, 0 },
&nbsp;&nbsp;&nbsp;&nbsp;.{ 0, 1, 0, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;.{ 0, 0, 1, 0 },
&nbsp;&nbsp;&nbsp;&nbsp;.{ 0, 0, 0, 1 },
};

// Access the 2D array then the inner array through indexes.
try expect(mat4x4[1][1] == 1.0);

// Here we iterate with for loops.
for (mat4x4) |row, row_index| {
&nbsp;&nbsp;&nbsp;&nbsp;for (row) |cell, column_index| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
</ul>
<h5
	id="arraylist-codestd-arraylistt-code" >
    ArrayList (
    <code>std.ArrayList(T)</code>
    )
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/arraylist" 
				class="external-link" 
				target="_blank" >
                ArrayList
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Serves as a buffer that can change size.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Similarities
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>std.ArrayList(T)</code>
                    &nbsp;is similar to C++'s 
                    <code>std::vector&lt;T&gt;</code>
                    &nbsp;and Rust's 
                    <code>Vec&lt;T&gt;</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Memory
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>deinit()</code>
                    &nbsp;method frees all memory used by the ArrayList.
				</p>
			</li>
			<li>
				<p>
                    Memory can be read from and written to via its slice field - 
                    <code>.items</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;

const eql = std.mem.eql;
const ArrayList = std.ArrayList;
const test_allocator = std.testing.allocator;

test "arraylist" {
&nbsp;&nbsp;&nbsp;&nbsp;var list = ArrayList(u8).init(test_allocator);
&nbsp;&nbsp;&nbsp;&nbsp;defer list.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('H');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('e');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('l');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('l');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('o');
&nbsp;&nbsp;&nbsp;&nbsp;try list.appendSlice(" World!");

&nbsp;&nbsp;&nbsp;&nbsp;try expect(eql(u8, list.items, "Hello World!"));
}
</code></pre>
<h3
	id="vectors" >
    Vectors
</h3>
<ul>
	<li>
		<p>
            Allow efficient parallel operations using 
			<strong>
                SIMD (Single Instruction, Multiple Data)
			</strong>
            &nbsp;instructions.
		</p>
	</li>
	<li>
		<p>
            A data type that stores multiple values of the same type.
		</p>
		<ul>
			<li>
				<p>
                    Vectors can only have child types of booleans, integers, floats and pointers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Note that using explicit vectors may result in slower code if you make wrong choices. The compiler's auto-vectorization is fairly smart.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Access
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vectors are indexable.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "vector indexing" {
&nbsp;&nbsp;&nbsp;&nbsp;const x: @Vector(4, u8) = .{ 255, 0, 255, 0 };
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x[0] == 255);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Addition
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const meta = @import("std").meta;

test "vector add" {
&nbsp;&nbsp;&nbsp;&nbsp;const x: @Vector(4, f32) = .{ 1, -10, 20, -1 };
&nbsp;&nbsp;&nbsp;&nbsp;const y: @Vector(4, f32) = .{ 2, 10, 0, 1 };
&nbsp;&nbsp;&nbsp;&nbsp;const z = x + y;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(meta.eql(z, @Vector(4, f32){ 3, 0, 20, 0 }));
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const a: @Vector(4, i32) = @Vector(4, i32){ 1, 2, 3, 4 };
const b: @Vector(4, i32) = @Vector(4, i32){ 10, 20, 30, 40 };

const c = a + b; // Result: {11, 22, 33, 44}

</code></pre>
			</li>
			<li>
				<p>
					<strong>
                        Scalar Multiply
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The function 
                            <code>@splat(len, value)</code>
                            &nbsp;creates a vector filled with the same value.
						</p>
					</li>
				</ul>
<pre><code class="language-zig" data-lang="zig">const v: @Vector(4, i32) = @Vector(4, i32){ 2, 4, 6, 8 };
const scale = 2;

const result = v * @splat(4, scale); // {4, 8, 12, 16}

</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Coercion
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vectors coerce to their respective arrays.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const arr: [4]f32 = @Vector(4, f32){ 1, 2, 3, 4 };
</code></pre>
	</li>
</ul>
<h3
	id="strings" >
    Strings
</h3>
<pre><code class="language-zig" data-lang="zig">// Simple string constant.
const greetings = "hello";
// ... which is equivalent to:
const greetings: *const [5:0]u8 = "hello";
// In words: "greetings" is a constant value, a pointer to a constant array of 5 elements (8-bit unsigned integers), with an extra '0' at the end.
// The extra "0" is called a "sentinel value".

print("string: {s}\n", .{greetings});
</code></pre>
<ul>
	<li>
		<p>
            &quot;There are no strings in Zig, everything is an array of u8. It's frustrating.&quot;
		</p>
		<ul>
			<li>
				<p>
                    <code>[]const u8</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://gencmurat.com/en/posts/zig-strings/" 
				class="external-link" 
				target="_blank" >
                Tutorial =)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://medium.com/codex/solving-the-crazy-zig-literal-strings-f2f692ae500b" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.huy.rocks/everyday/01-04-2022-zig-strings-in-5-minutes" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=nTfyhJnKG7o" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            RAGE AGAINST THE DYING OF THE LIGHT..................................
		</p>
	</li>
</ul>
<h5
	id="string-literals" >
    String Literals
</h5>
<ul>
	<li>
		<p>
            The type of string literals is 
            <code>*const [N:0]u8</code>
            , where N is the length of the string.
		</p>
		<ul>
			<li>
				<p>
                    This allows string literals to coerce to sentinel-terminated slices, and sentinel-terminated many pointers.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "string literal" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf("hello") == *const [5:0]u8);
}
</code></pre>
<h5
	id="concatenation" >
    Concatenation
</h5>
<ul>
	<li>
		<p>
			<strong>
                With Alloc
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const name = "Leto";
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;const say = std.fmt.allocPrint(allocator, "Hello {s}", .{name});
&nbsp;&nbsp;&nbsp;&nbsp;defer allocator.free(say);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{s}\n", .{greeting});
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                With buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This API moves the memory management burden to the caller. If we had a longer 
                    <code>name</code>
                    , or a smaller 
                    <code>buf</code>
                    , our 
                    <code>bufPrint</code>
                    &nbsp;could return a 
                    <code>NoSpaceLeft</code>
                    &nbsp;error.
				</p>
			</li>
			<li>
				<p>
                    But there are plenty of scenarios where an application has known limits, such as a maximum name length.
				</p>
			</li>
			<li>
				<p>
                    In those cases 
                    <code>bufPrint</code>
                    &nbsp;is safer and faster.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const name = "Leto";

&nbsp;&nbsp;&nbsp;&nbsp;var buf: [100]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const greeting = try std.fmt.bufPrint(&buf, "Hello {s}", .{name});

&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{s}\n", .{greeting});
}
</code></pre>
	</li>
</ul>
<h5
	id="equal" >
    Equal
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://nofmal.github.io/zig-with-example/string-handling/#string-equal" 
				class="external-link" 
				target="_blank" >
                std.mem.eql
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const internalIcons = "Internal_Icons";
if (std.mem.eql(u8, internalIcons, "Internal_Icons")) continue;
</code></pre>
<h5
	id="contains" >
    Contains
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://nofmal.github.io/zig-with-example/string-handling/#string-contains" 
				class="external-link" 
				target="_blank" >
                Contains
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="copy" >
    Copy
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://nofmal.github.io/zig-with-example/string-handling/#string-copy" 
				class="external-link" 
				target="_blank" >
                Copy
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="c-strings" >
    C Strings
</h5>
<ul>
	<li>
		<p>
            <code>[*:0]u8</code>
            &nbsp;and 
            <code>[*:0]const u8</code>
            &nbsp;perfectly model C's strings.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "C string" {
&nbsp;&nbsp;&nbsp;&nbsp;const c_string: [*:0]const u8 = "hello";
&nbsp;&nbsp;&nbsp;&nbsp;var array: [5]u8 = undefined;

&nbsp;&nbsp;&nbsp;&nbsp;var i: usize = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while (c_string[i] != 0) : (i += 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[i] = c_string[i];
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h4
	id="sentinel-termination" >
    Sentinel Termination
</h4>
<ul>
	<li>
		<p>
            <code>[N:t]T</code>
            , 
            <code>[:t]T</code>
            , and 
            <code>[*:t]T</code>
            , where 
            <code>t</code>
            &nbsp;is a value of the child type 
            <code>T</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "sentinel termination" {
&nbsp;&nbsp;&nbsp;&nbsp;const terminated = [3:0]u8{ 3, 2, 1 };
&nbsp;&nbsp;&nbsp;&nbsp;try expect(terminated.len == 3);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@as(*const [4]u8, @ptrCast(&terminated))[3] == 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `@ptrCast` is used to perform an unsafe type conversion. This shows us that the last element of the array is followed by a 0 byte.
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Coercion
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Sentinel-terminated types coerce to their non-sentinel-terminated counterparts.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "coercion" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: [*:0]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const b: [*]u8 = a;

&nbsp;&nbsp;&nbsp;&nbsp;const c: [5:0]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const d: [5]u8 = c;

&nbsp;&nbsp;&nbsp;&nbsp;const e: [:0]f32 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const f: []f32 = e;

&nbsp;&nbsp;&nbsp;&nbsp;_ = .{ b, d, f }; // ignore unused
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Sentinel Terminated Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can be used to create a sentinel-terminated slice with the syntax 
                    <code>x[n..m:t]</code>
                    , where 
                    <code>t</code>
                    &nbsp;is the terminator value.
				</p>
			</li>
			<li>
				<p>
                    Doing this is an assertion from the programmer that the memory is terminated where it should be. Getting this wrong is detectable illegal behaviour.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "sentinel terminated slicing" {
&nbsp;&nbsp;&nbsp;&nbsp;var x = [_:0]u8{255} ** 3;
&nbsp;&nbsp;&nbsp;&nbsp;const y = x[0..3 :0];
&nbsp;&nbsp;&nbsp;&nbsp;_ = y;
}
</code></pre>
	</li>
</ul>
<h3
	id="hashmaps" >
    HashMaps
</h3>
<ul>
	<li>
		<p>
            <code>std.StringHashMap</code>
            &nbsp;and 
            <code>std.AutoHashMap</code>
            &nbsp;are just wrappers for 
            <code>std.HashMap</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    If these two do not fulfill your needs, using 
                    <code>std.HashMap</code>
                    &nbsp;directly gives you much more control.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="autohashmap" >
    AutoHashMap
</h5>
<ul>
	<li>
		<p>
            <code>std.AutoHashMap</code>
		</p>
	</li>
	<li>
		<p>
            Lets you easily create a hash map type from a key type and a value type.
		</p>
	</li>
	<li>
		<p>
            These must be initialized with an allocator.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">test "hashing" {
&nbsp;&nbsp;&nbsp;&nbsp;const Point = struct { x: i32, y: i32 };

&nbsp;&nbsp;&nbsp;&nbsp;var map = std.AutoHashMap(u32, Point).init(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_allocator,&nbsp;&nbsp;// refers to `std.testing.allocator`.
&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;defer map.deinit();

&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1525, .{ .x = 1, .y = -4 });
&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1550, .{ .x = 2, .y = -3 });
&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1575, .{ .x = 3, .y = -2 });
&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1600, .{ .x = 4, .y = -1 });

&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.count() == 4);

&nbsp;&nbsp;&nbsp;&nbsp;var sum = Point{ .x = 0, .y = 0 };
&nbsp;&nbsp;&nbsp;&nbsp;var iterator = map.iterator();

&nbsp;&nbsp;&nbsp;&nbsp;while (iterator.next()) |entry| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum.x += entry.value_ptr.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum.y += entry.value_ptr.y;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;try expect(sum.x == 10);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(sum.y == -10);
}
</code></pre>
<ul>
	<li>
		<p>
            <code>.fetchPut</code>
		</p>
		<ul>
			<li>
				<p>
                    Puts a value in the hash map, 
					<strong>
                        returning
					</strong>
                    &nbsp;a value if there was previously a value for that key.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">test "fetchPut" {
&nbsp;&nbsp;&nbsp;&nbsp;var map = std.AutoHashMap(u8, f32).init(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_allocator,
&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;defer map.deinit();

&nbsp;&nbsp;&nbsp;&nbsp;try map.put(255, 10);
&nbsp;&nbsp;&nbsp;&nbsp;const old = try map.fetchPut(255, 100);

&nbsp;&nbsp;&nbsp;&nbsp;try expect(old.?.value == 10);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.get(255).? == 100);
}
</code></pre>
	</li>
</ul>
<h5
	id="stringhashmap" >
    StringHashMap
</h5>
<ul>
	<li>
		<p>
            <code>std.StringHashMap</code>
		</p>
	</li>
	<li>
		<p>
            For when you need strings as keys.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">test "string hashmap" {
&nbsp;&nbsp;&nbsp;&nbsp;var map = std.StringHashMap(enum { cool, uncool }).init(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_allocator,
&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;defer map.deinit();

&nbsp;&nbsp;&nbsp;&nbsp;try map.put("loris", .uncool);
&nbsp;&nbsp;&nbsp;&nbsp;try map.put("me", .cool);

&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.get("me").? == .cool);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.get("loris").? == .uncool);
}
</code></pre>
<h3
	id="enums-codeenum-code" >
    Enums (
    <code>enum {}</code>
    )
</h3>
<ul>
	<li>
		<p>
            Allow you to define types with a restricted set of named values.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const Direction = enum { north, south, east, west };
</code></pre>
<pre><code class="language-zig" data-lang="zig">const Value = enum(u2) { zero, one, two };
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Default values
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Enum ordinal values start at 0. They can be accessed with the built-in function 
                    <code>@intFromEnum</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Value = enum(u2) { zero, one, two };

test "enum ordinal value" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value.zero) == 0);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value.one) == 1);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value.two) == 2);
}
</code></pre>
		<ul>
			<li>
				<p>
                    Values can be overridden, with subsequent values continuing from there.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Value2 = enum(u32) {
&nbsp;&nbsp;&nbsp;&nbsp;hundred = 100,
&nbsp;&nbsp;&nbsp;&nbsp;thousand = 1000,
&nbsp;&nbsp;&nbsp;&nbsp;million = 1000000,
&nbsp;&nbsp;&nbsp;&nbsp;next,
};

test "set enum ordinal value" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.hundred) == 100);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.thousand) == 1000);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.million) == 1000000);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.next) == 1000001);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Variables
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Enums can also have 
                    <code>var</code>
                    &nbsp;and 
                    <code>const</code>
                    &nbsp;declarations.
				</p>
			</li>
			<li>
				<p>
                    These act as namespaced globals and their values are unrelated to instances of the enum type.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Mode = enum {
&nbsp;&nbsp;&nbsp;&nbsp;var count: u32 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;on,
&nbsp;&nbsp;&nbsp;&nbsp;off,
};

test "hmm" {
&nbsp;&nbsp;&nbsp;&nbsp;Mode.count += 1;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(Mode.count == 1);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Methods
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Suit = enum {
&nbsp;&nbsp;&nbsp;&nbsp;clubs,
&nbsp;&nbsp;&nbsp;&nbsp;spades,
&nbsp;&nbsp;&nbsp;&nbsp;diamonds,
&nbsp;&nbsp;&nbsp;&nbsp;hearts,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;pub fn isClubs(self: Suit) bool {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self == Suit.clubs;
&nbsp;&nbsp;&nbsp;&nbsp;}
};

test "enum method" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(Suit.spades.isClubs() == Suit.isClubs(.spades));
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Casting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Enums aren't integers. Convert them with a built-in.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const Value = enum { zero, stuff, blah };
if (@enumToInt(Value.zero)&nbsp;&nbsp;== 0) { ... }
if (@enumToInt(Value.stuff) == 1) { ... }
if (@enumToInt(Value.blah)&nbsp;&nbsp;== 2) { ... }
</code></pre>
	</li>
</ul>
<h3
	id="unions" >
    Unions
</h3>
<ul>
	<li>
		<p>
            Define types that store one value of many possible typed fields.
		</p>
	</li>
	<li>
		<p>
            Only one field may be active at a time.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const Result = union {
&nbsp;&nbsp;&nbsp;&nbsp;int: i64,
&nbsp;&nbsp;&nbsp;&nbsp;float: f64,
&nbsp;&nbsp;&nbsp;&nbsp;bool: bool,
};

test "simple union" {
&nbsp;&nbsp;&nbsp;&nbsp;var result = Result{ .int = 1234 };
&nbsp;&nbsp;&nbsp;&nbsp;result.int = 11;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// valid.
&nbsp;&nbsp;&nbsp;&nbsp;result.float = 12.34; // invalid.
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Tagged Unions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Are unions that use an enum to indicate which field is active.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Tag = enum { a, b, c };

const Tagged = union(Tag) { a: u8, b: f32, c: bool };

test "switch on tagged union" {
&nbsp;&nbsp;&nbsp;&nbsp;var value = Tagged{ .b = 1.5 };
&nbsp;&nbsp;&nbsp;&nbsp;switch (value) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// With `|*value|` we can capture a pointer to the values instead of the values themselves, allowing us to use dereferencing to mutate the original value.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.a =&gt; |*byte| byte.* += 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.b =&gt; |*float| float.* *= 2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.c =&gt; |*b| b.* = !b.*,
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(value.b == 3);
}
</code></pre>
		<ul>
			<li>
				<p>
                    The tag type of a tagged union can also be inferred. This is equivalent to the 
                    <code>Tagged</code>
                    &nbsp;type above.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const Tagged = union(enum) { a: u8, b: f32, c: bool };
</code></pre>
		<ul>
			<li>
				<p>
                    <code>void</code>
                    &nbsp;member types can have their type omitted from the syntax. Here, 
                    <code>none</code>
                    &nbsp;has type 
                    <code>void</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const Tagged2 = union(enum) { a: u8, b: f32, c: bool, none };
</code></pre>
	</li>
</ul>
<h3
	id="structs-codet-code" >
    Structs (
    <code>T{}</code>
    )
</h3>
<ul>
	<li>
		<p>
            Zig gives no guarantees about the in-memory order of fields in a struct or its size.
		</p>
	</li>
	<li>
		<p>
            Struct fields cannot be implicitly uninitialized. If some component of the Struct is missing initialization, it will cause an error.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const Vec3 = struct { x: f32, y: f32, z: f32 };

test "struct usage" {
&nbsp;&nbsp;&nbsp;&nbsp;const my_vector = Vec3{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.x = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.y = 100,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.z = 50,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;_ = my_vector;
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Defaults
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const Vec4 = struct { x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 0 };

test "struct defaults" {
&nbsp;&nbsp;&nbsp;&nbsp;const my_vector = Vec4{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.x = 25,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.y = -50,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;_ = my_vector;
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Packed
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">// Packed structure, with guaranteed in-memory layout.
const Divided = packed struct {
&nbsp;&nbsp;&nbsp;&nbsp;half1: u8,
&nbsp;&nbsp;&nbsp;&nbsp;quarter3: u4,
&nbsp;&nbsp;&nbsp;&nbsp;quarter4: u4,
};
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Methods
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Structs have the unique property that when given a pointer to a struct, one level of dereferencing is done automatically when accessing fields.&quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;In this example, 
                    <code>self.x</code>
                    &nbsp;and 
                    <code>self.y</code>
                    &nbsp;are accessed in the swap function without needing to dereference the self pointer.&quot;
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Stuff = struct {
&nbsp;&nbsp;&nbsp;&nbsp;x: i32,
&nbsp;&nbsp;&nbsp;&nbsp;y: i32,
&nbsp;&nbsp;&nbsp;&nbsp;fn swap(self: *Stuff) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const tmp = self.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.x = self.y;&nbsp;&nbsp;&nbsp;&nbsp;// "without needing to dereference the self pointer", I believe this is `self.x` in Zig, whereas in C++ it would be `self-&gt;x` / `(*self).x`.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.y = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;}
};

test "automatic dereference" {
&nbsp;&nbsp;&nbsp;&nbsp;var thing = Stuff{ .x = 10, .y = 20 };
&nbsp;&nbsp;&nbsp;&nbsp;thing.swap();
&nbsp;&nbsp;&nbsp;&nbsp;try expect(thing.x == 20);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(thing.y == 10);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const Point = struct {
&nbsp;&nbsp;&nbsp;&nbsp;const Self = @This(); // Refers to its own type (later called "Point").

&nbsp;&nbsp;&nbsp;&nbsp;x: u32,
&nbsp;&nbsp;&nbsp;&nbsp;y: u32,
&nbsp;&nbsp;&nbsp;&nbsp;// Take a look at the signature. First argument is of type *Self: "self" is
&nbsp;&nbsp;&nbsp;&nbsp;// a pointer on the instance of the structure.
&nbsp;&nbsp;&nbsp;&nbsp;// This allows the same "dot" notation as in OOP, like "instance.set(x,y)".
&nbsp;&nbsp;&nbsp;&nbsp;// See the following example.
&nbsp;&nbsp;&nbsp;&nbsp;pub fn set(self: *Self, x: u32, y: u32) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.x = x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.y = y;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Again, look at the signature. First argument is of type Self (not *Self),
&nbsp;&nbsp;&nbsp;&nbsp;// this isn't a pointer. In this case, "self" refers to the instance of the
&nbsp;&nbsp;&nbsp;&nbsp;// structure, but can't be modified.
&nbsp;&nbsp;&nbsp;&nbsp;pub fn getx(self: Self) u32 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self.x;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// PS: two previous functions may be somewhat useless.
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; Attributes can be changed directly, no need for accessor functions.
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; It was just an example.
};
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Anonymous Structs
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "anonymous struct literal" {
&nbsp;&nbsp;&nbsp;&nbsp;const Point = struct { x: i32, y: i32 };

&nbsp;&nbsp;&nbsp;&nbsp;const pt: Point = .{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.x = 13,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.y = 67,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;try expect(pt.x == 13);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(pt.y == 67);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "fully anonymous struct" {
&nbsp;&nbsp;&nbsp;&nbsp;try dump(.{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.int = @as(u32, 1234),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.float = @as(f64, 12.34),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.b = true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.s = "hi",
&nbsp;&nbsp;&nbsp;&nbsp;});
}

fn dump(args: anytype) !void {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.int == 1234);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.float == 12.34);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.b);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.s[0] == 'h');
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.s[1] == 'i');
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Files as Structs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://youtu.be/oAVUW6sMb4U?si=78gjoshqC7vPJDvW&t=690" 
						class="external-link" 
						target="_blank" >
                        Using files as structs {11:30}
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Important notes:
						</p>
						<ul>
							<li>
								<p>
                                    <code>const Point = @This;</code>
                                    &nbsp;as the access point.
								</p>
							</li>
							<li>
								<p>
                                    Define functions as 
                                    <code>pub</code>
                                    &nbsp;if you want them accessible outside the file.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="this" >
    @This()
</h5>
<pre><code class="language-zig" data-lang="zig">const Tea = struct {
&nbsp;&nbsp;const Self = @This();
};

pub fn main() !void {
&nbsp;&nbsp;// prints "true"
&nbsp;&nbsp;std.debug.print("{}\n", .{Tea == Tea.Self});
}
</code></pre>
<h5
	id="declaration" >
    Declaration
</h5>
<ul>
	<li>
		<p>
            &quot;The principal units of code in Zig are declarations, not expressions&quot;.
		</p>
	</li>
	<li>
		<p>
			<strong>
                In Godot
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const z := Vector2(0, 0)
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Method 'a'
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const a: rl.Vector2 = .{.x = 0, .y = 0}; 
</code></pre>
		<ul>
			<li>
				<p>
                    Initializes the struct by values.
				</p>
			</li>
			<li>
				<p>
                    The method is called 'Anonymous Struct'.
				</p>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            When it comes to defining default values in a struct, maybe method 
                            <code>a</code>
                            &nbsp;is okay, but it's still inconvenient.
						</p>
					</li>
				</ul>
<pre><code class="language-zig" data-lang="zig">const MinhaStruct = Struct{
&nbsp;&nbsp;&nbsp;&nbsp;// vel: rl.Vector2 = .{.x = 0, .y = 0},
&nbsp;&nbsp;&nbsp;&nbsp;// vel: rl.Vector2 = rl.Vector2.init(0, 0),
};
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Method 'b'
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const b = rl.Vector2.init(0, 0); 
</code></pre>
		<ul>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            I feel a bit worried about 'initializing the struct by values', as I don't know if I'm initializing all the necessary values of the struct, so I usually go for a 
                            <code>.init</code>
                            -based approach.
						</p>
					</li>
					<li>
						<p>
                            The problem is: I change the struct, but I don't get warnings from the LSP, so the only way I know I'm creating the struct wrong is when compiling. Though, if there is an 
                            <code>init</code>
                            &nbsp;function and I'm always using it, it feels easier on the LSP, and I don't need to compile to see the error.
						</p>
					</li>
					<li>
						<p>
                            I'm thinking more about how to avoid having to compile every time to check for type errors in places where I use the struct.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Method 'c'
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const c = rl.Vector2{.x = 0, .y = 0}; 
</code></pre>
		<ul>
			<li>
				<p>
                    Initializes the struct by values.
				</p>
			</li>
			<li>
				<p>
                    Quotes:
				</p>
				<ul>
					<li>
						<p>
                            &quot;c is probably least recommended followed by b.&quot;
						</p>
					</li>
					<li>
						<p>
                            &quot;a and b are fine, c is weird&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Method 'd'
			</strong>
		</p>
<pre><code class="language-zig" data-lang="zig">const d: rl.Vector2 = .init(0, 0);
</code></pre>
		<ul>
			<li>
				<p>
                    Quotes:
				</p>
				<ul>
					<li>
						<p>
                            &quot;the problem with d is that it doesn't work with 
                            <code>catch</code>
                            &quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="error-handling" >
    Error Handling
</h2>
<h3
	id="undefined-null-void" >
    undefined, null, void
</h3>
<h5
	id="undefined" >
    undefined
</h5>
<ul>
	<li>
		<p>
            <code>var foo: u8 = undefined</code>
            .
		</p>
	</li>
	<li>
		<p>
            Should not be thought of as no value, but as a way of telling the compiler that you are not assigning a value 
			<em>
                yet
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Any type may be set to undefined, but attempting to read or use that value is 
			<em>
                always
			</em>
            &nbsp;considered a mistake.
		</p>
	</li>
</ul>
<h5
	id="null" >
    null
</h5>
<ul>
	<li>
		<p>
            <code>var foo: ?u8 = null;</code>
            .
		</p>
	</li>
	<li>
		<p>
            The &quot;null&quot; primitive value 
			<em>
                is
			</em>
            &nbsp;a value that means &quot;no value&quot;.
		</p>
	</li>
	<li>
		<p>
            This is typically used with optional types as in the example above.
		</p>
	</li>
	<li>
		<p>
            When 
            <code>foo</code>
            &nbsp;equals 
            <code>null</code>
            , that's not a value of type 
            <code>u8</code>
            . It means there is 
			<em>
                no value
			</em>
            &nbsp;of type 
            <code>u8</code>
            &nbsp;in 
            <code>foo</code>
            &nbsp;at all.
		</p>
	</li>
</ul>
<h5
	id="void" >
    void
</h5>
<ul>
	<li>
		<p>
            <code>var foo: void = {};</code>
            .
		</p>
	</li>
	<li>
		<p>
            &quot;void&quot; is a 
			<em>
                type
			</em>
            , not a value.
		</p>
	</li>
	<li>
		<p>
            It is the most common of the Zero Bit Types (those types which take up absolutely no space and have only a semantic value).
		</p>
	</li>
	<li>
		<p>
            When compiled to executable code, zero bit types generate no code at all.
		</p>
	</li>
	<li>
		<p>
            The above example shows a variable 
            <code>foo</code>
            &nbsp;of type 
            <code>void</code>
            &nbsp;which is assigned the value of an empty expression.
		</p>
	</li>
	<li>
		<p>
            It's much more common to see 
            <code>void</code>
            &nbsp;as the return type of a function that returns nothing.
		</p>
	</li>
</ul>
<h3
	id="error-sets-try-catch" >
    Error Sets, Try, Catch
</h3>
<h5
	id="error-sets" >
    Error Sets
</h5>
<ul>
	<li>
		<p>
            An error set is like an enum, where each error in the set is a value.
		</p>
	</li>
	<li>
		<p>
            There are no exceptions in Zig; errors are values.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const FileOpenError = error{
&nbsp;&nbsp;&nbsp;&nbsp;AccessDenied,
&nbsp;&nbsp;&nbsp;&nbsp;OutOfMemory,
&nbsp;&nbsp;&nbsp;&nbsp;FileNotFound,
};
</code></pre>
<h5
	id="union-error" >
    Union: Error
</h5>
<ul>
	<li>
		<p>
            An error set type and another type can be combined with the 
            <code>!</code>
            &nbsp;operator to form an error union type.
		</p>
	</li>
	<li>
		<p>
            Values of these types may be an 
			<em>
                error value
			</em>
            &nbsp;or 
			<em>
                a value of the other type
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            If you call a function that returns an error union (
            <code>!T</code>
            ) without using 
            <code>try</code>
            &nbsp;or 
            <code>catch</code>
            , the Zig compiler will emit a compile error, since there is no defined way to handle the possible error.
		</p>
	</li>
	<li>
		<p>
            <code>anyerror</code>
		</p>
		<ul>
			<li>
				<p>
                    Is the global error set, which due to being the superset of all error sets, can have an error from any set coerced to it. Its usage should generally be avoided.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                In variables
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const maybe_error: AllocationError!u16 = 10;
&nbsp;&nbsp;&nbsp;&nbsp;// `maybe_error` can be a `u16` or an error of type `AllocationError`.
&nbsp;&nbsp;&nbsp;&nbsp;// `AllocationError!u16` means the type can be `AllocationError` or `u16`.
const no_error = maybe_error catch 0;
&nbsp;&nbsp;&nbsp;&nbsp;// If `maybe_error` contained an error, `no_error` would receive `0`.
&nbsp;&nbsp;&nbsp;&nbsp;// Since `maybe_error` does not contain an error, `no_error` equals 10.
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                In functions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        With AnyError
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">fn mightFail(x: bool) !i32 { 
&nbsp;&nbsp;&nbsp;&nbsp;// `!i32` means the type can be **any error** or `i32`.
&nbsp;&nbsp;&nbsp;&nbsp;if (x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error.SomeError; 
&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;return 42;
}
</code></pre>
			</li>
			<li>
				<p>
					<strong>
                        With ErrorSet
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">const MyErrors = error{ OutOfMemory, InvalidInput };

fn example(x: bool) MyErrors!i32 {
&nbsp;&nbsp;&nbsp;&nbsp;if (x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error.OutOfMemory;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// valid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//return error.InvalidInput;&nbsp;&nbsp; // valid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//return error.SomeOtherError; // invalid.
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return 42;
}

</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Merge
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const A = error{ NotDir, PathNotFound };
const B = error{ OutOfMemory, PathNotFound };
const C = A || B;
</code></pre>
	</li>
</ul>
<h5
	id="try" >
    Try
</h5>
<ul>
	<li>
		<p>
            Used to 
			<strong>
                propagate errors automatically
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    If the operation results in an error, the error will be returned to the caller.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Zig's 
                    <code>try</code>
                    &nbsp;and 
                    <code>catch</code>
                    &nbsp;are unrelated to try-catch in other languages.
				</p>
			</li>
			<li>
				<p>
                    Zig does not let us ignore error unions via 
                    <code>_ = x;</code>
                    . We must unwrap it with 
                    <code>try</code>
                    , 
                    <code>catch</code>
                    , or 
                    <code>if</code>
                    &nbsp;by some means.
				</p>
				<ul>
					<li>
						<p>
                            <code>_ = try x;</code>
                            &nbsp;or 
                            <code>_ = x catch {};</code>
                            &nbsp;is possible.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Syntax sugar for 
                <code>|err|</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>try x</code>
                    &nbsp;is shorthand for 
                    <code>x catch |err| return err</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="catch" >
    Catch
</h5>
<ul>
	<li>
		<p>
            <code>catch</code>
            &nbsp;is used to 
			<strong>
                handle errors directly
			</strong>
            , providing an alternative value or specific handling.
		</p>
		<ul>
			<li>
				<p>
                    In other words, a 'fallback value'.
				</p>
			</li>
			<li>
				<p>
                    &quot;Could instead be a 
                    <code>noreturn</code>
                    &nbsp;- the type of 
                    <code>return</code>
                    , 
                    <code>while (true)</code>
                    &nbsp;and others.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Basic
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const result = mightFail(false) catch -1; // If there is an error, result is -1.
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                With Payload Capturing
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">fn failingFunction() error{Oops}!void {
&nbsp;&nbsp;&nbsp;&nbsp;return error.Oops;
}

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;failingFunction() catch |err| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                With Payload Capturing and Blocks
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;If you want to provide a default value with 
                    <code>catch</code>
                    &nbsp;after performing some logic, you can combine 
                    <code>catch</code>
                    &nbsp;with named 
					<a
						href="https://ziglang.org/documentation/master/#Blocks" 
						class="external-link" 
						target="_blank" >
                        Blocks
					</a>
                    :&quot;
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://ziglang.org/documentation/master/#catch" 
						class="external-link" 
						target="_blank" >
                        Source
					</a>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const a: ?std.json.Parsed(std.json.Value) = parseJson(allocator, "mapa/mapa.ldtkasd") catch |err| blk: {

&nbsp;&nbsp;&nbsp;&nbsp;print("File not found {}\n", .{err});

&nbsp;&nbsp;&nbsp;&nbsp;break :blk null;

};
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                With Payload Capturing and Switch
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">fn mightFail(x: bool) !i32 {
&nbsp;&nbsp;&nbsp;&nbsp;if (x) return 42;
&nbsp;&nbsp;&nbsp;&nbsp;return error.SomeError;
}

pub fn main() void {
&nbsp;&nbsp;&nbsp;&nbsp;const result = mightFail(false) catch |err| switch (err) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error.SomeError =&gt; -1, // Convert the error to -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else =&gt; -999, // Capture other errors
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                My examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Potentially crashing the program if an error occurs:
				</p>
<pre><code class="language-zig" data-lang="zig">const jsonParsed = try parseJson(allocator, mapa);
defer jsonParsed.deinit();
</code></pre>
			</li>
			<li>
				<p>
                    Trying to continue program execution if an error occurs:
				</p>
<pre><code class="language-zig" data-lang="zig">const jsonParsed: ?std.json.Parsed(std.json.Value) = parseJson(allocator, mapa) catch |err| a: {
&nbsp;&nbsp;&nbsp;&nbsp;print("\nERROR | LDtkParser: {}, {s}\n", .{err, mapa});
&nbsp;&nbsp;&nbsp;&nbsp;break :a null;
};
if (jsonParsed) |*jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.*.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;//etc.
}
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="optionals" >
    Optionals
</h3>
<h5
	id="union-optionals-codet-code" >
    Union: Optionals (
    <code>?T</code>
    )
</h5>
<ul>
	<li>
		<p>
            Used to store either 
            <code>null</code>
            &nbsp;or a value of type 
            <code>T</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Unwrapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>.?</code>
                    &nbsp;is a shorthand for 
                    <code>orelse unreachable</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            This is used when you know it is impossible for an optional value to be null; using this to unwrap a 
                            <code>null</code>
                            &nbsp;value is detectable illegal behaviour.
						</p>
					</li>
				</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "orelse unreachable" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: ?f32 = 5;
&nbsp;&nbsp;&nbsp;&nbsp;const b = a orelse unreachable;
&nbsp;&nbsp;&nbsp;&nbsp;const c = a.?;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(b == c);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf(c) == f32);
}
</code></pre>
			</li>
			<li>
				<p>
                    <code>orelse</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Acts when the optional is 
                            <code>null</code>
                            . This unwraps the optional to its child type.
						</p>
					</li>
				</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "orelse" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: ?f32 = null;
&nbsp;&nbsp;&nbsp;&nbsp;const fallback_value: f32 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;const b = a orelse fallback_value;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(b == 0);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf(b) == f32);
}
</code></pre>
			</li>
			<li>
				<p>
					<strong>
                        Unwrapping in expressions and loops
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://zig.guide/language-basics/payload-captures" 
								class="external-link" 
								target="_blank" >
                                All uses of Payload Capturing
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
							<strong>
                                If
							</strong>
                            :
						</p>
<pre><code class="language-zig" data-lang="zig">const a: ?i32 = 5;
// Method 1
if (a != null) {
&nbsp;&nbsp;&nbsp;&nbsp;const value = a.?;
&nbsp;&nbsp;&nbsp;&nbsp;_ = value;
}
// Method 2
var b: ?i32 = 5;
if (b) |*value| {
&nbsp;&nbsp;&nbsp;&nbsp;value.* += 1;
}
</code></pre>
					</li>
					<li>
						<p>
							<strong>
                                While
							</strong>
                            :
						</p>
<pre><code class="language-zig" data-lang="zig">var numbers_left: u32 = 4;
fn eventuallyNullSequence() ?u32 {
&nbsp;&nbsp;&nbsp;&nbsp;if (numbers_left == 0) return null;
&nbsp;&nbsp;&nbsp;&nbsp;numbers_left -= 1;
&nbsp;&nbsp;&nbsp;&nbsp;return numbers_left;
}

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var sum: u32 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while (eventuallyNullSequence()) |value| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += value;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
					</li>
					<li>
						<p>
                            As in the union example, the captured value is immutable, but we can still use a pointer capture to modify the value stored in 
                            <code>b</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Optional pointer and optional slice types do not take up any extra memory compared to non-optional ones.
				</p>
				<ul>
					<li>
						<p>
                            This is because internally they use the 0 value of the pointer for 
                            <code>null</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="runtime-safety-unreachable" >
    Runtime Safety, Unreachable
</h3>
<h5
	id="detectable-illegal-behaviour" >
    Detectable illegal behaviour
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Illegal-Behavior" 
				class="external-link" 
				target="_blank" >
                Illegal Behaviours
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Illegal behaviour will be caught (causing a panic) with safety on, but will result in undefined behaviour with safety off.
		</p>
	</li>
	<li>
		<p>
            Users are strongly recommended to develop and test their software with safety on, despite its speed penalties.
		</p>
	</li>
	<li>
		<p>
            Enabled:
		</p>
<pre><code class="language-zig" data-lang="zig">test "out of bounds" {
&nbsp;&nbsp;&nbsp;&nbsp;const a = [3]u8{ 1, 2, 3 };
&nbsp;&nbsp;&nbsp;&nbsp;var index: u8 = 5;
&nbsp;&nbsp;&nbsp;&nbsp;const b = a[index];

&nbsp;&nbsp;&nbsp;&nbsp;_ = b;
&nbsp;&nbsp;&nbsp;&nbsp;index = index;
}
</code></pre>
	</li>
	<li>
		<p>
            Disabled:
		</p>
<pre><code class="language-zig" data-lang="zig">test "out of bounds, no safety" {
&nbsp;&nbsp;&nbsp;&nbsp;@setRuntimeSafety(false);
&nbsp;&nbsp;&nbsp;&nbsp;const a = [3]u8{ 1, 2, 3 };
&nbsp;&nbsp;&nbsp;&nbsp;var index: u8 = 5;
&nbsp;&nbsp;&nbsp;&nbsp;const b = a[index];

&nbsp;&nbsp;&nbsp;&nbsp;_ = b;
&nbsp;&nbsp;&nbsp;&nbsp;index = index;
}
</code></pre>
	</li>
</ul>
<h5
	id="unreachable" >
    Unreachable
</h5>
<ul>
	<li>
		<p>
            <code>unreachable</code>
            &nbsp;is an 
			<strong>
                assertion
			</strong>
            &nbsp;to the compiler that this statement will not be reached.
		</p>
	</li>
	<li>
		<p>
            It can tell the compiler that a branch is impossible, which the optimiser can then take advantage of.
		</p>
	</li>
	<li>
		<p>
            Reaching an 
            <code>unreachable</code>
            &nbsp;is detectable illegal behaviour.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">test "unreachable" {
&nbsp;&nbsp;&nbsp;&nbsp;const x: i32 = 1;
&nbsp;&nbsp;&nbsp;&nbsp;const y: u32 = if (x == 2) 5 else unreachable;&nbsp;&nbsp;// crashes if `unreachable` is reached.
&nbsp;&nbsp;&nbsp;&nbsp;_ = y;
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

fn asciiToUpper(x: u8) u8 {
&nbsp;&nbsp;&nbsp;&nbsp;return switch (x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'a'...'z' =&gt; x + 'A' - 'a',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'A'...'Z' =&gt; x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else =&gt; unreachable,&nbsp;&nbsp;&nbsp;&nbsp;// crashes if `unreachable` is reached.
&nbsp;&nbsp;&nbsp;&nbsp;};
}

test "unreachable switch" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(asciiToUpper('a') == 'A');
&nbsp;&nbsp;&nbsp;&nbsp;try expect(asciiToUpper('A') == 'A');
}
</code></pre>
<h2
	id="memory" >
    Memory
</h2>
<ul>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/Memory/Memory.html">
            Memory
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="lifetime-and-ownership" >
    Lifetime and Ownership
</h5>
<ul>
	<li>
		<p>
            Ownership determines whose responsibility it is to free the memory referenced by the pointer, and lifetime determines the point at which the memory becomes inaccessible.
		</p>
	</li>
	<li>
		<p>
            It is the Zig programmer's responsibility to ensure that a pointer is not accessed when the memory pointed to is no longer available.
		</p>
	</li>
	<li>
		<p>
            Note that a slice is a form of pointer, in that it references other memory.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Conventions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In general, when a function returns a pointer, the documentation for the function should explain who &quot;owns&quot; the pointer. This concept helps the programmer decide when it is appropriate, if ever, to free the pointer.
				</p>
				<ul>
					<li>
						<p>
                            For example, the function's documentation may say &quot;caller owns the returned memory&quot;, in which case the code that calls the function must have a plan for when to free that memory.
						</p>
					</li>
					<li>
						<p>
                            Probably in this situation, the function will accept an 
                            <code>Allocator</code>
                            &nbsp;parameter.
						</p>
					</li>
					<li>
						<p>
                            The API documentation for functions and data structures should take great care to explain the ownership and lifetime semantics of pointers.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="defer" >
    Defer
</h3>
<h5
	id="defer" >
    Defer
</h5>
<ul>
	<li>
		<p>
            Defer is used to execute a statement upon exiting the current block.
		</p>
	</li>
	<li>
		<p>
            When there are multiple defers in a single block, they are executed in reverse order.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "defer" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: i16 = 5;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer x += 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 5); // first the test runs, then the defer happens.
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 7);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "multi defer" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: f32 = 5;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer x += 2;&nbsp;&nbsp; // runs after this one.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer x /= 2;&nbsp;&nbsp; // runs first.
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 4.5);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;
const print = std.debug.print;

test "defer unwinding" {
&nbsp;&nbsp;&nbsp;&nbsp;print("\n", .{});

&nbsp;&nbsp;&nbsp;&nbsp;defer {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("1 ", .{});
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;defer {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("2 ", .{});
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (false) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// defers are not run if they are never executed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("3 ", .{});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example of handling Optionals (
                <code>?T</code>
                )
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const jsonParsed: ?std.json.Parsed(std.json.Value) = parseJson(allocator, mapa) catch |err| blk:
&nbsp;&nbsp;&nbsp;&nbsp;print("\nERROR | LDtkParser: {}, {s}\n", .{err, mapa});
&nbsp;&nbsp;&nbsp;&nbsp;break :blk null;
};
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Correct
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">defer {
&nbsp;&nbsp;&nbsp;&nbsp;if (jsonParsed != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonParsed.?.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// or
&nbsp;&nbsp;&nbsp;&nbsp;if (jsonParsed) |jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// or, (not sure which is correct)
&nbsp;&nbsp;&nbsp;&nbsp;if (jsonParsed) |*jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.*.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
				<ul>
					<li>
						<p>
                            The 
                            <code>defer</code>
                            &nbsp;will happen at the expected moment, performing actions depending on whether the variable is null.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Incorrect
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">if (jsonParsed != null) {
&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed.?.deinit();
}
// or
if (jsonParsed) |jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.deinit();
}
// or, (not sure which is correct)
if (jsonParsed) |*jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.*.deinit();
}
</code></pre>
				<ul>
					<li>
						<p>
                            All syntaxes are valid, but the 
                            <code>defer</code>
                            &nbsp;will run as soon as the 
                            <code>if</code>
                            &nbsp;scope exits, i.e., immediately. The 
                            <code>defer</code>
                            &nbsp;is executed inside the 
                            <code>if</code>
                            , not outside it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Comparing with Go
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Zig's 
                    <code>defer</code>
                    &nbsp;is similar to Go's, with one major difference.
				</p>
			</li>
			<li>
				<p>
                    In Zig, the defer runs at the end of its containing scope.
				</p>
			</li>
			<li>
				<p>
                    In Go, defer runs at the end of the containing function.
				</p>
			</li>
			<li>
				<p>
                    Zig's approach is probably less surprising, unless you are a Go developer.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="errdefer" >
    errdefer
</h5>
<ul>
	<li>
		<p>
            <code>errdefer</code>
            &nbsp;works like 
            <code>defer</code>
            , but only executes when the function returns with an error inside the 
            <code>errdefer</code>
            's block.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">var problems: u32 = 98;

fn failingFunction() error{Oops}!void {
&nbsp;&nbsp;&nbsp;&nbsp;return error.Oops;
}

fn failFnCounter() error{Oops}!void {
&nbsp;&nbsp;&nbsp;&nbsp;errdefer problems += 1;
&nbsp;&nbsp;&nbsp;&nbsp;try failingFunction();
}

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;failFnCounter() catch |err| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const Allocator = std.mem.Allocator;

pub const Game = struct {
&nbsp;&nbsp;&nbsp;&nbsp;players: []Player,
&nbsp;&nbsp;&nbsp;&nbsp;history: []Move,
&nbsp;&nbsp;&nbsp;&nbsp;allocator: Allocator,

&nbsp;&nbsp;&nbsp;&nbsp;fn init(allocator: Allocator, player_count: usize) !Game {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var players = try allocator.alloc(Player, player_count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errdefer allocator.free(players);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// store 10 most recent moves per player
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var history = try allocator.alloc(Move, player_count * 10);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return .{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.players = players,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.history = history,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.allocator = allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;fn deinit(game: Game) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const allocator = game.allocator;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(game.players);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(game.history);
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
		<ul>
			<li>
				<p>
                    Under normal conditions, 
                    <code>players</code>
                    &nbsp;is allocated in 
                    <code>init</code>
                    &nbsp;and released in 
                    <code>deinit</code>
                    . But there's an edge case when the initialization of 
                    <code>history</code>
                    &nbsp;fails. In this case and only this case we need to undo the allocation of 
                    <code>players</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Another notable aspect is that the lifecycle of our two dynamically allocated slices, 
                    <code>players</code>
                    &nbsp;and 
                    <code>history</code>
                    , is based on application logic. There's no rule that dictates when 
                    <code>deinit</code>
                    &nbsp;must be called or who must call it. This is good because it gives arbitrary lifetimes, but bad because we can forget to call 
                    <code>deinit</code>
                    &nbsp;or call it more than once.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="comptime" >
    Comptime
</h3>
<ul>
	<li>
		<p>
            &quot;Compile time&quot; is a program's environment while it is being compiled.
		</p>
	</li>
	<li>
		<p>
            &quot;Run time&quot; is the environment while the compiled program executes.
		</p>
	</li>
	<li>
		<p>
            All compiled languages perform some logic at compile time to analyze code and build symbol tables.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Optimizations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Compilers can precompute or inline things at compile time to make the resulting program more efficient.
				</p>
			</li>
			<li>
				<p>
                    Smart compilers can even unroll loops.
				</p>
			</li>
			<li>
				<p>
                    Zig makes compile-time execution an integral part of the language.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Zig has a powerful 
            <code>comptime</code>
            &nbsp;feature to do things at compile time. Compile-time execution can only operate on compile-time known data. Zig provides 
            <code>comptime_int</code>
            &nbsp;and 
            <code>comptime_float</code>
            &nbsp;types. Example:
		</p>
<pre><code class="language-zig" data-lang="zig">var x = 0;
while (true) {
&nbsp;&nbsp;if (someCondition()) break;
&nbsp;&nbsp;x += 2;
}
</code></pre>
		<ul>
			<li>
				<p>
                    This won't compile. 
                    <code>x</code>
                    's type is inferred as a 
                    <code>comptime_int</code>
                    &nbsp;since the value 
                    <code>0</code>
                    &nbsp;is known at compile time. A 
                    <code>comptime_int</code>
                    &nbsp;must be a 
                    <code>const</code>
                    . If we change to 
                    <code>const x = 0;</code>
                    &nbsp;we'll get a different error because we try to add 2 to a 
                    <code>const</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The solution is to explicitly define 
                    <code>x</code>
                    &nbsp;as a runtime integer type:
				</p>
<pre><code class="language-zig" data-lang="zig">var x: usize = 0;
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="numeric-literals" >
    Numeric Literals
</h5>
<ul>
	<li>
		<p>
            ALL numeric literals in Zig are of type 
            <code>comptime_int</code>
            &nbsp;or 
            <code>comptime_float</code>
            . They are arbitrary precision.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const const_int = 12345;
const const_float = 987.654;
</code></pre>
<ul>
	<li>
		<p>
            When assigned to 
            <code>const</code>
            &nbsp;identifiers, we don't need to specify sizes like 
            <code>u8</code>
            &nbsp;or 
            <code>f64</code>
            .
		</p>
	</li>
	<li>
		<p>
            The values are inserted at compile time. The identifiers 
            <code>const_int</code>
            &nbsp;and 
            <code>const_float</code>
            &nbsp;don't exist in the compiled binary.
		</p>
	</li>
</ul>
<h3
	id="pointers" >
    Pointers
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Pointers" 
				class="external-link" 
				target="_blank" >
                Pointers
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="single-item-pointer-codet-code" >
    Single-item Pointer (
    <code>*T</code>
    )
</h5>
<ul>
	<li>
		<p>
            Normal pointers in Zig cannot have 0 or null as a value.
		</p>
		<ul>
			<li>
				<p>
                    Setting a 
                    <code>*T</code>
                    &nbsp;to 0 is detectable illegal behaviour.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Referencing is 
            <code>&variable</code>
            , dereferencing is 
            <code>variable.*</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

// The function receives a pointer to `u8`.
fn increment(num: *u8) void {
&nbsp;&nbsp;&nbsp;&nbsp;num.* += 1;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `num.*` accesses the value pointed to by the pointer (dereference).
}

test "pointers" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: u8 = 1;
&nbsp;&nbsp;&nbsp;&nbsp;increment(&x); // Pass a pointer to `x` to `increment`.
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 2);
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Sizes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>usize</code>
                    &nbsp;and 
                    <code>isize</code>
                    &nbsp;have the same size as pointers.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">test "usize" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@sizeOf(usize) == @sizeOf(*u8));
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@sizeOf(isize) == @sizeOf(*u8));
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Coercion / Casting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Pointers are not integers; explicit conversion is needed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Recommendations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Prefer slices and array types to raw pointers. Compiler-enforced types are less error-prone than pointer manipulation.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="many-item-pointer-codet-code" >
    Many-item Pointer (
    <code>[*]T</code>
    )
</h5>
<ul>
	<li>
		<p>
            Many pointer types exist to represent what is pointed to: single value or array, known length or not.
		</p>
	</li>
	<li>
		<p>
            Most programs need buffers with runtime-known lengths. Many-item pointers represent those.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Questions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Example usage confusion:
				</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

fn doubleAllManypointer(buffer: [*]u8, byte_count: usize) void {
&nbsp;&nbsp;&nbsp;&nbsp;var i: usize = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while (i &lt; byte_count) : (i += 1) buffer[i] *= 2;
}

test "many-item pointers" {
&nbsp;&nbsp;&nbsp;&nbsp;var buffer: [100]u8 = [_]u8{1} ** 100;
&nbsp;&nbsp;&nbsp;&nbsp;const buffer_ptr: *[100]u8 = &buffer;

&nbsp;&nbsp;&nbsp;&nbsp;const buffer_many_ptr: [*]u8 = buffer_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;doubleAllManypointer(buffer_many_ptr, buffer.len);
&nbsp;&nbsp;&nbsp;&nbsp;for (buffer) |byte| try expect(byte == 2);

&nbsp;&nbsp;&nbsp;&nbsp;const first_elem_ptr: *u8 = &buffer_many_ptr[0];
&nbsp;&nbsp;&nbsp;&nbsp;const first_elem_ptr_2: *u8 = @ptrCast(buffer_many_ptr);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(first_elem_ptr == first_elem_ptr_2);
}
</code></pre>
			</li>
			<li>
				<p>
                    &quot;Slices can be thought of as many-item pointers (
                    <code>[*]T</code>
                    ) plus a length (
                    <code>usize</code>
                    ).&quot;
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="slices-codet-code" >
    Slices (
    <code>[]T</code>
    )
</h5>
<ul>
	<li>
		<p>
			<strong>
                Slices vs Arrays
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Slices do not store data, only a 
					<em>
                        reference
					</em>
                    &nbsp;to the original array.
				</p>
				<ul>
					<li>
						<p>
                            They store the valid length of the buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Slices can have runtime variable length; arrays have fixed length known at compile time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Slices vs Many-item Pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Slices are safer and more convenient. 
                    <code>for</code>
                    &nbsp;loops work on slices.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Slices are &quot;fat pointers&quot; and are typically twice the size of a normal pointer.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Create from an array with 
                    <code>x[n..m]</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Slicing includes 
                    <code>n</code>
                    &nbsp;and excludes 
                    <code>m</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

fn total(values: []const u8) usize {
&nbsp;&nbsp;&nbsp;&nbsp;var soma: usize = 0;
&nbsp;&nbsp;&nbsp;&nbsp;for (values) |v| soma += v;
&nbsp;&nbsp;&nbsp;&nbsp;return soma;
}

test "slices" {
&nbsp;&nbsp;&nbsp;&nbsp;const array = [_]u8{ 1, 2, 3, 4, 5 };
&nbsp;&nbsp;&nbsp;&nbsp;const slice = array[0..3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// elements 0, 1 and 2.
&nbsp;&nbsp;&nbsp;&nbsp;try expect(total(slice) == 6);&nbsp;&nbsp;// returns 6 = 1 + 2 + 3.
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf(slice) == *const [3]u8);
}
</code></pre>
		<ul>
			<li>
				<p>
                    Use 
                    <code>x[n..]</code>
                    &nbsp;to slice to the end.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">test "slices 3" {
&nbsp;&nbsp;&nbsp;&nbsp;var array = [_]u8{ 1, 2, 3, 4, 5 };
&nbsp;&nbsp;&nbsp;&nbsp;var slice = array[0..];
&nbsp;&nbsp;&nbsp;&nbsp;_ = slice;
}
</code></pre>
	</li>
</ul>
<h5
	id="pointer-types" >
    Pointer Types
</h5>
<ul>
	<li>
		<p>
			<strong>
                Single-item Pointer vs Multi-item Pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250307235940.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250308001358.png" width="575" >
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>[]T</code>
                    &nbsp;is a Slice.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="dangling-pointers" >
    Dangling Pointers
</h5>
<ul>
	<li>
		<p>
			<strong>
                About
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Returning the address of a local.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;const warning1 = try powerLevel(9000);
&nbsp;&nbsp;const warning2 = try powerLevel(10);

&nbsp;&nbsp;std.debug.print("{s}\n", .{warning1});
&nbsp;&nbsp;std.debug.print("{s}\n", .{warning2});
}

fn powerLevel(over: i32) ![]u8 {
&nbsp;&nbsp;var buf: [20]u8 = undefined;
&nbsp;&nbsp;return std.fmt.bufPrint(&buf, "over {d}!!!", .{over});
}
</code></pre>
		<ul>
			<li>
				<p>
                    Here we return the address of 
                    <code>buf</code>
                    , but 
                    <code>buf</code>
                    &nbsp;ceases to exist when the function returns.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex2
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.openmymind.net/Zig-Dangling-Pointers/" 
						class="external-link" 
						target="_blank" >
                        Source examples
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Other examples:
				</p>
				<ul>
					<li>
						<p>
                            Arena allocator created inside a struct, etc.
						</p>
						<ul>
							<li>
								<p>
                                    Not fully understood.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Printing a pointer that pointed to a StringHashMap entry that was removed.
						</p>
						<ul>
							<li>
								<p>
                                    A simple, somewhat silly example.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex3
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() void {
&nbsp;&nbsp;&nbsp;&nbsp;const user1 = User.init(1, 10);
&nbsp;&nbsp;&nbsp;&nbsp;const user2 = User.init(2, 20);

&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("User {d} has power of {d}\n", .{user1.id, user1.power});
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("User {d} has power of {d}\n", .{user2.id, user2.power});
}

pub const User = struct {
&nbsp;&nbsp;&nbsp;&nbsp;id: u64,
&nbsp;&nbsp;&nbsp;&nbsp;power: i32,

&nbsp;&nbsp;&nbsp;&nbsp;fn init(id: u64, power: i32) *User{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var user = User{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.id = id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.power = power,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &user;
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
		<ul>
			<li>
				<p>
                    The problem is 
                    <code>User.init</code>
                    &nbsp;returns the address of the local 
                    <code>user</code>
                    . That's a dangling pointer. Returning 
                    <code>&user</code>
                    &nbsp;returns an invalid address.
				</p>
			</li>
			<li>
				<p>
                    A simple fix is to change 
                    <code>init</code>
                    &nbsp;to return 
                    <code>User</code>
                    &nbsp;(not 
                    <code>*User</code>
                    ) and 
                    <code>return user;</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            But that's not always possible.
						</p>
					</li>
					<li>
						<p>
                            Data often must outlive function scope. For that we use the heap.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex4
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">fn read() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const input = try readUserInput();
&nbsp;&nbsp;&nbsp;&nbsp;return Parser.parse(input);
}
</code></pre>
		<ul>
			<li>
				<p>
                    If 
                    <code>Parser.parse</code>
                    &nbsp;returns a value that references 
                    <code>input</code>
                    , that will be a dangling pointer. Ideally 
                    <code>Parser</code>
                    &nbsp;would copy 
                    <code>input</code>
                    &nbsp;if it needs it to live longer. There's nothing here to enforce that. Check documentation or source to know semantics.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="memory-allocators" >
    Memory: Allocators
</h2>
<h5
	id="injecting-the-allocator" >
    Injecting the Allocator
</h5>
<ul>
	<li>
		<p>
            One of Zig's core principle is 
			<em>
                no hidden memory allocations
			</em>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's a sharp contrast to what you'll find in C where memory is allocated with the standard library's 
                    <code>malloc</code>
                    &nbsp;function.
				</p>
			</li>
			<li>
				<p>
                    In C, if you want to know whether or not a function allocates memory, you need to read the source and look for calls to 
                    <code>malloc</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The advantage of injecting the allocator isn't just explicitness, it's also flexibility.
		</p>
		<ul>
			<li>
				<p>
                    <code>std.mem.Allocator</code>
                    &nbsp;is an interface which provides the 
                    <code>alloc</code>
                    , 
                    <code>free</code>
                    , 
                    <code>create</code>
                    &nbsp;and 
                    <code>destroy</code>
                    &nbsp;functions, along with a few others.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you're building a library, then it's best to accept an 
            <code>std.mem.Allocator</code>
            &nbsp;and let users of your library decide which allocator implementation to use. Otherwise, you'll need to chose the right allocator.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Related notes when using std.json
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Caio: &quot;is it a good idea to only use 1 allocator across the whole game? I don't know if this is even possible, but purely talking in terms of a centralized way of allocating and deallocating memory&quot;
				</p>
				<ul>
					<li>
						<p>
                            yes. you might end up wanting two allocators (one for general memory that you manage the lifetime of, and a seperate arena allocator that frees all its memory every frame)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio: &quot;seems like the function is returning a huge bag of unwanted data. I mean, all I actually want is the obj, as it is inside of it that the json data is stored. Is there a way to only return the obj and not have a leak?
				</p>
				<ul>
					<li>
						<p>
                            &quot;if memory is allocated within the function, then you need a way for the caller to free it. so with std.json.parseFromSlice(), that's by calling .deinit() on the returned value. that's a pretty common pattern.&quot;
						</p>
					</li>
					<li>
						<p>
                            Caio: &quot;if memory is allocated inside a function, return the object allocated&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;For a json parsing, the Parsed(T) includes an ArenaAllocator and the value - that's it. The ArenaAllocator holds all the memory for everything inside value&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="areas-of-memory" >
    Areas of memory
</h3>
<ul>
	<li>
		<p>
            The areas are conceptual; OS and executable enforce them.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Global space
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Stack
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Heap
			</strong>
            .
		</p>
	</li>
</ul>
<h5
	id="global-space" >
    Global Space
</h5>
<ul>
	<li>
		<p>
            The first is global space, which is where program constants, including string literals, are stored.
		</p>
	</li>
	<li>
		<p>
            All global data is baked into the binary, fully known at compile time (and thus runtime) and immutable.
		</p>
	</li>
	<li>
		<p>
            This data exists throughout the lifetime of the program, never needing more or less memory.
		</p>
	</li>
	<li>
		<p>
            Aside from the impact it has on the size of our binary, this isn't something we need to worry about at all.
		</p>
	</li>
</ul>
<h5
	id="stack-allocator" >
    Stack Allocator
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=GZ6PuLikw84" 
				class="external-link" 
				target="_blank" >
                Explanation of Allocators, focusing on Linear Allocators (Stack)
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Does not talk about the different types of allocators, only the Linear (Stack).
				</p>
			</li>
			<li>
				<p>
                    Provides a good visualization of how the Stack is used in functions.
				</p>
			</li>
			<li>
				<p>
                    The video is good, but not very detailed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The call stack is amazing because of the simple and predictable way it manages data (by pushing and popping stack frames).
				</p>
			</li>
			<li>
				<p>
                    Automatically handled by the compiler.
				</p>
			</li>
			<li>
				<p>
                    Very fast allocation and cleanup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Constraints
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Fixed total memory.
				</p>
				<ul>
					<li>
						<p>
                            &quot;You are not allowed to store GBs of memory on the stack, for example&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Fixed size.
				</p>
			</li>
			<li>
				<p>
                    Fixed lifetimes.
				</p>
				<ul>
					<li>
						<p>
                            Data has a lifetime tied to its place on the call stack.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="heap-allocator" >
    Heap Allocator
</h5>
<ul>
	<li>
		<p>
            Useful for data that has to live beyond the rigid boundaries of function scopes.
		</p>
	</li>
	<li>
		<p>
            We can create memory at runtime with a runtime-known size and have complete control over its lifetime.
		</p>
	</li>
	<li>
		<p>
            It has no built-in life cycle, so our data can live for as long or as short as necessary. And that benefit is its drawback: it has no built-in life cycle, so if we don't free data, no one will.
		</p>
		<ul>
			<li>
				<p>
                    You can allocate memory in an HTTP handler and free it in a background thread, two completely separate parts of the code.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Everything we've seen so far has been constrained by requiring an upfront size. Arrays always have a compile-time known length (in fact, the length is part of the type). All of our strings have been string literals, which have a compile-time known length.
		</p>
	</li>
	<li>
		<p>
            Furthermore, the two types of memory management strategies we've seen, global data and the call stack, while simple and efficient, are limiting. Neither can deal with dynamically sized data and both are rigid with respect to data lifetimes.
		</p>
	</li>
</ul>
<h3
	id="strategies-heap-allocation" >
    Strategies: Heap Allocation
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#fixedbuffer" 
				class="external-link" 
				target="_blank" >
                Heap Allocation Strategies
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=vHWiDx_l4V0" 
				class="external-link" 
				target="_blank" >
                Different Allocator Strategies in Zig
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    At the time, GPA (DebugAllocator) did not exist.
				</p>
			</li>
			<li>
				<p>
                    The conclusion of the video was that &quot;This is a developing area, but Zig is doing very well here, because it has no default allocator and forces you to think about allocator choice.&quot;
				</p>
			</li>
			<li>
				<p>
                    It wasnâ€™t discussed which allocator to use in each case; it was only about strategies.
				</p>
			</li>
			<li>
				<p>
                    Itâ€™s strange how this area still feels so &quot;new&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="page-allocator-quotusing-syscallsquot" >
    Page Allocator (&quot;using syscalls&quot;)
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.page_allocator;</code>
            .
		</p>
	</li>
	<li>
		<p>
            Allocates a whole page of memory each time we ask for some memory.
		</p>
	</li>
	<li>
		<p>
            Whenever this allocator makes an allocation, it will ask your OS for entire pages of memory; an allocation of a single byte will likely reserve multiple kibibytes.
		</p>
	</li>
	<li>
		<p>
            As asking the OS for memory requires a system call, this is also extremely inefficient for speed.
		</p>
	</li>
	<li>
		<p>
            Very simple, very dumb, very wasteful.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;This is the base of most allocators, but it's not what people use directly&quot;.
				</p>
			</li>
			<li>
				<p>
                    Very slow, since it uses syscalls; &quot;massive slow in your program&quot;.
				</p>
			</li>
			<li>
				<p>
                    Wasteful.
				</p>
				<ul>
					<li>
						<p>
                            It doesnâ€™t think in terms of bytes, but pages (4KB).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = std.heap.page_allocator;

&nbsp;&nbsp;&nbsp;&nbsp;const memory = try allocator.alloc(u8, 100);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// we allocate 100 bytes as a `[]u8`.
&nbsp;&nbsp;&nbsp;&nbsp;defer allocator.free(memory);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// defer is used in conjunction with a free - this is a common pattern for memory management in Zig.
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Construction?
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const PageAllocator = struct {
&nbsp;&nbsp;&nbsp;&nbsp;pub fn alloc(self: *@This(), size: u32) []u8 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const mem = std.os.mmap( // slow (syscall)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alignForward(size, page_size)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) catch {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error.OutOfMemory;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mem[0..size];
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn free(self: *@This(), mem: []u8) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std.os.munmap(mem);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
</ul>
<h5
	id="fixedbufferallocator-quotbump-allocatorquot" >
    FixedBufferAllocator (&quot;Bump Allocator&quot;)
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.FixedBufferAllocator.init(...);</code>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#fixedbuffer" 
				class="external-link" 
				target="_blank" >
                Using FixedBufferAllocator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Is an allocator that allocates memory into a fixed buffer and does not make any heap allocations.
		</p>
	</li>
	<li>
		<p>
            Uses a fixed buffer to get its memory, doesnâ€™t ask memory from the kernel.
		</p>
	</li>
	<li>
		<p>
            It will give you the error 
            <code>OutOfMemory</code>
            &nbsp;if it has run out of bytes.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Very fast allocation.
				</p>
			</li>
			<li>
				<p>
                    Control lifetime via buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Fixed total memory.
				</p>
			</li>
			<li>
				<p>
                    Cannot free individual memory.
				</p>
				<ul>
					<li>
						<p>
                            &quot;There is no data structure, it only stores the last memory index. Therefore, you canâ€™t deallocate memory in the middle of this region.&quot;
						</p>
					</li>
					<li>
						<p>
                            &quot;Maybe itâ€™s possible to deallocate the last allocation.&quot;
						</p>
					</li>
					<li>
						<p>
                            &quot;Itâ€™s possible to clear the whole buffer.&quot;
						</p>
					</li>
					<li>
						<p>
                            <code>free</code>
                            &nbsp;and 
                            <code>destroy</code>
                            &nbsp;will only work on the last allocated/created item (think of a stack).
						</p>
						<ul>
							<li>
								<p>
                                    Freeing the non-last allocation is safe to call, but wonâ€™t do anything.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                When to use
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This is useful when heap usage is not wanted, for example, when writing a kernel.
				</p>
			</li>
			<li>
				<p>
                    It may also be considered for performance reasons.
				</p>
			</li>
			<li>
				<p>
                    &quot;If you donâ€™t care about expandable memory, you should use FixedBufferAllocator, as itâ€™s simply faster.&quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;Probably the fastest youâ€™ll ever get.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var buffer: [1000]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;var fba = std.heap.FixedBufferAllocator.init(&buffer);
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = fba.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;const memory = try allocator.alloc(u8, 100);
&nbsp;&nbsp;&nbsp;&nbsp;defer allocator.free(memory);
}
</code></pre>
	</li>
</ul>
<h5
	id="arenaallocator-quotbump-allocator-with-expandable-memoryquot" >
    ArenaAllocator (&quot;Bump Allocator with expandable memory&quot;)
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.ArenaAllocator.init(...);</code>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#arena" 
				class="external-link" 
				target="_blank" >
                Using ArenaAllocator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Itâ€™s the place where you store all data that share the same lifetime.
		</p>
	</li>
	<li>
		<p>
            Takes in a child allocator and allows you to allocate many times and only free once. Use in combination with another allocator.
		</p>
	</li>
	<li>
		<p>
            Here, 
            <code>.deinit()</code>
            &nbsp;is called on the arena, which frees all memory.
		</p>
		<ul>
			<li>
				<p>
                    Using 
                    <code>allocator.free</code>
                    &nbsp;in this example would be a no-op (i.e., does nothing).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Very fast allocation.
				</p>
			</li>
			<li>
				<p>
                    Expandable total memory.
				</p>
			</li>
			<li>
				<p>
                    Manual lifetime.
				</p>
				<ul>
					<li>
						<p>
                            &quot;Arena = One Lifetime&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Very simple way of avoiding leaks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cannot free individual memory.
				</p>
				<ul>
					<li>
						<p>
                            &quot;This ends up being useful for cases like Linked Lists, for example, since it allows freeing the entire listâ€™s memory at once without traversing it.&quot;
						</p>
					</li>
					<li>
						<p>
                            Disclaimer: &quot;Donâ€™t use Linked Lists, use arrays. Arrays are much faster nowadays.&quot;
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                When to use
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Commonly used in some places, but the problem of not being able to &quot;free individual memory&quot; can be annoying in some cases.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
&nbsp;&nbsp;&nbsp;&nbsp;defer arena.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = arena.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;_ = try allocator.alloc(u8, 1);
&nbsp;&nbsp;&nbsp;&nbsp;_ = try allocator.alloc(u8, 10);
&nbsp;&nbsp;&nbsp;&nbsp;_ = try allocator.alloc(u8, 100);
}
</code></pre>
	</li>
</ul>
<h5
	id="debugallocator-formerly-generalpurposeallocator-gpa" >
    DebugAllocator (formerly GeneralPurposeAllocator (GPA))
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.DebugAllocator(.{}){};</code>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#gpa" 
				class="external-link" 
				target="_blank" >
                Using GPA
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            &quot;In debug builds, use DebugAllocator, formerly known as GPA. In release builds, use std.heap.smp_allocator.&quot;
		</p>
	</li>
	<li>
		<p>
            &quot;DebugAllocator and smp_allocator are both backed by page_allocator, which requests more memory from the operating system when it runs out.&quot;
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Designed for safety over performance, but may still be many times faster than page_allocator.
				</p>
			</li>
			<li>
				<p>
                    This is a safe allocator that can prevent double-free, use-after-free, and detect leaks.
				</p>
				<ul>
					<li>
						<p>
                            Safety checks and thread safety can be turned off via its configuration struct.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Thread-safe allocator.
				</p>
			</li>
			<li>
				<p>
                    Gets some memory first and manages buckets of memory to reduce the number of allocations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Uses
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can serve as your application's main allocator. For many programs, this will be the only allocator needed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const httpz = @import("httpz");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;// create our general purpose allocator
&nbsp;&nbsp;&nbsp;&nbsp;var gpa = std.heap.GeneralPurposeAllocator(.{}){};

&nbsp;&nbsp;&nbsp;&nbsp;// get an std.mem.Allocator from it
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = gpa.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;// pass our allocator to functions and libraries that require it
&nbsp;&nbsp;&nbsp;&nbsp;var server = try httpz.Server().init(allocator, .{.port = 5882});

&nbsp;&nbsp;&nbsp;&nbsp;var router = server.router();
&nbsp;&nbsp;&nbsp;&nbsp;router.get("/api/user/:id", getUser);

&nbsp;&nbsp;&nbsp;&nbsp;// blocks the current thread
&nbsp;&nbsp;&nbsp;&nbsp;try server.listen();
}
</code></pre>
		<ul>
			<li>
				<p>
                    (2025-03-27)
				</p>
<pre><code class="language-zig" data-lang="zig">var debugAllocator = std.heap.DebugAllocator(.{}){};
&nbsp;&nbsp;&nbsp;&nbsp;// Creates the DebugAllocator TYPE with configuration (.{})
&nbsp;&nbsp;&nbsp;&nbsp;// Using this type, an instance is obtained by {};
&nbsp;&nbsp;&nbsp;&nbsp;// debugAllocator is now an instance of the object `DebugAllocator(...)`.
&nbsp;&nbsp;&nbsp;&nbsp;// Itâ€™s important that `debugAllocator` is a VAR. If you use CONST, everything crashes at .allocator() below.
const allocator = debugAllocator.allocator();
&nbsp;&nbsp;&nbsp;&nbsp;// The internal function is used to obtain the allocator.
&nbsp;&nbsp;&nbsp;&nbsp;// allocator is of type `Allocator`.
defer {
&nbsp;&nbsp;&nbsp;&nbsp;_ = debugAllocator.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Not sure exactly why, but itâ€™s important to call .deinit() on the debugAllocator.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Interestingly, the page_allocator does not require this.
}
</code></pre>
			</li>
			<li>
				<p>
                    What is this: 
                    <code>GeneralPurposeAllocator(.{}){}</code>
                    ?
				</p>
				<ul>
					<li>
						<p>
                            <code>std.heap.GeneralPurposeAllocator</code>
                            &nbsp;is a function, and since it uses PascalCase, we know it returns a type.
						</p>
					</li>
					<li>
						<p>
                            <code>.{}</code>
                            &nbsp;is a struct initializer with an implicit type. Whatâ€™s the type and where are the fields? The type is 
                            <code>std.heap.general_purpose_allocator.Config</code>
                            , though it isnâ€™t directly exposed like this, which is one reason we arenâ€™t explicit. No fields are set because the 
                            <code>Config</code>
                            &nbsp;struct defines defaults, which weâ€™ll be using.
						</p>
					</li>
					<li>
						<p>
                            This is a common pattern with configuration / options.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="smp-allocator" >
    SMP Allocator
</h5>
<ul>
	<li>
		<p>
            ?
		</p>
	</li>
	<li>
		<p>
            Suggested for Release builds.
		</p>
	</li>
</ul>
<h5
	id="testing-allocator" >
    Testing Allocator
</h5>
<ul>
	<li>
		<p>
            <code>std.testing.allocator</code>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#testing" 
				class="external-link" 
				target="_blank" >
                Using the Testing Allocator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                About
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This is a special allocator that 
					<strong>
                        only works in tests
					</strong>
                    &nbsp;and can detect memory leaks.
				</p>
			</li>
			<li>
				<p>
                    Currently, itâ€™s implemented using the 
                    <code>GeneralPurposeAllocator</code>
                    &nbsp;with added integration in Zigâ€™s test runner, but thatâ€™s an implementation detail.
				</p>
			</li>
			<li>
				<p>
                    The important thing is that if we use 
                    <code>std.testing.allocator</code>
                    &nbsp;in our 
					<strong>
                        tests
					</strong>
                    , we can catch most memory leaks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In your code, use whatever allocator is appropriate.
		</p>
	</li>
</ul>
<h5
	id="discussion-slab-allocator" >
    Discussion: Slab Allocator
</h5>
<ul>
	<li>
		<p>
            Similar to the Arena Allocator.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You can manually free memory.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Allocations have fixed sizes.
				</p>
			</li>
			<li>
				<p>
                    Metadata storage is wasteful.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="discussion-general-purpose-allocator" >
    Discussion: General Purpose Allocator
</h5>
<ul>
	<li>
		<p>
			<strong>
                About
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This type of allocator was discussed in this 
					<a
						href="https://www.youtube.com/watch?v=vHWiDx_l4V0" 
						class="external-link" 
						target="_blank" >
                        Zig talk
					</a>
                    &nbsp;from June 2020. There was no GPA yet, so everything discussed in the video and the section below is speculative.
				</p>
			</li>
			<li>
				<p>
                    Not sure if DebugAllocator / GPA is related to this concept.
				</p>
			</li>
			<li>
				<p>
                    Still, the strategic discussion is interesting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Free lists
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Advantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            You can manually free memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Disadvantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allocations have a minimum size.
						</p>
					</li>
					<li>
						<p>
                            Very slow.
						</p>
					</li>
					<li>
						<p>
                            Memory Fragmentation.
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Worse performance the longer your program is running&quot;.
								</p>
							</li>
							<li>
								<p>
                                    &quot;Thereâ€™s no way to defragment your memory, as there are pointers going everywhere and you canâ€™t really track them down&quot;.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const FreeListAllocator = struct {
&nbsp;&nbsp;&nbsp;&nbsp;root: ?*Node,

&nbsp;&nbsp;&nbsp;&nbsp;fn find(self: *@This(), size: u32) ?[]u8 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var iter = self.root;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (iter) |node| : (iter = node.next) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.size == size) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.remove(node);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return node.buffer();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn free(self: *@This(), mem: u32) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const node = Node.init(mem);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.prepend(node);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Free lists with size buckets
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This solves the Fragmentation problem, since allocations have fixed sizes; kinda; &quot;mitigated, not all gone&quot;.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Advantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            You can manually free memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Disadvantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allocations have a fixed size.
						</p>
					</li>
					<li>
						<p>
                            Cache pressure.
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Youâ€™ll probably have cache misses if youâ€™re allocating sporadically&quot;.
								</p>
							</li>
							<li>
								<p>
                                    If everything is allocated at once, there might not be cache misses, but if allocations happen occasionally, cache misses will likely occur.
								</p>
							</li>
							<li>
								<p>
                                    This makes sense when you consider that although fragmentation is avoided, this solution ends up spreading allocations that happen after deallocations.
								</p>
							</li>
							<li>
								<p>
                                    &quot;This is really bad&quot;.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="init-deinit-create-destroy" >
    init(), deinit(), create(), destroy()
</h3>
<ul>
	<li>
		<p>
            For slices: use 
            <code>alloc</code>
            &nbsp;and 
            <code>free</code>
            .
		</p>
	</li>
	<li>
		<p>
            For single items: use 
            <code>create</code>
            &nbsp;and 
            <code>destroy</code>
            .
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;

test "allocator create/destroy" {
&nbsp;&nbsp;&nbsp;&nbsp;const byte = try std.heap.page_allocator.create(u8);
&nbsp;&nbsp;&nbsp;&nbsp;defer std.heap.page_allocator.destroy(byte);
&nbsp;&nbsp;&nbsp;&nbsp;byte.* = 128;
}
</code></pre>
	</li>
</ul>
<h3
	id="warnings" >
    Warnings
</h3>
<h5
	id="double-free" >
    Double Free
</h5>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var gpa = std.heap.GeneralPurposeAllocator(.{}){};
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = gpa.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;var arr = try allocator.alloc(usize, 4);
&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(arr);
&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(arr);

&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("This won't get printed\n", .{});
}
</code></pre>
<ul>
	<li>
		<p>
            In the case of a double free, weâ€™ll get a hard crash.
		</p>
	</li>
</ul>
<h5
	id="memory-leak" >
    Memory Leak
</h5>
<pre><code class="language-zig" data-lang="zig">fn isSpecial(allocator: Allocator, name: [] const u8) !bool {
&nbsp;&nbsp;&nbsp;&nbsp;const lower = try allocLower(allocator, name);
&nbsp;&nbsp;&nbsp;&nbsp;return std.mem.eql(u8, lower, "admin");
}
</code></pre>
<ul>
	<li>
		<p>
            The memory created in 
            <code>allocLower</code>
            &nbsp;is never freed.
		</p>
	</li>
	<li>
		<p>
            Not only that, but once 
            <code>isSpecial</code>
            &nbsp;returns, it can 
			<strong>
                never
			</strong>
            &nbsp;be freed. Once 
            <code>isSpecial</code>
            &nbsp;returns, we lose our only reference to the allocated memory, the 
            <code>lower</code>
            &nbsp;variable. The memory is gone until our process exits.
		</p>
		<ul>
			<li>
				<p>
                    Damn.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Our function might only leak a few bytes, but if it's a long-running process and this function is called repeatedly, it 
			<em>
                will
			</em>
            &nbsp;add up and we'll eventually run out of memory.
		</p>
	</li>
	<li>
		<p>
            Memory leaks can be insidious. It isnâ€™t just that the root cause can be difficult to identify. Really small leaks or leaks in infrequently executed code can be even harder to detect.
		</p>
	</li>
</ul>
<h2
	id="threads" >
    Threads
</h2>
<ul>
	<li>
		<p>
            While Zig provides more advanced ways of writing concurrent and parallel code, 
            <code>std.Thread</code>
            &nbsp;is available for making use of OS threads.
		</p>
	</li>
	<li>
		<p>
            Threads, however, 
			<strong>
                aren't particularly useful
			</strong>
            &nbsp;without strategies for thread safety.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">fn ticker(step: u8) void {
&nbsp;&nbsp;&nbsp;&nbsp;while (true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std.time.sleep(1 * std.time.ns_per_s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick += @as(isize, step);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

var tick: isize = 0;

test "threading" {
&nbsp;&nbsp;&nbsp;&nbsp;var thread = try std.Thread.spawn(.{}, ticker, .{@as(u8, 1)});
&nbsp;&nbsp;&nbsp;&nbsp;_ = thread;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(tick == 0);
&nbsp;&nbsp;&nbsp;&nbsp;std.time.sleep(3 * std.time.ns_per_s / 2);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(tick == 1);
}
</code></pre>
<h2
	id="file-system" >
    File System
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/filesystem" 
				class="external-link" 
				target="_blank" >
                FileSystem
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/readers-and-writers" 
				class="external-link" 
				target="_blank" >
                IO Reader and Writer
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="json" >
    Json
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/Reading-A-Json-Config-In-Zig/" 
				class="external-link" 
				target="_blank" >
                Reading a Json file
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's an interesting read.
				</p>
			</li>
			<li>
				<p>
                    (2025-03-28) I think some things have changed nowadays.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.openmymind.net/Zigs-std-json-Parsed/" 
				class="external-link" 
				target="_blank" >
                std.json.Parse(T)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.openmymind.net/Writing-Json-To-A-Custom-Output-in-Zig/" 
				class="external-link" 
				target="_blank" >
                Writing a Json file
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/json" 
				class="external-link" 
				target="_blank" >
                Json
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Poor explanation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://ziglang.org/documentation/master/std/#std.json" 
				class="external-link" 
				target="_blank" >
                std.json
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    I prefer to look at the actual std.json file rather than trust that this documentation is up to date.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="regex" >
    Regex
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.openmymind.net/Regular-Expressions-in-Zig/" 
				class="external-link" 
				target="_blank" >
                Regex
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="others" >
    Others
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/sorting" 
				class="external-link" 
				target="_blank" >
                Sorting
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/random-numbers" 
				class="external-link" 
				target="_blank" >
                Random Numbers
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/crypto" 
				class="external-link" 
				target="_blank" >
                Crypto
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="interfaces" >
    Interfaces
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/Zig-Interfaces/" 
				class="external-link" 
				target="_blank" >
                Interface Implementation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Zig doesn't have nice syntactic sugar for creating interfaces.
		</p>
	</li>
	<li>
		<p>
            One pattern for interface-like behavior are tagged unions, though that's relatively constrained compared to true interfaces.
		</p>
	</li>
	<li>
		<p>
            Other patterns have emerged and are used throughout the standard library, such as with 
            <code>std.mem.Allocator</code>
            .
		</p>
	</li>
</ul>
<h2
	id="game-dev" >
    Game Dev
</h2>
<h5
	id="impressions" >
    Impressions
</h5>
<ul>
	<li>
		<p>
            (2025-03-13)
		</p>
	</li>
	<li>
		<p>
            I feel like I'm always having to fight the casting system.
		</p>
		<ul>
			<li>
				<p>
                    The system isn't bad, but it's simply VERY verbose and it gets in the way when dealing with APIs, having to do transforms all the time.
				</p>
			</li>
			<li>
				<p>
                    Making a 
                    <code>util.zig</code>
                    &nbsp;file and defining helper functions to do the casting helps a lot.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Compilation times are kind of long.
		</p>
		<ul>
			<li>
				<p>
                    Not absurd, but I feel it can be a problem when dealing with a very large file.
				</p>
			</li>
			<li>
				<p>
                    So far it's been okay.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Dealing with strings is super stressful for game dev.
		</p>
		<ul>
			<li>
				<p>
                    When both strings are comptime, concatenation is okay, but when they're runtime you need to work with allocators, etc.
				</p>
			</li>
			<li>
				<p>
                    This is not a big problem, because I always avoid using strings anyway, besides that although more work, there is elegance in handling strings as 
                    <code>[:0]const u8</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Allocation is a nightmare.
		</p>
		<ul>
			<li>
				<p>
                    (2025-03-28) Lifetimes are simply very complex, even for something simple.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="libraries" >
    Libraries
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/zig-gamedev#libraries" 
				class="external-link" 
				target="_blank" >
                Libraries
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="render" >
    Render
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Not-Nik/RayLib-zig" 
				class="external-link" 
				target="_blank" >
                RayLib-Zig
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=-xIFpg7sBVs" 
						class="external-link" 
						target="_blank" >
                        Zig with RayLib
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/castholm/SDL" 
				class="external-link" 
				target="_blank" >
                SDL-Zig
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/floooh/sokol-zig" 
				class="external-link" 
				target="_blank" >
                Sokol-Zig
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Made by the author of Sokol.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ecs" >
    ECS
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/prime31/zig-ecs" 
				class="external-link" 
				target="_blank" >
                Zig ECS (Entt port)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/foxnne/zflecs" 
				class="external-link" 
				target="_blank" >
                zflecs (Flecs port)
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="demos" >
    Demos
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/zig-gamedev" 
				class="external-link" 
				target="_blank" >
                Zig GameDev
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>zig build simple_raytracer-run</code>
				</p>
				<ul>
					<li>
						<p>
                            Failed to open, does not exist.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="demo-games" >
    Demo: Games
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Srekel/tides-of-revival" 
				class="external-link" 
				target="_blank" >
                Tides of Revival
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://tides-of-revival.itch.io/tides-of-revival" 
						class="external-link" 
						target="_blank" >
                        Tides of Revival
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=RdFBBEQxMN0" 
						class="external-link" 
						target="_blank" >
                        Author's channel video
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Seems friendly :)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2025-03-10)
				</p>
				<ul>
					<li>
						<p>
                            I couldn't build it.
						</p>
					</li>
					<li>
						<p>
                            0.14.0+ is incompatible.
						</p>
					</li>
					<li>
						<p>
                            I had issues finding dependencies, etc.
						</p>
					</li>
					<li>
						<p>
                            I managed to open the file downloaded from itch.io
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        When testing
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The game has a long way to go '-', but at the same time it has a nice charm of a pleasant little game.
						</p>
					</li>
					<li>
						<p>
                            Reminds me of the feeling of playing a Minecraft alpha at night, kind of cool.
						</p>
					</li>
					<li>
						<p>
                            The game has no options menu and crashes when trying to resize the window.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://github.com/btipling/blockens" 
				class="external-link" 
				target="_blank" >
                Blockens
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    (2025-03-10)
				</p>
				<ul>
					<li>
						<p>
                            I only managed to build on 1.12.1.
						</p>
					</li>
					<li>
						<p>
                            The FPS is INSANELY low; like, 4 fps in the start menu and in-game.
						</p>
					</li>
					<li>
						<p>
                            The CPU got very hot.
						</p>
					</li>
					<li>
						<p>
                            The game is not worth it at all, for learning or inspiration.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="mach" >
    Mach
</h3>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            Engine in Zig.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://machengine.org/" 
				class="external-link" 
				target="_blank" >
                Mach
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/hexops/mach" 
				class="external-link" 
				target="_blank" >
                Mach
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://machengine.org/docs/object/" 
				class="external-link" 
				target="_blank" >
                Documentation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="impressions" >
    Impressions
</h5>
<ul>
	<li>
		<p>
            I found it a bit uncomfortable to always have a variable called 'mach_system' or 'mech_algo', being an anonymous struct containing method names.
		</p>
		<ul>
			<li>
				<p>
                    From what I understand, this is a way to show Mach which kind of method symbolizes what, so they can be accessed and 
                    <code>run</code>
                    &nbsp;by Mach's API.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In this case, 
            <code>pub const main</code>
            &nbsp;symbolizes a scheduler to make certain things be called in order, etc, when calling the &quot;main module&quot; (I think main is the module of this script).
		</p>
		<ul>
			<li>
				<p>
                    Since this script is 
                    <code>App.zig</code>
                    , this 
                    <code>pub const main</code>
                    &nbsp;indicates the entry point that the 
                    <code>main.zig</code>
                    &nbsp;file (generated by Mach) will call, once everything starts.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250311113142.png" width="350" >
            .
		</p>
	</li>
</ul>
<h5
	id="things-made-with-mach" >
    Things made with Mach
</h5>
<ul>
	<li>
		<p>
			<strong>
                Games
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/foxnne/aftersun" 
						class="external-link" 
						target="_blank" >
                        Aftersun
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            (2025-03-10)
						</p>
						<ul>
							<li>
								<p>
                                    I couldn't build it.
								</p>
							</li>
							<li>
								<p>
                                    0.13.0 is old, 0.14.0+ is incompatible.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Pixel art Editor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/foxnne/pixi" 
						class="external-link" 
						target="_blank" >
                        Pixi
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            (2025-03-10)
						</p>
						<ul>
							<li>
								<p>
                                    I couldn't build it.
								</p>
							</li>
							<li>
								<p>
                                    0.13.0 is old, 0.14.0+ is incompatible.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="godot" >
    Godot
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/godot-zig/godot-zig" 
				class="external-link" 
				target="_blank" >
                Godot Zig
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/godot-zig/godot-zig-examples" 
				class="external-link" 
				target="_blank" >
                Examples
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/godot-zig/godot-zig-examples/blob/master/src/SpriteNode.zig" 
						class="external-link" 
						target="_blank" >
                        Demo
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;Each file is also a struct&quot;.
		</p>
	</li>
</ul>
<h5
	id="impressions" >
    Impressions
</h5>
<ul>
	<li>
		<p>
            (2025-01-18)
		</p>
		<ul>
			<li>
				<p>
                    Extreme boilerplate. Not doable.
				</p>
			</li>
			<li>
				<p>
                    Very verbose.
				</p>
			</li>
			<li>
				<p>
                    I really don't like having to deal with object deinitialization.
				</p>
			</li>
			<li>
				<p>
                    &quot;Actually I don't like usingnamespace either in its current state, but it's the simplest way I can work out to wrap OOP. The fundamental problem is that Zig doesnâ€™t favor OOP at all, there should be some facilities to assist in doing such&quot;.
				</p>
				<ul>
					<li>
						<p>
                            The idea of repeatedly using namespaces sounds strange when looking at the code.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    My feeling is that although Zig is easier to read than Rust, it curiously seems to introduce more boilerplate than Rust, due to the way Godot Zig was implemented. Maybe that will change in the future, but I don't feel it's worth it at all.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tests" >
    Tests
</h5>
<ul>
	<li>
		<p>
            (2025-01-18)
		</p>
		<ul>
			<li>
				<p>
                    Did not work with Godot 4.4-beta1, but worked with Godot 4.3.
				</p>
			</li>
			<li>
				<p>
                    I can use the Godot 4.3 .exe and use the .dll in Godot 4.4-beta1 without problems.
				</p>
			</li>
			<li>
				<p>
                    Steps:
				</p>
				<ul>
					<li>
						<p>
                            Inside 
                            <code>build.zig</code>
                            :
						</p>
					</li>
				</ul>
<pre><code class="language-zig" data-lang="zig">const godot_path = b.option([]const u8, "godot", "Path to Godot engine binary [default: `godot`]") orelse "C:\\Users\\caior\\Desktop\\Programas\\! Godot Launchers\\Godot_v4.3-stable_win64.exe";`
</code></pre>
				<ul>
					<li>
						<p>
                            <code>zig build</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Other Programming Languages/Rust/Rust.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Other Programming Languages/Go.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2025-12-13 ðŸš€
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#impressions" >
                            Impressions
						</a>
						<ul>
							<li>
								<a
									href="#negative-points" >
                                    Negative points
								</a>
							</li>
							<li>
								<a
									href="#positive-points" >
                                    Positive points
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#about" >
                            About
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#installation" >
                            Installation
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#build" >
                            Build
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#basics" >
                            Basics
						</a>
						<ul>
							<li>
								<a
									href="#comments-print-formatting" >
                                    Comments, Print, Formatting
								</a>
							</li>
							<li>
								<a
									href="#functions" >
                                    Functions
								</a>
							</li>
							<li>
								<a
									href="#control-flow-if-while-for-switch-labelled-iterators" >
                                    Control Flow (if, while, for, switch, labelled, iterators)
								</a>
							</li>
							<li>
								<a
									href="#imports" >
                                    Imports
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#types" >
                            Types
						</a>
						<ul>
							<li>
								<a
									href="#casting" >
                                    Casting
								</a>
							</li>
							<li>
								<a
									href="#primitives" >
                                    Primitives
								</a>
							</li>
							<li>
								<a
									href="#generics" >
                                    Generics
								</a>
							</li>
							<li>
								<a
									href="#tuples" >
                                    Tuples
								</a>
							</li>
							<li>
								<a
									href="#arrays" >
                                    Arrays
								</a>
							</li>
							<li>
								<a
									href="#vectors" >
                                    Vectors
								</a>
							</li>
							<li>
								<a
									href="#strings" >
                                    Strings
								</a>
							</li>
							<li>
								<a
									href="#hashmaps" >
                                    HashMaps
								</a>
							</li>
							<li>
								<a
									href="#enums-codeenum-code" >
                                    Enums (<code>enum {}</code>)
								</a>
							</li>
							<li>
								<a
									href="#unions" >
                                    Unions
								</a>
							</li>
							<li>
								<a
									href="#structs-codet-code" >
                                    Structs (<code>T{}</code>)
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#error-handling" >
                            Error Handling
						</a>
						<ul>
							<li>
								<a
									href="#undefined-null-void" >
                                    undefined, null, void
								</a>
							</li>
							<li>
								<a
									href="#error-sets-try-catch" >
                                    Error Sets, Try, Catch
								</a>
							</li>
							<li>
								<a
									href="#optionals" >
                                    Optionals
								</a>
							</li>
							<li>
								<a
									href="#runtime-safety-unreachable" >
                                    Runtime Safety, Unreachable
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory" >
                            Memory
						</a>
						<ul>
							<li>
								<a
									href="#defer" >
                                    Defer
								</a>
							</li>
							<li>
								<a
									href="#comptime" >
                                    Comptime
								</a>
							</li>
							<li>
								<a
									href="#pointers" >
                                    Pointers
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory-allocators" >
                            Memory: Allocators
						</a>
						<ul>
							<li>
								<a
									href="#areas-of-memory" >
                                    Areas of memory
								</a>
							</li>
							<li>
								<a
									href="#strategies-heap-allocation" >
                                    Strategies: Heap Allocation
								</a>
							</li>
							<li>
								<a
									href="#init-deinit-create-destroy" >
                                    init(), deinit(), create(), destroy()
								</a>
							</li>
							<li>
								<a
									href="#warnings" >
                                    Warnings
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#threads" >
                            Threads
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#file-system" >
                            File System
						</a>
						<ul>
							<li>
								<a
									href="#json" >
                                    Json
								</a>
							</li>
							<li>
								<a
									href="#regex" >
                                    Regex
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#others" >
                            Others
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#game-dev" >
                            Game Dev
						</a>
						<ul>
							<li>
								<a
									href="#libraries" >
                                    Libraries
								</a>
							</li>
							<li>
								<a
									href="#demos" >
                                    Demos
								</a>
							</li>
							<li>
								<a
									href="#mach" >
                                    Mach
								</a>
							</li>
							<li>
								<a
									href="#godot" >
                                    Godot
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.24731.js" >
		</script>
	</body>
</html>
