<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.45986.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
					open="">
					<summary>
                        Odin
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-overview.html" >
                                Overview
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-my-impressions.html" >
                                My Impressions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-installation.html" >
                                Installation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-building.html" >
                                Building
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-compile-time-stuff.html" >
                                Compile-time Stuff
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-package-system.html" >
                                Package System
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-lsp-ols-odin-language-server.html" >
                                LSP (OLS - Odin Language Server)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-operations.html" >
                                Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-control-flow-if-when-switch-for-defer.html" >
                                Control Flow (if, when, switch, for, defer)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-procedures.html" >
                                Procedures
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-typing.html" >
                                Typing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-any.html" >
                                any
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-primitive-types.html" >
                                Primitive Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-matrix.html" >
                                Matrix
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-quaternion.html" >
                                Quaternion
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-complex.html" >
                                Complex
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-strings.html" >
                                Strings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-rune.html" >
                                Rune
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-maps-hash-maps.html" >
                                Maps (Hash Maps)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-struct.html" >
                                Struct
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-union.html" >
                                Union
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-bit-sets.html" >
                                Bit Sets
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-arrays.html" >
                                Arrays
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-interfaces-methods-vtables.html" >
                                Interfaces / Methods / VTables
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-error-handling.html" >
                                Error Handling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-context.html" >
                                Context
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-memory-address.html" >
                                Memory: Address
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-memory-allocators.html" >
                                Memory: Allocators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-memory-operations.html" >
                                Memory: Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-entry-point.html" >
                                Entry Point
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Low-Level Systems/Odin/Odin-multi-threading.html" >
                                Multi-Threading
							</a>
							<ul>
								<li>
									<a
										href="#corethread" >
                                        core:thread
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#channels-codecoresync-chan-code" >
                                        Channels <code>core:sync/chan</code>
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#cpu-yield" >
                                        CPU Yield
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#synchronization-primitives-direct-comparisons" >
                                        Synchronization Primitives: Direct Comparisons
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#atomics" >
                                        Atomics
									</a>
									<ul>
										<li>
											<a
												href="#memory-order" >
                                                Memory Order
											</a>
										</li>
										<li>
											<a
												href="#operations" >
                                                Operations
											</a>
										</li>
									</ul>
								</li>
								<li>
									<a
										href="#barrier-codesync-barrier-code" >
                                        Barrier (<code>sync.Barrier</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#semaphore-codesync-sema-code" >
                                        Semaphore (<code>sync.Sema</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#benaphore-codesync-benaphore-code" >
                                        Benaphore (<code>sync.Benaphore</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#recursive-benaphore-codesync-recursive_benaphore-code" >
                                        Recursive Benaphore (<code>sync.Recursive_Benaphore</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#auto-reset-event-codesync-auto_reset_event-code" >
                                        Auto Reset Event (<code>sync.Auto_Reset_Event</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mutex-codesync-mutex-code" >
                                        Mutex (<code>sync.Mutex</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#futex-codesync-futex-code" >
                                        Futex (<code>sync.Futex</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#one-shot-event-codesync-one_shot_event-code" >
                                        One Shot Event (<code>sync.One_Shot_Event</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#parker-codesync-parker-code" >
                                        Parker (<code>sync.Parker</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#read-write-mutex-codesync-rw_mutex-code-codesys_windows-srwlock-code" >
                                        Read-Write Mutex (<code>sync.RW_Mutex</code>) / (<code>sys_windows.SRWLock</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#once-codesync-once-code" >
                                        Once (<code>sync.Once</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#ticket-mutex-codesync-ticket_mutex-code" >
                                        Ticket Mutex (<code>sync.Ticket_Mutex</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#condition-variable-codesync-cond-code" >
                                        Condition Variable (<code>sync.Cond</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#wait-group-codesync-wait_group-code" >
                                        Wait Group (<code>sync.Wait_Group</code>)
									</a>
									<ul>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-simd.html" >
                                SIMD
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-directives.html" >
                                Directives
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-ffi-foreign-function-interface-bindings.html" >
                                FFI (Foreign Function Interface) / Bindings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-web-build.html" >
                                Web Build
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-file-system-process-cli-shell.html" >
                                File System / Process / CLI / Shell
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin-useful-packages.html" >
                                Useful Packages
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Memory
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-virtual-memory.html" >
                                Virtual Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-os-memory-on-windows.html" >
                                OS: Memory on Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-memory-alignment.html" >
                                Memory Alignment
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-address.html" >
                                Address
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-allocators.html" >
                                Allocators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-tools-memory-analysis.html" >
                                Tools: Memory Analysis
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-handles-instead-of-pointers.html" >
                                Handles instead of Pointers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-ownership-strategies-destruction-strategies.html" >
                                Ownership Strategies / Destruction Strategies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-strategies-for-handling-short-lived-memory.html" >
                                Strategies for handling short lived memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-garbage-collection.html" >
                                Garbage Collection
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory-initialization.html" >
                                Initialization
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        CPU
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU-concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU-physical-structure.html" >
                                Physical Structure
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU-cache.html" >
                                Cache
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU-soa-struct-of-arrays-ecs-entity-component-system.html" >
                                SOA (Struct Of Arrays) / ECS (Entity Component System)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU-simd.html" >
                                SIMD
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Multithreading
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading-core-concepts.html" >
                                Core Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading-thread.html" >
                                Thread
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading-strategies.html" >
                                Strategies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading-implementation-detail.html" >
                                Implementation Detail
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading-synchronization-primitives.html" >
                                Synchronization Primitives
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading-double-buffering.html" >
                                Double-Buffering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading-networking-strategies.html" >
                                Networking Strategies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Handmade Hero
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero-handmade-hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Profilers
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers-tracy.html" >
                                Tracy
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers-spall.html" >
                                Spall
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers-nvidia-nsight-graphics-gpu-trace.html" >
                                Nvidia Nsight Graphics - GPU Trace
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers-amd-gpu-profiler-amd-rgp.html" >
                                AMD GPU Profiler (AMD RGP)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers-intel-gpa.html" >
                                Intel GPA
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers-nsight-systems.html" >
                                <s>Nsight Systems</s>
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        C
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-critiques.html" >
                                Critiques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-c-standard.html" >
                                C Standard
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-c-standard-library-libc.html" >
                                C Standard Library (libc)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-building.html" >
                                Building
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-loops.html" >
                                Loops
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-strings.html" >
                                Strings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-structs.html" >
                                Structs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-pointers.html" >
                                Pointers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-arrays.html" >
                                Arrays
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-preprocessors.html" >
                                Preprocessors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-undefined-behavior.html" >
                                Undefined Behavior
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-gamedev.html" >
                                GameDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C-windows-c-api.html" >
                                WIndows C API
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Build Systems - Compilation - Linking
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilation-process.html" >
                                Compilation Process
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-linker.html" >
                                Linker
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilers.html" >
                                Compilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-build-tools.html" >
                                Build Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-meta-build-tools.html" >
                                Meta Build Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-extra-annoying-things-on-windows.html" >
                                Extra: Annoying things on Windows
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Debuggers
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-file-types.html" >
                                File Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-rad-debbuger.html" >
                                RAD Debbuger
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-gdb-gnu-debugger.html" >
                                GDB (GNU Debugger)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-lldb.html" >
                                LLDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-vscode.html" >
                                VSCode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-visual-studio-debugger.html" >
                                Visual Studio Debugger
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-others.html" >
                                Others
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers-web.html" >
                                Web
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Assembly - ASM
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM-notes.html" >
                                Notes
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM-operations.html" >
                                Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM-reverse-engineering.html" >
                                Reverse Engineering
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Parsing
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Parsing-parsing.html" >
                                Parsing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Parsing-lexer.html" >
                                Lexer
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Parsing-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        JAI
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI-build.html" >
                                Build
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI-types.html" >
                                Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI-meta-programming.html" >
                                Meta programming
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI-control-flow.html" >
                                Control flow
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Multi-Threading
						</h1>
						<p>
							<time
								datetime="2025-03-28" >
                                ðŸ•’ Created: 2025-03-28
							</time>
							<time
								datetime="2026-02-01" >
                                | Updated: 2026-02-01
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<ul>
	<li>
		<p>
			<em>
                Note
			</em>
            : I'm still studying about Odin's implementation of multithreading, so the notes here are basically me organizing the content I found around the source code and 
			<a
				href="https://pkg.odin-lang.org/core/sync/" 
				class="external-link" 
				target="_blank" >
                core:sync
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Ginger Bill:
		</p>
		<ul>
			<li>
				<p>
                    &quot;Odin does have numerous threading and synchronization primitives in its core library. But it does not have any parallelism/concurrency features built directly into the language itself because all of them require some form of automatic memory management which is a no-go.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;Odin handles threads similarly to how Go handles it&quot;.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang" 
				class="external-link" 
				target="_blank" >
                Multithreading tutorial in Odin
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/jakubtomsu/jobs" 
				class="external-link" 
				target="_blank" >
                odin-jobs
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="corethread" >
    core:thread
</h3>
<h5
	id="thread-create" >
    thread.create
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/thread/#create" 
				class="external-link" 
				target="_blank" >
                <code>create</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-creating-threads" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Create a thread in a suspended state with the given priority.
		</p>
	</li>
	<li>
		<p>
            This procedure creates a thread that will be set to run the procedure specified by the 
            <code>procedure</code>
            &nbsp;parameter with a specified priority. The returned thread will be in a suspended state until 
            <code>start()</code>
            &nbsp;procedure is called.
		</p>
	</li>
</ul>
<h5
	id="thread-pool" >
    Thread Pool
</h5>
<ul>
	<li>
		<p>
			<strong>
                Via thread.pool
			</strong>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/thread/#pool_init" 
						class="external-link" 
						target="_blank" >
                        <code>pool_init</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/thread/#Pool" 
						class="external-link" 
						target="_blank" >
                        <code>Pool</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-creating-a-threadpool-using-threadpool" 
						class="external-link" 
						target="_blank" >
                        Tutorial
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Via dynamic array
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Stores pointer to a thread.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-now-lets-try-creating-many-threads" 
						class="external-link" 
						target="_blank" >
                        Tutorial
					</a>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">arr := []int{1,2,3}

main :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;threadPool := make([dynamic]^thread.Thread, 0, len(arr))
&nbsp;&nbsp;&nbsp;&nbsp;defer delete(threadPool)
}
</code></pre>
	</li>
</ul>
<h3
	id="channels-codecoresync-chan-code" >
    Channels 
    <code>core:sync/chan</code>
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/chan/" 
				class="external-link" 
				target="_blank" >
                core:sync/chan
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The tutorial is useful.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-communicating-between-threads-using-channels" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            This package provides both high-level and low-level channel types for thread-safe communication.
		</p>
	</li>
	<li>
		<p>
            While channels are essentially thread-safe queues under the hood, their primary purpose is to facilitate safe communication between multiple readers and multiple writers. Although they can be used like queues, channels are designed with synchronization and concurrent messaging patterns in mind.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Provided types
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>Chan</code>
                    &nbsp;a high-level channel.
				</p>
			</li>
			<li>
				<p>
                    <code>Raw_Chan</code>
                    &nbsp;a low-level channel.
				</p>
			</li>
			<li>
				<p>
                    <code>Raw_Queue</code>
                    &nbsp;a low-level non-threadsafe queue implementation used internally.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="cpu-yield" >
    CPU Yield
</h3>
<ul>
	<li>
		<p>
            <code>cpu_relax</code>
		</p>
		<ul>
			<li>
				<p>
                    This procedure may lower CPU consumption or yield to a hyperthreaded twin processor.
				</p>
			</li>
			<li>
				<p>
                    It's exact function is architecture specific, but the intent is to say that you're not doing much on a CPU.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="synchronization-primitives-direct-comparisons" >
    Synchronization Primitives: Direct Comparisons
</h3>
<h5
	id="comparing-codesema-code-vs-codeatomic_sema-code" >
    Comparing 
    <code>Sema</code>
    &nbsp;vs 
    <code>Atomic_Sema</code>
</h5>
<ul>
	<li>
		<p>
            <code>Sema</code>
            &nbsp;is just a wrapper around 
            <code>_Sema</code>
            &nbsp;implementations depending on the OS, 
			<em>
                but
			</em>
            , as there's only one implementation of 
            <code>_Sema</code>
            &nbsp;in the whole 
            <code>sync</code>
            &nbsp;library, 
            <code>Sema</code>
            &nbsp;and 
            <code>Atomic_Sema</code>
            &nbsp;ends up being the same.
		</p>
	</li>
	<li>
		<p>
            It's just an edge case for consistency.
		</p>
	</li>
	<li>
		<p>
            Blob:
		</p>
		<ul>
			<li>
				<p>
                    Once upon a time there was a Wait Group based Semaphore, which could be switched to with a flag. Ya, I'd image it's just keep as is for a consistency. 
					<a
						href="https://github.com/odin-lang/Odin/commit/d5886c1572c6b093079e3be9911d5aaad0e65a7d" 
						class="external-link" 
						target="_blank" >
                        #d5886c1
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="comparing-codemutex-code-vs-codeatomic_mutex-code" >
    Comparing 
    <code>Mutex</code>
    &nbsp;vs 
    <code>Atomic_Mutex</code>
</h5>
<ul>
	<li>
		<p>
			<strong>
                For any other OS
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It doesn't matter. 
                    <code>Mutex</code>
                    &nbsp;uses 
                    <code>Atomic_Mutex</code>
                    &nbsp;directly. It acts like a direct wrapper.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                For Windows
			</strong>
            :
		</p>
		<ul>
			<li>
				<p
					class="line-emphasis" >
					<input
						type="checkbox" 
						disabled=""
>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="comparing-coderw_mutex-code-vs-codeatomic_rw_mutex-code" >
    Comparing 
    <code>RW_Mutex</code>
    &nbsp;vs 
    <code>Atomic_RW_Mutex</code>
</h5>
<ul>
	<li>
		<p>
			<strong>
                For any other OS
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It doesn't matter. 
                    <code>RW_Mutex</code>
                    &nbsp;uses 
                    <code>Atomic_RW_Mutex</code>
                    &nbsp;directly. It acts like a direct wrapper.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                For Windows
			</strong>
            :
		</p>
		<ul>
			<li>
				<p
					class="line-emphasis" >
					<input
						type="checkbox" 
						disabled=""
>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="comparing-codecond-code-vs-codeatomic_cond-code" >
    Comparing 
    <code>Cond</code>
    &nbsp;vs 
    <code>Atomic_Cond</code>
</h5>
<ul>
	<li>
		<p>
			<strong>
                For any other OS
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It doesn't matter. 
                    <code>Cond</code>
                    &nbsp;uses 
                    <code>Atomic_Cond</code>
                    &nbsp;directly. It acts like a direct wrapper.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                For Windows
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Which one to use for Windows?
				</p>
				<ul>
					<li>
						<p>
                            By default lots of implementations from other synchronization primitives use 
                            <code>Cond</code>
                            , so I guess I should stay with that one for consistency? I don't know. The implementation from 
                            <code>ntdll</code>
                            &nbsp;seems more troublesome then 
                            <code>win32</code>
                            , based on what I saw.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Using 
                        <code>Cond</code>
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>win32.SleepConditionVariableSRW</code>
                            &nbsp;will be used.
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin">SleepConditionVariableSRW :: proc(ConditionVariable: ^CONDITION_VARIABLE, SRWLock: ^SRWLOCK, dwMilliseconds: DWORD, Flags: LONG) -&gt; BOOL ---
</code></pre>
				<ul>
					<li>
						<p>
                            Is a Win32 API function that blocks a thread until a condition variable is signaled, while using an SRW lock as the associated synchronization object.
						</p>
					</li>
					<li>
						<p>
                            Provide a lightweight, efficient way for threads to wait for a condition to change without spinning. It is the higher-level Win32 analogue to Linux futex-style waits and internally uses the wait-on-address mechanism.
						</p>
					</li>
					<li>
						<p>
                            <code>ConditionVariable</code>
						</p>
						<ul>
							<li>
								<p>
                                    The condition variable to wait on.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>SRWLock</code>
						</p>
						<ul>
							<li>
								<p>
                                    A previously acquired SRW lock (in shared or exclusive mode).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dwMilliseconds</code>
						</p>
						<ul>
							<li>
								<p>
                                    Timeout in milliseconds, or 
                                    <code>INFINITE</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>Flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>CONDITION_VARIABLE_LOCKMODE_SHARED</code>
                                    &nbsp;if the lock was acquired in shared mode;
								</p>
							</li>
							<li>
								<p>
                                    <code>0</code>
                                    &nbsp;if it was acquired in exclusive mode.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            How it works:
						</p>
						<ol>
							<li>
								<p>
                                    The caller must already hold the SRW lock.
								</p>
							</li>
							<li>
								<p>
                                    The function atomically unlocks the SRW lock and puts the thread to sleep on the condition variable.
								</p>
							</li>
							<li>
								<p>
                                    When awakened by 
                                    <code>WakeConditionVariable</code>
                                    &nbsp;or 
                                    <code>WakeAllConditionVariable</code>
                                    , it 
									<em>
                                        reacquires
									</em>
                                    &nbsp;the SRW lock before returning.
								</p>
							</li>
							<li>
								<p>
                                    The caller must recheck the condition because wake-ups may be spurious.
								</p>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Using 
                        <code>Atomic_Cond</code>
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>Futex</code>
                            &nbsp;implementation for Windows will be used instead, which uses 
                            <code>atomic_cond_wait -&gt; Ntdll.RtlWaitOnAddress</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>ntdll.dll</code>
                            &nbsp;is the lowest-level user-mode runtime library in Windows, providing the Native API and the gateway to kernel system calls.
						</p>
						<ol>
							<li>
								<p>
                                    The NT system call interface
								</p>
								<ul>
									<li>
										<p>
                                            It provides the user-mode entry points for system calls (
                                            <code>Nt*</code>
                                            &nbsp;and 
                                            <code>Zw*</code>
                                            &nbsp;functions). These functions are thin wrappers that transition into kernel mode.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The Windows Native API (undocumented or semi-documented)
								</p>
								<ul>
									<li>
										<p>
                                            This includes functions prefixed with 
                                            <code>Rtl*</code>
                                            , 
                                            <code>Ldr*</code>
                                            , 
                                            <code>Nt*</code>
                                            , etc. They cover low-level tasks such as process/thread start-up, memory management helpers, loader functionality, string utilities, and synchronization primitives.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Process bootstrapping code
								</p>
								<ul>
									<li>
										<p>
                                            Every user-mode process loads 
                                            <code>ntdll.dll</code>
                                            &nbsp;first. It sets up the runtime before the main moduleâ€™s entry point runs.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Support for critical subsystems
								</p>
								<ul>
									<li>
										<p>
                                            Exception dispatching
										</p>
									</li>
									<li>
										<p>
                                            Thread local storage internals
										</p>
									</li>
									<li>
										<p>
                                            Heap internals (working with the kernel)
										</p>
									</li>
									<li>
										<p>
                                            Loader and module management
										</p>
									</li>
									<li>
										<p>
                                            Atomically waiting/waking primitives (like 
                                            <code>RtlWaitOnAddress</code>
                                            )
										</p>
									</li>
								</ul>
							</li>
						</ol>
						<ul>
							<li>
								<p>
                                    It is not meant for application-level use. Many of its functions are undocumented, can change between Windows releases, and may break compatibility.
								</p>
							</li>
							<li>
								<p>
                                    It is not the same as 
                                    <code>kernel32.dll</code>
                                    &nbsp;or 
                                    <code>user32.dll</code>
                                    . Those are higher-level and officially documented; they themselves call into 
                                    <code>ntdll.dll</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin">RtlWaitOnAddress :: proc(Address: rawptr, CompareAddress: rawptr, AddressSize: uint, Timeout: ^i64) -&gt; i32 ---
</code></pre>
				<ul>
					<li>
						<p>
                            Rtl (Run-time library) + WaitOnAddress â†’ â€œrun-time library: wait on (a) memory address.â€
						</p>
					</li>
					<li>
						<p>
                            &quot;block the calling thread until the memory at a specified address no longer matches a given value (or a timeout/interrupt occurs)&quot;.
						</p>
					</li>
					<li>
						<p>
                            Atomically compares the bytes at 
                            <code>AddressToWaitOn</code>
                            &nbsp;with the bytes pointed to by 
                            <code>CompareAddress</code>
                            &nbsp;(size 
                            <code>AddressSize</code>
                            ).
						</p>
					</li>
					<li>
						<p>
                            If they are equal, the caller is put to sleep by the kernel until either the memory changes, a timeout/interrupt occurs, or a wake is issued.
						</p>
					</li>
					<li>
						<p>
                            If they are different on first check, it returns immediately.
						</p>
					</li>
					<li>
						<p>
                            Ginger Bill:
						</p>
						<ul>
							<li>
								<p>
                                    For some bizarre reason, 
                                    <code>timeout</code>
                                    &nbsp;has to be a negative number.
								</p>
							</li>
							<li>
								<p>
                                    <code>WaitOnAddress</code>
                                    &nbsp;is implemented on top of 
                                    <code>RtlWaitOnAddress</code>
                                    &nbsp;BUT requires taking the return value of it and if it is non-zero converting that status to a DOS error and then 
                                    <code>SetLastError</code>
                                    &nbsp;If this is not done, then things don't work as expected when an error occurs GODDAMN MICROSOFT!
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="atomics" >
    Atomics
</h3>
<h4
	id="memory-order" >
    Memory Order
</h4>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#atomics">
            Multithreading#Atomics
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="implicit-memory-order" >
    Implicit Memory Order
</h5>
<ul>
	<li>
		<p>
            Non-explicit atomics will always be sequentially consistent (
            <code>.Seq_Cst</code>
            ).
		</p>
	</li>
</ul>
<h5
	id="explicit-memory-order" >
    Explicit Memory Order
</h5>
<ul>
	<li>
		<p>
            In Odin there are 5 different memory ordering guaranties that can be provided to an atomic operation:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Atomic_Memory_Order :: enum {
&nbsp;&nbsp;&nbsp;&nbsp;Relaxed = 0, // Unordered
&nbsp;&nbsp;&nbsp;&nbsp;Consume = 1, // Monotonic
&nbsp;&nbsp;&nbsp;&nbsp;Acquire = 2,
&nbsp;&nbsp;&nbsp;&nbsp;Release = 3,
&nbsp;&nbsp;&nbsp;&nbsp;Acq_Rel = 4,
&nbsp;&nbsp;&nbsp;&nbsp;Seq_Cst = 5,
}
</code></pre>
<h4
	id="operations" >
    Operations
</h4>
<ul>
	<li>
		<p>
            Most of the procedure have a &quot;normal&quot; and 
            <code>_explicit</code>
            &nbsp;variant.
		</p>
	</li>
	<li>
		<p>
            The &quot;normal&quot; variant will always have a memory order sequentially consistent (
            <code>.Seq_Cst</code>
            ).
		</p>
	</li>
	<li>
		<p>
            The &quot;normal&quot; variant will always have a memory order defined by the 
            <code>order</code>
            &nbsp;parameter (
            <code>Atomic_Memory_Order</code>
            ); unless specified differently.
		</p>
	</li>
</ul>
<h5
	id="load-store" >
    Load / Store
</h5>
<ul>
	<li>
		<p>
            <code>atomic_store</code>
            &nbsp;/ 
            <code>atomic_store_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically store a value into memory.
				</p>
			</li>
			<li>
				<p>
                    This procedure stores a value to a memory location in such a way that no other thread is able to see partial reads.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>atomic_load</code>
            &nbsp;/ 
            <code>atomic_load_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically load a value from memory.
				</p>
			</li>
			<li>
				<p>
                    This procedure loads a value from a memory location in such a way that the received value is not a partial read.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>atomic_exchange</code>
            &nbsp;/ 
            <code>atomic_exchange_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically exchange the value in a memory location, with the specified value.
				</p>
			</li>
			<li>
				<p>
                    This procedure loads a value from the specified memory location, and stores the specified value into that memory location. Then the loaded value is returned, all done in a single atomic operation.
				</p>
			</li>
			<li>
				<p>
                    This operation is an atomic equivalent of the following:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">Â  Â  tmp := dst^
Â  Â  dst^ = val
Â  Â  return tmp
</code></pre>
	</li>
</ul>
<h5
	id="compare-exchange" >
    Compare-Exchange
</h5>
<ul>
	<li>
		<p>
            <code>atomic_compare_exchange_strong</code>
            &nbsp;/ 
            <code>atomic_compare_exchange_strong_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically compare and exchange the value with a memory location.
				</p>
			</li>
			<li>
				<p>
                    This procedure checks if the value pointed to by the 
                    <code>dst</code>
                    &nbsp;parameter is equal to 
                    <code>old</code>
                    , and if they are, it stores the value 
                    <code>new</code>
                    &nbsp;into the memory location, all done in a single atomic operation. This procedure returns the old value stored in a memory location and a boolean value signifying whether 
                    <code>old</code>
                    &nbsp;was equal to 
                    <code>new</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This procedure is an atomic equivalent of the following operation:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">Â  Â  old_dst := dst^
Â  Â  if old_dst == old {
Â  Â  Â  Â  dst^ = new
Â  Â  Â  Â  return old_dst, true
Â  Â  } else {
Â  Â  Â  Â  return old_dst, false
Â  Â  }
</code></pre>
		<ul>
			<li>
				<p>
                    The strong version of compare exchange always returns true, when the returned old value stored in location pointed to by 
                    <code>dst</code>
                    &nbsp;and the 
                    <code>old</code>
                    &nbsp;parameter are equal.
				</p>
			</li>
			<li>
				<p>
                    Atomic compare exchange has two memory orderings: One is for the read-modify-write operation, if the comparison succeeds, and the other is for the load operation, if the comparison fails.
				</p>
			</li>
			<li>
				<p>
                    For the non-explicit version: The memory ordering for both of of these operations is sequentially-consistent.
				</p>
			</li>
			<li>
				<p>
                    For the explicit version: The memory ordering for these operations is as specified by 
                    <code>success</code>
                    &nbsp;and 
                    <code>failure</code>
                    &nbsp;parameters respectively.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>atomic_compare_exchange_weak</code>
            &nbsp;/ 
            <code>atomic_compare_exchange_weak_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically compare and exchange the value with a memory location.
				</p>
			</li>
			<li>
				<p>
                    This procedure checks if the value pointed to by the 
                    <code>dst</code>
                    &nbsp;parameter is equal to 
                    <code>old</code>
                    , and if they are, it stores the value 
                    <code>new</code>
                    &nbsp;into the memory location, all done in a single atomic operation. This procedure returns the old value stored in a memory location and a boolean value signifying whether 
                    <code>old</code>
                    &nbsp;was equal to 
                    <code>new</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This procedure is an atomic equivalent of the following operation:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">Â  Â  old_dst := dst^
Â  Â  if old_dst == old {
Â  Â  Â  Â  // may return false here
Â  Â  Â  Â  dst^ = new
Â  Â  Â  Â  return old_dst, true
Â  Â  } else {
Â  Â  Â  Â  return old_dst, false
Â  Â  }
</code></pre>
		<ul>
			<li>
				<p>
                    The weak version of compare exchange may return false, even if 
                    <code>dst^ == old</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    On some platforms running weak compare exchange in a loop is faster than a strong version.
				</p>
			</li>
			<li>
				<p>
                    Atomic compare exchange has two memory orderings: One is for the read-modify-write operation, if the comparison succeeds, and the other is for the load operation, if the comparison fails.
				</p>
			</li>
			<li>
				<p>
                    For the non-explicit version: The memory ordering for both of of these operations is sequentially-consistent.
				</p>
			</li>
			<li>
				<p>
                    For the explicit version: The memory ordering for these operations is as specified by 
                    <code>success</code>
                    &nbsp;and 
                    <code>failure</code>
                    &nbsp;parameters respectively.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="arithmetic" >
    Arithmetic
</h5>
<ul>
	<li>
		<p>
            <code>atomic_add</code>
            &nbsp;/ 
            <code>atomic_add_explicit </code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically add a value to the value stored in memory.
				</p>
			</li>
			<li>
				<p>
                    This procedure loads a value from memory, adds the specified value to it, and stores it back as an atomic operation.
				</p>
			</li>
			<li>
				<p>
                    This operation is an atomic equivalent of the following:
				</p>
			</li>
			<li>
				<p>
                    <code>dst^ += val</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>atomic_sub</code>
            &nbsp;/ 
            <code>atomic_sub_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically subtract a value from the value stored in memory.
				</p>
			</li>
			<li>
				<p>
                    This procedure loads a value from memory, subtracts the specified value from it, and stores the result back as an atomic operation.
				</p>
			</li>
			<li>
				<p>
                    This operation is an atomic equivalent of the following:
				</p>
				<ul>
					<li>
						<p>
                            <code>dst^ -= val</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="logical" >
    Logical
</h5>
<ul>
	<li>
		<p>
            <code>atomic_and</code>
            &nbsp;/ 
            <code>atomic_and_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically replace the memory location with the result of AND operation with the specified value.
				</p>
			</li>
			<li>
				<p>
                    This procedure loads a value from memory, calculates the result of AND operation between the loaded value and the specified value, and stores it back into the same memory location as an atomic operation.
				</p>
			</li>
			<li>
				<p>
                    This operation is an atomic equivalent of the following:
				</p>
				<ul>
					<li>
						<p>
                            <code>dst^ &= val</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>atomic_nand</code>
            &nbsp;/ 
            <code>atomic_nand_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically replace the memory location with the result of NAND operation with the specified value.
				</p>
			</li>
			<li>
				<p>
                    This procedure loads a value from memory, calculates the result of NAND operation between the loaded value and the specified value, and stores it back into the same memory location as an atomic operation.
				</p>
			</li>
			<li>
				<p>
                    This operation is an atomic equivalent of the following:
				</p>
				<ul>
					<li>
						<p>
                            <code>dst^ = ~(dst^ & val)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>atomic_or</code>
                    &nbsp;/ 
                    <code>atomic_or_explicit</code>
				</p>
				<ul>
					<li>
						<p>
                            Atomically replace the memory location with the result of OR operation with the specified value.
						</p>
					</li>
					<li>
						<p>
                            This procedure loads a value from memory, calculates the result of OR operation between the loaded value and the specified value, and stores it back into the same memory location as an atomic operation.
						</p>
					</li>
					<li>
						<p>
                            This operation is an atomic equivalent of the following:
						</p>
						<ul>
							<li>
								<p>
                                    <code>dst^ |= val</code>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>atomic_xor</code>
            &nbsp;/ 
            <code>atomic_xor_explicit</code>
		</p>
		<ul>
			<li>
				<p>
                    Atomically replace the memory location with the result of XOR operation with the specified value.
				</p>
			</li>
			<li>
				<p>
                    This procedure loads a value from memory, calculates the result of XOR operation between the loaded value and the specified value, and stores it back into the same memory location as an atomic operation.
				</p>
			</li>
			<li>
				<p>
                    This operation is an atomic equivalent of the following:
				</p>
			</li>
			<li>
				<p>
                    <code>dst^ ~= val</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ordering" >
    Ordering
</h5>
<ul>
	<li>
		<p>
            <code>atomic_thread_fence</code>
		</p>
		<ul>
			<li>
				<p>
                    Establish memory ordering.
				</p>
			</li>
			<li>
				<p>
                    This procedure establishes memory ordering, without an associated atomic operation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>atomic_signal_fence</code>
		</p>
		<ul>
			<li>
				<p>
                    Establish memory ordering between a current thread and a signal handler.
				</p>
			</li>
			<li>
				<p>
                    This procedure establishes memory ordering between a thread and a signal handler, that run on the same thread, without an associated atomic operation.
				</p>
			</li>
			<li>
				<p>
                    This procedure is equivalent to 
                    <code>atomic_thread_fence</code>
                    , except it doesn't issue any CPU instructions for memory ordering.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="barrier-codesync-barrier-code" >
    Barrier (
    <code>sync.Barrier</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Cond :: struct {
Â  Â  impl: _Cond,
}

Mutex :: struct {
Â  Â  impl: _Mutex,
}

Barrier :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;mutex:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mutex,
&nbsp;&nbsp;&nbsp;&nbsp;cond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cond,
&nbsp;&nbsp;&nbsp;&nbsp;index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp;generation_id: int,
&nbsp;&nbsp;&nbsp;&nbsp;thread_count:&nbsp;&nbsp;int,
}
</code></pre>
<ul>
	<li>
		<p>
            For any other OS:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

Atomic_Cond :: struct {
Â  Â  state: Futex,
}

_Cond :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;cond: Atomic_Cond,
}

Atomic_Mutex_State :: enum Futex {
Â  Â  Unlocked = 0,
Â  Â  Locked Â  = 1,
Â  Â  Waiting Â = 2,
}

Atomic_Mutex :: struct {
Â  Â  state: Atomic_Mutex_State,
}

_Mutex :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;mutex: Atomic_Mutex,
}
</code></pre>
<ul>
	<li>
		<p>
            For Windows:
		</p>
	</li>
</ul>
<pre><code class="language-Odin" data-lang="Odin">LPVOID :: rawptr

CONDITION_VARIABLE :: struct {
Â  Â  ptr: LPVOID,
}

_Cond :: struct {
Â  Â  cond: win32.CONDITION_VARIABLE,
}

SRWLOCK :: struct {
Â  Â  ptr: LPVOID,
}

_Mutex :: struct {
Â  Â  srwlock: win32.SRWLOCK,
}
</code></pre>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#barrier">
            Multithreading#Barrier
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="example" >
    Example
</h5>
<pre><code class="language-odin" data-lang="odin">THREAD_COUNT :: 4

threads: [THREAD_COUNT]^thread.Thread

sync.barrier_init(barrier, THREAD_COUNT)

for _, i in threads {
&nbsp;&nbsp;&nbsp;&nbsp;threads[i] = thread.create_and_start(proc(t: ^thread.Thread) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Same messages will be printed together but without any interleaving
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("Getting ready!")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sync.barrier_wait(barrier)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("Off their marks they go!")
&nbsp;&nbsp;&nbsp;&nbsp;})
}

for t in threads {
&nbsp;&nbsp;&nbsp;&nbsp;thread.destroy(t)
}
</code></pre>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#barrier_init" 
				class="external-link" 
				target="_blank" >
                <code>barrier_init</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Initializes the barrier for the specified amount of participant threads.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">barrier_init :: proc "contextless" (b: ^Barrier, thread_count: int) {
Â  Â  when ODIN_VALGRIND_SUPPORT {
Â  Â  Â  Â  vg.helgrind_barrier_resize_pre(b, uint(thread_count))
Â  Â  }
Â  Â  b.index = 0
Â  Â  b.generation_id = 0
Â  Â  b.thread_count = thread_count
}
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#barrier_wait" 
				class="external-link" 
				target="_blank" >
                <code>barrier_wait</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Blocks the execution of the current thread, until all threads have reached the same point in the execution of the thread proc.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">barrier_wait :: proc "contextless" (b: ^Barrier) -&gt; (is_leader: bool) {
Â  Â  when ODIN_VALGRIND_SUPPORT {
Â  Â  Â  Â  vg.helgrind_barrier_wait_pre(b)
Â  Â  }
Â  Â  guard(&b.mutex)
Â  Â  local_gen := b.generation_id
Â  Â  b.index += 1
Â  Â  if b.index &lt; b.thread_count {
Â  Â  Â  Â  for local_gen == b.generation_id && b.index &lt; b.thread_count {
Â  Â  Â  Â  Â  Â  cond_wait(&b.cond, &b.mutex)
Â  Â  Â  Â  }
Â  Â  Â  Â  return false
Â  Â  }
Â  Â  b.index = 0
Â  Â  b.generation_id += 1
Â  Â  cond_broadcast(&b.cond)
Â  Â  return true
}
</code></pre>
	</li>
</ul>
<h3
	id="semaphore-codesync-sema-code" >
    Semaphore (
    <code>sync.Sema</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

Atomic_Sema :: struct {
Â  Â  count: Futex,
}

_Sema :: struct {
Â  Â  atomic: Atomic_Sema,
}

Sema :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;impl: _Sema,
}
</code></pre>
<ul>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#semaphore">
            Multithreading#Semaphore
            </a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            : A semaphore must not be copied after first use (e.g., after posting to it). This is because, in order to coordinate with other threads, all threads must watch the same memory address to know when the lock has been released. Trying to use a copy of the lock at a different memory address will result in broken and unsafe behavior. For this reason, semaphores are marked asÂ 
            <code>#no_copy</code>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
			<input
				type="checkbox" 
				disabled=""
>
            I'm not sure how to use this.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#post" 
				class="external-link" 
				target="_blank" >
                <code>post</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#sema_post" 
						class="external-link" 
						target="_blank" >
                        <code>sema_post</code>
					</a>
				</p>
			</li>
			<li>
				<p>
                    Increment the internal counter on a semaphore by the specified amount.
				</p>
			</li>
			<li>
				<p>
                    If any of the threads were waiting on the semaphore, up to 
                    <code>count</code>
                    &nbsp;of threads will continue the execution and enter the critical section.
				</p>
			</li>
			<li>
				<p>
                    Internally it's just an 
                    <code>atomic_add_explicit</code>
                    &nbsp;+ 
                    <code>futex_signal</code>
                    &nbsp;/ 
                    <code>futex_broadcast</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">atomic_sema_post :: proc "contextless" (s: ^Atomic_Sema, count := 1) {
Â  Â  atomic_add_explicit(&s.count, Futex(count), .Release)
Â  Â  if count == 1 {
Â  Â  Â  Â  futex_signal(&s.count)
Â  Â  } else {
Â  Â  Â  Â  futex_broadcast(&s.count)
Â  Â  }
}

_sema_post :: proc "contextless" (s: ^Sema, count := 1) {
Â  Â  when ODIN_VALGRIND_SUPPORT {
Â  Â  Â  Â  vg.helgrind_sem_post_pre(s)
Â  Â  }
Â  Â  atomic_sema_post(&s.impl.atomic, count)
}

sema_post :: proc "contextless" (s: ^Sema, count := 1) {
Â  Â  _sema_post(s, count)
}
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait" 
				class="external-link" 
				target="_blank" >
                <code>wait</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#sema_wait" 
						class="external-link" 
						target="_blank" >
                        <code>sema_wait</code>
					</a>
				</p>
			</li>
			<li>
				<p>
                    Wait on a semaphore until the internal counter is non-zero.
				</p>
			</li>
			<li>
				<p>
                    This procedure blocks the execution of the current thread, until the semaphore counter is non-zero, and atomically decrements it by one, once the wait has ended.
				</p>
			</li>
			<li>
				<p>
                    Internally it's just an 
                    <code>atomic_load_explicit</code>
                    &nbsp;+ 
                    <code>futex_wait</code>
                    &nbsp;+ 
                    <code>atomic_compare_exchange_strong_explicit</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">atomic_sema_wait :: proc "contextless" (s: ^Atomic_Sema) {
Â  Â  for {
Â  Â  Â  Â  original_count := atomic_load_explicit(&s.count, .Relaxed)
Â  Â  Â  Â  for original_count == 0 {
Â  Â  Â  Â  Â  Â  futex_wait(&s.count, u32(original_count))
Â  Â  Â  Â  Â  Â  original_count = atomic_load_explicit(&s.count, .Relaxed)
Â  Â  Â  Â  }
Â  Â  Â  Â  if original_count == atomic_compare_exchange_strong_explicit(&s.count, original_count, original_count-1, .Acquire, .Acquire) {
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  }
}

_sema_wait :: proc "contextless" (s: ^Sema) {
Â  Â  atomic_sema_wait(&s.impl.atomic)
Â  Â  when ODIN_VALGRIND_SUPPORT {
Â  Â  Â  Â  vg.helgrind_sem_wait_post(s)
Â  Â  }
}

sema_wait :: proc "contextless" (s: ^Sema) {
Â  Â  _sema_wait(s)
}
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait_with_timeout" 
				class="external-link" 
				target="_blank" >
                <code>wait_with_timeout</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#sema_wait_with_timeout" 
						class="external-link" 
						target="_blank" >
                        <code>sema_wait_with_timeout</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="benaphore-codesync-benaphore-code" >
    Benaphore (
    <code>sync.Benaphore</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

Atomic_Sema :: struct {
Â  Â  count: Futex,
}

_Sema :: struct {
Â  Â  atomic: Atomic_Sema,
}

Sema :: struct {
Â  Â  impl: _Sema,
}

Benaphore :: struct {
Â  Â  counter: i32,
Â  Â  sema: Â  Â Sema,
}
</code></pre>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#benaphore">
            Multithreading#Benaphore
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
			<input
				type="checkbox" 
				disabled=""
>
            Seems like a Mutex + Semaphore combined?
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#lock" 
				class="external-link" 
				target="_blank" >
                <code>lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#benaphore_lock" 
						class="external-link" 
						target="_blank" >
                        <code>benaphore_lock</code>
					</a>
				</p>
			</li>
			<li>
				<p>
                    Acquire a lock on a benaphore. If the lock on a benaphore is already held, this procedure also blocks the execution of the current thread, until the lock could be acquired.
				</p>
			</li>
			<li>
				<p>
                    Once a lock is acquired, all threads attempting to take a lock will be blocked from entering any critical sections associated with the same benaphore, until until the lock is released.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">benaphore_lock :: proc "contextless" (b: ^Benaphore) {
Â  Â  if atomic_add_explicit(&b.counter, 1, .Acquire) &gt; 0 {
Â  Â  Â  Â  sema_wait(&b.sema)
Â  Â  }
}
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#unlock" 
				class="external-link" 
				target="_blank" >
                <code>unlock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#benaphore_unlock" 
						class="external-link" 
						target="_blank" >
                        <code>benaphore_unlock</code>
					</a>
				</p>
			</li>
			<li>
				<p>
                    Release a lock on a benaphore. If any of the threads are waiting on the lock, exactly one thread is allowed into a critical section associated with the same benaphore.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">benaphore_unlock :: proc "contextless" (b: ^Benaphore) {
Â  Â  if atomic_sub_explicit(&b.counter, 1, .Release) &gt; 1 {
Â  Â  Â  Â  sema_post(&b.sema)
Â  Â  }
}
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#try_lock" 
				class="external-link" 
				target="_blank" >
                <code>try_lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#benaphore_try_lock" 
						class="external-link" 
						target="_blank" >
                        <code>benaphore_try_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#guard" 
				class="external-link" 
				target="_blank" >
                <code>guard</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#benaphore_guard" 
						class="external-link" 
						target="_blank" >
                        <code>benaphore_guard</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="recursive-benaphore-codesync-recursive_benaphore-code" >
    Recursive Benaphore (
    <code>sync.Recursive_Benaphore</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

Atomic_Sema :: struct {
Â  Â  count: Futex,
}

_Sema :: struct {
Â  Â  atomic: Atomic_Sema,
}

Sema :: struct {
Â  Â  impl: _Sema,
}

Recursive_Benaphore :: struct {
Â  Â  counter: Â  int,
Â  Â  owner: Â  Â  int,
Â  Â  recursion: i32,
Â  Â  sema: Â  Â  Â Sema,
}
</code></pre>
<p>
    See 
    <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#recursive-benaphore">
    Multithreading#Recursive Benaphore
    </a>
    .
</p>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#lock" 
				class="external-link" 
				target="_blank" >
                <code>lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#recursive_benaphore_lock" 
						class="external-link" 
						target="_blank" >
                        <code>recursive_benaphore_lock</code>
					</a>
				</p>
			</li>
			<li>
				<p>
                    Acquire a lock on a recursive benaphore. If the benaphore is held by another thread, this function blocks until the lock can be acquired.
				</p>
			</li>
			<li>
				<p>
                    Once a lock is acquired, all other threads attempting to acquire a lock will be blocked from entering any critical sections associated with the same recursive benaphore, until the lock is released.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">recursive_benaphore_lock :: proc "contextless" (b: ^Recursive_Benaphore) {
Â  Â  tid := current_thread_id()
Â  Â  check_owner: if tid != atomic_load_explicit(&b.owner, .Acquire) {
Â  Â  Â  Â  atomic_add_explicit(&b.counter, 1, .Relaxed)
Â  Â  Â  Â  if _, ok := atomic_compare_exchange_strong_explicit(&b.owner, 0, tid, .Release, .Relaxed); ok {
Â  Â  Â  Â  Â  Â  break check_owner
Â  Â  Â  Â  }
Â  Â  Â  Â  sema_wait(&b.sema)
Â  Â  Â  Â  atomic_store_explicit(&b.owner, tid, .Release)
Â  Â  }
Â  Â  // inside the lock
Â  Â  b.recursion += 1
}
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#unlock" 
				class="external-link" 
				target="_blank" >
                <code>unlock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#recursive_benaphore_unlock" 
						class="external-link" 
						target="_blank" >
                        <code>recursive_benaphore_unlock</code>
					</a>
				</p>
			</li>
			<li>
				<p>
                    Release a lock on a recursive benaphore. It also causes the critical sections associated with the same benaphore, to become open for other threads for entering.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">recursive_benaphore_unlock :: proc "contextless" (b: ^Recursive_Benaphore) {
Â  Â  tid := current_thread_id()
Â  Â  assert_contextless(tid == atomic_load_explicit(&b.owner, .Relaxed), "tid != b.owner")
Â  Â  b.recursion -= 1
Â  Â  recursion := b.recursion
Â  Â  if recursion == 0 {
Â  Â  Â  Â  if atomic_sub_explicit(&b.counter, 1, .Relaxed) == 1 {
Â  Â  Â  Â  Â  Â  atomic_store_explicit(&b.owner, 0, .Release)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  sema_post(&b.sema)
Â  Â  Â  Â  }
Â  Â  }
Â  Â  // outside the lock
}
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#try_lock" 
				class="external-link" 
				target="_blank" >
                <code>try_lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#recursive_benaphore_try_lock" 
						class="external-link" 
						target="_blank" >
                        <code>recursive_benaphore_try_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#guard" 
				class="external-link" 
				target="_blank" >
                <code>guard</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#recursive_benaphore_guard" 
						class="external-link" 
						target="_blank" >
                        <code>recursive_benaphore_guard</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="auto-reset-event-codesync-auto_reset_event-code" >
    Auto Reset Event (
    <code>sync.Auto_Reset_Event</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Auto_Reset_Event :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;status: i32,
&nbsp;&nbsp;&nbsp;&nbsp;sema:&nbsp;&nbsp; Sema,
}
</code></pre>
<ul>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#auto-reset-event">
            Multithreading#Auto Reset Event
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<strong>
                Status
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>status ==&nbsp;&nbsp;0</code>
                    :&nbsp;&nbsp;Event is reset and no threads are waiting
				</p>
			</li>
			<li>
				<p>
                    <code>status ==&nbsp;&nbsp;1</code>
                    :&nbsp;&nbsp;Event is signalled
				</p>
			</li>
			<li>
				<p>
                    <code>status == -Â´N</code>
                    : Event is reset and N threads are waiting
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#auto_reset_event_signal" 
				class="external-link" 
				target="_blank" >
                <code>auto_reset_event_signal</code>
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#auto_reset_event_wait" 
				class="external-link" 
				target="_blank" >
                <code>auto_reset_event_wait</code>
			</a>
		</p>
	</li>
</ul>
<h3
	id="mutex-codesync-mutex-code" >
    Mutex (
    <code>sync.Mutex</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Mutex :: struct {
Â  Â  impl: _Mutex,
}
</code></pre>
<ul>
	<li>
		<p>
            For any other OS:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Atomic_Mutex_State :: enum Futex {
Â  Â  Unlocked = 0,
Â  Â  Locked Â  = 1,
Â  Â  Waiting Â = 2,
}

Atomic_Mutex :: struct {
Â  Â  state: Atomic_Mutex_State,
}

_Mutex :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;mutex: Atomic_Mutex,
}
</code></pre>
<ul>
	<li>
		<p>
            For Windows:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">LPVOID :: rawptr

SRWLOCK :: struct {
Â  Â  ptr: LPVOID,
}

_Mutex :: struct {
Â  Â  srwlock: win32.SRWLOCK,
}
</code></pre>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#mutex-mutual-exclusion-lock">
            Multithreading#Mutex (Mutual exclusion lock)
            </a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            : A Mutex must not be copied after first use (e.g., after locking it the first time). This is because, in order to coordinate with other threads, all threads must watch the same memory address to know when the lock has been released. Trying to use a copy of the lock at a different memory address will result in broken and unsafe behavior. For this reason, Mutexes are marked as 
            <code>#no_copy</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            : If the current thread attempts to lock a mutex, while it's already holding another lock, that will cause a trivial case of deadlock. Do not use 
            <code>Mutex</code>
            &nbsp;in recursive functions. In case multiple locks by the same thread are desired, use 
            <code>Recursive_Mutex</code>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#lock" 
				class="external-link" 
				target="_blank" >
                <code>lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#mutex_lock" 
						class="external-link" 
						target="_blank" >
                        <code>mutex_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#unlock" 
				class="external-link" 
				target="_blank" >
                <code>unlock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#mutex_unlock" 
						class="external-link" 
						target="_blank" >
                        <code>mutex_unlock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#try_lock" 
				class="external-link" 
				target="_blank" >
                <code>try_lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Returns 
                    <code>true</code>
                    &nbsp;if success, 
                    <code>false</code>
                    &nbsp;if failure.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#mutex_try_lock" 
						class="external-link" 
						target="_blank" >
                        <code>mutex_try_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#guard" 
				class="external-link" 
				target="_blank" >
                <code>guard</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Scope 
                    <code>lock</code>
                    &nbsp;+ 
                    <code>unlock</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#mutex_guard" 
						class="external-link" 
						target="_blank" >
                        <code>mutex_guard</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait" 
				class="external-link" 
				target="_blank" >
                <code>wait</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#cond_wait" 
						class="external-link" 
						target="_blank" >
                        <code>cond_wait</code>
					</a>
				</p>
			</li>
			<li>
				<p>
                    Wait until the condition variable is signalled and release the associated mutex.
				</p>
			</li>
			<li>
				<p>
                    This procedure blocks the current thread until the specified condition variable is signalled, or until a spurious wakeup occurs. In addition, if the condition has been signalled, this procedure releases the lock on the specified mutex.
				</p>
			</li>
			<li>
				<p>
                    The mutex must be held by the calling thread, before calling the procedure.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Note
					</strong>
                    : This procedure can return on a spurious wake-up, even if the condition variable was not signalled by a thread.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait_with_timeout" 
				class="external-link" 
				target="_blank" >
                <code>wait_with_timeout</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#cond_wait_with_timeout" 
						class="external-link" 
						target="_blank" >
                        <code>cond_wait_with_timeout</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="futex-codesync-futex-code" >
    Futex (
    <code>sync.Futex</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32
</code></pre>
<ul>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#futex-fast-userspace-mutex">
            Multithreading#Futex (Fast Userspace Mutex)
            </a>
            .
		</p>
	</li>
	<li>
		<p>
            Uses a pointer to a 32-bit value as an identifier of the queue of waiting threads. The value pointed to by that pointer can be used to store extra data.
		</p>
	</li>
	<li>
		<p>
			<strong>
                IMPORTANT
			</strong>
            : A futex must not be copied after first use (e.g., after waiting on it the first time, or signalling it). This is because, in order to coordinate with other threads, all threads must watch the same memory address. Trying to use a copy of the lock at a different memory address will result in broken and unsafe behavior.
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
            The implementations of the functions are heavy OS-dependent.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#signal" 
				class="external-link" 
				target="_blank" >
                <code>signal</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Notify one thread.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#futex_signal" 
						class="external-link" 
						target="_blank" >
                        <code>futex_signal</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#broadcast" 
				class="external-link" 
				target="_blank" >
                <code>broadcast</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Notify all threads.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#futex_broadcast" 
						class="external-link" 
						target="_blank" >
                        <code>futex_broadcast</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait" 
				class="external-link" 
				target="_blank" >
                <code>wait</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#futex_wait" 
						class="external-link" 
						target="_blank" >
                        <code>futex_wait</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait_with_timeout" 
				class="external-link" 
				target="_blank" >
                <code>wait_with_timeout</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#futex_wait_with_timeout" 
						class="external-link" 
						target="_blank" >
                        <code>futex_wait_with_timeout</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="one-shot-event-codesync-one_shot_event-code" >
    One Shot Event (
    <code>sync.One_Shot_Event</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

One_Shot_Event :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;state: Futex,
}
</code></pre>
<ul>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#one-shot-event">
            Multithreading#One Shot Event
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#one_shot_event_signal" 
				class="external-link" 
				target="_blank" >
                <code>one_shot_event_signal</code>
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#one_shot_event_wait" 
				class="external-link" 
				target="_blank" >
                <code>one_shot_event_wait</code>
			</a>
		</p>
	</li>
</ul>
<h3
	id="parker-codesync-parker-code" >
    Parker (
    <code>sync.Parker</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

Parker :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;state: Futex,
}
</code></pre>
<ul>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#parker">
            Multithreading#Parker
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#park" 
				class="external-link" 
				target="_blank" >
                <code>park</code>
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#park_with_timeout" 
				class="external-link" 
				target="_blank" >
                <code>park_with_timeout</code>
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#unpark" 
				class="external-link" 
				target="_blank" >
                <code>unpark</code>
			</a>
		</p>
	</li>
</ul>
<h3
	id="read-write-mutex-codesync-rw_mutex-code-codesys_windows-srwlock-code" >
    Read-Write Mutex (
    <code>sync.RW_Mutex</code>
    ) / (
    <code>sys_windows.SRWLock</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">RW_Mutex :: struct {
Â  Â  impl: _RW_Mutex,
}
</code></pre>
<ul>
	<li>
		<p>
            For any other OS:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

Atomic_RW_Mutex_State :: distinct uint

Atomic_Mutex_State :: enum Futex {
Â  Â  Unlocked = 0,
Â  Â  Locked Â  = 1,
Â  Â  Waiting Â = 2,
}

Atomic_Mutex :: struct {
Â  Â  state: Atomic_Mutex_State,
}

Atomic_Sema :: struct {
Â  Â  count: Futex,
}

Atomic_RW_Mutex :: struct {
Â  Â  state: Atomic_RW_Mutex_State,
Â  Â  mutex: Atomic_Mutex,
Â  Â  sema: Â Atomic_Sema,
}

_RW_Mutex :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;mutex: Atomic_RW_Mutex,
}
</code></pre>
<ul>
	<li>
		<p>
            For Windows:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">LPVOID :: rawptr

SRWLOCK :: struct {
Â  Â  ptr: LPVOID,
}

_RW_Mutex :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;srwlock: win32.SRWLOCK,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The same as _Mutex for Windows.
}
</code></pre>
<ul>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#read-write-mutex-read-write-lock">
            Multithreading#Read-Write Mutex / Read-Write Lock
            </a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            : A read-write mutex must not be copied after first use (e.g., after acquiring a lock). This is because, in order to coordinate with other threads, all threads must watch the same memory address to know when the lock has been released. Trying to use a copy of the lock at a different memory address will result in broken and unsafe behavior. For this reason, mutexes are marked as 
            <code>#no_copy</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            : A read-write mutex is not recursive. Do not attempt to acquire an exclusive lock more than once from the same thread, or an exclusive and shared lock on the same thread. Taking a shared lock multiple times is acceptable.
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#lock" 
				class="external-link" 
				target="_blank" >
                <code>lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_lock" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#unlock" 
				class="external-link" 
				target="_blank" >
                <code>unlock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_unlock" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_unlock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#try_lock" 
				class="external-link" 
				target="_blank" >
                <code>try_lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_try_lock" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_try_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#guard" 
				class="external-link" 
				target="_blank" >
                <code>guard</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_guard" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_guard</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#shared_lock" 
				class="external-link" 
				target="_blank" >
                <code>shared_lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_shared_lock" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_shared_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#shared_unlock" 
				class="external-link" 
				target="_blank" >
                <code>shared_unlock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_shared_unlock" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_shared_unlock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#try_shared_lock" 
				class="external-link" 
				target="_blank" >
                <code>try_shared_lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_try_shared_lock" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_try_shared_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#shared_guard" 
				class="external-link" 
				target="_blank" >
                <code>shared_guard</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#rw_mutex_shared_guard" 
						class="external-link" 
						target="_blank" >
                        <code>rw_mutex_shared_guard</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="once-codesync-once-code" >
    Once (
    <code>sync.Once</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Once :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;m:&nbsp;&nbsp;&nbsp;&nbsp;Mutex,
&nbsp;&nbsp;&nbsp;&nbsp;done: bool,
}
</code></pre>
<ul>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#once">
            Multithreading#Once
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#once_do" 
				class="external-link" 
				target="_blank" >
                <code>once_do</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#once_do_with_data" 
						class="external-link" 
						target="_blank" >
                        <code>once_do_with_data</code>
					</a>
				</p>
<pre><code class="language-odin" data-lang="odin">once_do_without_data :: proc(o: ^Once, fn: proc()) {
Â  Â  @(cold)
Â  Â  do_slow :: proc(o: ^Once, fn: proc()) {
Â  Â  Â  Â  guard(&o.m)
Â  Â  Â  Â  if !o.done {
Â  Â  Â  Â  Â  Â  fn()
Â  Â  Â  Â  Â  Â  atomic_store_explicit(&o.done, true, .Release)
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if atomic_load_explicit(&o.done, .Acquire) == false {
Â  Â  Â  Â  do_slow(o, fn)
Â  Â  }
}
</code></pre>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#once_do_with_data_contextless" 
						class="external-link" 
						target="_blank" >
                        <code>once_do_with_data_contextless</code>
					</a>
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#once_do_without_data" 
						class="external-link" 
						target="_blank" >
                        <code>once_do_without_data</code>
					</a>
				</p>
<pre><code class="language-odin" data-lang="odin">once_do_with_data :: proc(o: ^Once, fn: proc(data: rawptr), data: rawptr) {
Â  Â  @(cold)
Â  Â  do_slow :: proc(o: ^Once, fn: proc(data: rawptr), data: rawptr) {
Â  Â  Â  Â  guard(&o.m)
Â  Â  Â  Â  if !o.done {
Â  Â  Â  Â  Â  Â  fn(data)
Â  Â  Â  Â  Â  Â  atomic_store_explicit(&o.done, true, .Release)
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if atomic_load_explicit(&o.done, .Acquire) == false {
Â  Â  Â  Â  do_slow(o, fn, data)
Â  Â  }
}
</code></pre>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#once_do_without_data_contextless" 
						class="external-link" 
						target="_blank" >
                        <code>once_do_without_data_contextless</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ticket-mutex-codesync-ticket_mutex-code" >
    Ticket Mutex (
    <code>sync.Ticket_Mutex</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Ticket_Mutex :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;ticket:&nbsp;&nbsp;uint,
&nbsp;&nbsp;&nbsp;&nbsp;serving: uint,
}
</code></pre>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#lock" 
				class="external-link" 
				target="_blank" >
                <code>lock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#ticket_mutex_lock" 
						class="external-link" 
						target="_blank" >
                        <code>ticket_mutex_lock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#unlock" 
				class="external-link" 
				target="_blank" >
                <code>unlock</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#ticket_mutex_unlock" 
						class="external-link" 
						target="_blank" >
                        <code>ticket_mutex_unlock</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#guard" 
				class="external-link" 
				target="_blank" >
                <code>guard</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#ticket_mutex_guard" 
						class="external-link" 
						target="_blank" >
                        <code>ticket_mutex_guard</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="condition-variable-codesync-cond-code" >
    Condition Variable (
    <code>sync.Cond</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Cond :: struct {
Â  Â  impl: _Cond,
}
</code></pre>
<ul>
	<li>
		<p>
            For any other OS:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Futex :: distinct u32

Atomic_Cond :: struct {
Â  Â  state: Futex,
}

_Cond :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;cond: Atomic_Cond,
}
</code></pre>
<ul>
	<li>
		<p>
            For Windows:
		</p>
	</li>
</ul>
<pre><code class="language-Odin" data-lang="Odin">LPVOID :: rawptr

CONDITION_VARIABLE :: struct {
Â  Â  ptr: LPVOID,
}

_Cond :: struct {
Â  Â  cond: win32.CONDITION_VARIABLE,
}
</code></pre>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#condition-variable">
            Multithreading#Condition Variable
            </a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            : A condition variable must not be copied after first use (e.g., after waiting on it the first time). This is because, in order to coordinate with other threads, all threads must watch the same memory address to know when the lock has been released. Trying to use a copy of the lock at a different memory address will result in broken and unsafe behavior. For this reason, condition variables are marked as 
            <code>#no_copy</code>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#broadcast" 
				class="external-link" 
				target="_blank" >
                <code>broadcast</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#cond_broadcast" 
						class="external-link" 
						target="_blank" >
                        <code>cond_broadcast</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#signal" 
				class="external-link" 
				target="_blank" >
                <code>signal</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#cond_signal" 
						class="external-link" 
						target="_blank" >
                        <code>cond_signal</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait" 
				class="external-link" 
				target="_blank" >
                <code>wait</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#cond_wait" 
						class="external-link" 
						target="_blank" >
                        <code>cond_wait</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait_with_timeout" 
				class="external-link" 
				target="_blank" >
                <code>wait_with_timeout</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#cond_wait_with_timeout" 
						class="external-link" 
						target="_blank" >
                        <code>cond_wait_with_timeout</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="wait-group-codesync-wait_group-code" >
    Wait Group (
    <code>sync.Wait_Group</code>
    )
</h3>
<pre><code class="language-odin" data-lang="odin">Wait_Group :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;counter: int,
&nbsp;&nbsp;&nbsp;&nbsp;mutex:&nbsp;&nbsp; Mutex,
&nbsp;&nbsp;&nbsp;&nbsp;cond:&nbsp;&nbsp;&nbsp;&nbsp;Cond,
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Note
			</strong>
            : Just like any synchronization primitives, a wait group cannot be copied after first use.
		</p>
	</li>
	<li>
		<p>
            See&nbsp;&nbsp;
            <a href="/studies/Low-Level Systems/Multithreading/Multithreading.html#wait-group">
            Multithreading#Wait Group
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait_group_add" 
				class="external-link" 
				target="_blank" >
                <code>wait_group_add</code>
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait_group_done" 
				class="external-link" 
				target="_blank" >
                <code>wait_group_done</code>
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait" 
				class="external-link" 
				target="_blank" >
                <code>wait</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#wait_group_wait" 
						class="external-link" 
						target="_blank" >
                        <code>wait_group_wait</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#wait_with_timeout" 
				class="external-link" 
				target="_blank" >
                <code>wait_with_timeout</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/sync/#wait_group_wait_with_timeout" 
						class="external-link" 
						target="_blank" >
                        <code>wait_group_wait_with_timeout</code>
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-02-03 ðŸš€
			</footer>
		</div>
		<script
			src="/static/studies.45986.js" >
		</script>
	</body>
</html>
