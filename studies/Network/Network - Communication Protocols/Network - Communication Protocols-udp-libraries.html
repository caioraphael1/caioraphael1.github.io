<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.53525.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
						open="">
						<summary>
                            Network - Communication Protocols
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Communication Protocols/Network - Communication Protocols-tcp-transmission-control-protocol.html" >
                                    TCP (Transmission Control Protocol)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Communication Protocols/Network - Communication Protocols-tcp-paid-services.html" >
                                    TCP - Paid Services
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Communication Protocols/Network - Communication Protocols-udp-user-datagram-protocol.html" >
                                    UDP (User Datagram Protocol)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Network/Network - Communication Protocols/Network - Communication Protocols-udp-libraries.html" >
                                    UDP - Libraries
								</a>
								<ul>
									<li>
										<a
											href="#enet" >
                                            ENet
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#kcp-fast-and-reliable-udp-library" >
                                            KCP (Fast and Reliable UDP Library)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#quic-quick-udp-internet-connections" >
                                            QUIC (Quick UDP Internet Connections)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#reliable-udp-rudp" >
                                            Reliable UDP (RUDP)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#webrtc-web-real-time-communication" >
                                            WebRTC (Web Real-Time Communication)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#grpc-with-udp-non-native" >
                                            gRPC with UDP (non-native)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#lidgren-network" >
                                            Lidgren.Network
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#raknet" >
                                            RakNet
										</a>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Communication Protocols/Network - Communication Protocols-udp-paid-services.html" >
                                    UDP - Paid Services
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Communication Protocols/Network - Communication Protocols-higher-level-communication-protocols.html" >
                                    Higher Level Communication Protocols
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Network - Backend
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Backend/Network - Backend-network-architecture.html" >
                                    Network Architecture
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Backend/Network - Backend-socket.html" >
                                    Socket
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Backend/Network - Backend-security-and-authentication.html" >
                                    Security and Authentication
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Network - Netcode
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Netcode/Network - Netcode-netcode.html" >
                                    Netcode
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Netcode/Network - Netcode-full-synchronization-with-input-lag.html" >
                                    Full Synchronization with Input Lag
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Netcode/Network - Netcode-lag-compensation.html" >
                                    Lag Compensation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Netcode/Network - Netcode-correcting-wrong-states-or-predictions.html" >
                                    Correcting Wrong States (or Predictions)
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Network - HTTP
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - HTTP/Network - HTTP-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - HTTP/Network - HTTP-strategies.html" >
                                    Strategies
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - HTTP/Network - HTTP-structure.html" >
                                    Structure
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - HTTP/Network - HTTP-restful-representational-state-transfer-rest-api.html" >
                                    RESTful (Representational State Transfer) / REST API
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - HTTP/Network - HTTP-implementation-examples.html" >
                                    Implementation Examples
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Network - Telecom
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Telecom/Network - Telecom-notes.html" >
                                    Notes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Telecom/Network - Telecom-hardware.html" >
                                    Hardware
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Telecom/Network - Telecom-connections-and-settings.html" >
                                    Connections and Settings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Telecom/Network - Telecom-server.html" >
                                    Server
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Telecom/Network - Telecom-security-protocols.html" >
                                    Security Protocols
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Network - Telecom/Network - Telecom-vpn-proxy.html" >
                                    VPN / Proxy
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Encryption
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Encryption-hashing.html" >
                                    Hashing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Encryption-security-tests-requirements-etc.html" >
                                    Security Tests / Requirements / Etc
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Web Security
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/Web Security-inspecting-site.html" >
                                    Inspecting Site
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            SSH
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Network/SSH-ssh.html" >
                                    SSH
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        UDP - Libraries
					</h1>
					<p>
						<time
							datetime="2024-10-19" >
                            üïí Created: 2024-10-19
						</time>
						<time
							datetime="2026-01-30" >
                            | Updated: 2026-01-30
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<h3
	id="enet" >
    ENet
</h3>
<ul>
	<li>
		<p>
            Free and open-source.
		</p>
	</li>
	<li>
		<p>
            Designed for reliability over UDP with low latency.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Supports reliability and flow control over UDP.
				</p>
			</li>
			<li>
				<p>
                    Highly optimized for large-scale multiplayer games, especially for low-latency, real-time state communication.
				</p>
			</li>
			<li>
				<p>
                    Good scalability, supporting multiple clients.
				</p>
			</li>
			<li>
				<p>
                    Solid documentation and active community.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Slightly more complex implementation compared to other solutions due to fine-grained control.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                License
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    MIT License.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/zpl-c/enet" 
				class="external-link" 
				target="_blank" >
                ENet
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="http://enet.bespin.org/" 
				class="external-link" 
				target="_blank" >
                ENet
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="packet-flags-enet" >
    Packet Flags: ENet
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/lsalzman/enet/blob/657eaf97d9d335917c58484a4a4b5e03838ebd8e/include/enet/enet.h#L100" 
				class="external-link" 
				target="_blank" >
                Enet Github
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="http://enet.bespin.org/enet_8h.html#a38c59a481ed607b07d63b7bc3e88ca98" 
				class="external-link" 
				target="_blank" >
                Documentation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                ENET_PACKET_FLAG_RELIABLE:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    &quot;packet must be received by the target peer and resend attempts should be made until the packet is delivered&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ENET_PACKET_FLAG_UNSEQUENCED:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    &quot;packet will not be sequenced with other packets. not supported for reliable packets&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    &quot;packet will be fragmented using unreliable (instead of reliable) sends if it exceeds the MTU&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="packet-flags-godot" >
    Packet Flags: Godot
</h5>
<ul>
	<li>
		<p>
			<strong>
                FLAG_RELIABLE
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Mark the packet to be sent as reliable.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                FLAG_UNSEQUENCED
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Mark the packet to be sent unsequenced (unreliable).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                FLAG_UNRELIABLE_FRAGMENT
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Mark the packet to be sent unreliable even if the packet is too big and needs fragmentation (increasing the chance of it being dropped).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/godotengine/godot/blob/c2732ae4b6fa4e7b543c065bedcd92759f6db387/modules/enet/enet_multiplayer_peer.cpp#L342" 
				class="external-link" 
				target="_blank" >
                Godot Github
			</a>
            .
		</p>
<pre><code class="language-cpp" data-lang="cpp">switch (get_transfer_mode()) {
&nbsp;&nbsp;&nbsp;&nbsp;case TRANSFER_MODE_UNRELIABLE: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet_flags = ENET_PACKET_FLAG_UNSEQUENCED | ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel = SYSCH_UNRELIABLE;
&nbsp;&nbsp;&nbsp;&nbsp;} break;
&nbsp;&nbsp;&nbsp;&nbsp;case TRANSFER_MODE_UNRELIABLE_ORDERED: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet_flags = ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel = SYSCH_UNRELIABLE;
&nbsp;&nbsp;&nbsp;&nbsp;} break;
&nbsp;&nbsp;&nbsp;&nbsp;case TRANSFER_MODE_RELIABLE: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet_flags = ENET_PACKET_FLAG_RELIABLE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel = SYSCH_RELIABLE;
&nbsp;&nbsp;&nbsp;&nbsp;} break;
}
</code></pre>
	</li>
</ul>
<h5
	id="enet-reliable" >
    ENet Reliable
</h5>
<ul>
	<li>
		<p>
            ENet is based on UDP, which does not guarantee packet delivery by default. To fix this, ENet implements its own reliability system:
		</p>
	</li>
	<li>
		<p>
			<strong>
                ACKs (acknowledgment) and Retransmissions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Each reliable packet has a unique sequence number.
				</p>
			</li>
			<li>
				<p>
                    When the receiver gets a packet, it sends an ACK confirming receipt.
				</p>
			</li>
			<li>
				<p>
                    If the sender does not receive an ACK in time, it retransmits the packet.
				</p>
			</li>
			<li>
				<p>
                    This continues until the packet is confirmed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Dynamic Timeout
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ENet measures Round-Trip Time (RTT) and dynamically adjusts the retransmission time for lost packets.
				</p>
			</li>
			<li>
				<p>
                    Reduces unnecessary retransmissions and improves performance on unstable networks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example of ENet reliability
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Client sends P1, P2, P3
				</p>
			</li>
			<li>
				<p>
                    Server receives P1 and P3, but P2 is lost
				</p>
			</li>
			<li>
				<p>
                    Server sends ACKs for P1 and P3, but not P2
				</p>
			</li>
			<li>
				<p>
                    Client notices P2 was not acknowledged and retransmits it
				</p>
			</li>
			<li>
				<p>
                    Server receives P2 and sends an ACK
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="enet-reliable-vs-tcp" >
    ENet Reliable vs TCP
</h5>
<ul>
	<li>
		<p>
			<strong>
                TCP
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reliable, guarantees ordered delivery without loss, retransmitting packets as needed. But it has more overhead and may have higher latency due to congestion control and acknowledgments.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ENet (reliable)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ENet reliable is generally faster than TCP in most scenarios where it is supported.
				</p>
			</li>
			<li>
				<p>
                    Uses UDP as a base, but implements reliability with optional retransmissions and ordering. It is lighter and faster than TCP for games and low-latency networks, as it avoids some of TCP's restrictions, such as global congestion control and head-of-line blocking.
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                How does ENet avoid Head-of-Line Blocking?
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    ENet solves this problem in three main ways:
								</p>
							</li>
							<li>
								<p>
									<strong>
                                        Multiple Channels
									</strong>
								</p>
								<ul>
									<li>
										<p>
                                            In ENet, packets can be sent on different channels within the same connection.
										</p>
									</li>
									<li>
										<p>
                                            If a reliable packet is lost, only packets on that specific channel wait for retransmission.
										</p>
									</li>
									<li>
										<p>
                                            Other channels continue sending packets unaffected.
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                Example:
											</strong>
										</p>
										<ul>
											<li>
												<p>
                                                    Channel 0 sends P1, P2, P3
												</p>
											</li>
											<li>
												<p>
                                                    Channel 1 sends A1, A2, A3
												</p>
											</li>
											<li>
												<p>
                                                    If P2 (from Channel 0) is lost, only P3 waits. A1, A2, and A3 continue normally!
												</p>
											</li>
											<li>
												<p>
                                                    Result: Less delay, smoother communication
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<strong>
                                        Retransmission without blocking other packets
									</strong>
								</p>
								<ul>
									<li>
										<p>
                                            ENet only retransmits lost packets at the channel level, without blocking the delivery of independent packets.
										</p>
									</li>
									<li>
										<p>
                                            TCP, on the other hand, must guarantee global order, so a single lost packet can block everything.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<strong>
                                        Custom reliability control
									</strong>
								</p>
								<ul>
									<li>
										<p>
                                            In TCP, all packets are reliable and ordered.
										</p>
									</li>
									<li>
										<p>
                                            In ENet, you can mix reliable and unreliable packets, choosing when to guarantee delivery and when to prioritize speed.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                &quot;When would you choose to use TCP then?&quot;
			</strong>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Standard and compatible environment
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            TCP is natively supported by any operating system and does not require an extra library like ENet.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Works well with firewalls and NAT
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Since it uses established connections, TCP has fewer problems with firewalls and NAT than UDP.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Transmission of large and continuous data
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            For things like HTTP, downloads, file streaming, TCP is optimized to ensure everything arrives without loss and efficiently.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Less manual work
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            With TCP, you don't need to manage retransmissions, congestion control, or implement your own reliability logic. It handles everything automatically.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Verdict
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ENet appears superior to TCP in almost all scenarios where it is supported, especially for online games, VoIP, and other applications requiring low latency.
				</p>
			</li>
			<li>
				<p>
                    Despite ENet's advantages, TCP still has its uses, mainly because it is native across all platforms and networks.
				</p>
				<ul>
					<li>
						<p>
                            Universal compatibility ‚Äì TCP works without additional libraries, while ENet requires implementation.
						</p>
					</li>
					<li>
						<p>
                            Works better with firewalls and NAT ‚Äì Many networks block UDP (the base of ENet), while TCP is always allowed.
						</p>
					</li>
					<li>
						<p>
                            Use in non-interactive applications ‚Äì For HTTP, downloads, file streaming, TCP works very well and is already optimized for that.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="kcp-fast-and-reliable-udp-library" >
    KCP (Fast and Reliable UDP Library)
</h3>
<ul>
	<li>
		<p>
            KCP is a popular library for UDP focused on fast and reliable connections, widely used in games and network applications that require low latency.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Easy to integrate and offers customizable settings for flow control and packet loss recovery. It is a lightweight alternative to QUIC, maintaining good performance.
				</p>
			</li>
			<li>
				<p>
                    Excellent for high-latency and packet-loss environments, as it is designed to maintain reliability without sacrificing performance.
				</p>
			</li>
			<li>
				<p>
                    Widely used in games that require good scalability.
				</p>
			</li>
			<li>
				<p>
                    Simple implementation and easy to integrate.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Does not have built-in security and may require manual tuning for scalability and optimal traffic configuration.
				</p>
			</li>
			<li>
				<p>
                    Lacks advanced network control features like ENet, such as packet ordering or finely adjustable flow control.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ideal Scenarios
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Multiplayer games and applications requiring low latency and reliable transmission over networks without built-in encryption.
				</p>
			</li>
			<li>
				<p>
                    Ideal for games needing reliable communication without the costs and complexity of a protocol like TCP. KCP is efficient in MMOs where latency is critical, but some packet loss can be tolerated.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="quic-quick-udp-internet-connections" >
    QUIC (Quick UDP Internet Connections)
</h3>
<ul>
	<li>
		<p>
            Developed by Google and now an IETF standard, QUIC is a UDP-based protocol that offers built-in reliability and security features (e.g., TLS encryption).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    High scalability for multiple users, congestion control, and lost packet recovery, all with very low latency. It is one of the best options for reliable and secure data transmission over UDP.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    More complex to implement than ENet and other libraries. Also, built-in security can require more computational resources compared to lighter solutions.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ideal Scenarios
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Low-latency applications with high scalability, such as video streaming, multiplayer games, or secure web connections.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                License
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Varies by library, but Quiche, for example, is licensed under the BSD license.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="reliable-udp-rudp" >
    Reliable UDP (RUDP)
</h3>
<ul>
	<li>
		<p>
            RUDP is a UDP extension that implements reliability, providing packet acknowledgment and retransmission while maintaining the simplicity of the protocol.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Offers more control over data transmission than pure UDP but with less overhead than TCP. Facilitates scalable implementation, as it has flow control and packet acknowledgment.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    RUDP libraries can be more complex and vary in efficiency. Basic reliability may not be sufficient for data-intensive use cases.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ideal Scenarios
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Applications that need more guaranteed delivery than pure UDP but do not require the full complexity and overhead of TCP.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                License
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    License varies depending on implementation, but many are MIT or BSD.
				</p>
			</li>
			<li>
				<p>
                    Several free implementations are available, especially on GitHub, although RUDP is more of a technique than a single library.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="webrtc-web-real-time-communication" >
    WebRTC (Web Real-Time Communication)
</h3>
<ul>
	<li>
		<p>
            WebRTC enables real-time communication via UDP using data channels. It is widely used in browsers and supports NAT traversal features.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/networking/webrtc.html" 
				class="external-link" 
				target="_blank" >
                WebRTC
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Harder to implement than WebSockets and not necessary if you only need data exchange.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=WmR9IMUD_CY" 
				class="external-link" 
				target="_blank" >
                WebRTC explanation in 100 seconds
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Interesting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            WebRTC is a technology that enables real-time communication of audio, video, and data directly between browsers or devices without intermediate servers.
		</p>
	</li>
	<li>
		<p>
            It is especially useful for peer-to-peer communication and is widely used in video and voice call applications.
		</p>
	</li>
	<li>
		<p>
            It has low latency, making it ideal for real-time communication like video calls and fast file sharing.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Scalable and very useful for peer-to-peer connections. Provides built-in encryption and is free on local networks and easy to configure between browsers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Focused on peer-to-peer connections, which limits use in centralized server architectures. NAT traversal overhead may add latency.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ideal Scenarios
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Applications requiring P2P communication and moderate scalability, such as browser games or video/audio apps.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                License
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Varies depending on implementation, but most browsers that support WebRTC use permissive licenses like BSD.
				</p>
			</li>
			<li>
				<p>
                    WebRTC is a free standard with open-source implementations in browsers and communication frameworks.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="comparison-with-websockets" >
    Comparison with WebSockets
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=jth1QB32Ask" 
				class="external-link" 
				target="_blank" >
                Video call comparison between WebSockets and WebRTC
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Very cool.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Harder to implement than WebSockets and not necessary if you only need data exchange.
		</p>
	</li>
	<li>
		<p>
            WebRTC uses technologies like 
			<em>
                UDP
			</em>
            &nbsp;to transmit data, which can result in lower latency compared to TCP (protocol used by WebSockets), especially on unstable networks.
		</p>
	</li>
</ul>
<h5
	id="usage-examples" >
    Usage Examples
</h5>
<ul>
	<li>
		<p>
            Video calls and Voice (VoIP).
		</p>
	</li>
	<li>
		<p>
            File sharing.
		</p>
	</li>
	<li>
		<p>
            Real-time games.
		</p>
	</li>
</ul>
<h3
	id="grpc-with-udp-non-native" >
    gRPC with UDP (non-native)
</h3>
<ul>
	<li>
		<p>
            gRPC is a high-performance RPC library that usually works over HTTP/2 but can be adapted for UDP in some cases.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Since gRPC is widely adopted, adapting it to UDP in microservices can allow fast calls between services, with scalability in distributed systems.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Not natively UDP-based, so it requires adaptations. Scalability and performance may vary depending on the level of customization.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ideal Scenarios
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Microservice environments requiring low latency but that can forgo full reliability and robust sequencing.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                License
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Apache License 2.0.
				</p>
			</li>
			<li>
				<p>
                    gRPC is free and open-source, but adaptations are needed for use with UDP, which can be done without additional costs.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="lidgren-network" >
    Lidgren.Network
</h3>
<ul>
	<li>
		<p>
            Lidgren.Network is a network library aimed at games and is a reliable solution over UDP. It is written in C# and is popular for games requiring high performance and low latency.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Support for reliable connections and real-time communication.
				</p>
			</li>
			<li>
				<p>
                    Easy to integrate and highly optimized for game networks.
				</p>
			</li>
			<li>
				<p>
                    Designed for games with a high number of simultaneous users, with scalability capabilities.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Focused on C#, which may be a limitation if you are developing in another language.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ideal Scenario
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Perfect for MMOs written in C#, especially on platforms like Unity, where Lidgren can be easily integrated with the game engine.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                License
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    MIT License
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="raknet" >
    RakNet
</h3>
<ul>
	<li>
		<p>
            A network library widely used in multiplayer games, supporting many players and features aimed at MMOs.
		</p>
	</li>
	<li>
		<p>
			<strong>
                License
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Originally open-source under the MIT license, but later acquired by Oculus (Facebook), and the latest version is available under a commercial license.
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.53525.js" >
		</script>
	</body>
</html>
