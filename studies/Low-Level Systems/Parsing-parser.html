<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.90633.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Odin
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-overview.html" >
                                    Overview
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-my-impressions.html" >
                                    My Impressions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-installation.html" >
                                    Installation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-building.html" >
                                    Building
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-compile-time-stuff.html" >
                                    Compile-time Stuff
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-package-system.html" >
                                    Package System
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-lsp-ols-odin-language-server.html" >
                                    LSP (OLS - Odin Language Server)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-control-flow-if-when-switch-for-defer.html" >
                                    Control Flow (if, when, switch, for, defer)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-procedures.html" >
                                    Procedures
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-typing.html" >
                                    Typing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-any.html" >
                                    any
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-primitive-types.html" >
                                    Primitive Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-matrix.html" >
                                    Matrix
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-quaternion.html" >
                                    Quaternion
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-complex.html" >
                                    Complex
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-strings.html" >
                                    Strings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-rune.html" >
                                    Rune
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-maps-hash-maps.html" >
                                    Maps (Hash Maps)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-struct.html" >
                                    Struct
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-enum.html" >
                                    Enum
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-union.html" >
                                    Union
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-bit-sets.html" >
                                    Bit Sets
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-arrays.html" >
                                    Arrays
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-interfaces-methods-vtables.html" >
                                    Interfaces / Methods / VTables
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-error-handling.html" >
                                    Error Handling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-context.html" >
                                    Context
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-address.html" >
                                    Memory: Address
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-allocators.html" >
                                    Memory: Allocators
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-operations.html" >
                                    Memory: Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-entry-point.html" >
                                    Entry Point
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-multi-threading.html" >
                                    Multi-Threading
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-simd.html" >
                                    SIMD
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-directives.html" >
                                    Directives
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-ffi-foreign-function-interface-bindings.html" >
                                    FFI (Foreign Function Interface) / Bindings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-web-build.html" >
                                    Web Build
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-file-system-process-cli-shell.html" >
                                    File System / Process / CLI / Shell
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-useful-packages.html" >
                                    Useful Packages
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Memory
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-virtual-memory.html" >
                                    Virtual Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-os-memory-on-windows.html" >
                                    OS: Memory on Windows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-memory-alignment.html" >
                                    Memory Alignment
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-address.html" >
                                    Address
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-allocators.html" >
                                    Allocators
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-tools-memory-analysis.html" >
                                    Tools: Memory Analysis
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-handles-instead-of-pointers.html" >
                                    Handles instead of Pointers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-ownership-strategies-destruction-strategies.html" >
                                    Ownership Strategies / Destruction Strategies
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-strategies-for-handling-short-lived-memory.html" >
                                    Strategies for handling short lived memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-garbage-collection.html" >
                                    Garbage Collection
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-initialization.html" >
                                    Initialization
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            CPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-physical-structure.html" >
                                    Physical Structure
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-branchless.html" >
                                    Branchless
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-soa-struct-of-arrays-ecs-entity-component-system.html" >
                                    SOA (Struct Of Arrays) / ECS (Entity Component System)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-simd.html" >
                                    SIMD
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Multithreading
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-core-concepts.html" >
                                    Core Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-thread.html" >
                                    Thread
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-strategies.html" >
                                    Strategies
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-implementation-detail.html" >
                                    Implementation Detail
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-synchronization-primitives.html" >
                                    Synchronization Primitives
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-double-buffering.html" >
                                    Double-Buffering
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-networking-strategies.html" >
                                    Networking Strategies
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Handmade Hero
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero-handmade-hero.html" >
                                    Handmade Hero
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Profilers
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-tracy.html" >
                                    Tracy
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-spall.html" >
                                    Spall
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-nvidia-nsight-graphics-gpu-trace.html" >
                                    Nvidia Nsight Graphics - GPU Trace
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-amd-gpu-profiler-amd-rgp.html" >
                                    AMD GPU Profiler (AMD RGP)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-intel-gpa.html" >
                                    Intel GPA
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-nsight-systems.html" >
                                    <s>Nsight Systems</s>
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            C
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-c-standard.html" >
                                    C Standard
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-c-standard-library-libc.html" >
                                    C Standard Library (libc)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-compiling.html" >
                                    Compiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-includes.html" >
                                    Includes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-libraries.html" >
                                    Libraries
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-critiques.html" >
                                    Critiques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-integers.html" >
                                    Integers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-loops.html" >
                                    Loops
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-strings.html" >
                                    Strings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-structs.html" >
                                    Structs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-pointers.html" >
                                    Pointers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-arrays.html" >
                                    Arrays
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-preprocessors.html" >
                                    Preprocessors
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-undefined-behavior.html" >
                                    Undefined Behavior
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-windows-c-api.html" >
                                    WIndows C API
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Build Systems - Compilation - Linking
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilation-process.html" >
                                    Compilation Process
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-linker.html" >
                                    Linker
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilers.html" >
                                    Compilers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-build-tools.html" >
                                    Build Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-meta-build-tools.html" >
                                    Meta Build Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-extra-annoying-things-on-windows.html" >
                                    Extra: Annoying things on Windows
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Debuggers
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-debugging-tips.html" >
                                    Debugging Tips
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-file-types.html" >
                                    File Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-rad-debugger.html" >
                                    RAD Debugger
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-gdb-gnu-debugger.html" >
                                    GDB (GNU Debugger)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-lldb.html" >
                                    LLDB
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-vscode.html" >
                                    VSCode
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-visual-studio-debugger.html" >
                                    Visual Studio Debugger
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-others.html" >
                                    Others
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Assembly - ASM
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-my-notes.html" >
                                    My Notes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-reverse-engineering.html" >
                                    Reverse Engineering
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-assemblers.html" >
                                    Assemblers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            History of Programming
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-architectural-specifications.html" >
                                    Architectural Specifications
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-microarchitecture.html" >
                                    Microarchitecture
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-abi-application-binary-interface.html" >
                                    ABI (Application Binary Interface)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-languages.html" >
                                    Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-assembly.html" >
                                    Assembly
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Parsing
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-lexer.html" >
                                    Lexer
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Low-Level Systems/Parsing-parser.html" >
                                    Parser
								</a>
								<ul>
									<li>
										<a
											href="#parsing-strategy-direction" >
                                            Parsing strategy direction
										</a>
										<ul>
											<li>
												<a
													href="#top-down-parsing" >
                                                    Top-down Parsing
												</a>
											</li>
											<li>
												<a
													href="#bottom-up-parsing" >
                                                    Bottom-Up Parsing
												</a>
											</li>
										</ul>
									</li>
									<li>
										<a
											href="#formal-grammar-families" >
                                            Formal Grammar Families
										</a>
										<ul>
											<li>
												<a
													href="#ll-parser" >
                                                    LL parser
												</a>
											</li>
											<li>
												<a
													href="#lr-parser" >
                                                    LR parser
												</a>
											</li>
										</ul>
									</li>
									<li>
										<a
											href="#recursive-descent-parser-rd" >
                                            Recursive Descent Parser (RD)
										</a>
										<ul>
											<li>
												<a
													href="#plain-recursive-descent-ll1-style" >
                                                    Plain recursive descent (LL(1)-style)
												</a>
											</li>
											<li>
												<a
													href="#recursive-descent-with-manual-lookahead-llk" >
                                                    Recursive descent with manual lookahead (LL(k))
												</a>
											</li>
											<li>
												<a
													href="#recursive-descent-with-backtracking" >
                                                    Recursive descent with backtracking
												</a>
											</li>
											<li>
												<a
													href="#packrat-peg-parsers-memoized-recursive-descent" >
                                                    Packrat / PEG parsers (memoized recursive descent)
												</a>
											</li>
											<li>
												<a
													href="#recursive-descent-pratt-very-common-hybrid" >
                                                    Recursive descent + Pratt (very common hybrid)
												</a>
											</li>
										</ul>
									</li>
									<li>
										<a
											href="#operator-precedence-parser" >
                                            Operator-precedence Parser
										</a>
										<ul>
											<li>
												<a
													href="#top-down-operator-precedence-parser-pratt-parsing" >
                                                    Top-down Operator-Precedence Parser (Pratt Parsing)
												</a>
											</li>
											<li>
												<a
													href="#classical-operator-precedence-parsers-floyd-style" >
                                                    <s>Classical Operator-Precedence Parsers (Floyd style)</s>
												</a>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-abstract-syntax-tree-ast.html" >
                                    Abstract Syntax Tree (AST)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            JAI
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-build.html" >
                                    Build
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-types.html" >
                                    Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-meta-programming.html" >
                                    Meta programming
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-control-flow.html" >
                                    Control flow
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Serialization - Encoding
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Serialization - Encoding/Serialization - Encoding-serialization.html" >
                                    Serialization
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Serialization - Encoding/Serialization - Encoding-encoding.html" >
                                    Encoding
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Parser
					</h1>
					<p>
						<time
							datetime="2025-12-25" >
                            ðŸ•’ Created: 2025-12-25
						</time>
						<time
							datetime="2026-02-21" >
                            | Updated: 2026-02-21
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=WdlXBDHXqAs" 
				class="external-link" 
				target="_blank" >
                Quick theory around Precedence, Loop and Recursion
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    No code.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=bxpc9Pp5pZM" 
				class="external-link" 
				target="_blank" >
                Computerphile - Basic theory explanation for a parser, thinking of it as grammar/sentences
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    No code.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Chomsky grammar hierarchy:
            <br>
            0. Unrestricted.
		</p>
		<ol>
			<li>
				<p>
                    Context-sensitive.
				</p>
			</li>
			<li>
				<p>
                    Context-free.
				</p>
			</li>
			<li>
				<p>
                    Regular.
				</p>
			</li>
		</ol>
	</li>
</ul>
<h3
	id="parsing-strategy-direction" >
    Parsing strategy direction
</h3>
<ul>
	<li>
		<p>
            How the tree is built.
		</p>
	</li>
	<li>
		<p>
            How the parser is constructed relative to the grammar derivation
		</p>
	</li>
	<li>
		<p>
            Top-down â†’ builds the tree from the start symbol toward the leaves
		</p>
	</li>
	<li>
		<p>
            Bottom-up â†’ builds the tree from tokens toward the start symbol
		</p>
	</li>
	<li>
		<p>
            Formally, it corresponds to:
		</p>
		<ul>
			<li>
				<p>
                    top-down â†’ leftmost derivation
				</p>
			</li>
			<li>
				<p>
                    bottom-up â†’ reverse rightmost derivation
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="top-down-parsing" >
    Top-down Parsing
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/Top-down_parsing" 
				class="external-link" 
				target="_blank" >
                Top-down Parsing
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A top-down parser discovers and processes the hierarchical tree starting from the top, and incrementally works its way first downwards and then rightwards.
		</p>
	</li>
	<li>
		<p>
            Top-down parsing eagerly decides what a construct is much earlier, when it has only scanned the leftmost symbol of that construct and has not yet parsed any of its parts.
		</p>
	</li>
	<li>
		<p>
            Builds the parse tree from root to leaves
		</p>
	</li>
	<li>
		<p>
            Predicts productions before seeing all input
		</p>
	</li>
	<li>
		<p>
            Commonly implemented as recursive descent or LL parsers
		</p>
	</li>
	<li>
		<p>
            Pros
		</p>
		<ul>
			<li>
				<p>
                    Simple to implement by hand
				</p>
			</li>
			<li>
				<p>
                    Easy to understand and debug
				</p>
			</li>
			<li>
				<p>
                    Good error reporting
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Cons
		</p>
		<ul>
			<li>
				<p>
                    Cannot handle left-recursive grammars without rewriting
				</p>
			</li>
			<li>
				<p>
                    Less powerful grammar coverage
				</p>
			</li>
			<li>
				<p>
                    May require grammar refactoring (left factoring)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Typical use cases
		</p>
		<ul>
			<li>
				<p>
                    Hand-written parsers
				</p>
			</li>
			<li>
				<p>
                    Simple languages
				</p>
			</li>
			<li>
				<p>
                    Config formats
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="bottom-up-parsing" >
    Bottom-Up Parsing
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/Bottom-up_parsing" 
				class="external-link" 
				target="_blank" >
                Bottom-Up Parsing
			</a>
		</p>
	</li>
	<li>
		<p>
            A bottom-up parse discovers and processes that tree starting from the bottom left end, and incrementally works its way upwards and rightwards.
		</p>
	</li>
	<li>
		<p>
            A parser may act on the structure hierarchy's low, mid, and highest levels without ever creating an actual data tree; the tree is then merely implicit in the parser's actions. Bottom-up parsing patiently waits until it has scanned and parsed all parts of some construct before committing to what the combined construct is.
		</p>
	</li>
	<li>
		<p>
            If a language grammar has multiple rules that may start with the same leftmost symbols but have different endings, then that grammar can be efficiently handled by a deterministic bottom-up parse but cannot be handled top-down without guesswork and backtracking. So bottom-up parsers in practice handle a somewhat larger range of computer language grammars than deterministic top-down parsers do.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=tH5AOX9929g" 
				class="external-link" 
				target="_blank" >
                Computerphile - Parsing Bottom Up, Shift, Reduction
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Looking for a longer and longer string is called shifting.
				</p>
			</li>
			<li>
				<p>
                    Going up and making it more abstract is called reducing.
				</p>
			</li>
			<li>
				<p>
                    Bottom up is basically saying 'I want the longest possible handle'. There was an intuition around bottom up being more powerful, as you gather more contextual information.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Builds the parse tree from leaves to root
		</p>
	</li>
	<li>
		<p>
            Shifts tokens and reduces using productions
		</p>
	</li>
	<li>
		<p>
            Pros
		</p>
		<ul>
			<li>
				<p>
                    Handles a larger class of grammars
				</p>
			</li>
			<li>
				<p>
                    Naturally supports left recursion
				</p>
			</li>
			<li>
				<p>
                    Often more suitable for complex programming languages
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Cons
		</p>
		<ul>
			<li>
				<p>
                    Harder to implement manually
				</p>
			</li>
			<li>
				<p>
                    Parser tables can be complex
				</p>
			</li>
			<li>
				<p>
                    Error messages are usually worse
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Typical use cases
		</p>
		<ul>
			<li>
				<p>
                    Production compilers
				</p>
			</li>
			<li>
				<p>
                    Parser generators (Yacc/Bison)
				</p>
			</li>
			<li>
				<p>
                    Complex expression grammars
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="formal-grammar-families" >
    Formal Grammar Families
</h3>
<ul>
	<li>
		<p>
            What class of grammars can be parsed predictively.
		</p>
	</li>
	<li>
		<p>
            It is a formal language classification.
		</p>
	</li>
	<li>
		<p>
            &quot;What grammars can be parsed deterministically with limited lookahead?&quot;
		</p>
	</li>
	<li>
		<p>
			<strong>
                In practice
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    LL parsers â†’ top-down
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Except
							</em>
                            : Not all top-down parsers are LL
						</p>
						<ul>
							<li>
								<p>
                                    Examples:
								</p>
								<ul>
									<li>
										<p>
                                            Pratt parser
										</p>
									</li>
									<li>
										<p>
                                            PEG / Packrat
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    LR parsers â†’ bottom-up
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Comparing
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    LR parsers can handle a larger range of languages and grammars than precedence parsers or top-down LL parsing. This is because the LR parser waits until it has seen an entire instance of some grammar pattern before committing to what it has found. An LL parser has to decide or guess what it is seeing much sooner, when it has only seen the leftmost input symbol of that pattern.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="ll-parser" >
    LL parser
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/LL_parser" 
				class="external-link" 
				target="_blank" >
                LL Parser
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Meaning
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Left to right, performing Leftmost derivation of the sentence.
				</p>
			</li>
			<li>
				<p>
                    LL(k)
				</p>
				<ul>
					<li>
						<p>
                            L: scan left-to-right
						</p>
					</li>
					<li>
						<p>
                            L: produce leftmost derivation
						</p>
					</li>
					<li>
						<p>
                            k: k tokens of lookahead
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="lr-parser" >
    LR parser
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/LR_parser" 
				class="external-link" 
				target="_blank" >
                LR Parser
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Meaning
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    left-to-right, rightmost derivation in reverse.
				</p>
			</li>
			<li>
				<p>
                    LR(k)
				</p>
				<ul>
					<li>
						<p>
                            L: scan left-to-right
						</p>
					</li>
					<li>
						<p>
                            R: reverse rightmost derivation
						</p>
					</li>
					<li>
						<p>
                            k: k lookahead
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A type of bottom-up parser that analyze deterministic context-free languages in linear time.
		</p>
		<ul>
			<li>
				<p>
                    This is ideal for computer languages, but LR parsers are not suited for human languages which need more flexible but inevitably slower methods.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Reads input text from left to right without backing up.
		</p>
	</li>
	<li>
		<p>
            To avoid backtracking or guessing, the LR parser is allowed to peek ahead at 
            <code>k</code>
            &nbsp;lookahead input symbols before deciding how to parse earlier symbols.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Variants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        SLR parsers (Simple LR)
					</strong>
				</p>
			</li>
			<li>
				<p>
					<strong>
                        LALR parsers (Look Ahead LR)
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Look-ahead, left-to-right, rightmost derivation parser.
						</p>
					</li>
					<li>
						<p>
                            Shift-reduce parser
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    canonical LR(1) parsers
				</p>
			</li>
			<li>
				<p>
                    minimal LR(1) parsers
				</p>
			</li>
			<li>
				<p>
                    generalized LR parsers
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="recursive-descent-parser-rd" >
    Recursive Descent Parser (RD)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/Recursive_descent_parser" 
				class="external-link" 
				target="_blank" >
                Recursive Descent Parser
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It's a top-down parsing strategy where each grammar rule is implemented as a function. It remains one of the most widely used parsing approaches in modern language toolingâ€”especially for hand-written compilers, interpreters, and DSLs.
		</p>
	</li>
	<li>
		<p>
			<em>
                RD relation to LL
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    All predictive recursive descent parsers are LL parsers.
				</p>
			</li>
			<li>
				<p>
                    But not all recursive descent parsers are LL.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            excellent control over diagnostics
		</p>
	</li>
	<li>
		<p>
            easy grammar evolution
		</p>
	</li>
	<li>
		<p>
            predictable performance
		</p>
	</li>
	<li>
		<p>
            no generator dependency
		</p>
	</li>
	<li>
		<p>
            incremental parsing
		</p>
	</li>
	<li>
		<p>
            error recovery control
		</p>
	</li>
	<li>
		<p>
            partial AST construction
		</p>
	</li>
	<li>
		<p>
            fast reparsing
		</p>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Recursive descent cannot handle left recursion.
				</p>
<pre><code class="language-txt" data-lang="txt">Expr â†’ Expr "+" Term
</code></pre>
				<ul>
					<li>
						<p>
                            This would infinite-loop in RD.
						</p>
					</li>
					<li>
						<p>
                            This can be avoided by using RD with Pratt.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    LL/RD parsers cannot naturally handle highly ambiguous constructs.
				</p>
<pre><code class="language-cpp" data-lang="cpp">T(a);
</code></pre>
				<ul>
					<li>
						<p>
                            Is it:
						</p>
						<ul>
							<li>
								<p>
                                    a variable declaration?
								</p>
							</li>
							<li>
								<p>
                                    a function call?
								</p>
							</li>
							<li>
								<p>
                                    a cast?
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            LR parsers handle this more mechanically; RD requires manual disambiguation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Deep lookahead languages get messy
				</p>
				<ul>
					<li>
						<p>
                            If your language needs large lookahead, you start writing hacks.
						</p>
					</li>
				</ul>
<pre><code class="language-c" data-lang="c">if peek(p).kind == .Something &&
&nbsp;&nbsp;&nbsp;&nbsp;peek(p,2).kind == .SomethingElse &&
&nbsp;&nbsp;&nbsp;&nbsp;peek(p,3).kind == ...
</code></pre>
				<ul>
					<li>
						<p>
                            When this appears frequently, the grammar may be better suited to LR.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Error recovery is manual work
				</p>
				<ul>
					<li>
						<p>
                            Parser generators give you structured recovery.
						</p>
					</li>
					<li>
						<p>
                            With RD + Pratt you must design:
						</p>
						<ul>
							<li>
								<p>
                                    synchronization tokens
								</p>
							</li>
							<li>
								<p>
                                    recovery points
								</p>
							</li>
							<li>
								<p>
                                    diagnostic strategy
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;statements are easy with RD; expressions are hard without Pratt&quot;.
		</p>
	</li>
	<li>
		<p>
			<em>
                Used in
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Go compiler: hand-written RD + precedence climbing for expressions
				</p>
			</li>
			<li>
				<p>
                    Rust compiler: largely hand-written top-down parser
				</p>
			</li>
			<li>
				<p>
                    Swift compiler: hand-written RD
				</p>
			</li>
			<li>
				<p>
                    Extremely common in:
				</p>
				<ul>
					<li>
						<p>
                            embeddable languages
						</p>
					</li>
					<li>
						<p>
                            game scripting
						</p>
					</li>
					<li>
						<p>
                            configuration languages
						</p>
					</li>
					<li>
						<p>
                            DSLs
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    IDE parsers and tooling.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="plain-recursive-descent-ll1-style" >
    Plain recursive descent (LL(1)-style)
</h4>
<ul>
	<li>
		<p>
            The classic textbook form.
		</p>
	</li>
	<li>
		<p>
            Characteristics:
		</p>
		<ul>
			<li>
				<p>
                    one-token lookahead
				</p>
			</li>
			<li>
				<p>
                    no backtracking
				</p>
			</li>
			<li>
				<p>
                    grammar must be LL(1)
				</p>
			</li>
			<li>
				<p>
                    very fast and simple
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Used in
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    simple languages
				</p>
			</li>
			<li>
				<p>
                    teaching compilers
				</p>
			</li>
			<li>
				<p>
                    carefully designed grammars
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Limitations
		</p>
		<ul>
			<li>
				<p>
                    cannot handle left recursion
				</p>
			</li>
			<li>
				<p>
                    grammar often must be refactored
				</p>
			</li>
			<li>
				<p>
                    limited expressiveness
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Today: rarely used in pure form for real languages.
		</p>
	</li>
</ul>
<h4
	id="recursive-descent-with-manual-lookahead-llk" >
    Recursive descent with manual lookahead (LL(k))
</h4>
<ul>
	<li>
		<p>
            Most real-world RD parsers are here.
		</p>
	</li>
	<li>
		<p>
            Characteristics:
		</p>
		<ul>
			<li>
				<p>
                    multiple-token lookahead when needed
				</p>
			</li>
			<li>
				<p>
                    selective disambiguation logic
				</p>
			</li>
			<li>
				<p>
                    still mostly predictive
				</p>
			</li>
			<li>
				<p>
                    no full backtracking
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Used in
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Go
				</p>
			</li>
			<li>
				<p>
                    Swift
				</p>
			</li>
			<li>
				<p>
                    parts of Rust
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Why it works well
		</p>
		<ul>
			<li>
				<p>
                    Most programming languages are designed to be easy to parse with limited lookahead.
				</p>
			</li>
			<li>
				<p>
                    This is the dominant modern RD style.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="recursive-descent-with-backtracking" >
    Recursive descent with backtracking
</h4>
<ul>
	<li>
		<p>
            Characteristics:
		</p>
		<ul>
			<li>
				<p>
                    try one rule, rewind on failure
				</p>
			</li>
			<li>
				<p>
                    conceptually simple
				</p>
			</li>
			<li>
				<p>
                    can parse more grammars
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Pros
		</p>
		<ul>
			<li>
				<p>
                    flexible
				</p>
			</li>
			<li>
				<p>
                    easy grammar expression
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Cons
		</p>
		<ul>
			<li>
				<p>
                    potentially exponential
				</p>
			</li>
			<li>
				<p>
                    poor worst-case performance
				</p>
			</li>
			<li>
				<p>
                    tricky error messages
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Modern usage
		</p>
		<ul>
			<li>
				<p>
                    Used cautiously in:
				</p>
				<ul>
					<li>
						<p>
                            some DSL parsers
						</p>
					</li>
					<li>
						<p>
                            quick prototypes
						</p>
					</li>
					<li>
						<p>
                            parser combinator libraries
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Rare in performance-critical compilers unless heavily controlled.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="packrat-peg-parsers-memoized-recursive-descent" >
    Packrat / PEG parsers (memoized recursive descent)
</h4>
<ul>
	<li>
		<p>
            Technically still recursive descent, but with memoization.
		</p>
	</li>
	<li>
		<p>
            Characteristics:
		</p>
		<ul>
			<li>
				<p>
                    unlimited lookahead
				</p>
			</li>
			<li>
				<p>
                    linear time via memoization
				</p>
			</li>
			<li>
				<p>
                    ordered choice (PEG semantics)
				</p>
			</li>
			<li>
				<p>
                    handles many ambiguous cases cleanly
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Where used
		</p>
		<ul>
			<li>
				<p>
                    Modern parsing ecosystems such as:
				</p>
				<ul>
					<li>
						<p>
                            PEG-based language tools
						</p>
					</li>
					<li>
						<p>
                            some configuration languages
						</p>
					</li>
					<li>
						<p>
                            research and newer language implementations
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Pros:
		</p>
		<ul>
			<li>
				<p>
                    very expressive grammar
				</p>
			</li>
			<li>
				<p>
                    no LL/LR refactoring
				</p>
			</li>
			<li>
				<p>
                    deterministic
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Cons:
		</p>
		<ul>
			<li>
				<p>
                    high memory usage
				</p>
			</li>
			<li>
				<p>
                    different ambiguity semantics
				</p>
			</li>
			<li>
				<p>
                    can surprise language designers
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="recursive-descent-pratt-very-common-hybrid" >
    Recursive descent + Pratt (very common hybrid)
</h4>
<ul>
	<li>
		<p>
            This is arguably the most common real-world pattern for hand-written languages.
		</p>
	</li>
	<li>
		<p>
            Structure:
		</p>
		<ul>
			<li>
				<p>
                    recursive descent â†’ statements/declarations
				</p>
			</li>
			<li>
				<p>
                    Pratt parser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†’ expressions
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Used because:
		</p>
		<ul>
			<li>
				<p>
                    statements are easy with RD
				</p>
			</li>
			<li>
				<p>
                    expressions are hard without Pratt
				</p>
			</li>
			<li>
				<p>
                    clean separation of concerns
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Common in:
		</p>
		<ul>
			<li>
				<p>
                    interpreters
				</p>
			</li>
			<li>
				<p>
                    scripting languages
				</p>
			</li>
			<li>
				<p>
                    modern hobby/indie compilers
				</p>
			</li>
			<li>
				<p>
                    many production hand-written parsers
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="operator-precedence-parser" >
    Operator-precedence Parser
</h3>
<ul>
	<li>
		<p>
            The term operator-precedence parsing is overloaded:
		</p>
		<ul>
			<li>
				<p>
                    Classical operator-precedence parsers (Floyd, bottom-up) â†’ rare today
				</p>
			</li>
			<li>
				<p>
                    Pratt parsing (top-down operator precedence) â†’ widely used in hand-written parsers
				</p>
			</li>
			<li>
				<p>
                    They solve similar problems but are architecturally different.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="top-down-operator-precedence-parser-pratt-parsing" >
    Top-down Operator-Precedence Parser (Pratt Parsing)
</h4>
<ul>
	<li>
		<p>
            &quot;Top Down Operator-Precedence&quot;, based on recursive descent.
		</p>
	</li>
	<li>
		<p>
			<em>
                LL or LR?
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Pratt is a technique inside recursive descent, not a competing parser family like LL vs LR.
				</p>
			</li>
			<li>
				<p>
                    Pratt is not an alternative for LL or LR.
				</p>
			</li>
			<li>
				<p>
                    LL and LR are formal grammar families defined by how a parser recognizes productions in a context-free grammar. Pratt parsing is a procedural expression-parsing technique that does not fit either formal family.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Is a recursive descent parsing technique used to parse expressions with operator precedence and associativity in a very flexible way.
		</p>
	</li>
	<li>
		<p>
            Instead of using a fixed grammar with many precedence levels, Pratt parsing assigns each token two behaviors:
		</p>
		<ul>
			<li>
				<p>
                    nud (null denotation) â€” how the token behaves when it appears at the start of an expression
				</p>
			</li>
			<li>
				<p>
                    led (left denotation) â€” how the token behaves when it appears in the middle of an expression (infix/postfix)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Each operator also has a binding power (precedence) that controls how tightly it binds.
		</p>
	</li>
	<li>
		<p>
            The parser then uses a single recursive function that:
		</p>
		<ul>
			<li>
				<p>
                    Parses a prefix expression (via nud)
				</p>
			</li>
			<li>
				<p>
                    While the next operator has higher precedence than the current context:
				</p>
				<ul>
					<li>
						<p>
                            consumes the operator
						</p>
					</li>
					<li>
						<p>
                            parses the right-hand side (via led)
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=0c8b7YfsBKs" 
				class="external-link" 
				target="_blank" >
                Pratt Parsing, Binding-power
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    A bit of Rust code.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Top-down
		</p>
	</li>
	<li>
		<p>
            Hand-written
		</p>
	</li>
	<li>
		<p>
            Function-driven (nud/led)
		</p>
	</li>
	<li>
		<p>
            Expression-focused
		</p>
	</li>
	<li>
		<p>
            Extremely ergonomic
		</p>
	</li>
	<li>
		<p>
            It excels at handling:
		</p>
		<ul>
			<li>
				<p>
                    Binary operators (+ - * /)
				</p>
			</li>
			<li>
				<p>
                    Unary operators (-x, !x)
				</p>
			</li>
			<li>
				<p>
                    Postfix operators (x++, x!)
				</p>
			</li>
			<li>
				<p>
                    Mixed precedences
				</p>
			</li>
			<li>
				<p>
                    Right/left associativity
				</p>
			</li>
			<li>
				<p>
                    Custom operators
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Typical use cases
		</p>
		<ul>
			<li>
				<p>
                    Arithmetic/logical expressions
				</p>
			</li>
			<li>
				<p>
                    Scripting languages
				</p>
			</li>
			<li>
				<p>
                    DSLs
				</p>
			</li>
			<li>
				<p>
                    Many production languages' expression subsystems
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Used in
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Lua
				</p>
			</li>
			<li>
				<p>
                    JavaScript engines (hand-written parsers in some implementations)
				</p>
			</li>
			<li>
				<p>
                    Lua
				</p>
			</li>
			<li>
				<p>
                    Monkey language / Crafting Interpreters ecosystem
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Even though Pratt is popular, many production compilers instead use:
		</p>
		<ul>
			<li>
				<p>
                    Recursive descent + precedence climbing
				</p>
				<ul>
					<li>
						<p>
                            Used by:
						</p>
						<ul>
							<li>
								<p>
                                    Go compiler
								</p>
							</li>
							<li>
								<p>
                                    many C/C++ frontends
								</p>
							</li>
							<li>
								<p>
                                    some Rust tooling
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Very similar in spirit to Pratt but simpler structurally.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    LR/LALR parsers
				</p>
				<ul>
					<li>
						<p>
                            Still dominant in many large compilers via tools like Bison.
						</p>
					</li>
					<li>
						<p>
                            Used historically and currently in parts of:
						</p>
					</li>
					<li>
						<p>
                            C toolchains
						</p>
					</li>
					<li>
						<p>
                            SQL parsers
						</p>
					</li>
					<li>
						<p>
                            many legacy compilers
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Extremely complex expression grammars can stress Pratt
				</p>
				<ul>
					<li>
						<p>
                            Pratt handles most languages well, but becomes tricky with:
						</p>
						<ul>
							<li>
								<p>
                                    mixfix operators
								</p>
							</li>
							<li>
								<p>
                                    user-defined precedence
								</p>
							</li>
							<li>
								<p>
                                    context-sensitive operators
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Still solvable, but requires care.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="classical-operator-precedence-parsers-floyd-style" >
    <s>Classical Operator-Precedence Parsers (Floyd style)</s>
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/Operator-precedence_parser" 
				class="external-link" 
				target="_blank" >
                Operator-precedence Parser
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Bottom-up
		</p>
	</li>
	<li>
		<p>
            Table-driven
		</p>
	</li>
	<li>
		<p>
            Based on precedence relations between terminals
		</p>
	</li>
	<li>
		<p>
            Related to shift-reduce parsing
		</p>
	</li>
	<li>
		<p>
            Interprets an operator-precedence grammar.
		</p>
	</li>
	<li>
		<p>
			<em>
                Were used in
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Some early ALGOL compilers
				</p>
			</li>
			<li>
				<p>
                    Academic compilers for expression grammars
				</p>
			</li>
			<li>
				<p>
                    Teaching compilers in compiler textbooks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Used in
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    embedded math evaluators
				</p>
			</li>
			<li>
				<p>
                    spreadsheet formula engines
				</p>
			</li>
			<li>
				<p>
                    simple rule engines
				</p>
			</li>
			<li>
				<p>
                    legacy financial systems
				</p>
			</li>
			<li>
				<p>
                    Reason: small tables, predictable behavior.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            They were quickly displaced by LR-family parsers.
		</p>
	</li>
	<li>
		<p>
            Mostly of historical/academic interest today
		</p>
	</li>
	<li>
		<p>
            Example: most calculators use operator-precedence parsers to convert from the human-readable infix notation relying on order of operations to a format that is optimized for evaluation such as Reverse Polish notation (RPN).
		</p>
	</li>
	<li>
		<p>
            This Operator-precedence parser is not used often in practice; however they do have some properties that make them useful within a larger design. First, they are simple enough to write by hand, which is not generally the case with more sophisticated right shift-reduce parsers. Second, they can be written to consult an operator table at run time, which makes them suitable for languages that can add to or change their operators while parsing. (An example is Haskell, which allows user-defined infix operators with custom associativity and precedence; consequently, an operator-precedence parser must be run on the program after parsing of all referenced modules.)
		</p>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-2026 ðŸš€
			</footer>
		</main>
		<script
			src="/static/studies.90633.js" >
		</script>
	</body>
</html>
