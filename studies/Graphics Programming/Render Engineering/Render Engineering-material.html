<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.33995.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
								<ul>
									<li>
										<a
											href="#base-color-albedo" >
                                            Base Color / Albedo
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#roughness-value-roughness-map" >
                                            Roughness Value / Roughness Map
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#metallic-map" >
                                            Metallic Map
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#reflectance" >
                                            Reflectance
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#emission" >
                                            Emission
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#normal-map-displacement-map" >
                                            Normal Map, Displacement Map
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#ambient-occlusion-map" >
                                            Ambient Occlusion Map
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#anisotropy" >
                                            Anisotropy
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#clear-coat" >
                                            Clear Coat
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#sheen" >
                                            Sheen
										</a>
										<ul>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sizes.html" >
                                    Sizes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-fixing-artifacts.html" >
                                    Fixing Artifacts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Material
					</h1>
					<p>
						<time
							datetime="2025-07-03" >
                            üïí Created: 2025-07-03
						</time>
						<time
							datetime="2026-02-15" >
                            | Updated: 2026-02-15
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<h3
	id="base-color-albedo" >
    Base Color / Albedo
</h3>
<ul>
	<li>
		<p>
            Diffuse albedo for non-metallic surfaces, and specular color for metallic surfaces.
		</p>
	</li>
	<li>
		<p>
            Linear RGB 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            It should be devoid of lighting information, except for micro-occlusion.
		</p>
	</li>
	<li>
		<p>
			<em>
                For Non-Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Represents the reflected color and should be an sRGB value in the range 50-240 (strict range) or 30-240 (tolerant range).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                For Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Represents both the specular color and reflectance.
				</p>
			</li>
			<li>
				<p>
                    Use values with a luminosity of 67% to 100% (170-255 sRGB).
				</p>
			</li>
			<li>
				<p>
                    Oxidized or dirty metals should use a lower luminosity than clean metals to take into account the non-metallic components.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="roughness-value-roughness-map" >
    Roughness Value / Roughness Map
</h3>
<ul>
	<li>
		<p>
            Perceived smoothness (0.0) or roughness (1.0) of a surface. Smooth surfaces exhibit sharp reflections
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093528.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Rough (left), smooth (right).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093458.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Remapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911104026.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911104037.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="metallic-map" >
    Metallic Map
</h3>
<ul>
	<li>
		<p>
            Whether a surface appears to be dielectric (0.0) or conductor (1.0).
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            Is almost a binary value. Pure conductors have a metallic value of 1 and pure dielectrics have a metallic value of 0. You should try to use values close at or close to 0 and 1. Intermediate values are meant for transitions between surface types (metal to rust for instance).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093402.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Non-Metallic.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093417.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Metallic.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="reflectance" >
    Reflectance
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
            Fresnel reflectance at normal incidence for dielectric surfaces. This replaces an explicit index of refraction
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                For Non-Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Should be set to 127 sRGB (0.5 linear, 4% reflectance) if you cannot find a proper value. Do not use values under 90 sRGB (0.35 linear, 2% reflectance).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                For Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is ignored (calculated from the base color).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We will use the remapping for dielectric surfaces:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911103051.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    For 
                    <code>reflectance = 0.5</code>
                    , 
                    <code>f0 = 0.04</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The goal is to map onto a range that can represent the Fresnel values of both common dielectric surfaces (4% reflectance) and gemstones (8% to 16%).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911103131.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The mapping function is chosen to yield a 4% Fresnel reflectance value for an input reflectance of 0.5 (or 128 on a linear RGB gray scale).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911103206.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        No
					</strong>
                    &nbsp;real world material has a value under 2%.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911103248.png" width="448" >
            .
		</p>
	</li>
</ul>
<h3
	id="emission" >
    Emission
</h3>
<ul>
	<li>
		<p>
            Additional diffuse albedo to simulate emissive surfaces (such as neons, etc.) This parameter is mostly useful in an HDR pipeline with a bloom pass
		</p>
	</li>
	<li>
		<p>
            Linear RGB 
            <code>[0..1]</code>
            &nbsp;+ exposure compensation.
		</p>
	</li>
</ul>
<h3
	id="normal-map-displacement-map" >
    Normal Map, Displacement Map
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_ZbkOZNgwNk" 
				class="external-link" 
				target="_blank" >
                PBR Textures in 3 minutes
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.a23d.co/blog/different-maps-in-pbr-textures/" 
				class="external-link" 
				target="_blank" >
                PBR Textures Showcase
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=cM7RjEtZGHw" 
				class="external-link" 
				target="_blank" >
                Bump, Normal, Displacement, and Parallax Mapping
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Great video. No formulas or implementation, though.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="displacement-map" >
    Displacement Map
</h5>
<ul>
	<li>
		<p>
            Actually generate the geometry deformation; it's not faking anything.
		</p>
	</li>
	<li>
		<p>
            A lot more expensive then Bump Map or Normal Map.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911231808.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Requirements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You can have a really high-res Displacement Map, but if you don't have enough vertices to displace, then you will not get the geometric detail.
				</p>
				<ul>
					<li>
						<p>
                            This is not the same for Normal Maps; a high-res Normal Map give high detail, regardless of the vertex count.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Displacement Map vs Displacement Map + Normal Map
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The Displacement Map is usually used with a Normal Map.
				</p>
				<ul>
					<li>
						<p>
                            Just by moving vertices around, you are 
							<em>
                                not
							</em>
                            &nbsp;changing the normals. To see the visual changes, you need the normals that the geometry will have after the displacement.
						</p>
					</li>
					<li>
						<p>
                            How can I get the Normal Map? You can use the Displacement Map as a Bump Map, which will give you the information you need to get the Normal Map.
						</p>
					</li>
					<li>
						<p>
                            You should have a Normal Map if you intend to use the Displacement Map at runtime, as it's cheaper then having to calculate the normals on the fly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911232555.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    You 
					<strong>
                        can
					</strong>
                    &nbsp;use a Displacement Map without a Normal Map, but you need to &quot;apply&quot; the Displacement Map so you calculate the new normals after the Displacement.
				</p>
			</li>
			<li>
				<p>
                    If you don't apply (and thus re-calculate the surface normals), you will need a Normal Map.
				</p>
			</li>
			<li>
				<p>
                    In the end, you 
					<strong>
                        need
					</strong>
                    &nbsp;the new normals, in one way or another.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Used for
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Offline Terrain Generation.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250911232137.png" width="500" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Offline Sculptures.
				</p>
				<ul>
					<li>
						<p>
                            Some fine details that are hard to model, and you may want geometry, instead of faking with a Normal Map.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250911231924.png" width="450" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Per-Pixel Displacement Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's a technique to get the 
					<em>
                        visual
					</em>
                    &nbsp;of a displacement map, without generating new geometry.
				</p>
			</li>
			<li>
				<p>
                    The trick is not 
					<em>
                        elevating
					</em>
                    &nbsp;the geometry with the Displacement Mapping, but &quot;craving&quot; the geometry.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911233759.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Renders the green point, instead of the blue point.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This is a lot cheaper then having a Displacement Map generating the geometry, but still has a cost, as the fragment shader needs to figure out what pixel to actually shade.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Parallax Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a way to approximate the result of 
					<em>
                        Per-Pixel Displacement Mapping
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911234430.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            With 
							<em>
                                Per-Pixel Displacement Mapping
							</em>
                            , the frag shader would have to figure out what's the correct point to shade. It will look for the blue point B.
						</p>
					</li>
					<li>
						<p>
                            With 
							<em>
                                Parallax Mapping
							</em>
                            , the height between the A point and the correct height H(A) is used as an approximation to determine where the blue point B is. In this example, the technique misses the B point and reaches P, but this is the final pixel that will be drawn.
						</p>
						<ul>
							<li>
								<p>
                                    Even tho seems like a &quot;big miss&quot;, the final visual looks fine.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911234814.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911234847.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            If the surface is rotated, things begin to not look so good.
						</p>
					</li>
					<li>
						<p>
                            Looking head on is better.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Steep Parallax Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A better approximation for 
					<em>
                        Per-Pixel Displacement Mapping
					</em>
                    &nbsp;then 
					<em>
                        Parallax Mapping
					</em>
                    , but a considerable more expensive then 
					<em>
                        Parallax Mapping
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235213.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            It does multiple texture reads instead of just one, in order to determine a better &quot;stopping point&quot; for the 'correct pixel to shade'.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235433.png" width="400" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            It's better, but if the angle is too exagerated, the problem returns.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Parallax Occlusion Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A better approximation for 
					<em>
                        Per-Pixel Displacement Mapping
					</em>
                    &nbsp;then 
					<em>
                        Step Parallax Mapping
					</em>
                    , but a bit more expensive then 
					<em>
                        Step Parallax Mapping
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235525.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            It adds one extra step at the end of the 
							<em>
                                Step Parallax Mapping
							</em>
                            &nbsp;evaluation.
						</p>
					</li>
					<li>
						<p>
                            This extra step doesn't perform any new texture read, it just better guesses the 'correct pixel to shade' based on the position of the previous step and the final step.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It gives more &quot;continuity&quot; for the guesses. It's smoother.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235820.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000032.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            The stairs uses the Parallax Occlusion Mapping; it's just a flat plain.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000107.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            All the walls uses the Parallax Occlusion Mapping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000151.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000230.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                What about shadow casting?
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Displacement Mapping and all techniques that approximate the result of Displacement Mapping 
					<strong>
                        can
					</strong>
                    &nbsp;cast shadows.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000441.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://apoorvaj.io/exploring-bump-mapping-with-webgl/" 
				class="external-link" 
				target="_blank" >
                WebGL Demo of different displacement techniques
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    (2025-09-12) Didn't work on Firefox, Brave, or Chrome.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="normal-map" >
    Normal Map
</h5>
<ul>
	<li>
		<p>
			<strong>
                Tangent Space
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=htr3vELCmnY" 
						class="external-link" 
						target="_blank" >
                        Explanation, with visualization of the Tangent Space
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="http://wiki.polycount.com/wiki/Normal_Map_Technical_Details" 
						class="external-link" 
						target="_blank" >
                        Tech Details
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://terathon.com/blog/tangent-space.html" 
						class="external-link" 
						target="_blank" >
                        Tangent Space - Eric Lengyel
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            (2025-09-15)
						</p>
						<ul>
							<li>
								<p>
                                    This is the one I chose to use.
								</p>
							</li>
							<li>
								<p>
                                    RayLib does this same implementation in 
                                    <code>GenMeshTangents</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="http://www.mikktspace.com/" 
						class="external-link" 
						target="_blank" >
                        mikktspace
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The implementation is designed, specifically, to make the generation of tangent space as resilient as possible to a 3D model being moved from one application to another. That is generate the same tangent spaces even if there is a change in index list(s), ordering of faces/vertices of a face, and/or the removal of degenerate primitives. Both triangles and quads are supported.
						</p>
					</li>
					<li>
						<p>
                            This makes it easy for anyone to integrate the implementation into their own application and thus reproduce the same tangent spaces. This also makes the code a perfect candidate for an implementation standard. We hope the standard will be adopted by as many developers as possible.
						</p>
					</li>
					<li>
						<p>
                            The standard is used in Blender 2.57 and is also used by default in xNormal since version 3.17.5 in the form of a built-in tangent space plugin (binary and code).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/wrapperup/odin-mikktspace/blob/main/mikktspace.odin" 
						class="external-link" 
						target="_blank" >
                        Mikktspace in Odin
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://github.com/wrapperup/odin-mikktspace/blob/main/example/example.odin" 
								class="external-link" 
								target="_blank" >
                                Example
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Smooth Shading / Flat Shading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Apparently my procedural Meshes are smooth by default, due to my implementation.
				</p>
				<ul>
					<li>
						<p>
                            If adjacent faces share the same vertex a
						</p>
					</li>
					<li>
						<p>
                            If triangles do not share vertex normals (i.e., each triangle has its own vertex normal equal to the face normal), lighting will be flat (sharp edges between faces).nd that vertex has a single normal (an average), shading will be smooth across the faces.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Meshes coming from models may or may not be smooth, depending on how it was imported.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A RGB texture encoding surface normals (X, Y, Z).
		</p>
	</li>
	<li>
		<p>
            Overrides per-pixel normal vectors, giving the illusion of complex surface detail under lighting without changing geometry.
		</p>
	</li>
	<li>
		<p>
            Used for small details/deformations; doesn't work well for something that is too deep or elevated; the illusion breaks.
		</p>
	</li>
	<li>
		<p>
            The coordinates from the Normal Map are actually in local coordinates from the point evaluated.
		</p>
		<ul>
			<li>
				<p>
                    This make sense, as we want the normals to make sense, even if the character is moving.
				</p>
			</li>
			<li>
				<p>
                    This is why there's a lof of blue in a normal map. The more blue the map is, the less disturbed the normal of a point is.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Color intuition
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Red: inclining the normal towards the X direction (X+ == right).
				</p>
			</li>
			<li>
				<p>
                    Green: inclining towards the Y direction (Y+ == up).
				</p>
			</li>
			<li>
				<p>
                    Blue: not inclining.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911232302.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.texturecan.com/post/3/DirectX-vs-OpenGL-Normal-Map/" 
				class="external-link" 
				target="_blank" >
                NormalMap DirectX vs NormalMap OpenGL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Blending normal maps
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reoriented normal mapping
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 t = texture(baseMap,&nbsp;&nbsp; uv).xyz * vec3( 2.0,&nbsp;&nbsp;2.0, 2.0) + vec3(-1.0, -1.0,&nbsp;&nbsp;0.0);
vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,&nbsp;&nbsp;1.0, -1.0);
vec3 r = normalize(t * dot(t, u) - u * t.z);
return r;
</code></pre>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911115624.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        UDN Blending
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Its main advantage is the low number of shader instructions it requires.
						</p>
					</li>
					<li>
						<p>
                            While it leads to a reduction in details over flat areas, UDN blending is interesting if blending must be performed at runtime.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 t = texture(baseMap,&nbsp;&nbsp; uv).xyz * 2.0 - 1.0;
vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
vec3 r = normalize(t.xy + u.xy, t.z);
return r;
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="height-map" >
    ~Height Map
</h5>
<ul>
	<li>
		<p>
            Usually referred to as a Bump Map, but they aren't 
			<em>
                really
			</em>
            &nbsp;the same.
		</p>
	</li>
	<li>
		<p>
            Grayscale texture, encoding relative surface elevation; it represents the actual height/elevation values, 
			<em>
                not the variations
			</em>
            &nbsp;as a Bump Map would do.
		</p>
	</li>
	<li>
		<p>
            It can be used in different contexts:
		</p>
		<ul>
			<li>
				<p>
                    To generate normals (essentially turning it into a bump/normal map).
				</p>
			</li>
			<li>
				<p>
                    To drive 
					<strong>
                        parallax mapping
					</strong>
                    &nbsp;(screen-space depth illusion).
				</p>
			</li>
			<li>
				<p>
                    To drive 
					<strong>
                        displacement mapping
					</strong>
                    &nbsp;(real geometric change).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="bump-map" >
    <s>Bump Map</s>
</h5>
<ul>
	<li>
		<p>
            Grayscale texture where brightness represents surface height 
			<em>
                variations
			</em>
            . White = high, black = low.
		</p>
	</li>
	<li>
		<p>
            It does not store absolute &quot;height,&quot; but only brightness variations that are sampled to compute a local slope.
		</p>
	</li>
	<li>
		<p>
            No depth, no parallax.
		</p>
	</li>
	<li>
		<p>
            Very lightweight (single-channel grayscale).
		</p>
	</li>
	<li>
		<p>
            Typically used for adding simple surface detail in older or performance-constrained engines.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911232217.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            Requires additional texture reads. You have to know how the height is changing in regions around the current point.
		</p>
	</li>
	<li>
		<p>
            &quot;Would be nice to just pre-record the normals (as that what we actually want), instead of having to compute the normals through a Bump Map? Yes! That's why a Normal Map exists&quot;.
		</p>
	</li>
	<li>
		<p>
            The Normal Map stores the normals, instead of the variation of the normals, like a Bump Map.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911231258.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Visually, at runtime, they will look exactly the same; not always, but close enough; the parameters need to be the same.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Normal Map is the modernized version of a Bump Map.
		</p>
	</li>
</ul>
<h3
	id="ambient-occlusion-map" >
    Ambient Occlusion Map
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
            Defines how much of the ambient light is accessible to a surface point. It is a per-pixel shadowing factor between 0.0 and 1.0.
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            AO is an 
			<em>
                approximation of diffuse global illumination
			</em>
            , focusing purely on occlusion from nearby geometry, approximating how exposed each point in a scene is to ambient lighting.
		</p>
	</li>
	<li>
		<p>
            More specifically, it estimates the amount of indirect light that reaches a surface point by considering occlusion from nearby geometry.
		</p>
		<ul>
			<li>
				<p>
                    Areas that are tightly enclosed or near other surfaces (e.g., corners, creases) receive less ambient light and appear darker.
				</p>
			</li>
			<li>
				<p>
                    Areas that are more open or exposed receive more ambient light and appear brighter.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            AO is not full global illumination; it ignores directional light transport and color bleeding‚Äîit‚Äôs a simplified model to capture the general ‚Äúshadowing‚Äù effect of ambient light.
		</p>
	</li>
	<li>
		<p>
            The idea for Ambient Occlusion is to determine how bright or dark a region should be based on what is occluding it.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917181932.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917182017.png" width="800" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917182035.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="ambient-occlusion-map" >
    Ambient Occlusion Map
</h5>
<ul>
	<li>
		<p>
			<strong>
                Diffuse
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">// diffuse indirect
vec3 indirectDiffuse = max(irradianceSH(n), 0.0) * Fd_Lambert();

// ambient occlusion
indirectDiffuse *= texture2D(aoMap, outUV).r;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Specular
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">float f90 = clamp(dot(f0, 50.0 * 0.33), 0.0, 1.0);
// cheap luminance approximation
float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">float computeSpecularAO(float NoV, float ao, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp;return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);
}

// specular indirect
vec3 indirectSpecular = evaluateSpecularIBL(r, perceptualRoughness);

// ambient occlusion
float ao = texture2D(aoMap, outUV).r;
indirectSpecular *= computeSpecularAO(NoV, ao, roughness);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Horizon
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">// specular indirect
vec3 indirectSpecular = evaluateSpecularIBL(r, perceptualRoughness);

// horizon occlusion with falloff, should be computed for direct specular too
float horizon = min(1.0 + dot(r, n), 1.0);
indirectSpecular *= horizon * horizon;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Suggestions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    : Option 4 is the correct one, 3 is acceptable in the absence of IBL, and 1 is a non-physics-based hack.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    ~multiply only the albedo.
				</p>
				<ul>
					<li>
						<p>
                            Blender does it this way.
						</p>
					</li>
					<li>
						<p>
                            I felt that it greatly increases the contrast in the object. Even in the most illuminated points, there are dark regions.
						</p>
					</li>
					<li>
						<p>
                            If you multiply the base color texture directly by AO (texture-level multiplication), you may inadvertently change the metallic F0 appearance. Avoid multiplying the base color used for F0 in the specular path; instead apply AO only to the diffuse/indirect parts.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~multiply only the diffuse.
				</p>
				<ul>
					<li>
						<p>
                            I felt that it greatly increases the contrast in the object. Even in the most illuminated points, there are dark regions.
						</p>
					</li>
					<li>
						<p>
                            Do not multiply light_accumulation by AO ‚Äî that would darken direct lighting and specular highlights.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~multiply the ambient_final
				</p>
				<ul>
					<li>
						<p>
                            If you have no IBL yet, multiply the AO into ambient_final. Once you add IBL, multiply AO into the indirect diffuse term (the irradiance / ambient diffuse) and apply a reduced or rougness-weighted AO to the indirect specular if you want occlusion to affect glossy reflections.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    apply only to ambient indirect:
				</p>
<pre><code class="language-glsl" data-lang="glsl">// -&gt; Indirect diffuse (irradiance)
vec3 irradiance; // from diffuse irradiance probe / spherical harmonics / ambient color
// the diffuse response (Lambertian) is usually: irradiance * albedo / PI
vec3 ambient_diffuse = irradiance * (albedo * (1.0 / PI));
// apply AO to indirect diffuse (AO modulates the irradiance * albedo term)
ambient_diffuse *= ao;

// -&gt;Indirect specular (IBL)
// prefilteredSpecular and a BRDF LUT give you the specular IBL contribution:
vec3 prefilteredColor; // sample prefiltered environment map with roughness
vec2 brdfLUT; ¬† ¬† ¬† ¬† ¬†// result from split-sum integration: (scale, bias)
vec3 ambient_specular = prefilteredColor * (brdfLUT.x * F0 + brdfLUT.y);
// Optionally attenuate indirect specular by AO depending on roughness.
// Rationale: very smooth surfaces reflect far-away environment less affected by local occluders.
float specularAO = mix(1.0, ao, clamp(1.0 - roughness, 0.0, 1.0)); // lerp: smooth -&gt; less AO effect
ambient_specular *= specularAO;

// -&gt; Combine
vec3 ambient_indirect = ambient_diffuse + ambient_specular;
// final (linear)
vec3 final_color = light_accumulation + ambient_indirect + emissive;
return final_color;
</code></pre>
			</li>
		</ol>
	</li>
</ul>
<h3
	id="anisotropy" >
    Anisotropy
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
            Amount of anisotropy.
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[-1..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            Note that negative values will align the anisotropy with the bitangent direction instead of the tangent direction.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105626.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    For a rough metallic surface.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="anisotropy-specular-brdf" >
    Anisotropy Specular BRDF
</h5>
<ul>
	<li>
		<p>
            The standard material model described previously can only describe isotropic surfaces, that is, surfaces whose properties are identical in all directions. Many real-world materials, such as brushed metal, can, however, only be replicated using an anisotropic model.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105315.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                Isotropic Specular BRDF
			</em>
            &nbsp;described previously can be modified to handle anisotropic materials.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Burley's anisotropic NDF
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">float at = max(roughness * (1.0 + anisotropy), 0.001);
float ab = max(roughness * (1.0 - anisotropy), 0.001);

float D_GGX_Anisotropic(float NoH, const vec3 h,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const vec3 t, const vec3 b, float at, float ab) {
&nbsp;&nbsp;&nbsp;&nbsp;float ToH = dot(t, h);
&nbsp;&nbsp;&nbsp;&nbsp;float BoH = dot(b, h);
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = at * ab;
&nbsp;&nbsp;&nbsp;&nbsp;highp vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
&nbsp;&nbsp;&nbsp;&nbsp;highp float v2 = dot(v, v);
&nbsp;&nbsp;&nbsp;&nbsp;float w2 = a2 / v2;
&nbsp;&nbsp;&nbsp;&nbsp;return a2 * w2 * w2 * (1.0 / PI);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Anisotropic visibility function
			</strong>
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float at = max(roughness * (1.0 + anisotropy), 0.001);
float ab = max(roughness * (1.0 - anisotropy), 0.001);

float V_SmithGGXCorrelated_Anisotropic(float at, float ab, float ToV, float BoV,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float ToL, float BoL, float NoV, float NoL) {
&nbsp;&nbsp;&nbsp;&nbsp;float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
&nbsp;&nbsp;&nbsp;&nbsp;float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
&nbsp;&nbsp;&nbsp;&nbsp;float v = 0.5 / (lambdaV + lambdaL);
&nbsp;&nbsp;&nbsp;&nbsp;return saturateMediump(v);
}
</code></pre>
<h3
	id="clear-coat" >
    Clear Coat
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
			<strong>
                Clear Coat
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Strength of the clear coat layer.
				</p>
			</li>
			<li>
				<p>
                    Scalar 
                    <code>[0..1]</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Clear Coat Roughness
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Perceived smoothness or roughness of the clear coat layer.
				</p>
			</li>
			<li>
				<p>
                    Scalar 
                    <code>[0..1]</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911104913.png" width="500" >
            .
		</p>
	</li>
</ul>
<h5
	id="clear-coat-specular-brdf" >
    Clear Coat Specular BRDF
</h5>
<ul>
	<li>
		<p>
            The standard material model is a good fit for isotropic surfaces made of a single layer.
		</p>
	</li>
	<li>
		<p>
            Multi-layer materials are fairly common, particularly materials with a thin translucent layer over a standard layer.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Car paints, soda cans, lacquered wood, acrylic, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911104505.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            A clear coat layer can be simulated as an extension of the standard material model by adding a second specular lobe, which implies evaluating a second specular BRDF.
		</p>
	</li>
	<li>
		<p>
            To simplify the implementation and parameterization, the clear coat layer will always be isotropic and dielectric.
		</p>
	</li>
	<li>
		<p>
            Our model will however not simulate inter reflection and refraction behaviors.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911104550.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            It's a 
			<em>
                Cook-Torrance
			</em>
            &nbsp;specular microfacet model, with a 
			<em>
                GGX
			</em>
            &nbsp;normal distribution function, a 
			<em>
                Kelemen
			</em>
            &nbsp;visibility function, and a 
			<em>
                Schlick Fresnel
			</em>
            &nbsp;function.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Kelemen visibility term
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">float V_Kelemen(float LoH) {
&nbsp;&nbsp;&nbsp;&nbsp;return 0.25 / (LoH * LoH);
}
</code></pre>
	</li>
</ul>
<h3
	id="sheen" >
    Sheen
</h3>
<h5
	id="parameters" >
    Parameters
</h5>
<ul>
	<li>
		<p>
			<strong>
                Color
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Specular tint to create two-tone specular fabrics (defaults to 0.04 to match the standard reflectance).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Subsurface Color
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Tint for the diffuse color after scattering and absorption through the material.
				</p>
			</li>
			<li>
				<p>
                    To create a velvet-like material, the base color can be set to black (or a dark color). Chromaticity information should instead be set on the sheen color. To create more common fabrics such as denim, cotton, etc. use the base color for chromaticity and use the default sheen color or set the sheen color to the luminance of the base color.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="cloth-specular-brdf" >
    Cloth Specular BRDF
</h5>
<ul>
	<li>
		<p>
            All the material models described previously are designed to simulate dense surfaces, both at a macro and at a micro level. Clothes and fabrics are however often made of loosely connected threads that absorb and scatter incident light. The microfacet BRDFs presented earlier do a poor job of recreating the nature of cloth due to their underlying assumption that a surface is made of random grooves that behave as perfect mirrors. When compared to hard surfaces, cloth is characterized by a softer specular lobe with a large falloff and the presence of fuzz lighting, caused by forward/backward scattering. Some fabrics also exhibit two-tone specular colors (velvets for instance).
		</p>
	</li>
	<li>
		<p>
            A traditional microfacet BRDF fails to capture the appearance of a sample of denim fabric. The surface appears rigid (almost plastic-like), more similar to a tarp than a piece of clothing. This figure also shows how important the softer specular lobe caused by absorption and scattering is to the faithful recreation of the fabric.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105748.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            Velvet is an interesting use case for a cloth material model. As shown below, this type of fabric exhibits strong rim lighting due to forward and backward scattering. These scattering events are caused by fibers standing straight at the surface of the fabric. When the incident light comes from the direction opposite to the view direction, the fibers will forward-scatter the light. Similarly, when the incident light from the same direction as the view direction, the fibers will scatter the light backward.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105824.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                cloth specular BRDF
			</em>
            &nbsp;we use is a modified microfacet BRDF as described by 
			<em>
                Ashikhmin
			</em>
            &nbsp;and 
			<em>
                Premoze
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ashikhmin's Velvet NDF
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">float D_Ashikhmin(float roughness, float NoH) {
&nbsp;&nbsp;&nbsp;&nbsp;// Ashikhmin 2007, "Distribution-based BRDFs"
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = roughness * roughness;
&nbsp;&nbsp;&nbsp;&nbsp;float cos2h = NoH * NoH;
&nbsp;&nbsp;&nbsp;&nbsp;float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 &gt; 0 in fp16
&nbsp;&nbsp;&nbsp;&nbsp;float sin4h = sin2h * sin2h;
&nbsp;&nbsp;&nbsp;&nbsp;float cot2 = -cos2h / (a2 * sin2h);
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0 / (PI * (4.0 * a2 + 1.0) * sin4h) * (4.0 * exp(cot2) + sin4h);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Charlie NDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Optimized to properly fit in half float formats.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">float D_Charlie(float roughness, float NoH) {
&nbsp;&nbsp;&nbsp;&nbsp;// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
&nbsp;&nbsp;&nbsp;&nbsp;float invAlpha&nbsp;&nbsp;= 1.0 / roughness;
&nbsp;&nbsp;&nbsp;&nbsp;float cos2h = NoH * NoH;
&nbsp;&nbsp;&nbsp;&nbsp;float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 &gt; 0 in fp16
&nbsp;&nbsp;&nbsp;&nbsp;return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
</code></pre>
	</li>
</ul>
<h5
	id="cloth-diffuse-brdf" >
    Cloth Diffuse BRDF
</h5>
<ul>
	<li>
		<p>
			<strong>
                Sheen
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    To offer better control over the appearance of cloth and to give users the ability to recreate two-tone specular materials, we introduce the ability to directly modify the specular reflectance.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911110124.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Subsurface Scattering
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911110609.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.33995.js" >
		</script>
	</body>
</html>
