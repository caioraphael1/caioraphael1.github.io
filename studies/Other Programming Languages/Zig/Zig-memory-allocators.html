<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.94901.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
>
					<summary>
                        Rust
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-installation.html" >
                                Installation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-cargo.html" >
                                Cargo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-debug.html" >
                                Debug
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-imports.html" >
                                Imports
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-symbols.html" >
                                Symbols
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-keywords.html" >
                                Keywords
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-operations.html" >
                                Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-control-flow.html" >
                                Control Flow
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-types.html" >
                                Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-strings.html" >
                                Strings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-tuples.html" >
                                Tuples
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-arrays.html" >
                                Arrays
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-vectors.html" >
                                Vectors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-hash-maps.html" >
                                Hash Maps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-functions.html" >
                                Functions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-structs.html" >
                                Structs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-traits.html" >
                                Traits
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-enums.html" >
                                Enums
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-options.html" >
                                Options
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-result.html" >
                                Result
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-match.html" >
                                Match
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-iterator.html" >
                                Iterator
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Zig
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-impressions.html" >
                                Impressions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-installation.html" >
                                Installation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-build.html" >
                                Build
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-types.html" >
                                Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-error-handling.html" >
                                Error Handling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Other Programming Languages/Zig/Zig-memory-allocators.html" >
                                Memory: Allocators
							</a>
							<ul>
								<li>
									<a
										href="#areas-of-memory" >
                                        Areas of memory
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#strategies-heap-allocation" >
                                        Strategies: Heap Allocation
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#init-deinit-create-destroy" >
                                        init(), deinit(), create(), destroy()
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#warnings" >
                                        Warnings
									</a>
									<ul>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-threads.html" >
                                Threads
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-file-system.html" >
                                File System
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-others.html" >
                                Others
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Go
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go-overview.html" >
                                Overview
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go-goroutines.html" >
                                Goroutines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go-godot.html" >
                                Godot
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        C++
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-building.html" >
                                Building
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-explanations.html" >
                                Explanations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-gamedev.html" >
                                GameDev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        CSharp
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp-explanations.html" >
                                Explanations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Lua
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-functions.html" >
                                Functions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-table.html" >
                                Table
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-metatables.html" >
                                Metatables
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-control-flows.html" >
                                Control Flows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-modules.html" >
                                Modules
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Nim
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Swift
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-setup.html" >
                                Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-nullability.html" >
                                Nullability
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-error-handling.html" >
                                Error Handling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-operations.html" >
                                Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-control-flow.html" >
                                Control Flow
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-types.html" >
                                Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-functions.html" >
                                Functions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-enums.html" >
                                Enums
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-structs-and-classes.html" >
                                Structs and Classes
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Python
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-network.html" >
                                Network
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-matplotlib-graphs.html" >
                                Matplotlib (Graphs)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-pyinstaller-create-exe.html" >
                                PyInstaller (Create .exe)
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Haxe
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Kotlin
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin-syntax.html" >
                                Syntax
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Java
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java-about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Memory: Allocators
						</h1>
						<p>
							<time
								datetime="2025-01-09" >
                                ðŸ•’ Created: 2025-01-09
							</time>
							<time
								datetime="2026-01-23" >
                                | Updated: 2026-01-23
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h5
	id="injecting-the-allocator" >
    Injecting the Allocator
</h5>
<ul>
	<li>
		<p>
            One of Zig's core principle is 
			<em>
                no hidden memory allocations
			</em>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's a sharp contrast to what you'll find in C where memory is allocated with the standard library's 
                    <code>malloc</code>
                    &nbsp;function.
				</p>
			</li>
			<li>
				<p>
                    In C, if you want to know whether or not a function allocates memory, you need to read the source and look for calls to 
                    <code>malloc</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The advantage of injecting the allocator isn't just explicitness, it's also flexibility.
		</p>
		<ul>
			<li>
				<p>
                    <code>std.mem.Allocator</code>
                    &nbsp;is an interface which provides the 
                    <code>alloc</code>
                    , 
                    <code>free</code>
                    , 
                    <code>create</code>
                    &nbsp;and 
                    <code>destroy</code>
                    &nbsp;functions, along with a few others.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you're building a library, then it's best to accept an 
            <code>std.mem.Allocator</code>
            &nbsp;and let users of your library decide which allocator implementation to use. Otherwise, you'll need to chose the right allocator.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Related notes when using std.json
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Caio: &quot;is it a good idea to only use 1 allocator across the whole game? I don't know if this is even possible, but purely talking in terms of a centralized way of allocating and deallocating memory&quot;
				</p>
				<ul>
					<li>
						<p>
                            yes. you might end up wanting two allocators (one for general memory that you manage the lifetime of, and a seperate arena allocator that frees all its memory every frame)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio: &quot;seems like the function is returning a huge bag of unwanted data. I mean, all I actually want is the obj, as it is inside of it that the json data is stored. Is there a way to only return the obj and not have a leak?
				</p>
				<ul>
					<li>
						<p>
                            &quot;if memory is allocated within the function, then you need a way for the caller to free it. so with std.json.parseFromSlice(), that's by calling .deinit() on the returned value. that's a pretty common pattern.&quot;
						</p>
					</li>
					<li>
						<p>
                            Caio: &quot;if memory is allocated inside a function, return the object allocated&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;For a json parsing, the Parsed(T) includes an ArenaAllocator and the value - that's it. The ArenaAllocator holds all the memory for everything inside value&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="areas-of-memory" >
    Areas of memory
</h3>
<ul>
	<li>
		<p>
            The areas are conceptual; OS and executable enforce them.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Global space
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Stack
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Heap
			</strong>
            .
		</p>
	</li>
</ul>
<h5
	id="global-space" >
    Global Space
</h5>
<ul>
	<li>
		<p>
            The first is global space, which is where program constants, including string literals, are stored.
		</p>
	</li>
	<li>
		<p>
            All global data is baked into the binary, fully known at compile time (and thus runtime) and immutable.
		</p>
	</li>
	<li>
		<p>
            This data exists throughout the lifetime of the program, never needing more or less memory.
		</p>
	</li>
	<li>
		<p>
            Aside from the impact it has on the size of our binary, this isn't something we need to worry about at all.
		</p>
	</li>
</ul>
<h5
	id="stack-allocator" >
    Stack Allocator
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=GZ6PuLikw84" 
				class="external-link" 
				target="_blank" >
                Explanation of Allocators, focusing on Linear Allocators (Stack)
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Does not talk about the different types of allocators, only the Linear (Stack).
				</p>
			</li>
			<li>
				<p>
                    Provides a good visualization of how the Stack is used in functions.
				</p>
			</li>
			<li>
				<p>
                    The video is good, but not very detailed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The call stack is amazing because of the simple and predictable way it manages data (by pushing and popping stack frames).
				</p>
			</li>
			<li>
				<p>
                    Automatically handled by the compiler.
				</p>
			</li>
			<li>
				<p>
                    Very fast allocation and cleanup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Constraints
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Fixed total memory.
				</p>
				<ul>
					<li>
						<p>
                            &quot;You are not allowed to store GBs of memory on the stack, for example&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Fixed size.
				</p>
			</li>
			<li>
				<p>
                    Fixed lifetimes.
				</p>
				<ul>
					<li>
						<p>
                            Data has a lifetime tied to its place on the call stack.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="heap-allocator" >
    Heap Allocator
</h5>
<ul>
	<li>
		<p>
            Useful for data that has to live beyond the rigid boundaries of function scopes.
		</p>
	</li>
	<li>
		<p>
            We can create memory at runtime with a runtime-known size and have complete control over its lifetime.
		</p>
	</li>
	<li>
		<p>
            It has no built-in life cycle, so our data can live for as long or as short as necessary. And that benefit is its drawback: it has no built-in life cycle, so if we don't free data, no one will.
		</p>
		<ul>
			<li>
				<p>
                    You can allocate memory in an HTTP handler and free it in a background thread, two completely separate parts of the code.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Everything we've seen so far has been constrained by requiring an upfront size. Arrays always have a compile-time known length (in fact, the length is part of the type). All of our strings have been string literals, which have a compile-time known length.
		</p>
	</li>
	<li>
		<p>
            Furthermore, the two types of memory management strategies we've seen, global data and the call stack, while simple and efficient, are limiting. Neither can deal with dynamically sized data and both are rigid with respect to data lifetimes.
		</p>
	</li>
</ul>
<h3
	id="strategies-heap-allocation" >
    Strategies: Heap Allocation
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#fixedbuffer" 
				class="external-link" 
				target="_blank" >
                Heap Allocation Strategies
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=vHWiDx_l4V0" 
				class="external-link" 
				target="_blank" >
                Different Allocator Strategies in Zig
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    At the time, GPA (DebugAllocator) did not exist.
				</p>
			</li>
			<li>
				<p>
                    The conclusion of the video was that &quot;This is a developing area, but Zig is doing very well here, because it has no default allocator and forces you to think about allocator choice.&quot;
				</p>
			</li>
			<li>
				<p>
                    It wasnâ€™t discussed which allocator to use in each case; it was only about strategies.
				</p>
			</li>
			<li>
				<p>
                    Itâ€™s strange how this area still feels so &quot;new&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="page-allocator-quoteusing-syscallsquote" >
    Page Allocator (&quot;using syscalls&quot;)
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.page_allocator;</code>
            .
		</p>
	</li>
	<li>
		<p>
            Allocates a whole page of memory each time we ask for some memory.
		</p>
	</li>
	<li>
		<p>
            Whenever this allocator makes an allocation, it will ask your OS for entire pages of memory; an allocation of a single byte will likely reserve multiple kibibytes.
		</p>
	</li>
	<li>
		<p>
            As asking the OS for memory requires a system call, this is also extremely inefficient for speed.
		</p>
	</li>
	<li>
		<p>
            Very simple, very dumb, very wasteful.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;This is the base of most allocators, but it's not what people use directly&quot;.
				</p>
			</li>
			<li>
				<p>
                    Very slow, since it uses syscalls; &quot;massive slow in your program&quot;.
				</p>
			</li>
			<li>
				<p>
                    Wasteful.
				</p>
				<ul>
					<li>
						<p>
                            It doesnâ€™t think in terms of bytes, but pages (4KB).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = std.heap.page_allocator;

&nbsp;&nbsp;&nbsp;&nbsp;const memory = try allocator.alloc(u8, 100);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// we allocate 100 bytes as a `[]u8`.
&nbsp;&nbsp;&nbsp;&nbsp;defer allocator.free(memory);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// defer is used in conjunction with a free - this is a common pattern for memory management in Zig.
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Construction?
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const PageAllocator = struct {
&nbsp;&nbsp;&nbsp;&nbsp;pub fn alloc(self: *@This(), size: u32) []u8 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const mem = std.os.mmap( // slow (syscall)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alignForward(size, page_size)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) catch {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error.OutOfMemory;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mem[0..size];
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn free(self: *@This(), mem: []u8) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std.os.munmap(mem);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
</ul>
<h5
	id="fixedbufferallocator-quotebump-allocatorquote" >
    FixedBufferAllocator (&quot;Bump Allocator&quot;)
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.FixedBufferAllocator.init(...);</code>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#fixedbuffer" 
				class="external-link" 
				target="_blank" >
                Using FixedBufferAllocator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Is an allocator that allocates memory into a fixed buffer and does not make any heap allocations.
		</p>
	</li>
	<li>
		<p>
            Uses a fixed buffer to get its memory, doesnâ€™t ask memory from the kernel.
		</p>
	</li>
	<li>
		<p>
            It will give you the error 
            <code>OutOfMemory</code>
            &nbsp;if it has run out of bytes.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Very fast allocation.
				</p>
			</li>
			<li>
				<p>
                    Control lifetime via buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Fixed total memory.
				</p>
			</li>
			<li>
				<p>
                    Cannot free individual memory.
				</p>
				<ul>
					<li>
						<p>
                            &quot;There is no data structure, it only stores the last memory index. Therefore, you canâ€™t deallocate memory in the middle of this region.&quot;
						</p>
					</li>
					<li>
						<p>
                            &quot;Maybe itâ€™s possible to deallocate the last allocation.&quot;
						</p>
					</li>
					<li>
						<p>
                            &quot;Itâ€™s possible to clear the whole buffer.&quot;
						</p>
					</li>
					<li>
						<p>
                            <code>free</code>
                            &nbsp;and 
                            <code>destroy</code>
                            &nbsp;will only work on the last allocated/created item (think of a stack).
						</p>
						<ul>
							<li>
								<p>
                                    Freeing the non-last allocation is safe to call, but wonâ€™t do anything.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                When to use
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This is useful when heap usage is not wanted, for example, when writing a kernel.
				</p>
			</li>
			<li>
				<p>
                    It may also be considered for performance reasons.
				</p>
			</li>
			<li>
				<p>
                    &quot;If you donâ€™t care about expandable memory, you should use FixedBufferAllocator, as itâ€™s simply faster.&quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;Probably the fastest youâ€™ll ever get.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var buffer: [1000]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;var fba = std.heap.FixedBufferAllocator.init(&buffer);
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = fba.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;const memory = try allocator.alloc(u8, 100);
&nbsp;&nbsp;&nbsp;&nbsp;defer allocator.free(memory);
}
</code></pre>
	</li>
</ul>
<h5
	id="arenaallocator-quotebump-allocator-with-expandable-memoryquote" >
    ArenaAllocator (&quot;Bump Allocator with expandable memory&quot;)
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.ArenaAllocator.init(...);</code>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#arena" 
				class="external-link" 
				target="_blank" >
                Using ArenaAllocator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Itâ€™s the place where you store all data that share the same lifetime.
		</p>
	</li>
	<li>
		<p>
            Takes in a child allocator and allows you to allocate many times and only free once. Use in combination with another allocator.
		</p>
	</li>
	<li>
		<p>
            Here, 
            <code>.deinit()</code>
            &nbsp;is called on the arena, which frees all memory.
		</p>
		<ul>
			<li>
				<p>
                    Using 
                    <code>allocator.free</code>
                    &nbsp;in this example would be a no-op (i.e., does nothing).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Very fast allocation.
				</p>
			</li>
			<li>
				<p>
                    Expandable total memory.
				</p>
			</li>
			<li>
				<p>
                    Manual lifetime.
				</p>
				<ul>
					<li>
						<p>
                            &quot;Arena = One Lifetime&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Very simple way of avoiding leaks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cannot free individual memory.
				</p>
				<ul>
					<li>
						<p>
                            &quot;This ends up being useful for cases like Linked Lists, for example, since it allows freeing the entire listâ€™s memory at once without traversing it.&quot;
						</p>
					</li>
					<li>
						<p>
                            Disclaimer: &quot;Donâ€™t use Linked Lists, use arrays. Arrays are much faster nowadays.&quot;
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                When to use
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Commonly used in some places, but the problem of not being able to &quot;free individual memory&quot; can be annoying in some cases.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
&nbsp;&nbsp;&nbsp;&nbsp;defer arena.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = arena.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;_ = try allocator.alloc(u8, 1);
&nbsp;&nbsp;&nbsp;&nbsp;_ = try allocator.alloc(u8, 10);
&nbsp;&nbsp;&nbsp;&nbsp;_ = try allocator.alloc(u8, 100);
}
</code></pre>
	</li>
</ul>
<h5
	id="debugallocator-formerly-generalpurposeallocator-gpa" >
    DebugAllocator (formerly GeneralPurposeAllocator (GPA))
</h5>
<ul>
	<li>
		<p>
            <code>std.heap.DebugAllocator(.{}){};</code>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#gpa" 
				class="external-link" 
				target="_blank" >
                Using GPA
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            &quot;In debug builds, use DebugAllocator, formerly known as GPA. In release builds, use std.heap.smp_allocator.&quot;
		</p>
	</li>
	<li>
		<p>
            &quot;DebugAllocator and smp_allocator are both backed by page_allocator, which requests more memory from the operating system when it runs out.&quot;
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Designed for safety over performance, but may still be many times faster than page_allocator.
				</p>
			</li>
			<li>
				<p>
                    This is a safe allocator that can prevent double-free, use-after-free, and detect leaks.
				</p>
				<ul>
					<li>
						<p>
                            Safety checks and thread safety can be turned off via its configuration struct.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Thread-safe allocator.
				</p>
			</li>
			<li>
				<p>
                    Gets some memory first and manages buckets of memory to reduce the number of allocations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Uses
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can serve as your application's main allocator. For many programs, this will be the only allocator needed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const httpz = @import("httpz");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;// create our general purpose allocator
&nbsp;&nbsp;&nbsp;&nbsp;var gpa = std.heap.GeneralPurposeAllocator(.{}){};

&nbsp;&nbsp;&nbsp;&nbsp;// get an std.mem.Allocator from it
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = gpa.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;// pass our allocator to functions and libraries that require it
&nbsp;&nbsp;&nbsp;&nbsp;var server = try httpz.Server().init(allocator, .{.port = 5882});

&nbsp;&nbsp;&nbsp;&nbsp;var router = server.router();
&nbsp;&nbsp;&nbsp;&nbsp;router.get("/api/user/:id", getUser);

&nbsp;&nbsp;&nbsp;&nbsp;// blocks the current thread
&nbsp;&nbsp;&nbsp;&nbsp;try server.listen();
}
</code></pre>
		<ul>
			<li>
				<p>
                    (2025-03-27)
				</p>
<pre><code class="language-zig" data-lang="zig">var debugAllocator = std.heap.DebugAllocator(.{}){};
&nbsp;&nbsp;&nbsp;&nbsp;// Creates the DebugAllocator TYPE with configuration (.{})
&nbsp;&nbsp;&nbsp;&nbsp;// Using this type, an instance is obtained by {};
&nbsp;&nbsp;&nbsp;&nbsp;// debugAllocator is now an instance of the object `DebugAllocator(...)`.
&nbsp;&nbsp;&nbsp;&nbsp;// Itâ€™s important that `debugAllocator` is a VAR. If you use CONST, everything crashes at .allocator() below.
const allocator = debugAllocator.allocator();
&nbsp;&nbsp;&nbsp;&nbsp;// The internal function is used to obtain the allocator.
&nbsp;&nbsp;&nbsp;&nbsp;// allocator is of type `Allocator`.
defer {
&nbsp;&nbsp;&nbsp;&nbsp;_ = debugAllocator.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Not sure exactly why, but itâ€™s important to call .deinit() on the debugAllocator.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Interestingly, the page_allocator does not require this.
}
</code></pre>
			</li>
			<li>
				<p>
                    What is this: 
                    <code>GeneralPurposeAllocator(.{}){}</code>
                    ?
				</p>
				<ul>
					<li>
						<p>
                            <code>std.heap.GeneralPurposeAllocator</code>
                            &nbsp;is a function, and since it uses PascalCase, we know it returns a type.
						</p>
					</li>
					<li>
						<p>
                            <code>.{}</code>
                            &nbsp;is a struct initializer with an implicit type. Whatâ€™s the type and where are the fields? The type is 
                            <code>std.heap.general_purpose_allocator.Config</code>
                            , though it isnâ€™t directly exposed like this, which is one reason we arenâ€™t explicit. No fields are set because the 
                            <code>Config</code>
                            &nbsp;struct defines defaults, which weâ€™ll be using.
						</p>
					</li>
					<li>
						<p>
                            This is a common pattern with configuration / options.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="smp-allocator" >
    SMP Allocator
</h5>
<ul>
	<li>
		<p>
            ?
		</p>
	</li>
	<li>
		<p>
            Suggested for Release builds.
		</p>
	</li>
</ul>
<h5
	id="testing-allocator" >
    Testing Allocator
</h5>
<ul>
	<li>
		<p>
            <code>std.testing.allocator</code>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/heap_memory/#testing" 
				class="external-link" 
				target="_blank" >
                Using the Testing Allocator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                About
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This is a special allocator that 
					<strong>
                        only works in tests
					</strong>
                    &nbsp;and can detect memory leaks.
				</p>
			</li>
			<li>
				<p>
                    Currently, itâ€™s implemented using the 
                    <code>GeneralPurposeAllocator</code>
                    &nbsp;with added integration in Zigâ€™s test runner, but thatâ€™s an implementation detail.
				</p>
			</li>
			<li>
				<p>
                    The important thing is that if we use 
                    <code>std.testing.allocator</code>
                    &nbsp;in our 
					<strong>
                        tests
					</strong>
                    , we can catch most memory leaks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In your code, use whatever allocator is appropriate.
		</p>
	</li>
</ul>
<h5
	id="discussion-slab-allocator" >
    Discussion: Slab Allocator
</h5>
<ul>
	<li>
		<p>
            Similar to the Arena Allocator.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You can manually free memory.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Allocations have fixed sizes.
				</p>
			</li>
			<li>
				<p>
                    Metadata storage is wasteful.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="discussion-general-purpose-allocator" >
    Discussion: General Purpose Allocator
</h5>
<ul>
	<li>
		<p>
			<strong>
                About
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This type of allocator was discussed in this 
					<a
						href="https://www.youtube.com/watch?v=vHWiDx_l4V0" 
						class="external-link" 
						target="_blank" >
                        Zig talk
					</a>
                    &nbsp;from June 2020. There was no GPA yet, so everything discussed in the video and the section below is speculative.
				</p>
			</li>
			<li>
				<p>
                    Not sure if DebugAllocator / GPA is related to this concept.
				</p>
			</li>
			<li>
				<p>
                    Still, the strategic discussion is interesting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Free lists
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Advantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            You can manually free memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Disadvantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allocations have a minimum size.
						</p>
					</li>
					<li>
						<p>
                            Very slow.
						</p>
					</li>
					<li>
						<p>
                            Memory Fragmentation.
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Worse performance the longer your program is running&quot;.
								</p>
							</li>
							<li>
								<p>
                                    &quot;Thereâ€™s no way to defragment your memory, as there are pointers going everywhere and you canâ€™t really track them down&quot;.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const FreeListAllocator = struct {
&nbsp;&nbsp;&nbsp;&nbsp;root: ?*Node,

&nbsp;&nbsp;&nbsp;&nbsp;fn find(self: *@This(), size: u32) ?[]u8 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var iter = self.root;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (iter) |node| : (iter = node.next) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.size == size) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.remove(node);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return node.buffer();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn free(self: *@This(), mem: u32) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const node = Node.init(mem);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.prepend(node);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Free lists with size buckets
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This solves the Fragmentation problem, since allocations have fixed sizes; kinda; &quot;mitigated, not all gone&quot;.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Advantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            You can manually free memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Disadvantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allocations have a fixed size.
						</p>
					</li>
					<li>
						<p>
                            Cache pressure.
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Youâ€™ll probably have cache misses if youâ€™re allocating sporadically&quot;.
								</p>
							</li>
							<li>
								<p>
                                    If everything is allocated at once, there might not be cache misses, but if allocations happen occasionally, cache misses will likely occur.
								</p>
							</li>
							<li>
								<p>
                                    This makes sense when you consider that although fragmentation is avoided, this solution ends up spreading allocations that happen after deallocations.
								</p>
							</li>
							<li>
								<p>
                                    &quot;This is really bad&quot;.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="init-deinit-create-destroy" >
    init(), deinit(), create(), destroy()
</h3>
<ul>
	<li>
		<p>
            For slices: use 
            <code>alloc</code>
            &nbsp;and 
            <code>free</code>
            .
		</p>
	</li>
	<li>
		<p>
            For single items: use 
            <code>create</code>
            &nbsp;and 
            <code>destroy</code>
            .
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;

test "allocator create/destroy" {
&nbsp;&nbsp;&nbsp;&nbsp;const byte = try std.heap.page_allocator.create(u8);
&nbsp;&nbsp;&nbsp;&nbsp;defer std.heap.page_allocator.destroy(byte);
&nbsp;&nbsp;&nbsp;&nbsp;byte.* = 128;
}
</code></pre>
	</li>
</ul>
<h3
	id="warnings" >
    Warnings
</h3>
<h5
	id="double-free" >
    Double Free
</h5>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var gpa = std.heap.GeneralPurposeAllocator(.{}){};
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = gpa.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;var arr = try allocator.alloc(usize, 4);
&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(arr);
&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(arr);

&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("This won't get printed\n", .{});
}
</code></pre>
<ul>
	<li>
		<p>
            In the case of a double free, weâ€™ll get a hard crash.
		</p>
	</li>
</ul>
<h5
	id="memory-leak" >
    Memory Leak
</h5>
<pre><code class="language-zig" data-lang="zig">fn isSpecial(allocator: Allocator, name: [] const u8) !bool {
&nbsp;&nbsp;&nbsp;&nbsp;const lower = try allocLower(allocator, name);
&nbsp;&nbsp;&nbsp;&nbsp;return std.mem.eql(u8, lower, "admin");
}
</code></pre>
<ul>
	<li>
		<p>
            The memory created in 
            <code>allocLower</code>
            &nbsp;is never freed.
		</p>
	</li>
	<li>
		<p>
            Not only that, but once 
            <code>isSpecial</code>
            &nbsp;returns, it can 
			<strong>
                never
			</strong>
            &nbsp;be freed. Once 
            <code>isSpecial</code>
            &nbsp;returns, we lose our only reference to the allocated memory, the 
            <code>lower</code>
            &nbsp;variable. The memory is gone until our process exits.
		</p>
		<ul>
			<li>
				<p>
                    Damn.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Our function might only leak a few bytes, but if it's a long-running process and this function is called repeatedly, it 
			<em>
                will
			</em>
            &nbsp;add up and we'll eventually run out of memory.
		</p>
	</li>
	<li>
		<p>
            Memory leaks can be insidious. It isnâ€™t just that the root cause can be difficult to identify. Really small leaks or leaks in infrequently executed code can be even harder to detect.
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-01-23 ðŸš€
			</footer>
		</div>
		<script
			src="/static/studies.94901.js" >
		</script>
	</body>
</html>
