<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.15101.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
>
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering.html" >
                                Font Rendering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Low-Level Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers.html" >
                                Profilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Parsing.html" >
                                Parsing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Design Patterns
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - COP/Data Oriented Design - COP.html" >
                                Data Oriented Design - COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design.html" >
                                Data Oriented Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS.html" >
                                Data Oriented Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns.html" >
                                Other Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Concepts and Terminology.html" >
                                Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Rules of thumb - Laws - Guidelines and Principles/Rules of thumb - Laws - Guidelines and Principles.html" >
                                Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Paradigms.html" >
                                Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Production Methodologies/Production Methodologies.html" >
                                Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Security.html" >
                                Security
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Game Development
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game AI/Game AI.html" >
                                Game AI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Procedural Animation/Procedural Animation.html" >
                                Procedural Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game Design/Game Design.html" >
                                Game Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Level Design.html" >
                                Level Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Scanning Algorithms.html" >
                                Scanning Algorithms
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Art
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing, Color Theory, Pixel Art/Drawing, Color Theory, Pixel Art.html" >
                                Drawing, Color Theory, Pixel Art
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Low-Poly, PSX.html" >
                                Low-Poly, PSX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Animation.html" >
                                Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Texel Density.html" >
                                Texel Density
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender.html" >
                                Blender
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender - Rigging and Animation.html" >
                                Blender - Rigging and Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench.html" >
                                Blockbench
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench - Source Code.html" >
                                Blockbench - Source Code
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing Softwares.html" >
                                Drawing Softwares
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Aseprite/Aseprite.html" >
                                Aseprite
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Voxel Editors.html" >
                                Voxel Editors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/MagicaVoxel.html" >
                                MagicaVoxel
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 2D/Level Editors 2D.html" >
                                Level Editors 2D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 3D.html" >
                                Level Editors 3D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/LDtk/LDtk.html" >
                                LDtk
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/TrenchBroom.html" >
                                TrenchBroom
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Assets - Sources and References/Assets - Sources and References.html" >
                                Assets - Sources and References
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Frameworks - Libraries
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Frameworks - Libraries/Frameworks - Libraries.html" >
                                Frameworks - Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/RayLib/RayLib.html" >
                                RayLib
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Clay/Clay.html" >
                                Clay
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Physics Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines.html" >
                                Physics Engines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics.html" >
                                Physics Engines - JoltPhysics
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Godot Engine
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot/Godot.html" >
                                Godot
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDScript/Godot - GDScript.html" >
                                Godot - GDScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDExtensions.html" >
                                Godot - GDExtensions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - Source Code.html" >
                                Godot - Source Code
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Embedded Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/RaspiberryPi.html" >
                                RaspiberryPi
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Embedded Systems.html" >
                                Embedded Systems
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Platforms
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Windows/Windows.html" >
                                Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Steam/Steam.html" >
                                Steam
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Android/Android.html" >
                                Android
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/iOS/iOS.html" >
                                iOS
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Terminal
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Code Editors
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim/NeoVim.html" >
                                NeoVim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Etc
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Licenses.html" >
                                Licenses
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Unity/Unity.html" >
                                Unity
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Other Engines.html" >
                                Other Engines
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Data Oriented Design - ECS
						</h1>
						<p>
							<time
								datetime="2025-03-11" >
                                ðŸ•’ Created: 2025-03-11
							</time>
							<time
								datetime="2026-01-12" >
                                | Updated: 2026-01-12
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h5
	id="until-now" >
    Until now
</h5>
<ul>
	<li>
		<p>
            (2026-01-04)
		</p>
	</li>
	<li>
		<p>
            Using arrays to reduce branching is something very interesting.
		</p>
		<ul>
			<li>
				<p>
                    Instead of looping through entities and check if it's alive, it's interesting having 1 array of alive entities and 1 array of dead entities; this reduces an if statement.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            I'm getting the feeling that SOA and SIMD motivations were quite well explained, as one is for reducing cache misses and the other for keeping the cpu fed.
		</p>
	</li>
</ul>
<h2
	id="discussion" >
    Discussion
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://www.dataorienteddesign.com/dodbook/node1.html" 
				class="external-link" 
				target="_blank" >
                Data Oriented Design
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Very very interesting read.
				</p>
			</li>
			<li>
				<p>
                    There's quite a lot of yapping about things that don't quite correlate to the problem, but even so, it's a great read.
				</p>
			</li>
			<li>
				<p>
                    I stopped at &quot;Searching&quot; (node7); I haven't read it yet.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="critiques" >
    Critiques
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=UolgW-Ff4bA" 
				class="external-link" 
				target="_blank" >
                Ryan Fleury - Mega-Struct as an alternative to ECS
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=VWC9RT5u8gQ" 
				class="external-link" 
				target="_blank" >
                Jonathan Blow - Mega-Struct as an alternative to ECS
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            What I've heard:
		</p>
		<ul>
			<li>
				<p>
                    Performance:
				</p>
				<ul>
					<li>
						<p>
                            Unnecessary:
						</p>
						<ul>
							<li>
								<p>
                                    Entity update is usually a very miniscule thing in the frame, and if you separate the world into chunks, the goes down even harder.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Particles:
						</p>
						<ul>
							<li>
								<p>
                                    It's usually a complete separate thing than entities.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Flexibility:
				</p>
				<ul>
					<li>
						<p>
                            If you put everything an entity might possibly have into a mega-struct (CoP), you get the flexibility.
						</p>
					</li>
					<li>
						<p>
                            Use a big table of flags, explicitly turn on/off paths of execution.
						</p>
					</li>
					<li>
						<p>
                            &quot;streams of execution, instead of streams of data&quot;.
						</p>
					</li>
					<li>
						<p>
                            Don't think of &quot;doors&quot;, &quot;levers&quot;, &quot;guns&quot;, etc; do put things inside this mental model, just think of paths of execution.
						</p>
						<ul>
							<li>
								<p>
                                    ECS already does that by default, but his suggestion is do that while using a mega-struct, thinking in terms of paths of execution.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            (2026-01-12) Caio
		</p>
		<ul>
			<li>
				<p>
                    Performance.
				</p>
				<ul>
					<li>
						<p>
                            Indeed not an actual concern by looking at Tracy; most of the frame is spent doing other things.
						</p>
					</li>
					<li>
						<p>
                            And indeed, many games will not hit the entity count where having an ECS model makes a difference.
						</p>
					</li>
					<li>
						<p>
                            It's sure good having the option for easy optimization with parallelism/SIMD, but if you are trying to be efficient with your time, probably entity updates will not be this first thing in your code you'll be optimizing.
						</p>
					</li>
					<li>
						<p>
                            Tho, simply just having a dense packed array with your data in it, simple gives you the benefit of faster code due to less cache misses &quot;basically for free&quot;; sure you have to interact with the component system and there's a little bit of wasted memory, but I don't think both of these compare to how wasteful and convoluted a Mega-struct can be. My point is: coding like the processor want us to code and thus making performant code being the base line is sure great.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Flexibility:
				</p>
				<ul>
					<li>
						<p>
                            I disagree. After working with Mega-struct for some months, I see a lot of annoying things happening for having an insane branched-out code: having to manage a lot of different states and code paths, separating behavior based on some enums, or simply holding to SO MUCH DATA that will 
							<strong>
                                never
							</strong>
                            &nbsp;be used by that specific entity at any point during the whole game. All of this creates a lot of operational error, literally me just doing wrong things just by how convoluted the branched out code can be; forgetting to initialize vital structs, forgetting to turn on some behavior or turn off other behavior, etc. As there's a lot of different paths of execution, is not trivial to change the behavior of one entity. Adding new behavior or data in a specific can be quite demotivated, as now you have to go through a gigantic file, going through the scope of a bunch of things and have to constantly think whether you forgot to set up something inside that big pool of random code. One way to think about these issues is by considering how similar having to manage so many branches and states is to a State Machine; if you have worked with a complex State Machine before, you know how easily things can get out of hand and how maintenance complexity grows.
						</p>
					</li>
					<li>
						<p>
                            I'm currently implementing ECS in my engine, and I laugh at how easily it was to make the main character behave like an NPC: I commented 1 line that added a specific input move component, and added 1 line to add an AI move component, that's it.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In conclusion, having the option for easy optimization is sure great but probably not very useful in most common games, but when it comes to flexibility I don't think a Mega-struct beats the clarity and peace of mind an ECS code brings.
				</p>
			</li>
			<li>
				<p>
                    Obviously, Mega-struct is the 
					<strong>
                        absolute
					</strong>
                    &nbsp;winner when comparing with OOP; I just thought I mentioned.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="philosophy" >
    Philosophy
</h3>
<img src="assets/2026-01-07_13-45-11.png" width="400" >

<p>
    This example class includes many of the types of things found in games, where the codebase has grown organically. It's common for the Player class to have lots of helper functions to make writing game code easier. Helper functions typically consider the Player as an instance in itself, from data in save through to rendering on screen. It's not unusual for the Player class to touch nearly every aspect of a game, as the human player is the target of the code in the first place, the Player class is going to reference nearly everything too.
</p>
<p>
    AI characters will have similarly gnarly looking classes if they are generalized rather than specialized. Specializing AI was more commonplace when games needed to fit in smaller machines, but now, because the Player class has to interact with many of them over the course of the game, they tend to be unified into one type just like the player, if not the same as the player, to help simplify the code that allows them to interact. As of writing, the way in which AI is differentiated is mostly by data, with behavior trees taking the main stage for driving how AI thinks about its world. Behavior trees are another concept subject to various interpretations, so some forms are data-oriented design friendly, and others are not.
</p>
<p>
    A recurring theme in articles and post-mortems from people moving from object-oriented hierarchies of gameplay classes to a component based approach is the transitional states of turning their classes into containers of smaller objects, an approach often called composition. This transitional form takes an existing class and finds the boundaries between concepts internal to the class and attempts to refactor them out into new classes which can be owned or pointed to by the original class. From our monolithic player class, we can see there are lots of things that are not directly related, but that does not mean they are not linked together.
</p>
<p>
    Object-oriented hierarchies are is-a relationships, and components and composition oriented designs are traditionally thought of as has-a relationships. Moving from one to the other can be thought of as delegating responsibility or moving away from being locked into what you are, but having a looser role and keeping the specialization until further down the tree. Composition clears up most of the common cases of diamond inheritance issues, as capabilities of the classes are added by accretion as much as they are added by overriding.
</p>
<p>
    The first move we need to make will be to take related pieces of our monolithic class and move them into their own classes, along the lines of composing, changing the class from owning all the data and the actions that modify the data into having instances which contain data and delegating actions down into those specialized structures where possible. We move the data out into separate structures so they can be more easily combined into new classes later. We will initially only separate by categories we perceive as being the boundaries between systems. For example, we separate rendering from controller input, from gameplay details such as inventory, and we split out animation from all.
</p>
<p>
    Taking a look at the results of splitting the player class up, such as in listing [*], it's possible to make some initial assessments of how this may turn out. We can see how a first pass of building a class out of smaller classes can help organize the data into distinct, purpose oriented collections, but we can also see the reason why a class ends up being a tangled mess. When you think about the needs of each of the pieces, what their data requirements are, the coupling can become evident. The rendering functions need access to the player's position as well as the model, and the gameplay functions such as Shoot(Vec target) need access to the inventory as well as setting animations and dealing damage. Taking damage will need access to the animations and health. Things are already seeming more difficult to handle than expected, but what's really happening here is that it's becoming clear that code needs to cut across different pieces of data. With just this first pass, we can start to see that functionality and data don't belong together.
</p>
<p>
    In this first step, we made the player class a container for the components. Currently, the player has the components, and the player class has to be instantiated to make a player exist. To allow for the cleanest separation into components in the most reusable way, it's worth attempting to move components into being managed by managers, and not handled or updated by their entities. In doing this, there will also be a benefit of cache locality when we're iterating over multiple entities doing related tasks when we move them away from their owners.
</p>
<p>
	<strong>
        This is where it gets a bit philosophical
	</strong>
    . Each system has an idea of the data it needs in order to function, and even though they will overlap, they will not share all data. Consider what it is that a serialization system needs to know about a character. It is unlikely to care about the current state of the animation system, but it will care about inventory. The rendering system will care about position and animation, but won't care about the current amount of ammo. The UI rendering code won't even care about where the player is, but will care about inventory and their health and damage. This difference of interest is at the heart of why 
	<strong>
        putting all the data in one class isn't a good long-term solution
	</strong>
    .
</p>
<p>
    The functionality of a class, or an object, comes from how the internal state is interpreted, and how the changes to state over time are interpreted too. 
	<strong>
        The relationship between facts is part of the problem domain and could be called meaning, but the facts are only raw data
	</strong>
    . This separation of fact from meaning is not possible with an object-oriented approach, which is why every time a fact acquires a new meaning, the meaning has to be implemented as part of the class containing the fact. Dissolving the class, extracting the facts and keeping them as separate components, has given us the chance to move away from classes that instill permanent meaning at the expense of occasionally having to look up facts via less direct methods. Rather than store all the possibly associated data by meaning, we choose to only add meaning when necessary. We add meaning when it is part of the immediate problem we are trying to solve.
</p>
<h3
	id="relational-databases" >
    Relational Databases
</h3>
<ul>
	<li>
		<p>
            You certainly don't have to move your data to a database style to do data-oriented design, but there are many places where you will wish you had a simple array to work with.
		</p>
	</li>
	<li>
		<p>
            Edgar F. Codd proposed the relational model to handle the current and future needs of agents interacting with data. He proposed a solution to structuring data for insert, update, delete, and query operations. His proposal claimed to reduce the need to maintain a deep understanding of how the data was laid out to use it well. His proposal also claimed to reduce the likelihood of introducing internal inconsistencies. He introduced the fundamental terms of normalization we use to this day in a systematic approach to reducing the most complex of interconnected state information to linear lists of unique independent tuples.
		</p>
	</li>
	<li>
		<p>
            What we see here as we normalize our data is a tendency to split data by dependency. Looking at many third party engines and APIs, you can see some parallels with the results of these normalization. It's unlikely that the people involved in the design and evolution of these engines took their data and applied database normalization techniques,&nbsp;&nbsp;but sometimes the separations between object and components of objects can be obvious enough that you don't need a formal technique in order to realize some positive structural changes.
		</p>
	</li>
	<li>
		<p>
            In some games, the entity object is not just an object that can be anything, but is instead a specific subset of the types of entity involved in the game. For example, in one game there might be a class for the player character, and one for each major type of enemy character, and another for vehicles. The player may have different attributes to other entities, such as lacking AI controls, or having player controls, or having regenerating health, or having ammo. This object-oriented approach puts a line, invisible to the user, but intrusive to the developer, between classes of object and their instances. It is intrusive because when classes touch, they have to adapt to each other. When they don't reside in the same hierarchy, they have to work through abstraction layers to message each other. The amount of code required to bridge these gaps can be small, but they always introduce complexity.
		</p>
	</li>
	<li>
		<p>
            When developing software, this usually manifests as time spent writing out templated code that can operate on multiple classes rather than refactoring the classes involved into more discrete components. This could be considered wasted time as the likelihood of other operations needing to operate on all the objects is greater than zero,&nbsp;&nbsp;and the effort to refactor into components is usually similar to the effort to create a working templated operation.
		</p>
	</li>
	<li>
		<p>
            Without classes to define boundaries, the table-based approach levels the playing field for data to be manipulated together. In all cases on our journey through normalizing the level data, we have made it so changes to the design require fewer changes to the data, and made it so data changes are less likely to cause the state to become inconsistent. In many cases, it would seem we have added complexity when it wasn't necessary, and that's up to experimentation and experience to help you decide how far to go.
		</p>
	</li>
	<li>
		<p>
            We saw that sometimes adding new features required nothing more than adding a new table, or a new column to an existing table. That's a non-intrusive modification if you are using a database style of storage, but a significant change if you're adding a new member to a class.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-06_08-14-51.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-06_08-18-46.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="what-should-be-a-column" >
    What should be a column
</h5>
<ul>
	<li>
		<p>
            We're not going to go into the details of the lowest level of how we utilize large data primitives such as meshes, textures, sounds and such. For now, think of these raw assets (sounds, textures, vertex buffers, etc.) as primitives, much like the integers, floating point numbers, strings and boolean values we shall be working with. We do this because the relational model calls for atomicity when working with data. What is and is not atomic has been debated without an absolute answer becoming clear, but for the intents of developing software intended for human consumption, the granularity can be rooted in considering the data from the perspective of human perception. There are existing APIs that present strings in various ways depending on how they are used, for example the difference between human-readable strings (usually UTF-8) and ASCII strings for debugging. Adding sounds, textures, and meshes to this seems quite natural once you realize all these things are resources which if cut into smaller pieces begin to lose what it is that makes them what they are. For example, half of a sentence is a lot less useful than a whole one, and loses integrity by disassociation. A slice of a sentence is clearly not reusable in any meaningful way with another random slice of a different sentence. Even subtitles are split along meaningful boundaries, and it's this idea of 
			<strong>
                meaningful boundary
			</strong>
            &nbsp;that gives us the our definition of atomicity for software developed for humans. To this end, when working with your data, when you're normalizing, try to stay at the level of nouns, the nameable pieces. A whole song can be an atom, but so is a single tick sound of a clock. A whole page of text is an atom, but so is the player's gamer-tag.
		</p>
	</li>
</ul>
<h5
	id="operations" >
    Operations
</h5>
<ul>
	<li>
		<p>
            When you use objects, you call methods on them, so how do you unlock a door in this table-based approach? Actions are always going to be insert, delete, or updates. These were clearly specified in Edgar F. Codd's works, and they are all you need to manipulate a relational model.
		</p>
	</li>
	<li>
		<p>
            In a real database, finding what mesh to load, or whether a door is locked would normally require a join between tables. A real database would also attempt to optimize the join by changing the sequence of operations until it had made the smallest possible expected workload. We can do better than that because we can take absolute charge of how we look at and request data from our tables. To find out if a door is locked, we don't need to join tables, we know we can look up into the locked doors table directly. Just because the data is laid out like a database, doesn't mean we have to use a query language to access it.
		</p>
	</li>
	<li>
		<p>
            When it comes to operations that change state, it's best to try to stick to the kind of operation you would normally find in a DBMS, as doing unexpected operations brings unexpected state complexity. For example, imagine you have a table of doors that are open, and a table of doors that are closed. Moving a door from one table might be considered wasteful, so you may consider changing the representation to a single table, but with all closed doors at one end, and all open at the other. By having both tables represented as a single table, and having the isClosed attribute defined implicitly by a cut-off point in the array, such as in listing [*], leads to the table being somewhat ordered. This type of memory optimization comes at a price. Introducing order into a table makes the whole table inherently less parallelizable to operations, so beware the additional complexity introduced by making changes like this, and document them well.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-07_08-44-54.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            Unlocking a door can be a delete. A door is locked because there is an entry in the LockedDoors table that matches the Door you are interested in. Unlocking a door is a delete if door matches, and you have the right key.
		</p>
	</li>
	<li>
		<p>
            The player inventory would be a table with just PickupIDs. This is the idea that &quot;the primary key is also the data&quot; mentioned much earlier. If the player enters a room and picks up a Pickup, then the entry matching the room is deleted while the inventory is updated to include the new PickupID.
		</p>
	</li>
	<li>
		<p>
            Databases have the concept of triggers, where operations on a table can cause cascades of further operations. In the case of picking up a key, we would want a trigger on insert into the inventory that joins the new PickupID with the LockedDoors table. For each matching row, delete it, and now the door is unlocked.
		</p>
	</li>
</ul>
<h3
	id="stream-processing-no-global-memory" >
    Stream Processing (no global memory)
</h3>
<ul>
	<li>
		<p>
            Stream processing means to process data without writing to variables external to the process. This means not allowing things like global accumulators, or accessing global memory not set as a source for the process. This ensures the processes or transforms are trivially parallelizable.
		</p>
	</li>
	<li>
		<p>
            When you prepare a primitive render for a graphics card, you set up constants such as the transform matrix, the texture binding, any lighting values, or which shader you want to run. When you come to run the shader, each vertex and pixel may have its own scratchpad of local variables, but they never write to globals or refer to a global scratchpad. The concept of shared memory in general purpose GPU code, such as CUDA and OpenCL, allows the use of a kind of managed cache. None of the GPGPU techniques offer access to global memory, and thus maintain a clear separation of domains and continue to guarantee no side-effects caused by any kernels being run outside of their own sandboxed shared memory. By enforcing this lack of side-effects, we can guarantee trivial parallelism because the order of operations are assured to be irrelevant. If a shader was allowed to write to globals, there would be locking, or it would become an inherently serial operation. Neither of these are good for massive core count devices like graphics cards, so that has been a self imposed limit and an important factor in their design. Adding shared memory to the mix starts to inject some potential locking into the process, and hence is explicitly only used when writing compute shaders.
		</p>
	</li>
	<li>
		<p>
            Doing all processing this way, without globals / global scratchpads, gives you the rigidity of intention to highly parallelize your processing and make it easier to think about the system, inspect it, debug it, and extend it or interrupt it to hook in new features. If you know the order doesn't matter, it's very easy to rerun any tests or transforms that have caused bad state.
		</p>
	</li>
</ul>
<h3
	id="ownership" >
    Ownership
</h3>
<ul>
	<li>
		<p>
            Where once we would have an object instance for an area in a game, and we would interrogate it for exits that take us to other areas, now we look into a structure that only contains links between areas, and filter by the area we are in. This reversal of ownership can be a massive benefit in debugging, but can sometimes appear backward when all you want to do is find out what exits are available to get out of an area.
		</p>
	</li>
</ul>
<h3
	id="existential-processing" >
    Existential processing
</h3>
<ul>
	<li>
		<p>
            Attempts to provide a way to remove unnecessary querying about whether or not to process your data. In most software, there are checks for NULL and queries to make sure the objects are in a valid state before work is started. What if you could always guarantee your pointers were not null? What if you were able to trust that your objects were in a valid state, and should always be processed?
		</p>
	</li>
	<li>
		<p>
            If you use existential processing techniques, your classes defined by the tables they belong to, then you can switch between tables at runtime.
		</p>
	</li>
</ul>
<h3
	id="enums" >
    Enums
</h3>
<ul>
	<li>
		<p>
            The reason why you would put an enum in table form, is to reduce control flow impact. Given this, it's when we aren't using the enumerations to control instruction flow that it's fine to leave them alone. Another possibility is when the value of the enum changes with great frequency, as moving objects from table to table has a cost too.
		</p>
	</li>
	<li>
		<p>
            Enumerations are used to define sets of states. We could have had a state variable for the regenerating entity, one that had 
            <code>in_full_health</code>
            , 
            <code>is_hurt</code>
            , 
            <code>is_dead</code>
            &nbsp;as its three states. We could have had a team index variable for the avoidance entity enumerating all the available teams. Instead, we used tables to provide all the information we needed, as there were only two teams. Any enum can be emulated with a variety of tables. All you need is one table per enumerable value. Setting the enumeration is an insert into a table or a migration from one table to another.
		</p>
	</li>
	<li>
		<p>
            When using tables to replace enums, some things become more difficult: finding out the value of an enum in an entity is difficult as it requires checking all the tables which represent that state for the entity. However, the main reason for getting the value is either to do an operation based on an external state or to find out if an entity is in the right state to be considered for an operation. This is disallowed and unnecessary for the most part, as firstly, accessing external state is not valid in a pure function, and secondly, any dependent data should already be part of the table element.
		</p>
	</li>
	<li>
		<p>
            If the enum is a state or type enum previously handled by a switch or virtual call, then we don't need to look up the value, instead, we change the way we think about the problem. The solution is to run transforms taking the content of each of the switch cases or virtual methods as the operation to apply to the appropriate table, the table corresponding to the original enumeration value.
		</p>
	</li>
	<li>
		<p>
            If the enum is instead used to determine whether or not an entity can be operated upon, such as for reasons of compatibility, then consider an auxiliary table to represent being in a compatible state. If you're thinking about the case where you have an entity as the result of a query and need to know if it is in a certain state before deciding to commit some changes,&nbsp;&nbsp;consider that the compatibility you seek could have been part of the criteria for generating the output table in the first place, or a second filtering operation could be committed to create a table in the right form.
		</p>
	</li>
	<li>
		<p>
            Examples of enumerations that make sense are keybindings, enumerations of colors, or good names for small finite sets of values. Functions that return enums, such as collision responses (none, penetrating, through). Any kind of enumeration which is actually a lookup into data of another form is good, where the enum is being used to rationalize the access to those larger or harder to remember data tables. There is also a benefit to some enums in that they will help you trap unhandled cases in switches, and to some extent, they are a self-documenting feature in most languages.
		</p>
	</li>
</ul>
<h3
	id="polymorphism" >
    Polymorphism
</h3>
<ul>
	<li>
		<p>
            Let's consider now how we implement polymorphism. We know we don't have to use a virtual table pointer; we could use an enum as a type variable. That variable, the member of the structure that defines at runtime what that structure should be capable of and how it is meant to react. That variable will be used to direct the choice of functions called when methods are called on the object.
		</p>
	</li>
	<li>
		<p>
            When your type is defined by a member type variable, it's usual to implement virtual functions as switches based on that type, or as an array of functions. If we want to allow for runtime loaded libraries, then we would need a system to update which functions are called. The humble switch is unable to accommodate this, but the array of functions could be modified at runtime.
		</p>
	</li>
	<li>
		<p>
            We have a solution, but it's not elegant, or efficient. The data is still in charge of the instructions, and we suffer the same instruction cache misses and branch mispredictions as whenever a virtual function is unexpected. However, when we don't really use enums,&nbsp;&nbsp;but instead tables that represent each possible value of an enum,&nbsp;&nbsp;it is still possible to keep compatible with dynamic library loading the same as with pointer based polymorphism, but we also gain the efficiency of a data-flow processing approach to processing heterogeneous types.
		</p>
	</li>
	<li>
		<p>
            For each class, instead of a class declaration, we have a factory that produces the correct selection of table insert calls. Instead of a polymorphic method call, we utilize existential processing. Our elements in tables allow the characteristics of the class to be implicit. Creating your classes with factories can easily be extended by runtime loaded libraries. Registering a new factory should be simple as long as there is a data-driven factory method. The processing of the tables and their update() functions would also be added to the main loop.
		</p>
	</li>
	<li>
		<p>
            If you create your classes by composition, and you allow the state to change by inserting and removing from tables, then you also allow yourself access to dynamic runtime polymorphism. This is a feature normally only available when dynamically responding via a switch.
		</p>
	</li>
	<li>
		<p>
            Polymorphism is the ability for an instance in a program to react to a common entry point in different ways due only to the nature of the instance. In C++, compile-time polymorphism can be implemented through templates and overloading. Runtime polymorphism is the ability for a class to provide a different implementation for a common base operation with the class type unknown at compile-time. C++ handles this through virtual tables, calling the right function at runtime based on the type hidden in the virtual table pointer at the start of the memory pointed to by the this pointer. Dynamic runtime polymorphism is when a class can react to a common call signature in different ways based on its type, but its type can change at runtime. C++ doesn't implement this explicitly, but if a class allows the use of an internal state variable or variables, it can provide differing reactions based on the state as well as the core language runtime virtual table lookup. Other languages which define their classes more fluidly,&nbsp;&nbsp;such as Python, allow each instance to update how it responds to messages, but most of these languages have very poor general performance as the dispatch mechanism has been built on top of dynamic lookup.
		</p>
	</li>
</ul>
<h3
	id="events" >
    Events
</h3>
<ul>
	<li>
		<p>
            Using your existence in a table as the registration technique makes this simpler than before and lets you register and de-register with great pace. Subscription becomes an insert, and unsubscribing a delete. It's possible to have global tables for subscribing to global events. It would also be possible to have named tables. Named tables would allow a subscriber to subscribe to events before the publisher exists.
		</p>
	</li>
</ul>
<h3
	id="soa" >
    SOA
</h3>
<ul>
	<li>
		<p>
            It is okay to keep hot and cold data side by side in an SoA object as data is pulled into the cache by necessity rather than by accidental physical location.
		</p>
	</li>
	<li>
		<p>
            Database technology was here first. In DBMS terms, it's called column-oriented databases and they provide better throughput for data processing over traditional row-oriented relational databases simply because irrelevant data is not loaded when doing column aggregations or filtering.
		</p>
	</li>
	<li>
		<p>
            For getting the &quot;average age of a population&quot;:
		</p>
		<ul>
			<li>
                <img src="assets/2026-01-04_17-41-27.png" width="250" >

			</li>
			<li>
                <img src="assets/2026-01-04_17-42-03.png" width="250" >

			</li>
		</ul>
	</li>
	<li>
        <img src="assets/2026-01-04_17-40-22.png" width="250" >

	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#soa-data-types" 
				class="external-link" 
				target="_blank" >
                Odin - SOA Data Types
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="sources" >
    Sources
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=SofC6c9xQv4" 
				class="external-link" 
				target="_blank" >
                Rust Auckland - Azriel: ECS: A Programming Paradigm
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Really good video for explaining the general theory behind ECS, but then falls short when it comes to implementation and Rust things.
				</p>
			</li>
			<li>
				<p>
                    I didn't like the video after {31:00}, as it went for an implementation with Rust and I though it was very confusing.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="bitsquid-engine-building-a-data-oriented-entity-system" >
    Bitsquid Engine - Building a Data-Oriented Entity System
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://bitsquid.blogspot.com/2014/08/building-data-oriented-entity-system.html" 
				class="external-link" 
				target="_blank" >
                pt1
			</a>
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://bitsquid.blogspot.com/2014/09/building-data-oriented-entity-system.html" 
				class="external-link" 
				target="_blank" >
                pt2
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://bitsquid.blogspot.com/2014/10/building-data-oriented-entity-system.html" 
				class="external-link" 
				target="_blank" >
                pt3
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://bitsquid.blogspot.com/2014/10/building-data-oriented-entity-system_10.html" 
				class="external-link" 
				target="_blank" >
                pt4
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">const unsigned ENTITY_INDEX_BITS = 22;
const unsigned ENTITY_INDEX_MASK = (1&lt;&lt;ENTITY_INDEX_BITS)-1;

const unsigned ENTITY_GENERATION_BITS = 8;
const unsigned ENTITY_GENERATION_MASK = (1&lt;&lt;ENTITY_GENERATION_BITS)-1;

struct Entity
{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned id;

&nbsp;&nbsp;&nbsp;&nbsp;unsigned index() const {return id & ENTITY_INDEX_MASK;}
&nbsp;&nbsp;&nbsp;&nbsp;unsigned generation() const {return (id &gt;&gt; ENTITY_INDEX_BITS) & ENTITY_GENERATION_MASK;}
};

class EntityManager
{
&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;unsigned char&gt; _generation;
&nbsp;&nbsp;&nbsp;&nbsp;Deque&lt;unsigned&gt; _free_indices;

&nbsp;&nbsp;&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;&nbsp;Entity create() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned idx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (_free_indices.size() &gt; MINIMUM_FREE_INDICES) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx = _free_indices.front();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_free_indices.pop_front();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_generation.push_back(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx = _generation.size() - 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XENSURE(idx &lt; (1 &lt;&lt; ENTITY_INDEX_BITS));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return make_entity(idx, _generation[idx]);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;bool alive(Entity e) const {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _generation[e.index()] == e.generation();
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;void destroy(Entity e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned idx = e.index();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++_generation[idx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_free_indices.push_back(idx);
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
<ul>
	<li>
		<p>
            The idea here is that the index part directly gives us the index of the entity in a lookup array.
		</p>
		<ul>
			<li>
				<p>
                    The generation part is used to distinguish entities created at the same index slot. As we create and destroy entities we will at some point have to reuse an index in the array. By changing the generation value when that happens we ensure that we still get a unique ID.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In our system we are restricted to using 30 bits for the entity ID. We steal two bits from this pointer in order to distinguish it from other types of light userdata that we use in the engine.
		</p>
		<ul>
			<li>
				<p>
                    We've split up our 30 bits into 22 bits for the index and 8 bits for the generation. This means that we support a maximum of 4 million simultaneous entities. It also means that we can only distinguish between 256 different entities created at the same index slot. If more than 256 entities are created at the same index slot, the generation value will wrap around and our new entity will get the same ID as an old entity.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A nice thing about only having 8 bits in generation is that we just need 8 bits per entity in our lookup array. This saves memory, but also gives us better performance, since we will fit more in the cache.
		</p>
	</li>
	<li>
		<p>
            Component:
		</p>
	</li>
	<li>
		<p>
            Components in our system are not individual objects, instead all components of a particular type are handled by a component manager for that type. The component manager has full control over how the component data is stored internally and how updates are applied.
		</p>
	</li>
	<li>
		<p>
            It is perhaps not self-evident why we want to store the entity that owns the component, but it will come in handy later.
		</p>
	</li>
	<li>
		<p>
            Component Manager:
		</p>
	</li>
	<li>
		<p>
            The task of a ComponentManager is to associate entities with components. It is up to the component manager to decide if it makes sense for an entity to have multiple components of its type.
		</p>
	</li>
	<li>
		<p>
            There is no place where we keep a list of all the components that an entity has. This is only defined by what has been registered with the different component managers in the game.
		</p>
	</li>
	<li>
		<p>
            When considering how we should layout the data in the component manager we have two goals:
		</p>
		<ul>
			<li>
				<p>
                    Given an entity we want to be able to quickly look up the component data for that entity.
				</p>
			</li>
			<li>
				<p>
                    We want the component data to be packed tightly in memory for good cache performance.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">class PointMassComponentManager {
&nbsp;&nbsp;&nbsp;&nbsp;struct InstanceData {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Entity&gt; entity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;float&gt; mass;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Vector3&gt; position;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Vector3&gt; velocity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Vector3&gt; acceleration;
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;InstanceData _data;
};
</code></pre>
<ul>
	<li>
		<p>
            That works well enough, but it does mean that the data gets stored in five separately allocated memory buffers.
		</p>
	</li>
	<li>
		<p>
            I use a different approach. I allocate the entire memory buffer as a single allocation and then just let entity, mass, etc, point to different parts of that buffer:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">class PointMassComponentManager {
&nbsp;&nbsp;&nbsp;&nbsp;struct InstanceData {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&lt; Number of used instances.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned allocated;&nbsp;&nbsp;///&lt; Number of allocated instances.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *buffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&lt; Buffer with instance data.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entity *entity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float *mass;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 *position;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 *velocity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 *acceleration;
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;InstanceData _data;

&nbsp;&nbsp;&nbsp;&nbsp;void allocate(unsigned sz)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(sz &gt; _data.n);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstanceData new_data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned bytes = sz * (sizeof(Entity) + sizeof(float) +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 * sizeof(Vector3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.buffer = _allocator.allocate(bytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.n = _data.n;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.allocated = sz;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.entity = (Entity *)(new_data.buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.mass = (float *)(new_data.entity + sz);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.position = (Vector3 *)(new_data.mass + sz);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.velocity = new_data.position + sz;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.acceleration = new_data.velocity + sz;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.entity, _data.entity, _data.n * sizeof(Entity));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.mass, _data.mass, _data.n * sizeof(float));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.position, _data.position, _data.n * sizeof(Vector3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.velocity, _data.velocity, _data.n * sizeof(Vector3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.acceleration, _data.acceleration,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data.n * sizeof(Vector3));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_allocator.deallocate(_data.buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data = new_data;
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
<ul>
	<li>
		<p>
            This avoids any hidden overheads that might exist in the Array class and we only have a single allocation to keep track of. This is better both for the cache and the memory allocation system`.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">
Array&lt;unsigned&gt; _map;
</code></pre>
<ul>
	<li>
		<p>
            Here, the 
            <code>_map</code>
            &nbsp;allows us to look up a component index based on the entity index.
            <br>
            This is a lot better, because now it is just the _map array that has holes, not the _data array, which means that the holes are fewer and smaller. Still, I would only use this if I was certain that the component was almost universal and that lookups where performance critical. In most cases, I think a hash index is a better approach:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">HashMap&lt;Entity, unsigned&gt; _map;
</code></pre>
<ul>
	<li>
		<p>
            This uses less memory and lookups are still pretty fast.
		</p>
	</li>
	<li>
		<p>
            Update:
		</p>
		<ul>
			<li>
				<p>
                    Since the component data is laid out sequentially in memory, writing a function that simulates physics for all entities is simple:
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">void simulate(float dt)
{
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;_data.n; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data.velocity[i] += _data.acceleration[i] * dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data.position[i] += _data.velocity[i] * dt;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
		<ul>
			<li>
				<p>
                    This function traverses memory in-order which gives us good cache performance. Itâ€™s also easy to profile, vectorize and parallelize, should the need arise.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Destroy:
		</p>
		<ul>
			<li>
				<p>
                    When destroying components, we want to make sure that we keep the 
                    <code>_data</code>
                    &nbsp;array tightly packed. We can achieve that by moving the last element to the position of the component we want to remove. We must also update the 
                    <code>_map</code>
                    &nbsp;entry for the corresponding entity.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">void destroy(unsigned i)
{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned last = _data.n - 1;
&nbsp;&nbsp;&nbsp;&nbsp;Entity e = _data.entity[i];
&nbsp;&nbsp;&nbsp;&nbsp;Entity last_e = _data.entity[last];

&nbsp;&nbsp;&nbsp;&nbsp;_data.entity[i] = _data.entity[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.mass[i] = _data.mass[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.position[i] = _data.position[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.velocity[i] = _data.velocity[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.acceleration[i] = _data.acceleration[last];

&nbsp;&nbsp;&nbsp;&nbsp;_map[last_e] =&nbsp;&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;_map.erase(e);

&nbsp;&nbsp;&nbsp;&nbsp;--_n;
}
</code></pre>
		<ul>
			<li>
				<p>
                    Another question is how we handle destruction of components when an entity is destroyed. As you may recall, the entity does not have an explicit list of components that it owns. Also, it seems onerous to require of the user of the API to manually destroy the right components when the entity dies.
				</p>
			</li>
			<li>
				<p>
                    Components that need to be destroyed immediately (perhaps because they hold external resources) can register a destruction callback with the EntityManager and that callback will be called when the entity is destroyed.
				</p>
			</li>
			<li>
				<p>
                    However, for simpler components, like the point mass component, there is nothing that require components to be destroyed at exactly the same time as the entity. We can take advantage of that and use garbage collection to lazily destroy components instead of spending memory and effort on storing callback lists:
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">void gc(const EntityManager &em)
{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned alive_in_row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while (_data.n &gt; 0 && alive_in_row &lt; 4) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned i = random_in_range(0, _data.n - 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (em.alive(_data.entity[i])) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++alive_in_row;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alive_in_row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy(i);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
</ul>
<h5
	id="mach-engine-lets-build-ecs-in-zig" >
    <s>Mach Engine - Let's Build ECS in Zig</s>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://devlog.hexops.com/2022/lets-build-ecs-part-1/" 
				class="external-link" 
				target="_blank" >
                pt1
			</a>
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://devlog.hexops.com/2022/lets-build-ecs-part-2-databases/" 
				class="external-link" 
				target="_blank" >
                pt2
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Mentioned ECS in Bevy as a great source, but now &quot;further simplified&quot;.
		</p>
	</li>
	<li>
		<p>
            There's a lot of 'method' usage, classes, etc. Not a pretty code.
		</p>
	</li>
	<li>
		<p>
            Seems to have used solely archetypes.
		</p>
	</li>
	<li>
		<p>
            Zig code is not great to look at; very OOP-ed.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">pub const Entities = struct {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;// Returns a new entity.
&nbsp;&nbsp;&nbsp;&nbsp;pub fn new(entities: *Entities) !EntityID {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const new_id = entities.counter;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entities.counter += 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new_id;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub inline fn archetypeByID(entities: *Entities, entity: EntityID) *ArchetypeStorage {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ptr = entities.entities.get(entity).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &entities.archetypes.values()[ptr.archetype_index];
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn getComponent(entities: *Entities, entity: EntityID, name: []const u8, comptime Component: type) ?Component {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var archetype = entities.archetypeByID(entity);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var component_storage_erased = archetype.components.get(name) orelse return null;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ptr = entities.entities.get(entity).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var component_storage = ErasedComponentStorage.cast(component_storage_erased.ptr, Component);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return component_storage.get(ptr.row_index);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn setComponent(entities: *Entities, entity: EntityID, name: []const u8, component: anytype) !void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var archetype = entities.archetypeByID(entity);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const old_hash = archetype.hash;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var have_already = archetype.components.contains(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const new_hash = if (have_already) old_hash else old_hash ^ std.hash_map.hashString(name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var archetype_entry = try entities.archetypes.getOrPut(entities.allocator, new_hash);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!archetype_entry.found_existing) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;archetype_entry.value_ptr.* = ArchetypeStorage{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.allocator = entities.allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.components = .{},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.hash = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var new_archetype = archetype_entry.value_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var column_iter = archetype.components.iterator();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (column_iter.next()) |entry| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var erased: ErasedComponentStorage = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry.value_ptr.cloneType(entry.value_ptr.*, &new_archetype.entity_ids.items.len, entities.allocator, &erased) catch ...;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_archetype.components.put(entities.allocator, entry.key_ptr.*, erased) catch ...;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create storage/column for the new component.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const erased = entities.initErasedStorage(&new_archetype.entity_ids.items.len, @TypeOf(component)) catch ...;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_archetype.components.put(entities.allocator, name, erased) catch ...;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_archetype.calculateHash();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var current_archetype_storage = archetype_entry.value_ptr;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_hash == old_hash) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ptr = entities.entities.get(entity).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try current_archetype_storage.set(ptr.row_index, name, component);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const new_row = try current_archetype_storage.new(entity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const old_ptr = entities.entities.get(entity).?;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var column_iter = archetype.components.iterator();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (column_iter.next()) |entry| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var old_component_storage = entry.value_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var new_component_storage = current_archetype_storage.components.get(entry.key_ptr.*).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_component_storage.copy(new_component_storage.ptr, entities.allocator, new_row, old_ptr.row_index, old_component_storage.ptr) catch |err| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.undoNew();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.entity_ids.items[new_row] = entity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.set(new_row, name, component) catch |err| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.undoNew();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;};
};

// Represents the storage for a single type of component within a single type of entity.
// Database equivalent: a column within a table.
pub fn ComponentStorage(comptime Component: type) type {
&nbsp;&nbsp;&nbsp;&nbsp;return struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A reference to the total number of entities with the same type as is being stored here.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_rows: *usize,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The actual densely stored component data.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: std.ArrayListUnmanaged(Component) = .{},

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Self = @This();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pub fn deinit(storage: *Self, allocator: Allocator) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage.data.deinit(allocator);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;};
}

const ptr: Pointer = entities.entities.get(entity_id).?;
var archetype = entities.archetypes.entries.get(ptr.archetype_index);

test "ecs" {
&nbsp;&nbsp;&nbsp;&nbsp;...

&nbsp;&nbsp;&nbsp;&nbsp;const Location = struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x: f32 = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y: f32 = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z: f32 = 0,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;try world.setComponent(player, "Name", "jane"); // add Name component
&nbsp;&nbsp;&nbsp;&nbsp;try world.setComponent(player, "Location", Location{}); // add Location component
&nbsp;&nbsp;&nbsp;&nbsp;try world.setComponent(player, "Name", "joe"); // update Name component
}
</code></pre>
<h5
	id="bevy-engine-ecs" >
    <s>Bevy Engine - ECS</s>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            https://bevy.org/learn/quick-start/getting-started/ecs/
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://github.com/bevyengine/bevy/blob/v0.14.0/examples/ecs/ecs_guide.rs" 
				class="external-link" 
				target="_blank" >
                ECS demo in Bevy
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            it's terrible trying to understand anything inside a rust code....
		</p>
	</li>
</ul>
<h5
	id="godot-why-isnt-ecs-based" >
    Godot - Why isn't ECS-based?
</h5>
<ul>
	<li>
		<p>
            TLDR:
		</p>
		<ul>
			<li>
				<p>
                    &quot;Godot as an engine tries to take the burden of 
					<em>
                        processing
					</em>
                    &nbsp;away from the user, and instead places the focus on 
					<em>
                        deciding
					</em>
                    &nbsp;what to do in case of an event. This ensures users have to optimize 
					<em>
                        less
					</em>
                    &nbsp;in order to write much of the game code, and is part of the vision Godot conveys about what should constitute an 
					<em>
                        easy to use game engine
					</em>
                    &quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://godotengine.org/article/why-isnt-godot-ecs-based-game-engine/" 
				class="external-link" 
				target="_blank" >
                Why isn't Godot an ECS-based game engine?
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            ECS is a design pattern commonly used in video games (although not very common in the rest of the software industry) which consists of having a base Entity (a container object) and Components that can be added upon it. Components provide data and the means to interact with the whole world. Finally, Systems work independently and act on every similar component.
		</p>
	</li>
	<li>
		<p>
            This design became common in game engines and libraries in the early 2010s. The main appeal (besides architecture) is that component data can be placed in contiguous memory, improving cache access.
		</p>
	</li>
	<li>
		<p>
            This is a common form of 
			<a
				href="https://en.wikipedia.org/wiki/Data-oriented_design" 
				class="external-link" 
				target="_blank" >
                data-oriented
			</a>
            &nbsp;optimization.
		</p>
	</li>
	<li>
		<p>
            Architecturally, ECS aims to replace 
			<a
				href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" 
				class="external-link" 
				target="_blank" >
                inheritance
			</a>
            , by favoring composition, similar to how 
			<em>
                interfaces
			</em>
            &nbsp;or 
			<em>
                multiple inheritance
			</em>
            &nbsp;works in OOP.
		</p>
	</li>
	<li>
		<p>
            The key advantage in ECS is that components are 
			<em>
                dynamic
			</em>
            &nbsp;(can be added or removed at runtime).
		</p>
	</li>
	<li>
		<p>
            Godot does composition at a higher level than in a traditional ECS.
		</p>
	</li>
	<li>
		<p>
            One of the biggest advantages of ECS is the Systems (data-oriented) part, which allows running through a lot of similar components' data organized in linear memory.
		</p>
		<ul>
			<li>
				<p>
                    This brings huge performance improvements over the way Godot works with nodes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Most (if not all) technologies that utilize ECS do it at the core engine level, by serving as the base architecture and building everything else (physics, rendering, audio, etc.) over it.
		</p>
	</li>
	<li>
		<p>
            Godot instead keeps those subsystems separate and isolated (and they fit inside of 
			<a
				href="https://godotengine.org/article/why-does-godot-use-servers-and-rids" 
				class="external-link" 
				target="_blank" >
				<em>
                    Servers
				</em>
			</a>
            ).
		</p>
		<ul>
			<li>
				<p>
                    I find this makes code simpler and easier to maintain and optimize.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            To put it simply, nodes are just interfaces to the actual data being processed inside servers, while in ECS the actual entities are what gets processed by the systems.
		</p>
		<ul>
			<li>
				<p>
                    As I understood it: Nodes seem to create a layer of abstraction over Systems, because they are very low-level.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In other words, Godot as an engine tries to take the burden of 
			<em>
                processing
			</em>
            &nbsp;away from the user, and instead places the focus on 
			<em>
                deciding
			</em>
            &nbsp;what to do in case of an event. This ensures users have to optimize 
			<em>
                less
			</em>
            &nbsp;in order to write much of the game code, and is part of the vision Godot conveys about what should constitute an 
			<em>
                easy to use game engine
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            These are generally games that need to process game logic on dozens of thousands of objects, where data-oriented optimizations become necessary, as the amount of pages moved into CPU cache increases by several orders of magnitude, severely affecting performance (and battery usage on mobile devices).
		</p>
		<ul>
			<li>
				<p>
                    City builders (lots of things going on).
				</p>
			</li>
			<li>
				<p>
                    Sandboxes (lots of tiny things need processing every frame).
				</p>
			</li>
			<li>
				<p>
                    Some strategy games (while not the majority, some can use thousands or tens of thousands of units at the same time).
				</p>
			</li>
			<li>
				<p>
                    Other AAA games with lots of content going on.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="entity" >
    Entity
</h2>
<ul>
	<li>
		<p>
            Mach:
		</p>
		<ul>
			<li>
				<p>
                    A unique integer
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Bevy:
		</p>
		<ul>
			<li>
				<p>
                    A collection of components with a unique id.
				</p>
			</li>
			<li>
				<p>
                    <code>Entity1 { Name("Alice"), Position(0, 0) }</code>
				</p>
			</li>
			<li>
				<p>
                    <code>Entity2 { Name("Bill"), Position(10, 5) }</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            An entity is a unique identifier (usually a number or an ID) that represents a &quot;thing&quot; in the system, like a character, object, or actor in a game or simulation.
		</p>
	</li>
	<li>
		<p>
            Entities are simple identifiers and do not have behavior or data directly attached to them. They merely aggregate components.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In a game, a player, an enemy, a bullet, or a tree can be represented as entities.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="component" >
    Component
</h2>
<ul>
	<li>
		<p>
            A truly component based object is nothing more than the sum of its parts. This means the definition of a component based object is also nothing more than an inventory with some construction arguments. This object or definition agnostic approach makes refactoring and redesigning a much simpler exercise.
		</p>
	</li>
	<li>
		<p>
            When you introduce component based entities, you have an opportunity to turn the idea of how you define an object on its head. The normal approach to defining an object in object-oriented design is to name it, then fill out the details as and when they become necessary. For example, your car object is defined as a Car,&nbsp;&nbsp;if not extending Vehicle, then at least including some data about what physics and meshes are needed, with construction arguments for wheels and body shell model assets etc, possibly changing class dependent on whether it's an AI or player car. In component-oriented design, objects aren't so rigidly defined, and don't so much become defined after they are named, as much as a definition is selected or compiled, and then tagged with a name if necessary. For example, instancing a physics component with four-wheel physics,&nbsp;&nbsp;instancing a renderable for each part (wheels,&nbsp;&nbsp;shell, suspension) adding an AI or player component to control the inputs for the physics component, all adds up to something which we can tag as a Car, or leave as is and it becomes something implicit rather than explicit and immutable.
		</p>
	</li>
</ul>
<h3
	id="storage-models" >
    Storage Models
</h3>
<ul>
	<li>
		<p>
			<em>
                Problem
			</em>
            :
		</p>
		<ul>
			<li>
                <img src="assets/2026-01-04_17-48-21.png" width="350" >

			</li>
			<li>
				<p>
                    In this case, it's used an 
                    <code>union</code>
                    , so the data can be either a value or nil.
				</p>
			</li>
			<li>
				<p>
                    There are a lot of empty spots inside those vectors, causing memory bloat; the data is not tightly packed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Frameworks
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Entt uses a sparse set ECS, Flecs uses archetypes&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<p
	class="table" >
    | Strategy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Iteration | Removal | Complexity |
    <br>
    | -------------- | --------- | ------- | ---------- |
    <br>
    | Sparse Set&nbsp;&nbsp;&nbsp;&nbsp; | Fast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| O(1)&nbsp;&nbsp;&nbsp;&nbsp;| Medium&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | Archetype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Fastest&nbsp;&nbsp; | Medium&nbsp;&nbsp;| High&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<h5
	id="sparse-set" >
    Sparse Set
</h5>
<ul>
	<li>
		<p>
            Sparse-sets organize data by component type (one dense array per component + a sparse entityâ†’index table).
		</p>
	</li>
	<li>
		<p>
            Make structural changes cheap and queries flexible.
		</p>
	</li>
	<li>
		<p>
            Manage components individually, using a dense array for each component type and a sparse array for existence checks. It's generally better in scenarios where components are added or removed frequently because you don't need to move all components an entity has, but iteration is more expensive as it requires checks to ensure each entity has the requested components.
		</p>
	</li>
	<li>
		<p>
            Splits one list into a Sparse List and a Dense List.
		</p>
	</li>
	<li>
		<p>
            We don't care about the cache friendliness of the Sparse List, only for the Dense List.
		</p>
	</li>
	<li>
		<p>
            Dense List:
		</p>
		<ul>
			<li>
				<p>
                    Contains the actual component data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Sparse List:
		</p>
		<ul>
			<li>
				<p>
                    It's what maps its Entity ID to its corresponding Dense List index.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-08_09-05-11.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-04_18-02-35.png" width="300" >
            .
		</p>
	</li>
	<li>
        <img src="assets/2026-01-07_13-59-07.png" width="600" >

	</li>
	<li>
		<p>
            It's also possible to use the Sparse List as a HashMap:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/2026-01-04_18-03-02.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This has trade-offs in performance, depending on the amount of entities there are stored.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=yyZMoE1FAJ0" 
						class="external-link" 
						target="_blank" >
                        Cient video
					</a>
                    : &quot;For what I've seem, the HashMap is usually faster for fewer entities (100), but a sparse list with Pagination is faster with a higher entity count (100k)&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Component :: struct($T: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp;sparse: [COMPONENT_MAX_ENTITIES]Maybe(u32), // Maybe(dense_idx) = sparse[ent]
&nbsp;&nbsp;&nbsp;&nbsp;dense:&nbsp;&nbsp;[dynamic]Entity_ID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ent = dense[dense_idx]
&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;&nbsp; [dynamic]T,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // T = data[dense_idx]
}
</code></pre>
<ul>
	<li>
		<p>
			<em>
                Get
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>O(1)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/2026-01-08_09-06-12.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Add
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>O(1)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/2026-01-08_09-06-00.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Remove
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>O(1)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/2026-01-08_09-10-22.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Swap the element we want to delete in the Dense List, with the last element of the Dense List.
				</p>
			</li>
			<li>
				<p>
                    Update the Sparse List, so the swapped elements from the Dense List point to the correct elements.
				</p>
			</li>
			<li>
				<p>
                    The deleted element from the Dense List should be set to a nil value, so it doesn't point to anything.
				</p>
			</li>
			<li>
				<p>
                    Pop the Dense List.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                For very large entity numbers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Pagination
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The Sparse Set can be divided into a &quot;array of arrays&quot;.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/2026-01-08_09-12-38.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/2026-01-08_09-14-29.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            &quot;Allocate pages only when needed&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Entity ID Recycling
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Generation counter.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bitmask
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only answers â€œis the component present?â€; it does not give you the 
                    <code>dense_idx</code>
                    &nbsp;you need to locate the component 
                    <code>T</code>
                    &nbsp;in your data array.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Speeding multi-component queries
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    Archetypes is a way to get the speed up, at its costs.
				</p>
			</li>
			<li>
				<p>
                    Iterate the best order.
				</p>
				<ul>
					<li>
						<p>
                            Always drive the query with the smallest component set (sparse-set dense array with fewest entries).
						</p>
					</li>
					<li>
						<p>
                            Complexity: O(min_set_size) + O(1) membership checks for each candidate.
						</p>
					</li>
					<li>
						<p>
                            Cheap, no extra memory, often good enough if one component is small.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Etc, do it later.
				</p>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="archetypes" >
    Archetypes
</h5>
<ul>
	<li>
		<p>
            An archetype is a grouping of entities that all share the exact same set of component types. Each archetype stores component data in contiguous, component-oriented arrays so that iteration over entities that have a particular set of components is very fast.
		</p>
	</li>
	<li>
		<p>
            Maximize per-system data locality and remove membership checks at the cost of entity migration bookkeeping.
		</p>
	</li>
	<li>
		<p>
            Archetypes seems like a specialization, just like oop is a specialization, so it comes at a cost of less flexibility.
		</p>
	</li>
	<li>
		<p>
            Group entities with identical sets of components together in memory, allowing for contiguous memory storage and fast access patterns during iteration.
		</p>
	</li>
	<li>
		<p>
            You don't need to check whether a given entity has certain components on each iteration.
		</p>
	</li>
	<li>
		<p>
            Adding or removing components is generally more expensive than with sparse sets, as you need to transfer all components for an entity from one pool to another.
		</p>
	</li>
	<li>
		<p>
            A chosen set of components that an entity of a certain type will have
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-08_14-40-19.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            Each archetype has one contiguous array per component type. Rows are entities.
		</p>
	</li>
</ul>
<pre><code class="language-txt" data-lang="txt">Entities:&nbsp;&nbsp;&nbsp;&nbsp; Pos.x&nbsp;&nbsp;Pos.y&nbsp;&nbsp;| Vel.x&nbsp;&nbsp;Vel.y&nbsp;&nbsp;| Health.hp
Entity 42&nbsp;&nbsp;&nbsp;&nbsp; [ 1.2 ] [ 3.4 ]| [ 0.1 ] [ 0.0 ]| [ 100 ]
Entity 73&nbsp;&nbsp;&nbsp;&nbsp; [ 5.6 ] [ 2.2 ]| [ -1. ] [ 0.3 ]| [&nbsp;&nbsp;80 ]
Entity 11&nbsp;&nbsp;&nbsp;&nbsp; [ ... ] [ ... ]| [ ... ] [ ... ]| [ 120 ]
</code></pre>
<ul>
	<li>
		<p>
            <img src="assets/2026-01-05_19-19-18.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-08_14-36-17.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=71RSWVyOMEY" 
						class="external-link" 
						target="_blank" >
                        ECS Archetypes explanation {5:09}
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Archetypes are created lazily, else we run into a combinatorial of creating new tables for each theoretical component combination, even tho that combination might not be useful as an entity type in the world.
		</p>
	</li>
	<li>
		<p>
            Because every entity in a table must have every component, there can't be any gaps.
		</p>
	</li>
	<li>
		<p>
			<em>
                Problem
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    If we want to loop over everything with a position and velocity components, we would have to loop over 2 different tables.
				</p>
			</li>
			<li>
				<p>
                    Solution:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/2026-01-08_14-41-07.png" width="500" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Take the intersection of these arrays, giving us the final set of archetypes, where each archetype contains all of the requested components.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Add/Remove
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Move entity from one archetype to another (copy component values to new archetype arrays, remove from old archetype).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                In Unity
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's not a container for anything. It doesn't contain the entity or any data associated with them. It's just an unique identifier.
				</p>
			</li>
			<li>
				<p>
                    &quot;Unique combination of components types for an entity&quot;.
				</p>
			</li>
			<li>
				<p>
                    We can have multiple archetypes for an entity query.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="system" >
    System
</h2>
<ul>
	<li>
		<p>
            A normal function.
		</p>
	</li>
	<li>
		<p>
            Is logic or a process that operates on one or more components of entities to modify their states or perform some operation.
		</p>
	</li>
</ul>
<h3
	id="with-sparse-sets" >
    With Sparse Sets
</h3>
<h5
	id="intersection-into-an-array-of-entity" >
    Intersection into an array of Entity
</h5>
<ul>
	<li>
		<p>
            &quot;give me all entities that have both Name and Person component&quot;.
		</p>
	</li>
	<li>
		<p>
			<em>
                Pros
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Contiguous index buffer â†’ easy to split into chunks for parallel workers.
				</p>
			</li>
			<li>
				<p>
                    Great for data-local processing (pull components by index into tight loops).
				</p>
			</li>
			<li>
				<p>
                    Enables SIMD easily because you can iterate contiguous component arrays by index with known bounds.
				</p>
			</li>
			<li>
				<p>
                    Allows simple scheduling (divide vec into ranges, spawn jobs, no shared iterator state).
				</p>
			</li>
			<li>
				<p>
                    Good throughput when query result is large or will be iterated multiple times.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Cons
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Upfront cost to compute intersection (time) and memory for the vector.
				</p>
			</li>
			<li>
				<p>
                    Allocation overhead unless you reuse buffers or reserve capacity.
				</p>
			</li>
			<li>
				<p>
                    If the query result is small or you only need first few matches, cost may be wasted.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;The movement system takes the Transform and Physics components, so the entity's Transform x and y are changed using information from Physics.&quot;
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">void MovementSystem::Move(ECS& ecs, EntityID entity, float dx, float dy) {
&nbsp;&nbsp;&nbsp;&nbsp;if (ecs.HasComponents&lt;TransformComponent, PhysicsComponent&gt;(entity)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransformComponent& transform = ecs.GetComponent&lt;TransformComponent&gt;(entity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhysicsComponent& physics = ecs.GetComponent&lt;PhysicsComponent&gt;(entity);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform.x += physics.velX;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform.y += physics.velY;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Iterate the smallest componentâ€™s dense array and use sparse lookups for other components
			</strong>
            :
		</p>
<pre><code class="language-cpp" data-lang="cpp">// sparse set API: dense[], sparse[entity] -&gt; index or -1, comps[] indexed by index
void sys_move(World *w, float dt) {
&nbsp;&nbsp;&nbsp;&nbsp;SparseSet *pos = &w-&gt;pos;
&nbsp;&nbsp;&nbsp;&nbsp;SparseSet *vel = &w-&gt;vel;
&nbsp;&nbsp;&nbsp;&nbsp;for (size_t i = 0; i &lt; pos-&gt;len; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entity e = pos-&gt;dense[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int vi = sparse_index(vel, e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vi &lt; 0) continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Position *p = &pos-&gt;comps[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Velocity *v = &vel-&gt;comps[vi];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x += v-&gt;x * dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;y += v-&gt;y * dt;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Idea 1: Array of Entity
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; []Entity_ID {</code>
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">for entity in intersect3(_dynamic_bodies, _velocities_max, _movement_directions) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(&_dynamic_bodies,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(&_velocities_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity)^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(&_movement_directions, entity)^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Fetches 
                            <code>component.sparse[entity]</code>
                            &nbsp;twice.
						</p>
					</li>
					<li>
						<p>
                            The programmer has to type the name of the component twice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<strong>
                Idea 4: Each component has a array of queried_data_indices array of u32
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; (count: int) {</code>
				</p>
			</li>
			<li>
				<p>
                    The query 
                    <code>intersect2</code>
                    &nbsp;function returns a length to be used inside the for loop.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">component_get_query :: #force_inline proc(component: Component($T), idx: int) -&gt; ^T {
&nbsp;&nbsp;&nbsp;&nbsp;return &component.dense[component.queried_data_indices[idx]]
}
for i in 0..&lt;intersect3(_dynamic_bodies, _velocities_max, _movement_directions) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_dynamic_bodies,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_velocities_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i)^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_movement_directions, i)^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Existence of the 
                            <code>.queried_data_indices</code>
                            ; Size of the 
                            <code>.queried_data_indices</code>
                            &nbsp;array; should not be allocated, for efficiency.
						</p>
					</li>
					<li>
						<p>
                            The programmer has to type the name of the component twice.
						</p>
					</li>
					<li>
						<p>
                            More memory waste than Idea 1, as every Component has to have its own 
                            <code>queried_data_indices</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Way more convoluted than the Idea 1.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 2: Many arrays of dense_idx
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; (r1, r2: []u32) {</code>
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">dyn_body_indices, vel_max_indices, mov_indices := intersect3(_dynamic_bodies, _velocities_max, _movement_directions)
for i in 0..&lt;len(dyn_body_indices) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_dynamic_bodies.dense[dyn_body_indices[i]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_velocities_max.dense[vel_max_indices[i]]^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_movement_directions.dense[mov_indices[i]]^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
                    Avoids fetching 
                    <code>component.sparse[entity]</code>
                    &nbsp;twice.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            ~There has to be lots of different arrays to store each one of 
                            <code>dyn_body_indices, vel_max_indices, mov_indices</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The programmer has to type the name of the component twice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 6: Each 
                <code>Component(T)</code>
                &nbsp;has a array of query_result array of ^T
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; (count: int) {</code>
				</p>
			</li>
			<li>
				<p>
                    The query 
                    <code>intersect2</code>
                    &nbsp;function returns a length to be used inside the for loop.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">component_get_query :: #force_inline proc(component: Component($T), idx: int) -&gt; ^T {
&nbsp;&nbsp;&nbsp;&nbsp;return component.query_result[idx]
}
for i in 0..&lt;intersect3(_dynamic_bodies, _velocities_max, _movement_directions) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_dynamic_bodies,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_velocities_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i)^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_movement_directions, i)^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            When comparing to Idea 4, it comes down to what's lighter, as the ideas are basically the same.
						</p>
						<ul>
							<li>
								<p>
                                    Idea 4 seems better, as a 
                                    <code>u32</code>
                                    &nbsp;is lighter than a 
                                    <code>uintptr</code>
                                    &nbsp;(size of 
                                    <code>int</code>
                                    /
                                    <code>uint</code>
                                    ).
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 3: Many arrays of T
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; (r1: []T, r2: []W) {</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The array being 
                            <code>[]T</code>
                            &nbsp;doesn't make sense, as I want a pointer to the element, but doing so would give me a pointer to a copy of the element.
						</p>
					</li>
					<li>
						<p>
                            It's necessary that the array be defined as 
                            <code>[]^T</code>
                            &nbsp;(same as Idea 6) or 
                            <code>[]u32</code>
                            &nbsp;(indices to 
                            <code>.data</code>
                            , which is exactly the same as Idea 4).
						</p>
					</li>
					<li>
						<p>
                            The generic nature of 
                            <code>T</code>
                            &nbsp;and 
                            <code>W</code>
                            &nbsp;makes this quite difficult.
						</p>
						<ol>
							<li>
								<p>
                                    Make a 
                                    <code>Component</code>
                                    &nbsp;be generic enough so it doesn't need 
                                    <code>T</code>
                                    &nbsp;or 
                                    <code>W</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <s>The returns are allocated</s>.
								</p>
								<ul>
									<li>
										<p>
                                            Seems very bad for performance.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 5: Each 
                <code>Component(T)</code>
                &nbsp;has a array of query_result array of T
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The array being 
                            <code>[]T</code>
                            &nbsp;doesn't make sense, as I want a pointer to the element, but doing so would give me a pointer to a copy of the element.
						</p>
					</li>
					<li>
						<p>
                            It's necessary that the array be defined as 
                            <code>[]^T</code>
                            &nbsp;(same as Idea 6) or 
                            <code>[]u32</code>
                            &nbsp;(indices to 
                            <code>.data</code>
                            , which is exactly the same as Idea 4).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="iterator" >
    Iterator
</h5>
<ul>
	<li>
		<p>
            &quot;iterate over everyÂ NameÂ component for entities that also have aÂ PersonÂ component&quot;.
		</p>
	</li>
	<li>
		<p>
			<em>
                Pros
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Low memory overhead, no allocation when you only consume a subset or stream.
				</p>
			</li>
			<li>
				<p>
                    Lower latency to obtain first match(s).
				</p>
			</li>
			<li>
				<p>
                    Useful for low-cardinality queries or queries that short-circuit early.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Cons
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Harder to parallelize unless the iterator supports splitting.
				</p>
			</li>
			<li>
				<p>
                    Potentially worse cache behavior because membership checks may bounce between sparse maps.
				</p>
			</li>
			<li>
				<p>
                    Harder to vectorize because you donâ€™t have fixed contiguous ranges to operate on.
				</p>
			</li>
			<li>
				<p>
                    Iterator state may create contention if shared between threads.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Idea 1: Simple iterator
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">intersect3_next:: proc(idx: ^u32, ca: ^Component($A), cb:^ Component($B), cc: ^Component($C)) -&gt; (^A, ^B, ^C, bool) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx^ += 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if idx^ &gt;= len(q.queried_data_indices[0]) - 1 do return

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a := ca.sparse[idx^]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if a == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b := cb.sparse[idx^]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c := cc.sparse[idx^]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if c == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &ca.data[a], &cb.data[b], &cc.data[c], true
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return
}

// Alternative with a static idx.
intersect3_next:: proc(ca: ^Component($A), cb: ^Component($B), cc: ^Component($C)) -&gt; (^A, ^B, ^C, bool) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@static idx: int
&nbsp;&nbsp;&nbsp;&nbsp;for {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx += 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if idx &gt;= len(q.queried_data_indices[0]) - 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx = 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a := ca.dense[idx]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if a == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b := cb.dense[idx]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c := cc.dense[idx]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if c == nil do continue

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &ca.data[a], &cb.data[b], &cc.data[c], true
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return
}

iterator_idx: u32
for dynamic_body, vel_max, mov_direction in intersect3_next(&iterator_idx, _dynamic_bodies, _velocities_max, _movement_directions) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(dynamic_body, vel_max, mov_direction)
}
</code></pre>
		<ul>
			<li>
				<p>
                    See the Odin note for an explanation on this pattern.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Parallelization?
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<strong>
                Idea 2: Query stores the queried_data_indices and pointer to components so query is used as an iterator
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">Query3 :: struct($N: int, $A, $B, $C: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp;idx: u32,

&nbsp;&nbsp;&nbsp;&nbsp;// I need to also store pointers to the components, to do `&component.dense[component.queried_data_indices[idx]]`
&nbsp;&nbsp;&nbsp;&nbsp;ca: ^Component(A),
&nbsp;&nbsp;&nbsp;&nbsp;cb: ^Component(B),
&nbsp;&nbsp;&nbsp;&nbsp;cc: ^Component(C),

&nbsp;&nbsp;&nbsp;&nbsp;queried_data_indices: [3][dynamic]u32,
}

@(require_results)
query3_via_intersect3 :: proc(ca: ^Component($A), cb: ^Component($B), cc: ^Component($C)) -&gt; Query3(A, B, C) {
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;a := make([dynamic]u32, allocator)
&nbsp;&nbsp;&nbsp;&nbsp;b := make([dynamic]u32, allocator)
&nbsp;&nbsp;&nbsp;&nbsp;c := make([dynamic]u32, allocator)

&nbsp;&nbsp;&nbsp;&nbsp;idx := 0
&nbsp;&nbsp;&nbsp;&nbsp;for entity in ca.dense {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cb.sparse[entity] == nil || cc.sparse[entity] == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;append(&a, ca.sparse[entity])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;append(&b, cb.sparse[entity])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;append(&c, cc.sparse[entity])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx += 1
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ca = ca,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cb = cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc = cc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queried_data_indices = { a, b, c },
&nbsp;&nbsp;&nbsp;&nbsp;}
}
query := query3_via_intersect3(_dynamic_bodies, _velocities_max, _movement_directions)

query3_next:: proc(q: ^Query3($A, $B, $C)) -&gt; (A, B, C, bool) {
&nbsp;&nbsp;&nbsp;&nbsp;if q.idx == len(q.queried_data_indices[0]) - 1 do return
&nbsp;&nbsp;&nbsp;&nbsp;q.idx += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&q.ca.dense[q.queried_data_indices[0][q.idx]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&q.cb.dense[q.queried_data_indices[1][q.idx]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&q.cc.dense[q.queried_data_indices[2][q.idx]], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true
}

for dynamic_body, vel_max, mov_direction in query3_next(&query) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(dynamic_body, vel_max, mov_direction)
}
</code></pre>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://github.com/odin-engine/ode_ecs" 
				class="external-link" 
				target="_blank" >
                ode_ecs
			</a>
            </s>.
		</p>
<pre><code class="language-odin" data-lang="odin">view: ecs.View
ecs.view_init(&view, &my_ecs, {&ais, &positions})

it: ecs.Iterator
ecs.iterator_init(&it, &view)
for ecs.iterator_next(&it) {
&nbsp;&nbsp;&nbsp;&nbsp;eid = ecs.get_entity(&it)
&nbsp;&nbsp;&nbsp;&nbsp;pos1 = ecs.get_component(&positions, &it)
&nbsp;&nbsp;&nbsp;&nbsp;ai = ecs.get_component(&ais, &it)
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("Iterating over view: ", eid, pos1, ai)
}
</code></pre>
		<ul>
			<li>
				<p>
                    I don't love the pattern. The programmer still have to type the name of the component twice: once on 
                    <code>view_init</code>
                    &nbsp;and again when inside the loop.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In Rust:
		</p>
<pre><code class="language-rust" data-lang="rust">for (pos, vel) in (&positions, &velocities).join() {
&nbsp;&nbsp;&nbsp;&nbsp;pos.x += vel.x
}
</code></pre>
		<ul>
			<li>
				<p>
                    <code>.join()</code>
                    &nbsp;here is just a method from some class. There's nothing special here; I believe it's somewhat equivalent to the Odin version.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="with-archetypes" >
    With Archetypes
</h3>
<pre><code class="language-c" data-lang="c">void movement_system(float dt) {
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; a_pv.count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pv.pos[i].x += a_pv.vel[i].vx * dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pv.pos[i].y += a_pv.vel[i].vy * dt;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; a_pvh.count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pvh.pos[i].x += a_pvh.vel[i].vx * dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pvh.pos[i].y += a_pvh.vel[i].vy * dt;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            No 
            <code>has_component</code>
            &nbsp;checks.
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-01-13 ðŸš€
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#discussion" >
                            Discussion
						</a>
						<ul>
							<li>
								<a
									href="#critiques" >
                                    Critiques
								</a>
							</li>
							<li>
								<a
									href="#philosophy" >
                                    Philosophy
								</a>
							</li>
							<li>
								<a
									href="#relational-databases" >
                                    Relational Databases
								</a>
							</li>
							<li>
								<a
									href="#stream-processing-no-global-memory" >
                                    Stream Processing (no global memory)
								</a>
							</li>
							<li>
								<a
									href="#ownership" >
                                    Ownership
								</a>
							</li>
							<li>
								<a
									href="#existential-processing" >
                                    Existential processing
								</a>
							</li>
							<li>
								<a
									href="#enums" >
                                    Enums
								</a>
							</li>
							<li>
								<a
									href="#polymorphism" >
                                    Polymorphism
								</a>
							</li>
							<li>
								<a
									href="#events" >
                                    Events
								</a>
							</li>
							<li>
								<a
									href="#soa" >
                                    SOA
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#sources" >
                            Sources
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#entity" >
                            Entity
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#component" >
                            Component
						</a>
						<ul>
							<li>
								<a
									href="#storage-models" >
                                    Storage Models
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#system" >
                            System
						</a>
						<ul>
							<li>
								<a
									href="#with-sparse-sets" >
                                    With Sparse Sets
								</a>
							</li>
							<li>
								<a
									href="#with-archetypes" >
                                    With Archetypes
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.15101.js" >
		</script>
	</body>
</html>
