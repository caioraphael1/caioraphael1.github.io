<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.33995.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Physics Engines
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Physics Engines/Physics Engines-theory.html" >
                                    Theory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Physics Engines/Physics Engines-options.html" >
                                    Options
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Physics Engines - JoltPhysics
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics-explanations.html" >
                                    Explanations
								</a>
								<ul>
									<li>
										<a
											href="#body-type" >
                                            Body Type
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#motion-types" >
                                            Motion Types
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#activation" >
                                            Activation
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#shapes" >
                                            Shapes
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#sensors" >
                                            Sensors
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#contact-manifold" >
                                            Contact Manifold
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#collisions" >
                                            Collisions
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#physics-properties" >
                                            Physics Properties
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#constraints" >
                                            Constraints
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#skeleton-and-ragdoll" >
                                            Skeleton &amp; Ragdoll
										</a>
									</li>
								</ul>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Explanations
					</h1>
					<p>
						<time
							datetime="2025-06-22" >
                            üïí Created: 2025-06-22
						</time>
						<time
							datetime="2026-01-30" >
                            | Updated: 2026-01-30
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<h3
	id="body-type" >
    Body Type
</h3>
<h5
	id="rigid" >
    Rigid
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="soft" >
    Soft
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h3
	id="motion-types" >
    Motion Types
</h3>
<h5
	id="static" >
    Static
</h5>
<ul>
	<li>
		<p>
            Non-movable.
		</p>
	</li>
</ul>
<h5
	id="dynamic" >
    Dynamic
</h5>
<ul>
	<li>
		<p>
            Responds to forces like a normal physics object.
		</p>
	</li>
</ul>
<h5
	id="kinematic" >
    Kinematic
</h5>
<ul>
	<li>
		<p>
            Movable using velocities only. Does not respond to forces.
		</p>
	</li>
	<li>
		<p>
            Kinematic objects are not affected by other kinematic/static objects.
		</p>
		<ul>
			<li>
				<p>
                    I believe this is standard because Kinematic Bodies have infinite mass, which makes interaction with other Kinematic and Static bodies tricky.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Note:
		</p>
		<ul>
			<li>
				<p>
                    From my understanding, Kinematic bodies can only interact with other Kinematic or Static Bodies through the Character/CharacterVirtual class.
				</p>
			</li>
			<li>
				<p>
                    I'm not familiar with Kinematic bodies yet.
				</p>
			</li>
			<li>
				<p>
                    I recommend looking into the Samples from JoltPhysics in C++; there are some examples of using Kinematic Bodies and Character/CharacterVirtual.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The physics engine will never change the velocity of a kinematic body; you need to do this yourself. If you stop calling 
            <code>MoveKinematic</code>
            &nbsp;the body will continue moving at the same speed forever. If you want the body to stop after arriving then call 
            <code>BodyInterface::SetLinearAndAngularVelocity(body_id, Vec3:sZero(), Vec3:sZero())</code>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Kinematic.
		</p>
		<ul>
			<li>
				<p>
                    I experimented changing the 'wall boxes' from 
                    <code>EMotionType::Dynamic</code>
                    &nbsp;to 
                    <code>EMotionType::Static</code>
                    , and the spheres just pass through the boxes without interacting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Rig/KinematicRig.
		</p>
		<ul>
			<li>
				<p>
                    I experimented changing the 'wall boxes' from 
                    <code>EMotionType::Dynamic</code>
                    &nbsp;to 
                    <code>EMotionType::Static</code>
                    , and the rig just passes through the boxes without interacting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Character.
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/CharacterVirtual.
		</p>
	</li>
</ul>
<h5
	id="change-motion-type" >
    Change Motion Type
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Change Motion Type.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Create body as static, but allow to become dynamic
BodyCreationSettings settings;
settings.SetShape(new BoxShape(Vec3(0.5f, 1.0f, 2.0f)));
settings.mPosition = RVec3(0, 10, 0);
settings.mMotionType = EMotionType::Static;
settings.mObjectLayer = Layers::MOVING; // Put in moving layer, this will result in some overhead when the body is static
settings.mAllowDynamicOrKinematic = true;
mBody = mBodyInterface-&gt;CreateBody(settings);
mBodyInterface-&gt;AddBody(mBody-&gt;GetID(), EActivation::Activate);

// .. toggling later
mBodyInterface-&gt;SetMotionType(mBody-&gt;GetID(), motion_type, EActivation::Activate);

// -&gt; Before Update
// Provide kinematic body a target
if (mBody-&gt;IsKinematic())
&nbsp;&nbsp;&nbsp;&nbsp;mBody-&gt;MoveKinematic(RVec3(Sin(mTime), 10, 0), Quat::sRotation(Vec3::sAxisX(), Cos(mTime)), inParams.mDeltaTime);
</code></pre>
<h3
	id="activation" >
    Activation
</h3>
<h5
	id="sleep" >
    Sleep
</h5>
<ul>
	<li>
		<p>
            &quot;Active and Deactive is just sleep. The body continues to register contacts normally. It is not ignored by the physics system.&quot;
		</p>
	</li>
	<li>
		<p>
            A physics_system can be configured to have a smaller sleep time, or to be configured so that no body will go to sleep.
		</p>
	</li>
	<li>
		<p>
            An individual body can also be configured to not be allowed to sleep via 
            <code>allowsleeping</code>
            .
		</p>
	</li>
	<li>
		<p>
            Sensors can't go to sleep, no matter what.
		</p>
	</li>
</ul>
<h5
	id="dynamic" >
    Dynamic
</h5>
<ul>
	<li>
		<p>
            If not a sensor:
		</p>
		<ul>
			<li>
				<p>
                    If activated and stopped, it will become deactivated after 0.5s (default defined in the physics system).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If deactivated and receives a collision, it will activate.
		</p>
	</li>
	<li>
		<p>
            A deactivated body is not moved by velocities during update; it stays still.
		</p>
		<ul>
			<li>
				<p>
                    It is still considered for contact detection, but it is not moved on its own.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="static" >
    Static
</h5>
<ul>
	<li>
		<p>
            When calling 
            <code>BodyInterface_AddBody</code>
            , it doesn't matter if defined as 
            <code>.Activate</code>
            &nbsp;or 
            <code>.Dont_Activate</code>
            , the body will be created as 
            <code>.Dont_Activate</code>
            .
		</p>
	</li>
	<li>
		<p>
            A static body cannot be activated, even when using the body_interface after it has already been created.
		</p>
	</li>
</ul>
<h3
	id="shapes" >
    Shapes
</h3>
<h5
	id="edges" >
    Edges
</h5>
<ul>
	<li>
		<p>
			<strong>
                Without Meshes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    Samples/General/Enhanced Internal Edge Removal.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">// A sphere
BodyCreationSettings sphere_bcs(new SphereShape(2.0f), pos, Quat::sIdentity(), EMotionType::Dynamic, Layers::MOVING);
sphere_bcs.mLinearVelocity = Vec3(20, 0, 0);
sphere_bcs.mEnhancedInternalEdgeRemoval = enhanced_removal == 1;
id = mBodyInterface-&gt;CreateAndAddBody(sphere_bcs, EActivation::Activate);
SetBodyLabel(id, labels[enhanced_removal]);
pos += RVec3(0, 0, 5.0_r);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                With Meshes
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>mesh_shape.mActiveEdgeCosThresholdAngle</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>mesh_settings.mEnhancedInternalEdgeRemoval = true</code>
                    .
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    Samples/General/Active Edges.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">// Settings for all frictionless boxes.
Ref&lt;BoxShape&gt; box_shape = new BoxShape(Vec3(1.0f, 1.0f, 1.0f), cDefaultConvexRadius);
BodyCreationSettings box_settings(box_shape, RVec3::sZero(), Quat::sIdentity(), EMotionType::Dynamic, Layers::MOVING);
box_settings.mFriction = 0.0f;
box_settings.mLinearDamping = 0.0f;
box_settings.mAllowSleeping = false;

// Mesh shape
MeshShapeSettings mesh_shape(triangles);
mesh_shape.SetEmbedded();
mesh_shape.mActiveEdgeCosThresholdAngle = Cos(DegreesToRadians(50.0f));
// Mesh
BodyCreationSettings mesh_settings(&mesh_shape, RVec3::sZero(), Quat::sIdentity(), EMotionType::Static, Layers::NON_MOVING);
&nbsp;&nbsp;&nbsp;&nbsp;// Instead of setting mesh_shape.mActiveEdgeCosThresholdAngle you can also set: mesh_settings.mEnhancedInternalEdgeRemoval = true.
mesh_settings.mFriction = 0.0f;
mBodyInterface-&gt;CreateAndAddBody(mesh_settings, EActivation::DontActivate);
</code></pre>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    Samples/General/Enhanced Internal Edge Removal.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">// Turn off regular active edge determination so that we only rely on the mEnhancedInternalEdgeRemoval flag
mesh_settings.mActiveEdgeCosThresholdAngle = -1.0f; 
// In the "Samples/General/Active Edges" example this is not used.
</code></pre>
	</li>
</ul>
<h5
	id="simshapefilter" >
    SimShapeFilter
</h5>
<ul>
	<li>
		<p>
            Set/get the shape filter that will be used during simulation. This can be used to exclude shapes within a body from colliding with each other.
		</p>
	</li>
	<li>
		<p>
            The PhysicsSystem does not own the ShapeFilter, make sure it stays alive during the lifetime of the PhysicsSystem.
		</p>
	</li>
	<li>
		<p>
			<em>
                Ex
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    If you have a high detail and a low detail collision model, you can attach them to the same body in a StaticCompoundShape and use the ShapeFilter to exclude the high detail collision model when simulating and exclude the low detail collision model when casting rays. Note that in this case you would need to pass the inverse of inShapeFilter to the CastRay function. Pass a nullptr to disable the shape filter.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">SetSimShapeFilter;
GetSimShapeFilter;
</code></pre>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Shape Filter (Collision Detection).
		</p>
	</li>
</ul>
<h5
	id="compoundshape" >
    CompoundShape
</h5>
<pre><code class="language-cpp" data-lang="cpp">// Compound shape
Ref&lt;Shape&gt; capsule = new CapsuleShape(2, 0.1f);
capsule-&gt;SetUserData(1); // Don't want the capsule to collide with the platform
Ref&lt;Shape&gt; sphere = new SphereShape(0.5f);
sphere-&gt;SetUserData(1); // Don't want the sphere to collide with the platform
Ref&lt;Shape&gt; box = new BoxShape(Vec3::sReplicate(0.5f));
Ref&lt;StaticCompoundShapeSettings&gt; compound = new StaticCompoundShapeSettings;
compound-&gt;AddShape(Vec3::sZero(), Quat::sIdentity(), capsule);
compound-&gt;AddShape(Vec3(0, -2, 0), Quat::sIdentity(), sphere);
compound-&gt;AddShape(Vec3(0, 2, 0), Quat::sIdentity(), box);

// Create compound
BodyCreationSettings compound_body(compound, RVec3(0, 15, 0), Quat::sIdentity(), EMotionType::Dynamic, Layers::MOVING);
mShapeFilter.mCompoundID[0] = mBodyInterface-&gt;CreateAndAddBody(compound_body, EActivation::Activate);
</code></pre>
<h5
	id="meshes" >
    Meshes
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="changing-shapes" >
    Changing Shapes
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Change Shape.
		</p>
		<ul>
			<li>
				<p>
                    Nothing special, just 
                    <code>mBodyInterface-&gt;SetShape(mBodyID, mShapes[mShapeIdx], true, EActivation::Activate);</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="sensors" >
    Sensors
</h3>
<ul>
	<li>
		<p>
            The cheapest sensor has a Static motion type. This type of sensor will only detect active bodies entering its area. As soon as a body goes to sleep, the contact will be lost. Note that you can still move a Static sensor around using 
            <code>BodyInterface::SetPosition</code>
            .
		</p>
	</li>
	<li>
		<p>
            When you make a sensor Kinematic or Dynamic and activate it, it will also detect collisions with sleeping bodies, albeit with a higher run-time cost.
		</p>
	</li>
</ul>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            A collision shape that detects overlaps/contacts but doesn‚Äôt generate physical responses.
		</p>
	</li>
	<li>
		<p>
            Use Cases:
		</p>
		<ul>
			<li>
				<p>
                    Detecting when a player enters a zone.
				</p>
			</li>
			<li>
				<p>
                    Custom logic for proximity (e.g., AI awareness).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            No friction/restitution applied.
		</p>
	</li>
	<li>
		<p>
            Also called a trigger (e.g., in Unity).
		</p>
	</li>
	<li>
		<p>
            Overlaps trigger callbacks (e.g., 
            <code>OnTriggerEnter</code>
            &nbsp;in Unity).
		</p>
	</li>
	<li>
		<p>
			<em>
                Exs
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    A pressure plate in a game that triggers a door opening.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="how-to-use" >
    How to use
</h5>
<ul>
	<li>
		<p>
            To detect collisions, it is normally used from a ContactListener; it is vital to obtain callbacks.
		</p>
	</li>
</ul>
<h5
	id="example" >
    Example
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Sensor.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// A static sensor that attracts dynamic bodies that enter its area
BodyCreationSettings sensor_settings(new SphereShape(10.0f), RVec3(0, 10, 0), Quat::sIdentity(), EMotionType::Static, Layers::SENSOR);
sensor_settings.mIsSensor = true;
mSensorID[StaticAttractor] = mBodyInterface-&gt;CreateAndAddBody(sensor_settings, EActivation::DontActivate);

// A static sensor that only detects active bodies
BodyCreationSettings sensor_settings(new BoxShape(Vec3::sReplicate(5.0f)), RVec3(-10, 5.1f, 0), Quat::sIdentity(), EMotionType::Static, Layers::SENSOR);
sensor_settings.mIsSensor = true;
mSensorID[StaticSensor] = mBodyInterface-&gt;CreateAndAddBody(sensor_settings, EActivation::DontActivate);

// A kinematic sensor that also detects sleeping bodies
BodyCreationSettings sensor_settings(new BoxShape(Vec3::sReplicate(5.0f)), RVec3(10, 5.1f, 0), Quat::sIdentity(), EMotionType::Kinematic, Layers::SENSOR);
sensor_settings.mIsSensor = true;
mSensorID[KinematicSensor] = mBodyInterface-&gt;CreateAndAddBody(sensor_settings, EActivation::Activate);
SetBodyLabel(mSensorID[KinematicSensor], "Kinematic sensor that also detects sleeping bodies");

// A kinematic sensor that also detects static bodies
BodyCreationSettings sensor_settings(new BoxShape(Vec3::sReplicate(5.0f)), RVec3(25, 5.1f, 0), Quat::sIdentity(), EMotionType::Kinematic, Layers::MOVING); 
&nbsp;&nbsp;&nbsp;&nbsp;// Put in a layer that collides with static
sensor_settings.mIsSensor = true;
sensor_settings.mCollideKinematicVsNonDynamic = true;
mSensorID[SensorDetectingStatic] = mBodyInterface-&gt;CreateAndAddBody(sensor_settings, EActivation::Activate);


// -&gt; Before Update

// Apply forces to dynamic bodies in StaticAttractor sensor.
lock_guard lock(mMutex);
RVec3 center(0, 10, 0);
float centrifugal_force = 10.0f;
Vec3 gravity = mPhysicsSystem-&gt;GetGravity();
for (const BodyAndCount &body_and_count : mBodiesInSensor[StaticAttractor])
{
&nbsp;&nbsp;&nbsp;&nbsp;BodyLockWrite body_lock(mPhysicsSystem-&gt;GetBodyLockInterface(), body_and_count.mBodyID);
&nbsp;&nbsp;&nbsp;&nbsp;if (body_lock.Succeeded())
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Body &body = body_lock.GetBody();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (body.IsKinematic())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate centrifugal acceleration
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec3 acceleration = Vec3(center - body.GetPosition());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float length = acceleration.Length();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length &gt; 0.0f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acceleration *= centrifugal_force / length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acceleration = Vec3::sZero();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw acceleration
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mDebugRenderer-&gt;DrawArrow(body.GetPosition(), body.GetPosition() + acceleration, Color::sGreen, 0.1f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Cancel gravity
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acceleration -= gravity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Apply as force
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body.AddForce(acceleration / body.GetMotionProperties()-&gt;GetInverseMass());
&nbsp;&nbsp;&nbsp;&nbsp;}
}

// -&gt; Callbacks
// See the callbacks in the file; they are important.

void SensorTest::OnContactAdded(...) {

}

/*
OnContactRemoved:
*/
</code></pre>
<h3
	id="contact-manifold" >
    Contact Manifold
</h3>
<h5
	id="contact-manifold" >
    Contact Manifold
</h5>
<ul>
	<li>
		<p>
            The set of data describing the contact points between two colliding objects.
		</p>
	</li>
	<li>
		<p>
            Used by the solver to compute collision responses (e.g., pushing objects apart).
		</p>
	</li>
	<li>
		<p>
            In Physics Engines, stores:
		</p>
		<ul>
			<li>
				<p>
                    Contact points (positions where objects touch).
				</p>
			</li>
			<li>
				<p>
                    Contact normals (direction to resolve collisions).
				</p>
			</li>
			<li>
				<p>
                    Penetration depth (how much objects overlap).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Types:
		</p>
		<ul>
			<li>
				<p>
                    Persistent Manifold: Reused across frames for efficiency (e.g., in Bullet/Box2D).
				</p>
			</li>
			<li>
				<p>
                    Discrete Manifold: Generated per collision (simpler cases).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Exs
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    A box resting on the ground has a manifold with 1‚Äì4 contact points (depending on engine optimizations).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Contact Manifold
		</p>
		<ul>
			<li>
				<p>
                    The example has nothing special, it just spawns objects at an angle to demonstrate contacts.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="collisions" >
    Collisions
</h3>
<h5
	id="ghost-collisions" >
    Ghost Collisions
</h5>
<ul>
	<li>
		<p>
            (2025-06-22)
		</p>
		<ul>
			<li>
				<p>
                    I had a problem with Ghost Collisions when loading tons of Boxes from LDtk.
				</p>
			</li>
			<li>
				<p>
                    *Without 
                    <code>StaticCompoundShape</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Using 
                            <code>BodyCreationSettings_SetEnhancedInternalEdgeRemoval</code>
                            &nbsp;for the protagonist did not help.
						</p>
					</li>
					<li>
						<p>
                            Using a 
                            <code>CapsuleShape</code>
                            &nbsp;instead of a 
                            <code>BoxShape</code>
                            &nbsp;did not help.
						</p>
					</li>
					<li>
						<p>
                            Changing the 
                            <code>ConvexRadius</code>
                            &nbsp;parameters of the 
                            <code>BoxShape</code>
                            &nbsp;did not help.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This was solved via 
                    <code>StaticCompoundShape</code>
                    , joining all the Boxes into a single body.
				</p>
				<ul>
					<li>
						<p>
                            I also used 
                            <code>BodyCreationSettings_SetEnhancedInternalEdgeRemoval</code>
                            &nbsp;for the protagonist; I did not use it for the 
                            <code>CompoundShape</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Other possible ideas were:
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            HeightFieldShape.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            Use of Meshes.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Conveyor Belt.
		</p>
		<ul>
			<li>
				<p>
                    ~I think it acts on the collided body manually after the contact is registered.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="physics-properties" >
    Physics Properties
</h3>
<h5
	id="gravity-factor" >
    Gravity Factor
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Gravity Factor.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">Body &body = *mBodyInterface-&gt;CreateBody(BodyCreationSettings(box, RVec3(-50.0f + i * 10.0f, 25.0f, 0), Quat::sIdentity(), EMotionType::Dynamic, Layers::MOVING));
body.GetMotionProperties()-&gt;SetGravityFactor(0.1f * i);
mBodyInterface-&gt;AddBody(body.GetID(), EActivation::Activate);
</code></pre>
<h5
	id="inverse-mass" >
    Inverse Mass
</h5>
<ul>
	<li>
		<p>
            Inverse mass ($\frac{1}{m}$‚Äã) is a computational optimization and mathematical trick used in physics engines to simplify calculations, particularly in constraint solving and collision response.
		</p>
		<ul>
			<li>
				<p>
                    Multiplying is faster than dividing.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For dynamic objects:
		</p>
		<ul>
			<li>
				<p>
                    Mass = $m$ ‚Üí Inverse mass = $\frac{1}{m}$‚Äã (a finite, positive value).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For static/immovable objects:
		</p>
		<ul>
			<li>
				<p>
                    Mass = $‚àû$ ‚Üí Inverse mass = $0$ (avoids division-by-infinity issues).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="friction" >
    Friction
</h5>
<ul>
	<li>
		<p>
            A force that opposes the relative motion between two surfaces in contact.
		</p>
	</li>
	<li>
		<p>
            Opposes relative motion between two surfaces in contact.
		</p>
	</li>
	<li>
		<p>
            Acts tangentially (parallel to the contact surface).
		</p>
	</li>
	<li>
		<p>
            Friction 
			<strong>
                requires contact
			</strong>
            &nbsp;and only acts when objects are touching.
		</p>
	</li>
	<li>
		<p>
			<em>
                Types
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Static friction: Prevents an object from moving when at rest (must be overcome to start sliding).
				</p>
			</li>
			<li>
				<p>
                    Dynamic (kinetic) friction: Slows down an object already in motion.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Depends on
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The friction coefficient (a material property, e.g., rubber vs. ice).
				</p>
			</li>
			<li>
				<p>
                    The normal force (how hard the surfaces are pressed together).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Exs
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    A box sliding on a rough floor slows down due to friction.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250622130934.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Friction.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Floor
Body &floor = *mBodyInterface-&gt;CreateBody(
&nbsp;&nbsp;&nbsp;&nbsp;BodyCreationSettings(new BoxShape(Vec3(100.0f, 1.0f, 100.0f), 0.0f), RVec3::sZero(), Quat::sRotation(Vec3::sAxisX(), 0.25f * JPH_PI), EMotionType::Static, Layers::NON_MOVING)
);
floor.SetFriction(1.0f);
mBodyInterface-&gt;AddBody(floor.GetID(), EActivation::DontActivate);

// Box
Body &body = *mBodyInterface-&gt;CreateBody(
&nbsp;&nbsp;&nbsp;&nbsp;BodyCreationSettings(box, RVec3(-50.0f + i * 10.0f, 55.0f, -50.0f), Quat::sRotation(Vec3::sAxisX(), 0.25f * JPH_PI), EMotionType::Dynamic, Layers::MOVING)
);
body.SetFriction(0.1f * i);
mBodyInterface-&gt;AddBody(body.GetID(), EActivation::Activate);
</code></pre>
<h5
	id="damping" >
    Damping
</h5>
<ul>
	<li>
		<p>
            A force that gradually reduces velocity over time (simulates drag/resistance).
		</p>
	</li>
	<li>
		<p>
            Acts like &quot;drag&quot; or &quot;viscous resistance,&quot; slowing down an object proportionally to its velocity.
		</p>
	</li>
	<li>
		<p>
            Applies globally (even without contact with other objects).
		</p>
	</li>
	<li>
		<p>
            Prevents objects from moving indefinitely and stabilizes simulations.
		</p>
	</li>
	<li>
		<p>
            Damping works 
			<strong>
                without contact
			</strong>
            &nbsp;and is like an &quot;invisible force&quot; slowing things down.
		</p>
	</li>
	<li>
		<p>
			<em>
                Types
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Linear damping: Slows down straight-line movement (translation).
				</p>
			</li>
			<li>
				<p>
                    Angular damping: Slows down rotation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Depends on
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    A damping coefficient (set per object, often between 
                    <code>0</code>
                    &nbsp;and 
                    <code>1</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    The object‚Äôs current velocity (higher velocity ‚Üí stronger damping).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Exs
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    A swinging pendulum gradually stops due to air resistance (modeled as damping).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Damping.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Floor
CreateFloor();

// Box
Body &body = *mBodyInterface-&gt;CreateBody(BodyCreationSettings(sphere, RVec3(-50.0f + i * 10.0f, 2.0f, -80.0f), Quat::sIdentity(), EMotionType::Dynamic, Layers::MOVING));
body.GetMotionProperties()-&gt;SetAngularDamping(0.0f);
body.GetMotionProperties()-&gt;SetLinearDamping(0.1f * i);
body.SetLinearVelocity(Vec3(0, 0, 10));
mBodyInterface-&gt;AddBody(body.GetID(), EActivation::Activate);
</code></pre>
<h5
	id="restitution" >
    Restitution
</h5>
<ul>
	<li>
		<p>
            A measure of how &quot;bouncy&quot; a collision is (elasticity).
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/Restitution.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Floor
CreateFloor();

// Box
BodyCreationSettings settings(sphere, RVec3(-50.0f + i * 10.0f, 20.0f, -20.0f), Quat::sIdentity(), EMotionType::Dynamic, Layers::MOVING);
settings.mRestitution = 0.1f * i;
settings.mLinearDamping = 0.0f;
BodyID id = mBodyInterface-&gt;CreateAndAddBody(settings, EActivation::Activate);
</code></pre>
<h3
	id="constraints" >
    Constraints
</h3>
<h5
	id="priority" >
    Priority
</h5>
<ul>
	<li>
		<p>
            'Samples/Constraint/Constraint Priority' explains this very well.
		</p>
	</li>
</ul>
<h5
	id="fixed-constraint" >
    Fixed Constraint
</h5>
<ul>
	<li>
		<p>
			<strong>
                DOFs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Rotation: 0 DOF
				</p>
			</li>
			<li>
				<p>
                    Translation: 0 DOF
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Use Case
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Welding two bodies together
				</p>
			</li>
			<li>
				<p>
                    Attaching parts that should move as one unit
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            See the problem of &quot;I want areas to follow bodies, for Hitboxes and Hurtboxes&quot;.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Create
fixed_constraint_settings: jolt.Fixed_Constraint_Settings
jolt.FixedConstraintSettings_Init(&fixed_constraint_settings)
fixed_constraint_settings.auto_detect_point = true
area.constraint = jolt.FixedConstraint_Create(&fixed_constraint_settings, body_to_fixate, area.body)
jolt.PhysicsSystem_AddConstraint(physics_system, area.constraint)

// Destroy
jolt.PhysicsSystem_RemoveConstraint(physics_system, area.constraint)
jolt.Constraint_Destroy(area.constraint)
</code></pre>
<h5
	id="dofs-degrees-of-freedom" >
    DOFs (Degrees Of Freedom)
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/General/2D funnel.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">BodyCreationSettings bcs(shapes[0], RVec3::sZero(), Quat::sIdentity(), EMotionType::Dynamic, Layers::MOVING);
bcs.mAllowedDOFs = EAllowedDOFs::Plane2D;
</code></pre>
<h5
	id="point-constraint" >
    Point Constraint
</h5>
<ul>
	<li>
		<p>
            Full rotational freedom.
		</p>
	</li>
	<li>
		<p>
			<strong>
                DOFs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Rotation: 3 DOFs
				</p>
			</li>
			<li>
				<p>
                    Translation: 0 DOF
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Use Case
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Shoulder joints
				</p>
			</li>
			<li>
				<p>
                    General-purpose free rotation where only positional constraint is needed.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="hinge-constraint" >
    Hinge Constraint
</h5>
<ul>
	<li>
		<p>
            Rotation only around a single axis.
		</p>
	</li>
	<li>
		<p>
			<strong>
                DOFs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Rotation: 1 DOF (around the hinge axis).
				</p>
			</li>
			<li>
				<p>
                    Translation: 0 DOFs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Use Case
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Elbows, knees
				</p>
			</li>
			<li>
				<p>
                    Wheels, doors
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            What distinguishes a soft hinge from a hard hinge is the use of spring configuration. A soft hinge uses springs:
		</p>
<pre><code class="language-cpp" data-lang="cpp">hinge.mLimitsSpringSettings.mFrequency = 1.0f;
hinge.mLimitsSpringSettings.mDamping = 0.5f;
</code></pre>
	</li>
	<li>
		<p>
            (2025-07-19) 
			<strong>
                What I used for hinge tests
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Important notes
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I felt 
							<strong>
                                instability
							</strong>
                            &nbsp;in the character's movement while a hinge was attached to the character.
						</p>
						<ul>
							<li>
								<p>
                                    It's easy to assume the swing of the 
                                    <code>second_body</code>
                                    &nbsp;caused the 
                                    <code>dynamic_body</code>
                                    &nbsp;of the character to sway by inertia.
								</p>
							</li>
							<li>
								<p>
                                    Removing the system solved the problem.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">// -&gt; In Character_User
second_body:&nbsp;&nbsp;eng.Dynamic_Body,
hinge: ^jolt.Hinge_Constraint,

// -&gt; At spawn
eng.dynamic_body_create(
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body = &personagem.second_body,
&nbsp;&nbsp;&nbsp;&nbsp;shape = jolt.SphereShape_Create(eng.from_world_to_physics_space(3)),
&nbsp;&nbsp;&nbsp;&nbsp;pos = {},
&nbsp;&nbsp;&nbsp;&nbsp;layers = u32(Object_Layer.Dynamic_Body),
&nbsp;&nbsp;&nbsp;&nbsp;child_transform = nil,
&nbsp;&nbsp;&nbsp;&nbsp;can_rotate = true,
)

hinge_settings: jolt.Hinge_Constraint_Settings
jolt.HingeConstraintSettings_Init(&hinge_settings)

hinge_settings.space = .Local_To_Body_COM
hinge_settings.point1 = { 0, 0, 0 }
hinge_settings.point2 = { 1, 0, 0 }
hinge_settings.hinge_axis1&nbsp;&nbsp;= { 0, 0, 1 }
hinge_settings.hinge_axis2&nbsp;&nbsp;= { 0, 0, 1 }
hinge_settings.normal_axis1 = { 1, 0, 0 }
hinge_settings.normal_axis2 = { 0, 1, 0 }
hinge_settings.limits_max = 0 * rl.DEG2RAD
hinge_settings.limits_min = -90 * rl.DEG2RAD

personagem.hinge = jolt.HingeConstraint_Create(&hinge_settings, personagem.dynamic_body, personagem.second_body)
// personagem.hinge = jolt.HingeConstraint_Create(&hinge_settings, personagem.second_body, personagem.dynamic_body)
jolt.PhysicsSystem_AddConstraint(eng.physics_system, personagem.hinge)
</code></pre>
	</li>
</ul>
<h5
	id="cone-constraint" >
    Cone Constraint
</h5>
<ul>
	<li>
		<p>
            Allows swing within a cone and optional twist around the axis.
		</p>
	</li>
	<li>
		<p>
			<strong>
                DOFs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Swing: 2 DOF (inside a cone)
				</p>
			</li>
			<li>
				<p>
                    Twist: 1 DOF (about the constraint axis; often limited)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Use Case
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Shoulder joints with realistic swing and twist
				</p>
			</li>
			<li>
				<p>
                    Ragdoll simulation (e.g., upper arms, hips)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="skeleton-and-ragdoll" >
    Skeleton &amp; Ragdoll
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Rig/CreateRigTest.cpp | Samples/Utils/RagdollLoader.cpp
		</p>
		<ul>
			<li>
				<p>
                    Contain only a helper to create a ragdoll manually, as shown in 'Samples/Utils/RagdollLoader.cpp'.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">// Create skeleton
Ref&lt;Skeleton&gt; skeleton = new Skeleton;
uint lower_body = skeleton-&gt;AddJoint("LowerBody");
uint mid_body = skeleton-&gt;AddJoint("MidBody", lower_body);
uint upper_body = skeleton-&gt;AddJoint("UpperBody", mid_body);
/*uint head =*/ skeleton-&gt;AddJoint("Head", upper_body);
uint upper_arm_l = skeleton-&gt;AddJoint("UpperArmL", upper_body);
uint upper_arm_r = skeleton-&gt;AddJoint("UpperArmR", upper_body);
/*uint lower_arm_l =*/ skeleton-&gt;AddJoint("LowerArmL", upper_arm_l);
/*uint lower_arm_r =*/ skeleton-&gt;AddJoint("LowerArmR", upper_arm_r);
uint upper_leg_l = skeleton-&gt;AddJoint("UpperLegL", lower_body);
uint upper_leg_r = skeleton-&gt;AddJoint("UpperLegR", lower_body);
/*uint lower_leg_l =*/ skeleton-&gt;AddJoint("LowerLegL", upper_leg_l);
/*uint lower_leg_r =*/ skeleton-&gt;AddJoint("LowerLegR", upper_leg_r);

// ..
// Create arrays of shapes, positions, rotations, constraint positions, twist axis, twist angle, normal angle, plane angle.
// ..

// Create ragdoll settings
RagdollSettings *settings = new RagdollSettings;
settings-&gt;mSkeleton = skeleton;
settings-&gt;mParts.resize(skeleton-&gt;GetJointCount());
for (int p = 0; p &lt; skeleton-&gt;GetJointCount(); ++p)
{
&nbsp;&nbsp;&nbsp;&nbsp;RagdollSettings::Part &part = settings-&gt;mParts[p];
&nbsp;&nbsp;&nbsp;&nbsp;part.SetShape(shapes[p]);
&nbsp;&nbsp;&nbsp;&nbsp;part.mPosition = positions[p];
&nbsp;&nbsp;&nbsp;&nbsp;part.mRotation = rotations[p];
&nbsp;&nbsp;&nbsp;&nbsp;part.mMotionType = EMotionType::Dynamic;
&nbsp;&nbsp;&nbsp;&nbsp;part.mObjectLayer = Layers::MOVING;
&nbsp;&nbsp;&nbsp;&nbsp;// First part is the root, doesn't have a parent and doesn't have a constraint
&nbsp;&nbsp;&nbsp;&nbsp;if (p &gt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SwingTwistConstraintSettings *constraint = new SwingTwistConstraintSettings;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mDrawConstraintSize = 0.1f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mPosition1 = constraint-&gt;mPosition2 = constraint_positions[p];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mTwistAxis1 = constraint-&gt;mTwistAxis2 = twist_axis[p];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mPlaneAxis1 = constraint-&gt;mPlaneAxis2 = Vec3::sAxisZ();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mTwistMinAngle = -DegreesToRadians(twist_angle[p]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mTwistMaxAngle = DegreesToRadians(twist_angle[p]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mNormalHalfConeAngle = DegreesToRadians(normal_angle[p]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint-&gt;mPlaneHalfConeAngle = DegreesToRadians(plane_angle[p]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part.mToParent = constraint;
&nbsp;&nbsp;&nbsp;&nbsp;}
}

// Optional: Stabilize the inertia of the limbs
settings-&gt;Stabilize();
// Disable parent child collisions so that we don't get collisions between constrained bodies
settings-&gt;DisableParentChildCollisions();
// Calculate the map needed for GetBodyIndexToConstraintIndex()
settings-&gt;CalculateBodyIndexToConstraintIndex();
</code></pre>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Rig/LoadRigTest.cpp | Samples/Utils/RagdollLoader.cpp
		</p>
		<ul>
			<li>
				<p>
                    Code to load a 
                    <code>Human.tof</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The load code is in 'Samples/Utils/RagdollLoader.cpp'.
				</p>
			</li>
			<li>
				<p>
                    As I understand it, the file is read, marshalled, and then the constraints are created manually based on features contained in the read file.
				</p>
			</li>
			<li>
				<p>
                    The creation of the rig / skeleton appears to be done automatically when passing a pointer to a 
                    <code>ragdoll_settings</code>
                    ; only constraints are not created automatically.
				</p>
			</li>
			<li>
				<p>
                    The load function belongs to 
                    <code>ObjectStream</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            ObjectStreamIn contains all logic for reading an object from disk. It is the base class for the text and binary input streams (ObjectStreamTextIn and ObjectStreamBinaryIn).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Rig/KinematicRigTest.cpp.
		</p>
		<ul>
			<li>
				<p>
                    Two interesting things:
				</p>
				<ul>
					<li>
						<p>
                            The rig is kinematic, so it can interact with Dynamic Bodies but not with Static Bodies.
						</p>
					</li>
					<li>
						<p>
                            An animation is applied to the Rig.
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">// -&gt; On init, after creating the ragdoll:
mPose.SetSkeleton(mRagdollSettings-&gt;GetSkeleton());
// Position ragdoll
mAnimation-&gt;Sample(0.0f, mPose);
mPose.CalculateJointMatrices();
mRagdoll-&gt;SetPose(mPose);

// -&gt; On pre_physics_update:
// Sample previous pose and draw it (ragdoll should have achieved this position)
mAnimation-&gt;Sample(mTime, mPose);
mPose.CalculateJointMatrices();
// Update time
mTime += inParams.mDeltaTime;
// Sample new pose
mAnimation-&gt;Sample(mTime, mPose);
mPose.CalculateJointMatrices();
mRagdoll-&gt;DriveToPoseUsingKinematics(mPose, inParams.mDeltaTime);
</code></pre>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Rig/PoweredRigTest.cpp
		</p>
		<ul>
			<li>
				<p>
                    Basically the same as 'Samples/Rig/KinematicRigTest.cpp', but it changes how pre_update is done:
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">// -&gt; On init, after creating the ragdoll:
mPose.SetSkeleton(mRagdollSettings-&gt;GetSkeleton());
// Position ragdoll
mAnimation-&gt;Sample(0.0f, mPose);
mPose.CalculateJointMatrices();
mRagdoll-&gt;SetPose(mPose);

// -&gt; On pre_physics_update:
// Update time
mTime += inParams.mDeltaTime;
// Sample new pose
mAnimation-&gt;Sample(mTime, mPose);
// Place the root joint on the first body so that we draw the pose in the right place
RVec3 root_offset;
SkeletonPose::JointState &joint = mPose.GetJoint(0);
joint.mTranslation = Vec3::sZero(); // All the translation goes into the root offset
mRagdoll-&gt;GetRootTransform(root_offset, joint.mRotation);
mPose.SetRootOffset(root_offset);
mPose.CalculateJointMatrices();
mRagdoll-&gt;DriveToPoseUsingMotors(mPose);
</code></pre>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Rig/LoadSaveRigTest.cpp.
		</p>
		<ul>
			<li>
				<p>
                    Same as 'LoadRigTest', but changes are saved via 
                    <code>ObjectStreamOut:sWriteObject(data, ObjectStream:EStreamType:Text, *settings)</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Samples/Rig/LoadSaveBinaryRigTest.cpp.
		</p>
		<ul>
			<li>
				<p>
                    Same as 'LoadRigTest', but changes are saved via 
                    <code>mSkeleton-&gt;SaveBinaryState(inStream)</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.33995.js" >
		</script>
	</body>
</html>
