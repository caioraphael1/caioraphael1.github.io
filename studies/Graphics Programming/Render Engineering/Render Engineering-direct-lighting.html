<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.89309.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
>
					<summary>
                        Vulkan
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                Samples
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                Core
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                Render Loop
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                Synchronization and Cache Control
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                Command Buffers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                Pipelines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                Compute Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                Resources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                Depth
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                Mapping Data to Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                Memory Allocation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                HDR Support
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                Profiling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                Mobile
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                VR
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                Video Decoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                SPIR-V
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                Web
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Render Engineering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                Graphics APIs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                Shader Languages
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                Choosing the Space to compute Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                BSDF (Bidirectional Scattering Distribution Function)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                Material
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                Direct Lighting
							</a>
							<ul>
								<li>
									<a
										href="#parametrization" >
                                        Parametrization
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#directional-lights" >
                                        Directional Lights
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#punctual-lights" >
                                        Punctual Lights
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#photometric-lights" >
                                        Photometric Lights
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mobile-adaptations" >
                                        Mobile Adaptations
									</a>
									<ul>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                Shadows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                Skybox / Skydome
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                Transparency
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                Global Illumination / Indirect Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                Global Illumination - Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                Global Illumination - Discarded Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                Lightmaps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                Post-Processing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                Anti-Aliasing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                Light Path / Rendering Method
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                Optimization Techniques
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Graphics and Shaders
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                Sources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                Math, Linear Algebra
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                Spaces, Transformations and Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                Common Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                Shaders
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GLSL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                Storage Qualifiers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                Layout Qualifiers
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GPU
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                Execution Building Blocks
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                Specialized units &amp; instructions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                Cache
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                GPU VA (Virtual Address)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                Tiled-GPUs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Slang
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang-slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Font Rendering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                Text Processing Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                Formats
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                Libs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                Fonts
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        OpenGL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Direct Lighting
						</h1>
						<p>
							<time
								datetime="2025-07-03" >
                                üïí Created: 2025-07-03
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h3
	id="parametrization" >
    Parametrization
</h3>
<ul>
	<li>
		<p>
            To simplify the implementation, all luminous powers will converted to luminous intensities () before being sent to the shader. The conversion is light dependent and is explained in the previous sections.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Type
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Directional, point, spot or area
				</p>
			</li>
			<li>
				<p>
                    Can be inferred from other parameters (e.g. a point light has a length, radius, inner angle and outer angle of 0).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Direction
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used for directional lights, spot lights, photometric point lights, and linear and tubular area lights (orientation)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Color
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The color of emitted light, as a linear RGB color. Can be specified as an sRGB color or a color temperature in the tools
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Intensity
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The light's brightness. The unit depends on the type of light
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Falloff radius
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Maximum distance of influence
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Inner angle
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Angle of the inner cone for spot lights, in degrees
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Outer angle
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Angle of the outer cone for spot lights, in degrees
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Length
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Length of the area light, used to create linear or tubular lights
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Radius
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Radius of the area light, used to create spherical or tubular lights
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Photometric profile
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Texture representing a photometric light profile, works only for punctual lights
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Masked profile
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Boolean indicating whether the IES profile is used as a mask or not. When used as a mask, the light's brightness will be multiplied by the ratio between the user specified intensity and the integrated IES profile intensity. When not used as a mask, the user specified intensity is ignored but the IES multiplier is used instead
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Photometric multiplier
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Brightness multiplier for photometric lights (if IES as mask is turned off)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="color-temperature" >
    Color Temperature
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911113125.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            I got a little lost about this. See this 
			<a
				href="https://google.github.io/filament/Filament.html.html#mjx-eqn%3Akrystek" 
				class="internal-link" 
				target="_self" >
                session
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Convert from the XYZ space to linear RGB with a simple 3√ó3 matrix.
		</p>
	</li>
	<li>
		<p>
            Conversion using the inverse matrix for the sRGB color space:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911113236.png" width="387" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The result of these operations is a linear RGB triplet in the sRGB color space.
		</p>
	</li>
	<li>
		<p>
            Since we care about the chromaticity of the results, we must apply a normalization step to avoid clamping values greater than 1.0 and distort resulting colors:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911113304.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            We must finally apply the sRGB opto-electronic conversion function (OECF) to obtain a displayable value (the value should remain linear if passed to the renderer for shading).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911113351.png" width="443" >
            .
		</p>
	</li>
</ul>
<h3
	id="directional-lights" >
    Directional Lights
</h3>
<ul>
	<li>
		<p>
            The main purpose of directional lights is to recreate important light sources for outdoor environment, i.e. the sun and/or the moon. While directional lights do not truly exist in the physical world, any light source sufficiently far from the light receptor can be assumed to be directional
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911110921.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111039.png" width="" >
            .
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Illuminance
					</strong>
                    &nbsp;is measured with the unit 
					<strong>
                        Lux
					</strong>
                    &nbsp;($lx$); $lx$ is the symbol, like $W$ for 
					<em>
                        Watts
					</em>
                    .
                    <br>
                    <img src="assets/image_20250911111413.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Dynamic directional lights are particularly cheap to evaluate at runtime.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 l = normalize(-lightDirection);
float NoL = clamp(dot(n, l), 0.0, 1.0);
// lightIntensity is the illuminance
// at perpendicular incidence in lux
float illuminance = lightIntensity * NoL;
vec3 luminance = BSDF(v, l) * illuminance;
</code></pre>
<h3
	id="punctual-lights" >
    Punctual Lights
</h3>
<ul>
	<li>
		<p>
            For punctual lights following the inverse square law, we use:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111706.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            Where $d$ is the distance from a point at the surface to the light.
		</p>
	</li>
</ul>
<h5
	id="point-lights" >
    Point Lights
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911111739.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111759.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111829.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Physically based punctual lights
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Note that the light intensity used in this piece of code is the luminous intensity in , converted from the luminous power CPU-side. This snippet is not optimized and some of the computations can be offloaded to the CPU (for instance the square of the light's inverse falloff radius, or the spot scale and angle).
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">float getSquareFalloffAttenuation(vec3 posToLight, float lightInvRadius) {
&nbsp;&nbsp;&nbsp;&nbsp;float distanceSquare = dot(posToLight, posToLight);
&nbsp;&nbsp;&nbsp;&nbsp;float factor = distanceSquare * lightInvRadius * lightInvRadius;
&nbsp;&nbsp;&nbsp;&nbsp;float smoothFactor = max(1.0 - factor * factor, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;return (smoothFactor * smoothFactor) / max(distanceSquare, 1e-4);
}

float getSpotAngleAttenuation(vec3 l, vec3 lightDir,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float innerAngle, float outerAngle) {
&nbsp;&nbsp;&nbsp;&nbsp;// the scale and offset computations can be done CPU-side
&nbsp;&nbsp;&nbsp;&nbsp;float cosOuter = cos(outerAngle);
&nbsp;&nbsp;&nbsp;&nbsp;float spotScale = 1.0 / max(cos(innerAngle) - cosOuter, 1e-4)
&nbsp;&nbsp;&nbsp;&nbsp;float spotOffset = -cosOuter * spotScale

&nbsp;&nbsp;&nbsp;&nbsp;float cd = dot(normalize(-lightDir), l);
&nbsp;&nbsp;&nbsp;&nbsp;float attenuation = clamp(cd * spotScale + spotOffset, 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;return attenuation * attenuation;
}

vec3 evaluatePunctualLight() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 l = normalize(posToLight);
&nbsp;&nbsp;&nbsp;&nbsp;float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 posToLight = lightPosition - worldPosition;

&nbsp;&nbsp;&nbsp;&nbsp;float attenuation;
&nbsp;&nbsp;&nbsp;&nbsp;attenuation&nbsp;&nbsp;= getSquareFalloffAttenuation(posToLight, lightInvRadius);
&nbsp;&nbsp;&nbsp;&nbsp;attenuation *= getSpotAngleAttenuation(l, lightDir, innerAngle, outerAngle);

&nbsp;&nbsp;&nbsp;&nbsp;vec3 luminance = (BSDF(v, l) * lightIntensity * attenuation * NoL) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp;return luminance;
}


vec3 l = normalize(-lightDirection);
float NoL = clamp(dot(n, l), 0.0, 1.0);

// lightIntensity is the illuminance
// at perpendicular incidence in lux
float illuminance = lightIntensity * NoL;
vec3 luminance = BSDF(v, l) * illuminance;
</code></pre>
	</li>
</ul>
<h5
	id="spot-lights" >
    Spot Lights
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911111900.png" width="400" >
            .
		</p>
	</li>
	<li>
        <img src="assets/image_20250911111959.png" width="500" >

	</li>
	<li>
		<p>
            <img src="assets/image_20250911112027.png" width="400" >
            .
		</p>
	</li>
</ul>
<h3
	id="photometric-lights" >
    Photometric Lights
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911112803.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911112748.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            Implementation:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float getPhotometricAttenuation(vec3 posToLight, vec3 lightDir) {
&nbsp;&nbsp;&nbsp;&nbsp;float cosTheta = dot(-posToLight, lightDir);
&nbsp;&nbsp;&nbsp;&nbsp;float angle = acos(cosTheta) * (1.0 / PI);
&nbsp;&nbsp;&nbsp;&nbsp;return texture2DLodEXT(lightProfileMap, vec2(angle, 0.0), 0.0).r;
}

vec3 evaluatePunctualLight() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 l = normalize(posToLight);
&nbsp;&nbsp;&nbsp;&nbsp;float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 posToLight = lightPosition - worldPosition;

&nbsp;&nbsp;&nbsp;&nbsp;float attenuation;
&nbsp;&nbsp;&nbsp;&nbsp;attenuation&nbsp;&nbsp;= getSquareFalloffAttenuation(posToLight, lightInvRadius);
&nbsp;&nbsp;&nbsp;&nbsp;attenuation *= getSpotAngleAttenuation(l, lightDirection, innerAngle, outerAngle);
&nbsp;&nbsp;&nbsp;&nbsp;attenuation *= getPhotometricAttenuation(l, lightDirection);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This is the addition to the Punctual Light. It requires a lightProfileMap, etc.

&nbsp;&nbsp;&nbsp;&nbsp;float luminance = (BSDF(v, l) * lightIntensity * attenuation * NoL) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp;return luminance;
}
</code></pre>
<ul>
	<li>
		<p>
            The light intensity is computed CPU-side and depends on whether the photometric profile is used as a mask.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float multiplier;
// Photometric profile used as a mask
if (photometricLight.isMasked()) {
&nbsp;&nbsp;&nbsp;&nbsp;// The desired intensity is set by the artist
&nbsp;&nbsp;&nbsp;&nbsp;// The integrated intensity comes from a Monte-Carlo
&nbsp;&nbsp;&nbsp;&nbsp;// integration over the unit sphere around the luminaire
&nbsp;&nbsp;&nbsp;&nbsp;multiplier = photometricLight.getDesiredIntensity() /
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;photometricLight.getIntegratedIntensity();
} else {
&nbsp;&nbsp;&nbsp;&nbsp;// Multiplier provided for convenience, set to 1.0 by default
&nbsp;&nbsp;&nbsp;&nbsp;multiplier = photometricLight.getMultiplier();
}

// The max intensity in cd comes from the IES profile
float lightIntensity = photometricLight.getMaxIntensity() * multiplier;
</code></pre>
<h3
	id="mobile-adaptations" >
    Mobile Adaptations
</h3>
<h5
	id="pre-expose-lights" >
    Pre-Expose Lights
</h5>
<ul>
	<li>
		<p>
            &quot;How to store and handle the large range of values produced by the lighting code?&quot;
		</p>
	</li>
	<li>
		<p>
            Assuming computations performed at full precision in the shaders, we still want to be able to store the linear output of the lighting pass in a reasonably sized buffer (
            <code>RGB16F</code>
            &nbsp;or equivalent).
		</p>
	</li>
	<li>
		<p>
            The most obvious and easiest way to achieve this is to simply apply the camera exposure before writing out the result of the lighting pass.
		</p>
	</li>
	<li>
		<p>
            Pre-exposing lights allows the entire shading pipeline to use half precision floats.
		</p>
	</li>
	<li>
		<p>
            In practice we pre-expose the following lights:
		</p>
		<ul>
			<li>
				<p>
                    Punctual lights (point and spot):
				</p>
				<ul>
					<li>
						<p>
                            on the GPU
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Directional light:
				</p>
				<ul>
					<li>
						<p>
                            on the CPU
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    IBLs:
				</p>
				<ul>
					<li>
						<p>
                            on the CPU
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Material emissive:
				</p>
				<ul>
					<li>
						<p>
                            on the GPU
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This can be easily done with:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">fragColor = luminance * camera.exposure;
</code></pre>
<ul>
	<li>
		<p>
            But, this requires intermediate computations to be performed with single precision floats.
		</p>
	</li>
	<li>
		<p>
            We would instead prefer to perform all (or at least most) of the lighting work using half precision floats instead.
		</p>
	</li>
	<li>
		<p>
            Doing so can greatly improve performance and power usage, particularly on mobile devices. Half precision floats are however ill-suited for this kind of work as common illuminance and luminance values (for the sun for instance) can exceed their range.
		</p>
	</li>
	<li>
		<p>
            The solution is to simply pre-expose the lights themselves instead of the result of the lighting pass.
		</p>
	</li>
	<li>
		<p>
            This can be done efficiently on the 
			<strong>
                CPU
			</strong>
            &nbsp;if updating a light's constant buffer is cheap.
		</p>
	</li>
	<li>
		<p>
            This can also be done on the 
			<strong>
                GPU
			</strong>
            , like so:
		</p>
<pre><code class="language-glsl" data-lang="glsl">// The inputs must be highp/single precision,
// both for range (intensity) and precision (exposure)
// The output is mediump/half precision
float computePreExposedIntensity(highp float intensity, highp float exposure) {
&nbsp;&nbsp;&nbsp;&nbsp;return intensity * exposure;
}

Light getPointLight(uint index) {
&nbsp;&nbsp;&nbsp;&nbsp;Light light;
&nbsp;&nbsp;&nbsp;&nbsp;uint lightIndex = // fetch light index;

&nbsp;&nbsp;&nbsp;&nbsp;// the intensity must be highp/single precision
&nbsp;&nbsp;&nbsp;&nbsp;highp vec4 colorIntensity&nbsp;&nbsp;= lightsUniforms.lights[lightIndex][1];

&nbsp;&nbsp;&nbsp;&nbsp;// pre-expose the light
&nbsp;&nbsp;&nbsp;&nbsp;light.colorIntensity.w = computePreExposedIntensity(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorIntensity.w, frameUniforms.exposure);

&nbsp;&nbsp;&nbsp;&nbsp;return light;
}
</code></pre>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-10-21 .&nbsp;&nbsp;2026-01-23 üöÄ
			</footer>
		</div>
		<script
			src="/static/studies.89309.js" >
		</script>
	</body>
</html>
