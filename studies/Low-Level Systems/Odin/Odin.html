<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
>
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering.html" >
                                Font Rendering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Low-Level Systems
					</summary>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Low-Level Systems/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers.html" >
                                Profilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - DOD e COP/Design - DOD e COP.html" >
                                Design - DOD e COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - ECS/Design - ECS.html" >
                                Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Design Patterns/Design - Design Patterns.html" >
                                Design - Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Architecture Patterns.html" >
                                Design - Architecture Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Concepts and Terminology.html" >
                                Design - Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Rules of thumb - Laws - Guidelines and Principles/Design - Rules of thumb - Laws - Guidelines and Principles.html" >
                                Design - Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Paradigms.html" >
                                Design - Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Production Methodologies/Design - Production Methodologies.html" >
                                Design - Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Security.html" >
                                Security
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Game Development
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game AI/Game AI.html" >
                                Game AI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Procedural Animation/Procedural Animation.html" >
                                Procedural Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game Design/Game Design.html" >
                                Game Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Level Design.html" >
                                Level Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Scanning Algorithms.html" >
                                Scanning Algorithms
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Art
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing, Color Theory, Pixel Art/Drawing, Color Theory, Pixel Art.html" >
                                Drawing, Color Theory, Pixel Art
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Low-Poly, PSX.html" >
                                Low-Poly, PSX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Animation.html" >
                                Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Texel Density.html" >
                                Texel Density
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender.html" >
                                Blender
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender - Rigging and Animation.html" >
                                Blender - Rigging and Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench.html" >
                                Blockbench
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench - Source Code.html" >
                                Blockbench - Source Code
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing Softwares.html" >
                                Drawing Softwares
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Aseprite/Aseprite.html" >
                                Aseprite
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Voxel Editors.html" >
                                Voxel Editors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/MagicaVoxel.html" >
                                MagicaVoxel
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 2D/Level Editors 2D.html" >
                                Level Editors 2D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 3D.html" >
                                Level Editors 3D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/LDtk/LDtk.html" >
                                LDtk
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/TrenchBroom.html" >
                                TrenchBroom
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Assets - Sources and References/Assets - Sources and References.html" >
                                Assets - Sources and References
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Frameworks - Libraries
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Frameworks - Libraries/Frameworks - Libraries.html" >
                                Frameworks - Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Raylib/RayLib.html" >
                                RayLib
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Clay/Clay.html" >
                                Clay
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Physics Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines.html" >
                                Physics Engines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics.html" >
                                Physics Engines - JoltPhysics
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML - Tests/HTML - Tests.html" >
                                HTML - Tests
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Godot Engine
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot/Godot.html" >
                                Godot
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDScript/Godot - GDScript.html" >
                                Godot - GDScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDExtensions.html" >
                                Godot - GDExtensions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - Source Code.html" >
                                Godot - Source Code
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Embedded Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/RaspiberryPi.html" >
                                RaspiberryPi
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Platforms
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Windows/Windows.html" >
                                Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Steam/Steam.html" >
                                Steam
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Android/Android.html" >
                                Android
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/iOS/iOS.html" >
                                iOS
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Terminal
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Code Editors
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim/NeoVim.html" >
                                NeoVim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Etc
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Licenses.html" >
                                Licenses
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Unity/Unity.html" >
                                Unity
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Other Engines.html" >
                                Other Engines
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Odin
						</h1>
						<p>
							<time
								datetime="2025-03-28" >
                                ðŸ•’ Created: 2025-03-28
							</time>
							<time
								datetime="2025-11-20" >
                                | Updated: 2025-11-20
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="about" >
    About
</h2>
<ul>
	<li>
		<p>
            Open-source.
		</p>
	</li>
	<li>
		<p>
            Created on [2016/07/07].
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/" 
				class="external-link" 
				target="_blank" >
                Overview
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/examples/" 
				class="external-link" 
				target="_blank" >
                Basic Examples
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/faq/" 
				class="external-link" 
				target="_blank" >
                FAQ
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/rCqFdYUnC24?si=b86ASVjw-RKkri19&t=602" 
				class="external-link" 
				target="_blank" >
                Brief Explanation {10:02 -&gt; end}
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=mljzCWnvWCs" 
				class="external-link" 
				target="_blank" >
                Tips for searching information in the source code
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/faq/#what-does-odin-offer-over-other-languages" 
				class="external-link" 
				target="_blank" >
                Features compared to other languages
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Philosophy
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Simplicity and readability
				</p>
			</li>
			<li>
				<p>
                    Programs are about transforming data into other forms of data.
				</p>
				<ul>
					<li>
						<p>
                            Data structures are just data.
						</p>
					</li>
					<li>
						<p>
                            Odin is not OOP.
						</p>
					</li>
					<li>
						<p>
                            Odin doesn't have any methods.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The entire language specification should be possible to be memorized by a mere mortal.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.gingerbill.org/article/2024/09/08/odin-weird-to-market/" 
						class="external-link" 
						target="_blank" >
                        Odin Market is Weird
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            &quot;The killer feature is that it has no features&quot;.
						</p>
					</li>
					<li>
						<p>
                            &quot;bring them the 'joy of programming' back&quot;.
						</p>
					</li>
					<li>
						<p>
                            He ends the article by asking how to market the language, he doesn't know himself.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Paradigm
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Focus on the procedural paradigm.
				</p>
			</li>
			<li>
				<p>
                    GingerBill: &quot;Odin is not a Functional Programming Language&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Roadmap
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    FAQ:
				</p>
				<ul>
					<li>
						<p>
                            There is no official roadmap. Public roadmaps are pretty much a form of marketing for the language rather than being anything useful for the development team. The development team does have internal goals, many of which are not viewable by the public, and problems are dealt with when and as necessary.
						</p>
					</li>
					<li>
						<p>
                            Odin as a language is pretty much done, but Odin the compiler, toolchain, and core library are still in development and always improved.&quot;
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                C Integration
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Odin was designed to facilitate integration with C code. It supports interfacing with C libraries directly and interoperability with other languages is facilitated.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Metaprogramming
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Odin offers some metaprogramming facilities, such as macros and templates, without becoming overly complex.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Compiler
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Written in C++.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Aimed systems
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Ginger Bill:
				</p>
				<ul>
					<li>
						<p>
                            Odin has been designed specifically for modern systems: 32-bit and 64-bit platforms.
						</p>
					</li>
					<li>
						<p>
                            I highly recommend you don't use Odin, Zig or C for 8-bit chips; prefer a high-level assembly language instead.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Style
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We are not going to enforce any case style ever. You can do whatever you want.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=W2rwB1LTSF8" 
				class="external-link" 
				target="_blank" >
                Karl Zylinski on Odin and Raylib
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Burnout with Unreal Engine&quot;.
				</p>
				<ul>
					<li>
						<p>
                            No idea of what is happening in the engine.
						</p>
					</li>
					<li>
						<p>
                            Difficult and slow interaction.
						</p>
					</li>
					<li>
						<p>
                            C++.
						</p>
					</li>
					<li>
						<p>
                            etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;Odin fell into my lap and was perfect for what I wanted&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;Hotreloading was the best thing I did; without it I would have gotten discouraged, because I am very impatient with iteration times&quot;.
				</p>
				<ul>
					<li>
						<p>
                            Many things are in .dlls that are observed so if there are changes they reload, something like that.
						</p>
					</li>
					<li>
						<p>
                            &quot;Don't necessarily create config files to tweak the game, but use code as data for tweaks&quot;.
						</p>
						<ul>
							<li>
								<p>
                                    Nah. Maybe if there is actual hotreloading it can be okay, but a config file is very useful at times.
								</p>
							</li>
							<li>
								<p>
                                    I think they are not mutually exclusive; config files are good for some things and hotreloading for fast iterations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;I made my own UIs, using Rectangles, with text inside, elegant borders, mouse hover system&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;I have fun and love the feeling of doing things from scratch&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;Why Raylib?&quot;
				</p>
				<ul>
					<li>
						<p>
                            &quot;Reminder of how fun programming was in college when I was 22, now he's 36.&quot;
						</p>
					</li>
					<li>
						<p>
                            So, he didn't really answer the question.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Critiques of OOP, both from Karl and Wookash.
				</p>
				<ul>
					<li>
						<p>
                            Nice.
						</p>
					</li>
					<li>
						<p>
                            Mentioned Mike Acton and DoD, etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Overall, the video is nice but doesn't talk about anything technical regarding Odin or Raylib.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="sources" >
    Sources
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/@karl_zylinski/videos" 
				class="external-link" 
				target="_blank" >
                Karl Zylinski
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Odin, Raylib.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://zylinski.se/" 
						class="external-link" 
						target="_blank" >
                        Karl Zylinski
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/@mccGoNZooo/videos" 
				class="external-link" 
				target="_blank" >
                Rickard Andersson
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/@mccGoNZooo/streams" 
						class="external-link" 
						target="_blank" >
                        Lives
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Odin, Zig, Haskell.
				</p>
			</li>
			<li>
				<p>
                    &quot;I don't think OOP is the way things should be done, in pretty much any scenario. I don't think it is necessarily useful&quot;.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Zig
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If Odin didn't exist, I would be writing Zig.
						</p>
					</li>
					<li>
						<p>
                            The Zig Error Handling is just worse.
						</p>
					</li>
					<li>
						<p>
                            &quot;The Odin code is nicer without any cost&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Go
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            &quot;I don't feel like I have clear control&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/@DanKorostelev/videos" 
				class="external-link" 
				target="_blank" >
                Nadako
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Sokol, SDL, Vulkan, all in Odin.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/@CodingWithTom-tn7nl/videos" 
				class="external-link" 
				target="_blank" >
                Coding with Tom
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Odin, Zig.
				</p>
			</li>
			<li>
				<p>
                    Not very fond of the explanations.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="games-and-apps-made-in-odin" >
    Games and Apps made in Odin
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=zo1Zfo-SjwE" 
				class="external-link" 
				target="_blank" >
                Showcase from a game jam
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://itch.io/jam/odin-7-day-jam" 
				class="external-link" 
				target="_blank" >
                Odin 7 Day Jam
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="impressions" >
    Impressions
</h3>
<h5
	id="negative-points" >
    Negative Points
</h5>
<ul>
	<li>
		<p>
            [2025-11-13]
		</p>
	</li>
	<li>
		<p>
			<strong>
                Lack of keywords for single-thread concurrency is somewhat annoying (async await)
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                I would prefer 
                <code>@(require_results)</code>
                &nbsp;to be the default, while having something like 
                <code>@(optional_results)</code>
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    I'm really not a fan of this.
				</p>
			</li>
			<li>
				<p>
                    [2025-11-13] I made a suggestion for something like 
                    <code>#+vet explicit-returns</code>
                    , as way to have every unhandled return be treated as an error, even for 
                    <code>#optional_ok</code>
                    &nbsp;or 
                    <code>#optional_allocator_error</code>
                    &nbsp;, as well as a compiler flag, but it was denied :/
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                I would prefer if there was no default parameters in procedures
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    This sounds a bit wild, but I came to realize how little I actually need a default parameter.
				</p>
			</li>
			<li>
				<p>
                    They result in implicit behavior, which I believe leads to worse code.
				</p>
			</li>
			<li>
				<p>
                    Meanwhile, working without default parameters is actually an interesting challenge to solve that results in much better APIs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                I don't like 
                <code>using</code>
                &nbsp;outside of structs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Ginger Bill also considers this a mistake.
				</p>
			</li>
			<li>
				<p>
                    Read the 
                    <code>using</code>
                    &nbsp;section for more information.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<strong>
                No RTTI, just like C
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This means I cannot compare subtypes, like in gdscript, with 
                    <code>is</code>
                    :
				</p>
			</li>
		</ul>
<pre><code class="language-swift" data-lang="swift"> func _detect_hitbox(area: Area2D) -&gt; void:
 Â  Â  if not (area is Hitbox):
 Â  Â  Â  Â  Debug.red('(%s | Hurtbox) The area is not a Hitbox.' % _name)
 Â  Â  Â  Â  return
</code></pre>
		<ul>
			<li>
				<p>
                    It is necessary to use advanced idioms, with Unions / Enums, etc., to get the desired information.
				</p>
			</li>
			<li>
				<p>
                    See 
                    <a href="Odin.html#Advanced Idioms, Down-Cast and Up-Cast">
                    Odin#Advanced Idioms, Down-Cast and Up-Cast
                    </a>
                    &nbsp;for more information.
				</p>
			</li>
			<li>
				<p>
                    [2025-11-13]
				</p>
				<ul>
					<li>
						<p>
                            I think I'm ok with this. It's actually really rare I have to use something like the code shown in GDScript, and avoiding these situations led the code to be more understandable.
						</p>
					</li>
					<li>
						<p>
                            It's a lower level thing, but once you get used to it, I think it's ok.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                No need for 
                <code>-&gt;</code>
                &nbsp;for function return
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Minor, but I feel it could be hidden.
				</p>
			</li>
			<li>
				<p>
                    [2025-07-03]
				</p>
				<ul>
					<li>
						<p>
                            Genuinely, I don't care at all.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                No need for 
                <code>case</code>
                &nbsp;keyword for switches
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Minor, but I think the keyword shouldn't exist.
				</p>
			</li>
			<li>
				<p>
                    [2025-07-03]
				</p>
				<ul>
					<li>
						<p>
                            Genuinely, I don't care at all.
						</p>
					</li>
					<li>
						<p>
                            I actually kind of like it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                No need for 
                <code>proc</code>
                &nbsp;keyword for procedures
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Ultra minor, I got used to the keyword and it's convenient when considering how similar the syntax is to:
				</p>
<pre><code class="language-odin" data-lang="odin"> my_proc :: proc() {}

 my_struct :: struct {}
</code></pre>
			</li>
			<li>
				<p>
                    Jai opts not to use the keyword, but I have come to appreciate its use.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="positive-points" >
    Positive Points
</h5>
<ul>
	<li>
		<p>
            Many, I have enjoyed the language.
		</p>
	</li>
	<li>
		<p>
            Solves many problems I had with Zig.
		</p>
	</li>
</ul>
<h5
	id="2025-07-08" >
    [2025/07/08]
</h5>
<ul>
	<li>
		<p>
			<strong>
                I really like the big focus on NAMES in the syntax
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I found the syntax very weird, but the reality is it is ultra intuitive and I have liked it a lot.
				</p>
<pre><code class="language-odin" data-lang="odin"> my_var := 123
 my_proc :: proc() {}
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                No need for 
                <code>;</code>
                &nbsp;and don't miss it
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I never missed 
                    <code>;</code>
                    , after all what made the experience positive are the 
                    <code>{ }</code>
                    , not the 
                    <code>;</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    You can use 
                    <code>;</code>
                    &nbsp;if you want, though.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                No need for 
                <code>( )</code>
                &nbsp;in expressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Much better than in Zig, nice.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Enum access is simple, similar to Swift
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can be used as 
                    <code>.A</code>
                    &nbsp;instead of 
                    <code>MyEnum.A</code>
                    , in the correct context.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                No need to specify return type for 
                <code>void</code>
                &nbsp;when there is no return
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Nice.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                The package system really seems very good, with folders
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Inspired by Go.
				</p>
			</li>
			<li>
				<p>
                    After seeing GingerBill's explanation in this 
					<a
						href="https://youtu.be/fYUruq352yE?si=wIwcabHJPYePmqv4&t=1606" 
						class="external-link" 
						target="_blank" >
                        video {26:50 -&gt; 34:30}
					</a>
                    , I found it very nice.
				</p>
			</li>
			<li>
				<p>
                    Really seems to be a very good solution for managing exports/imports.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="installation" >
    Installation
</h2>
<h5
	id="versions-used" >
    Versions used
</h5>
<ul>
	<li>
		<p>
            [2025-11-10]
		</p>
	</li>
	<li>
		<p>
            Odin: Using 
            <code>dc57773b</code>
            &nbsp;from [2025-11-10].
		</p>
<pre><code class="language-sh" data-lang="sh"> cd C:\odin
 .\build.bat release
</code></pre>
	</li>
	<li>
		<p>
            OLS:&nbsp;&nbsp;Using 
            <code>980ccd16</code>
            &nbsp;from [2025-11-09].
		</p>
<pre><code class="language-sh" data-lang="sh"> cd C:\odin-ols
 .\build.bat
</code></pre>
		<ul>
			<li>
				<p>
                    Remeber to close VSCode before instalation.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="installation" >
    Installation
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/install/" 
				class="external-link" 
				target="_blank" >
                Installation
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="building-from-source" >
    Building from source
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/odin-lang/Odin" 
				class="external-link" 
				target="_blank" >
                Repo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>x64 Native Tools Command Prompt for VS 2022</code>
		</p>
		<ul>
			<li>
				<p>
                    Search for this terminal in the Windows search bar.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>cd c:\odin</code>
		</p>
	</li>
	<li>
		<p>
            <code>build.bat</code>
		</p>
		<ul>
			<li>
				<p>
                    or 
                    <code>build.bat release</code>
                    &nbsp;for a faster compiler (the command takes longer).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>build_vendor.bat</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Considerations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Apps running Odin must be closed.
				</p>
				<ul>
					<li>
						<p>
                            VSCode can stay open, but .exe compiled with Odin must be closed.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="building" >
    Building
</h2>
<h5
	id="build" >
    Build
</h5>
<ul>
	<li>
		<p>
            Compiles, generates executable.
		</p>
<pre><code class="language-odin" data-lang="odin"> odin build .
</code></pre>
	</li>
</ul>
<h5
	id="run" >
    Run
</h5>
<ul>
	<li>
		<p>
            Compile, generate executable, run executable.
		</p>
<pre><code class="language-odin" data-lang="odin"> odin run .
</code></pre>
	</li>
	<li>
		<p>
            <code>.</code>
            &nbsp;refers to the directory.
		</p>
	</li>
	<li>
		<p>
            Odin thinks in terms of directory-based packages. The 
            <code>odin build &lt;dir&gt;</code>
            &nbsp;command takes all the files in the directory 
            <code>&lt;dir&gt;</code>
            , compiles them into a package and then turns that into an executable. You can also tell it to treat a single file as a complete package by adding 
            <code>-file</code>
            , like so:
		</p>
<pre><code class="language-odin" data-lang="odin"> odin run hellope.odin -file
</code></pre>
	</li>
</ul>
<h5
	id="help" >
    Help
</h5>
<ul>
	<li>
		<p>
            <code>odin build -help</code>
		</p>
	</li>
	<li>
		<p>
            Output path:
		</p>
		<ul>
			<li>
				<p>
                    <code>odin build . -out:foo.exe</code>
				</p>
			</li>
			<li>
				<p>
                    <code>odin build . -out:out/odin-engine.exe</code>
				</p>
				<ul>
					<li>
						<p>
                            The directory is not created by default, so if the 
                            <code>out</code>
                            &nbsp;dir doesn't exist it will give an error in the build; use 
                            <code>mkdir</code>
                            &nbsp;beforehand.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="subsystems" >
    Subsystems
</h3>
<h5
	id="remove-terminal-from-executable" >
    Remove terminal from executable
</h5>
<ul>
	<li>
		<p>
            For Windows:
		</p>
		<ul>
			<li>
				<p>
                    <code>-subsystem:windows</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="compile-time-stuff" >
    Compile-time Stuff
</h2>
<h3
	id="compile-time-flags" >
    Compile-time Flags
</h3>
<ul>
	<li>
		<p>
            Check 
            <code>base:builtin/builtin.odin</code>
            .
		</p>
	</li>
</ul>
<h3
	id="when" >
    When
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#when-statements" 
				class="external-link" 
				target="_blank" >
                When
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Certain compile-time expressions.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>when</code>
            &nbsp;statement is almost identical to the 
            <code>if</code>
            &nbsp;statement but with some differences:
		</p>
		<ul>
			<li>
				<p>
                    Each condition must be a constant expression as a 
                    <code>when</code>
                    &nbsp;statement is evaluated at compile time.
				</p>
			</li>
			<li>
				<p>
                    The statements within a branch do not create a new scope.
				</p>
			</li>
			<li>
				<p>
                    The compiler checks the semantics and code 
					<strong>
                        only
					</strong>
                    &nbsp;for statements that belong to the first condition that is 
                    <code>true</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    An initial statement is not allowed in a 
                    <code>when</code>
                    &nbsp;statement.
				</p>
			</li>
			<li>
				<p>
                    <code>when</code>
                    &nbsp;statements are allowed at file scope.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="config" >
    #config
</h3>
<h5
	id="in-code" >
    In Code
</h5>
<ul>
	<li>
		<p>
            <code>TRACY_IS_ENABLED :: #config(TRACY_ENABLE, false)</code>
		</p>
		<ul>
			<li>
				<p>
                    The name on the left is for code use. The name on the right is for the compiler.
				</p>
			</li>
			<li>
				<p>
                    They can be the same, it doesn't matter.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="compilation-flag" >
    Compilation Flag
</h5>
<pre><code class="language-sh" data-lang="sh">odin run . -define:TRACY_ENABLE=true
</code></pre>
<ul>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    If a lib defines 
                    <code>OPTION :: #config(OPTION, false)</code>
                    , is it possible for me to enable it in my app, without using compiler flags? If I redefine it in my app as 
                    <code>OPTION:: #config(OPTION, true)</code>
                    , it doesn't work.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Oskar:
		</p>
		<ul>
			<li>
				<p>
                    Only compiler flag.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="procedure-disabled" >
    Procedure Disabled
</h3>
<pre><code class="language-odin" data-lang="odin">@(disabled=CONDITION)
</code></pre>
<ul>
	<li>
		<p>
            Disabled the procedure at compile-time if the condition is met.
		</p>
	</li>
	<li>
		<p>
            The procedure will 
			<em>
                not be used
			</em>
            &nbsp;when called.
		</p>
	</li>
	<li>
		<p>
            The procedure cannot have a return value.
		</p>
	</li>
	<li>
		<p>
            The procedures using this are still type-checked.
		</p>
		<ul>
			<li>
				<p>
                    This differs from Zig. Odin tries to check as much as possible.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Modify the compilation details or behavior of declarations.
		</p>
	</li>
</ul>
<h3
	id="variable-and-procedure-access" >
    Variable and Procedure Access
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#general-attributes" 
				class="external-link" 
				target="_blank" >
                General Attributes
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>@(private)</code>
		</p>
		<ul>
			<li>
				<p>
                    Equivalent to 
                    <code>@(private="package")</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Using 
                    <code>#+private</code>
                    &nbsp;before the package declaration will automatically add 
                    <code>@(private)</code>
                    &nbsp;to everything in that file.
				</p>
			</li>
			<li>
				<p>
                    <code>#+private file</code>
                    &nbsp;is equivalent to automatically adding 
                    <code>@(private="file")</code>
                    &nbsp;to each declaration.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>@(static)</code>
		</p>
	</li>
	<li>
		<p>
            <code>@(rodata)</code>
		</p>
		<ul>
			<li>
				<p>
                    Read-only
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="comp-time-loop" >
    Comp-time Loop
</h3>
<ul>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    There's no compile-time loop, though. I seem to recall Bill saying something about not wanting to add it, IIRC because it's a bit of a slippery slope (e.g. then people will want to be able to iterate over struct fields). I can't find the message I'm thinking of, though.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Sobex:
		</p>
		<ul>
			<li>
				<p>
                    Since you unroll you can kinda do a unrolled loop with inlined recursion
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"></code></pre>
	</li>
</ul>
<p>
    Â  Â  comp_loop :: #force_inline proc(as: []int, $i: int, $end: int) {
    <br>
    Â  Â  Â  Â  _, _ = args[i].(intrinsics.type_proc_parameter_type(F, i))
    <br>
    Â  Â  Â  Â  a := as[i]
    <br>
    Â  Â  Â  Â  fmt.print(a)
    <br>
    Â  Â  Â  Â  when i + 1 != end do comp_loop(as, i+1, end)
    <br>
    Â  Â  }
    <br>
    Â  Â  as := [?]int{5, 4, 3, 2, 1}
    <br>
    Â  Â  comp_loop(as[:], 0, 5)
    <br>
    ```
</p>
<h3
	id="build-tags" >
    Build Tags
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#build-tags" 
				class="external-link" 
				target="_blank" >
                Build Tags
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Used to define build platforms.
		</p>
	</li>
	<li>
		<p>
            It is recommended to use 
			<a
				href="https://odin-lang.org/docs/overview/#file-suffixes" 
				class="external-link" 
				target="_blank" >
                File Suffixes
			</a>
            &nbsp;anyway.
		</p>
		<ul>
			<li>
				<p>
                    This has a function, not just decorative.
				</p>
			</li>
			<li>
				<p>
                    &quot;For example, 
                    <code>foobar_windows.odin</code>
                    &nbsp;would only be compiled on Windows, 
                    <code>foobar_linux.odin</code>
                    &nbsp;only on Linux, and 
                    <code>foobar_windows_amd64.odin</code>
                    &nbsp;only on Windows AMD64.&quot;
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ignore" >
    Ignore
</h3>
<pre><code class="language-odin" data-lang="odin">#+build ignore
</code></pre>
<h3
	id="optimizations" >
    Optimizations
</h3>
<h5
	id="force-inline-codeforce_inline-code" >
    Force Inline (
    <code>#force_inline</code>
    )
</h5>
<ul>
	<li>
		<p>
            Doesn't work on 
            <code>-o:none</code>
            .
		</p>
	</li>
</ul>
<h3
	id="intrinsics" >
    Intrinsics
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/intrinsics/" 
				class="external-link" 
				target="_blank" >
                Intrinsics
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>intrinsics.type_is_integer()</code>
		</p>
		<ul>
			<li>
				<p>
                    Caio:
				</p>
<pre><code class="language-odin" data-lang="odin"> proc (a: [$T]any) where intrinsics.type_is_integer(T)
 
 Expected a type for 'type_is_integer', got 'T'
&nbsp;&nbsp;&nbsp;&nbsp; intrinsics.type_is_integer(T)
</code></pre>
			</li>
			<li>
				<p>
                    Blob:
				</p>
				<ul>
					<li>
						<p>
                            Because the type of 
                            <code>T</code>
                            &nbsp;is an untyped integer, as it's technically a constant, &amp; there's no way to check against an untyped type (I would like there to be honestly). What you'd want to check against is the type of the array itself 
                            <code>proc (a: $E/[$T]any) where intrinsics.type_is_array(E)</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>instrinsics.type_elem_type()</code>
		</p>
		<ul>
			<li>
				<p>
                    Underlying type.
				</p>
			</li>
			<li>
				<p>
                    Useful for arrays.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="package-system" >
    Package System
</h2>
<ul>
	<li>
		<p>
            Joren:
		</p>
		<ul>
			<li>
				<p>
                    When the spec is written (around v1's release), it will be clarified that there are 3 standard &quot;collections&quot;:
				</p>
				<ul>
					<li>
						<p>
                            base: defined by the language specification, expected to work the same no matter the compiler vendor,
						</p>
					</li>
					<li>
						<p>
                            core: would be nice if it mirrors upstream Odin's packages for interopability, but up to the compiler vendor,
						</p>
					</li>
					<li>
						<p>
                            vendor: things like raylib, directx, entirely up to the compiler vendor what's shipped here,
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    You can still opt to fork Odin and tweak things in 
                    <code>base</code>
                    , but at that point you have your own dialect of the language that can no longer necessarily be compiler by another Odin implementation, even if you copy across 
                    <code>core</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;A Package is basically a folder with Odin code in it, where everything inside that folder becomes part of that package&quot;.
		</p>
	</li>
	<li>
		<p>
            &quot;The Package system is made for library creation, not necessarily to organize code within a library&quot;.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=Ntt73Zdoztc" 
				class="external-link" 
				target="_blank" >
                Explanation
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Examples show how using different packages within the same game can create friction, as:
				</p>
				<ul>
					<li>
						<p>
                            You have to be careful with cyclic dependencies.
						</p>
					</li>
					<li>
						<p>
                            You have to use imported library name prefixes everywhere.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Everything is accessible within the same Package.
		</p>
	</li>
	<li>
		<p>
            &quot;The only reason to separate code into different files within the same package is for code organization; in practice it's as if everything were together&quot;.
		</p>
	</li>
	<li>
		<p>
            In the given example, all files can communicate with each other without &quot;include&quot;, since all belong to the same package and will be compiled into a single &quot;thing&quot;.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250331095353.png" width="179" >
                    .
				</p>
			</li>
			<li>
				<p>
                    &quot;I can simply cut the code and paste it in another file and everything will still work the same&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            All declarations in a package are public by default.
		</p>
	</li>
	<li>
		<p>
            If you want something to be private to the current file, write:
		</p>
<pre><code class="language-odin" data-lang="odin"> @(private="file")
 my_procedure :: proc() {}&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
		<ul>
			<li>
				<p>
                    &quot;I wouldn't worry about this, it doesn't matter if the file is accessible outside the file&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;The only place I use this is so I TAKE care not to define global state by accident&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="creating-a-package" >
    Creating a package
</h5>
<ul>
	<li>
		<p>
            &quot;Packages cannot have cyclic references&quot;.
		</p>
		<ul>
			<li>
				<p>
                    &quot;game -&gt; ren&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;ren -!&gt; game&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Keyword 
                <code>package</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    All files must have a 
                    <code>package</code>
                    &nbsp;at the top.
				</p>
				<ul>
					<li>
						<p>
                            The name does not need to be the same as the folder the file is in, it can be anything.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    All files within the same package must have the same name at the top.
				</p>
				<ul>
					<li>
						<p>
                            If not, it gives a compiler error.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Which name to use
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If you are making a game, the 
                            <code>package</code>
                            &nbsp;name is not very important.
						</p>
					</li>
					<li>
						<p>
                            But if you are making something intended for use by others, then choose a good and 
							<strong>
                                unique
							</strong>
                            &nbsp;name among existing package names.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="installing-a-new-package" >
    Installing a new package
</h5>
<ul>
	<li>
		<p>
            Download the folder, put it there, it works.
		</p>
	</li>
</ul>
<h5
	id="using-a-package" >
    Using a package
</h5>
<ul>
	<li>
		<p>
			<strong>
                From a collection
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> import rl "vendor:raylib" 
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                From the file system
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If no prefix is present, the import will look relative to the current file.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> import ren "renderer"
&nbsp;&nbsp;&nbsp;&nbsp; // Uses the "renderer" package (folder).
</code></pre>
<pre><code class="language-odin" data-lang="odin"> import cmn "../common"
&nbsp;&nbsp;&nbsp;&nbsp; // goes to the parent package (parent folder) and gets the "common" package (folder).
</code></pre>
	</li>
</ul>
<h3
	id="package-collections" >
    Package Collections
</h3>
<ul>
	<li>
		<p>
            There's a 
            <code>shared</code>
            &nbsp;folder in the Odin installation folder that you can use for that. It's available as a collection by default (e.g. 
            <code>import "shared:some_package"</code>
            )
		</p>
	</li>
	<li>
		<p>
            New Package Collections:
		</p>
		<ul>
			<li>
				<p>
                    You can specify your own collections by including 
                    <code>-collection:name=some/path</code>
                    &nbsp;when running the compiler.
				</p>
			</li>
			<li>
				<p>
                    There's no built-in way to make it &quot;permanent&quot; though.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Odin
			</em>
            &nbsp;has the concept of 
            <code>collections</code>
            &nbsp;that are predefined paths that can be used in imports.
		</p>
	</li>
	<li>
		<p>
            <code>core:</code>
            &nbsp;The most common collection that contains useful libraries from 
			<em>
                Odin
			</em>
            &nbsp;core like 
            <code>fmt</code>
            &nbsp;or 
            <code>strings</code>
            .
		</p>
	</li>
	<li>
		<p>
            You can define your own collection at build time
		</p>
	</li>
	<li>
		<p>
            The following will define the collection 
            <code>project</code>
            &nbsp;and put the path at the current directory.
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">odin run . -collection:project=.
</code></pre>
<pre><code class="language-odin" data-lang="odin">import "project:lib/cat"
</code></pre>
<h3
	id="types-of-packages" >
    Types of Packages
</h3>
<h5
	id="base" >
    Base
</h5>
<ul>
	<li>
		<p>
            Fundamental for Odin.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/" 
				class="external-link" 
				target="_blank" >
                Builtin
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/intrinsics/" 
				class="external-link" 
				target="_blank" >
                Intrinsics
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/" 
				class="external-link" 
				target="_blank" >
                Runtime
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="core" >
    Core
</h5>
<ul>
	<li>
		<p>
            Useful and important things, but not fundamental.
		</p>
	</li>
</ul>
<h5
	id="vendor" >
    Vendor
</h5>
<ul>
	<li>
		<p>
            3rd party, but included with Odin.
		</p>
	</li>
	<li>
		<p>
            &quot;High-quality, officially supported&quot;.
		</p>
	</li>
</ul>
<h2
	id="lsp-ols-odin-language-server" >
    LSP (OLS - Odin Language Server)
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/DanielGavin/ols" 
				class="external-link" 
				target="_blank" >
                OLS
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/showcase/ols/" 
				class="external-link" 
				target="_blank" >
                OLS Showcase
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            I downloaded OLS, used 
            <code>build.bat</code>
            &nbsp;and 
            <code>odinfmt.bat</code>
            .
		</p>
	</li>
	<li>
		<p>
            Stored the entire OLS folder in a directory.
		</p>
	</li>
	<li>
		<p>
            Installed the VSCode extension.
		</p>
	</li>
	<li>
		<p>
            Set the path of 
            <code>ols.exe</code>
            &nbsp;in Odin settings inside VSCode.
		</p>
	</li>
	<li>
		<p>
            Created the 
            <code>ols.json</code>
            &nbsp;file in my project directory in VSCode, with configs from the OLS GitHub.
		</p>
	</li>
</ul>
<h3
	id="check-args" >
    Check Args
</h3>
<ul>
	<li>
		<p>
            <code>odin check -help</code>
		</p>
	</li>
</ul>
<h3
	id="examples" >
    Examples
</h3>
<ul>
	<li>
		<p>
            Rickard Andersson's OLS
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250413111832.png" width="475" >
            .
		</p>
	</li>
</ul>
<h2
	id="operations" >
    Operations
</h2>
<h3
	id="arithmetic-operations" >
    Arithmetic Operations
</h3>
<h5
	id="" >
    %
</h5>
<ul>
	<li>
		<p>
            Modulo (truncated).
		</p>
	</li>
	<li>
		<p>
            <code>%</code>
            &nbsp;is dividend
		</p>
	</li>
</ul>
<h5
	id="" >
    %%
</h5>
<ul>
	<li>
		<p>
            Remainder (floored).
		</p>
	</li>
	<li>
		<p>
            <code>%%</code>
            &nbsp;is divisor.
		</p>
	</li>
	<li>
		<p>
            For unsigned integers, 
            <code>%</code>
            &nbsp;and 
            <code>%%</code>
            &nbsp;are identical, but the difference comes when using signed integers.
		</p>
	</li>
</ul>
<h3
	id="logical-operations" >
    Logical Operations
</h3>
<h5
	id="quotshort-circuitquot" >
    &quot;Short-Circuit&quot;
</h5>
<ul>
	<li>
		<p>
            It means that if the first condition is 
            <code>false</code>
            &nbsp;then the second condition won't be evaluated.
		</p>
	</li>
	<li>
		<p>
            This works for any control flow, as the &quot;short-circuiting&quot; is a property of the logical operators (
            <code>&&</code>
            , 
            <code>||</code>
            ), not the control flow.
		</p>
		<ul>
			<li>
				<p>
                    So this is also applicable to ternary operations, for example.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>if a != nil && a.something == true {}</code>
		</p>
		<ul>
			<li>
				<p>
                    This is safe, as when the first condition is 
                    <code>false</code>
                    , the second one will not be evaluated.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>if a.something == true && a != nil {}</code>
		</p>
		<ul>
			<li>
				<p>
                    This is unsafe. The first condition will be evaluated first, so if 
                    <code>a == nil</code>
                    , this will crash.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="conditional-and-codeampamp-code" >
    conditional AND (
    <code>&&</code>
    )
</h5>
<pre><code class="language-c" data-lang="c">a && b&nbsp;&nbsp;is&nbsp;&nbsp;"b if a else false"
</code></pre>
<h5
	id="conditional-or-code-code" >
    conditional OR (
    <code>||</code>
    )
</h5>
<pre><code class="language-c" data-lang="c">a || b&nbsp;&nbsp;is&nbsp;&nbsp;"true if a else b"
</code></pre>
<h3
	id="bitwise-operations" >
    Bitwise Operations
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#arithmetic-operators" 
				class="external-link" 
				target="_blank" >
                Bitwise Operations
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="or-code-code" >
    OR (
    <code>|</code>
    )
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="xor-code-code" >
    XOR (
    <code>~</code>
    )
</h5>
<ul>
	<li>
		<p>
            <code>~u32(0)</code>
            &nbsp;is effectively 
            <code>max(u32)</code>
            .
		</p>
	</li>
</ul>
<h5
	id="and-codeamp-code" >
    AND (
    <code>&</code>
    )
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="and-not-codeamp-code" >
    AND-NOT (
    <code>&~</code>
    )
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="left-shift-codeltlt-code" >
    LEFT SHIFT (
    <code>&lt;&lt;</code>
    )
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="right-shift-codegtgt-code" >
    RIGHT SHIFT (
    <code>&gt;&gt;</code>
    )
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h2
	id="control-flow-if-when-switch-for-defer" >
    Control Flow (if, when, switch, for, defer)
</h2>
<h3
	id="if" >
    If
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#if-statement" 
				class="external-link" 
				target="_blank" >
                If
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">if x &gt;= 0 {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("x is positive")
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Initial statement
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Like 
                    <code>for</code>
                    , the 
                    <code>if</code>
                    &nbsp;statement can start with an initial statement to execute before the condition.
				</p>
			</li>
			<li>
				<p>
                    Variables declared by the initial statement are 
					<strong>
                        only
					</strong>
                    &nbsp;in the scope of that 
                    <code>if</code>
                    &nbsp;statement, including the 
                    <code>else</code>
                    &nbsp;blocks.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> if x := foo(); x &lt; 0 {
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println("x is negative")
 }
</code></pre>
<pre><code class="language-odin" data-lang="odin"> if x := foo(); x &lt; 0 {
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println("x is negative")
 } else if x == 0 {
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println("x is zero")
 } else {
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println("x is positive")
 }
</code></pre>
	</li>
</ul>
<h3
	id="if-ternary" >
    If Ternary
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#ternary-operator" 
				class="external-link" 
				target="_blank" >
                Ternary Operator
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">bar := 1 if condition else 42
// or
bar := condition ? 1 : 42
</code></pre>
<h3
	id="for" >
    For
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#for-statement" 
				class="external-link" 
				target="_blank" >
                For
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It's the only type of loop.
		</p>
	</li>
	<li>
		<p>
            Braces 
            <code>{ }</code>
            &nbsp;or a 
            <code>do</code>
            &nbsp;are always required.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">for i := 0; i &lt; 10; i++ {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println(i);
}
for i := 0; i &lt; 10; i += 1 { }
for i := 0; i &lt; 10; i += 1 do single_statement()
</code></pre>
<pre><code class="language-odin" data-lang="odin">for i in 0..&lt;10 {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println(i)
}
// or
for i in 0..=9 {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println(i)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">str: string = "Some text"
for character in str {
&nbsp;&nbsp;&nbsp;&nbsp;assert(type_of(character) == rune)
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println(character)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">memory_block_found := false
for block := arena.curr_block; block != nil; block = block.prev {
&nbsp;&nbsp;&nbsp;&nbsp;if block == temp.block {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_block_found = true
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h3
	id="when" >
    When
</h3>
<ul>
	<li>
		<p>
            The 
            <code>when</code>
            &nbsp;statement is almost identical to the 
            <code>if</code>
            &nbsp;statement but with some differences:
		</p>
		<ul>
			<li>
				<p>
                    Each condition must be a constant expression as a 
                    <code>when</code>
                    &nbsp;statement is evaluated at 
					<strong>
                        compile time
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    The statements within a branch do not create a new scope.
				</p>
			</li>
			<li>
				<p>
                    The compiler checks the semantics and code 
					<strong>
                        only
					</strong>
                    &nbsp;for statements that belong to the first condition that is 
                    <code>true</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    An initial statement is not allowed in a 
                    <code>when</code>
                    &nbsp;statement.
				</p>
			</li>
			<li>
				<p>
                    <code>when</code>
                    &nbsp;statements are allowed at file scope.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">when ODIN_ARCH == .i386 {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("32 bit")
} else when ODIN_ARCH == .amd64 {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("64 bit")
} else {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("Unsupported architecture")
}
</code></pre>
<h3
	id="switch" >
    Switch
</h3>
<ul>
	<li>
		<p>
            <code>switch</code>
            &nbsp;is runtime. The compiler doesn't know if those cases are actually reachable or not, so it needs to check them all.
		</p>
		<ul>
			<li>
				<p>
                    The switch evaluates the possibility of entering each case, so the operation inside each case must be compatible.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The Switch has no fallthrough, but requires the use of the 
            <code>case</code>
            &nbsp;keyword.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">switch arch := ODIN_ARCH; arch {
case .i386, .wasm32, .arm32:
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("32 bit")
case .amd64, .wasm64p32, .arm64, .riscv64:
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("64 bit")
case .Unknown:
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("Unknown architecture")
}
</code></pre>
<h5
	id="partial" >
    Partial
</h5>
<pre><code class="language-odin" data-lang="odin">Foo :: enum {
&nbsp;&nbsp;&nbsp;&nbsp;A,
&nbsp;&nbsp;&nbsp;&nbsp;B,
&nbsp;&nbsp;&nbsp;&nbsp;C,
&nbsp;&nbsp;&nbsp;&nbsp;D,
}

f := Foo.A
switch f {
case .A: fmt.println("A")
case .B: fmt.println("B")
case .C: fmt.println("C")
case .D: fmt.println("D")
case:&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("?")
}

#partial switch f {
case .A: fmt.println("A")
case .D: fmt.println("D")
}
</code></pre>
<h5
	id="type-switch" >
    Type switch
</h5>
<ul>
	<li>
		<p>
            <code>v</code>
            &nbsp;is the unwrapped value from 
            <code>value</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">value: Value = ...
switch v in value {
case string:
&nbsp;&nbsp;&nbsp;&nbsp;#assert(type_of(v) == string)

case bool:
&nbsp;&nbsp;&nbsp;&nbsp;#assert(type_of(v) == bool)

case i32, f32:
&nbsp;&nbsp;&nbsp;&nbsp;// This case allows for multiple types, therefore we cannot know which type to use
&nbsp;&nbsp;&nbsp;&nbsp;// `v` remains the original union value
&nbsp;&nbsp;&nbsp;&nbsp;#assert(type_of(v) == Value)
case:
&nbsp;&nbsp;&nbsp;&nbsp;// Default case
&nbsp;&nbsp;&nbsp;&nbsp;// In this case, it is `nil`
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Note
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Having multiple types in a single case will mean it won't be unwrapped, as there's no one type the complier can guarantee it'll be.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="defer" >
    Defer
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#defer-statement" 
				class="external-link" 
				target="_blank" >
                Defer
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A defer statement defers the execution of a statement until the end of the scope it is in.
		</p>
	</li>
	<li>
		<p>
            The following will print 
            <code>4</code>
            &nbsp;then 
            <code>234</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">package main

import "core:fmt"

main :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;x := 123
&nbsp;&nbsp;&nbsp;&nbsp;defer fmt.println(x)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer x = 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 2
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println(x)

&nbsp;&nbsp;&nbsp;&nbsp;x = 234
}
</code></pre>
<h2
	id="procedures" >
    Procedures
</h2>
<ul>
	<li>
		<p>
			<em>
                Procedure
			</em>
            &nbsp;used to be the common term as opposed to a function or subroutine. A function is a mathematical entity that has no side effects. A subroutine is something that has side effects but does not return anything.
		</p>
	</li>
	<li>
		<p>
            A procedure is a superset of functions and subroutines. A procedure may or may not return something. A procedure may or may not have side effects.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">multiply :: proc(x: int, y: int) -&gt; int {
&nbsp;&nbsp;&nbsp;&nbsp;return x * y
}
fmt.println(multiply(137, 432))
</code></pre>
<pre><code class="language-odin" data-lang="odin">multiply :: proc(x, y: int) -&gt; int {
&nbsp;&nbsp;&nbsp;&nbsp;return x * y
}
fmt.println(multiply(137, 432))
</code></pre>
<ul>
	<li>
		<p>
            Everything in Odin is passed by value, rather than by reference.
		</p>
	</li>
	<li>
		<p>
            All procedure parameters in Odin are immutable values.
		</p>
	</li>
	<li>
		<p>
            Passing a pointer value makes a copy of the pointer, not the data it points to.
		</p>
	</li>
	<li>
		<p>
            Slices, dynamic arrays, and maps behave like pointers in this case (Internally they are structures that contain values, which include pointers, and the â€œstructureâ€ is passed by value).
		</p>
	</li>
</ul>
<h3
	id="calling-conventions" >
    Calling Conventions
</h3>
<ul>
	<li>
		<p>
            Procedure types are only compatible with the procedures that have the same calling convention and parameter types.
		</p>
	</li>
</ul>
<h5
	id="odin" >
    odin
</h5>
<ul>
	<li>
		<p>
            By default, Odin procedures use the 
            <code>"odin"</code>
            &nbsp;calling convention.
		</p>
	</li>
	<li>
		<p>
            This calling convention is the same as C, however it differs in a couple of ways:
		</p>
		<ul>
			<li>
				<p
					class="line-emphasis" >
					<input
						type="checkbox" 
						disabled=""
>
                    It promotes values to a pointer if thatâ€™s more efficient on the target system
				</p>
				<ul>
					<li>
						<p>
                            Where would this be more efficient?
						</p>
					</li>
					<li>
						<p>
                            It passes all parameters larger than 
                            <code>16 bytes</code>
                            &nbsp;by reference.
						</p>
					</li>
					<li>
						<p>
                            The promotion is enabled by the fact that all parameters are immutable in Odin, and its rules are consistent for a given type and platform and can be relied on since they are part of the calling convention.
						</p>
					</li>
					<li>
						<p>
                            Passing a pointer value makes a copy of the pointer, not the data it points to. Slices, dynamic arrays, and maps have no special considerations here; they are normal structures with pointer fields, and are passed as such. Their elements will not be copied.
						</p>
					</li>
					<li>
						<p>
                            Note: This is subject to change.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        It includes a pointer to the current context as an implicit additional argument
					</strong>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="contextless" >
    contextless
</h5>
<ul>
	<li>
		<p>
            Same as 
            <code>odin</code>
            &nbsp;but without the implicit 
            <code>context</code>
            &nbsp;pointer.
		</p>
	</li>
</ul>
<h5
	id="stdcall-std" >
    stdcall / std
</h5>
<ul>
	<li>
		<p>
            This is the 
            <code>stdcall</code>
            &nbsp;convention as specified by Microsoft.
		</p>
	</li>
</ul>
<h5
	id="c-cdecl" >
    c / cdecl
</h5>
<ul>
	<li>
		<p>
            This is the default calling convention generated of a procedure in C.
		</p>
	</li>
	<li>
		<p>
            If it's within a 
            <code>foreign</code>
            &nbsp;block, the default calling conventions is 
            <code>cdecl</code>
            .
		</p>
	</li>
</ul>
<h5
	id="fastcall-fast" >
    fastcall / fast
</h5>
<ul>
	<li>
		<p>
            This is a compiler dependent calling convention.
		</p>
	</li>
</ul>
<h5
	id="none" >
    none
</h5>
<ul>
	<li>
		<p>
            This is a compiler dependent calling convention which will do nothing to parameters.
		</p>
	</li>
</ul>
<h3
	id="variadic-arguments" >
    Variadic Arguments
</h3>
<ul>
	<li>
		<p>
            Ginger Bill: &quot;It's just a slice allocated on the stack.&quot;
		</p>
<pre><code class="language-odin" data-lang="odin"> foo :: proc(x: ..int) {} 
 
 // Calling
 foo(1, 2, 3)

 // is the same as
 temp_array := [3]int{1, 2, 3} 
 temp_slice := temp_array[:] 
 foo(..temp_slice)
</code></pre>
	</li>
	<li>
		<p>
            Procedures can be variadic, taking a varying number of arguments:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">sum :: proc(nums: ..int) -&gt; (result: int) {
&nbsp;&nbsp;&nbsp;&nbsp;for n in nums {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += n
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return
}
fmt.println(sum())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0
fmt.println(sum(1, 2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3
fmt.println(sum(1, 2, 3, 4, 5)) // 15

odds := []int{1, 3, 5}
fmt.println(sum(..odds))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 9, passing a slice as varargs
</code></pre>
<h3
	id="multiple-returns" >
    Multiple returns
</h3>
<pre><code class="language-odin" data-lang="odin">swap :: proc(x, y: int) -&gt; (int, int) {
&nbsp;&nbsp;&nbsp;&nbsp;return y, x
}
a, b := swap(1, 2)
fmt.println(a, b) // 2 1
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Implicitly
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> end_msg_as_bytes, err_end := cbor.marshal_into_bytes(end_msg)
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Explicitly
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> end_msg_as_bytes: []byte
 err_end: cbor.MarshalError
 end_msg_as_bytes, err_end = cbor.marshal_into_bytes(end_msg)

 // or
 packet_as_bytes: []byte; err_packet: cbor.Marshal_Error
</code></pre>
	</li>
</ul>
<p>
    Â  Â  packet_as_bytes, err_packet = cbor.marshal_into_bytes(packet[:])
    <br>
    ```
</p>
<h3
	id="closures-they-dont-exist" >
    Closures (They don't exist)
</h3>
<ul>
	<li>
		<p>
            Does not have closures, only Lambdas.
		</p>
	</li>
	<li>
		<p>
            Odin only has non-capturing lambda procedures.
		</p>
	</li>
	<li>
		<p>
            For closures to work correctly would require a form of automatic memory management which will never be implemented into Odin.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">foo :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;y: int
&nbsp;&nbsp;&nbsp;&nbsp;x := proc() -&gt; int {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `y` is not available in this scope as it is in a different stack frame
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 123
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h3
	id="procedure-groups-explicit-overload" >
    Procedure Groups (explicit overload)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#explicit-procedure-overloading" 
				class="external-link" 
				target="_blank" >
                Explicit Procedure Overloading
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    if I have a struct that inherits another struct with 
                    <code>using</code>
                    , and then I make a procedure group, where the first procedure accepts the original struct, and the second accepts the struct that inherits the first struct, what would happen? This &quot;higher level&quot; struct would call which of these procedures? Does it depend on the order the procedures are stored in the procedure group, or something like that? Casting has been the weirdest thing for me.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    The order of the procs in the proc group isn't used to decide which to call, the compiler &quot;scores&quot; each candidate to decide which one is the best fit for a given call. As best I can tell it 
					<em>
                        does
					</em>
                    &nbsp;appear that the compiler accounts for subtypes when doing this, so it should consistently call the proc closest to the base type https://github.com/odin-lang/Odin/blob/090cac62f9cc30f759cba086298b4bdb8c7c62b3/src/check_expr.cpp#L829.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Odin:
		</p>
		<ul>
			<li>
				<p>
                    In retrospect it sounds a bit weird that odin checks for subtyping in cases of proc groups, but it can't be done directly. In a way, overloading itself sounds weird with no RTTI. Is it just because of the c++ part of odin? We were talking about options for downcasting, but maybe a proc group could also be an option while not having to store any extra data in the struct? I have no idea, it just sounds odd going back to proc groups after the limitations we were talking about. I wonder what would be cheaper, letting a proc group handle the polymorphism, or using a union subtype polymorphism as discussed
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Jesse:
		</p>
		<ul>
			<li>
				<p>
                    Nothing to do with the language choice for the compiler.
				</p>
			</li>
			<li>
				<p>
                    It's a compile time switch basically. A better designed 
                    <code>_Generic</code>
                    &nbsp;macro from C.
				</p>
			</li>
			<li>
				<p>
                    They act on type information available at compile time. There's nothing runtime about proc groups.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="generics" >
    Generics
</h3>
<ul>
	<li>
		<p>
            Use of 
            <code>$T</code>
            &nbsp;in 
			<strong>
                parameter type
			</strong>
            &nbsp;of the procedure.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#parametric-polymorphism" 
				class="external-link" 
				target="_blank" >
                Parametric Polymorphism
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=3X2IzOfzepA" 
				class="external-link" 
				target="_blank" >
                Parametric Polymorphism
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Fun facts
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Parapoly doesn't support default values.
				</p>
				<ul>
					<li>
						<p>
                            <code>[]$MEMBER</code>
                            &nbsp;can't have a default value, for example.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Specialization
			</em>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> array: $T/[dynamic]$E
</code></pre>
		<ul>
			<li>
				<p>
                    <code>T</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Type of the entire array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>E</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Type of the element inside the array.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="force-parameters-to-be-compile-time-constants" >
    Force parameters to be compile-time constants
</h3>
<ul>
	<li>
		<p>
            Use of 
            <code>$T</code>
            &nbsp;in 
			<strong>
                parameter name
			</strong>
            &nbsp;of the procedure.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">my_new :: proc($T: typeid) -&gt; ^T {
&nbsp;&nbsp;&nbsp;&nbsp;return (^T)(alloc(size_of(T), align_of(T)))
}

ptr := my_new(int)
</code></pre>
<h3
	id="deferred" >
    Deferred
</h3>
<ul>
	<li>
		<p>
            <code>@(deferred_in=&lt;proc&gt;)</code>
		</p>
		<ul>
			<li>
				<p>
                    will receive the same parameters as the called proc
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>@(deferred_out=&lt;proc&gt;)</code>
		</p>
		<ul>
			<li>
				<p>
                    will receive the result of the called proc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>@(deferred_in_out=&lt;proc&gt;)</code>
		</p>
		<ul>
			<li>
				<p>
                    will receive both
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>@(deferred_none=&lt;proc&gt;)</code>
		</p>
		<ul>
			<li>
				<p>
                    will receive no parameters.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="return-from-a-deferred-procedure" >
    Return from a deferred procedure
</h5>
<ul>
	<li>
		<p>
            what happens if I have a 
            <code>@(deferred_none=end) begin :: proc() -&gt; bool</code>
            &nbsp;and a 
            <code>end :: proc() -&gt; bool</code>
            , and I call 
            <code>result := begin()</code>
            ? How does the return of deferred procedures work? Would 
            <code>result</code>
            &nbsp;hold the value of 
            <code>begin</code>
            &nbsp;or something else?
		</p>
		<ul>
			<li>
				<p>
                    <code>result</code>
                    &nbsp;will hold the return value from 
                    <code>begin</code>
                    , the return value of 
                    <code>end</code>
                    &nbsp;will be silently dropped when it runs
				</p>
			</li>
			<li>
				<p>
                    It'd be equivalent to
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> result := begin()
 defer end()
</code></pre>
	</li>
</ul>
<h2
	id="typing" >
    Typing
</h2>
<h3
	id="declaration" >
    Declaration
</h3>
<h5
	id="constants" >
    Constants
</h5>
<pre><code class="language-odin" data-lang="odin">u :: "what";&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Untyped.
y : int : 123
&nbsp;&nbsp;&nbsp;&nbsp;// Explicitly typed constant.
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/faq/#why-can-i-not-indexaddress-a-constant-with-a-variable" 
				class="external-link" 
				target="_blank" >
                Consts are not indexable
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>::</code>
            &nbsp;is closer to 
            <code>#define</code>
            &nbsp;than it is 
            <code>static const</code>
            .
		</p>
	</li>
	<li>
		<p>
            To achieve similar behaviour to Câ€™s 
            <code>static const</code>
            , apply the 
            <code>@(rodata)</code>
            &nbsp;attribute to a variable declaration (
            <code>:=</code>
            ) to state that the data must live in the read-only data section of the executable.
		</p>
	</li>
	<li>
		<p>
            &quot;Anything declared with 
            <code>::</code>
            &nbsp;behaves like a constant. That includes types and procs.&quot;
		</p>
	</li>
	<li>
		<p>
			<strong>
                Aliases
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> Vector3 :: [3]f32
</code></pre>
	</li>
</ul>
<h5
	id="variables" >
    Variables
</h5>
<pre><code class="language-odin" data-lang="odin">x: int
&nbsp;&nbsp;&nbsp;&nbsp;// default to 0
</code></pre>
<pre><code class="language-odin" data-lang="odin">// All below are equivalent.
x : int = 123
x :&nbsp;&nbsp;&nbsp;&nbsp; = 123
x := 123
x := int(123)
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Multi-declaration
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">y, z: int 
&nbsp;&nbsp;&nbsp;&nbsp;// both are int.
</code></pre>
<h3
	id="literal-types" >
    Literal Types
</h3>
<ul>
	<li>
		<p>
            Literals are 
            <code>untyped</code>
            , but 
            <code>untyped</code>
            &nbsp;values doesn't 
			<em>
                have
			</em>
            &nbsp;to be from a literal; you can get 
            <code>untyped</code>
            &nbsp;values from builtins like 
            <code>len</code>
            &nbsp;when applicable.
		</p>
	</li>
	<li>
		<p>
            &quot;I might say that a literal rune is a piece of syntax that yields an untyped rune&quot;.
		</p>
	</li>
	<li>
		<p>
            <code>untyped</code>
            &nbsp;usually means it comes from a literal, though sometimes intrinsics/builtins can give them too.
		</p>
	</li>
	<li>
		<p>
            It basically just means a 
			<strong>
                compile-time-known
			</strong>
            &nbsp;value.
		</p>
	</li>
	<li>
		<p>
            rgats:
		</p>
		<ul>
			<li>
				<p>
                    i can see why some people prefer literals having static types, 
                    <code>10</code>
                    &nbsp;is always an int in C
				</p>
			</li>
			<li>
				<p>
                    and the conversions happen at runtime
				</p>
			</li>
			<li>
				<p>
                    but i dont think it makes a very big difference in most cases
				</p>
			</li>
			<li>
				<p>
                    honestly i think it'd make a bigger difference in a language without type inference
				</p>
			</li>
			<li>
				<p>
                    in C you have to specify the type of your literal, 
                    <code>10</code>
                    , 
                    <code>10u</code>
                    , 
                    <code>10f</code>
                    , 
                    <code>10l</code>
                    , etc, and you also have to specify the type of your variable, like 
                    <code>unsigned long long x = 10ull;</code>
				</p>
			</li>
			<li>
				<p>
                    c implicitly converts 
                    <code>int</code>
                    &nbsp;to 
                    <code>unsigned long long</code>
                    &nbsp;i believe, but if you actually wanted a very large number you'd need to specify the type (edited)Monday, 27 October 2025 15:31
				</p>
			</li>
			<li>
				<p>
                    so it gets extra messy there
				</p>
			</li>
			<li>
				<p>
                    and not every number converts implicitly, i dont think 
                    <code>float x = 10.5;</code>
                    &nbsp;works for example, which gets annoying
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="untyped-types" >
    Untyped Types
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2021/03/07/untyped-types/" 
				class="external-link" 
				target="_blank" >
                Ginger Bill - Untyped Types
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Can be assigned to constants (
            <code>::</code>
            ) without being forced into a specific type, but once it gets assigned to a variable (
            <code>=</code>
            ) it has to have an actual type.
		</p>
	</li>
</ul>
<pre><code class="language-swift" data-lang="swift">A_CONSTANT :: 'x' 
// is an untyped thing you can make yourself
</code></pre>
<h3
	id="zero-value" >
    Zero Value
</h3>
<ul>
	<li>
		<p>
            Variables declared without an explicit initial value are given their 
			<em>
                zero
			</em>
            &nbsp;value.
		</p>
	</li>
	<li>
		<p>
            The zero value is:
		</p>
		<ul>
			<li>
				<p>
                    <code>0</code>
                    &nbsp;for numeric and rune types
				</p>
			</li>
			<li>
				<p>
                    <code>false</code>
                    &nbsp;for boolean types
				</p>
			</li>
			<li>
				<p>
                    <code>""</code>
                    &nbsp;(the empty string) for strings
				</p>
			</li>
			<li>
				<p>
                    <code>nil</code>
                    &nbsp;for pointer, typeid, and any types.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The expression 
            <code>{}</code>
            &nbsp;can be used for all types to act as a zero type.
		</p>
		<ul>
			<li>
				<p>
                    This is 
					<em>
                        not
					</em>
                    &nbsp;recommended as it is not clear and if a type has a specific zero value shown above, please prefer that.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="broadcasting" >
    Broadcasting
</h3>
<h5
	id="directive" >
    Directive
</h5>
<ul>
	<li>
		<p>
            <code>#no_broadcast</code>
		</p>
	</li>
</ul>
<h5
	id="example" >
    Example
</h5>
<ul>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    I have this procedure:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> tween_create :: proc(
 Â  Â  Â  Â  value: Â  Â  Â  Â  Â  Â  Â ^$T,
 Â  Â  Â  Â  #no_broadcast end: Â T,
 Â  Â  Â  Â  duration_s: Â  Â  Â  Â  f64,
 Â  Â  Â  Â  ease: Â  Â  Â  Â  Â  Â  Â  ease.Ease = .Linear,
 Â  Â  Â  Â  start_delay_s: Â  Â  Â f64 = 0,
 Â  Â  Â  Â  custom_data: Â  Â  Â  Â rawptr = nil,
 Â  Â  Â  Â  on_start: Â  Â  Â  Â  Â  proc(tween: ^Tween) = nil,
 Â  Â  Â  Â  on_update: Â  Â  Â  Â  Â proc(tween: ^Tween) = nil,
 Â  Â  Â  Â  on_end: Â  Â  Â  Â  Â  Â  proc(tween: ^Tween) = nil,
 Â  Â  Â  Â  loc := Â  Â  Â  Â  Â  Â  Â #caller_location
 Â  Â  ) -&gt; (handle: Tween_Handle) { //etc }
</code></pre>
		<ul>
			<li>
				<p>
                    And I call it with:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> tween_create(
&nbsp;&nbsp;&nbsp;&nbsp; value = &personagem_user.arm1.pos_world,
&nbsp;&nbsp;&nbsp;&nbsp; end = arm_relative_target_trans.pos,
&nbsp;&nbsp;&nbsp;&nbsp; duration_s = 0.1,
&nbsp;&nbsp;&nbsp;&nbsp; on_end = proc(tween: ^eng.Tween) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; personagem_user.arm1.is_stepping = false
&nbsp;&nbsp;&nbsp;&nbsp; },
 )
</code></pre>
		<ul>
			<li>
				<p>
                    So why don't I get a compile error, considering that 
                    <code>value</code>
                    &nbsp;is a 
                    <code>[2]f32</code>
                    &nbsp;and 
                    <code>end</code>
                    &nbsp;is a 
                    <code>f32</code>
                    ?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Thag and Blob:
		</p>
		<ul>
			<li>
				<p>
                    Because 
                    <code>f32</code>
                    &nbsp;can broadcast to 
                    <code>[2]f32</code>
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> my_arr: [2]f32 
 my_arr = 3.0 
 fmt.println(my_arr) // [2]f32{3.0, 3.0}
</code></pre>
		<ul>
			<li>
				<p>
                    it's really useful in certain cases
				</p>
			</li>
			<li>
				<p>
                    like allowing you to do:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> my_vec *= 2
</code></pre>
		<ul>
			<li>
				<p>
                    you can add 
                    <code>#no_broadcast param</code>
                    &nbsp;to procs params to stop it doing so.
				</p>
			</li>
			<li>
				<p>
                    in front of the param
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> #no_broadcast end: T
</code></pre>
		<ul>
			<li>
				<p>
                    you can add it both to 
                    <code>value</code>
                    &nbsp;and 
                    <code>end</code>
                    &nbsp;if you want.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="casting" >
    Casting
</h3>
<ul>
	<li>
		<p>
            All the syntaxes below produce the exact same result.
		</p>
	</li>
	<li>
		<p>
            Those are semantic casts. It's a compiler-known 
			<em>
                conversion
			</em>
            &nbsp;between two types in a way that semantically makes sense.
		</p>
	</li>
	<li>
		<p>
            A straightforward example would be converting between 
            <code>int</code>
            &nbsp;and 
            <code>f64</code>
            ; the conversion will have the same 
			<em>
                numerical
			</em>
            &nbsp;value, which will change its representation in memory.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">i := 123
f := f64(i)
u := u32(f)
</code></pre>
<pre><code class="language-odin" data-lang="odin">i := 123
f := (f64)(i)
u := (u32)(f)
</code></pre>
<pre><code class="language-odin" data-lang="odin">i := 123
f := cast(f64)i
u := cast(u32)f
</code></pre>
<h5
	id="auto-cast-operator" >
    ~Auto Cast Operator
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#auto-cast-operation" 
				class="external-link" 
				target="_blank" >
                Auto Cast Operator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The 
            <code>auto_cast</code>
            &nbsp;operator automatically casts an expression to the destinationâ€™s type if possible.
		</p>
	</li>
	<li>
		<p>
            This operation is only recommended for prototyping and quick tests. Do not overuse it.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">x: f32 = 123
y: int = auto_cast x
</code></pre>
<h5
	id="advanced-idioms-down-cast-and-up-cast" >
    Advanced Idioms, Down-Cast and Up-Cast
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#advanced-idioms" 
				class="external-link" 
				target="_blank" >
                <code>union</code>
                -based subtype polymorphism (Advanced Idioms)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Subtyping in procedure overload
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    See 
                    <a href="Odin.html#Procedure Groups (explicit overload)">
                    Odin#Procedure Groups (explicit overload)
                    </a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Area to Hurtbox and Hurtbox to Area
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Very useful.
				</p>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            Consider an 
                            <code>Area</code>
                            &nbsp;and a 
                            <code>Hurtbox</code>
                            &nbsp;type, where 
                            <code>Hurtbox</code>
                            &nbsp;inherits from 
                            <code>Area</code>
                            &nbsp;(
                            <code>using area: Area</code>
                            ).
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> obj := Area{
&nbsp;&nbsp;&nbsp;&nbsp; area_entered = some_func_pointer,
&nbsp;&nbsp;&nbsp;&nbsp; area_exited&nbsp;&nbsp;= some_func_pointer,
 }
 fmt.printfln("OPERATION 1: %v", cast(Hurtbox)obj)
 fmt.printfln("OPERATION 2: %v", cast(^Hurtbox)&obj)
</code></pre>
				<ul>
					<li>
						<p>
                            The Operation 1 is not allowed, and the Operation 2 causes a Stack-Buffer-Overflow. My question is: how / why does this happen, for both operations?
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Barinzaya:
				</p>
				<ul>
					<li>
						<p>
                            A 
                            <code>Hurtbox</code>
                            &nbsp;is an 
                            <code>Area</code>
                            &nbsp;
							<em>
                                plus more
							</em>
                            &nbsp;(the 
                            <code>Area</code>
                            &nbsp;is just part of the 
                            <code>Hurtbox</code>
                            ). When you assign 
                            <code>obj</code>
                            &nbsp;to be an 
                            <code>Area</code>
                            , it is 
							<em>
                                only
							</em>
                            &nbsp;the contents of an 
                            <code>Area</code>
                            , there's no extra space reserved for the extra things that a 
                            <code>Hurtbox</code>
                            &nbsp;would also contain.
						</p>
					</li>
					<li>
						<p>
                            Subtyping can easily downcast (
                            <code>Hurtbox</code>
                            &nbsp;to 
                            <code>Area</code>
                            ) because every 
                            <code>Hurtbox</code>
                            &nbsp;contains a complete 
                            <code>Area</code>
                            , but upcasting (
                            <code>Area</code>
                            &nbsp;to 
                            <code>Hurtbox</code>
                            ) only works on an 
                            <code>^Area</code>
                            &nbsp;that 
							<em>
                                points into
							</em>
                            &nbsp;a complete 
                            <code>Hurtbox</code>
                            .
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        NOTE
									</em>
                                    : You can 
									<strong>
                                        only
									</strong>
                                    &nbsp;cast if it's also the first field, otherwise you'd need to use 
                                    <code>container_of</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    When you make a variable of type 
                                    <code>Area</code>
                                    , it 
									<em>
                                        isn't
									</em>
                                    &nbsp;part of a complete 
                                    <code>Hurtbox</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Odin doesn't implicitly embed any 
							<strong>
                                RTTI
							</strong>
                            &nbsp;(Runtime Type Information) in the type, so you can't definitively tell whether a given 
                            <code>Area</code>
                            &nbsp;is part of a 
                            <code>Hurtbox</code>
                            &nbsp;or not, so there is no 
                            <code>dynamic_cast</code>
                            /type-aware pointer casting.
						</p>
					</li>
					<li>
						<p>
                            That's where patterns like 
							<a
								href="https://odin-lang.org/docs/overview/#advanced-idioms" 
								class="external-link" 
								target="_blank" >
                                <code>union</code>
                                -based subtype polymorphism
							</a>
                            &nbsp;come into play--that's an approach to 
							<em>
                                adding
							</em>
                            &nbsp;that extra information for you to know what type it is.
						</p>
						<ul>
							<li>
								<p>
                                    Though it stores a self-pointer, so it can cause issues if you later copy the struct without updating it.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            Isn't there a way to do something like gdscript does: 
                            <code>if not (area is Hitbox): return</code>
                            , for example?
						</p>
					</li>
					<li>
						<p>
                            I mean, can I check for something like the length of the object inside the pointer, to see if the length corresponds to a complete Area or something more? I'm not sure if my question makes sense, as I don't know if checking for the content of the ^Area would give me something besides what an Area has
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Barinzaya:
				</p>
				<ul>
					<li>
						<p>
                            That would require Odin to implicitly add extra info into the 
                            <code>struct</code>
                            . It doesn't do that.
						</p>
					</li>
					<li>
						<p>
                            And as for the length: That info isn't in the type. If you're talking like 
                            <code>size_of(ptr^)</code>
                            &nbsp;or something, the compiler is just going to give you that info based on what it knows based on the types. It doesn't do any kind of run-time lookup to try to figure it out.
						</p>
					</li>
					<li>
						<p>
                            &quot;as I don't know if checking for the content of the ^Area would give me something besides what an Area has&quot;. That's exactly what I'm saying--there 
							<em>
                                is
							</em>
                            &nbsp;no other info there other than what you put in the 
                            <code>struct</code>
                            . There's nothing 
							<em>
                                to
							</em>
                            &nbsp;check, unless you put it there yourself.
						</p>
					</li>
					<li>
						<p>
                            Subtyping is syntax sugar, and nothing more.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            So my only options are:
						</p>
						<ol>
							<li>
								<p>
                                    Place some more info in the struct to avoid casting blindly
								</p>
							</li>
							<li>
								<p>
                                    Yolo cast blindly, but only do the casting if you are sure it's safe (like I'm doing for the function pointers inside the structs).
								</p>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Barinzaya:
				</p>
				<ul>
					<li>
						<p>
                            Basically, yes.
						</p>
					</li>
					<li>
						<p>
                            Number 1 is what OOP languages do, they just do it implicitly. Odin doesn't do that.
						</p>
					</li>
					<li>
						<p>
                            More specifically: that info has to come from 
							<em>
                                somewhere
							</em>
                            . If all you have is an 
                            <code>^Area</code>
                            , then it has to come from inside of the 
                            <code>struct</code>
                            , but it could also come from something associated with the pointer.
						</p>
					</li>
					<li>
						<p>
                            A 
                            <code>union</code>
                            &nbsp;of pointers or an 
                            <code>any</code>
                            , they store both a pointer 
							<em>
                                and
							</em>
                            &nbsp;a tag/
                            <code>typeid</code>
                            &nbsp;respectively that they use to know what the pointer actually points it.
						</p>
						<ul>
							<li>
								<p>
                                    He means in the sense of not receiving 
                                    <code>^Arena</code>
                                    &nbsp;directly, but an 
                                    <code>union</code>
                                    &nbsp;or 
                                    <code>any</code>
                                    &nbsp;in its place
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="transmute" >
    Transmute
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#transmute-operator" 
				class="external-link" 
				target="_blank" >
                Transmute Operator
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It is a bitcast; that is, it reinterprets the memory for a variable without changing its actual bytes.
		</p>
	</li>
	<li>
		<p>
            Using the same example as above, 
            <code>transmute</code>
            ing from 
            <code>int</code>
            &nbsp;to 
            <code>f64</code>
            &nbsp;will keep the same representation in memory, which means the 
			<em>
                numerical
			</em>
            &nbsp;value will be different.
		</p>
	</li>
	<li>
		<p>
            This can be useful for bit-twiddling things in floats, for instance; 
            <code>core:math</code>
            &nbsp;does that for some of its procs.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">f: f32 = 123
u := transmute(u32)f
</code></pre>
<h3
	id="type-conversions" >
    Type Conversions
</h3>
<h5
	id="from-codeint-code-to-code8byte-code" >
    From 
    <code>int</code>
    &nbsp;to 
    <code>[8]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>transmute([8]byte)i</code>
		</p>
	</li>
	<li>
		<p>
            A fixed array is its data, so transmuting will give you the actual bytes of the 
            <code>int</code>
            .
		</p>
	</li>
	<li>
		<p>
            You may also want to consider 
			<em>
                casting
			</em>
            &nbsp;to one of the endian-specific integer types first if you care about the bytes being the same on big-endian systems.
		</p>
	</li>
</ul>
<h5
	id="from-codeint-code-to-codebyte-code" >
    From 
    <code>[]int</code>
    &nbsp;to 
    <code>[]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>[]int</code>
            &nbsp;ss a slice, but 
            <code>transmute</code>
            ing to 
            <code>u8</code>
            &nbsp;won't change the length; a slice of 4 
            <code>int</code>
            s would 
            <code>transmute</code>
            &nbsp;into a slice of 4 
            <code>u8</code>
            s.
		</p>
	</li>
	<li>
		<p>
            You probably want to use 
            <code>slice.to_bytes</code>
            &nbsp;(or more generically, 
            <code>slice.reinterpret</code>
            ). That will give you a 
            <code>u8</code>
            &nbsp;slice with the correct size.
		</p>
	</li>
	<li>
		<p>
            The same note about endianness applies here, but it's not as straightforward to convert between the two.
		</p>
	</li>
</ul>
<h5
	id="from-codet-code-to-codebyte-code" >
    From 
    <code>[]T</code>
    &nbsp;to 
    <code>[]byte</code>
</h5>
<ul>
	<li>
		<p>
            <s>
            <code>transmute([]byte)my_slice</code>
            </s>
		</p>
		<ul>
			<li>
				<p>
                    Doesn't work well.
				</p>
			</li>
			<li>
				<p>
                    &quot;It will literally reinterpret the slice itself as a byte slice; you have to use something in 
                    <code>core:slice</code>
                    &nbsp;or 
                    <code>encoding</code>
                    &quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codestring-code-to-codecstring-code" >
    From 
    <code>string</code>
    &nbsp;to 
    <code>cstring</code>
</h5>
<ul>
	<li>
		<p>
            <code>strings.unsafe_string_to_cstring(st)</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
			<li>
				<p>
                    The internal operation is:
				</p>
<pre><code class="language-odin" data-lang="odin"> raw_string&nbsp;&nbsp;:= transmute(mem.Raw_String)s
 cs := cstring(raw_string.data)
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>strings.clone_to_cstring(s)</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Copy.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codestring-code-to-coderune-code" >
    From 
    <code>string</code>
    &nbsp;to 
    <code>rune</code>
</h5>
<ul>
	<li>
		<p>
            <code>for in</code>
		</p>
		<ul>
			<li>
				<p>
                    Assumes the string is encoded as UTF-8.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> s := "important words"
 for r in s {
&nbsp;&nbsp;&nbsp;&nbsp; // r is type `rune`.
&nbsp;&nbsp;&nbsp;&nbsp; // works equally for any UTF-8 char; e.g., Japanese, etc.
 }
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Stream
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codestring-code-to-coderune-code" >
    From 
    <code>string</code>
    &nbsp;to 
    <code>[]rune</code>
</h5>
<ul>
	<li>
		<p>
            <code>utf8.string_to_runes(st)</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Copy
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codestring-code-to-codebyte-code" >
    From 
    <code>string</code>
    &nbsp;to 
    <code>byte</code>
</h5>
<pre><code class="language-odin" data-lang="odin">last_character := s[len(s) - 1]
&nbsp;&nbsp;&nbsp;&nbsp;// This is a `byte` / `u8`
</code></pre>
<pre><code class="language-odin" data-lang="odin">// string length is in bytes
for idx in 0..&lt;len(s) {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println(idx, s[idx])
&nbsp;&nbsp;&nbsp;&nbsp;// 0 65
&nbsp;&nbsp;&nbsp;&nbsp;// 1 66
&nbsp;&nbsp;&nbsp;&nbsp;// 2 67
}
</code></pre>
<h5
	id="from-codestring-code-to-codebyte-code" >
    From 
    <code>string</code>
    &nbsp;to 
    <code>[]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>transmute([]byte)s</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
			<li>
				<p>
                    Is functionally a 
                    <code>[]byte</code>
                    &nbsp;with different semantics, so you can transmute to it.
				</p>
			</li>
			<li>
				<p>
                    This works because their in-memory layout is the same; see 
                    <code>runtime.Raw_Slice</code>
                    &nbsp;and 
                    <code>runtime.Raw_String</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Does not work for 
                    <code>untyped string</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The type needs to be explicit.
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> // Does not work
 msg :: "hello"
 data := transmute([]u8)msg
 
 // Works
 msg: string : "hello"
 data := transmute([]u8)msg
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codestring-code-to-codebyte-code" >
    From 
    <code>string</code>
    &nbsp;to 
    <code>[^]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>raw_data(s)</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codestring-code-to-codebyte-code" >
    From 
    <code>[]string</code>
    &nbsp;to 
    <code>[]byte</code>
</h5>
<ul>
	<li>
		<p>
            It's effectively a pointer to pointers.
		</p>
	</li>
	<li>
		<p>
            If you want the bytes of each string sequentially, you will have to loop through them and copy them into a buffer.
		</p>
	</li>
</ul>
<h5
	id="from-codecstring-code-to-codestring-code" >
    From 
    <code>cstring</code>
    &nbsp;to 
    <code>string</code>
</h5>
<ul>
	<li>
		<p>
            <code>string(cs)</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>strings.clone_from_cstring(cs)</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Copy.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codecstring-code-to-coderune-code" >
    From 
    <code>cstring</code>
    &nbsp;to 
    <code>rune</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codecstring-code-to-coderune-code" >
    From 
    <code>cstring</code>
    &nbsp;to 
    <code>[]rune</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codecstring-code-to-codebyte-code" >
    From 
    <code>cstring</code>
    &nbsp;to 
    <code>byte</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codecstring-code-to-codebyte-code" >
    From 
    <code>cstring</code>
    &nbsp;to 
    <code>[]byte</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codecstring-code-to-codebyte-code" >
    From 
    <code>cstring</code>
    &nbsp;to 
    <code>[^]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>transmute([^]byte)cs</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-codestring-code" >
    From 
    <code>[]byte</code>
    &nbsp;to 
    <code>string</code>
</h5>
<ul>
	<li>
		<p>
            <code>string(bs)</code>
		</p>
		<ul>
			<li>
				<p>
                    Unless it's a slice literal
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>transmute(string)bs</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-codecstring-code" >
    From 
    <code>[]byte</code>
    &nbsp;to 
    <code>cstring</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-coderune-code" >
    From 
    <code>[]byte</code>
    &nbsp;to 
    <code>rune</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-coderune-code" >
    From 
    <code>[]byte</code>
    &nbsp;to 
    <code>[]rune</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-codebyte-code" >
    From 
    <code>[]byte</code>
    &nbsp;to 
    <code>[^]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>raw_data(bs)</code>
		</p>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-codestring-code" >
    From 
    <code>byte</code>
    &nbsp;to 
    <code>string</code>
</h5>
<pre><code class="language-odin" data-lang="odin">last_character_as_byte := my_str[len(my_str) - 1]
string([]byte{ last_character_as_byte })
</code></pre>
<h5
	id="from-codebyte-code-to-codecstring-code" >
    From 
    <code>byte</code>
    &nbsp;to 
    <code>cstring</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-coderune-code" >
    From 
    <code>byte</code>
    &nbsp;to 
    <code>rune</code>
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="from-coderune-code-to-codestring-code" >
    From 
    <code>rune</code>
    &nbsp;to 
    <code>string</code>
</h5>
<ul>
	<li>
		<p>
            With a 
            <code>strings.Builder</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>strings.write_rune</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">bytes, length := utf8.encode_rune(r)
string(bytes[:length])
</code></pre>
<ul>
	<li>
		<p>
            <code>utf8.encode_rune</code>
            &nbsp;+ slice using the 
            <code>int</code>
            &nbsp;returned, to perform a 
            <code>string()</code>
            &nbsp;cast.
		</p>
	</li>
	<li>
		<p>
            No allocation is needed.
		</p>
	</li>
</ul>
<h5
	id="from-coderune-code-to-codebyte-code" >
    From 
    <code>rune</code>
    &nbsp;to 
    <code>[]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>utf8.encode_rune</code>
		</p>
		<ul>
			<li>
				<p>
                    Takes a 
                    <code>rune</code>
                    &nbsp;and gives you a 
                    <code>[4]u8, int</code>
                    &nbsp;which you can slice and string cast.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-coderune-code-to-codestring-code" >
    From 
    <code>[]rune</code>
    &nbsp;to 
    <code>string</code>
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/unicode/utf8/#runes_to_string" 
				class="external-link" 
				target="_blank" >
                <code>utf8.runes_to_string(rs)</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;C Byte Slice&quot;.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Copy.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codebyte-code-length-to-codestring-code" >
    From 
    <code>[^]byte</code>
    &nbsp;+ length to 
    <code>string</code>
</h5>
<ul>
	<li>
		<p>
            <code>strings.string_from_ptr(ptr, length)</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codebyte-code-to-codecstring-code" >
    From 
    <code>[^]byte</code>
    &nbsp;to 
    <code>cstring</code>
</h5>
<ul>
	<li>
		<p>
            <code>cstring(ptr)</code>
		</p>
		<ul>
			<li>
				<p>
                    &quot;C Byte Slice&quot;.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Action
					</strong>
                    : Alias.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="from-codestruct-code-to-codebyte-code" >
    From 
    <code>struct</code>
    &nbsp;to 
    <code>[^]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>cast([^]u8)&my_struct</code>
		</p>
	</li>
</ul>
<h5
	id="from-codestruct-code-to-codebyte-code" >
    From 
    <code>struct</code>
    &nbsp;to 
    <code>[]byte</code>
</h5>
<ul>
	<li>
		<p>
            <code>(cast([^]u8)&my_struct)[:size_of(my_struct)]</code>
		</p>
	</li>
	<li>
		<p>
            <code>mem.ptr_to_bytes(ptr, len)</code>
		</p>
		<ul>
			<li>
				<p>
                    Creates a byte slice pointing to 
                    <code>len</code>
                    &nbsp;objects, starting from the address specified by 
                    <code>ptr</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    It just does 
                    <code>transmute([]byte)Raw_Slice{ptr, len*size_of(T)}</code>
                    &nbsp;internally.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="type-typeid-size_of" >
    type / typeid / size_of
</h3>
<h5
	id="type" >
    Type
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#type_of" 
				class="external-link" 
				target="_blank" >
                <code>type_of(x: expr) -&gt; type</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Strange.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Get the type of a variable
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> typeid_of(type_of(parse))
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Places using 
                <code>expr</code>
                &nbsp;or 
                <code>type</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>base:builtin</code>
				</p>
<pre><code class="language-odin" data-lang="odin"> type_of :: proc(x: expr) -&gt; type ---
</code></pre>
			</li>
			<li>
				<p>
                    <code>base:intrinsics</code>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> soa_struct :: proc($N: int, $T: typeid) -&gt; type/#soa[N]T
 type_base_type :: proc($T: typeid) -&gt; type ---
 type_core_type :: proc($T: typeid) -&gt; type ---
 type_elem_type :: proc($T: typeid) -&gt; type ---
 type_integer_to_unsigned :: proc($T: typeid) -&gt; type where type_is_integer(T), !type_is_unsigned(T) ---
 type_integer_to_signed Â  :: proc($T: typeid) -&gt; type where type_is_integer(T), type_is_unsigned(T) ---
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="typeid" >
    typeid
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#typeid" 
				class="external-link" 
				target="_blank" >
                <code>typeid</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#type_info_of" 
				class="external-link" 
				target="_blank" >
                <code>type_info_of($T: typeid) -&gt; Type_Info</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#typeid_of" 
				class="external-link" 
				target="_blank" >
                <code>typeid_of($T: typeid) -&gt; typeid</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Strange.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            Why isn't this allowed?
						</p>
<pre><code class="language-odin" data-lang="odin"> id: typeid = f32
 data: int = 2
 log.debugf("thing: %v", cast(id)data)
</code></pre>
					</li>
					<li>
						<p>
                            I'm trying to understand a bit more about typeid.
						</p>
					</li>
					<li>
						<p>
                            I've seen it being used as a compile time known constant in generic procedures, 
                            <code>$T: typeid</code>
                            , and in this case it can be used for casting? How does this work?
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    GingerBill:
				</p>
				<ul>
					<li>
						<p>
                            Because 
                            <code>cast</code>
                            &nbsp;is a compile time operation.
						</p>
					</li>
					<li>
						<p>
                            What you are doing requires an run time operation which is very difficult to do.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Barinzaya:
				</p>
				<ul>
					<li>
						<p>
                            A proc argument like 
                            <code>$T: typeid</code>
                            &nbsp;is 
							<a
								href="https://odin-lang.org/docs/overview/#explicit-parametric-polymorphism" 
								class="external-link" 
								target="_blank" >
                                parapoly
							</a>
                            , which means it's basically a generic/template argument.
						</p>
					</li>
					<li>
						<p>
                            The compiler will generate a separate variation of the proc for every unique group of parapoly arguments it's called with.
						</p>
					</li>
					<li>
						<p>
                            Naturally, that means that the argument must be known at compile-time, so it can't be a variable.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            hmmm ok. So, a brief of what I was thinking of doing: I'm trying to store some data in a struct in its generic form, and then use some other data to cast it back to the original data. A 
                            <code>any</code>
                            &nbsp;stores exactly what I need: a 
                            <code>rawptr</code>
                            &nbsp;and a type, but I got confused about the 
                            <code>typeid</code>
                            . Is there a way to accomplish this operation?
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Barinzaya:
				</p>
				<ul>
					<li>
						<p>
                            You basically have to just type switch on the 
                            <code>any</code>
                            &nbsp;and handle the cases that you care about, e.g. how 
                            <code>fmt</code>
                            &nbsp;handles arguments: https://github.com/odin-lang/Odin/blob/38faec757d4e4648a86fb17a1fda0e2399a3ea19/core/fmt/fmt.odin#L3168.
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> base_arg := arg&nbsp;&nbsp;// is an any.
 base_arg.id = runtime.typeid_base(base_arg.id)&nbsp;&nbsp;// probably to avoid derivative types `my_int :: int`, something like that.
 switch a in base_arg {
 case bool:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt_bool(fi, a, verb)
 case b8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt_bool(fi, bool(a), verb)
 case b16:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt_bool(fi, bool(a), verb)
 case b32:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt_bool(fi, bool(a), verb)
 case b64:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt_bool(fi, bool(a), verb)
 
 case any:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt_arg(fi,&nbsp;&nbsp;a, verb)
 case rune:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt_rune(fi, a, verb)
 // etc
 }
</code></pre>
				<ul>
					<li>
						<p>
                            A 
                            <code>union</code>
                            &nbsp;is usually better unless you 
							<em>
                                really
							</em>
                            &nbsp;need to handle anything. 
                            <code>any</code>
                            &nbsp;is a pointer that doesn't behave like a pointer and is easy to misuse; a 
                            <code>union</code>
                            &nbsp;actually contains its value. Cases needing true generic handling are rare, usually for arbitrary (de)serialization and printing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Jesse:
				</p>
				<ul>
					<li>
						<p>
                            <code>any</code>
                            &nbsp;should be avoided until all other alternatives have been explored.
						</p>
					</li>
					<li>
						<p>
                            It is almost never the case that you really don't know what set of types some data could be.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="size_of" >
    size_of
</h5>
<ul>
	<li>
		<p>
            Why do I get a different value for 
            <code>size_of</code>
            , between 
            <code>bar1</code>
            &nbsp;and 
            <code>bar2</code>
            ?
		</p>
<pre><code class="language-odin" data-lang="odin"> Vertex :: struct {
&nbsp;&nbsp;&nbsp;&nbsp; pos:&nbsp;&nbsp; [2]f32,
&nbsp;&nbsp;&nbsp;&nbsp; color: [3]f32,
 }
 
 foo :: proc(array: []$MEMBER) {&nbsp;&nbsp;// passing a `[]Vertex` as a parameter
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println(size_of(MEMBER))&nbsp;&nbsp;// prints 20
&nbsp;&nbsp;&nbsp;&nbsp; bar1(MEMBER)
&nbsp;&nbsp;&nbsp;&nbsp; bar2(MEMBER)
 }
 
 bar1 :: proc(member: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println(size_of(member)) // prints 8
 }
 
 bar2 :: proc($member: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println(size_of(member)) // prints 20
 }
</code></pre>
		<ul>
			<li>
				<p>
                    <code>bar1</code>
                    &nbsp;is the 
                    <code>typeid</code>
                    &nbsp;of 
                    <code>Vertex</code>
                    , not 
                    <code>Vertex</code>
                    , so it's getting the size of a 
                    <code>typeid</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>typeid</code>
                    &nbsp;is the type of types. It's a hash of the type's canonical name. At compile time the compiler knows what the underlying type is, so it'll use the type itself rather than 
                    <code>typeid</code>
                    . At runtime it can't know, so it'll be a 
                    <code>typeid</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Compile-time 
                    <code>typeid</code>
                    s 
					<em>
                        are
					</em>
                    &nbsp;effectively types (which is why you can do stuff like 
                    <code>proc ($T: typeid) -&gt; T</code>
                    ), whereas run-time 
                    <code>typeid</code>
                    s are indeed just an ID (
                    <code>u64</code>
                    -sized).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="any" >
    any
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#any" 
				class="external-link" 
				target="_blank" >
                <code>any</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#Raw_Any" 
				class="external-link" 
				target="_blank" >
                <code>Raw_Any</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It is functionally equivalent to 
            <code>struct {data: rawptr, id: typeid}</code>
            &nbsp;with extra semantics on how assignment and type assertion works.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>any</code>
            &nbsp;value is only valid as long as the underlying data is still valid. Passing a literal to an 
            <code>any</code>
            &nbsp;will allocate the literal in the current stack frame.
		</p>
	</li>
</ul>
<h3
	id="comparison-codeany-code-vs-codeunion-code" >
    Comparison 
    <code>any</code>
    &nbsp;vs 
    <code>union</code>
</h3>
<ul>
	<li>
		<p>
            <code>any</code>
            &nbsp;is a topologically-dual to a 
            <code>union</code>
            &nbsp;in terms of its usage.
		</p>
		<ul>
			<li>
				<p>
                    Both support assignments of differing types (
                    <code>any</code>
                    &nbsp;being open to any type, 
                    <code>union</code>
                    &nbsp;being closed to a specific set of types).
				</p>
			</li>
			<li>
				<p>
                    Both support type assertions (
                    <code>x.(T)</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    Both support 
                    <code>switch in</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The main internal difference is how the memory is stored.
		</p>
		<ul>
			<li>
				<p>
                    A 
                    <code>any</code>
                    &nbsp;being open is a pointer+typeid, a 
                    <code>union</code>
                    &nbsp;is a blob+tag.
				</p>
			</li>
			<li>
				<p>
                    A 
                    <code>union</code>
                    &nbsp;does not need to store a 
                    <code>typeid</code>
                    &nbsp;because it is a closed ABI-consistent set of variant types.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="structure" >
    Structure
</h3>
<pre><code class="language-odin" data-lang="odin">Raw_Any :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;data: rawptr, // pointer to the data
&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;&nbsp; typeid, // type of the data
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">@(require_results)
any_data :: #force_inline proc(v: any) -&gt; (data: rawptr, id: typeid) {
Â  Â  return v.data, v.id
}
</code></pre>
<h3
	id="storing-data" >
    Storing data
</h3>
<ul>
	<li>
		<p>
            It always stores a pointer to the data.
		</p>
	</li>
	<li>
		<p>
            <code>any</code>
            &nbsp;only works by having a pointer to something. This something can be stored in the heap or on the stack.
		</p>
	</li>
	<li>
		<p>
            If the data is already stored somewhere the operation is more direct, otherwise a temp variable is created on the stack and a pointer to this temp variable is used instead.
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                only
			</em>
            &nbsp;way to make 
            <code>any</code>
            &nbsp;hold a value that outlasts the stack, the value needs to be stored in the heap. This is needed as an 
            <code>any</code>
            &nbsp;only stores a pointer to something; this indirection makes things a quite more annoying.
		</p>
	</li>
</ul>
<h5
	id="loose-examples" >
    Loose examples
</h5>
<ul>
	<li>
		<p>
			<strong>
                The value is already stored
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">x: int = 123
a: any = x

// equivalent to

a: any = { data = &x, id = typeid_of(type_of(x)) }
</code></pre>
<pre><code class="language-odin" data-lang="odin">x: ^int = new(123)
a: any = x

// equivalent to

a: any = { data = &x, id = typeid_of(type_of(x)) }
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                The value is not yet stored
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">a: any = 123

// equivalent to

_tmp: int = 123&nbsp;&nbsp;// variable created on the stack
a: any = { data = &_tmp, id = typeid_of(type_of(_tmp)) }
</code></pre>
<pre><code class="language-odin" data-lang="odin">x: int = 123
a: any = &x

// equivalent to

_tmp: ^int = &x // variable created on the stack
a: any = { data = &_tmp, id = typeid_of(type_of(_tmp)) }
</code></pre>
<h5
	id="storing-a-pointer-to-something-on-the-stack" >
    Storing a pointer to something on the stack
</h5>
<ul>
	<li>
		<p>
            It's possible to get a pointer to the value (the value is stored):
		</p>
		<ul>
			<li>
				<p>
                    Assigning implicitly:
				</p>
				<ul>
					<li>
						<p>
                            <code>x: int = 123; a: any = x</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>x</code>
                                    &nbsp;is a value on the stack.
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores&nbsp;&nbsp;
                                    <code>a.data = &x</code>
                                    , which is a pointer to the value on the 
									<strong>
                                        stack
									</strong>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>x: ^int = &i; a: any = x</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>i</code>
                                    &nbsp;is a value on the stack.
								</p>
							</li>
							<li>
								<p>
                                    <code>x</code>
                                    &nbsp;stores a pointer to something on the stack.
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores&nbsp;&nbsp;
                                    <code>a.data = &x</code>
                                    , which is a pointer to something on the 
									<strong>
                                        stack
									</strong>
                                    , to a pointer to something on the stack.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>x := make([]int, 3); a: any = x</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>x</code>
                                    &nbsp;is a array slice on the stack, that stores a pointer to something on the heap.
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores 
                                    <code>a.data = &x</code>
                                    , which is a pointer to the array slice on the 
									<strong>
                                        stack
									</strong>
                                    , which then points to the heap.
								</p>
							</li>
							<li>
								<p>
                                    This is a really weird one, but 
                                    <code>x</code>
                                    &nbsp;is indeed on the stack, as mentioned by 'Barinzaya' and 'rats'.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>x: ^int = new_clone(123); a: any = x</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>x</code>
                                    &nbsp;is a pointer to the heap.
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores 
                                    <code>a.data = &x</code>
                                    , which is a pointer on the 
									<strong>
                                        stack
									</strong>
                                    , to a pointer on the heap.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Assigning explicitly (storing directly into the 
                    <code>.data</code>
                    &nbsp;field):
				</p>
				<ul>
					<li>
						<p>
                            <code>x: ^int = &i; a: any = { data = x, id = typeid_of(int) }</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>i</code>
                                    &nbsp;is a value on the stack.
								</p>
							</li>
							<li>
								<p>
                                    <code>x</code>
                                    &nbsp;stores a pointer to something on the stack.
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores a pointer to something on the 
									<strong>
                                        stack
									</strong>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Note how an indirection is removed, when comparing to 
                                    <code>x: ^int = &i; a: any = x</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It's not possible to get a pointer to the value (the value is not stored):
		</p>
		<ul>
			<li>
				<p>
                    Assigning implicitly:
				</p>
				<ul>
					<li>
						<p>
                            <code>a</code>
                            &nbsp;will 
							<em>
                                always
							</em>
                            &nbsp;store 
                            <code>a.data = &_tmp</code>
                            , where 
                            <code>_tmp</code>
                            &nbsp;is on the stack; therefore, it always stores a pointer to the 
							<strong>
                                stack
							</strong>
                            , due to the indirection of&nbsp;&nbsp;
                            <code>&_tmp</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>a: any = 123</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>123</code>
                                    &nbsp;is a literal, not yet stored.
								</p>
							</li>
							<li>
								<p>
                                    <code>_tmp: int = 123</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores 
                                    <code>a.data = &_tmp</code>
                                    , which is a pointer to something on the 
									<strong>
                                        stack
									</strong>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>x: int = 123; a: any = &x</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>&x</code>
                                    &nbsp;is a pointer to 
                                    <code>x</code>
                                    ; the value is stored, but the pointer is not yet stored.
								</p>
							</li>
							<li>
								<p>
                                    <code>_tmp: ^int = &x</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores 
                                    <code>a.data = &_tmp</code>
                                    , which is a pointer to something on the 
									<strong>
                                        stack
									</strong>
                                    , to a pointer to something on the stack.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>a: any = new_clone(123)</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>new_clone(123)</code>
                                    &nbsp;is a pointer to 
                                    <code>123</code>
                                    &nbsp;on the heap; the value is stored on the heap, but the pointer is not yet stored.
								</p>
							</li>
							<li>
								<p>
                                    <code>_tmp: ^int = new_clone(123)</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores 
                                    <code>a.data = &_tmp</code>
                                    , which is a pointer to something on the 
									<strong>
                                        stack
									</strong>
                                    , to a pointer to something on the heap.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Assigning explicitly (storing directly into the 
                    <code>.data</code>
                    &nbsp;field):
				</p>
				<ul>
					<li>
						<p>
                            <code>a: any = { data = &i, id = typeid_of(int) }</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the same case as 
                                    <code>x: ^int = &i; a: any = { data = x, id = typeid_of(int) }</code>
                                    , but removing the need for 
                                    <code>x</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="storing-a-pointer-to-something-on-the-heap" >
    Storing a pointer to something on the heap
</h5>
<ul>
	<li>
		<p>
            It's possible to get a pointer to the value (the value is stored):
		</p>
		<ul>
			<li>
				<p>
                    Assigning implicitly:
				</p>
				<ul>
					<li>
						<p>
                            <code>x := make([]int, 3); a: any = x[2]</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>x</code>
                                    &nbsp;is a array slice on the stack, that stores a pointer to something on the heap.
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores 
                                    <code>a.data = &x[2]</code>
                                    , which is a pointer to something on the 
									<strong>
                                        heap
									</strong>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Even though 
                                    <code>x</code>
                                    &nbsp;is on the stack, 
                                    <code>x[i]</code>
                                    &nbsp;is a value on the heap, so 
                                    <code>&x[i]</code>
                                    &nbsp;is a pointer on the heap.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Assigning explicitly (storing directly into the 
                    <code>.data</code>
                    &nbsp;field):
				</p>
				<ul>
					<li>
						<p>
                            <code>x: ^int = new_clone(123, context.temp_allocator); a: any = { data = x, id = typeid_of(int) }</code>
						</p>
						<ul>
							<li>
								<p>
                                    <code>x</code>
                                    &nbsp;stores a pointer to something on the heap.
								</p>
							</li>
							<li>
								<p>
                                    <code>a</code>
                                    &nbsp;stores a pointer to something on the heap.
								</p>
								<ul>
									<li>
										<p>
                                            This is 
											<strong>
                                                not
											</strong>
                                            &nbsp;the same as doing:
										</p>
<pre><code class="language-odin" data-lang="odin"> x: ^int = new_clone(123)
 a: any = x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
										<ul>
											<li>
												<p>
                                                    <code>a</code>
                                                    &nbsp;stores a pointer to 
                                                    <code>x</code>
                                                    &nbsp;on the stack, which stores a pointer to something on the heap.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Note how 
                                    <code>id</code>
                                    &nbsp;needs to be 
                                    <code>int</code>
                                    , while 
                                    <code>x: ^int</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    When unwrapping the data, we'll get an 
                                    <code>int</code>
                                    , not the original 
                                    <code>^int</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The original 
                                    <code>^int</code>
                                    &nbsp;can actually be retrieved by doing 
                                    <code>(cast(^int)a.data)</code>
                                    , instead of 
                                    <code>(cast(^int)a.data)^</code>
                                    ; this has to be done manually.
								</p>
								<ul>
									<li>
										<p>
                                            The second option is done automatically by 
                                            <code>a.(int)</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Doing something like 
                                            <code>a.(^int)</code>
                                            &nbsp;in this case will just cause a failure, as 
                                            <code>(cast(^^int)a.data)^</code>
                                            &nbsp;is not valid; the data is not 
                                            <code>^^int</code>
                                            , but 
                                            <code>^int</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If the original 
                                    <code>^int</code>
                                    &nbsp;is not retrieved, then the pointer is lost and the memory cannot be freed; to avoid this, this technique should use of arena allocators, such as 
                                    <code>context.temp_allocator</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    [2025-11-08]
								</p>
								<ul>
									<li>
										<p>
                                            I tested this and it worked correctly:
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin"> batch := new_clone(Batch(T){
&nbsp;&nbsp;&nbsp;&nbsp; index Â = i32(i),
&nbsp;&nbsp;&nbsp;&nbsp; offset = i32(offset),
&nbsp;&nbsp;&nbsp;&nbsp; data Â  = data[offset:min(offset + max_batch_size, len(data))],
 }, context.temp_allocator)
 args[0] = { data = batch, id = typeid_of(Batch(T)) }
</code></pre>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It's not possible to get a pointer to the value (the value is not stored):
		</p>
		<ul>
			<li>
				<p>
                    <s>Assigning implicitly</s>:
				</p>
				<ul>
					<li>
						<p>
                            This makes a 
                            <code>_tmp</code>
                            &nbsp;be created, which will always be on the stack, so this is not possible if you want to store a pointer to something on the heap.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Assigning explicitly (storing directly into the 
                    <code>.data</code>
                    &nbsp;field):
				</p>
				<ul>
					<li>
						<p>
                            <code>a: any = { data = new_clone(123, context.temp_allocator), id = typeid_of(int) }</code>
						</p>
						<ul>
							<li>
								<p>
                                    Same case as 
                                    <code>x: ^int = new_clone(123, context.temp_allocator); a: any = { data = x, id = typeid_of(int) }</code>
                                    , but removing the need for 
                                    <code>x</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="about-array-slices-with-codeany-code" >
    About array/slices with 
    <code>any</code>
</h5>
<ul>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    A slice is a pointer and length, in 
                    <code>x := make([]int)</code>
                    &nbsp;
                    <code>x</code>
                    &nbsp;would still be on the stack.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Rats:
		</p>
		<ul>
			<li>
				<p>
                    Variables are always on the stack.
				</p>
			</li>
			<li>
				<p>
                    You can't have a &quot;heap allocated variable&quot;, but you can have a variable holding a pointer into the heap.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinazaya:
		</p>
		<ul>
			<li>
				<p>
                    That's what 
                    <code>x</code>
                    &nbsp;is. The actual data 
					<em>
                        in
					</em>
                    &nbsp;the slice is behind the pointer, and can be anywhere (heap, stack, mapped file, static data, etc.)
				</p>
			</li>
			<li>
				<p>
                    A slice is ultimately just a kind of pointer, it just points to an 
					<em>
                        array
					</em>
                    &nbsp;of a variable number of things rather than just one thing
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/runtime/#Raw_Slice" 
						class="external-link" 
						target="_blank" >
                        <code>Raw_Slice</code>
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    is it possible to do something like 
                    <code>x := make([]int); a: any = x.data</code>
                    , so the 
                    <code>a.data = &x.data</code>
                    , which then is a pointer to the heap?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    Kind of, but you wouldn't be able to keep the length
				</p>
			</li>
			<li>
				<p>
                    That's basically what 
                    <code>a: any = x[0]</code>
                    &nbsp;would do -- it would store a pointer to the first element in the backing data. But it loses the length.
				</p>
			</li>
			<li>
				<p>
                    If you knew the length, you could &quot;rebuild&quot; the slice, but 
                    <code>any</code>
                    &nbsp;won't really help with that.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    so then, there's no way for me to store a whole array inside a 
                    <code>any</code>
                    ?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    You'd have to allocate 
					<em>
                        the slice itself
					</em>
                    &nbsp;too
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> x_data := make([]int, 4)
 x := new_clone(x_data)
 a: any = x^
</code></pre>
		<ul>
			<li>
				<p>
                    But that means you need to handle 
                    <code>delete</code>
                    ing/
                    <code>free</code>
                    ing both levels of indirection. If you're getting to that point, maybe it's time to reconsider 
					<em>
                        why
					</em>
                    &nbsp;you need that.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="getting-the-underlying-value" >
    Getting the underlying value
</h3>
<ul>
	<li>
		<p>
            <code>(cast(^T)a.data)^</code>
            &nbsp;is the same as 
            <code>a.(T)</code>
            .
		</p>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    Also asserting the 
                    <code>id</code>
                    , but otherwise yes, they are the same.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Not possible:
		</p>
		<ul>
			<li>
				<p>
                    <code>(cast(^(a.id))a.data)^</code>
				</p>
			</li>
			<li>
				<p>
                    or
				</p>
			</li>
			<li>
				<p>
                    <code>a.(a.id)</code>
				</p>
			</li>
			<li>
				<p>
                    As the 
                    <code>.id</code>
                    &nbsp;id runtime known, not comptime known.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="using-code-code" >
    Using 
    <code>.()</code>
</h5>
<pre><code class="language-odin" data-lang="odin">My_Struct :: struct{
Â  Â  x: int,
Â  Â  y: intrinsics.Atomic_Memory_Order,
}
main :: proc() {
Â  Â  {
Â  Â  Â  Â  a: int = 123
Â  Â  Â  Â  b: any = a
Â  Â  Â  Â  c := b.(int)
Â  Â  Â  Â  fmt.printfln("a: %v, b: %v, c: %v", a, b, c)
Â  Â  }
Â  Â  {
Â  Â  Â  Â  a: [4]bool
Â  Â  Â  Â  b: any = a
Â  Â  Â  Â  c := b.([4]bool)
Â  Â  Â  Â  fmt.printfln("a: %v, b: %v, c: %v", a, b, c)
Â  Â  }
Â  Â  {
Â  Â  Â  Â  a := make([dynamic]My_Struct, context.temp_allocator)
Â  Â  Â  Â  append(&a, My_Struct{}, My_Struct{ 2, .Relaxed })
Â  Â  Â  Â  b: any = a
Â  Â  Â  Â  c := b.([dynamic]My_Struct)
Â  Â  Â  Â  fmt.printfln("a: %v, b: %v, c: %v", a, b, c)
Â  Â  }
Â  Â  {
Â  Â  Â  Â  a := make([dynamic]My_Struct, context.temp_allocator)
Â  Â  Â  Â  append(&a, My_Struct{}, My_Struct{ 2, .Relaxed })
Â  Â  Â  Â  b: any = a[:]
Â  Â  Â  Â  c := b.([]My_Struct)
Â  Â  Â  Â  fmt.printfln("a: %v, b: %v, c: %v", a, b, c)
Â  Â  }
}
</code></pre>
<ul>
	<li>
		<p>
            <code>a</code>
            , 
            <code>b</code>
            &nbsp;and 
            <code>c</code>
            &nbsp;here are always printed the same, while 
            <code>c</code>
            &nbsp;has the type of 
            <code>a</code>
            .
		</p>
	</li>
</ul>
<h5
	id="using-codeswitch-v-in-a-code" >
    Using 
    <code>switch v in a {}</code>
</h5>
<ul>
	<li>
		<p>
            <code>a</code>
            &nbsp;is the 
            <code>any</code>
            &nbsp;variable.
		</p>
	</li>
	<li>
		<p>
            <code>v</code>
            &nbsp;is the unwrapped value.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">a: any = 123
switch v in a {
case int:
&nbsp;&nbsp;&nbsp;&nbsp;fmt.printfln("Is int. Value: %v", v)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// prints "Is int. Value: 123"
case []byte:
}
</code></pre>
<h5
	id="using-the-codereflect-code-procedures" >
    Using the 
    <code>reflect</code>
    &nbsp;procedures
</h5>
<ul>
	<li>
		<p>
            They do the same operation as shown, but fancier.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_bool" 
				class="external-link" 
				target="_blank" >
                <code>as_bool</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_bytes" 
				class="external-link" 
				target="_blank" >
                <code>as_bytes</code>
			</a>
            .
		</p>
<pre><code class="language-odin" data-lang="odin"> @(require_results)
 as_bytes :: proc(v: any) -&gt; []byte {
 Â  Â  if v != nil {
 Â  Â  Â  Â  sz := size_of_typeid(v.id)
 Â  Â  Â  Â  return ([^]byte)(v.data)[:sz]
 Â  Â  }
 Â  Â  return nil
 }
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_f64" 
				class="external-link" 
				target="_blank" >
                <code>as_f64</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_i64" 
				class="external-link" 
				target="_blank" >
                <code>as_i64</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_u64" 
				class="external-link" 
				target="_blank" >
                <code>as_u64</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_int" 
				class="external-link" 
				target="_blank" >
                <code>as_int</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_uint" 
				class="external-link" 
				target="_blank" >
                <code>as_uint</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_pointer" 
				class="external-link" 
				target="_blank" >
                <code>as_pointer</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Attempts to convert an 
                    <code>any</code>
                    &nbsp;to a 
                    <code>rawptr</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This only works for 
                    <code>^T</code>
                    , 
                    <code>[^]T</code>
                    , 
                    <code>cstring</code>
                    , 
                    <code>cstring16</code>
                    &nbsp;based types.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> // Various considerations first.
 result = (^rawptr)(any_value.data)^
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_raw_data" 
				class="external-link" 
				target="_blank" >
                <code>as_raw_data</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Returns the equivalent of doing 
                    <code>raw_data(v)</code>
                    &nbsp;where 
                    <code>v</code>
                    &nbsp;is a non-any value
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> // Various considerations first.
 result = any_value.data
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_string" 
				class="external-link" 
				target="_blank" >
                <code>as_string</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_string16" 
				class="external-link" 
				target="_blank" >
                <code>as_string16</code>
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="etc" >
    Etc
</h3>
<h5
	id="is" >
    Is
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#is_nil" 
				class="external-link" 
				target="_blank" >
                <code>is_nil</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Returns true if the 
                    <code>any</code>
                    &nbsp;value is either 
                    <code>nil</code>
                    &nbsp;or the data stored at the address is all zeroed
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="etc" >
    Etc
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#as_string16" 
				class="external-link" 
				target="_blank" >
                <code>deref</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Dereferences 
                    <code>any</code>
                    &nbsp;if it represents a pointer-based value (
                    <code>^T -&gt; T</code>
                    )
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#enum_name_from_value_any" 
				class="external-link" 
				target="_blank" >
                <code>enum_name_from_value_any</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Returns the name of enum field if a valid name using reflection, otherwise returns 
                    <code>"", false</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#equal" 
				class="external-link" 
				target="_blank" >
                <code>equal</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Checks to see if two 
                    <code>any</code>
                    &nbsp;values are semantically equivalent
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#get_union_variant" 
				class="external-link" 
				target="_blank" >
                <code>get_union_variant</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Returns the underlying variant value of a union. Panics if a union was not passed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#get_union_variant_raw_tag" 
				class="external-link" 
				target="_blank" >
                <code>get_union_variant_raw_tag</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    UNSAFE: Returns the underlying tag value of a union. Panics if a union was not passed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#index" 
				class="external-link" 
				target="_blank" >
                <code>index</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Ggets the value by an index, if the type is indexable. Returns 
                    <code>nil</code>
                    &nbsp;if not possible
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
            See the example below about 
            <code>typeid</code>
            s.
		</p>
	</li>
</ul>
<h2
	id="primitive-types" >
    Primitive Types
</h2>
<h5
	id="bool" >
    bool
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#bool" 
				class="external-link" 
				target="_blank" >
                bool
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Has a size of 1 
            <code>byte</code>
            &nbsp;(
            <code>b8</code>
            ).
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">bool
</code></pre>
<ul>
	<li>
		<p>
            Other bools:
		</p>
<pre><code class="language-odin" data-lang="odin"> b8 b16 b32 b64
</code></pre>
		<ul>
			<li>
				<p>
                    &quot;The only world where you would use one of these other bools is if you are making a binding for another language that has different sized bool types.&quot;
				</p>
			</li>
			<li>
				<p>
                    <code>bool</code>
                    &nbsp;is equivalent to 
                    <code>b8</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="nil" >
    nil
</h5>
<ul>
	<li>
		<p>
            Types that support 
            <code>nil</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>rawptr</code>
				</p>
			</li>
			<li>
				<p>
                    <code>any</code>
				</p>
			</li>
			<li>
				<p>
                    <code>cstring</code>
				</p>
			</li>
			<li>
				<p>
                    <code>typeid</code>
				</p>
			</li>
			<li>
				<p>
                    <code>enum</code>
				</p>
			</li>
			<li>
				<p>
                    <code>bit_set</code>
				</p>
			</li>
			<li>
				<p>
                    Slices
				</p>
			</li>
			<li>
				<p>
                    <code>proc</code>
                    &nbsp;values
				</p>
			</li>
			<li>
				<p>
                    Pointers
				</p>
			</li>
			<li>
				<p>
                    <code>#soa</code>
                    &nbsp;Pointers
				</p>
			</li>
			<li>
				<p>
                    Multi-Pointers
				</p>
			</li>
			<li>
				<p>
                    Dynamic Arrays
				</p>
			</li>
			<li>
				<p>
                    <code>map</code>
				</p>
			</li>
			<li>
				<p>
                    <code>union</code>
                    &nbsp;without the 
                    <code>#no_nil</code>
                    &nbsp;directive
				</p>
			</li>
			<li>
				<p>
                    <code>#soa</code>
                    &nbsp;slices
				</p>
			</li>
			<li>
				<p>
                    <code>#soa</code>
                    &nbsp;dynamic arrays
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="rawptr" >
    rawptr
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#rawptr" 
				class="external-link" 
				target="_blank" >
                rawptr
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            All pointers can implicitly convert to 
            <code>rawptr</code>
            .
		</p>
	</li>
</ul>
<h5
	id="integer" >
    integer
</h5>
<ul>
	<li>
		<p>
            â€œnaturalâ€ register size.
		</p>
		<ul>
			<li>
				<p>
                    Is guaranteed to be greater than or equal to the size of a pointer.
				</p>
			</li>
			<li>
				<p>
                    When you need an integer value, you should default to using 
                    <code>int</code>
                    &nbsp;unless you have a specific reason to use a sized or unsigned integer type
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> int&nbsp;&nbsp;
 uint
</code></pre>
	</li>
	<li>
		<p>
            Specific sizes:
		</p>
<pre><code class="language-odin" data-lang="odin"> i8 i16 i32 i64 i128
 u8 u16 u32 u64 u128 
</code></pre>
	</li>
	<li>
		<p>
            Pointer size:
		</p>
<pre><code class="language-odin" data-lang="odin"> uintptr
</code></pre>
	</li>
	<li>
		<p>
            Endian-specific integers:
		</p>
<pre><code class="language-odin" data-lang="odin"> // little endian
 i16le i32le i64le i128le u16le u32le u64le u128le 
 
 // big endian
 i16be i32be i64be i128be u16be u32be u64be u128be 
</code></pre>
	</li>
</ul>
<h5
	id="float" >
    float
</h5>
<ul>
	<li>
		<p>
            No need to use 
            <code>f</code>
            &nbsp;in front of the float.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">f16 f32 f64
</code></pre>
<ul>
	<li>
		<p>
            Endian-specific floating point numbers:
		</p>
<pre><code class="language-odin" data-lang="odin"> // little endian
 f16le f32le f64le 
 
 // big endian
 f16be f32be f64be 
 
</code></pre>
	</li>
</ul>
<h5
	id="rune" >
    rune
</h5>
<ul>
	<li>
		<p>
            Signed 32-bit integer.
		</p>
	</li>
	<li>
		<p>
            Represents a Unicode code point.
		</p>
	</li>
	<li>
		<p>
            Is a distinct type from 
            <code>i32</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">rune
</code></pre>
<h2
	id="math-types" >
    Math Types
</h2>
<h3
	id="matrix" >
    Matrix
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#matrix-type" 
				class="external-link" 
				target="_blank" >
                Matrix
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<pre><code class="language-odin" data-lang="odin">m: matrix[2, 3]f32

m = matrix[2, 3]f32{
&nbsp;&nbsp;&nbsp;&nbsp;1, 9, -13,
&nbsp;&nbsp;&nbsp;&nbsp;20, 5, -6,
}
</code></pre>
<h5
	id="layout" >
    Layout
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#technical-information-of-matrix-types" 
				class="external-link" 
				target="_blank" >
                <code>#row_major</code>
                &nbsp;explanation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="clarification" >
    Clarification
</h5>
<ul>
	<li>
		<p>
            Rows and Columns begin at 0.
		</p>
	</li>
	<li>
		<p>
            &quot;column 1&quot; means the 2nd column.
		</p>
	</li>
	<li>
		<p>
            Same as an array.
		</p>
	</li>
</ul>
<h5
	id="representation-codex-y-code" >
    Representation 
    <code>[x, y]</code>
</h5>
<ul>
	<li>
		<p>
            The representation 
            <code>m[x, y]</code>
            &nbsp;is always the same regardless of the layout (column-major vs row-major).
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// row 1, column 2
elem := m[1, 2] 
</code></pre>
<h5
	id="representation-codex-code" >
    Representation 
    <code>[x]</code>
</h5>
<ul>
	<li>
		<p>
            Will return an array of the values in that column/row, 
			<strong>
                whichever is major
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            For column-major (default):
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// column 1
elem := m[1]
</code></pre>
<ul>
	<li>
		<p>
            For row-major (with 
            <code>#row_major</code>
            ):
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// row 1
elem := m[1]
</code></pre>
<h5
	id="representation-codexy-code" >
    Representation 
    <code>[x][y]</code>
</h5>
<ul>
	<li>
		<p>
            <code>m[x][y]</code>
            &nbsp;is just 
            <code>m[x]</code>
            &nbsp;and then indexing the 
            <code>y</code>
            th value in the array. If the layout of 
            <code>m[x]</code>
            &nbsp;changes, so does this; in other words, this representation is affected by the layout.
		</p>
	</li>
	<li>
		<p>
            For column-major (default):
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// column 1, row 2
elem := m[1][2] 
</code></pre>
<ul>
	<li>
		<p>
            For row-major (with 
            <code>#row_major</code>
            ):
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// row 1, column 2
elem := m[1][2] 
</code></pre>
<h5
	id="operations" >
    Operations
</h5>
<ul>
	<li>
		<p>
            <code>matrix4_perspective</code>
		</p>
		<ul>
			<li>
				<p>
                    Clip Space Z Range:
				</p>
				<ul>
					<li>
						<p>
                            <code>[-1 to +1]</code>
                            , just like OpenGL.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Clip Space Y:
				</p>
				<ul>
					<li>
						<p>
                            Y Up, just like OpenGL (Vulkan is Y Down).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Handedness:
				</p>
				<ul>
					<li>
						<p>
                            If 
                            <code>flip_z_axis</code>
                            &nbsp;is 
                            <code>true</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Right-handed coordinate system (camera forward is -Z).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If 
                            <code>flip_z_axis</code>
                            &nbsp;is 
                            <code>false</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Left-handed coordinate system (camera forward is +Z).
                                    <br>
                                    ``
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="quaternion" >
    Quaternion
</h3>
<h5
	id="type" >
    type
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#quaternion64" 
				class="external-link" 
				target="_blank" >
                <code>quaternion</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Is the set of all complex numbers with 
                    <code>f16</code>
                    /
                    <code>f32</code>
                    /
                    <code>f64</code>
                    &nbsp;real and imaginary (
                    <code>i</code>
                    , 
                    <code>j</code>
                    , &amp; 
                    <code>k</code>
                    ) parts.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#Raw_Quaternion128" 
				class="external-link" 
				target="_blank" >
                <code>Raw_Quaternion</code>
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">quaternion64 quaternion128 quaternion256
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#implicit-type-conversions" 
				class="external-link" 
				target="_blank" >
                Type Conversion
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>fN</code>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
                    <code>quaternion4N</code>
                    &nbsp;(e.g. 
                    <code>f32</code>
                    &nbsp;-&gt; 
                    <code>quaternion128</code>
                    )
				</p>
			</li>
			<li>
				<p>
                    <code>complex2N</code>
                    &nbsp;-&gt; 
                    <code>quaternion4N</code>
                    &nbsp;(e.g. 
                    <code>complex64</code>
                    &nbsp;-&gt; 
                    <code>quaternion128</code>
                    )
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="interpretation" >
    Interpretation
</h5>
<ul>
	<li>
		<p>
            &quot;It's a bit odd that the value is an operation. It's just a very 
			<em>
                mathematical
			</em>
            &nbsp;approach to it. It's basically an extension of how complex numbers are written mathematically, e.g., 
            <code>1 + 2i</code>
            &quot;.
		</p>
	</li>
	<li>
		<p>
            &quot;It's more just syntax sugar for setting its fields, I think&quot;.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">rot: quaternion128 = quaternion(x=0, y=0, z=0, w=1)&nbsp;&nbsp;// arguments must be named, to avoid ambiguity

rot: quaternion128 = 1 + 0i + 0j + 0k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this is valid.
</code></pre>
<ul>
	<li>
		<p>
            <code>rot: quaternion128 = 1</code>
            , same as 
            <code>1 + 0i + 0j + 0k</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is the identity quaternion.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>rot: quaternion128 = 0</code>
            , same as 
            <code>0 + 0i + 0j + 0k</code>
            .
		</p>
	</li>
</ul>
<h5
	id="procedures" >
    Procedures
</h5>
<ul>
	<li>
		<p>
			<strong>
                Quaternion from X
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(real, imag, jmag, kmag: Float) -&gt; (Quaternion_Type)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_scalar" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_from_scalar</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(f: f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_matrix3" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_from_matrix3</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(m: matrix[3, 3]f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_matrix4" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_from_matrix4</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(m: matrix[4, 4]f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#to_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>to_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>quaternion_from_matrix...</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>quaternion_from_scalar...</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Quaternion from angle
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_angle_axis" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_angle_axis</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(angle_radians: f32, axis: [3]f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Using 
                    <code>quaternion_angle_axis</code>
                    , specifying the axis automatically:
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_euler_angle_x" 
								class="external-link" 
								target="_blank" >
                                <code>quaternion_from_euler_angle_x</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    <code>(angle: f32) -&gt; (quaternion128)</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<a
								href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_euler_angle_y" 
								class="external-link" 
								target="_blank" >
                                <code>quaternion_from_euler_angle_y</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    <code>(angle: f32) -&gt; (quaternion128)</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<a
								href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_euler_angle_z" 
								class="external-link" 
								target="_blank" >
                                <code>quaternion_from_euler_angle_z</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    <code>(angle: f32) -&gt; (quaternion128)</code>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Using 
                    <code>quaternion_from_euler_angle_x/y/z</code>
                    , specifying the operation order:
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_euler_angles" 
								class="external-link" 
								target="_blank" >
                                <code>quaternion_from_euler_angles</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    <code>(t1, t2, t3: f32, order: Euler_Angle_Order) -&gt; (quaternion128)</code>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_pitch_yaw_roll" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_from_pitch_yaw_roll</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(pitch, yaw, roll: f32) -&gt; (quaternion128)</code>
						</p>
					</li>
					<li>
						<p>
                            Interestingly, does not use any of the above procedures.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250828142707.png" width="325" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Quaternion from vectors3
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_from_forward_and_up" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_from_forward_and_up</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(forward, up: [3]f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_look_at" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_look_at</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(eye, centre: [3]f32, up: [3]f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_between_two_vector3" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_between_two_vector3</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(from, to: [3]f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Quaternion to quaternion
			</strong>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_mul_vector3" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_mul_vector3</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128, v: [3]f32) -&gt; ([3]f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_nlerp" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_nlerp</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(a, b: quaternion128, t: f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_slerp" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_slerp</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(x, y: quaternion128, t: f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#quaternion_squad" 
						class="external-link" 
						target="_blank" >
                        <code>quaternion_squad</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q1, q2, s1, s2: quaternion128, h: f32) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#normalize" 
						class="external-link" 
						target="_blank" >
                        <code>normalize</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(quaternion128) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#normalize0" 
						class="external-link" 
						target="_blank" >
                        <code>normalize0</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(quaternion128) -&gt; (quaternion128)</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                X from quaternion
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#real" 
						class="external-link" 
						target="_blank" >
                        <code>real</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#imag" 
						class="external-link" 
						target="_blank" >
                        <code>imag</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#jmag" 
						class="external-link" 
						target="_blank" >
                        <code>jmag</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#kmag" 
						class="external-link" 
						target="_blank" >
                        <code>kmag</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#conj" 
						class="external-link" 
						target="_blank" >
                        <code>conj</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#angle_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>angle_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128) -&gt; (f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#angle_axis_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>angle_axis_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128) -&gt; (angle: f32, axis: [3]f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#euler_angles_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>euler_angles_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(m: quaternion128, order: Euler_Angle_Order) -&gt; (t1, t2, t3: f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#axis_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>axis_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128) -&gt; ([3]f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#pitch_yaw_roll_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>pitch_yaw_roll_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128) -&gt; (pitch, yaw, roll: f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#pitch_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>pitch_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128) -&gt; (f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#yaw_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>yaw_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128) -&gt; (f32)</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/math/linalg/#roll_from_quaternion" 
						class="external-link" 
						target="_blank" >
                        <code>roll_from_quaternion</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>(q: quaternion128) -&gt; (f32)</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="complex" >
    Complex
</h3>
<h5
	id="type" >
    type
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#complex32" 
				class="external-link" 
				target="_blank" >
                complex
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">complex32 complex64 complex128
</code></pre>
<h5
	id="interpretation" >
    Interpretation
</h5>
<ul>
	<li>
		<p>
            &quot;It's a bit odd that the value is an operation. It's just a very 
			<em>
                mathematical
			</em>
            &nbsp;approach to it. It's basically how complex numbers are written mathematically, e.g., 
            <code>1 + 2i</code>
            .&quot;
		</p>
	</li>
</ul>
<h5
	id="procedures" >
    Procedures
</h5>
<ul>
	<li>
		<p>
			<strong>
                X from complex
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#real" 
						class="external-link" 
						target="_blank" >
                        <code>real</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#imag" 
						class="external-link" 
						target="_blank" >
                        <code>imag</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#conj" 
						class="external-link" 
						target="_blank" >
                        <code>conj</code>
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="strings" >
    Strings
</h2>
<h3
	id="strings" >
    Strings
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#string-type" 
				class="external-link" 
				target="_blank" >
                Strings
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="types" >
    Types
</h5>
<ul>
	<li>
		<p>
            <code>string</code>
		</p>
		<ul>
			<li>
				<p>
                    Used as default when doing type inference: 
                    <code>my_string := "hello"</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Stores the pointer to the data and the length of the string.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>cstring</code>
		</p>
		<ul>
			<li>
				<p>
                    &quot;A little longer, with a 0 at the end&quot;.
				</p>
			</li>
			<li>
				<p>
                    Is used to interface with foreign libraries written in/for C that use zero-terminated strings.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="syntax" >
    Syntax
</h5>
<pre><code class="language-odin" data-lang="odin">"string"
</code></pre>
<pre><code class="language-odin" data-lang="odin">'rune'
</code></pre>
<pre><code class="language-odin" data-lang="odin">`multiline_string`
</code></pre>
<h3
	id="manipulation" >
    Manipulation
</h3>
<pre><code class="language-odin" data-lang="odin">import "core:strings"
</code></pre>
<ul>
	<li>
		<p>
            If there is allocation, 
            <code>delete</code>
            &nbsp;is used.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Compare
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> value: int = strings.compare("hello", "hi")
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Contains
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> flag: bool = strings.contains("hello", "hi")&nbsp;&nbsp;// "hi" is in "hello"
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Concatenate
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> my_string, err := strings.concatenate({"hello", "hi"})
 defer delete(my_string)
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Upper
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> my_string := strings.to_upper("hello")
 defer delete(my_string)
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Lower
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> my_string := strings.to_lower("hello")
 defer delete(my_string)
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Cut
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;substring&quot;, &quot;make the string smaller&quot;.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> my_string, err := strings.cut("hello", 3, 5)&nbsp;&nbsp;// (string, first_idx, last_idx)
 defer delete(my_string)
</code></pre>
	</li>
</ul>
<h3
	id="slicing" >
    Slicing
</h3>
<ul>
	<li>
		<p>
            Uses array slicing property.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">my_str := "little cat"
sub_str := my_str[7:]
&nbsp;&nbsp;&nbsp;&nbsp;// `cat`
</code></pre>
<ul>
	<li>
		<p>
            Depending on the char, it is useful to use the 
            <code>"core:string"</code>
            &nbsp;library to avoid the issues below.
		</p>
	</li>
	<li>
		<p>
            In the example below, ideally use &quot;runes&quot; instead of &quot;bytes&quot;, since Japanese chars use 3 bytes per rune.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">my_str := "imagine something Japanese"
sub_str := my_str[1:]
&nbsp;&nbsp;&nbsp;&nbsp;// issues
</code></pre>
<h3
	id="prints" >
    Prints
</h3>
<h5
	id="formatting" >
    Formatting
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#aprint" 
				class="external-link" 
				target="_blank" >
                <code>aprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>aprintln</code>
				</p>
			</li>
			<li>
				<p>
                    <code>aprintf</code>
				</p>
			</li>
			<li>
				<p>
                    <code>aprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>any</code>
                    &nbsp;and returns 
                    <code>string</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#tprint" 
				class="external-link" 
				target="_blank" >
                <code>tprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>tprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>tprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>tprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>any</code>
                    &nbsp;and returns 
                    <code>int</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Prints
					</em>
                    &nbsp;to 
                    <code>os.stdout</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Allocates with the 
                    <code>temp_allocator</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#bprint" 
				class="external-link" 
				target="_blank" >
                <code>bprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>bprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>bprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>bprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>[]u8</code>
                    &nbsp;and returns 
                    <code>string</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#sbprint" 
				class="external-link" 
				target="_blank" >
                <code>sbprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>sbprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>sbprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>sbprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>^strings.Builder</code>
                    &nbsp;and returns 
                    <code>string</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#caprint" 
				class="external-link" 
				target="_blank" >
                <code>caprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>caprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>caprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>caprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>any</code>
                    &nbsp;and returns 
                    <code>cstring</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#ctprint" 
				class="external-link" 
				target="_blank" >
                <code>ctprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>ctprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>ctprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>ctprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>any</code>
                    &nbsp;and returns 
                    <code>cstring</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Allocates with the 
                    <code>temp_allocator</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="writes-to-terminal-os-std" >
    Writes to Terminal (os.std)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#print" 
				class="external-link" 
				target="_blank" >
                <code>print</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>println</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>printf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>printfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>any</code>
                    &nbsp;and returns 
                    <code>int</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Prints
					</em>
                    &nbsp;to 
                    <code>os.stdout</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#eprint" 
				class="external-link" 
				target="_blank" >
                <code>eprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>eprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>eprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>eprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>any</code>
                    &nbsp;and returns 
                    <code>int</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Prints
					</em>
                    &nbsp;to 
                    <code>os.stderr</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#panicf" 
				class="external-link" 
				target="_blank" >
                <code>panicf</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Takes 
                    <code>any</code>
                    &nbsp;and returns 
                    <code>void</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Panics
					</em>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="write-to-file" >
    Write to File
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#fprint" 
				class="external-link" 
				target="_blank" >
                <code>fprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>fprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>fprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>fprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>fprint_type</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>fprint_typeid</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>os.Handle</code>
                    &nbsp;and returns 
                    <code>int</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Writes
					</em>
                    &nbsp;to file.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="writes-to-io-stream" >
    Writes to io.Stream
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/fmt/#wprint" 
				class="external-link" 
				target="_blank" >
                <code>wprint</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>wprintln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>wprintf</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>wprintfln</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>wprint_type</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>wprint_typeid</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes 
                    <code>io.Stream</code>
                    &nbsp;and returns 
                    <code>int</code>
                    &nbsp;(bytes written).
				</p>
			</li>
			<li>
				<p>
					<em>
                        Writes
					</em>
                    &nbsp;to stream.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="formatting" >
    Formatting
</h3>
<h5
	id="pretty-formating" >
    Pretty Formating
</h5>
<ul>
	<li>
		<p>
			<strong>
                Opt 1
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">&nbsp;&nbsp;fmt.printf(
&nbsp;&nbsp;&nbsp;&nbsp; "Ping %d:\n" +
&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;Client RTT: %vms (self-measured)\n" +
&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;Server RTT: %vms (server's view of us)\n",
&nbsp;&nbsp;&nbsp;&nbsp; i,
&nbsp;&nbsp;&nbsp;&nbsp; time.duration_milliseconds(client_rtt),
&nbsp;&nbsp;&nbsp;&nbsp; time.duration_milliseconds(pong.client_ping), // Server's estimate
 )
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Opt 2
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/text/table/" 
						class="external-link" 
						target="_blank" >
                        core:text/table
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Examples:
						</p>
					</li>
				</ul>
<pre><code class="language-txt" data-lang="txt"> A_LONG_ENUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 54, // A comment about A_LONG_ENUM
 AN_EVEN_LONGER_ENUM = 1,&nbsp;&nbsp;// A comment about AN_EVEN_LONGER_ENUM
</code></pre>
<pre><code class="language-txt" data-lang="txt"> +-----------------------------------------------+
 |&nbsp;&nbsp;This is a table caption and it is very long&nbsp;&nbsp;|
 +------------------+-----------------+----------+
 | AAAAAAAAA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C |
 +------------------+-----------------+----------+
 | 123&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| foo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
 | 000000005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 6.283185&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bbb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
 +------------------+-----------------+----------+
 
 |&nbsp;&nbsp;&nbsp;&nbsp;AAAAAAAAA&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp; |
 |:-----------------|:---------------:|---------:|
 | 123&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| foo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
 | 000000005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 6.283185&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
 | a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bbb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tags-in-structs" >
    Tags in Structs
</h5>
<pre><code class="language-odin" data-lang="odin">Foo :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;a: [L]u8 `fmt:"s"`, // whole buffer is a string
&nbsp;&nbsp;&nbsp;&nbsp;b: [N]u8 `fmt:"s,0"`, // 0 terminated string
&nbsp;&nbsp;&nbsp;&nbsp;c: [M]u8 `fmt:"q,n"`, // string with length determined by n, and use %q rather than %s
&nbsp;&nbsp;&nbsp;&nbsp;n: int `fmt:"-"`, // ignore this from formatting
}
</code></pre>
<h5
	id="custom-formatters" >
    Custom formatters
</h5>
<ul>
	<li>
		<p>
            See 
            <code>fmt/example.odin</code>
            .
		</p>
	</li>
</ul>
<h5
	id="escaping-symbols" >
    Escaping symbols
</h5>
<ul>
	<li>
		<p>
            <code>%%</code>
		</p>
		<ul>
			<li>
				<p>
                    literal percent sign
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>{{</code>
		</p>
		<ul>
			<li>
				<p>
                    literal open brace
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>}}</code>
		</p>
		<ul>
			<li>
				<p>
                    literal close brace
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="formatting-verbs" >
    Formatting Verbs
</h5>
<ul>
	<li>
		<p>
            Using a verb in the wrong place does nothing, it just prints as if no formatting exists.
		</p>
		<ul>
			<li>
				<p>
                    This is very strict. If itâ€™s not in General, or the variable type, it wonâ€™t work.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                General
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%v</code>
                    &nbsp;/ 
                    <code>{:v}</code>
				</p>
				<ul>
					<li>
						<p>
                            The value in default format
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> Tilesets: [Tileset{uid = 21, texture = Texture{id = 5, width = 384, height = 160, mipmaps = 1, format = "UNCOMPRESSED_R8G8B8A8"}, tilesize = [32, 32], pivot = [0, 0]}]
</code></pre>
			</li>
			<li>
				<p>
                    <code>%w</code>
				</p>
				<ul>
					<li>
						<p>
                            An Odin-syntax representation of the value
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> Tilesets: {Tileset{uid = 21, texture = Texture{id = 5, width = 384, height = 160, mipmaps = 1, format = PixelFormat.UNCOMPRESSED_R8G8B8A8}, tilesize = {32, 32}, pivot = {0, 0}}}
</code></pre>
			</li>
			<li>
				<p>
                    <code>%T</code>
				</p>
				<ul>
					<li>
						<p>
                            An Odin-syntax representation of the 
							<strong>
                                type
							</strong>
                            &nbsp;of the value
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> Tilesets: [dynamic]Tileset
</code></pre>
			</li>
			<li>
				<p>
                    <code>%#v</code>
				</p>
				<ul>
					<li>
						<p>
                            An expanded format of %v with newlines and indentation
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> Tilesets: [
&nbsp;&nbsp;&nbsp;&nbsp; Tileset{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid = 21,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture = Texture{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id = 5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = 384,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = 160,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mipmaps = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format = "UNCOMPRESSED_R8G8B8A8",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tilesize = [
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pivot = [
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ],
&nbsp;&nbsp;&nbsp;&nbsp; },
 ]
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Boolean
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%t</code>
				</p>
				<ul>
					<li>
						<p>
                            The word &quot;true&quot; or &quot;false&quot;
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Integer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%b</code>
				</p>
				<ul>
					<li>
						<p>
                            base 2
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%c</code>
                    &nbsp;/ 
                    <code>%r</code>
				</p>
				<ul>
					<li>
						<p>
                            the character represented by the corresponding Unicode code point
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%o</code>
				</p>
				<ul>
					<li>
						<p>
                            base 8
						</p>
					</li>
					<li>
						<p>
                            Bytes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%d</code>
                    &nbsp;/ 
                    <code>%i</code>
				</p>
				<ul>
					<li>
						<p>
                            base 10
						</p>
					</li>
					<li>
						<p>
                            Decimal
						</p>
					</li>
					<li>
						<p>
							<em>
                                Default for
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <code>[]byte</code>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%z</code>
				</p>
				<ul>
					<li>
						<p>
                            base 12
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%x</code>
				</p>
				<ul>
					<li>
						<p>
                            base 16, lower-case a-f
						</p>
					</li>
					<li>
						<p>
                            Hexadecimal
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%X</code>
				</p>
				<ul>
					<li>
						<p>
                            base 16, upper-case A-F
						</p>
					</li>
					<li>
						<p>
                            Hexadecimal
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%U</code>
				</p>
				<ul>
					<li>
						<p>
                            Unicode format: U+1234; same as &quot;U+%04X&quot;
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Floating-point
			</strong>
            , 
			<strong>
                complex numbers
			</strong>
            ,&nbsp;&nbsp;
			<strong>
                quaternions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%e</code>
				</p>
				<ul>
					<li>
						<p>
                            scientific notation, e.g. -1.23456e+78
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%E</code>
				</p>
				<ul>
					<li>
						<p>
                            scientific notation, e.g. -1.23456E+78
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%f</code>
                    &nbsp;/ 
                    <code>%F</code>
				</p>
				<ul>
					<li>
						<p>
                            decimal point, no exponent, e.g. 123.456
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%g</code>
                    &nbsp;/ 
                    <code>%G</code>
				</p>
				<ul>
					<li>
						<p>
                            synonym for %f with default max precision
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%h</code>
				</p>
				<ul>
					<li>
						<p>
                            hexadecimal (lower-case) with 0h prefix (0h01234abcd)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%H</code>
				</p>
				<ul>
					<li>
						<p>
                            hexadecimal (upper-case) with 0H prefix (0H01234ABCD)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%m</code>
				</p>
				<ul>
					<li>
						<p>
                            number of bytes in best unit, e.g. 123.45mib
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%M</code>
				</p>
				<ul>
					<li>
						<p>
                            number of bytes in best unit, e.g. 123.45MiB
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Width and Precision
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Width
						</p>
						<ul>
							<li>
								<p>
                                    optional decimal number after '%'.
								</p>
							</li>
							<li>
								<p>
                                    Default: enough to represent value.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Precision
						</p>
						<ul>
							<li>
								<p>
                                    after width, period + decimal number.
								</p>
							</li>
							<li>
								<p>
                                    No period: default precision.
								</p>
							</li>
							<li>
								<p>
                                    Period alone: precision 0.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Measured in Unicode code points (runes).
						</p>
					</li>
					<li>
						<p>
                            n.b. C's printf uses bytes.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Examples
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <code>%f</code>
								</p>
								<ul>
									<li>
										<p>
                                            default width, default precision
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>%8f</code>
								</p>
								<ul>
									<li>
										<p>
                                            width 8, default precision
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>%.2f</code>
								</p>
								<ul>
									<li>
										<p>
                                            default width, precision 2
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>%8.3f</code>
								</p>
								<ul>
									<li>
										<p>
                                            width 8, precision 3
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>%8.f</code>
								</p>
								<ul>
									<li>
										<p>
                                            width 8, precision 0
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                String and slice of bytes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%s</code>
				</p>
				<ul>
					<li>
						<p>
                            uninterpreted bytes of string/slice
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%q</code>
				</p>
				<ul>
					<li>
						<p>
                            double-quoted string safely escaped with Odin syntax
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%x</code>
				</p>
				<ul>
					<li>
						<p>
                            base 16, lower-case, two chars per byte
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%X</code>
				</p>
				<ul>
					<li>
						<p>
                            base 16, upper-case, two chars per byte
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Slice and dynamic array
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%p</code>
				</p>
				<ul>
					<li>
						<p>
                            address of 0th element in base 16 (upper-case), with 0x
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Pointer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%p</code>
				</p>
				<ul>
					<li>
						<p>
                            base 16, with 0x
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%b</code>
                    , 
                    <code>%d</code>
                    , 
                    <code>%o</code>
                    , 
                    <code>%z,</code>
                    &nbsp;
                    <code>%x</code>
                    , 
                    <code>%X</code>
				</p>
				<ul>
					<li>
						<p>
                            also work with pointers as integers
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Enums
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>%s</code>
				</p>
				<ul>
					<li>
						<p>
                            name of enum field
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%i</code>
                    , 
                    <code>%d</code>
                    , 
                    <code>%f</code>
				</p>
				<ul>
					<li>
						<p>
                            also work as number
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="flags" >
    Flags
</h5>
<ul>
	<li>
		<p>
            Ignored by verbs that don't expect them.
		</p>
	</li>
	<li>
		<p>
            <code>+</code>
		</p>
		<ul>
			<li>
				<p>
                    always print a sign for numeric values
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>-</code>
		</p>
		<ul>
			<li>
				<p>
                    pad spaces on right (left-justify)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>#</code>
		</p>
		<ul>
			<li>
				<p>
                    Gives an alternative format.
				</p>
			</li>
			<li>
				<p>
                    <code>%#b</code>
				</p>
				<ul>
					<li>
						<p>
                            add leading 0b for binary
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%#o</code>
				</p>
				<ul>
					<li>
						<p>
                            add leading 0o for octal
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%#z</code>
				</p>
				<ul>
					<li>
						<p>
                            add leading 0z for dozenal
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%#x</code>
                    &nbsp;/ 
                    <code>%#X</code>
				</p>
				<ul>
					<li>
						<p>
                            add leading 0x or 0X for hexadecimal
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%#p</code>
				</p>
				<ul>
					<li>
						<p>
                            remove leading 0x for %p
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>%#m</code>
                    &nbsp;/ 
                    <code>%#M</code>
				</p>
				<ul>
					<li>
						<p>
                            add a space between bytes and the unit of measurement
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>(space)</code>
		</p>
		<ul>
			<li>
				<p>
                    leave a space for elided sign in numbers (% d)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>0</code>
		</p>
		<ul>
			<li>
				<p>
                    Pad with leading zeros rather than spaces
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="rune" >
    Rune
</h2>
<ul>
	<li>
		<p>
            A 
            <code>rune</code>
            &nbsp;is just a character in a string.
		</p>
	</li>
	<li>
		<p>
            Represents a Unicode code point.
		</p>
	</li>
	<li>
		<p>
            Signed 32 bit integer; 
            <code>distinct i32</code>
            .
		</p>
	</li>
	<li>
		<p>
            The default value is 
            <code>0</code>
            , as it's just an 
            <code>i32</code>
            .
		</p>
	</li>
	<li>
		<p>
            They just work like numbers in most cases; well they are numbers.
		</p>
		<ul>
			<li>
				<p>
                    For example, to lower a rune you can 
                    <code>unicode.to_lower(r)</code>
                    , but you can also just 
                    <code>r - 32</code>
                    &nbsp;if you're only dealing with ASCII.
				</p>
				<ul>
					<li>
						<p>
                            Supposedly.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Rune values are comparable and ordered.
		</p>
	</li>
</ul>
<h3
	id="untyped-runes-rune-literals" >
    Untyped Runes / Rune Literals
</h3>
<ul>
	<li>
		<p>
            Can be used to define a 
            <code>rune</code>
            , 
            <code>u8</code>
            , 
            <code>u16</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">foo&nbsp;&nbsp;&nbsp;&nbsp;:= 'x'
// ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^
// rune&nbsp;&nbsp;&nbsp;&nbsp;untyped rune


foo:&nbsp;&nbsp;u8 = 'x'
// ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
// u8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; untyped rune
// This is valid for UTF-8 runes, for UTF-16 use u16.


foo: u16 = 'x'
// ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
// u16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; untyped rune
</code></pre>
<pre><code class="language-odin" data-lang="odin">if str[i] == '\n'
// is using a rune literal as a `u8`
</code></pre>
<h3
	id="other-usages" >
    Other usages
</h3>
<pre><code class="language-odin" data-lang="odin">skip_whitespace :: proc(t: ^Tokenizer) {
&nbsp;&nbsp;&nbsp;&nbsp;for {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch t.ch {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ' ', '\t', '\r', '\n':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;advance_rune(t)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h2
	id="maps-hash-maps" >
    Maps (Hash Maps)
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#maps" 
				class="external-link" 
				target="_blank" >
                Maps
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Zero value of a map is 
            <code>nil</code>
            . A 
            <code>nil</code>
            &nbsp;map has no keys.
		</p>
	</li>
</ul>
<h3
	id="memory" >
    Memory
</h3>
<ul>
	<li>
		<p>
			<strong>
                Always a copy
			</strong>
		</p>
<pre><code class="language-odin" data-lang="odin"> m: map[string]int = ... 
 m2 := m 
 // points to the same data as m
 
 m2["foo"] = 123 
 // m is not aware of the new key that was added--it's in the data, but m has the wrong length 
 // worse, this could cause the map to reallocate, in which case m would point to freed memory 
 
 delete(m2) 
 // m is now definitely invalid
</code></pre>
	</li>
	<li>
		<p>
            Are you trying to remove the entire map entry? if so: 
			<a
				href="https://pkg.odin-lang.org/base/builtin/#delete_key" 
				class="external-link" 
				target="_blank" >
                https://pkg.odin-lang.org/base/builtin/#delete_key
			</a>
            &nbsp;and then 
            <code>delete</code>
            &nbsp;the 
            <code>deleted_key</code>
            &nbsp;(and 
            <code>deleted_entry</code>
            &nbsp;if you allocated it) (edited)
		</p>
	</li>
	<li>
		<p>
            Be consistent with your keys in the map--like I said, clone them all (and then you know you should delete them all when you delete the map) or don't clone any (and then you know not to delete any, but you also need to be careful with what you insert).
		</p>
	</li>
	<li>
		<p>
            <code>string</code>
            s just happen to be particularly annoying to deal with 
			<em>
                because
			</em>
            &nbsp;they're pointers
		</p>
	</li>
	<li>
		<p>
			<strong>
                Allocator requirements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Ginger Bill:
				</p>
				<ul>
					<li>
						<p>
                            So the 
                            <code>map</code>
                            &nbsp;type in Odin REQUIRES an allocator that can do 64-byte aligned allocations.
						</p>
					</li>
					<li>
						<p>
                            What you'll need to do is change the alignment when initializing the dynamic arena: 
                            <code>dynamic_arena_init(&arena, alignment=64)</code>
						</p>
					</li>
					<li>
						<p>
                            This does mean every allocation is a bit wasteful, unfortunately.
						</p>
					</li>
					<li>
						<p>
                            But that's the problem of custom allocators and trying to treat them &quot;generally&quot; any way.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="create" >
    Create
</h3>
<ul>
	<li>
		<p>
            Using 
            <code>make</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Uses the current 
                    <code>context</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> m := make(map[string]int)
</code></pre>
	</li>
	<li>
		<p>
            Map literals:
		</p>
<pre><code class="language-odin" data-lang="odin"> m := map[string]int{
&nbsp;&nbsp;&nbsp;&nbsp; "Bob" = 2,
&nbsp;&nbsp;&nbsp;&nbsp; "Chloe" = 5,
 }
</code></pre>
	</li>
</ul>
<h3
	id="delete" >
    Delete
</h3>
<ul>
	<li>
		<p>
            Using 
            <code>delete</code>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> delete(m)
</code></pre>
	</li>
</ul>
<h3
	id="insert-update" >
    Insert / update
</h3>
<pre><code class="language-odin" data-lang="odin">m[key] = elem
</code></pre>
<h3
	id="access" >
    Access
</h3>
<pre><code class="language-odin" data-lang="odin">elem = m[key]
</code></pre>
<ul>
	<li>
		<p>
            If an element for a key does not exist, the 
			<strong>
                zero
			</strong>
            &nbsp;value of the element will be returned.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">elem, ok := m[key] // `ok` is true if the element for that key exists
&nbsp;&nbsp;&nbsp;&nbsp;// â€œcomma ok idiomâ€

//or 

ok := key in m&nbsp;&nbsp;&nbsp;&nbsp; // `ok` is true if the element for that key exists
</code></pre>
<h3
	id="remove-element" >
    Remove element
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#delete_key" 
				class="external-link" 
				target="_blank" >
                <code>delete_key</code>
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">delete_key :: proc(m: ^$T/map[$K]$V, key: $K) -&gt; (deleted_key: $K, deleted_value: $V) {â€¦}
</code></pre>
<h3
	id="modify" >
    Modify
</h3>
<pre><code class="language-odin" data-lang="odin">Test :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;x: int,
&nbsp;&nbsp;&nbsp;&nbsp;y: int,
}

m := map[string]Test{
&nbsp;&nbsp;&nbsp;&nbsp;"Bob" = { 0, 0 },
&nbsp;&nbsp;&nbsp;&nbsp;"Chloe" = { 1, 1 },
}

// Method 1
value, ok := &m["Bob"]
if ok {
&nbsp;&nbsp;&nbsp;&nbsp;value^ = { 2, 2 }
}

// Method 2
m["Bob"] = { 3, 3 }

// Method 3 (Forbidden)
m["Chloe"].x = 0
</code></pre>
<h3
	id="quotcompound-literalsquot" >
    &quot;Compound Literals&quot;
</h3>
<ul>
	<li>
		<p>
            To enable compound literals for 
            <code>map</code>
            s, 
            <code>#+feature dynamic-literals</code>
            &nbsp;must be enabled per file.
		</p>
	</li>
	<li>
		<p>
            This is because dynamic literals will use the current 
            <code>context.allocator</code>
            &nbsp;and thus implicitly allocate.
		</p>
	</li>
	<li>
		<p>
            The opt-in feature exists so that Odin does not implicitly allocate by default and give the user any surprises.
		</p>
	</li>
</ul>
<h3
	id="container-calls" >
    Container Calls
</h3>
<ul>
	<li>
		<p>
            The built-in map also supports all the standard container calls that can be found with the 
			<a
				href="https://odin-lang.org/docs/overview/#dynamic-arrays" 
				class="external-link" 
				target="_blank" >
                dynamic array
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>len(some_map)</code>
		</p>
		<ul>
			<li>
				<p>
                    Returns the number of slots used
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>clear(&some_map)</code>
		</p>
		<ul>
			<li>
				<p>
                    Clears the entire map - dynamically allocated content needs to be freed manually
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>cap(some_map)</code>
		</p>
		<ul>
			<li>
				<p>
                    Returns the capacity of the map - the map will reallocate when exceeded
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>shrink(&some_map)</code>
		</p>
		<ul>
			<li>
				<p>
                    Shrinks the capacity down to the current length
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>reserve(&some_map, capacity)</code>
		</p>
		<ul>
			<li>
				<p>
                    Reserves the requested number of elements
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="struct" >
    Struct
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#structs" 
				class="external-link" 
				target="_blank" >
                Structs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#record-memory-layout" 
				class="external-link" 
				target="_blank" >
                Record memory layout
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Default values are not allowed.
		</p>
	</li>
</ul>
<h3
	id="parametric-polymorphism-parapoly" >
    Parametric Polymorphism (Parapoly)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#data-types-using-explicit-parametric-polymorphism-parapoly" 
				class="external-link" 
				target="_blank" >
                Structs with Parapoly
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Table_Slot :: struct($Key, $Value: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp;occupied: bool,
&nbsp;&nbsp;&nbsp;&nbsp;hash:&nbsp;&nbsp;&nbsp;&nbsp;u32,
&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;&nbsp;&nbsp;&nbsp; Key,
&nbsp;&nbsp;&nbsp;&nbsp;value:&nbsp;&nbsp; Value,
}
slot: Table_Slot(string, int)
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Odin-handle-map with 
                        <code>$HT: typeid</code>
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    I have a question about the 
									<a
										href="https://github.com/karl-zylinski/odin-handle-map" 
										class="external-link" 
										target="_blank" >
                                        odin-handle-map
									</a>
                                    :
								</p>
							</li>
						</ul>
<pre><code class="language-odin" data-lang="odin"> Handle_Map :: struct($T: typeid, $HT: typeid, $N: int) {
&nbsp;&nbsp;&nbsp;&nbsp; // Each item must have a field `handle` of type `HT`.
&nbsp;&nbsp;&nbsp;&nbsp; items: [N]T,
&nbsp;&nbsp;&nbsp;&nbsp; num_items: u32,
&nbsp;&nbsp;&nbsp;&nbsp; next_unused: u32,
&nbsp;&nbsp;&nbsp;&nbsp; unused_items: [N]u32,
&nbsp;&nbsp;&nbsp;&nbsp; num_unused: u32,
 }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
						<ul>
							<li>
								<p>
                                    I don't understand the use of 
                                    <code>$HT: typeid</code>
                                    , the 
                                    <code>HT</code>
                                    &nbsp;is not used inside this struct, so why is it there? Does it have the same influence from outside the struct?
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Thag:
						</p>
						<ul>
							<li>
								<p>
                                    It's because it allows other procs to then infer the handle type based on the type of the map
								</p>
							</li>
							<li>
								<p>
                                    i.e. 
                                    <code>remove :: proc(m: ^Handle_Map($T, $HT), h: HT)</code>
								</p>
							</li>
							<li>
								<p>
                                    notice how 
                                    <code>HT</code>
                                    &nbsp;can be known from the type specified in the handle map definition
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    so it's just type information for the handle it holds? I mean, if I were to make a 
                                    <code>distinct</code>
                                    &nbsp;handle?
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Thag:
						</p>
						<ul>
							<li>
								<p>
                                    you're right, it's type info that is then used by other procs at compile time.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Chamberlain:
						</p>
						<ul>
							<li>
								<p>
                                    I've done something similar with my Vulkan abstraction, haha. Good to see someone else used poly this way too.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="subtype-polymorphism-keyword-codeusing-code" >
    Subtype Polymorphism (Keyword 
    <code>using</code>
    )
</h3>
<ul>
	<li>
		<p>
            When using 
            <code>using</code>
            &nbsp;on 
			<strong>
                structs
			</strong>
            , this gives subtyping (inheritance).
		</p>
	</li>
	<li>
		<p>
            &quot;It's like 
            <code>embedding</code>
            &nbsp;in Go, but a little more explicit&quot;.
		</p>
	</li>
	<li>
		<p>
            Technically it is possible to &quot;force&quot; OOP via the use of &quot;function tables&quot; (&quot;V tables&quot;, virtual tables) and using 
            <code>using</code>
            &nbsp;to simulate inheritance:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=AuhIsaS5wRk" 
						class="external-link" 
						target="_blank" >
                        Explanatory video
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            &quot;just function pointers with a fancy name&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Using 
            <code>using</code>
            &nbsp;in other places:
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        In procedures
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Ginger Bill: &quot;It was a mistake&quot;.
						</p>
					</li>
					<li>
						<p>
                            Teej: &quot;I can see this being useful when using raylib a lot inside a function and I just want to drop the 
                            <code>rl.</code>
                            &quot;.
						</p>
					</li>
					<li>
						<p>
                            Ginger Bill: &quot;I still think that's bad, don't use it. It's just 3 characters, it's not worth it&quot;.
						</p>
					</li>
					<li>
						<p>
                            Ginger Bill: &quot;I regret adding this as a feature, because it only leads to unreadable spaghetti code. Try not to use it, this is a mistake.&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<strong>
                        In file scopes
					</strong>
                    </s>:
				</p>
				<ul>
					<li>
						<p>
                            Not possible.
						</p>
					</li>
					<li>
						<p>
                            Ginger Bill: &quot;I disallowed using 
                            <code>using</code>
                            &nbsp;at the file scope, because it makes it harder to understand where the code is coming from&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="memory-layout" >
    Memory Layout
</h3>
<h5
	id="packed" >
    #packed
</h5>
<ul>
	<li>
		<p>
            Removes padding between fields that is normally inserted to ensure all fields meet their typeâ€™s alignment requirements.
		</p>
	</li>
	<li>
		<p>
            The fields remain in source order.
		</p>
	</li>
	<li>
		<p>
            Useful where the structure is unlikely to be correctly aligned (the insertion rules assume it 
			<strong>
				<em>
                    is
				</em>
			</strong>
            ), or if space savings are more important than access speed.
		</p>
	</li>
	<li>
		<p>
            Accessing a field in a packed struct may require copying the field out into a temporary location, or using a machine instruction that doesnâ€™t assume the pointer is correctly aligned, to be performant or avoid crashes on some systems. (See 
            <code>intrinsics.unaligned_load</code>
            .)
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">struct #packed {...} 
</code></pre>
<h5
	id="alignedn" >
    #aligned(N)
</h5>
<ul>
	<li>
		<p>
            Specifies that the struct will be aligned to 
            <code>N</code>
            &nbsp;bytes.
		</p>
	</li>
	<li>
		<p>
            This applies to the struct itself, not its fields.
		</p>
	</li>
	<li>
		<p>
            Fields remain in source order.
		</p>
	</li>
	<li>
		<p>
            Can also be applied to a 
			<em>
                union
			</em>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">struct #align(4) {...} 
</code></pre>
<h5
	id="raw_union" >
    #raw_union
</h5>
<ul>
	<li>
		<p>
            Structâ€™s fields will share the same memory space, similar to 
            <code>union</code>
            s in C.
		</p>
	</li>
	<li>
		<p>
            All fields share the same offset (
            <code>0</code>
            ).
		</p>
	</li>
	<li>
		<p>
            Useful especially for bindings.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">struct #raw_union {...} 
</code></pre>
<h5
	id="equivalence" >
    Equivalence
</h5>
<ul>
	<li>
		<p>
			<em>
                Arrays
			</em>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> Vec3 :: [3]f32 
 Vec3 :: struct { 
&nbsp;&nbsp;&nbsp;&nbsp; x: f32, 
&nbsp;&nbsp;&nbsp;&nbsp; y: f32, 
&nbsp;&nbsp;&nbsp;&nbsp; z: f32,
 }
</code></pre>
	</li>
	<li>
		<p>
			<em>
                Matrices
			</em>
		</p>
<pre><code class="language-odin" data-lang="odin"> Matrix4x4 :: #row_major matrix[4, 4]f32
 Matrix4x4 :: struct {
&nbsp;&nbsp;&nbsp;&nbsp; m11, m12, m13, m14: f32,
&nbsp;&nbsp;&nbsp;&nbsp; m21, m22, m23, m24: f32,
&nbsp;&nbsp;&nbsp;&nbsp; m31, m32, m33, m34: f32,
&nbsp;&nbsp;&nbsp;&nbsp; m41, m42, m43, m44: f32,
 }
</code></pre>
		<ul>
			<li>
				<p>
					<a
						href="https://odin-lang.org/docs/overview/#technical-information-of-matrix-types" 
						class="external-link" 
						target="_blank" >
                        <code>#row_major</code>
                        &nbsp;explained
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="reflect" >
    Reflect
</h3>
<h5
	id="struct" >
    Struct
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/intrinsics/#type_is_struct" 
				class="external-link" 
				target="_blank" >
                <code>intrinsics.type_is_struct(typeid) -&gt; bool</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#is_struct" 
				class="external-link" 
				target="_blank" >
                <code>reflect.is_struct(Type_Info) -&gt; bool</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/intrinsics/#type_is_struct" 
				class="external-link" 
				target="_blank" >
                <code>intrinsics.type_is_subtype_of(typeid, typeid) -&gt; bool</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/intrinsics/#type_struct_has_implicit_padding" 
				class="external-link" 
				target="_blank" >
                <code>intrinsics.type_struct_has_implicit_padding(typeid) -&gt; bool</code>
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="struct-fields" >
    Struct Fields
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#Type_Info" 
				class="external-link" 
				target="_blank" >
                <code>runtime.Type_Info</code>
			</a>
            .
		</p>
<pre><code class="language-odin" data-lang="odin"> Type_Info :: struct {
&nbsp;&nbsp;&nbsp;&nbsp; size:&nbsp;&nbsp;&nbsp;&nbsp;int,
&nbsp;&nbsp;&nbsp;&nbsp; align:&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp; flags:&nbsp;&nbsp; Type_Info_Flags,
&nbsp;&nbsp;&nbsp;&nbsp; id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeid,
&nbsp;&nbsp;&nbsp;&nbsp; variant: union {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // etc
&nbsp;&nbsp;&nbsp;&nbsp; },
 }
</code></pre>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_field_types" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_field_types(typeid) -&gt; array ^Type_Info</code>
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#struct_field_names" 
				class="external-link" 
				target="_blank" >
                <code>reflect.struct_field_names(typeid) -&gt; array string</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#struct_field_offsets" 
				class="external-link" 
				target="_blank" >
                <code>reflect.struct_field_offsets(typeid) -&gt; array uintptr</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#struct_field_count" 
				class="external-link" 
				target="_blank" >
                <code>reflect.struct_field_count(typeid, method) -&gt; int</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#struct_field_value_by_name" 
				class="external-link" 
				target="_blank" >
                <code>reflect.struct_field_value_by_name(any, string, bool) -&gt; any</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#Struct_Field" 
				class="external-link" 
				target="_blank" >
                <code>reflect.Struct_Field</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Represents information of a struct field
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> Struct_Field :: struct {
&nbsp;&nbsp;&nbsp;&nbsp; name:&nbsp;&nbsp;&nbsp;&nbsp; string,
&nbsp;&nbsp;&nbsp;&nbsp; type:&nbsp;&nbsp;&nbsp;&nbsp; ^runtime.Type_Info,
&nbsp;&nbsp;&nbsp;&nbsp; tag:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Struct_Tag,
&nbsp;&nbsp;&nbsp;&nbsp; offset:&nbsp;&nbsp; uintptr, // in bytes
&nbsp;&nbsp;&nbsp;&nbsp; is_using: bool,
 }
</code></pre>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_field_at" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_field_at(typeid, int) -&gt; Struct_Field</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_fields_zipped" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_fields_zipped(typeid) -&gt; soa array Struct_Field</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Returns the fields of a struct type 
                            <code>T</code>
                            &nbsp;as an 
                            <code>#soa</code>
                            &nbsp;slice.
						</p>
					</li>
					<li>
						<p>
                            Useful for iteration.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_field_by_name" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_field_by_name(typeid, string) -&gt; Struct_Field</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_field_value" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_field_value(any, Struct_Field) -&gt; any</code>
					</a>
                    .
				</p>
<pre><code class="language-odin" data-lang="odin"> field := struct_field_value_by_name(the_struct, "field_name")
 value_by_field := struct_field_value(the_struct, field)
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://pkg.odin-lang.org/core/reflect/#Struct_Tag" 
				class="external-link" 
				target="_blank" >
                <code>reflect.Struct_Tag</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Represents the 
                    <code>string</code>
                    &nbsp;type of a struct field.
				</p>
			</li>
			<li>
				<p>
                    By convention, tags are concatenations of optionally space-separated key:&quot;value&quot; pairs. Each key is non-empty and contains no control characters other than space, quotes, and colon.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> Struct_Tag :: distinct string
</code></pre>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_field_tags" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_field_tags(typeid) -&gt; array Struct_Tag</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_tag_lookup" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_tag_lookup(Struct_Tag, string) -&gt; (string, bool)</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Returns the value associated with a key in the tag string.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/reflect/#struct_tag_get" 
						class="external-link" 
						target="_blank" >
                        <code>reflect.struct_tag_get(Struct_Tag, string) -&gt; string</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Wrapper around 
                            <code>struct_tag_lookup</code>
                            &nbsp;ignoring the 
                            <code>ok</code>
                            &nbsp;value.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="etc" >
    Etc
</h3>
<h5
	id="no_copy" >
    #no_copy
</h5>
<ul>
	<li>
		<p>
            This tag can be applied to a 
            <code>struct</code>
            &nbsp;to forbid copies. The initialization of a 
            <code>#no_copy</code>
            &nbsp;type must be implicitly zero, a constant literal, or a return value from a call expression.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Mutex :: struct #no_copy {
&nbsp;&nbsp;&nbsp;&nbsp;state: uintptr,
}

main :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;m: Mutex
&nbsp;&nbsp;&nbsp;&nbsp;v1 := m&nbsp;&nbsp;// This line will raise an error.
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;&nbsp;:= &m
&nbsp;&nbsp;&nbsp;&nbsp;v2 := p^ // So will this line.
}
</code></pre>
<h2
	id="union" >
    Union
</h2>
<h3
	id="parametric-polymorphism-parapoly" >
    Parametric Polymorphism (Parapoly)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#data-types-using-explicit-parametric-polymorphism-parapoly" 
				class="external-link" 
				target="_blank" >
                Unions with Parapoly
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Error :: enum {Foo0, Foo1, Foo2}
Param_Union :: union($T: typeid) #no_nil {T, Error}
r: Param_Union(int)
r = 123
r = Error.Foo0
</code></pre>
<h3
	id="print" >
    Print
</h3>
<ul>
	<li>
		<p>
			<strong>
                Union type
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">fmt.printfln("%T", my_union)
// or
fmt.printfln("%v", typeid_of(type_of(my_union)))
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Unwrapped Union type
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">fmt.printfln("%v", reflect.union_variant_typeid(my_union))
</code></pre>
<h3
	id="casting" >
    Casting
</h3>
<ul>
	<li>
		<p>
			<strong>
                Limitations with Pointer Casting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            how do I convert a 'pointer to a value', to a 'pointer to a union'? I'm doing 
                            <code>cast(^My_Union)value</code>
                            , where 
                            <code>value: ^$T</code>
                            , with 
                            <code>T</code>
                            &nbsp;being a generic parameter for a procedure, but I'm getting an &quot;index out of bounds&quot; error while trying to cast a 
                            <code>[2]f32</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Blob:
				</p>
				<ul>
					<li>
						<p>
                            you can't, unions are 
                            <code>&lt;data&gt;&lt;tag&gt;</code>
                            . meaning they're bigger than their types. the tag is just an index into an array in the RTTI.
						</p>
					</li>
					<li>
						<p>
                            except for unions with only a single pointer type 
                            <code>union{^T}</code>
                            &nbsp;where the tag is dropped &amp; the nil check just checks if the pointer is nil.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="type-check" >
    Type check
</h3>
<h6
	id="memory" >
    Memory
</h6>
<ul>
	<li>
		<p>
            Unwrapping the union does not change the value stored in memory.
		</p>
	</li>
	<li>
		<p>
            You are just checking that itâ€™s the right type and getting a pointer to it.
		</p>
	</li>
	<li>
		<p>
            Nothing happens in memory; you just point to a certain part.
		</p>
	</li>
	<li>
		<p>
            No implicit memory management occurs.
		</p>
	</li>
</ul>
<p>
    So, another memory related question:
    <br>
    I have this segment of a procedure that returns a 
    <code>[][]cbor.Value</code>
    . Considering that I'm creating 2 dynamic arrays inside this procedure, and using somethings from inside the first array, into the second, how should I handle the memory deletion? I'm really confused about deleting the 
    <code>packets_array</code>
    , as it's elements are used in 
    <code>packet_decoded, decode_err := cbor.decode_from_string(string(packet[:]))</code>
    , which then is appended into the 
    <code>packets_unpack := make_dynamic_array([dynamic][]cbor.Value, allocator)</code>
    . So, what sould be freed and when? Unfortunately I can't debug this in my code, as the program crashes without error messages and I know it's related to memory management in this procedure.
</p>
<h5
	id="via-codevalue-t-code" >
    Via 
    <code>value.(T)</code>
</h5>
<pre><code class="language-odin" data-lang="odin">Value :: union {
&nbsp;&nbsp;&nbsp;&nbsp;bool,
&nbsp;&nbsp;&nbsp;&nbsp;i32,
&nbsp;&nbsp;&nbsp;&nbsp;f32,
&nbsp;&nbsp;&nbsp;&nbsp;string,
}
v: Value
v = "Hellope"

// type assert that `v` is a `string` and panic otherwise.
s1 := v.(string)

// type assert but with an explicit BOOLEAN check. This will not panic.
s2, ok := v.(string)
if !ok {
&nbsp;&nbsp;&nbsp;&nbsp;// problem encountered.
}
</code></pre>
<h5
	id="via-switch-statement" >
    Via Switch Statement
</h5>
<ul>
	<li>
		<p>
            A type switch allows several type assertions in series.
		</p>
	</li>
	<li>
		<p>
            A type switch is like a regular switch, but the cases are types (not values).
		</p>
	</li>
	<li>
		<p>
            For a union, only the union's types are allowed as case types.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">value: Value = ...
switch v in value {
case string:
&nbsp;&nbsp;&nbsp;&nbsp;#assert(type_of(v) == string)

case bool:
&nbsp;&nbsp;&nbsp;&nbsp;#assert(type_of(v) == bool)

case i32, f32:
&nbsp;&nbsp;&nbsp;&nbsp;// This case allows multiple types, therefore we cannot know which type to use
&nbsp;&nbsp;&nbsp;&nbsp;// `v` remains the original union value
&nbsp;&nbsp;&nbsp;&nbsp;#assert(type_of(v) == Value)
case:
&nbsp;&nbsp;&nbsp;&nbsp;// Default case
&nbsp;&nbsp;&nbsp;&nbsp;// In this case, it is `nil`
}
</code></pre>
<h3
	id="maybe" >
    Maybe
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#maybet" 
				class="external-link" 
				target="_blank" >
                Maybe
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A union which 
			<em>
                either
			</em>
            &nbsp;returns a type 
            <code>T</code>
            &nbsp;or 
            <code>nil</code>
            . In other languages, often seen as 
            <code>Option(T)</code>
            , 
            <code>Result(T)</code>
            , etc.
		</p>
	</li>
	<li>
		<p>
            Not used much, as Odin supports multiple return values.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">halve :: proc(n: int) -&gt; Maybe(int) {
&nbsp;&nbsp;&nbsp;&nbsp;if n % 2 != 0 do return nil
&nbsp;&nbsp;&nbsp;&nbsp;return n / 2
}

half, ok := halve(2).?
if ok do fmt.println(half)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1
half, ok = halve(3).?
if !ok do fmt.println("3/2 isn't an int")

n := halve(4).? or_else 0
fmt.println(n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2
</code></pre>
<h2
	id="bit-sets" >
    Bit Sets
</h2>
<ul>
	<li>
		<p>
            <code>bit_set[_bitset_type_; _backing_type_]</code>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#bit-sets" 
				class="external-link" 
				target="_blank" >
                Bit Sets
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<pre><code class="language-odin" data-lang="odin">Direction :: enum{North, East, South, West}

Direction_Set :: bit_set[Direction]

Char_set :: bit_set['A'..='Z']

Int_Set :: bit_set[0..&lt;10] // bit_set[0..=9]

u32_set: bit_set[u32(0)..&lt;32]
&nbsp;&nbsp;&nbsp;&nbsp;// If you don't use u32(0), the range created will be `int`, even though the backing type is `u32`.
&nbsp;&nbsp;&nbsp;&nbsp;// Weird.
</code></pre>
<h5
	id="underlying-type" >
    Underlying type
</h5>
<ul>
	<li>
		<p>
            If a bit set requires a specific size, the underlying integer type can be specified:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Char_Set :: bit_set['A'..='Z'; u64]
#assert(size_of(Char_Set) == size_of(u64))
</code></pre>
<ul>
	<li>
		<p>
            The underlying type is not the same thing as the type of the bitset:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">unique_sets: bit_set[u32(0)..&lt;32]
&nbsp;&nbsp;&nbsp;&nbsp;// This is a u32 bit_set

unique_sets: bit_set[0..&lt;32; u32]
&nbsp;&nbsp;&nbsp;&nbsp;// This is an int bit_set, with u32 as backing type
&nbsp;&nbsp;&nbsp;&nbsp;// Weird.

unique_sets: bit_set[u32(0)..&lt;32; u32]
&nbsp;&nbsp;&nbsp;&nbsp;// This is a u32 bit_set, with u32 as backing type
</code></pre>
<h5
	id="evaluation" >
    Evaluation
</h5>
<ul>
	<li>
		<p>
			<strong>
                Bit Set vs Elements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>e in A</code>
                    &nbsp;- set membership (A contains element e)
				</p>
			</li>
			<li>
				<p>
                    <code>e not_in A</code>
                    &nbsp;- not set membership (A does not contain element e)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bit Set vs Bit Set
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>A + B</code>
                    &nbsp;- union of two sets (equivalent to 
                    <code>A | B</code>
                    )
				</p>
			</li>
			<li>
				<p>
                    <code>A - B</code>
                    &nbsp;- difference of two sets (A without Bâ€™s elements) (equivalent to 
                    <code>A &~ B</code>
                    )
				</p>
			</li>
			<li>
				<p>
                    <code>A & B</code>
                    &nbsp;- intersection of two sets
				</p>
			</li>
			<li>
				<p>
                    <code>A | B</code>
                    &nbsp;- union of two sets (equivalent to 
                    <code>A + B</code>
                    )
				</p>
			</li>
			<li>
				<p>
                    <code>A &~ B</code>
                    &nbsp;- difference of two sets (A without Bâ€™s elements) (equivalent to 
                    <code>A - B</code>
                    )
				</p>
			</li>
			<li>
				<p>
                    <code>A ~ B</code>
                    &nbsp;- symmetric difference (Elements that are in A and B but not both)
				</p>
			</li>
			<li>
				<p>
                    <code>A == B</code>
                    &nbsp;- set equality
				</p>
			</li>
			<li>
				<p>
                    <code>A != B</code>
                    &nbsp;- set inequality
				</p>
			</li>
			<li>
				<p>
                    <code>A &lt;= B</code>
                    &nbsp;- subset relation (A is a subset of B or equal to B)
				</p>
			</li>
			<li>
				<p>
                    <code>A &lt; B</code>
                    &nbsp;- strict subset relation (A is a proper subset of B)
				</p>
			</li>
			<li>
				<p>
                    <code>A &gt;= B</code>
                    &nbsp;- superset relation (A is a superset of B or equal to B)
				</p>
			</li>
			<li>
				<p>
                    <code>A &gt; B</code>
                    &nbsp;- strict superset relation (A is a proper superset of B)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#card" 
				class="external-link" 
				target="_blank" >
                <code>card</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>card(bit_set)</code>
                    &nbsp;returns how many 
                    <code>1</code>
                    s there are in the 
                    <code>bit_set</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Cardinality = popcount = number of 1s.
				</p>
			</li>
			<li>
				<p>
                    Ex:
				</p>
<pre><code class="language-odin" data-lang="odin"> unique_sets: bit_set[u32(0)..&lt;32; u32]
 for ubo in glsl_reflect.ubos {
&nbsp;&nbsp;&nbsp;&nbsp; unique_sets += { ubo.set }
 }
 for tex in glsl_reflect.textures {
&nbsp;&nbsp;&nbsp;&nbsp; unique_sets += { tex.set }
 }
 set_layouts = make([]Shaders_Set_Layout, card(unique_sets), allocator)
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="operations" >
    Operations
</h5>
<ul>
	<li>
		<p>
            Union of 
            <code>.WINDOW_RESIZABLE</code>
            &nbsp;and 
            <code>.WINDOW_ALWAYS_RUN</code>
            .
		</p>
<pre><code class="language-odin" data-lang="odin"> rl.SetWindowState({ .WINDOW_RESIZABLE, .WINDOW_ALWAYS_RUN })
</code></pre>
	</li>
</ul>
<h5
	id="discussions" >
    Discussions
</h5>
<ul>
	<li>
		<p>
			<strong>
                TLDR
			</strong>
            : &quot;Bitset 0 means 'activate the first bit&quot;.
		</p>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    For this bitset below, if I set 
                    <code>my_flags = {}</code>
                    , would that mean it's the same as setting 
                    <code>my_flags = { .INDIRECT_COMMAND_READ }</code>
                    ?
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> AccessFlags2 :: distinct bit_set[AccessFlag2; Flags64] // distinct u64 
 AccessFlag2 :: enum Flags64 {&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; INDIRECT_COMMAND_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0,&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; INDEX_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1,&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; VERTEX_ATTRIBUTE_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; // .. 
 }
</code></pre>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    No. 
                    <code>AccessFlags2</code>
                    &nbsp;is effectively an integer (
                    <code>Flags64</code>
                    , specifically), where its bits are used to indicate the presence of the enum values. The numeric value of the 
                    <code>enum</code>
                    &nbsp;variants correspond to which bit in that integer is used to represent them. So bit 0 (
                    <code>1 &lt;&lt; 0 == 1</code>
                    ) is used to indicate whether 
                    <code>INDIRECT_COMMAND_READ</code>
                    &nbsp;is set, bit 1 (
                    <code>1 &lt;&lt; 1 == 2</code>
                    ) is used to indicate whether 
                    <code>INDEX_READ</code>
                    &nbsp;is set, and so on. So 
                    <code>{}</code>
                    &nbsp;is an integer 
                    <code>0</code>
                    &nbsp;internally, 
                    <code>{.INDIRECT_COMMAND_READ}</code>
                    &nbsp;would be an integer 
                    <code>1</code>
                    &nbsp;internally
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    So, in my head I had this idea of a &quot;bit mask&quot;, so for example if I set it to 
                    <code>3</code>
                    , then it would mean that 
                    <code>INDEX_READ</code>
                    &nbsp;and 
                    <code>VERTEX_ATTRIBUTE_READ</code>
                    &nbsp;were active and zero, would actually be zero, with nothing active
				</p>
			</li>
			<li>
				<p>
                    Is it just a different concept? bit mask != bit set? I used bit masks before, so that's the model I have in my head
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    It's the same idea, I think you just have it shifted by 1. 
                    <code>INDIRECT_COMMAND_READ</code>
                    &nbsp;occupies a bit too (edited)
				</p>
			</li>
			<li>
				<p>
                    So in &quot;raw&quot; bit masks, it would be
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> INDIRECT_COMMAND_READ = 1 // 1 &lt;&lt; 0 (bit 0) 
 INDEX_READ = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1 &lt;&lt; 1 (bit 1) 
 VERTEX_ATTRIBUTE_READ = 4 // 1 &lt;&lt; 2 (bit 2) 
 FOURTH_ONE = 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1 &lt;&lt; 3 (bit 3) 
 FIFTH_ONE = 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1 &lt;&lt; 4 (bit 4)
</code></pre>
		<ul>
			<li>
				<p>
                    The value in the 
                    <code>AccessFlag2</code>
                    &nbsp;enum is just a bit 
					<em>
                        index
					</em>
                    , not a mask
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>bit_set</code>
                    &nbsp;handles turning it into a mask.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="arrays" >
    Arrays
</h2>
<h5
	id="alternatives" >
    Alternatives
</h5>
<ul>
	<li>
		<p>
            kit !!:
		</p>
		<ul>
			<li>
				<p>
                    &quot;you might want to consider just using a hashset, if the order isn't important and the array is relatively large&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Karl Zyliski:
		</p>
		<ul>
			<li>
				<p>
                    It's usually a sign of poor design. Better have an index or handle around and remove using index directly. Any time my code removes by finding the index by element value, then it is a code smell to me.
				</p>
			</li>
			<li>
				<p>
                    Caio: but every time the array shifts, all indexes stored would have to be updated, no? and what would you use as a handle in this case?
				</p>
			</li>
			<li>
				<p>
                    Don't remove stuff. Use a freelist.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="common-operations" >
    Common Operations
</h3>
<h5
	id="removing" >
    Removing
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#unordered_remove" 
				class="external-link" 
				target="_blank" >
                <code>unordered_remove</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Faster, but can change the order of elements.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> unordered_remove(&dyn_arr, idx)
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#ordered_remove" 
				class="external-link" 
				target="_blank" >
                <code>ordered_remove</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Doesn't change the order of elements.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> ordered_remove(&dyn_arr, idx)
</code></pre>
	</li>
</ul>
<h5
	id="info" >
    Info
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#len" 
				class="external-link" 
				target="_blank" >
                <code>len</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>len</code>
                    &nbsp;built-in procedure returns the length of 
                    <code>v</code>
                    &nbsp;according to its type:
				</p>
				<ul>
					<li>
						<p>
                            Array: the number of elements in v.
						</p>
					</li>
					<li>
						<p>
                            Pointer to (any) array: the number of elements in 
                            <code>v^</code>
                            &nbsp;(even if 
                            <code>v</code>
                            &nbsp;is 
                            <code>nil</code>
                            ).
						</p>
					</li>
					<li>
						<p>
                            Slice, dynamic array, or map: the number of elements in 
                            <code>v</code>
                            ; if 
                            <code>v</code>
                            &nbsp;is 
                            <code>nil</code>
                            , 
                            <code>len(v)</code>
                            &nbsp;is zero.
						</p>
					</li>
					<li>
						<p>
                            String: the number of bytes in 
                            <code>v</code>
						</p>
					</li>
					<li>
						<p>
                            Enumerated array: the number elements in v.
						</p>
					</li>
					<li>
						<p>
                            Enum type: the number of enumeration fields.
						</p>
					</li>
					<li>
						<p>
                            <code>#soa</code>
                            &nbsp;array: the number of elements in 
                            <code>v</code>
                            ; if 
                            <code>v</code>
                            &nbsp;is 
                            <code>nil</code>
                            , 
                            <code>len(v)</code>
                            &nbsp;is zero.
						</p>
					</li>
					<li>
						<p>
                            <code>#simd</code>
                            &nbsp;vector: the number of elements in 
                            <code>v</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    For some arguments, such as a string literal or a simple array expression, the result can be constant.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#cap" 
				class="external-link" 
				target="_blank" >
                <code>cap</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>cap</code>
                    &nbsp;built-in procedure returns the length of 
                    <code>v</code>
                    &nbsp;according to its type:
				</p>
				<ul>
					<li>
						<p>
                            Array: the number of elements in v.
						</p>
					</li>
					<li>
						<p>
                            Pointer to (any) array: the number of elements in 
                            <code>v^</code>
                            &nbsp;(even if 
                            <code>v</code>
                            &nbsp;is 
                            <code>nil</code>
                            ).
						</p>
					</li>
					<li>
						<p>
                            Dynamic array, or map: the reserved number of elements in 
                            <code>v</code>
                            ; if 
                            <code>v</code>
                            &nbsp;is 
                            <code>nil</code>
                            , 
                            <code>len(v)</code>
                            &nbsp;is zero.
						</p>
					</li>
					<li>
						<p>
                            Enum type: equal to 
                            <code>max(Enum)-min(Enum)+1</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>#soa</code>
                            &nbsp;dynamic array: the reserved number of elements in 
                            <code>v</code>
                            ; if 
                            <code>v</code>
                            &nbsp;is 
                            <code>nil</code>
                            , 
                            <code>len(v)</code>
                            &nbsp;is zero.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    For some arguments, such as a string literal or a simple array expression, the result can be constant.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="fixed-arrays-codent-code" >
    Fixed Arrays (
    <code>[n]T</code>
    )
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#fixed-arrays" 
				class="external-link" 
				target="_blank" >
                Fixed Arrays
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Similarity to structs
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Fixed arrays are equivalent to a struct with a field for each element.
				</p>
			</li>
			<li>
				<p>
                    They are just a number of values in a row in memory.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="creation-and-assigning" >
    Creation and Assigning
</h5>
<pre><code class="language-odin" data-lang="odin">some_ints: [7]int
</code></pre>
<pre><code class="language-odin" data-lang="odin">// With inferred size.
some_ints := [?]int{1, 2, 3, 4, 5}

favorite_animals := [?]string{
&nbsp;&nbsp;&nbsp;&nbsp;// Assign by index
&nbsp;&nbsp;&nbsp;&nbsp;0 = "Raven",
&nbsp;&nbsp;&nbsp;&nbsp;1 = "Zebra",
&nbsp;&nbsp;&nbsp;&nbsp;2 = "Spider",
&nbsp;&nbsp;&nbsp;&nbsp;// Assign by range of indices
&nbsp;&nbsp;&nbsp;&nbsp;3..=5 = "Frog",
&nbsp;&nbsp;&nbsp;&nbsp;6..&lt;8 = "Cat"
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">some_ints[0] = 5
some_ints[3] = 40
</code></pre>
<pre><code class="language-odin" data-lang="odin">some_ints = {5, 4, 3, 1, 2, 98, 100}
&nbsp;&nbsp;&nbsp;&nbsp;// Since the size is defined as 7, 7 elements must be given.
</code></pre>
<pre><code class="language-odin" data-lang="odin">x := [5]int{1, 2, 3, 4, 5}
for i in 0..=4 {
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println(x[i])
}
</code></pre>
<h5
	id="iterate" >
    Iterate
</h5>
<pre><code class="language-odin" data-lang="odin">for element in some_ints {
&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
<pre><code class="language-odin" data-lang="odin">for element, idx in some_ints {
&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
<pre><code class="language-odin" data-lang="odin">for &element in some_ints {
&nbsp;&nbsp;&nbsp;&nbsp;element *= 2
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
<h5
	id="copy" >
    Copy
</h5>
<pre><code class="language-odin" data-lang="odin">some_ints: [3]f32 = {1, 2, 3}
some_ints2 := some_ints
</code></pre>
<ul>
	<li>
		<p>
            Modifying array 2 will not modify array 1, and vice versa.
		</p>
	</li>
	<li>
		<p>
            &quot;No shared memory between fixed arrays&quot;.
		</p>
	</li>
</ul>
<h4
	id="small-array" >
    Small Array
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/container/small_array/#Small_Array" 
				class="external-link" 
				target="_blank" >
                Small_Array
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Pretty neat.
		</p>
	</li>
	<li>
		<p>
            Basically it's a Fixed Array with an API similar to a Dynamic Array.
		</p>
	</li>
	<li>
		<p>
            I found it really cool.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>Skeleton</code>
            &nbsp;uses this, as a reference.
		</p>
	</li>
</ul>
<h4
	id="enumerated-arrays-codeenumint-code" >
    Enumerated Arrays (
    <code>[enum]int</code>
    )
</h4>
<ul>
	<li>
		<p>
            Think of it as a Fixed Array.
		</p>
	</li>
	<li>
		<p>
            Even though we don't supply the size, the array will be the size of the enum.
		</p>
	</li>
</ul>
<h5
	id="create" >
    Create
</h5>
<pre><code class="language-odin" data-lang="odin">// Enum
Nice_People :: enum {
&nbsp;&nbsp;&nbsp;&nbsp;Bob,
&nbsp;&nbsp;&nbsp;&nbsp;Klucke,
&nbsp;&nbsp;&nbsp;&nbsp;Tim
}

// Method 1
nice_rating := [Nice_People]int {
&nbsp;&nbsp;&nbsp;&nbsp;.Bob = 5,
&nbsp;&nbsp;&nbsp;&nbsp;.Klucke = 7,
&nbsp;&nbsp;&nbsp;&nbsp;.Tim = 3,
}

// Method 2: all zeroes
nice_rating := [Nice_People]int&nbsp;&nbsp;&nbsp;&nbsp;

// Method 3: partial initialization
nice_rating := #partial [Nice_People]int {
&nbsp;&nbsp;&nbsp;&nbsp;.Klucke = 7,
}
</code></pre>
<h5
	id="access" >
    Access
</h5>
<pre><code class="language-odin" data-lang="odin">bob_niceness := nice_rating[.Bob]
</code></pre>
<h3
	id="slices-codet-code" >
    Slices (
    <code>[]T</code>
    )
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#slices" 
				class="external-link" 
				target="_blank" >
                Slices
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#making-and-deleting-slices-and-dynamic-arrays" 
				class="external-link" 
				target="_blank" >
                Making and deleting slices
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/slice/" 
				class="external-link" 
				target="_blank" >
                <code>core:slices</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#Raw_Slice" 
				class="external-link" 
				target="_blank" >
                <code>Raw_Slice</code>
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<ul>
	<li>
		<p>
			<strong>
                Via Fixed Array
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> a := [7]int{ 5, 4, 3, 1, 2, 98, 100 } 
&nbsp;&nbsp;&nbsp;&nbsp; // Left side:&nbsp;&nbsp;Fixed Array.
&nbsp;&nbsp;&nbsp;&nbsp; // Right side: Array Literal.
 b := a[2:5]
&nbsp;&nbsp;&nbsp;&nbsp; // Left side: Slice.
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Via Slice Literal
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Implicitly creates a stack fixed array, and then get a reference to it.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> a := []int{ 1, 6, 3 } 
&nbsp;&nbsp;&nbsp;&nbsp; // Left side:&nbsp;&nbsp;Slice.
&nbsp;&nbsp;&nbsp;&nbsp; // Right side: Slice Literal.
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Zero valued
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The zero value of a slice is 
                    <code>nil</code>
                    . A nil slice has a length of 0 and does not point to any underlying memory. Slices can be compared against 
                    <code>nil</code>
                    &nbsp;and nothing else.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> a: []int
 if a == nil {
&nbsp;&nbsp;&nbsp;&nbsp; fmt.println("a is nil!")
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Via 
                <code>rawptr</code>
                &nbsp;and length
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    From 
                    <code>base:runtime</code>
                    &nbsp;-&gt; 
                    <code>internal.odin</code>
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(private)
 byte_slice :: #force_inline proc "contextless" (data: rawptr, len: int) -&gt; []byte #no_bounds_check {
 Â  Â  return ([^]byte)(data)[:max(len, 0)]
 }
</code></pre>
	</li>
</ul>
<h5
	id="batch-assignment" >
    Batch assignment
</h5>
<ul>
	<li>
		<p>
			<strong>
                Heap allocated slice
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        NOT WHAT YOU WANT
					</strong>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> a := make([]int, 4, context.allocator)
 a = { 10, 20, 30, 40 } 
</code></pre>
				<ul>
					<li>
						<p>
                            This replaces the heap allocated slice with a stack slice.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Using 
                        <code>copy</code>
					</em>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> a := make([]int, 4, context.allocator)
 copy(a, []int{ 10, 20, 30, 40 })
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Using 
                        <code>slice.clone</code>
					</em>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> a := slice.clone([]int{ 10, 20, 30, 40 }, context.allocator)
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="destruction" >
    Destruction
</h5>
<ul>
	<li>
		<p>
            You only need to delete the slice 
			<strong>
                if
			</strong>
            &nbsp;the underlying value is heap allocated.
		</p>
	</li>
	<li>
		<p>
            You could delete the original 
            <code>[dynamic]int</code>
            &nbsp;or the 
            <code>[]int</code>
            ; both will delete the same memory.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">a := make([dynamic]int, context.allocator)
b := a[:]
delete(b)
&nbsp;&nbsp;&nbsp;&nbsp;// Will delete the underlying memory of `a` and `b`, as both point to heap memory.

// or

a := make([]int, context.allocator)
delete(a)
</code></pre>
<h5
	id="access-range" >
    Access range
</h5>
<pre><code class="language-odin" data-lang="odin">// Everything
a[:]

// From idx 3 to the end
a[3:]

// From start to idx 5
a[:5]
</code></pre>
<h5
	id="memory" >
    Memory
</h5>
<ul>
	<li>
		<p>
            Their length is 
			<strong>
                not
			</strong>
            &nbsp;known at compile-time.
		</p>
	</li>
	<li>
		<p>
            Slices are like references to arrays; they do not store any data.
		</p>
		<ul>
			<li>
				<p>
                    Internally, a slice stores a pointer to the data and an integer to store the length of the slice.
				</p>
			</li>
			<li>
				<p>
                    &quot;A window into the array&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A slice always points to memory, which can be in the stack or heap. If it's in the stack, no need for manual memory management, but if it's in the heap, we can use the address stored by the slice to free its memory, the same as done by a 
            <code>[dynamic]byte</code>
            .
		</p>
	</li>
	<li>
		<p>
            I can expand a 
            <code>[dynamic]byte</code>
            , but not a 
            <code>[]byte</code>
            , since a dynamic array has an allocator, and slices don't. Both of them point to memory, but slices can only free it, while 
            <code>[dynamic]byte</code>
            &nbsp;can free and expand.
		</p>
	</li>
	<li>
		<p>
            No allocation is done when slicing.
		</p>
		<ul>
			<li>
				<p>
                    This means it is bound to the array from which the slice was made.
				</p>
			</li>
			<li>
				<p>
                    For this reason, it is preferable to pass slices as procedure parameters.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Converting Array Slice to Dynamic Array
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> some_ints3 := slice.to_dynamic(some_ints2)
&nbsp;&nbsp;&nbsp;&nbsp; // array slice to dynamic array
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Allocate memory
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> // Method 1
 some_ints3 := slice.clone(some_ints2)
&nbsp;&nbsp;&nbsp;&nbsp; // array slice to array slice

 // Method 2: with `make`
 some_ints3 := make([]int)
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Delete
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If the slice has its own memory, then it is necessary to free this memory afterward:
						</p>
<pre><code class="language-odin" data-lang="odin"> delete(some_ints3)
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="dynamic-arrays-codedynamict-code" >
    Dynamic Arrays (
    <code>[dynamic]T</code>
    )
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#Raw_Dynamic_Array" 
				class="external-link" 
				target="_blank" >
                <code>Raw_Dynamic_Array</code>
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<pre><code class="language-odin" data-lang="odin">// Without make
dyn_arr: [dynamic]int

// With make
dyn_array := make([dynamic]int, context.temp_allocator)
dyn_array := make([dynamic]int, 5, 10, context.temp_allocator) // len 5, cap 10

// With core:bytes lib.
b: bytes.Buffer
bytes.buffer_init_allocator(&b, 0, 2048) // len 0, cap 2048
bytes.buffer_write_string(&b, "my string")
</code></pre>
<h5
	id="destruction" >
    Destruction
</h5>
<pre><code class="language-odin" data-lang="odin">delete(dyn_array)
</code></pre>
<h5
	id="clear" >
    Clear
</h5>
<pre><code class="language-odin" data-lang="odin">clear(&dyn_array)
</code></pre>
<h5
	id="appending" >
    Appending
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/runtime/#append" 
				class="external-link" 
				target="_blank" >
                <code>append</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>n: int</code>
                    &nbsp;symbolizes the number of elements appended.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> append(&dyn_arr, 5)
&nbsp;&nbsp;&nbsp;&nbsp; // dyn_arr[0] is now 5
</code></pre>
<pre><code class="language-odin" data-lang="odin"> x: [dynamic]int
 append(&x, 123)
 append(&x, 4, 1, 74, 3) // append multiple values at once
 
 y: [dynamic]int
 append(&y, ..x[:]) // append a slice
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Memory considerations when resizing
					</strong>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> skeleton_add_joint :: proc(skeleton: ^Skeleton, parent_joint_idx: int, pos: eng.Vec2, rot: f32 = 0, scale: f32 = 1.0, name: string = "") -&gt; int {
&nbsp;&nbsp;&nbsp;&nbsp; if eng.error_assert(skeleton != nil) do return INVALID_JOINT
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; parent_joint := &skeleton.joints[parent_joint_idx]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // !! This is invalidated if the append below causes a resize.
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; append(&skeleton.joints, Joint{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos Â  = pos,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rot Â  = rot,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scale = scale,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = name,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent = parent_joint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skeleton = skeleton,
&nbsp;&nbsp;&nbsp;&nbsp; })
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; joint_idx := len(skeleton.joints) - 1
&nbsp;&nbsp;&nbsp;&nbsp; append(&parent_joint.children, joint_idx)
&nbsp;&nbsp;&nbsp;&nbsp; return joint_idx
 }
</code></pre>
				<ul>
					<li>
						<p>
                            Barinzaya:
						</p>
						<ul>
							<li>
								<p>
                                    If the dynamic array is full when you append something, then it'd need to resize to add one. That may cause the backing memory to move.
								</p>
							</li>
							<li>
								<p>
                                    You're taking 
                                    <code>parent_joint</code>
                                    &nbsp;
									<em>
                                        before
									</em>
                                    &nbsp;you 
                                    <code>append</code>
                                    &nbsp;to the same array, so 
                                    <code>parent_joint</code>
                                    &nbsp;may be invalid after the append.
								</p>
							</li>
							<li>
								<p>
                                    Also, you're storing pointers to the array in 
                                    <code>Joint</code>
                                    &nbsp;(the 
                                    <code>parent</code>
                                    &nbsp;field). Those can also become invalid when the dynamic array resizes
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    So, what you are saying is that: if I have a pointer to the array, and the array resizes, then I'm screwed? I shouldn't store a pointer to an element in an array?
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Barinzaya:
						</p>
						<ul>
							<li>
								<p>
                                    Basically, yes. Though specifically when it resizes as in 
									<em>
                                        reallocates
									</em>
                                    &nbsp;(i.e. 
                                    <code>cap</code>
                                    &nbsp;changes). 
                                    <code>append</code>
                                    ing to an array with 
                                    <code>len == cap</code>
                                    &nbsp;will cause it to reallocate, for instance
								</p>
							</li>
							<li>
								<p>
                                    That can 
									<em>
                                        possibly
									</em>
                                    &nbsp;resize in place, but unless you know the specifics of the allocator it's using, you shouldn't rely on it.
								</p>
							</li>
							<li>
								<p>
                                    If it moves, the whole array will move (i.e. the 
                                    <code>[dynamic]Joint</code>
                                    &nbsp;will point somewhere else)
								</p>
							</li>
							<li>
								<p>
                                    The 
                                    <code>[dynamic]Joint</code>
                                    &nbsp;struct 
									<em>
                                        itself
									</em>
                                    &nbsp;won't move, it's still firmly in your struct--but the array's actual data is behind a pointer, and that can move.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            SaiMoen:
						</p>
						<ul>
							<li>
								<p>
                                    Unless you know the 
									<em>
                                        pointer is stable
									</em>
                                    &nbsp;because the backing allocator wouldn't move it (e.g. virtual arena w/ .Static where the only thing using it is the dynamic array).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    Is there a rule of thumb for dealing with this situations? some safe design I could use?
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Barinzaya:
						</p>
						<ol>
							<li>
								<p>
                                    Store array indices, rather than pointers, and any time you 
                                    <code>append</code>
                                    , assume that any pointers you got before the 
                                    <code>append</code>
                                    &nbsp;are now invalid.
								</p>
							</li>
							<li>
								<p>
                                    If you were to 
									<em>
                                        individually
									</em>
                                    &nbsp;allocate each 
                                    <code>Joint</code>
                                    &nbsp;(i.e. using 
                                    <code>new</code>
                                    ), then resizing the array wouldn't move the 
                                    <code>Joint</code>
                                    s themselves, just its array of pointers; by using 
                                    <code>[dynamic]^Joint</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The other option, if you know how many 
                                    <code>Joint</code>
                                    s there will be, is to 
                                    <code>reserve</code>
                                    &nbsp;the dynamic array ahead of time. If it never needs to resize, then you won't have an issue. You'd just need to be careful to make sure that it doesn't, in fact, resize. Indices would probably be less error-prone.
								</p>
							</li>
							<li>
								<p>
                                    &quot;have you looked at relative.Ptr? whether thats an alternative&quot;.
								</p>
								<ul>
									<li>
										<p>
                                            It would work if all of the pointers are within the same array as they seem to be here, yeah. Though array indices would probably be simpler and more debuggable.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    It's handy to have a fixed master array of entities that never changes and serves as a reference, and then you can manipulate seperate arrays of pointers (sorting, growing, etc). However this is not cache-local so it depends on your perf requirements.
								</p>
							</li>
						</ol>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#inject_at" 
				class="external-link" 
				target="_blank" >
                <code>inject_at</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    inject
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#assign_at" 
				class="external-link" 
				target="_blank" >
                <code>assign_at</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    ?
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="iterate" >
    Iterate
</h5>
<pre><code class="language-odin" data-lang="odin">for element in dyn_array {
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
<pre><code class="language-odin" data-lang="odin">for element, idx in dyn_array {
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
<pre><code class="language-odin" data-lang="odin">for &element in dyn_array {
&nbsp;&nbsp;&nbsp;&nbsp;element *= 2
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
<h5
	id="memory" >
    Memory
</h5>
<ul>
	<li>
		<p>
			<strong>
                Cache
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <a href="CPU.html#Performance Fixed Array (Small Array) vs Dynamic Array">
                    CPU#Performance Fixed Array (Small Array) vs Dynamic Array
                    </a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Stored in the heap.
				</p>
			</li>
			<li>
				<p>
                    They don't &quot;hold&quot; the memory, but actually just point to the address in memory where it is allocated.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Allocator
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is where the data the pointer points to comes from and where it goes to realloc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Interacting with Slices
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    When you slice a dyn array like 
                    <code>my_dyn_array[:]</code>
                    , the slice's 
					<em>
                        pointer
					</em>
                    &nbsp;and 
					<em>
                        len
					</em>
                    &nbsp;will be the same as the 
                    <code>my_dyn_array</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Because it's the same pointer, when you go to delete it the allocator knows which allocation you want to free.
						</p>
					</li>
					<li>
						<p>
                            In other words, freeing the array slice means that the original 
                            <code>my_dyn_array</code>
                            &nbsp;is freed, as they both point to the same thing.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Growth
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Grows when the 
					<em>
                        capacity
					</em>
                    &nbsp;is equal to the 
					<em>
                        length
					</em>
                    &quot;.
				</p>
			</li>
			<li>
				<p>
                    It's possible to use a different allocator to make the array grow:
				</p>
<pre><code class="language-odin" data-lang="odin"> // Method 1: change the allocator used by the array.
 dyn_arr: [dynamic]int
 dyn_array.allocator = context.temp_allocator
 append(&dyn_array, 5)

 // Method 2: use `make` when creating the array
 dyn_array := make([dynamic]int, context.temp_allocator)

 // Method 3: change the default allocator of the context (not recommended)
 dyn_arr: [dynamic]int
 context.allocator = context.temp_allocator
 append(&dyn_array, 5)

</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Copying
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Correct method
					</em>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> dyn_array: [dynamic]int
 append(&dyn_array, 5)

 dyn_array2 := slice.clone_to_dynamic(dyn_array[:])
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Incorrect method
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Be careful!
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> dyn_array: [dynamic]int
 append(&dyn_array, 5)

 dyn_array2 := dyn_array
</code></pre>
				<ul>
					<li>
						<p>
                            The second array points to the same location as the first array.
						</p>
						<ul>
							<li>
								<p>
                                    This is extremely error-prone, since appending to the first array will grow it, but the second array will not grow; things like that.
								</p>
							</li>
							<li>
								<p>
                                    It will probably crash.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Alternatives
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
					<em>
                        Via 
                        <code>Buffers</code>
                        &nbsp;from the 'core:bytes' library
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Loads information that may or may not be useful:
						</p>
						<ul>
							<li>
								<p>
                                    <code>off: int</code>
								</p>
								<ul>
									<li>
										<p>
                                            I believe it represents the offset from where reading stopped.
										</p>
									</li>
									<li>
										<p>
                                            This is used everywhere, so if something has been read, it is excluded from all future operations, including 
                                            <code>bytes.buffer_to_bytes</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Fortunately, this is quite explicit when reading the library's procs.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>last_read: Read_Op</code>
								</p>
								<ul>
									<li>
										<p>
                                            Flags for the last thing read.
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin"> Read_Op :: enum i8 {
 Â  Â  Read Â  Â  Â  = -1,
 Â  Â  Invalid Â  Â = Â 0,
 Â  Â  Read_Rune1 = Â 1,
 Â  Â  Read_Rune2 = Â 2,
 Â  Â  Read_Rune3 = Â 3,
 Â  Â  Read_Rune4 = Â 4,
 }
</code></pre>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Not intended for sorting, element removal, etc.
						</p>
						<ul>
							<li>
								<p>
                                    Obviously possible, since it's fundamentally just a 
                                    <code>[dynamic]T</code>
                                    , but it's not the focus.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</li>
</ul>
<h3
	id="multi-pointer-codet-code" >
    Multi-pointer (
    <code>[^]T</code>
    )
</h3>
<ul>
	<li>
		<p>
            Multi-pointers are just C arrays.
		</p>
	</li>
	<li>
		<p
			class="line-emphasis" >
            See 
            <a href="C.html#Arrays">
            C#Arrays
            </a>
            &nbsp;for better understanding.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#multi-pointers" 
				class="external-link" 
				target="_blank" >
                Multi Pointer
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;The name may be subject to change.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The type 
            <code>[^]T</code>
            &nbsp;is a multi-pointer to T value(s).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Used in
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Describe 
					<a
						href="https://odin-lang.org/docs/overview/#foreign-system" 
						class="external-link" 
						target="_blank" >
                        <code>foreign</code>
					</a>
                    &nbsp;(C-like) pointers which act like arrays (pointers that map to multiple items).
				</p>
			</li>
			<li>
				<p>
                    It is precisely what makes up a 
					<a
						href="https://pkg.odin-lang.org/base/runtime/#Raw_Cstring" 
						class="external-link" 
						target="_blank" >
                        Raw_Cstring
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            A 
							<a
								href="https://pkg.odin-lang.org/base/runtime/#Raw_Cstring" 
								class="external-link" 
								target="_blank" >
                                Raw_String
							</a>
                            &nbsp;is almost the same thing, but contains a length.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Zero Value
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>nil</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="operations" >
    Operations
</h5>
<pre><code class="language-odin" data-lang="odin">x: [^]T = ...

x[i]&nbsp;&nbsp; -&gt; T
x[:]&nbsp;&nbsp; -&gt; [^]T
x[i:]&nbsp;&nbsp;-&gt; [^]T
x[:n]&nbsp;&nbsp;-&gt; []T
x[i:n] -&gt; []T
</code></pre>
<h5
	id="re-allocating" >
    Re-allocating
</h5>
<ul>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    hello, if 
                    <code>image_pixel: []byte</code>
                    &nbsp;and 
                    <code>image_data: [^]u8</code>
                    , how can I allocate the values from the 
                    <code>image_data</code>
                    &nbsp;into 
                    <code>image_pixels</code>
                    ? I'm doing the following, but I'm getting a UAF.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> size := image_get_size(extent, format)
 image_pixels = make([]byte, size, allocator)
 image_pixels = image_data[:size]
</code></pre>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    All 
                    <code>image_pixels = image_data[:size]</code>
                    &nbsp;is doing is changing 
                    <code>image_pixels</code>
                    &nbsp;to point to 
                    <code>image_data</code>
                    's data, it's not actually copying the data. It sounds like you want 
                    <code>copy(image_pixels, image_data[:size])</code>
				</p>
			</li>
			<li>
				<p>
                    <code>copy</code>
                    &nbsp;is a built-in procedure that copies elements from a source slice/string 
                    <code>src</code>
                    &nbsp;to a destination slice 
                    <code>dst</code>
                    . The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="raw_data" >
    raw_data()
</h5>
<ul>
	<li>
		<p>
            Interacting with Multi-Pointers is easiest using the builtin 
            <code>raw_data()</code>
            &nbsp;call which can return a Multi-Pointer.
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/base/builtin/#raw_data" 
						class="external-link" 
						target="_blank" >
                        raw_data
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Returns the underlying data of a built-in data type as a multi-pointer.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">b := [?]int{ 10, 20, 30 }
a: [^]int
fmt.println(a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;nil&gt;
a = raw_data(b[:]) 
fmt.println(a, a[1]) // 0x7FFCBE9FE688 20
</code></pre>
<h5
	id="discussion" >
    Discussion
</h5>
<ul>
	<li>
		<p>
			<strong>
                Discussion 1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is 
                    <code>raw_data(my_array_ptr)</code>
                    &nbsp;the same as 
                    <code>&my_array_ptr[0]</code>
                    , if 
                    <code>len(my_array_ptr) &gt; 0</code>
                    ? I find that using 
                    <code>&my_array_ptr[0]</code>
                    &nbsp;is a bit more intuitive when something asks for a 
                    <code>[^]</code>
                    , does it make sense?
				</p>
				<ul>
					<li>
						<p>
                            Mostly. 
                            <code>&my_array[0]</code>
                            &nbsp;will invoke bounds checking on slices/dynamic arrays whereas 
                            <code>raw_data</code>
                            &nbsp;won't (and will just return the slice's pointer directly). The types are technically different, but 
                            <code>^T</code>
                            &nbsp;converts to 
                            <code>[^]T</code>
                            &nbsp;so that often doesn't matter
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    so, no harm no foul on using 
                    <code>&myarray[0]</code>
                    ? That makes things much easier to understand
				</p>
				<ul>
					<li>
						<p>
                            Should be fine if you know it won't be empty, but it may incur a bounds check. Otherwise, the result will be the same
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Discussion 2
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> property_count: u32
 vk_check(vk.EnumerateInstanceExtensionProperties(nil, &property_count, nil))
 
 properties := make([]vk.ExtensionProperties, property_count)
 vk_check(vk.EnumerateInstanceExtensionProperties(nil, &property_count, raw_data(properties)))
 
 fmt.printfln("property_count: %v, properties: %v", property_count, properties)
</code></pre>
		<ul>
			<li>
				<p>
                    Shouldn't I never use a multi-pointer directly, but only use 
                    <code>raw_data</code>
                    &nbsp;to interface with a foreign api?
				</p>
				<ul>
					<li>
						<p>
                            yeah you normally don't need a multipointer
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> physical_device_properties := vk.PhysicalDeviceProperties2{
&nbsp;&nbsp;&nbsp;&nbsp; sType = .PHYSICAL_DEVICE_PROPERTIES_2
 }
 vk.GetPhysicalDeviceProperties2(device, &physical_device_properties)
</code></pre>
		<ul>
			<li>
				<p>
                    just earlier I had to create an array slice and pass it with a 
                    <code>raw_data</code>
                    , but now I'm just using a pointer to a struct, why is that?
				</p>
				<ul>
					<li>
						<p>
                            They're equivalent.
						</p>
					</li>
					<li>
						<p>
                            Both a pointer and a slice are assignable to a multi-pointer.
						</p>
					</li>
					<li>
						<p>
                            Multi-pointers are just C arrays.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="interfaces-methods-vtables" >
    Interfaces / Methods / VTables
</h2>
<ul>
	<li>
		<p>
            The only reason I would organize data into a struct, instead of keeping them loose, would be POLYMORPHISM.
		</p>
	</li>
	<li>
		<p>
            Ways to have different systems for the same type of data:
		</p>
		<ol>
			<li>
				<p>
                    Function Pointers inside the struct, with different implementations.
				</p>
				<ul>
					<li>
						<p>
                            Reminds of methods, but:
						</p>
						<ul>
							<li>
								<p>
                                    The procedure is not private, nor anything.
								</p>
							</li>
							<li>
								<p>
                                    Doesn't interact with any constructor or destructor.
								</p>
							</li>
							<li>
								<p>
                                    Not part of any high-level abstraction concept.
								</p>
							</li>
							<li>
								<p>
                                    Can be changed at runtime.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            In other words, it's better than a method.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~Generics.
				</p>
				<ul>
					<li>
						<p>
                            Doesn't solve the problem. I don't want a generic procedure, but a completely different implementation of a procedure.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~Procedure Overloading.
				</p>
				<ul>
					<li>
						<p>
                            Doesn't solve the problem. I don't want a dynamic dispatcher that judges the object type and calls a different procedure.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<em>
                Cases where this could be useful
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        ECS
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Reminds me of ECS concepts, where I could use a struct and call the struct with its own procedure.
						</p>
					</li>
					<li>
						<p>
                            Probably not exactly ECS, but it allows for SOA usage.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Create of User_Character / NPC_Character / Creature.
				</p>
			</li>
			<li>
				<p>
                    Destroy of User_Character / NPC_Character / Creature.
				</p>
			</li>
			<li>
				<p>
                    PrePhysics of User_Character / NPC_Character / Creature.
				</p>
			</li>
			<li>
				<p>
                    PostPhysics of User_Character / NPC_Character / Creature.
				</p>
			</li>
			<li>
				<p>
                    Draw of User_Character / NPC_Character / Creature.
				</p>
			</li>
			<li>
				<p>
                    DrawCanvas of User_Character / NPC_Character / Creature.
				</p>
			</li>
			<li>
				<p>
                    Scene.
				</p>
				<ul>
					<li>
						<p>
                            This could remove the use of switches for: init, deinit, input, physics, draw.
						</p>
					</li>
					<li>
						<p>
                            The same goes for change_scene.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Note
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Technically this can be used in many places, BUT, I should only use it if I feel there's value in polymorphism.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=AuhIsaS5wRk" 
				class="external-link" 
				target="_blank" >
                OOP in Odin
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;just function pointers with a fancy name&quot;.
				</p>
			</li>
			<li>
				<p>
                    Use of &quot;function tables&quot; (&quot;V tables&quot;, virtual tables) with 
                    <code>using</code>
                    &nbsp;in structs to achieve inheritance.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="operator-code-gt-code" >
    Operator 
    <code>-&gt;</code>
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#--operator-selector-call-expressions" 
				class="external-link" 
				target="_blank" >
                Operator 
                <code>-&gt;</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The 
            <code>-&gt;</code>
            &nbsp;operator can be used to inject a pointer to itself as the first parameter of the procedure.
		</p>
	</li>
	<li>
		<p>
            As the 
            <code>-&gt;</code>
            &nbsp;operator is effectively 
			<strong>
                syntactic sugar
			</strong>
            , all of the same semantics still apply, meaning subtyping through 
            <code>using</code>
            &nbsp;will still work as expected to allow for the emulation of type hierarchies.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>-&gt;</code>
            &nbsp;syntax is being abused in the 2nd option to mimic 
			<a
				href="https://en.m.wikipedia.org/wiki/Uniform_function_call_syntax" 
				class="external-link" 
				target="_blank" >
                UFCS
			</a>
            , when it was initially implemented mostly for C++ 
			<a
				href="https://docs.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal" 
				class="external-link" 
				target="_blank" >
                Component Objective Model (COM)
			</a>
            &nbsp;pattern and Objective C code interop.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">x-&gt;y(123)
// is equivalent to
x.y(x, 123)
</code></pre>
<h3
	id="discussion" >
    Discussion
</h3>
<ol>
	<li>
		<p>
            Many procedures symbolizing init, deinit, update, and draw for a scene. Each scene holds an enum value to know which scene to play at a given moment. When switching to a different scene, I will have to use a 
            <code>switch</code>
            &nbsp;to properly call the deinit procedure for the 
            <code>last_scene</code>
            , and use a 
            <code>switch</code>
            &nbsp;to call init for the 
            <code>new_scene</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    Packing the abstraction into control flow.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Many procedures symbolizing init, deinit, update, and draw for a scene, but the scene is now a struct holding function pointers to each of its systems. When switching to a different scene, I just call 
            <code>last_scene.deinit(last_scene)</code>
            &nbsp;or 
            <code>last_scene-&gt;deinit()</code>
            , where 
            <code>deinit</code>
            &nbsp;is the function pointer.
		</p>
		<ul>
			<li>
				<p>
                    Packing the abstraction into memory.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            You can have a 
            <code>[Scene_Enum]Deinit_Proc</code>
            &nbsp;that contains each deinit proc for each Scene, and just use the scene enum to call the proc.
		</p>
		<ul>
			<li>
				<p>
                    Instead of attaching methods to types, group all operations by behavior.
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">typedef void (*DrawFunc)(void *);

DrawFunc draw_funcs[MAX_ENTITY_TYPE];

draw_funcs[ENTITY_PLAYER] = PlayerDraw;
draw_funcs[ENTITY_ENEMY]&nbsp;&nbsp;= EnemyDraw;
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#--operator-selector-call-expressions" 
				class="external-link" 
				target="_blank" >
                Subtype polymorphism with runtime type-safe down-casting
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Just a selector with Enum.
				</p>
			</li>
		</ul>
	</li>
</ol>
<ul>
	<li>
		<p>
			<em>
                Performance
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    I got a bit worried that option 2 could be bad for a system like a scene or entity, as these function pointers are called EVERY FRAME, for every entity (in cases where I use stuff like this for entities). Am I overthinking performance here? I mean, C++ seems to do that in the end, so is it a bad thing for performance?
				</p>
			</li>
			<li>
				<p>
					<em>
                        Opinions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I've seen all of them in practice, and they really are nothing but syntactic choices. I doubt they'd impact performance that much. But that is just my uneducated guess.
						</p>
					</li>
					<li>
						<p>
                            Depends on how the CPU behaves, best to benchmark if you really care although I doubt it will matter much. Also an uneducated guess.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://hero.handmade.network/forums/code-discussion/t/773-interfaces?utm_source=chatgpt.com" 
								class="external-link" 
								target="_blank" >
                                Source
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Casey:
						</p>
						<ul>
							<li>
								<p>
                                    Well, I guess the thing I would ask is, what is the benefit of making an &quot;object&quot; any more formal than just the struct and some functions? You already have the ability through function overloading to change which random number API you are using by changing the type (random_series to random_series_2 or whatever). So what is the benefit of making an &quot;object&quot; out of it?
								</p>
							</li>
							<li>
								<p>
                                    If the answer is polymorphism, well, yeah, at that point you have a vtable situation and things start to get a lot more expensive, because the random number generation can no longer be inlined, for example - it always has to be a function call. If the answer is something else, what is that something else?
								</p>
							</li>
							<li>
								<p>
                                    Yeah, ML and friends do type inference in a much better way, without making you do all kinds of template nonsense and so on. But there's a whole other set of things you have to worry about if you go that direction. It would have been nice if C++ had introduced a happy medium, but of course they always do the worst possible thing so they didn't :(
								</p>
								<ul>
									<li>
										<p>
											<em>
                                                ML
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    Stands for MetaLanguage â€” a family of functional programming languages that includes:
												</p>
												<ul>
													<li>
														<p>
                                                            Standard ML (SML)
														</p>
													</li>
													<li>
														<p>
                                                            OCaml
														</p>
													</li>
													<li>
														<p>
                                                            F (influenced by ML, part of the .NET ecosystem)
														</p>
													</li>
													<li>
														<p>
                                                            Caml (precursor to OCaml)
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    These languages are known for:
												</p>
												<ul>
													<li>
														<p>
                                                            Powerful static type systems
														</p>
													</li>
													<li>
														<p>
                                                            Type inference: The compiler can deduce the types of most expressions without requiring explicit type annotations.
														</p>
													</li>
													<li>
														<p>
                                                            Immutable data structures by default
														</p>
													</li>
													<li>
														<p>
                                                            Strong support for pattern matching, algebraic data types, and functional abstractions
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            He is contrasting ML-style type inference (clean, automatic, minimal boilerplate) with C++ templates, which:
										</p>
										<ul>
											<li>
												<p>
                                                    Often require verbose and complex syntax
												</p>
											</li>
											<li>
												<p>
                                                    Have poor error messages
												</p>
											</li>
											<li>
												<p>
                                                    Do not integrate cleanly with the rest of the type system
												</p>
											</li>
											<li>
												<p>
                                                    Are Turing-complete but hard to control (template metaprogramming)
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Ginger Bill:
						</p>
						<ul>
							<li>
								<p>
                                    I use Go(lang) a lot at work and Go interfaces can be useful. In the 
									<a
										href="https://golang.org/pkg/io/" 
										class="external-link" 
										target="_blank" >
                                        io
									</a>
                                    &nbsp;package, there are a few very useful interfaces: Reader, Writer, ReadWriter, WriterAt, WriterTo, ReaderAt, ReaderFrom.
								</p>
							</li>
							<li>
								<p>
                                    Interfaces are implicit so all you have to do is implement the functions for that type and it will automatically behave as that interface. I don't use interfaces that often as I usually just use structures and functions for most things but they are useful when you need a generic function.
								</p>
							</li>
							<li>
								<p>
                                    I do believe that they are implemented as vtables internally which can be a problem.
								</p>
							</li>
							<li>
								<p>
                                    I know that in C++17, they will/might implement concepts which act very similar but I do not know if they will solve it. I do not know how C++17 concepts are implemented nor have I ever had the chance to use them; so I cannot comment.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="vtables-virtual-tables" >
    VTables (Virtual Tables)
</h3>
<ul>
	<li>
		<p>
            A Vtable is:
		</p>
		<ul>
			<li>
				<p>
                    A table of function pointers.
				</p>
			</li>
			<li>
				<p>
                    Each class with virtual functions has its own vtable.
				</p>
			</li>
			<li>
				<p>
                    Each object of that class contains a hidden pointer to its classâ€™s vtable (commonly the first pointer in the object's memory layout).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            When a virtual method is called, the compiler emits code that:
		</p>
		<ul>
			<li>
				<p>
                    Looks up the function pointer in the vtable.
				</p>
			</li>
			<li>
				<p>
                    Indirectly calls that function through the pointer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Why VTables Can Be Problematic
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Performance Overhead
					</strong>
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                No inlining
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Virtual function calls can't be inlined because the exact function isn't known at compile time.
								</p>
							</li>
							<li>
								<p>
                                    In C++, Virtual functions disable inlining unless compiler devirtualizes.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Indirect branch
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Every call goes through an extra pointer dereference, which introduces a pipeline stall or branch prediction failure on modern CPUs.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Cache misses
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Function pointers may not be in cache, leading to further delays.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Hidden Complexity
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            VTables are often invisible in source code in C++. You donâ€™t explicitly write the table â€” the compiler generates it.
						</p>
						<ul>
							<li>
								<p>
                                    Every polymorphic object gets a hidden vtable pointer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            This leads to less control and transparency, especially when debugging or optimizing.
						</p>
					</li>
					<li>
						<p>
                            Harder Debugging
						</p>
						<ul>
							<li>
								<p>
                                    Debugging virtual dispatch is more difficult because the function being called isnâ€™t directly visible in code.
								</p>
							</li>
							<li>
								<p>
                                    Tools must inspect vtable pointers and offsets to determine the actual call target.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Binary Size and ABI Fragility
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Every virtual function adds a pointer to the vtable.
						</p>
					</li>
					<li>
						<p>
                            Changing the vtable layout breaks binary compatibility (ABI), which is a concern in shared library design.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=HfrBdf-hM28" 
				class="external-link" 
				target="_blank" >
                Calling functions inside classes via the function address stored in the VTable
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is used to do VTable swapping. Somehow this is used for hacking.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="error-handling" >
    Error Handling
</h2>
<ul>
	<li>
		<p>
            It reminds me of Go.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">f, err := os.open("my_file.txt")
if err != os.ERROR_NONE {
&nbsp;&nbsp;&nbsp;&nbsp;// handle error
}
defer os.close(f)
// rest of code
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=uoIutDC5iBE" 
				class="external-link" 
				target="_blank" >
                Example of usage
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="definitions" >
    Definitions
</h3>
<ul>
	<li>
		<p>
            <code>core/os/errors.odin</code>
		</p>
	</li>
</ul>
<h3
	id="panics" >
    Panics
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#assert" 
				class="external-link" 
				target="_blank" >
                <code>assert</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Can be ignored with 
                    <code>ODIN_DISABLE_ASSERT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Closes the program.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#ensure" 
				class="external-link" 
				target="_blank" >
                <code>ensure</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Cannot be ignored with 
                    <code>ODIN_DISABLE_ASSERT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Is stronger than 
                    <code>assert</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Closes the program.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#panic" 
				class="external-link" 
				target="_blank" >
                <code>panic</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Closes the program.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#unimplemented" 
				class="external-link" 
				target="_blank" >
                <code>unimplemented</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    ?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/log/#fatal" 
				class="external-link" 
				target="_blank" >
                <code>log.fatal</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Does not close the program.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="my-implementations" >
    My implementations
</h5>
<pre><code class="language-odin" data-lang="odin">@(require_results)
error_assert :: proc(eval: bool, loc := #caller_location, expr := #caller_expression(eval)) -&gt; bool {
Â  Â  if !eval {
Â  Â  Â  Â  log.errorf("%v(%v): %v", loc.procedure, loc.line, expr)
Â  Â  }
Â  Â  return !eval
}

// Thematically it's the same as assert.
fatal_assert :: proc(eval: bool, loc := #caller_location, expr := #caller_expression(eval)) {
Â  Â  if !eval {
Â  Â  Â  Â  log.fatalf("%v(%v): %v", loc.procedure, loc.line, expr)
Â  Â  Â  Â  runtime.trap()
Â  Â  Â  Â  Â  Â  // Crashes the app.
Â  Â  }
}
</code></pre>
<h2
	id="memory" >
    Memory
</h2>
<ul>
	<li>
		<p>
            Odin does not have a Garbage Collector (GC).
		</p>
	</li>
</ul>
<h3
	id="assignment" >
    Assignment
</h3>
<h5
	id="copy" >
    Copy
</h5>
<ul>
	<li>
		<p>
            &quot;
            <code>a = b</code>
            &nbsp;makes a copy?&quot;
		</p>
		<ul>
			<li>
				<p>
                    It copies 
                    <code>b</code>
                    &nbsp;itself, but if 
                    <code>b</code>
                    &nbsp;is (or contains) a pointer, the data behind that pointer won't get cloned.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Pointers aren't magical. They're values that (can) point to other values.
					</em>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Maps
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Keys and values are 
					<em>
                        always
					</em>
                    &nbsp;copied.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Procedures
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Parameters:
				</p>
				<ul>
					<li>
						<p>
                            Are 
							<em>
                                always
							</em>
                            &nbsp;passed by copy.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Returns:
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            Copy or move?
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="size" >
    Size
</h3>
<ul>
	<li>
		<p>
            The word 
            <code>size</code>
            &nbsp;is used to denote the 
			<strong>
                size in bytes
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            The word 
            <code>length</code>
            &nbsp;is used to denote the count of objects.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#size_of" 
				class="external-link" 
				target="_blank" >
                <code>size_of</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is evaluated at 
					<em>
                        compile-time
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes an expression or type, and returns the size in bytes of the type of the expression if it was hypothetically instantiated as a variable.
				</p>
			</li>
			<li>
				<p>
                    The size does not include any memory possibly referenced by a value.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Slice
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            This would return the size of the internal slice data structure and not the size of the memory referenced by the slice.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Struct
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Return size includes any padding introduced by field alignment (if not specified with 
                            <code>#packed</code>
                            ).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Other types follow similar rules.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#size_of_typeid" 
				class="external-link" 
				target="_blank" >
                <code>reflect.size_of_typeid</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is evaluated at 
					<em>
                        runtime
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    Returns the size of the type that the passed typeid represents
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="memory-leaks" >
    Memory Leaks
</h3>
<ul>
	<li>
		<p>
            If the procedure does not free the memory automatically, then everything that had memory allocated must be returned from the procedure, otherwise we'll have a 
			<strong>
                memory leak
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            While inside a procedure, if I create something on the heap I should 
			<em>
                always
			</em>
            &nbsp;return its pointer and not its value.
		</p>
	</li>
	<li>
		<p>
            If you return by value, you're returning it on the stack; except any pointers that value may contain
		</p>
	</li>
	<li>
		<p>
            The only way to reference allocated memory is by pointer (note that slices, 
            <code>string</code>
            s, etc., have pointers internally, so those count)
		</p>
	</li>
</ul>
<h5
	id="if-a-procedure-allocates-internally" >
    If a procedure allocates internally
</h5>
<ul>
	<li>
		<p>
            Options:
		</p>
		<ol>
			<li>
				<p>
                    Pass an allocator as one of the parameters and return the object that will need freeing.
				</p>
				<ul>
					<li>
						<p>
                            Requiring an allocators is important to avoid &quot;implicit allocations&quot;, which remove the agency from the user and makes easier to get memory leaks by accident, as it's not obvious something needs to be freed unless you read through the procedure implementation. C sometimes does this, which is bad.
						</p>
					</li>
					<li>
						<p>
                            Returning the allocated objects is a must to avoid memory leaks, otherwise the &quot;handle&quot; to the allocation is lost and you'll likely get a memory leak, unless the allocation was made using a Arena allocator, or similar, so by freeing the arena everything allocated with it is freed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Create the object outside and pass the pointer to the object as a parameter.
				</p>
				<ul>
					<li>
						<p>
                            This is a way to avoid a new object being created inside the procedure. It just modifies an existing object, which will know to delete.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
            Will leak.
		</p>
<pre><code class="language-odin" data-lang="odin"> create_data :: proc(allocator: mem.Allocator) -&gt; (data: Data) { 
&nbsp;&nbsp;&nbsp;&nbsp; data_ptr := new(Data, allocator = allocator) 
&nbsp;&nbsp;&nbsp;&nbsp; data_ptr^ = { .. something } 
&nbsp;&nbsp;&nbsp;&nbsp; data = data_ptr^ 
&nbsp;&nbsp;&nbsp;&nbsp; return 
 } 
 my_data := create_data(context.allocator) 
 free(&my_data)
</code></pre>
		<ul>
			<li>
				<p>
                    <code>data = data_ptr^</code>
                    &nbsp;copies the data from the allocation back to the stack, and then the pointer to the allocation is forgotten.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Will not leak:
		</p>
<pre><code class="language-odin" data-lang="odin"> create_data :: proc(allocator: mem.Allocator) -&gt; (data_ptr: ^Data) { 
&nbsp;&nbsp;&nbsp;&nbsp; data_ptr = new(Data, allocator = allocator) 
&nbsp;&nbsp;&nbsp;&nbsp; data_ptr^ = { .. something } 
&nbsp;&nbsp;&nbsp;&nbsp; return
 } 
 my_data_ptr := create_data(context.allocator) 
 free(my_data_ptr)
</code></pre>
	</li>
</ul>
<h3
	id="stack-use-after-return" >
    Stack-Use-After-Return
</h3>
<h5
	id="pointer-to-a-pointer-on-the-stack" >
    Pointer to a pointer on the stack
</h5>
<ul>
	<li>
		<p>
            If I have a procedure that does 
            <code>x: ^int = new_clone(123)</code>
            , if I return 
            <code>&x</code>
            , is this a stack-use-after-return bug?
		</p>
	</li>
	<li>
		<p>
            Pointer or not, 
            <code>x</code>
            &nbsp;is still a local variable, so 
            <code>&x</code>
            &nbsp;would be a pointer 
			<em>
                to
			</em>
            &nbsp;a pointer on the stack, yes. The thing that 
            <code>x</code>
            &nbsp;
			<em>
                points to
			</em>
            , however, is not.
		</p>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<pre><code class="language-odin" data-lang="odin">x_proc :: proc() -&gt; ^int {
Â  Â  x_value: int = 123
Â  Â  return &x_value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `x` is a value stored in the stack, while `&x` is a pointer to a value stored in the stack; this is invalid.
Â  Â  Â  Â  // Compiler Error: It is unsafe to return the address of a local variable ('&x_value') from a procedure, as it uses the current stack frame's memory
}

a_proc :: proc() -&gt; ^int {
Â  Â  a_slice := make([]int, 4, context.temp_allocator)
Â  Â  a_slice[2] = 30
Â  Â  return &a_slice[2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `a_slice[2]` is a value stored in the heap, while `&a_slice[2]` is a pointer to a value stored in the heap, so it's fine.
}

b_proc :: proc() -&gt; (a: any) {
Â  Â  b_slice := make([]int, 4, context.temp_allocator)
Â  Â  b_slice[2] = 30
Â  Â  return b_slice[2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `b_slice[2]` is a value stored in the heap, while `a: any = &b_slice[2]` which is a pointer to a value stored in the heap, so it's fine.
}

c_proc :: proc() -&gt; (a: any) {
Â  Â  c_slice := make([]int, 4, context.temp_allocator)
Â  Â  c_slice[2] = 30
Â  Â  return &c_slice[2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `&c_slice[2]` is a pointer to a value stored in the heap, but `any` created an implicit indirection with `_tmp`.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// So, this ends up being `c.data = &_tmp`, where `_tmp` is in the stack of `c_proc`, so this is invalid.
}

main :: proc() {
Â  Â  a := a_proc()
Â  Â  fmt.printfln("a: Â  Â %v", a) Â  Â  Â  Â  Â  Â // prints an address
Â  Â  fmt.printfln("a^: Â  %v", a^) Â  Â  Â  Â  Â  // prints '30'
Â  Â  
Â  Â  b := b_proc()
Â  Â  fmt.printfln("b: Â  Â  Â  %v", b) Â  Â  Â  Â  // prints '30'
Â  Â  fmt.printfln("b.(): Â  Â %v", b.(int)) Â  // prints '30'
Â  Â  fmt.printfln("b.data: Â %v", b.data) Â  Â // prints an address
Â  Â  // fmt.printfln("b.data^: %v", b.data^) Â  // Not possible to dereference rawptr.
Â  Â  
Â  Â  c := c_proc()
Â  Â  fmt.printfln("c: Â  Â  Â %v", c) Â  Â  Â  Â  Â // Invalid. This is accessing invalid memory; ASan doesn't crash, but it should.
Â  Â  fmt.printfln("c^: Â  Â  %v", c.(^int)) Â  // Invalid. This is accessing invalid memory; ASan doesn't crash, but it should.
&nbsp;&nbsp;&nbsp;&nbsp;Â  Â  // Barinzaya: I wonder if `any`s aren't integrated with ASan.
}
</code></pre>
<h3
	id="use-after-free-uaf" >
    Use-After-Free (UAF)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/odin-lang/Odin/pull/5072" 
				class="external-link" 
				target="_blank" >
                ASan in base:runtime
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="rules-against-uaf" >
    Rules against UAF
</h5>
<ul>
	<li>
		<p>
            I should not create an object inside a procedure and store its address somewhere.
		</p>
		<ul>
			<li>
				<p>
                    As soon as the procedure ends, its address will no longer exist.
				</p>
			</li>
			<li>
				<p>
                    Even if you return the object by address, its address will change once it leaves the procedure's stack.
				</p>
			</li>
			<li>
				<p>
                    See the example 'Question: Tracking allocator doesn't work' for more explanation.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="address-after-free" >
    Address after free
</h5>
<ul>
	<li>
		<p>
            Doesn't change...
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">int_ptr := new(int)
fmt.println(int_ptr)&nbsp;&nbsp; // 0x262CC7B6518
free(int_ptr)
fmt.println(int_ptr)&nbsp;&nbsp; // 0x262CC7B6518
</code></pre>
<h5
	id="question-tracking-allocator-doesnt-work" >
    Question: Tracking allocator doesn't work
</h5>
<ul>
	<li>
		<p>
            Caio:
		</p>
<pre><code class="language-odin" data-lang="odin"> track := init_tracking_allocator()
 
 init_tracking_allocator :: proc() -&gt; mem.Tracking_Allocator { 
&nbsp;&nbsp;&nbsp;&nbsp; track: mem.Tracking_Allocator
&nbsp;&nbsp;&nbsp;&nbsp; mem.tracking_allocator_init(&track, context.allocator) 
&nbsp;&nbsp;&nbsp;&nbsp; context.allocator = mem.tracking_allocator(&track) 
&nbsp;&nbsp;&nbsp;&nbsp; return track
 }
</code></pre>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://odin-lang.org/docs/overview/#implicit-context-system" 
						class="external-link" 
						target="_blank" >
                        Changes to 
                        <code>context</code>
                        &nbsp;are scoped
					</a>
                    , so after 
                    <code>init_tracking_allocator</code>
                    &nbsp;returns, 
                    <code>context.allocator</code>
                    &nbsp;does not change in the caller.
				</p>
			</li>
			<li>
				<p>
                    The 
					<a
						href="https://pkg.odin-lang.org/base/runtime/#Allocator" 
						class="external-link" 
						target="_blank" >
                        <code>Allocator</code>
					</a>
                    &nbsp;contains a pointer to the underlying allocator data, which is on the stack in 
                    <code>init_tracking_allocator</code>
                    &nbsp;(i.e. it's 
                    <code>&track</code>
                    ) and would no longer be valid after that proc returns. Returning it will 
					<em>
                        move
					</em>
                    &nbsp;it, and invalidate the pointer.
				</p>
				<ul>
					<li>
						<p>
                            any time you use 
                            <code>&</code>
                            &nbsp;on a local variable, the resulting pointer is only valid until the proc that variable is in returns. When you hand out a pointer (i.e. to 
                            <code>mem.tracking_allocator</code>
                            ), you need to be aware of how long that pointer needs to remain valid, and make sure that it's long enough
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    wow, that sounds crazy hard to debug, I mean, sure with practice that comes natural, but how can I check for a reference to a pointer used like that? That's been my question for today. What I mean is, I wish there was a way to make such bugs not silent, because for what it seems, it just corrupts the data without giving any indication of such. There was a lot of suggestions to use a debugger or address sanitization, but both this suggestions require me to be actively looking for something, and what scares me is that I'm not good enough with memory to know when this will happen.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tekk:
		</p>
		<ul>
			<li>
				<p>
                    i saw a project like toybox actually use this behavior to record the beginning of the stack, so this kind of bug isnt something a compiler can check for without being extremely annoying. just like in rust, you can cause memory leaks by forgetting the root node of a linked list; the compiler has no idea what's your intention behind that.
				</p>
			</li>
			<li>
				<p>
                    plus, maybe youre creating a small buffer on the stack, so you might actually want an address to a local variable to pass to a procedure
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    It does become natural with practice, but there's just no sure-fire way to catch use-after-free issues that doesn't require actively looking for them. Odin is unmanaged, and memory is, fundamentally, just a large array of bytes, it has no concept of who owns it or what it contains beyond &quot;bytes&quot;. The higher-level concepts that we're used to are just a matter of how those bytes are treated
				</p>
			</li>
			<li>
				<p>
                    The trick often comes down to just making your own life easier. Keep things in arrays, rather than separate allocations, use arenas for things that you know have a limited life-time (particularly deeply-nested structures that you know you'll destroy all at once, but can also be good for e.g. &quot;I won't need this after this frame ends&quot;, for instance). These practices are better not only for you to keep track of, but less work for the CPU to do as well
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            jason:
		</p>
		<ul>
			<li>
				<p>
                    I can attest to what Barinzaya said. It does become natural. I can write an entire program start to finish without making that mistake or really giving it any thought.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Aunt Esther:
		</p>
		<ul>
			<li>
				<p>
                    I may not understand your issue totally, but if you set up ASAN correctly it catches all the below. Not sure there is anything left to check for. Multi-pointer bounds checks are not covered since you are in C-like territory there, but use those with extreme caution and usually for FFI. IMO most people do not understand these four points and options for ASAN use on windows with Odin -- you CAN use ASAN to detect:
				</p>
				<ol>
					<li>
						<p>
                            Heap variable use after free (UAF) -- Odin does not detect this at compile or runtime.
						</p>
					</li>
					<li>
						<p>
                            Stack (local) variable use after free (UAF) at compile time for local intermediate variables assigned to local variables addresses of pointy local variables, e.g. taking the address of an indexed local variable like a local fixed array and assigning to another local variable for return -- Odin does not catch these at compile OR runtime. (note, Odin will error at compile time for local pointer type variables (e.g. fixed array) that directly have their address used as a return value). Historically stack UAF can sometimes prevent false positives (hence the default false setting), but so far it has not in my experience with Odin.
						</p>
					</li>
					<li>
						<p>
                            For all stack UAF detection, you have to set the ASAN variable 
                            <code>detect_stack_use_after_return</code>
                            &nbsp;to 
                            <code>true</code>
                            &nbsp;before you compile (default value if 
                            <code>false</code>
                            &nbsp;otherwise) - see below for an example build command to actuate these stack UAF features.
						</p>
					</li>
					<li>
						<p>
                            Compile time bounds checks for runtime type violations on both the stack and heap. Odin will catch this class of bugs only at runtime. For example a called proc accesses a runtime variable out of bounds.
						</p>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    Here is an example Odin compiler build command for windows
				</p>
				<ul>
					<li>
						<p>
                            <code>set ASAN_OPTIONS=detect_stack_use_after_return=true & odin run . -debug -warnings-as-errors -sanitize:address -vet-unused-variables -vet-unused-imports -vet-shadowing -vet-style -strict-style -vet-semicolon -out:output.exe</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The above for UAF and bounds checks, plus a debugger (for pinpointing) and the tracking allocators (for leaks and bad/double frees) should cover a lot.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Correct code:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">&nbsp;&nbsp;&nbsp;&nbsp;track := init_tracking_allocator()
Â  Â  context.allocator = mem.tracking_allocator(&track)

&nbsp;&nbsp;&nbsp;&nbsp;init_tracking_allocator :: proc() -&gt; mem.Tracking_Allocator {
&nbsp;&nbsp;&nbsp;&nbsp;Â  Â  track: mem.Tracking_Allocator
&nbsp;&nbsp;&nbsp;&nbsp;Â  Â  mem.tracking_allocator_init(&track, context.allocator)
&nbsp;&nbsp;&nbsp;&nbsp;Â  Â  return track
&nbsp;&nbsp;&nbsp;&nbsp;}
</code></pre>
<h3
	id="context" >
    Context
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#implicit-context-system" 
				class="external-link" 
				target="_blank" >
                Implicit Context System
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/odin-lang/Odin/blob/843c39189ef8fb4a65a787643314015b641009d6/base/runtime/core.odin#L697" 
				class="external-link" 
				target="_blank" >
                <code>default_context</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/odin-lang/Odin/blob/843c39189ef8fb4a65a787643314015b641009d6/base/runtime/core.odin#L713" 
						class="external-link" 
						target="_blank" >
                        <code>__init_context</code>
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="usages" >
    Usages
</h5>
<ul>
	<li>
		<p>
            Ginger Bill: &quot;To even call an allocator, you need a 
            <code>context</code>
            .&quot;
		</p>
		<ul>
			<li>
				<p>
                    [2025-11-19]
				</p>
			</li>
			<li>
				<p>
                    Yea, but only because you enforced that. I don't think this was necessary. It just sounds a bit bloated having to carry this information around...
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This is the usages I could find by 
            <code>ctrl+shift+F</code>
            &nbsp;on the whole Odin repository:
		</p>
<pre><code class="language-odin" data-lang="odin"> Context :: struct {
&nbsp;&nbsp;&nbsp;&nbsp; allocator: Â  Â  Â  Â  Â  Â  Â Allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Everywhere.
&nbsp;&nbsp;&nbsp;&nbsp; temp_allocator: Â  Â  Â  Â  Allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Everywhere.
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; assertion_failure_proc: Assertion_Failure_Proc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Used in `assert`, `panic`, `ensure`, `unimplemented`.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Used in `fmt` as: `assertf`, `panicf`, `ensuref`.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Used in `log` as: `assert`, `assertf`, `ensure`, `ensuref`.
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; random_generator: Â  Â  Â  Random_Generator, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Used in `math/rand`, `encoding/uuid`
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; logger: Â  Â  Â  Â  Â  Â  Â  Â  Logger,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // `core:log` is imported for `core:text/table`, `vendor:fontstash`, `vendor:nanovg/gl`.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // `context.logger` is used directly only once in `core:mem` (doesn't make any sense, tbh).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; user_ptr: Â &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rawptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not used anywhere.
&nbsp;&nbsp;&nbsp;&nbsp; user_index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not used anywhere.
&nbsp;&nbsp;&nbsp;&nbsp; _internal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rawptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not used anywhere, except in 1 Cpp script.
 }
</code></pre>
	</li>
</ul>
<h5
	id="context-allocator" >
    context.allocator
</h5>
<ul>
	<li>
		<p>
            For â€œgeneralâ€ allocations, for the subsystem it is used within.
		</p>
	</li>
	<li>
		<p>
            Is an 
			<strong>
                OS heap allocator
			</strong>
            .
		</p>
	</li>
</ul>
<h5
	id="context-temp_allocator" >
    context.temp_allocator
</h5>
<ul>
	<li>
		<p>
            For temporary and short lived allocations, which are to be freed once per cycle/frame/etc.
		</p>
	</li>
	<li>
		<p>
            Assigned to a 
			<strong>
                scratch allocator
			</strong>
            &nbsp;(a growing arena based allocator).
		</p>
	</li>
</ul>
<h5
	id="init" >
    Init
</h5>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
            &nbsp;-&gt; 
            <code>core.odin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@private
__init_context :: proc "contextless" (c: ^Context) {
Â  Â  if c == nil {
Â  Â  Â  Â  return
Â  Â  }
Â  Â  // NOTE(bill): Do not initialize these procedures with a call as they are not defined with the "contextless" calling convention
Â  Â  c.allocator.procedure = default_allocator_proc
Â  Â  c.allocator.data = nil
Â  Â  
Â  Â  c.temp_allocator.procedure = default_temp_allocator_proc
Â  Â  when !NO_DEFAULT_TEMP_ALLOCATOR {
Â  Â  Â  Â  c.temp_allocator.data = &global_default_temp_allocator_data
Â  Â  }
Â  Â  
Â  Â  when !ODIN_DISABLE_ASSERT {
Â  Â  Â  Â  c.assertion_failure_proc = default_assertion_failure_proc
Â  Â  }
Â  Â  
Â  Â  c.logger.procedure = default_logger_proc
Â  Â  c.logger.data = nil
Â  Â  
Â  Â  c.random_generator.procedure = default_random_generator_proc
Â  Â  c.random_generator.data = nil
}
</code></pre>
<h5
	id="threading" >
    Threading
</h5>
<ul>
	<li>
		<p>
            A new context is created using 
            <code>runtime.default_context()</code>
            &nbsp;if not context is specified when calling 
            <code>thread.create_and_start</code>
            .
		</p>
	</li>
	<li>
		<p>
            The new context will 
			<em>
                maybe
			</em>
            &nbsp;clean up its 
            <code>context.temp_allocator</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    Tetra, 2023-05-31:
				</p>
				<ul>
					<li>
						<p>
                            If the user specifies a custom context for the thread, then it's entirely up to them to handle whatever allocators they're using.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// core:thread
_select_context_for_thread :: proc(init_context: Maybe(runtime.Context)) -&gt; runtime.Context {
&nbsp;&nbsp;&nbsp;&nbsp;ctx, ok := init_context.?
&nbsp;&nbsp;&nbsp;&nbsp;if !ok {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return runtime.default_context()
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOTE(tetra, 2023-05-31):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ensure that the temp allocator is thread-safe when the user provides a specific initial context to use.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Without this, the thread will use the same temp allocator state as the parent thread, and thus, bork it up.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;when !ODIN_DEFAULT_TO_NIL_ALLOCATOR {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ctx.temp_allocator.procedure == runtime.default_temp_allocator_proc {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.temp_allocator.data = &runtime.global_default_temp_allocator_data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return ctx
}

// core:thread
_maybe_destroy_default_temp_allocator :: proc(init_context: Maybe(runtime.Context)) {
&nbsp;&nbsp;&nbsp;&nbsp;if init_context != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// NOTE(tetra, 2023-05-31): If the user specifies a custom context for the thread,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// then it's entirely up to them to handle whatever allocators they're using.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if context.temp_allocator.procedure == runtime.default_temp_allocator_proc {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runtime.default_temp_allocator_destroy(auto_cast context.temp_allocator.data)
&nbsp;&nbsp;&nbsp;&nbsp;}
}

// core/thread/thread_windows.odin:41 / core/thread/thread_unix.odin:54
_create :: proc(procedure: Thread_Proc, priority: Thread_Priority) -&gt; ^Thread {
&nbsp;&nbsp;&nbsp;&nbsp;// etc
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context = _select_context_for_thread(init_context)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_maybe_destroy_default_temp_allocator(init_context)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runtime.run_thread_local_cleaners()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.procedure(t)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//etc
}
</code></pre>
<h2
	id="memory-address" >
    Memory: Address
</h2>
<h3
	id="pointers" >
    Pointers
</h3>
<ul>
	<li>
		<p>
            A 
			<strong>
                pointer
			</strong>
            &nbsp;is an abstraction of an 
			<strong>
                address
			</strong>
            , a numberic value representing the location of an object in memory. That object is said to be pointed to by the pointer. To obtain the address of a pointer, cast it to 
            <code>uintptr</code>
            .
		</p>
	</li>
	<li>
		<p>
            When an object's values are read through a pointer, that operation is called a 
			<em>
                load
			</em>
            &nbsp;operation. When memory is written to through a pointer, that operation is called a 
			<strong>
                store
			</strong>
            &nbsp;operation. Both of these operations can be called a 
			<em>
                memory access operation
			</em>
            .
		</p>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            Symbol 
            <code>^</code>
            .
		</p>
	</li>
	<li>
		<p>
            No &quot;pointer arithmetic&quot;.
		</p>
	</li>
	<li>
		<p>
            The zero value of a pointer: 
            <code>nil</code>
            .
		</p>
	</li>
</ul>
<h5
	id="multi-pointer" >
    Multi-pointer
</h5>
<ul>
	<li>
		<p>
            A multi-pointer is a pointer that points to multiple objects. Unlike a pointer, a multi-pointer can be indexed, but does not have a definite length.
		</p>
	</li>
</ul>
<h5
	id="slice" >
    Slice
</h5>
<ul>
	<li>
		<p>
            A slice is a pointer that points to multiple objects equipped with the length, specifying the amount of objects a slice points to.
		</p>
	</li>
</ul>
<h5
	id="implicit-dereference" >
    Implicit Dereference
</h5>
<ul>
	<li>
		<p>
			<em>
                Pointer to a struct
			</em>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> v := Vector2{1, 2}
 p := &v
 p.x = 1335
 fmt.println(v)
</code></pre>
		<ul>
			<li>
				<p>
                    We could write 
                    <code>p^.x</code>
                    , however, it is nice not to have to explicitly dereference the pointer.
				</p>
			</li>
			<li>
				<p>
                    This is very useful when refactoring code to use a pointer rather than a value, and vice versa.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Pointer to an array
			</em>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> ptr_to_array[index] == ptr_to_array^[index]
</code></pre>
	</li>
</ul>
<h5
	id="implicit-pointer-to-the-stack" >
    Implicit pointer to the stack
</h5>
<pre><code class="language-odin" data-lang="odin">a := &My_Struct{}

// Is equivalent to

_a := My_Struct{} // not actually named, just for the example's sake
a := &_a
</code></pre>
<h3
	id="zero-by-default" >
    Zero by default
</h3>
<ul>
	<li>
		<p>
            Whenever new memory is allocated, via an allocator, or on the stack, by default Odin will zero-initialize that memory, even if it wasn't explicitly initialized. This allows for some convenience in certain scenarios and ease of debugging, which will not be described in detail here.
		</p>
	</li>
	<li>
		<p>
            However zero-initialization can be a cause of slowdowns, when allocating large buffers. For this reason, allocators have 
            <code>*_non_zeroed</code>
            &nbsp;modes of allocation that allow the user to request for uninitialized memory and will avoid a relatively expensive zero-filling of the buffer.
		</p>
	</li>
</ul>
<h3
	id="alignment" >
    Alignment
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/base/builtin/#align_of" 
				class="external-link" 
				target="_blank" >
                <code>align_of(typeid) -&gt; int</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is evaluated at 
					<em>
                        compile-time
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    Takes an expression or type, and returns the alignment in bytes of the type of the expression if it was hypothetically instantiated as a variable 
                    <code>v</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            I guess this means
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It is the largest value 
                    <code>m</code>
                    &nbsp;such that the address of 
                    <code>v</code>
                    &nbsp;is always 
                    <code>0 mod m</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            All this effectively means &quot;the address of 
                            <code>v</code>
                            &nbsp;is always a multiple of 
                            <code>m</code>
                            &quot;; so 
                            <code>uintptr(&t) % align_of(t) == 0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            This also implies 
                            <code>size_of(T) % align_of(T) == 0</code>
                            , which means that &quot;the size is a multiple of the alignment&quot;.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Notation 
                                <code>a â‰¡ r (mod m)</code>
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <code>â‰¡ (mod m)</code>
                                    &nbsp;means equality up to a multiple of 
                                    <code>m</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Is read as: 
                                    <code>a</code>
                                    &nbsp;is congruent to 
                                    <code>r modulo m</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Two numbers are 
											<em>
                                                congruent modulo m
											</em>
                                            &nbsp;if they give the 
											<em>
                                                same remainder
											</em>
                                            &nbsp;when divided by 
                                            <code>m</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Formally, it means: 
                                    <code>m</code>
                                    &nbsp;divides 
                                    <code>(a - r)</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Or equivalently: 
                                    <code>a âˆ’ r = kâ‹…m</code>
                                    &nbsp;forÂ someÂ integerÂ 
                                    <code>k</code>
                                    .
								</p>
							</li>
							<li>
								<p>
									<strong>
                                        Ex
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            <code>17 â‰¡ 5Â (modÂ 12)</code>
										</p>
										<ul>
											<li>
												<p>
                                                    <code>17âˆ’5=12</code>
                                                    , which is a multiple of 
                                                    <code>12</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>a â‰¡ 0 (mod m)</code>
										</p>
										<ul>
											<li>
												<p>
                                                    <code>a âˆ’ 0 = a</code>
                                                    , so 
                                                    <code>a</code>
                                                    &nbsp;must be divisible by 
                                                    <code>m</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/reflect/#align_of_typeid" 
				class="external-link" 
				target="_blank" >
                <code>reflect.align_of_typeid(typeid) -&gt; int</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is evaluated at 
					<em>
                        runtime
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    Returns the alignment of the type that the passed typeid represents.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="memory-allocators" >
    Memory: Allocators
</h2>
<pre><code class="language-odin" data-lang="odin">Allocator :: struct {
Â  Â  procedure: Allocator_Proc,
Â  Â  data: Â  Â  Â rawptr,
}
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=GZ6PuLikw84" 
				class="external-link" 
				target="_blank" >
                Allocators, Linear Allocators, Fragmentation, Stack Allocators - Nic Barker
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    To improve the fragmentation from Linear Allocators, the memory region is divided by blocks.
				</p>
			</li>
			<li>
				<p>
                    Memory that is all together, with sequentially increasing addresses as 
					<strong>
                        Contiguous
					</strong>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="why-use-allocators" >
    Why use allocators
</h5>
<ul>
	<li>
		<p>
            In C and C++ memory models, allocations of objects in memory are typically treated individually with a generic allocator (The 
            <code>malloc</code>
            &nbsp;procedure). Which in some scenarios can lead to poor cache utilization, slowdowns on individual objects' memory management and growing complexity of the code needing to keep track of the pointers and their lifetimes.
		</p>
	</li>
	<li>
		<p>
            Using different kinds of 
			<em>
                allocators
			</em>
            &nbsp;for different purposes can solve these problems. The allocators are typically optimized for specific use-cases and can potentially simplify the memory management code.
		</p>
	</li>
	<li>
		<p>
            For example, in the context of making a game, having an Arena allocator could simplify allocations of any temporary memory, because the programmer doesn't have to keep track of which objects need to be freed every time they are allocated, because at the end of every frame the whole allocator is reset to its initial state and all objects are freed at once.
		</p>
	</li>
	<li>
		<p>
            The allocators have different kinds of restrictions on object lifetimes, sizes, alignment and can be a significant gain, if used properly. Odin supports allocators on a language level.
		</p>
	</li>
	<li>
		<p>
            Operations such as 
            <code>new</code>
            , 
            <code>free</code>
            &nbsp;and 
            <code>delete</code>
            &nbsp;by default will use 
            <code>context.allocator</code>
            , which can be overridden by the user. When an override happens all called procedures will inherit the new context and use the same allocator.
		</p>
	</li>
	<li>
		<p>
            We will define one concept to simplify the description of some allocator-related procedures, which is ownership. If the memory was allocated via a specific allocator, that allocator is said to be the 
			<em>
                owner
			</em>
            &nbsp;of that memory region. To note, unlike Rust, in Odin the memory ownership model is not strict.
		</p>
	</li>
</ul>
<h5
	id="notes" >
    Notes
</h5>
<ul>
	<li>
		<p>
            There are some allocator requirements for 
            <code>map</code>
            s; see the 
			<a
				href="#Maps%20(Hash%20Maps)" 
				class="external-link" 
				target="_blank" >
                Maps (Hash Maps)
			</a>
            &nbsp;section.
		</p>
	</li>
	<li>
		<p>
            &quot;Arenas and Dynamic Allocators together can sometimes be inefficient&quot;.
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=1WnqZPD-qVc" 
						class="external-link" 
						target="_blank" >
                        Arenas + Dynamic Allocators
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    I didn't fully understand the concept.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="implicit-allocator-usage" >
    Implicit Allocator Usage
</h3>
<h5
	id="for-codecontext-allocator-code" >
    For 
    <code>context.allocator</code>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
            <code>runtime.default_allocator()</code>
		</p>
		<ul>
			<li>
				<p>
                    Only used if the 
                    <code>context.temp_allocator</code>
                    &nbsp;is not manually initialized.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
            <code>runtime.heap_allocator()</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    Used a lot around 
                    <code>os2</code>
                    &nbsp;and 
                    <code>os</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>TEMP_ALLOCATOR_GUARD</code>
				</p>
				<ul>
					<li>
						<p>
                            if the 
                            <code>context.temp_allocator</code>
                            &nbsp;is not manually initialized.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>os2._env: [dynamic]string</code>
                    &nbsp;in the 
                    <code>os2/env_linux.odin</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>os2.get_args()</code>
                    &nbsp;/ 
                    <code>os2.delete_args()</code>
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>os2.file_allocator()</code>
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            
                            <code>os2.walkers</code>
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            etc, a LOT of places inside the 
                            <code>os2</code>
                            &nbsp;lib.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
            <code>os.args</code>
		</p>
		<ul>
			<li>
				<p>
                    Uses it implicitly.
				</p>
			</li>
			<li>
				<p>
                    This is fixed by using 
                    <code>os2</code>
                    , which still uses a heap allocator implicitly, but at least is not the 
                    <code>context.allocator</code>
                    , but the 
                    <code>os2.heap_allocator</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            It's technically the same thing, but at least this doesn't break 
                            <code>-default-to-panic-allocator</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="for-codecontext-temp_allocator-code" >
    For 
    <code>context.temp_allocator</code>
</h5>
<ul>
	<li>
		<p>
			<em>
                Conclusion
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>context.temp_allocator</code>
                    &nbsp;/ 
                    <code>runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD</code>
                    &nbsp;is used implicitly A LOT inside the 
                    <code>core</code>
                    &nbsp;libraries.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>base</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Nothing uses it. Just definition.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>core</code>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>compress/common</code>
				</p>
				<ul>
					<li>
						<p>
                            Has 
							<em>
                                todo
							</em>
                            s to remove it.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>encoding/json</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>encoding/xml</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>fmt</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>image/jpeg</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>image/netbpm</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly with guard.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>image/png</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly with guard.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>net</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>odin/parser</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>os</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly with guard.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>os/os2</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly with guard.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>path/filepath</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly with guard.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>path/slashpath</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly with guard.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>sys/windows</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>sys/darwin</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>sys/info</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>sys/orca</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
                    <code>testing</code>
				</p>
				<ul>
					<li>
						<p>
                            Uses implicitly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>encoding/cbor</code>
				</p>
				<ul>
					<li>
						<p>
                            It's overridable in the parameters.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            
                            <code>cbor/tags.odin</code>
                            , wtf?
						</p>
						<ul>
							<li>
								<p>
                                    I'm seeing 
                                    <code>delete</code>
                                    &nbsp;with 
                                    <code>context.temp_allocator</code>
                                    ...
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The library is really messy.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>container</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            It's overridable in the parameters.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>container/kmac</code>
				</p>
				<ul>
					<li>
						<p>
                            It's overridable in the parameters.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>dynlib</code>
				</p>
				<ul>
					<li>
						<p>
                            It's overridable in the parameters.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>thread</code>
				</p>
				<ul>
					<li>
						<p>
                            Deletes the 
                            <code>context.temp_allocator</code>
                            &nbsp;if set.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="default-allocators" >
    Default Allocators
</h3>
<ul>
	<li>
		<p>
            For 
            <code>context.allocator</code>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> when ODIN_DEFAULT_TO_NIL_ALLOCATOR {
 Â  Â  default_allocator_proc :: nil_allocator_proc
 Â  Â  default_allocator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: nil_allocator
 } else when ODIN_DEFAULT_TO_PANIC_ALLOCATOR {
 Â  Â  default_allocator_proc :: panic_allocator_proc
 Â  Â  default_allocator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: panic_allocator
 } else when ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32) {
 Â  Â  default_allocator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: default_wasm_allocator
 Â  Â  default_allocator_proc :: wasm_allocator_proc
 } else {
 Â  Â  default_allocator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: heap_allocator
 Â  Â  default_allocator_proc :: heap_allocator_proc
 }
</code></pre>
	</li>
	<li>
		<p>
            For 
            <code>context.temp_allocator</code>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> when NO_DEFAULT_TEMP_ALLOCATOR {
 Â  Â  default_temp_allocator_proc :: nil_allocator_proc
 } else {
&nbsp;&nbsp;&nbsp;&nbsp; default_temp_allocator_proc :: proc(allocator_data: rawptr, mode: Allocator_Mode,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size, alignment: int,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_memory: rawptr, old_size: int, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s := (^Default_Temp_Allocator)(allocator_data)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return arena_allocator_proc(&s.arena, mode, size, alignment, old_memory, old_size, loc)
&nbsp;&nbsp;&nbsp;&nbsp; }
 }
</code></pre>
	</li>
	<li>
		<p>
            Both are used here:
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">__init_context :: proc "contextless" (c: ^Context) {
&nbsp;&nbsp;&nbsp;&nbsp;// etc
&nbsp;&nbsp;&nbsp;&nbsp;c.allocator.procedure = default_allocator_proc
&nbsp;&nbsp;&nbsp;&nbsp;c.allocator.data = nil
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;c.temp_allocator.procedure = default_temp_allocator_proc
&nbsp;&nbsp;&nbsp;&nbsp;when !NO_DEFAULT_TEMP_ALLOCATOR {
Â  Â  Â  Â  c.temp_allocator.data = &global_default_temp_allocator_data
Â  Â  }
&nbsp;&nbsp;&nbsp;&nbsp;// etcÂ  Â 
}
</code></pre>
<h3
	id="nil-allocator" >
    Nil Allocator
</h3>
<ul>
	<li>
		<p>
            The 
            <code>nil</code>
            &nbsp;allocator returns 
            <code>nil</code>
            &nbsp;on every allocation attempt. This type of allocator can be used in scenarios where memory doesn't need to be allocated, but an attempt to allocate memory is not an error.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
nil_allocator :: proc() -&gt; Allocator {
Â  Â  return Allocator{
Â  Â  Â  Â  procedure = nil_allocator_proc,
Â  Â  Â  Â  data Â  Â  Â = nil,
Â  Â  }
}

nil_allocator_proc :: proc(
Â  Â  allocator_data: Â rawptr,
Â  Â  mode: Â  Â  Â  Â  Â  Â Allocator_Mode,
Â  Â  size, alignment: int,
Â  Â  old_memory: Â  Â  Â rawptr,
Â  Â  old_size: Â  Â  Â  Â int,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) {
Â  Â  return nil, nil
}
</code></pre>
<h5
	id="default-to-nil" >
    Default to Nil
</h5>
<ul>
	<li>
		<p>
            Use 
            <code>-default-to-nil-allocator</code>
            &nbsp;as a compilation flag.
		</p>
	</li>
	<li>
		<p>
            Keep in mind: 
            <code>-default-to-panic-allocator</code>
            &nbsp;cannot be used with 
            <code>-default-to-nil-allocator</code>
            .
		</p>
	</li>
</ul>
<h3
	id="panic-allocator" >
    Panic Allocator
</h3>
<ul>
	<li>
		<p>
            The panic allocator is a type of allocator that panics on any allocation attempt. This type of allocator can be used in scenarios where memory should not be allocated, and an attempt to allocate memory is an error.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// basically the same as the Nil Allocator, but panics.
</code></pre>
<h5
	id="uses" >
    Uses
</h5>
<ul>
	<li>
		<p>
			<strong>
                To ensure explicit allocators, different from 
                <code>context.allocator</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You could set 
                    <code>context.allocator</code>
                    &nbsp;to a 
                    <code>runtime.panic_allocator()</code>
                    &nbsp;so that if anything uses it by accident it'll panic, then pass your allocator around explicitly.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="default-to-panic" >
    Default to Panic
</h5>
<ul>
	<li>
		<p>
            Use 
            <code>-default-to-panic-allocator</code>
            &nbsp;as a compilation flag.
		</p>
	</li>
	<li>
		<p>
            Keep in mind: 
            <code>-default-to-panic-allocator</code>
            &nbsp;cannot be used with 
            <code>-default-to-nil-allocator</code>
            .
		</p>
	</li>
</ul>
<h3
	id="arena-backed-directly-by-virtual-memory-codevmem-arena-code" >
    Arena: Backed directly by virtual memory (
    <code>vmem.Arena</code>
    )
</h3>
<ul>
	<li>
		<p>
            Reserving virtual memory does not increase memory usage. It goes up when the dynamic array actually grows into that reserved space.
		</p>
	</li>
	<li>
		<p>
            Uses virtual memory 
			<em>
                directly
			</em>
            , whereas the arenas in mem use a 
            <code>[]byte</code>
            &nbsp;or 
            <code>[dynamic]byte</code>
            &nbsp;for their memory, so they basically still exist inside the heap allocator.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/karl-zylinski/odin-handle-map?tab=readme-ov-file#which-variant-should-i-use" 
				class="external-link" 
				target="_blank" >
                How virtual arenas are used in odin-handle-map
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// Create an `Allocator` from the provided `Arena`
@(require_results, no_sanitize_address)
arena_allocator :: proc(arena: ^Arena) -&gt; mem.Allocator {
Â  Â  return mem.Allocator{arena_allocator_proc, arena}
}
</code></pre>
<h5
	id="kind-code-static-code" >
    kind 
    <code>.Static</code>
</h5>
<ul>
	<li>
		<p>
            Contains a single 
            <code>Memory_Block</code>
            &nbsp;allocated with virtual memory.
		</p>
	</li>
</ul>
<h5
	id="kind-code-growing-code" >
    kind 
    <code>.Growing</code>
</h5>
<ul>
	<li>
		<p>
            Is a linked list of 
            <code>Memory_Block</code>
            s allocated with virtual memory.
		</p>
	</li>
	<li>
		<p>
            Allows for 
            <code>vmem.Arena_Temp</code>
            &nbsp;which can call 
            <code>vmem.arena_growing_free_last_memory_block</code>
            , shrinking itself, from my understanding.
		</p>
	</li>
</ul>
<h5
	id="kind-code-buffer-code" >
    <s>kind 
    <code>.Buffer</code>
    </s>
</h5>
<ul>
	<li>
		<p>
            I'm not using this one, seems redundant. Just use 
            <code>mem.Arena</code>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Demo
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250402091802.png" width="525" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Discussion
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            Is the arena buffer from 
                            <code>mem/virtual</code>
                            &nbsp;actually virtual? I'm confused as the buffer is externally passed to 
                            <code>arena_init_buffer</code>
                            , and for what I was able to understand, the memory is never committed.
						</p>
					</li>
					<li>
						<p>
                            I mean, isn't a 
                            <code>mem.Arena</code>
                            &nbsp;more efficient, as it avoids unnecessary checks for something that will never be committed? They both seem to do the same thing, while 
                            <code>mem/virtual</code>
                            &nbsp;buffer uses the concept of 
                            <code>Memory_Blocks</code>
                            &nbsp;as an abstraction, but it doesn't seem to matter in this case
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Barinzaya:
				</p>
				<ul>
					<li>
						<p>
                            <code>buffer</code>
                            &nbsp;is one mode, but in that one 
							<em>
                                you
							</em>
                            &nbsp;provide the memory. The other modes (the default 
                            <code>growing</code>
                            &nbsp;as well as 
                            <code>static</code>
                            ) do their own allocation, indeed using virtual memory.
						</p>
					</li>
					<li>
						<p>
                            I guess it's just a matter of flexibility. It already has a mode to check anyway, and a lot of the logic is the same, so I guess it's a &quot;might as well&quot;--though I do find 
                            <code>virtual.Arena</code>
                            &nbsp;to be trying to do a bit too much myself
						</p>
					</li>
					<li>
						<p>
                            In the bigger picture, using the same code for both 
							<em>
                                could
							</em>
                            &nbsp;prove beneficial in terms of instruction cache, even if the code is less specialized
						</p>
					</li>
					<li>
						<p>
                            If you're actually 
							<em>
                                using
							</em>
                            &nbsp;it in both modes, that is.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="bootstrapping" >
    Bootstrapping
</h5>
<pre><code class="language-odin" data-lang="odin">// Ability to bootstrap allocate a struct with an arena within the struct itself using the growing variant strategy.
arena_growing_bootstrap_new :: proc{
Â  Â  arena_growing_bootstrap_new_by_offset,
Â  Â  arena_growing_bootstrap_new_by_name,
}

// Ability to bootstrap allocate a struct with an arena within the struct itself using the static variant strategy.
arena_static_bootstrap_new :: proc{
Â  Â  arena_static_bootstrap_new_by_offset,
Â  Â  arena_static_bootstrap_new_by_name,
}
</code></pre>
<h5
	id="alloc-from-memory-block" >
    Alloc from Memory Block
</h5>
<ul>
	<li>
		<p>
            Allocates memory from the provided arena.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results, no_sanitize_address, private)
arena_alloc_unguarded :: proc(arena: ^Arena, size: uint, alignment: uint, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  size := size
Â  Â  if size == 0 {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  switch arena.kind {
Â  Â  case .Growing:
Â  Â  Â  Â  prev_used := 0 if arena.curr_block == nil else arena.curr_block.used
Â  Â  Â  Â  data, err = alloc_from_memory_block(arena.curr_block, size, alignment, default_commit_size=arena.default_commit_size)
Â  Â  Â  Â  if err == .Out_Of_Memory {
Â  Â  Â  Â  Â  Â  if arena.minimum_block_size == 0 {
Â  Â  Â  Â  Â  Â  Â  Â  arena.minimum_block_size = DEFAULT_ARENA_GROWING_MINIMUM_BLOCK_SIZE
Â  Â  Â  Â  Â  Â  Â  Â  arena.minimum_block_size = mem.align_forward_uint(arena.minimum_block_size, DEFAULT_PAGE_SIZE)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if arena.default_commit_size == 0 {
Â  Â  Â  Â  Â  Â  Â  Â  arena.default_commit_size = min(DEFAULT_ARENA_GROWING_COMMIT_SIZE, arena.minimum_block_size)
Â  Â  Â  Â  Â  Â  Â  Â  arena.default_commit_size = mem.align_forward_uint(arena.default_commit_size, DEFAULT_PAGE_SIZE)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if arena.default_commit_size != 0 {
Â  Â  Â  Â  Â  Â  Â  Â  arena.default_commit_size, arena.minimum_block_size =
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  min(arena.default_commit_size, arena.minimum_block_size),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  max(arena.default_commit_size, arena.minimum_block_size)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  needed := mem.align_forward_uint(size, alignment)
Â  Â  Â  Â  Â  Â  needed = max(needed, arena.default_commit_size)
Â  Â  Â  Â  Â  Â  block_size := max(needed, arena.minimum_block_size)
Â  Â  Â  Â  Â  Â  new_block := memory_block_alloc(needed, block_size, alignment, {}) or_return
Â  Â  Â  Â  Â  Â  new_block.prev = arena.curr_block
Â  Â  Â  Â  Â  Â  arena.curr_block = new_block
Â  Â  Â  Â  Â  Â  arena.total_reserved += new_block.reserved
Â  Â  Â  Â  Â  Â  prev_used = 0
Â  Â  Â  Â  Â  Â  data, err = alloc_from_memory_block(arena.curr_block, size, alignment, default_commit_size=arena.default_commit_size)
Â  Â  Â  Â  }
Â  Â  Â  Â  arena.total_used += arena.curr_block.used - prev_used
Â  Â  case .Static:
Â  Â  Â  Â  if arena.curr_block == nil {
Â  Â  Â  Â  Â  Â  if arena.minimum_block_size == 0 {
Â  Â  Â  Â  Â  Â  Â  Â  arena.minimum_block_size = DEFAULT_ARENA_STATIC_RESERVE_SIZE
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  arena_init_static(arena, reserved=arena.minimum_block_size, commit_size=DEFAULT_ARENA_STATIC_COMMIT_SIZE) or_return
Â  Â  Â  Â  }
Â  Â  Â  Â  if arena.curr_block == nil {
Â  Â  Â  Â  Â  Â  return nil, .Out_Of_Memory
Â  Â  Â  Â  }
Â  Â  Â  Â  data, err = alloc_from_memory_block(arena.curr_block, size, alignment, default_commit_size=arena.default_commit_size)
Â  Â  Â  Â  arena.total_used = arena.curr_block.used
Â  Â  case .Buffer:
Â  Â  Â  Â  if arena.curr_block == nil {
Â  Â  Â  Â  Â  Â  return nil, .Out_Of_Memory
Â  Â  Â  Â  }
Â  Â  Â  Â  data, err = alloc_from_memory_block(arena.curr_block, size, alignment, default_commit_size=0)
Â  Â  Â  Â  arena.total_used = arena.curr_block.used
Â  Â  }
Â  Â  // sanitizer.address_unpoison(data)
Â  Â  return
}

@(require_results, no_sanitize_address)
alloc_from_memory_block :: proc(block: ^Memory_Block, min_size, alignment: uint, default_commit_size: uint = 0) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  @(no_sanitize_address)
Â  Â  calc_alignment_offset :: proc "contextless" (block: ^Memory_Block, alignment: uintptr) -&gt; uint {
Â  Â  Â  Â  alignment_offset := uint(0)
Â  Â  Â  Â  ptr := uintptr(block.base[block.used:])
Â  Â  Â  Â  mask := alignment-1
Â  Â  Â  Â  if ptr & mask != 0 {
Â  Â  Â  Â  Â  Â  alignment_offset = uint(alignment - (ptr & mask))
Â  Â  Â  Â  }
Â  Â  Â  Â  return alignment_offset
Â  Â  }
Â  Â  @(no_sanitize_address)
Â  Â  do_commit_if_necessary :: proc(block: ^Memory_Block, size: uint, default_commit_size: uint) -&gt; (err: Allocator_Error) {
Â  Â  Â  Â  if block.committed - block.used &lt; size {
Â  Â  Â  Â  Â  Â  pmblock := (^Platform_Memory_Block)(block)
Â  Â  Â  Â  Â  Â  base_offset := uint(uintptr(pmblock.block.base) - uintptr(pmblock))
Â  Â  Â  Â  Â  Â  // NOTE(bill): [Heuristic] grow the commit size larger than needed
Â  Â  Â  Â  Â  Â  // TODO(bill): determine a better heuristic for this behaviour
Â  Â  Â  Â  Â  Â  extra_size := max(size, block.committed&gt;&gt;1)
Â  Â  Â  Â  Â  Â  platform_total_commit := base_offset + block.used + extra_size
Â  Â  Â  Â  Â  Â  platform_total_commit = align_formula(platform_total_commit, DEFAULT_PAGE_SIZE)
Â  Â  Â  Â  Â  Â  platform_total_commit = min(max(platform_total_commit, default_commit_size), pmblock.reserved)
Â  Â  Â  Â  Â  Â  assert(pmblock.committed &lt;= pmblock.reserved)
Â  Â  Â  Â  Â  Â  assert(pmblock.committed &lt; platform_total_commit)
Â  Â  Â  Â  Â  Â  platform_memory_commit(pmblock, platform_total_commit) or_return
Â  Â  Â  Â  Â  Â  pmblock.committed = platform_total_commit
Â  Â  Â  Â  Â  Â  block.committed = pmblock.committed - base_offset
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  }
Â  Â  if block == nil {
Â  Â  Â  Â  return nil, .Out_Of_Memory
Â  Â  }
Â  Â  alignment_offset := calc_alignment_offset(block, uintptr(alignment))
Â  Â  size, size_ok := safe_add(min_size, alignment_offset)
Â  Â  if !size_ok {
Â  Â  Â  Â  err = .Out_Of_Memory
Â  Â  Â  Â  return
Â  Â  }
Â  Â  if to_be_used, ok := safe_add(block.used, size); !ok || to_be_used &gt; block.reserved {
Â  Â  Â  Â  err = .Out_Of_Memory
Â  Â  Â  Â  return
Â  Â  }
Â  Â  assert(block.committed &lt;= block.reserved)
Â  Â  do_commit_if_necessary(block, size, default_commit_size) or_return
Â  Â  data = block.base[block.used+alignment_offset:][:min_size]
Â  Â  block.used += size
Â  Â  // sanitizer.address_unpoison(data)
Â  Â  return
}

@(require_results, no_sanitize_address)
arena_alloc :: proc(arena: ^Arena, size: uint, alignment: uint, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(alignment & (alignment-1) == 0, "non-power of two alignment", loc)
Â  Â  size := size
Â  Â  if size == 0 {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  sync.mutex_guard(&arena.mutex)
Â  Â  return arena_alloc_unguarded(arena, size, alignment, loc)
}

@(no_sanitize_address)
arena_allocator_proc :: proc(allocator_data: rawptr, mode: mem.Allocator_Mode,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â size, alignment: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â old_memory: rawptr, old_size: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â location := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  switch mode {
Â  Â  case .Resize, .Resize_Non_Zeroed:
Â  Â  Â  Â  // etc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ = alloc_from_memory_block(block, new_end - old_end, 1, default_commit_size=arena.default_commit_size) or_return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// etc
Â  Â  Â  Â  new_memory := arena_alloc_unguarded(arena, size, alignment, location) or_return
Â  Â  }
Â  Â  return
}
</code></pre>
<h5
	id="memory-block-alloc" >
    Memory Block Alloc
</h5>
<pre><code class="language-odin" data-lang="odin">// Linux
_commit :: proc "contextless" (data: rawptr, size: uint) -&gt; Allocator_Error {
Â  Â  errno := linux.mprotect(data, size, {.READ, .WRITE})
Â  Â  if errno == .EINVAL {
Â  Â  Â  Â  return .Invalid_Pointer
Â  Â  } else if errno == .ENOMEM {
Â  Â  Â  Â  return .Out_Of_Memory
Â  Â  }
Â  Â  return nil
}

// Windows
@(no_sanitize_address)
_commit :: proc "contextless" (data: rawptr, size: uint) -&gt; Allocator_Error {
Â  Â  result := VirtualAlloc(data, size, MEM_COMMIT, PAGE_READWRITE)
Â  Â  if result == nil {
Â  Â  Â  Â  switch err := GetLastError(); err {
Â  Â  Â  Â  case 0:
Â  Â  Â  Â  Â  Â  return .Invalid_Argument
Â  Â  Â  Â  case ERROR_INVALID_ADDRESS, ERROR_COMMITMENT_LIMIT:
Â  Â  Â  Â  Â  Â  return .Out_Of_Memory
Â  Â  Â  Â  }
Â  Â  Â  Â  return .Out_Of_Memory
Â  Â  }
Â  Â  return nil
}

@(no_sanitize_address)
commit :: proc "contextless" (data: rawptr, size: uint) -&gt; Allocator_Error {
Â  Â  // sanitizer.address_unpoison(data, size)
Â  Â  return _commit(data, size)
}

// Linux
_reserve :: proc "contextless" (size: uint) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  addr, errno := linux.mmap(0, size, {}, {.PRIVATE, .ANONYMOUS})
Â  Â  if errno == .ENOMEM {
Â  Â  Â  Â  return nil, .Out_Of_Memory
Â  Â  } else if errno == .EINVAL {
Â  Â  Â  Â  return nil, .Invalid_Argument
Â  Â  }
Â  Â  return (cast([^]byte)addr)[:size], nil
}

// Windows
@(no_sanitize_address)
_reserve :: proc "contextless" (size: uint) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  result := VirtualAlloc(nil, size, MEM_RESERVE, PAGE_READWRITE)
Â  Â  if result == nil {
Â  Â  Â  Â  err = .Out_Of_Memory
Â  Â  Â  Â  return
Â  Â  }
Â  Â  data = ([^]byte)(result)[:size]
Â  Â  return
}

@(require_results, no_sanitize_address)
reserve :: proc "contextless" (size: uint) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  return _reserve(size)
}

@(no_sanitize_address)
platform_memory_alloc :: proc "contextless" (to_commit, to_reserve: uint) -&gt; (block: ^Platform_Memory_Block, err: Allocator_Error) {
Â  Â  to_commit, to_reserve := to_commit, to_reserve
Â  Â  to_reserve = max(to_commit, to_reserve)
Â  Â  
Â  Â  total_to_reserved := max(to_reserve, size_of(Platform_Memory_Block))
Â  Â  to_commit = clamp(to_commit, size_of(Platform_Memory_Block), total_to_reserved)
Â  Â  
Â  Â  data := reserve(total_to_reserved) or_return
Â  Â  
Â  Â  commit_err := commit(raw_data(data), to_commit)
Â  Â  assert_contextless(commit_err == nil)
Â  Â  
Â  Â  block = (^Platform_Memory_Block)(raw_data(data))
Â  Â  block.committed = to_commit
Â  Â  block.reserved Â = to_reserve
Â  Â  return
}

@(require_results, no_sanitize_address)
memory_block_alloc :: proc(committed, reserved: uint, alignment: uint = 0, flags: Memory_Block_Flags = {}) -&gt; (block: ^Memory_Block, err: Allocator_Error) {
Â  Â  page_size := DEFAULT_PAGE_SIZE
Â  Â  assert(mem.is_power_of_two(uintptr(page_size)))
Â  Â  
Â  Â  committed := committed
Â  Â  reserved Â := reserved
Â  Â  
Â  Â  committed = align_formula(committed, page_size)
Â  Â  reserved Â = align_formula(reserved, page_size)
Â  Â  committed = clamp(committed, 0, reserved)
Â  Â  
Â  Â  total_size Â  Â  := reserved + alignment + size_of(Platform_Memory_Block)
Â  Â  base_offset Â  Â := mem.align_forward_uintptr(size_of(Platform_Memory_Block), max(uintptr(alignment), align_of(Platform_Memory_Block)))
Â  Â  protect_offset := uintptr(0)
Â  Â  
Â  Â  do_protection := false
Â  Â  if .Overflow_Protection in flags { // overflow protection
Â  Â  Â  Â  rounded_size Â  := reserved
Â  Â  Â  Â  total_size Â  Â  = uint(rounded_size + 2*page_size)
Â  Â  Â  Â  base_offset Â  Â = uintptr(page_size + rounded_size - uint(reserved))
Â  Â  Â  Â  protect_offset = uintptr(page_size + rounded_size)
Â  Â  Â  Â  do_protection Â = true
Â  Â  }
Â  Â  
Â  Â  pmblock := platform_memory_alloc(0, total_size) or_return
Â  Â  
Â  Â  pmblock.block.base = ([^]byte)(pmblock)[base_offset:]
Â  Â  platform_memory_commit(pmblock, uint(base_offset) + committed) or_return
Â  Â  
Â  Â  // Should be zeroed
Â  Â  assert(pmblock.block.used == 0)
Â  Â  assert(pmblock.block.prev == nil) Â 
Â  Â  if do_protection {
Â  Â  Â  Â  protect(([^]byte)(pmblock)[protect_offset:], page_size, Protect_No_Access)
Â  Â  }
Â  Â  pmblock.block.committed = committed
Â  Â  pmblock.block.reserved Â = reserved
Â  Â  
Â  Â  return &pmblock.block, nil
}

@(require_results, no_sanitize_address)
arena_init_growing :: proc(arena: ^Arena, reserved: uint = DEFAULT_ARENA_GROWING_MINIMUM_BLOCK_SIZE) -&gt; (err: Allocator_Error) {
Â  Â  arena.kind Â  Â  Â  Â  Â  = .Growing
Â  Â  arena.curr_block Â  Â  = memory_block_alloc(0, reserved, {}) or_return
Â  Â  arena.total_used Â  Â  = 0
Â  Â  arena.total_reserved = arena.curr_block.reserved
Â  Â  if arena.minimum_block_size == 0 {
Â  Â  Â  Â  arena.minimum_block_size = reserved
Â  Â  }
Â  Â  // sanitizer.address_poison(arena.curr_block.base[:arena.curr_block.committed])
Â  Â  return
}

@(require_results, no_sanitize_address)
arena_init_static :: proc(arena: ^Arena, reserved: uint = DEFAULT_ARENA_STATIC_RESERVE_SIZE, commit_size: uint = DEFAULT_ARENA_STATIC_COMMIT_SIZE) -&gt; (err: Allocator_Error) {
Â  Â  arena.kind Â  Â  Â  Â  Â  = .Static
Â  Â  arena.curr_block Â  Â  = memory_block_alloc(commit_size, reserved, {}) or_return
Â  Â  arena.total_used Â  Â  = 0
Â  Â  arena.total_reserved = arena.curr_block.reserved
Â  Â  // sanitizer.address_poison(arena.curr_block.base[:arena.curr_block.committed])
Â  Â  return
}
</code></pre>
<h5
	id="memory-block-dealloc" >
    Memory Block Dealloc
</h5>
<pre><code class="language-odin" data-lang="odin">// Windows (this one seems odd)
@(no_sanitize_address)
_release :: proc "contextless" (data: rawptr, size: uint) {
&nbsp;&nbsp;&nbsp;&nbsp;VirtualFree(data, 0, MEM_RELEASE)
}

// Linux
_release :: proc "contextless" (data: rawptr, size: uint) {
&nbsp;&nbsp;&nbsp;&nbsp;_ = linux.munmap(data, size)
}

@(no_sanitize_address)
release :: proc "contextless" (data: rawptr, size: uint) {
&nbsp;&nbsp;&nbsp;&nbsp;// sanitizer.address_unpoison(data, size)
&nbsp;&nbsp;&nbsp;&nbsp;_release(data, size)
}

@(no_sanitize_address)
platform_memory_free :: proc "contextless" (block: ^Platform_Memory_Block) {
&nbsp;&nbsp;&nbsp;&nbsp;if block != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;release(block, block.reserved)
&nbsp;&nbsp;&nbsp;&nbsp;}
}

@(no_sanitize_address)
memory_block_dealloc :: proc(block_to_free: ^Memory_Block) {
&nbsp;&nbsp;&nbsp;&nbsp;if block := (^Platform_Memory_Block)(block_to_free); block != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;platform_memory_free(block)
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                For Growing arenas
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vmem.arena_free_all()</code>
				</p>
				<ul>
					<li>
						<p>
                            Will shrink the arena to the size of the first Memory Block.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Confirmed
							</strong>
                            : This is also shown in the Task Manager, as having much less memory when freeing all.
						</p>
					</li>
					<li>
						<p>
                            Deallocates all but the first memory block of the arena and resets the allocator's usage to 0.
						</p>
					</li>
				</ul>
<pre><code class="language-Odin" data-lang="Odin"> @(no_sanitize_address)
 arena_free_all :: proc(arena: ^Arena, loc := #caller_location) {
 Â  Â  switch arena.kind {
 Â  Â  case .Growing:
 Â  Â  Â  Â  sync.mutex_guard(&arena.mutex)
 Â  Â  Â  Â  // NOTE(bill): Free all but the first memory block (if it exists)
 Â  Â  Â  Â  for arena.curr_block != nil && arena.curr_block.prev != nil {
 Â  Â  Â  Â  Â  Â  arena_growing_free_last_memory_block(arena, loc)
 Â  Â  Â  Â  }
 Â  Â  Â  Â  // Zero the first block's memory
 Â  Â  Â  Â  if arena.curr_block != nil {
 Â  Â  Â  Â  Â  Â  curr_block_used := int(arena.curr_block.used)
 Â  Â  Â  Â  Â  Â  arena.curr_block.used = 0
 Â  Â  Â  Â  Â  Â  // sanitizer.address_unpoison(arena.curr_block.base[:curr_block_used])
 Â  Â  Â  Â  Â  Â  mem.zero(arena.curr_block.base, curr_block_used)
 Â  Â  Â  Â  Â  Â  // sanitizer.address_poison(arena.curr_block.base[:arena.curr_block.committed])
 Â  Â  Â  Â  }
 Â  Â  Â  Â  arena.total_used = 0
 Â  Â  case .Static, .Buffer:
 Â  Â  Â  Â  arena_static_reset_to(arena, 0)
 Â  Â  }
 Â  Â  arena.total_used = 0
 }
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="allocator-procedure" >
    Allocator Procedure
</h5>
<pre><code class="language-odin" data-lang="odin">// The allocator procedure used by an `Allocator` produced by `arena_allocator`
@(no_sanitize_address)
arena_allocator_proc :: proc(allocator_data: rawptr, mode: mem.Allocator_Mode,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â size, alignment: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â old_memory: rawptr, old_size: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â location := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  arena := (^Arena)(allocator_data)
Â  Â  size, alignment := uint(size), uint(alignment)
Â  Â  old_size := uint(old_size)
Â  Â  switch mode {
Â  Â  case .Alloc, .Alloc_Non_Zeroed:
Â  Â  Â  Â  return arena_alloc(arena, size, alignment, location)
Â  Â  case .Free:
Â  Â  Â  Â  err = .Mode_Not_Implemented
Â  Â  case .Free_All:
Â  Â  Â  Â  arena_free_all(arena, location)
Â  Â  case .Resize, .Resize_Non_Zeroed:
Â  Â  Â  Â  old_data := ([^]byte)(old_memory)
Â  Â  Â  Â  switch {
Â  Â  Â  Â  case old_data == nil:
Â  Â  Â  Â  Â  Â  return arena_alloc(arena, size, alignment, location)
Â  Â  Â  Â  case size == old_size:
Â  Â  Â  Â  Â  Â  // return old memory
Â  Â  Â  Â  Â  Â  data = old_data[:size]
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  case size == 0:
Â  Â  Â  Â  Â  Â  err = .Mode_Not_Implemented
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  sync.mutex_guard(&arena.mutex)
Â  Â  Â  Â  if uintptr(old_data) & uintptr(alignment-1) == 0 {
Â  Â  Â  Â  Â  Â  if size &lt; old_size {
Â  Â  Â  Â  Â  Â  Â  Â  // shrink data in-place
Â  Â  Â  Â  Â  Â  Â  Â  data = old_data[:size]
Â  Â  Â  Â  Â  Â  Â  Â  // sanitizer.address_poison(old_data[size:old_size])
Â  Â  Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if block := arena.curr_block; block != nil {
Â  Â  Â  Â  Â  Â  Â  Â  start := uint(uintptr(old_memory)) - uint(uintptr(block.base))
Â  Â  Â  Â  Â  Â  Â  Â  old_end := start + old_size
Â  Â  Â  Â  Â  Â  Â  Â  new_end := start + size
Â  Â  Â  Â  Â  Â  Â  Â  if start &lt; old_end && old_end == block.used && new_end &lt;= block.reserved {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // grow data in-place, adjusting next allocation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  prev_used := block.used
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _ = alloc_from_memory_block(block, new_end - old_end, 1, default_commit_size=arena.default_commit_size) or_return
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  arena.total_used += block.used - prev_used
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data = block.base[start:new_end]
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // sanitizer.address_unpoison(data)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  new_memory := arena_alloc_unguarded(arena, size, alignment, location) or_return
Â  Â  Â  Â  if new_memory == nil {
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  copy(new_memory, old_data[:old_size])
Â  Â  Â  Â  // sanitizer.address_poison(old_data[:old_size])
Â  Â  Â  Â  return new_memory, nil
Â  Â  case .Query_Features:
Â  Â  Â  Â  set := (^mem.Allocator_Mode_Set)(old_memory)
Â  Â  Â  Â  if set != nil {
Â  Â  Â  Â  Â  Â  set^ = {.Alloc, .Alloc_Non_Zeroed, .Free_All, .Resize, .Query_Features}
Â  Â  Â  Â  }
Â  Â  case .Query_Info:
Â  Â  Â  Â  err = .Mode_Not_Implemented
Â  Â  }
Â  Â  return
}
</code></pre>
<h4
	id="rollback-the-offset-from-codevmem-arena-gt-static-code-with-codevmem-arena_static_reset_to-code" >
    Rollback the offset from 
    <code>vmem.Arena -&gt; .Static</code>
    &nbsp;with 
    <code>vmem.arena_static_reset_to</code>
</h4>
<ul>
	<li>
		<p>
            Unlike other &quot;rollback arena options&quot;, there's no helper with that, but the following procedure can be used:
		</p>
		<ul>
			<li>
				<p>
                    Resets the memory of a Static or Buffer arena to a specific 
                    <code>position</code>
                    &nbsp;(offset) and zeroes the previously used memory.
				</p>
			</li>
			<li>
				<p>
                    It doesn't have a 
					<em>
                        begin
					</em>
                    , 
					<em>
                        end
					</em>
                    , or 
					<em>
                        guard
					</em>
                    ; the offset need to be defined by the user without any helpers.
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    It doesn't &quot;free&quot; the memory, etc.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(no_sanitize_address)
 arena_static_reset_to :: proc(arena: ^Arena, pos: uint, loc := #caller_location) -&gt; bool {
&nbsp;&nbsp;&nbsp;&nbsp; sync.mutex_guard(&arena.mutex)
&nbsp;&nbsp;&nbsp;&nbsp; if arena.curr_block != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(arena.kind != .Growing, "expected a non .Growing arena", loc)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_pos := arena.curr_block.used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arena.curr_block.used = clamp(pos, 0, arena.curr_block.reserved)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if prev_pos &gt; pos {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem.zero_slice(arena.curr_block.base[arena.curr_block.used:][:prev_pos-pos])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arena.total_used = arena.curr_block.used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sanitizer.address_poison(arena.curr_block.base[:arena.curr_block.committed])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true
&nbsp;&nbsp;&nbsp;&nbsp; } else if pos == 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arena.total_used = 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; return false
 }
</code></pre>
	</li>
</ul>
<h4
	id="free-last-memory-block-from-codevmem-arena-gt-growing-code-with-codevmem-arena_temp-code" >
    Free last Memory Block from&nbsp;&nbsp;
    <code>vmem.Arena -&gt; .Growing</code>
    &nbsp;with 
    <code>vmem.Arena_Temp</code>
</h4>
<ul>
	<li>
		<p>
            Is a way to produce temporary watermarks to reset an arena to a previous state.
		</p>
	</li>
	<li>
		<p>
            All uses of an 
            <code>Arena_Temp</code>
            &nbsp;must be handled by ending them with 
            <code>arena_temp_end</code>
            &nbsp;or ignoring them with 
            <code>arena_temp_ignore</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Arena :: struct {
Â  Â  kind: Â  Â  Â  Â  Â  Â  Â  Â Arena_Kind,
Â  Â  curr_block: Â  Â  Â  Â  Â ^Memory_Block,
Â  Â  total_used: Â  Â  Â  Â  Â uint,
Â  Â  total_reserved: Â  Â  Â uint,
Â  Â  default_commit_size: uint, // commit size &lt;= reservation size
Â  Â  minimum_block_size: Â uint, // block size == total reservation
Â  Â  temp_count: Â  Â  Â  Â  Â uint,
Â  Â  mutex: Â  Â  Â  Â  Â  Â  Â  sync.Mutex,
}

Memory_Block :: struct {
Â  Â  prev: ^Memory_Block,
Â  Â  base: Â  Â  Â [^]byte,
Â  Â  used: Â  Â  Â uint,
Â  Â  committed: uint,
Â  Â  reserved: Â uint,
}

Arena_Temp :: struct {
Â  Â  arena: ^Arena,
Â  Â  block: ^Memory_Block,
Â  Â  used: Â uint,
}
</code></pre>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<strong>
                Begin
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> @(require_results, no_sanitize_address)
 arena_temp_begin :: proc(arena: ^Arena, loc := #caller_location) -&gt; (temp: Arena_Temp) {
 Â  Â  assert(arena != nil, "nil arena", loc)
 Â  Â  sync.mutex_guard(&arena.mutex)
 Â  Â  
 Â  Â  temp.arena = arena
 Â  Â  temp.block = arena.curr_block
 Â  Â  if arena.curr_block != nil {
 Â  Â  Â  Â  temp.used = arena.curr_block.used
 Â  Â  }
 Â  Â  arena.temp_count += 1
 Â  Â  return
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                End
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> @(no_sanitize_address)
 arena_growing_free_last_memory_block :: proc(arena: ^Arena, loc := #caller_location) {
 Â  Â  if free_block := arena.curr_block; free_block != nil {
 Â  Â  Â  Â  assert(arena.kind == .Growing, "expected a .Growing arena", loc)
 Â  Â  Â  Â  arena.total_used -= free_block.used
 Â  Â  Â  Â  arena.total_reserved -= free_block.reserved
 Â  Â  Â  Â  arena.curr_block = free_block.prev
 Â  Â  Â  Â  // sanitizer.address_poison(free_block.base[:free_block.committed])
 Â  Â  Â  Â  memory_block_dealloc(free_block)
 Â  Â  }
 }
 
 @(no_sanitize_address)
 arena_temp_end :: proc(temp: Arena_Temp, loc := #caller_location) {
 Â  Â  assert(temp.arena != nil, "nil arena", loc)
 Â  Â  arena := temp.arena
 Â  Â  sync.mutex_guard(&arena.mutex)
 Â  Â  if temp.block != nil {
 Â  Â  Â  Â  memory_block_found := false
 Â  Â  Â  Â  for block := arena.curr_block; block != nil; block = block.prev {
 Â  Â  Â  Â  Â  Â  if block == temp.block {
 Â  Â  Â  Â  Â  Â  Â  Â  memory_block_found = true
 Â  Â  Â  Â  Â  Â  Â  Â  break
 Â  Â  Â  Â  Â  Â  }
 Â  Â  Â  Â  }
 Â  Â  Â  Â  if !memory_block_found {
 Â  Â  Â  Â  Â  Â  assert(arena.curr_block == temp.block, "memory block stored within Arena_Temp not owned by Arena", loc)
 Â  Â  Â  Â  }
 Â  Â  Â  Â  
 Â  Â  Â  Â  for arena.curr_block != temp.block {
 Â  Â  Â  Â  Â  Â  arena_growing_free_last_memory_block(arena)
 Â  Â  Â  Â  }
 Â  Â  Â  Â  
 Â  Â  Â  Â  if block := arena.curr_block; block != nil {
 Â  Â  Â  Â  Â  Â  assert(block.used &gt;= temp.used, "out of order use of arena_temp_end", loc)
 Â  Â  Â  Â  Â  Â  amount_to_zero := block.used-temp.used
 Â  Â  Â  Â  Â  Â  mem.zero_slice(block.base[temp.used:][:amount_to_zero])
 Â  Â  Â  Â  Â  Â  block.used = temp.used
 Â  Â  Â  Â  Â  Â  arena.total_used -= amount_to_zero
 Â  Â  Â  Â  }
 Â  Â  }
 Â  Â  assert(arena.temp_count &gt; 0, "double-use of arena_temp_end", loc)
 Â  Â  arena.temp_count -= 1
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Guard
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I didn't find any guard implementations for this one.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ignore
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> @(no_sanitize_address)
 arena_temp_ignore :: proc(temp: Arena_Temp, loc := #caller_location) {
 Â  Â  assert(temp.arena != nil, "nil arena", loc)
 Â  Â  arena := temp.arena
 Â  Â  sync.mutex_guard(&arena.mutex)
 Â  Â  assert(arena.temp_count &gt; 0, "double-use of arena_temp_end", loc)
 Â  Â  arena.temp_count -= 1
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Check
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Asserts that all uses of 
                    <code>Arena_Temp</code>
                    &nbsp;has been used by an 
                    <code>Arena</code>
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(no_sanitize_address)
 arena_check_temp :: proc(arena: ^Arena, loc := #caller_location) {
 Â  Â  assert(arena.temp_count == 0, "Arena_Temp not been ended", loc)
 }
</code></pre>
	</li>
</ul>
<h3
	id="arena-backed-buffer-as-an-arena-codemem-arena-code" >
    Arena: Backed buffer as an arena (
    <code>mem.Arena</code>
    )
</h3>
<ul>
	<li>
		<p>
            All those names are interchangeable.
		</p>
	</li>
	<li>
		<p>
            It's an allocator that uses a single backing buffer for allocations.
		</p>
	</li>
	<li>
		<p>
            The buffer is used contiguously, from start to end. Each subsequent allocation occupies the next adjacent region of memory in the buffer. Since the arena allocator does not keep track of any metadata associated with the allocations and their locations, it is impossible to free individual allocations.
		</p>
	</li>
	<li>
		<p>
            The arena allocator can be used for temporary allocations in frame-based memory management. Games are one example of such applications. A global arena can be used for any temporary memory allocations, and at the end of each frame all temporary allocations are freed. Since no temporary object is going to live longer than a frame, no lifetimes are violated.
		</p>
	</li>
	<li>
		<p>
            The arenaâ€™s logic only requires an offset (or pointer) to indicate the end of the last allocation.
		</p>
	</li>
	<li>
		<p>
            To allocate some memory from the arena, it is as simple as moving the offset (or pointer) forward. In Big-O notation, the allocation has complexity of 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            &nbsp;(constant).
		</p>
	</li>
	<li>
		<p>
            On arenas being slices, it's important to realize that what they are is an implementation. All the abstract idea is, is to allocate linearly from a buffer such that you can quickly free everything. Whether it's a single buffer and cannot grow at all depends entirely on the arena allocator implementation in question.
		</p>
	</li>
	<li>
		<p>
            You cannot deallocate memory individually in an arena allocator.
		</p>
		<ul>
			<li>
				<p>
                    <code>free</code>
                    &nbsp;for pointers created using an arena does not work.
				</p>
				<ul>
					<li>
						<p>
                            Returns the error 
                            <code>Mode_Not_Implemented</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The correct approach is to use 
                    <code>delete</code>
                    &nbsp;on the entire arena.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=hI9aN8ZG4vg" 
				class="external-link" 
				target="_blank" >
                Arena Allocators - Nic Barker
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=1WnqZPD-qVc" 
				class="external-link" 
				target="_blank" >
                Problems of using Arena Allocators for arrays with changing capacity - Karl Zylinski
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://zylinski.se/posts/dynamic-arrays-and-arenas/" 
						class="external-link" 
						target="_blank" >
                        Article
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Shows problems with using 
                    <code>make([dynamic]int, arena_alloc)</code>
                    .
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://zylinski.se/posts/dynamic-arrays-and-arenas/#what-happened" 
								class="external-link" 
								target="_blank" >
                                Explanation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            &quot;Trail of dead stuff, for every resize&quot;.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/Pasted%20image%2020251111172505.png" width="323" alt="" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Virtual Arenas doesn't always have this problem, as there's a special condition to avoid this, but it doesn't solve for every case.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://www.youtube.com/watch?v=TZ5a3gCCZYo" 
				class="external-link" 
				target="_blank" >
                Arena Allocators - Ryan Fleury
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It introduces DOD and tries to justify to the students how RAII can be really bad, etc.
				</p>
			</li>
			<li>
				<p>
                    When it comes to the arena, tho, I didn't really love the explanation. The arena could be really simple, but I felt like his examples went to a specific direction that could be simplified.
				</p>
			</li>
			<li>
				<p>
                    Most of the talk is: DOD -&gt; A specific implementation of Arena.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator" 
						class="external-link" 
						target="_blank" >
                        Article
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Arena :: struct {
Â  Â  data: Â  Â  Â  []byte,
Â  Â  offset: Â  Â  int,
Â  Â  peak_used: Â int,
Â  Â  temp_count: int,
}

@(require_results)
arena_allocator :: proc(arena: ^Arena) -&gt; Allocator {
Â  Â  return Allocator{
Â  Â  Â  Â  procedure = arena_allocator_proc,
Â  Â  Â  Â  data = arena,&nbsp;&nbsp; // The DATA is the arena.
Â  Â  }
}
</code></pre>
<h5
	id="rationale" >
    Rationale
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2019/02/08/memory-allocation-strategies-002/" 
				class="external-link" 
				target="_blank" >
                Arena Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The simplest arena allocator 
			<em>
                could
			</em>
            &nbsp;look like this:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">static unsigned char *arena_buffer;
static size_t arena_buffer_length;
static size_t arena_offset;

void *arena_alloc(size_t size) {
&nbsp;&nbsp;&nbsp;&nbsp;// Check to see if the backing memory has space left
&nbsp;&nbsp;&nbsp;&nbsp;if (arena_offset+size &lt;= arena_buffer_length) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *ptr = &arena_buffer[arena_offset];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arena_offset += size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Zero new memory by default
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ptr, 0, size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Return NULL if the arena is out of memory
&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
}
</code></pre>
<ul>
	<li>
		<p>
            There are two issues with this basic approach:
		</p>
		<ul>
			<li>
				<p>
                    You cannot reuse this procedure for different arenas
				</p>
				<ul>
					<li>
						<p>
                            Can be easily solved by coupling that global data into a structure and passing that to the procedure 
                            <code>arena_alloc</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The pointer returned may not be aligned correctly for the data you need.
				</p>
				<ul>
					<li>
						<p>
                            This requires understanding the basic issues of 
							<em>
                                unaligned memory
							</em>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It's also missing some important features of a practical implementation:
		</p>
		<ul>
			<li>
				<p>
                    <code>init</code>
                    , 
                    <code>alloc</code>
                    , 
                    <code>free</code>
                    , 
                    <code>resize</code>
                    , 
                    <code>free_all</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.gingerbill.org/code/memory-allocation-strategies/part002.c" 
						class="external-link" 
						target="_blank" >
                        Practical implementation of an arena allocator
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="initialize-an-arena" >
    Initialize an arena
</h5>
<ul>
	<li>
		<p>
            Initializes the arena 
            <code>a</code>
            &nbsp;with memory region 
            <code>data</code>
            &nbsp;as its backing buffer.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">arena_init :: proc(a: ^Arena, data: []byte) {
Â  Â  a.data Â  Â  Â  = data
Â  Â  a.offset Â  Â  = 0
Â  Â  a.peak_used Â = 0
Â  Â  a.temp_count = 0
Â  Â  // sanitizer.address_poison(a.data)
}
</code></pre>
<h5
	id="allocator-procedure" >
    Allocator Procedure
</h5>
<pre><code class="language-odin" data-lang="odin">arena_allocator_proc :: proc(
Â  Â  allocator_data: rawptr,
Â  Â  mode: Â  Â  Â  Â  Â  Allocator_Mode,
Â  Â  size: Â  Â  Â  Â  Â  int,
Â  Â  alignment: Â  Â  Â int,
Â  Â  old_memory: Â  Â  rawptr,
Â  Â  old_size: Â  Â  Â  int,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) Â {
Â  Â  arena := cast(^Arena)allocator_data
Â  Â  switch mode {
Â  Â  case .Alloc:
Â  Â  Â  Â  return arena_alloc_bytes(arena, size, alignment, loc)
Â  Â  case .Alloc_Non_Zeroed:
Â  Â  Â  Â  return arena_alloc_bytes_non_zeroed(arena, size, alignment, loc)
Â  Â  case .Free:
Â  Â  Â  Â  return nil, .Mode_Not_Implemented
Â  Â  case .Free_All:
Â  Â  Â  Â  arena_free_all(arena)
Â  Â  case .Resize:
Â  Â  Â  Â  return default_resize_bytes_align(byte_slice(old_memory, old_size), size, alignment, arena_allocator(arena), loc)
Â  Â  case .Resize_Non_Zeroed:
Â  Â  Â  Â  return default_resize_bytes_align_non_zeroed(byte_slice(old_memory, old_size), size, alignment, arena_allocator(arena), loc)
Â  Â  case .Query_Features:
Â  Â  Â  Â  set := (^Allocator_Mode_Set)(old_memory)
Â  Â  Â  Â  if set != nil {
Â  Â  Â  Â  Â  Â  set^ = {.Alloc, .Alloc_Non_Zeroed, .Free_All, .Resize, .Resize_Non_Zeroed, .Query_Features}
Â  Â  Â  Â  }
Â  Â  Â  Â  return nil, nil
Â  Â  case .Query_Info:
Â  Â  Â  Â  return nil, .Mode_Not_Implemented
Â  Â  }
Â  Â  return nil, nil
}
</code></pre>
<h5
	id="allocate" >
    Allocate
</h5>
<ul>
	<li>
		<p>
            All allocation procedures call this one:
		</p>
	</li>
	<li>
		<p>
            Allocate non-initialized memory from an arena.
		</p>
	</li>
	<li>
		<p>
            This procedure allocates 
            <code>size</code>
            &nbsp;bytes of memory aligned on a boundary specified by 
            <code>alignment</code>
            &nbsp;from an arena 
            <code>a</code>
            .
		</p>
	</li>
	<li>
		<p>
            The allocated memory is not explicitly zero-initialized. This procedure returns a slice of the newly allocated memory region.
		</p>
	</li>
	<li>
		<p>
            It creates a byte slice by using a pointer and a length. The pointer is within the region of the arena.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
arena_alloc_bytes_non_zeroed :: proc(
Â  Â  a: Â  Â ^Arena,
Â  Â  size: int,
Â  Â  alignment := DEFAULT_ALIGNMENT,
Â  Â  loc Â  Â  Â  := #caller_location
) -&gt; ([]byte, Allocator_Error) {
Â  Â  if a.data == nil {
Â  Â  Â  Â  panic("Allocation on uninitialized Arena allocator.", loc)
Â  Â  }
Â  Â  #no_bounds_check end := &a.data[a.offset]
Â  Â  ptr := align_forward(end, uintptr(alignment))
Â  Â  total_size := size + ptr_sub((^byte)(ptr), (^byte)(end))
Â  Â  if a.offset + total_size &gt; len(a.data) {
Â  Â  Â  Â  return nil, .Out_Of_Memory
Â  Â  }
Â  Â  a.offset += total_size
Â  Â  a.peak_used = max(a.peak_used, a.offset)
Â  Â  result := byte_slice(ptr, size)
Â  Â  // ensure_poisoned(result)
Â  Â  // sanitizer.address_unpoison(result)
Â  Â  return result, nil
}
</code></pre>
<h5
	id="free-all" >
    Free All
</h5>
<ul>
	<li>
		<p>
            Free all memory back to the arena allocator.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">arena_free_all :: proc(a: ^Arena) {
Â  Â  a.offset = 0
Â  Â  // sanitizer.address_poison(a.data)
}
</code></pre>
<h4
	id="rollback-the-offset-from-codemem-arena-code-with-codemem-arena_temp_memory-code" >
    Rollback the offset from 
    <code>mem.Arena</code>
    &nbsp;with: 
    <code>mem.Arena_Temp_Memory</code>
</h4>
<ul>
	<li>
		<p>
            Temporary memory region of an 
            <code>Arena</code>
            &nbsp;allocator.
		</p>
	</li>
	<li>
		<p>
            Temporary memory regions of an arena act as &quot;save-points&quot; for the allocator.
		</p>
	</li>
	<li>
		<p>
            When one is created, the subsequent allocations are done inside the temporary memory region.
		</p>
	</li>
	<li>
		<p>
            When 
            <code>end_arena_temp_memory</code>
            &nbsp;is called, the arena is rolled back, and all of the memory that was allocated from the arena will be freed.
		</p>
	</li>
	<li>
		<p>
            Multiple temporary memory regions can exist at the same time for an arena.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Arena_Temp_Memory :: struct {
Â  Â  arena: Â  Â  Â  ^Arena,
Â  Â  prev_offset: int,
}
</code></pre>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
			<strong>
                Begin
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Creates a temporary memory region. After a temporary memory region is created, all allocations are said to be 
					<em>
                        inside
					</em>
                    &nbsp;the temporary memory region, until 
                    <code>end_arena_temp_memory</code>
                    &nbsp;is called.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(require_results)
 begin_arena_temp_memory :: proc(a: ^Arena) -&gt; Arena_Temp_Memory {
 Â  Â  tmp: Arena_Temp_Memory
 Â  Â  tmp.arena = a
 Â  Â  tmp.prev_offset = a.offset
 Â  Â  a.temp_count += 1
 Â  Â  return tmp
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                End
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Ends the temporary memory region for an arena. All of the allocations 
					<em>
                        inside
					</em>
                    &nbsp;the temporary memory region will be freed to the arena.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> end_arena_temp_memory :: proc(tmp: Arena_Temp_Memory) {
 Â  Â  assert(tmp.arena.offset &gt;= tmp.prev_offset)
 Â  Â  assert(tmp.arena.temp_count &gt; 0)
 Â  Â  // sanitizer.address_poison(tmp.arena.data[tmp.prev_offset:tmp.arena.offset])
 Â  Â  tmp.arena.offset = tmp.prev_offset
 Â  Â  tmp.arena.temp_count -= 1
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Guard
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I didn't find any guard implementations for this one.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="arena-growing-codemem-arena-code-codemem-dynamic_arena-code" >
    Arena: Growing 
    <code>mem.Arena</code>
    &nbsp;(
    <code>mem.Dynamic_Arena</code>
    )
</h3>
<ul>
	<li>
		<p>
            The dynamic arena allocator uses blocks of a specific size, allocated on-demand using the block allocator. This allocator acts similarly to 
            <code>Arena</code>
            .
		</p>
	</li>
	<li>
		<p>
            All allocations in a block happen contiguously, from start to end. If an allocation does not fit into the remaining space of the block and its size is smaller than the specified out-band size, a new block is allocated using the 
            <code>block_allocator</code>
            &nbsp;and the allocation is performed from a newly-allocated block.
		</p>
	</li>
	<li>
		<p>
            If an allocation is larger than the specified out-band size, a new block is allocated such that the allocation fits into this new block. This is referred to as an 
			<em>
                out-band allocation
			</em>
            . The out-band blocks are kept separately from normal blocks.
		</p>
	</li>
	<li>
		<p>
            Just like 
            <code>Arena</code>
            , the dynamic arena does not support freeing of individual objects.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Dynamic_Arena :: struct {
Â  Â  block_size: Â  Â  Â  Â  Â  int,
Â  Â  out_band_size: Â  Â  Â  Â int,
Â  Â  alignment: Â  Â  Â  Â  Â  Â int,
Â  Â  unused_blocks: Â  Â  Â  Â [dynamic]rawptr,
Â  Â  used_blocks: Â  Â  Â  Â  Â [dynamic]rawptr,
Â  Â  out_band_allocations: [dynamic]rawptr,
Â  Â  current_block: Â  Â  Â  Â rawptr,
Â  Â  current_pos: Â  Â  Â  Â  Â rawptr,
Â  Â  bytes_left: Â  Â  Â  Â  Â  int,
Â  Â  block_allocator: Â  Â  Â Allocator,
}
</code></pre>
<h3
	id="arena-codecontext-temp_allocator-code-coderuntime-default_temp_allocator-code" >
    Arena: 
    <code>context.temp_allocator</code>
    &nbsp;(
    <code>runtime.Default_Temp_Allocator</code>
    )
</h3>
<ul>
	<li>
		<p>
            <code>Arena</code>
            &nbsp;here is a 
            <code>runtime.Arena</code>
		</p>
		<ul>
			<li>
				<p>
                    This 
                    <code>Arena</code>
                    &nbsp;is a growing arena that is only used for the default temp allocator.
				</p>
			</li>
			<li>
				<p>
                    &quot;For your own growing arena needs, prefer 
                    <code>Arena</code>
                    &nbsp;from 
                    <code>core:mem/virtual</code>
                    &quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            By default, every 
            <code>Memory_Block</code>
            &nbsp;is backed by the 
            <code>context.allocator</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Arena :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;backing_allocator: Â Allocator,
&nbsp;&nbsp;&nbsp;&nbsp;curr_block: Â  Â  Â  Â  ^Memory_Block,
&nbsp;&nbsp;&nbsp;&nbsp;total_used: Â  Â  Â  Â  uint,
&nbsp;&nbsp;&nbsp;&nbsp;total_capacity: Â  Â  uint,
&nbsp;&nbsp;&nbsp;&nbsp;minimum_block_size: uint,
&nbsp;&nbsp;&nbsp;&nbsp;temp_count: Â  Â  Â  Â  uint,
}

Memory_Block :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;prev: Â  Â  Â ^Memory_Block,
&nbsp;&nbsp;&nbsp;&nbsp;allocator: Allocator,
&nbsp;&nbsp;&nbsp;&nbsp;base: Â  Â  Â [^]byte,
&nbsp;&nbsp;&nbsp;&nbsp;used: Â  Â  Â uint,
&nbsp;&nbsp;&nbsp;&nbsp;capacity: Â uint,
}

Default_Temp_Allocator :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;arena: Arena,
}

@(require_results)
default_temp_allocator :: proc(allocator: ^Default_Temp_Allocator) -&gt; Allocator {
Â  Â  return Allocator{
Â  Â  Â  Â  procedure = default_temp_allocator_proc,
Â  Â  Â  Â  data Â  Â  Â = allocator,
Â  Â  }
}
</code></pre>
<h5
	id="default-codecontext-temp_allocator-code" >
    Default 
    <code>context.temp_allocator</code>
</h5>
<ul>
	<li>
		<p>
            <code>Default_Temp_Allocator</code>
            &nbsp;is a 
            <code>nil_allocator</code>
            &nbsp;when 
            <code>NO_DEFAULT_TEMP_ALLOCATOR</code>
            &nbsp;is 
            <code>true</code>
            .
		</p>
	</li>
	<li>
		<p>
            <code>context.temp_allocator</code>
            &nbsp;is typically called with 
            <code>free_all(context.temp_allocator)</code>
            &nbsp;once per &quot;frame-loop&quot; to prevent it from &quot;leaking&quot; memory.
		</p>
	</li>
	<li>
		<p>
			<strong>
                No Default
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> NO_DEFAULT_TEMP_ALLOCATOR: bool : ODIN_OS == .Freestanding || ODIN_DEFAULT_TO_NIL_ALLOCATOR
</code></pre>
		<ul>
			<li>
				<p>
                    Consequence of calling 
                    <code>-default-to-nil-allocator</code>
                    &nbsp;as a compiler flag.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="where-is-the-memory-actually-stored" >
    Where is the memory actually stored
</h5>
<ul>
	<li>
		<p>
            The 
			<strong>
                <code>Memory_Blocks</code>
                &nbsp;struct
			</strong>
            &nbsp;and the 
			<strong>
                reserved region
			</strong>
            &nbsp;from within the 
            <code>context.temp_allocator</code>
            &nbsp;are stored in its 
            <code>arena.backing_allocator</code>
            &nbsp;(usually 
            <code>context.allocator</code>
            ).
		</p>
	</li>
	<li>
		<p>
			<em>
                Analysis
			</em>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> @(require_results)
 memory_block_alloc :: proc(allocator: Allocator, capacity: uint, alignment: uint, loc := #caller_location) -&gt; (block: ^Memory_Block, err: Allocator_Error) {
 Â  Â  total_size Â := uint(capacity + max(alignment, size_of(Memory_Block)))
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // The total size of the data (`[]byte`) that will be used for `mem_alloc`.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // It's the `base_offset + capacity`; in other words: `Memory_Block` struct + `block.base` region.
 Â  Â  
 Â  Â  base_offset := uintptr(max(alignment, size_of(Memory_Block)))
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // It's an offset from the data (`[]byte`) that will be allocated.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // It represents the start of the `block.base`, which is the region the block uses to allocate new data when called `alloc_from_memory_block`.
 Â  Â  
 Â  Â  min_alignment: int = max(16, align_of(Memory_Block), int(alignment))
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // I'm not completely sure, but it's only used in `mem_alloc`.
 Â  Â  
 Â  Â  data := mem_alloc(int(total_size), min_alignment, allocator, loc) or_return
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // A `[]byte` is alloc using the backing_allocator.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  
 Â  Â  block = (^Memory_Block)(raw_data(data))
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // The pointer to this slice is used as the pointer to the block.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // This means that the block metadata will be the first thing populating the `[]byte` allocated.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  
 Â  Â  end := uintptr(raw_data(data)[len(data):])
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // Fancy way to get the pointer of the last element in the data (`[]byte`) region.
&nbsp;&nbsp;Â  Â  
 Â  Â  block.allocator = allocator
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // The backing_allocator is saved as the `block.allocator`
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  
 Â  Â  block.base = ([^]byte)(uintptr(block) + base_offset)
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // The `baseÂ´ will be right after the block struct end (considering a custom alignment from the procedure args).
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // It represents the start of the region the block uses to allocate new data when called `alloc_from_memory_block`.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  
 Â  Â  block.capacity = uint(end - uintptr(block.base))
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // The size of the `block.base`.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // Represents the allocation "capacity" of the `block.base`, which is how much memory the block can store.
&nbsp;&nbsp;&nbsp;&nbsp; Â  Â  // Calculated by doing the pointer subtraction: `uintptr(end) - uintptr(block.base)`.
 Â  Â  
 Â  Â  return
 }
</code></pre>
	</li>
	<li>
		<p>
            What 
            <code>arena.backing_allocator</code>
            &nbsp;should be used?
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>Memory_Blocks</code>
                    &nbsp;needs to be able to be free individually, as this is the main strategy around the 
                    <code>context.temp_allocator</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    In that sense, the 
                    <code>backing_allocator</code>
                    &nbsp;should be an allocator that implements 
                    <code>.Free</code>
                    ; this means that 
                    <code>mem.Arena</code>
                    &nbsp;is not good for this.
				</p>
			</li>
			<li>
				<p>
                    Any allocator that implements 
                    <code>.Free</code>
                    &nbsp;should be enough, I believe.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            So, what's stored &quot;inside the 
            <code>context.temp_allocator</code>
            &quot;?
		</p>
		<ul>
			<li>
				<p>
                    &quot;Nothing&quot;.
				</p>
			</li>
			<li>
				<p>
                    I mean, the 
                    <code>context.temp_allocator</code>
                    &nbsp;is a 
                    <code>runtime.Arena</code>
                    , which is:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> Arena :: struct {
 Â  Â  backing_allocator: Â Allocator,
 Â  Â  curr_block: Â  Â  Â  Â  ^Memory_Block,
 Â  Â  total_used: Â  Â  Â  Â  uint,
 Â  Â  total_capacity: Â  Â  uint,
 Â  Â  minimum_block_size: uint,
 Â  Â  temp_count: Â  Â  Â  Â  uint,
 }
</code></pre>
		<ul>
			<li>
				<p>
                    And it's stored inside the 
                    <code>context</code>
                    &nbsp;(which is on the stack), with its backing 
                    <code>.data</code>
                    &nbsp;being a pointer to 
                    <code>global_default_temp_allocator_data</code>
                    , which is a global variable.
				</p>
			</li>
			<li>
				<p>
                    So, the 
                    <code>context.temp_allocator</code>
                    &nbsp;is just a struct on the stack; it doesn't store anything on the heap. Its 
                    <code>arena.backing_allocator</code>
                    &nbsp;is what actually decides where the memory is stored.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="threading" >
    Threading
</h5>
<ul>
	<li>
		<p>
			<strong>
                Thread-safe?
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Ginger Bill:
				</p>
				<ul>
					<li>
						<p>
                            Within a thread, yes. Across? No.
						</p>
					</li>
					<li>
						<p>
                            It's a thread-local allocator.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            See 
			<a
				href="Odin#Context" 
				class="external-link" 
				target="_blank" >
                Odin#Context
			</a>
            &nbsp;for information on how to handle the 
            <code>context.temp_allocator</code>
            &nbsp;if a existing one is used or not.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Practical example: CPU multithreaded texture loading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        How I handled the 
                        <code>context.temp_allocator</code>
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Each thread has a functional 
                            <code>context.temp_allocator</code>
                            , completely thread-local.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Storing the image data
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Using 
                                <code>context.temp_allocator</code>
                                &nbsp;from the main thread
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    I was first using this while using a mutex in the 
                                    <code>pixels = make([]byte, size, allocator)</code>
                                    &nbsp;from 
                                    <code>load_image_file</code>
                                    , as the 
                                    <code>context.temp_allocator</code>
                                    &nbsp;is not thread-safe.
								</p>
								<ul>
									<li>
										<p>
                                            If the allocator were a 
                                            <code>vmem.Arena</code>
                                            , this was not going to be necessary, as the 
                                            <code>vmem.Arena</code>
                                            &nbsp;already has a mutex inside it, being thread-safe.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    My main idea at first is that I would use the main thread's 
                                    <code>context.temp_allocator</code>
                                    , so the main thread can keep the data loaded from the other threads, as I need the main thread to be the one responsible for managing the loaded data's lifetime, to later can call 
                                    <code>texture_copy_from_buffer()</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Tho, later I realized that the 
                                    <code>context.temp_allocator</code>
                                    &nbsp;from the main thread can not be used, as the main thread also participates in the 
                                    <code>jobs.try_execute_queued_job_globals()</code>
                                    , which then provokes its own 
                                    <code>context.temp_allocator</code>
                                    &nbsp;to do 
                                    <code>free_all()</code>
                                    &nbsp;after one of its jobs is executed, breaking everything.
								</p>
							</li>
							<li>
								<p>
                                    If a 
									<em>
                                        guard
									</em>
                                    &nbsp;is used instead of 
                                    <code>free_all()</code>
                                    , this fixes the freeing problem, but it would be 
									<strong>
                                        very
									</strong>
                                    &nbsp;weird handling 
									<em>
                                        guard
									</em>
                                    s when the 
                                    <code>context.temp_allocator</code>
                                    &nbsp;is being used in different threads; this is not a good option in this case.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Using a 
                                <code>vmem.Arena</code>
                                &nbsp;from the main thread
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Much better. This arena has a mutex and it's already thread-safe.
								</p>
							</li>
							<li>
								<p>
                                    There's no risk of freeing the data from this arena, as it's completely managed by the main thread and untouched by the Jobs System.
								</p>
							</li>
							<li>
								<p>
                                    There's no direct participation of a 
                                    <code>context.temp_allocator</code>
                                    &nbsp;from a different thread; it's much simpler.
								</p>
							</li>
							<li>
								<p>
                                    I'm now using a 
									<em>
                                        guard
									</em>
                                    &nbsp;for the 
                                    <code>context.temp_allocator</code>
                                    &nbsp;after the job is executed; this ensures no incorrect data is deleted by accident by calling 
                                    <code>free_all()</code>
                                    ; if this was not done, the main thread crashes 
									<em>
                                        after
									</em>
                                    &nbsp;all the jobs are executed, as it lost some important data from the dispatcher scope.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tracy-interaction" >
    Tracy interaction
</h5>
<ul>
	<li>
		<p>
            <code>free_all</code>
		</p>
		<ul>
			<li>
				<p>
                    Is ok, as it's just calling the 
                    <code>allocator_proc</code>
                    &nbsp;from inside its 
                    <code>backing_allocator</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If the 
                    <code>backing_allocator</code>
                    &nbsp;is profiled, then it works perfectly fine.
				</p>
			</li>
			<li>
				<p>
                    <code>.Free_All</code>
                    &nbsp;becames 
                    <code>.Free</code>
                    &nbsp;for every 
                    <code>Memory_Block</code>
                    , followed by the remaining 
                    <code>Memory_Block</code>
                    &nbsp;being zeroed out.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="init" >
    Init
</h5>
<ul>
	<li>
		<p>
			<strong>
                App initialization
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The first thing done before calling the entry point of the code, is:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> // Unix example
 @(link_name="main", linkage="strong", require)
 main :: proc "c" (argc: i32, argv: [^]cstring) -&gt; i32 {
&nbsp;&nbsp;&nbsp;&nbsp; args__ = argv[:argc]
&nbsp;&nbsp;&nbsp;&nbsp; context = default_context()
&nbsp;&nbsp;&nbsp;&nbsp; #force_no_inline _startup_runtime()
&nbsp;&nbsp;&nbsp;&nbsp; intrinsics.__entry_point()
&nbsp;&nbsp;&nbsp;&nbsp; #force_no_inline _cleanup_runtime()
&nbsp;&nbsp;&nbsp;&nbsp; return 0
 }
</code></pre>
		<ul>
			<li>
				<p>
                    The 
                    <code>default_context()</code>
                    will internally call 
                    <code>__init_context()</code>
                    , which internally assigns:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> c.temp_allocator.procedure = default_temp_allocator_proc
</code></pre>
	</li>
</ul>
<p>
    Â  Â  when !NO_DEFAULT_TEMP_ALLOCATOR {
    <br>
    Â  Â  Â  Â  c.temp_allocator.data = &amp;global_default_temp_allocator_data
    <br>
    Â  Â  }
    <br>
    <code>- The `global_default_temp_allocator_data` is defined at comp-time as:</code>
    odin
    <br>
    when !NO_DEFAULT_TEMP_ALLOCATOR {
    <br>
    Â  Â  when ODIN_ARCH == .i386 &amp;&amp; ODIN_OS == .Windows {
    <br>
    Â  Â  Â  Â  // Thread-local storage is problematic on Windows i386
    <br>
    Â  Â  Â  Â  global_default_temp_allocator_data: Default_Temp_Allocator
    <br>
    Â  Â  } else {
    <br>
    Â  Â  Â  Â  @thread_local global_default_temp_allocator_data: Default_Temp_Allocator
    <br>
    Â  Â  }
    <br>
    }
    <br>
    ```
    <br>
    - At this point, the 
    <code>.data</code>
    &nbsp;doesn't have anything, besides an empty `runtime.Arena`.
</p>
<ul>
	<li>
		<p>
			<strong>
                Manually initialize the 
                <code>context.temp_allocator</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Initializes the global temporary allocator used as the default 
                    <code>context.temp_allocator</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This is ignored when 
                    <code>NO_DEFAULT_TEMP_ALLOCATOR</code>
                    &nbsp;is true.
				</p>
			</li>
			<li>
				<p>
                    &quot;This procedure is not necessary to use the Arena as the default zero as 
                    <code>arena_alloc</code>
                    &nbsp;will set things up if necessary&quot;; this means that if this is not called, the 
                    <code>context.temp_allocator</code>
                    &nbsp;will be initialized automatically during its first allocation.
				</p>
			</li>
			<li>
				<p>
                    As this is a builtin procedure, you can just call it as 
                    <code>init_global_temporary_allocator(..)</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(builtin, disabled=NO_DEFAULT_TEMP_ALLOCATOR)
 init_global_temporary_allocator :: proc(size: int, backup_allocator := context.allocator) {
 Â  Â  when !NO_DEFAULT_TEMP_ALLOCATOR {
 Â  Â  Â  Â  default_temp_allocator_init(&global_default_temp_allocator_data, size, backup_allocator)
 Â  Â  }
 }
</code></pre>
		<ul>
			<li>
				<p>
                    Internally, this will be called:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(require_results)
 memory_block_alloc :: proc(allocator: Allocator, capacity: uint, alignment: uint, loc := #caller_location) -&gt; (block: ^Memory_Block, err: Allocator_Error) {
 Â  Â  total_size Â := uint(capacity + max(alignment, size_of(Memory_Block)))
 Â  Â  base_offset := uintptr(max(alignment, size_of(Memory_Block)))
 Â  Â  
 Â  Â  min_alignment: int = max(16, align_of(Memory_Block), int(alignment))
 Â  Â  data := mem_alloc(int(total_size), min_alignment, allocator, loc) or_return
 Â  Â  block = (^Memory_Block)(raw_data(data))
 Â  Â  end := uintptr(raw_data(data)[len(data):])
 Â  Â  
 Â  Â  block.allocator = allocator
 Â  Â  block.base = ([^]byte)(uintptr(block) + base_offset)
 Â  Â  block.capacity = uint(end - uintptr(block.base))
 Â  Â  
 Â  Â  // sanitizer.address_poison(block.base, block.capacity)
 Â  Â  
 Â  Â  // Should be zeroed
 Â  Â  assert(block.used == 0)
 Â  Â  assert(block.prev == nil)
 Â  Â  return
 }
 
 // Initializes the arena with a usable block. 
 @(require_results)
 arena_init :: proc(arena: ^Arena, size: uint, backing_allocator: Allocator, loc := #caller_location) -&gt; Allocator_Error {
 Â  Â  arena^ = {}
 Â  Â  arena.backing_allocator = backing_allocator
 Â  Â  arena.minimum_block_size = max(size, 1&lt;&lt;12) // minimum block size of 4 KiB
 Â  Â  new_block := memory_block_alloc(arena.backing_allocator, arena.minimum_block_size, 0, loc) or_return
 Â  Â  arena.curr_block = new_block
 Â  Â  arena.total_capacity += new_block.capacity
 Â  Â  return nil
 }
 
 default_temp_allocator_init :: proc(s: ^Default_Temp_Allocator, size: int, backing_allocator := context.allocator) {
&nbsp;&nbsp;&nbsp;&nbsp; _ = arena_init(&s.arena, uint(size), backing_allocator)
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Let the 
                <code>context.temp_allocator</code>
                &nbsp;be initialized automatically
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    When using the 
                    <code>context.temp_allocator</code>
                    &nbsp;to alloc anything, this procedure will be called:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> default_temp_allocator_proc :: proc(allocator_data: rawptr, mode: Allocator_Mode,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size, alignment: int,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_memory: rawptr, old_size: int, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
&nbsp;&nbsp;&nbsp;&nbsp; s := (^Default_Temp_Allocator)(allocator_data)
&nbsp;&nbsp;&nbsp;&nbsp; return arena_allocator_proc(&s.arena, mode, size, alignment, old_memory, old_size, loc)
 }
</code></pre>
		<ul>
			<li>
				<p>
                    The 
                    <code>runtime.arena_allocator_proc</code>
                    &nbsp;will internally call 
                    <code>runtime.arena_alloc</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Finally, if no 
                    <code>backing_allocator</code>
                    &nbsp;was set for the 
                    <code>context.temp_allocator</code>
                    , the 
                    <code>default_allocator()</code>
                    &nbsp;will be used:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> if arena.backing_allocator.procedure == nil {
&nbsp;&nbsp;&nbsp;&nbsp; arena.backing_allocator = default_allocator()
 }
</code></pre>
		<ul>
			<li>
				<p>
                    The default size will be:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> DEFAULT_TEMP_ALLOCATOR_BACKING_SIZE: int : #config(DEFAULT_TEMP_ALLOCATOR_BACKING_SIZE, 4 * Megabyte)
</code></pre>
		<ul>
			<li>
				<p>
                    The minimum size is 
                    <code>4 KiB</code>
                    ; this is enforced by the 
                    <code>arena_init</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>default_allocator</code>
                    &nbsp;is the 
                    <code>heap_allocator</code>
                    &nbsp;if the conditions are met:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> when ODIN_DEFAULT_TO_NIL_ALLOCATOR {
 Â  Â  default_allocator_proc :: nil_allocator_proc
 Â  Â  default_allocator :: nil_allocator
 } else when ODIN_DEFAULT_TO_PANIC_ALLOCATOR {
 Â  Â  default_allocator_proc :: panic_allocator_proc
 Â  Â  default_allocator :: panic_allocator
 } else when ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32) {
 Â  Â  default_allocator :: default_wasm_allocator
 Â  Â  default_allocator_proc :: wasm_allocator_proc
 } else {
 Â  Â  default_allocator :: heap_allocator
 Â  Â  default_allocator_proc :: heap_allocator_proc
 }
</code></pre>
	</li>
</ul>
<h5
	id="deinit" >
    Deinit
</h5>
<ul>
	<li>
		<p>
            Called automatically after the 
            <code>main</code>
            &nbsp;procedure ends (
            <code>@(fini)</code>
            ).
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">arena_destroy :: proc "contextless" (arena: ^Arena, loc := #caller_location) {
Â  Â  for arena.curr_block != nil {
Â  Â  Â  Â  free_block := arena.curr_block
Â  Â  Â  Â  arena.curr_block = free_block.prev
Â  Â  Â  Â  arena.total_capacity -= free_block.capacity
Â  Â  Â  Â  memory_block_dealloc(free_block, loc)
Â  Â  }
Â  Â  arena.total_used = 0
Â  Â  arena.total_capacity = 0
}

default_temp_allocator_destroy :: proc "contextless" (s: ^Default_Temp_Allocator) {
&nbsp;&nbsp;&nbsp;&nbsp;if s != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arena_destroy(&s.arena)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s^ = {}
&nbsp;&nbsp;&nbsp;&nbsp;}
}

@(fini, private)
_destroy_temp_allocator_fini :: proc "contextless" () {
&nbsp;&nbsp;&nbsp;&nbsp;default_temp_allocator_destroy(&global_default_temp_allocator_data)
}
</code></pre>
<h5
	id="allocator-proc" >
    Allocator Proc
</h5>
<pre><code class="language-odin" data-lang="odin">default_temp_allocator_proc :: proc(allocator_data: rawptr, mode: Allocator_Mode,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size, alignment: int,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_memory: rawptr, old_size: int, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
&nbsp;&nbsp;&nbsp;&nbsp;s := (^Default_Temp_Allocator)(allocator_data)
&nbsp;&nbsp;&nbsp;&nbsp;return arena_allocator_proc(&s.arena, mode, size, alignment, old_memory, old_size, loc)
}

arena_allocator_proc :: proc(allocator_data: rawptr, mode: Allocator_Mode,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â size, alignment: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â old_memory: rawptr, old_size: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â location := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  arena := (^Arena)(allocator_data)
Â  Â  size, alignment := uint(size), uint(alignment)
Â  Â  old_size := uint(old_size)
Â  Â  switch mode {
Â  Â  case .Alloc, .Alloc_Non_Zeroed:
Â  Â  Â  Â  return arena_alloc(arena, size, alignment, location)
Â  Â  case .Free:
Â  Â  Â  Â  err = .Mode_Not_Implemented
Â  Â  case .Free_All:
Â  Â  Â  Â  arena_free_all(arena, location)
Â  Â  case .Resize, .Resize_Non_Zeroed:
Â  Â  Â  Â  old_data := ([^]byte)(old_memory)
Â  Â  Â  Â  switch {
Â  Â  Â  Â  case old_data == nil:
Â  Â  Â  Â  Â  Â  return arena_alloc(arena, size, alignment, location)
Â  Â  Â  Â  case size == old_size:
Â  Â  Â  Â  Â  Â  // return old memory
Â  Â  Â  Â  Â  Â  data = old_data[:size]
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  case size == 0:
Â  Â  Â  Â  Â  Â  err = .Mode_Not_Implemented
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  case uintptr(old_data) & uintptr(alignment-1) == 0:
Â  Â  Â  Â  Â  Â  if size &lt; old_size {
Â  Â  Â  Â  Â  Â  Â  Â  // shrink data in-place
Â  Â  Â  Â  Â  Â  Â  Â  data = old_data[:size]
Â  Â  Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if block := arena.curr_block; block != nil {
Â  Â  Â  Â  Â  Â  Â  Â  start := uint(uintptr(old_memory)) - uint(uintptr(block.base))
Â  Â  Â  Â  Â  Â  Â  Â  old_end := start + old_size
Â  Â  Â  Â  Â  Â  Â  Â  new_end := start + size
Â  Â  Â  Â  Â  Â  Â  Â  if start &lt; old_end && old_end == block.used && new_end &lt;= block.capacity {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // grow data in-place, adjusting next allocation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  block.used = uint(new_end)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data = block.base[start:new_end]
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // sanitizer.address_unpoison(data)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  new_memory := arena_alloc(arena, size, alignment, location) or_return
Â  Â  Â  Â  if new_memory == nil {
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  copy(new_memory, old_data[:old_size])
Â  Â  Â  Â  return new_memory, nil
Â  Â  case .Query_Features:
Â  Â  Â  Â  set := (^Allocator_Mode_Set)(old_memory)
Â  Â  Â  Â  if set != nil {
Â  Â  Â  Â  Â  Â  set^ = {.Alloc, .Alloc_Non_Zeroed, .Free_All, .Resize, .Query_Features}
Â  Â  Â  Â  }
Â  Â  case .Query_Info:
Â  Â  Â  Â  err = .Mode_Not_Implemented
Â  Â  }
Â  Â  return
}
</code></pre>
<h4
	id="free-last-memory-block-from-coderuntime-arena-code-codecontext-temp_allocator-code-with-coderuntime-arena_temp-code-quottemp-allocator-tempquot-coderuntime-default_temp_allocator_temp_guard-code" >
    Free last Memory Block from 
    <code>runtime.Arena</code>
    &nbsp;(
    <code>context.temp_allocator</code>
    ) with 
    <code>runtime.Arena_Temp</code>
    &nbsp;/ &quot;Temp Allocator Temp&quot; / 
    <code>runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD</code>
</h4>
<ul>
	<li>
		<p>
            Is a way to produce temporary watermarks to reset an arena to a previous state.
		</p>
	</li>
	<li>
		<p>
            All uses of an 
            <code>Arena_Temp</code>
            &nbsp;must be handled by ending them with 
            <code>arena_temp_end</code>
            &nbsp;or ignoring them with 
            <code>arena_temp_ignore</code>
            .
		</p>
	</li>
	<li>
		<p>
            <code>Arena</code>
            &nbsp;here is a 
            <code>runtime.Arena</code>
		</p>
		<ul>
			<li>
				<p>
                    This 
                    <code>Arena</code>
                    &nbsp;is a growing arena that is only used for the default temp allocator.
				</p>
			</li>
			<li>
				<p>
                    &quot;For your own growing arena needs, prefer 
                    <code>Arena</code>
                    &nbsp;from 
                    <code>core:mem/virtual</code>
                    &quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>base:runtime -&gt; default_temp_allocator_arena.odin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Arena :: struct {
Â  Â  backing_allocator: Â Allocator,
Â  Â  curr_block: Â  Â  Â  Â  ^Memory_Block,
Â  Â  total_used: Â  Â  Â  Â  uint,
Â  Â  total_capacity: Â  Â  uint,
Â  Â  minimum_block_size: uint,
Â  Â  temp_count: Â  Â  Â  Â  uint,
}

Memory_Block :: struct {
Â  Â  prev: Â  Â  Â ^Memory_Block,
Â  Â  allocator: Allocator,
Â  Â  base: Â  Â  Â [^]byte,
Â  Â  used: Â  Â  Â uint,
Â  Â  capacity: Â uint,
}

Arena_Temp :: struct {
Â  Â  arena: ^Arena,
Â  Â  block: ^Memory_Block,
Â  Â  used: Â uint,
}
</code></pre>
<h5
	id="differences-from-the-codemem-arena_temp-code" >
    Differences from the 
    <code>mem.Arena_Temp</code>
</h5>
<ul>
	<li>
		<p>
            The 
            <code>runtime.Arena_Temp</code>
            &nbsp;has no 
            <code>Mutex</code>
            .
		</p>
	</li>
	<li>
		<p>
            The 
            <code>runtime.Arena_Temp</code>
            &nbsp;is made the 
            <code>runtime.Arena</code>
            , which is a growing arena; it's not for static arenas.
		</p>
	</li>
	<li>
		<p>
            Etc, I think these are the main differences.
		</p>
	</li>
</ul>
<h5
	id="tldr-and-faq-how-the-guard-works" >
    TLDR and FAQ: How the guard works
</h5>
<ul>
	<li>
		<p>
            When exiting the scope:
		</p>
		<ul>
			<li>
				<p>
                    It frees all the new memory blocks from the arena.
				</p>
			</li>
			<li>
				<p>
                    Any new things in the 
                    <code>temp.block</code>
                    &nbsp;(which is now the 
                    <code>arena.curr_block</code>
                    ) are zeroed.
				</p>
			</li>
			<li>
				<p>
                    The &quot;arena current position&quot; is rolled back (
                    <code>block.used</code>
                    ).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Is it inefficient to use this guard everywhere? Where should I use this guard vs just using the 
            <code>context.temp_allocator</code>
            &nbsp;directly?
		</p>
		<ul>
			<li>
				<p>
                    The guard will not free any memory if there's no new block inside the arena, BUT, it will ensure the new memory created within the arena is zeroed and the &quot;arena current position&quot; is rolled back.
				</p>
			</li>
			<li>
				<p>
                    In that sense, even though it might have situations where nothing will be freed on the OS, the arena will have &quot;more space&quot;, as new things can be allocated disregarding the space used in allocations inside the guard scope.
				</p>
			</li>
			<li>
				<p>
                    As a conclusion, it might not be that performance efficient to use the guard everywhere, but it reduces memory spikes. The more guards used, the more frequent the frees can be, reducing the memory spike, but approximating the allocator to a &quot;general allocator&quot; with 
                    <code>new</code>
                    /
                    <code>free</code>
                    . It's all about lifetimes. A good use of the guard is when placed where it prevents memory spikes and it's not frequent enough so it becomes inefficient.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<p>
    <code>base:runtime -&gt; default_temp_allocator_arena.odin + default_temporary_allocator.odin</code>
</p>
<ul>
	<li>
		<p>
			<strong>
                Begin
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> @(require_results)
 arena_temp_begin :: proc(arena: ^Arena, loc := #caller_location) -&gt; (temp: Arena_Temp) {
 Â  Â  assert(arena != nil, "nil arena", loc)
 Â  Â  temp.arena = arena
 Â  Â  temp.block = arena.curr_block
 Â  Â  if arena.curr_block != nil {
 Â  Â  Â  Â  temp.used = arena.curr_block.used
 Â  Â  }
 Â  Â  arena.temp_count += 1
 Â  Â  return
 }
 
 @(require_results)
 default_temp_allocator_temp_begin :: proc(loc := #caller_location) -&gt; (temp: Arena_Temp) {
&nbsp;&nbsp;&nbsp;&nbsp; if context.temp_allocator.data == &global_default_temp_allocator_data {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = arena_temp_begin(&global_default_temp_allocator_data.arena, loc)
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; return
 }
</code></pre>
		<ul>
			<li>
				<p>
                    The 
                    <code>runtime.Arena</code>
                    &nbsp;has a 
                    <code>temp_count</code>
                    &nbsp;to keep track to not used 
                    <code>_end</code>
                    &nbsp;twice in a row; if you just use the 
					<strong>
                        guard
					</strong>
                    , then this shouldn't matter.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                End
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> mem_free :: #force_no_inline proc(ptr: rawptr, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
 Â  Â  if ptr == nil || allocator.procedure == nil {
 Â  Â  Â  Â  return nil
 Â  Â  }
 Â  Â  _, err := allocator.procedure(allocator.data, .Free, 0, 0, ptr, 0, loc)
 Â  Â  return err
 }
 
 memory_block_dealloc :: proc "contextless" (block_to_free: ^Memory_Block, loc := #caller_location) {
 Â  Â  if block_to_free != nil {
 Â  Â  Â  Â  allocator := block_to_free.allocator
 Â  Â  Â  Â  // sanitizer.address_unpoison(block_to_free.base, block_to_free.capacity)
 Â  Â  Â  Â  context = default_context()
 Â  Â  Â  Â  context.allocator = allocator
 Â  Â  Â  Â  mem_free(block_to_free, allocator, loc)
 Â  Â  }
 }
 
 arena_free_last_memory_block :: proc(arena: ^Arena, loc := #caller_location) {
 Â  Â  if free_block := arena.curr_block; free_block != nil {
 Â  Â  Â  Â  arena.curr_block = free_block.prev
 Â  Â  Â  Â  
 Â  Â  Â  Â  arena.total_capacity -= free_block.capacity
 Â  Â  Â  Â  memory_block_dealloc(free_block, loc)
 Â  Â  }
 }
&nbsp;&nbsp; 
 arena_temp_end :: proc(temp: Arena_Temp, loc := #caller_location) {
 Â  Â  if temp.arena == nil {
 Â  Â  Â  Â  assert(temp.block == nil)
 Â  Â  Â  Â  assert(temp.used == 0)
 Â  Â  Â  Â  return
 Â  Â  }
 Â  Â  arena := temp.arena
 Â  Â  if temp.block != nil {
 Â  Â  Â  Â  memory_block_found := false
 Â  Â  Â  Â  for block := arena.curr_block; block != nil; block = block.prev {
 Â  Â  Â  Â  Â  Â  if block == temp.block {
 Â  Â  Â  Â  Â  Â  Â  Â  memory_block_found = true
 Â  Â  Â  Â  Â  Â  Â  Â  break
 Â  Â  Â  Â  Â  Â  }
 Â  Â  Â  Â  }
 Â  Â  Â  Â  if !memory_block_found {
 Â  Â  Â  Â  Â  Â  assert(arena.curr_block == temp.block, "memory block stored within Arena_Temp not owned by Arena", loc)
 Â  Â  Â  Â  }
 Â  Â  Â  Â  for arena.curr_block != temp.block {
 Â  Â  Â  Â  Â  Â  arena_free_last_memory_block(arena)
 Â  Â  Â  Â  }
 Â  Â  Â  Â  if block := arena.curr_block; block != nil {
 Â  Â  Â  Â  Â  Â  assert(block.used &gt;= temp.used, "out of order use of arena_temp_end", loc)
 Â  Â  Â  Â  Â  Â  amount_to_zero := block.used-temp.used
 Â  Â  Â  Â  Â  Â  intrinsics.mem_zero(block.base[temp.used:], amount_to_zero)
 Â  Â  Â  Â  Â  Â  // sanitizer.address_poison(block.base[temp.used:block.capacity])
 Â  Â  Â  Â  Â  Â  block.used = temp.used
 Â  Â  Â  Â  Â  Â  arena.total_used -= amount_to_zero
 Â  Â  Â  Â  }
 Â  Â  }
 Â  Â  assert(arena.temp_count &gt; 0, "double-use of arena_temp_end", loc)
 Â  Â  arena.temp_count -= 1
 }
 
 default_temp_allocator_temp_end :: proc(temp: Arena_Temp, loc := #caller_location) {
&nbsp;&nbsp;&nbsp;&nbsp; arena_temp_end(temp, loc)
 }
</code></pre>
		<ul>
			<li>
				<p>
                    The most important operations are:
				</p>
				<ul>
					<li>
						<p>
                            Frees any 
							<em>
                                new
							</em>
                            &nbsp;memory blocks from the 
                            <code>context.temp_allocator</code>
                            , comparing to the memory block stored on 
                            <code>arena_temp_begin</code>
                            :
						</p>
<pre><code class="language-odin" data-lang="odin"> for arena.curr_block != temp.block {
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
		<p>
            Â  Â  Â  Â  Â  Â  arena_free_last_memory_block(arena)
            <br>
            }
            <br>
            <code>- Internally:</code>
            odin
            <br>
            arena.curr_block = free_block.prev
            <br>
            arena.total_capacity -= free_block.capacity
            <br>
            <code>-&nbsp;&nbsp;- Zero the extra memory used during the scope:</code>
            odin
            <br>
            amount_to_zero := block.used-temp.used
            <br>
            intrinsics.mem_zero(block.base[temp.used:], amount_to_zero)
            <br>
            <code>- Revert the `arena.curr_block.used` and `arena.total_used` </code>
            odin
            <br>
            block.used = temp.used&nbsp;&nbsp;// 
            <code>block</code>
            &nbsp;is 
            <code>arena.curr_block</code>
            &nbsp;in this case.
            <br>
            arena.total_used -= amount_to_zero
            <br>
            ```
		</p>
	</li>
	<li>
		<p>
			<strong>
                Guard
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This one is used 
					<strong>
                        A LOT
					</strong>
                    &nbsp;in the 
                    <code>core</code>
                    &nbsp;library.
				</p>
			</li>
			<li>
				<p>
                    The return value from this procedure is never handled on purpose. The only reason there is a return is to send it to the 
                    <code>default_temp_allocator_temp_end</code>
                    &nbsp;on exiting the scope. The user doesn't usually care about the 
                    <code>Arena_Temp</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(deferred_out=default_temp_allocator_temp_end)
 DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD :: #force_inline proc(ignore := false, loc := #caller_location) -&gt; (Arena_Temp, Source_Code_Location) {
 Â  Â  if ignore {
 Â  Â  Â  Â  return {}, loc
 Â  Â  } else {
 Â  Â  Â  Â  return default_temp_allocator_temp_begin(loc), loc
 Â  Â  }
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Ignore
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Ignore the use of a 
                    <code>arena_temp_begin</code>
                    &nbsp;entirely.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>ignore</code>
                    &nbsp;is usually used like so, for example:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD(ignore = context.temp_allocator == context.allocator)
</code></pre>
<pre><code class="language-odin" data-lang="odin"> arena_temp_ignore :: proc(temp: Arena_Temp, loc := #caller_location) {
 Â  Â  assert(temp.arena != nil, "nil arena", loc)
 Â  Â  arena := temp.arena
 Â  Â  assert(arena.temp_count &gt; 0, "double-use of arena_temp_end", loc)
 Â  Â  arena.temp_count -= 1
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Check
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> arena_check_temp :: proc(arena: ^Arena, loc := #caller_location) {
 Â  Â  assert(arena.temp_count == 0, "Arena_Temp not been ended", loc)
 }
</code></pre>
	</li>
</ul>
<h3
	id="scratch-allocator" >
    Scratch Allocator
</h3>
<ul>
	<li>
		<p>
            The scratch allocator works in a similar way to the 
            <code>Arena</code>
            &nbsp;allocator.
		</p>
	</li>
	<li>
		<p>
            It has a backing buffer that is allocated in contiguous regions, from start to end.
		</p>
	</li>
	<li>
		<p>
            Each subsequent allocation will be the next adjacent region of memory in the backing buffer.
		</p>
	</li>
	<li>
		<p>
			<em>
                If the allocation doesn't fit into the remaining space of the backing buffer, this allocation is put at the start of the buffer, and all previous allocations will become invalidated.
			</em>
		</p>
	</li>
	<li>
		<p>
			<strong>
                If doesn't fit
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If the allocation doesn't fit into the backing buffer as a whole, it will be allocated using a backing allocator, and the pointer to the allocated memory region will be put into the 
                    <code>leaked_allocations</code>
                    &nbsp;array. A 
                    <code>Warning</code>
                    -level log message will be sent as well.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>leaked_allocations</code>
                    &nbsp;array is managed by the 
                    <code>context</code>
                    &nbsp;allocator if no 
                    <code>backup_allocator</code>
                    &nbsp;is specified in 
                    <code>scratch_init</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
scratch_allocator :: proc(allocator: ^Scratch) -&gt; Allocator {
Â  Â  return Allocator{
Â  Â  Â  Â  procedure = scratch_allocator_proc,
Â  Â  Â  Â  data = allocator,
Â  Â  }
}
</code></pre>
<h5
	id="resize" >
    Resize
</h5>
<ul>
	<li>
		<p>
            Allocations which are resized will be resized in-place if they were the last allocation. Otherwise, they are re-allocated to avoid overwriting previous allocations.
		</p>
	</li>
</ul>
<h3
	id="stack-allocator-lifo" >
    Stack Allocator (LIFO)
</h3>
<ul>
	<li>
		<p>
            The stack allocator is an allocator that allocates data in the backing buffer linearly, from start to end. Each subsequent allocation will get the next adjacent memory region.
		</p>
	</li>
	<li>
		<p>
			<em>
                Unlike arena allocator, the stack allocator saves allocation metadata and has a strict freeing order. Only the last allocated element can be freed. After the last allocated element is freed, the next previous allocated element becomes available for freeing.
			</em>
		</p>
	</li>
	<li>
		<p>
            The metadata is stored in the allocation headers, that are located before the start of each allocated memory region. Each header points to the start of the previous allocation header.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2019/02/15/memory-allocation-strategies-003/" 
				class="external-link" 
				target="_blank" >
                Stack Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A stack-like allocator means that the allocator acts like a data structure following the last-in, first-out (LIFO) principle.
		</p>
	</li>
	<li>
		<p>
            This has nothing to do with the stack or the stack frame.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Evolution of an Arena Allocator
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    As with the arena allocator, an offset into the memory block will be stored and will be moved forwards on every allocation.
				</p>
			</li>
			<li>
				<p>
                    The difference is that the offset can also be moved backwards when memory is freed. With an arena, you could only free all the memory all at once.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Stack :: struct {
Â  Â  data: Â  Â  Â  Â []byte,
Â  Â  prev_offset: int,
Â  Â  curr_offset: int,
Â  Â  peak_used: Â  int,
}


Stack_Allocation_Header :: struct {
Â  Â  prev_offset: int,
Â  Â  padding: Â  Â  int,
}

@(require_results)
stack_allocator :: proc(stack: ^Stack) -&gt; Allocator {
Â  Â  return Allocator{
Â  Â  Â  Â  procedure = stack_allocator_proc,
Â  Â  Â  Â  data Â  Â  Â = stack,
Â  Â  }
}
</code></pre>
<h5
	id="header" >
    Header
</h5>
<ul>
	<li>
		<p>
            The offset of the previous allocation needs to be tracked. This is required in order to free memory on a 
			<em>
                per-allocation
			</em>
            &nbsp;basis.
		</p>
	</li>
	<li>
		<p>
            One approach is to store a 
			<em>
                header
			</em>
            &nbsp;which stores information about that allocation. This 
			<em>
                header
			</em>
            &nbsp;allows the allocator to know how far back it should move the offset to free that memory.
		</p>
		<ul>
			<li>
				<p>
                    The stack allocator is the first of many allocators that will use the concept of a 
					<em>
                        header
					</em>
                    &nbsp;for allocations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            To allocate some memory from the stack allocator, as with the arena allocator, it is as simple as moving the offset forward while accounting for the header. In Big-O notation, the allocation has complexity of 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            &nbsp;(constant).
		</p>
	</li>
	<li>
		<p>
            To free a block, the header stored before the block of memory can be read in order to move the offset backwards. In Big-O notation, freeing this memory has complexity of 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            &nbsp;(constant).
		</p>
	</li>
	<li>
		<p>
			<strong>
                What's stored in the header
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There are three main approaches:
				</p>
				<ul>
					<li>
						<p>
                            Store the padding from the previous offset
						</p>
					</li>
					<li>
						<p>
                            Store the previous offset
						</p>
					</li>
					<li>
						<p>
                            Store the size of the allocation
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            See the article 
			<a
				href="https://www.gingerbill.org/article/2019/02/15/memory-allocation-strategies-003/" 
				class="external-link" 
				target="_blank" >
                Stack Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Improvements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You can extend the stack allocator even further by having two different offsets: one that starts at the beginning and increments forwards, and another that starts at the end and increments backwards. This is called a double-ended stack and allows for the maximization of memory usage whilst keeping fragmentation extremely low (as long as the offsets never overlap).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="small-stack-allocator" >
    Small Stack Allocator
</h4>
<ul>
	<li>
		<p>
            The small stack allocator is just like a 
            <code>Stack</code>
            &nbsp;allocator, with the only difference being an extremely small header size.
		</p>
	</li>
	<li>
		<p>
            Unlike the stack allocator, the small stack allows out-of order freeing of memory, with the stipulation that all allocations made after the freed allocation will become invalidated upon following allocations as they will begin to overwrite the memory formerly used by the freed allocation.
		</p>
	</li>
	<li>
		<p>
            The memory is allocated in the backing buffer linearly, from start to end. Each subsequent allocation will get the next adjacent memory region.
		</p>
	</li>
	<li>
		<p>
            The metadata is stored in the allocation headers, that are located before the start of each allocated memory region. Each header contains the amount of padding bytes between that header and end of the previous allocation.
		</p>
	</li>
</ul>
<h3
	id="buddy-memory-allocation" >
    Buddy Memory Allocation
</h3>
<ul>
	<li>
		<p>
            The buddy allocator is a type of allocator that splits the backing buffer into multiple regions called 
			<em>
                buddy blocks
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Initially, the allocator only has one block with the size of the backing buffer.
		</p>
	</li>
	<li>
		<p>
            Upon each allocation, the allocator finds the smallest block that can fit the size of requested memory region, and splits the block according to the allocation size. If no block can be found, the contiguous free blocks are coalesced and the search is performed again.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2021/12/02/memory-allocation-strategies-006/" 
				class="external-link" 
				target="_blank" >
                Buddy Memory Allocation - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The buddy allocator is a powerful allocator and a conceptually simple algorithm, but implementing it efficiently is a 
			<strong>
                lot harder
			</strong>
            &nbsp;than all of the previous allocators above.
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                Buddy Algorithm
			</em>
            &nbsp;assumes that the backing memory block is a power-of-two in bytes.
		</p>
	</li>
	<li>
		<p>
            When an allocation is requested, the allocator looks for a block whose size is at least the size of the requested allocation (similar to a free list).
		</p>
	</li>
	<li>
		<p>
            If the requested allocation size is less than half of the block, it is split into two (left and right), and the two resulting blocks are called â€œbuddies.â€
		</p>
	</li>
	<li>
		<p>
            If this requested allocation size is still less than half the size of the left buddy, the buddy block is recursively split until the resulting buddy is as small as possible to fit the requested allocation size.
		</p>
	</li>
	<li>
		<p>
            When a block is released, we can try to perform coalescence on buddies (contiguous neighboring blocks).
		</p>
	</li>
	<li>
		<p>
            Similar to free lists, there are specific conditions that must be met. Coalescence cannot be performed if a block has no (free) buddy, the block is still in use, or the buddy block is partially used.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Buddy_Block :: struct #align(align_of(uint)) {
Â  Â  size: Â  Â uint,
Â  Â  is_free: bool,
}

Buddy_Allocator :: struct {
Â  Â  head: Â  Â  Â ^Buddy_Block,
Â  Â  tail: Â  Â  Â ^Buddy_Block `fmt:"-"`,
Â  Â  alignment: uint,
}
</code></pre>
<h3
	id="pool-allocator" >
    Pool Allocator
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2019/02/16/memory-allocation-strategies-004/" 
				class="external-link" 
				target="_blank" >
                Pool Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A pool splits the supplied backing buffer into 
			<em>
                chunks
			</em>
            &nbsp;of equal size and keeps track of which of the chunks are free.
		</p>
		<ul>
			<li>
				<p>
                    When an allocation is requested, a free chunk is given.
				</p>
			</li>
			<li>
				<p>
                    When a chunk is freed, it adds that chunk back to the list of free chunks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Pool allocators are extremely useful when you need to allocate chunks of memory of the same size that are created and destroyed dynamically, especially in a random order.
		</p>
	</li>
	<li>
		<p>
            Pools also have the benefit that arenas and stacks have in that they provide very little fragmentation and allocate/free in constant time 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Pool allocators are usually used to allocate 
			<em>
                groups
			</em>
            &nbsp;of â€œthingsâ€ at once which share the same lifetime.
		</p>
		<ul>
			<li>
				<p>
                    An example could be within a game that creates and destroys entities in batches where each entity within a batch shares the same lifetime.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Free List
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://wikipedia.org/wiki/Free_list" 
						class="external-link" 
						target="_blank" >
                        free list
					</a>
                    &nbsp;is a data structure that internally stores a 
					<a
						href="https://wikipedia.org/wiki/Linked_list" 
						class="external-link" 
						target="_blank" >
                        linked list
					</a>
                    &nbsp;of the free slots/chunks within the memory buffer.
				</p>
			</li>
			<li>
				<p>
                    The nodes of the list are stored in-place, meaning there is no need for an additional data structure (e.g., array, list, etc.) to keep track of the free slots.
				</p>
			</li>
			<li>
				<p>
                    The data is 
					<em>
                        only
					</em>
                    &nbsp;stored 
					<em>
                        within
					</em>
                    &nbsp;the backing buffer of the pool allocator.
				</p>
			</li>
			<li>
				<p>
                    The general approach is to store a header at the beginning of the chunk (not before the chunk like with the stack allocator) which 
					<em>
                        points
					</em>
                    &nbsp;to the next available free chunk.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/code/memory-allocation-strategies/part004.c" 
				class="external-link" 
				target="_blank" >
                Full implementation - Ginger Bill
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="general-purpose-free-list-based-allocator" >
    General Purpose: Free List Based Allocator
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2021/11/30/memory-allocation-strategies-005/" 
				class="external-link" 
				target="_blank" >
                Free List Based Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A free list is a general-purpose allocator which, compared to the other allocators we previously looked at, does not impose any restrictions.
		</p>
	</li>
	<li>
		<p>
            It allows allocations and deallocations to be out of order and of any size.
		</p>
	</li>
	<li>
		<p>
            Due to its nature, the allocatorâ€™s 
			<strong>
                performance is not as good
			</strong>
            &nbsp;as the others previously discussed in this series.
		</p>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            There are two common approaches to implementing a free list allocator:
		</p>
		<ul>
			<li>
				<p>
                    Using a 
					<a
						href="https://wikipedia.org/wiki/Linked_list" 
						class="external-link" 
						target="_blank" >
                        linked list
					</a>
				</p>
			</li>
			<li>
				<p>
                    Using a 
					<a
						href="https://wikipedia.org/wiki/Red%E2%80%93black_tree" 
						class="external-link" 
						target="_blank" >
                        red-black tree
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            See the article for the implementations.
		</p>
	</li>
</ul>
<h3
	id="general-purpose-heap-allocator" >
    General Purpose: Heap Allocator
</h3>
<ul>
	<li>
		<p>
            Heap Allocators are a high level construct, and a specific kind of allocator.
		</p>
	</li>
	<li>
		<p>
            Odin just generalizes the concept of an allocator.
		</p>
	</li>
	<li>
		<p>
            A heap in general is a data structure and in the context of allocators it is a &quot;general purpose allocator&quot;. Most common heap allocators are built on top of allocating virtual memory directly. The point of the &quot;general purpose&quot; aspect means you can allocate &quot;things&quot; of varying size, alignment, and free them at arbitrary times (i.e. the lifetimes of each allocation is out of order). And to do this, they require storing some sort of metadata about the size of the allocation, and where the free allocations are (called a free list). More complicated algorithms do more things to be more efficient.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
heap_allocator :: proc() -&gt; Allocator {
Â  Â  return Allocator{
Â  Â  Â  Â  procedure = heap_allocator_proc,
Â  Â  Â  Â  data = nil,
Â  Â  }
}
</code></pre>
<h5
	id="in-codeos2-code" >
    In 
    <code>os2</code>
</h5>
<ul>
	<li>
		<p>
            The 
            <code>heap_allocator</code>
            &nbsp;is redefined internally if using Windows.
		</p>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    I'd guess probably because 
					<a
						href="https://github.com/odin-lang/Odin/pull/4749" 
						class="external-link" 
						target="_blank" >
                        <code>runtime.heap_allocator</code>
                        &nbsp;may eventually become an Odin-implemented heap allocator
					</a>
                    , and 
                    <code>os.heap_allocator</code>
                    &nbsp;is intended to specifically use the underlying OS allocator (which 
                    <code>runtime.heap_allocator</code>
                    &nbsp;currently also is).
				</p>
			</li>
			<li>
				<p>
                    This is done so 
                    <code>os.heap_allocator</code>
                    &nbsp;is 
					<em>
                        the OS's heap allocator
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    As for 
                    <code>os2</code>
                    &nbsp;using its own allocators instead of 
                    <code>context</code>
                    &nbsp;ones... OS Stuff is Differentâ„¢ is the usual reply I've seen.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="using-codeheap_allocator-code" >
    Using 
    <code>heap_allocator()</code>
</h5>
<ul>
	<li>
		<p>
            The procedure uses 
            <code>data = nil</code>
            , while the 
            <code>heap_allocator_proc</code>
            &nbsp;doesn't use the 
            <code>allocator_data: rawptr</code>
            . This means that every call to 
            <code>heap_allocator</code>
            &nbsp;uses the same backing region from the OS heap allocator implemented.
		</p>
	</li>
	<li>
		<p>
            Example:
		</p>
<pre><code class="language-odin" data-lang="odin"> a := runtime.heap_allocator()
 b := runtime.heap_allocator()
</code></pre>
		<ul>
			<li>
				<p>
                    <code>a</code>
                    &nbsp;and 
                    <code>b</code>
                    &nbsp;are the same. There's no new 
                    <code>mmap</code>
                    , or etc, being made.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="is-thread-safe" >
    Is thread-safe?
</h5>
<ul>
	<li>
		<p>
            Yes.
		</p>
	</li>
	<li>
		<p>
            It's just uses what the OS provides. which generally are, yes. And when we have our own malloc implementation, it'll be thread-safe too.
		</p>
		<ul>
			<li>
				<p>
                    The current PR for it: 
					<a
						href="https://github.com/odin-lang/Odin/pull/4749" 
						class="external-link" 
						target="_blank" >
                        https://github.com/odin-lang/Odin/pull/4749
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ChatGPT: &quot;The C standard library implementations of 
            <code>malloc</code>
            , 
            <code>calloc</code>
            , 
            <code>realloc</code>
            , and 
            <code>free</code>
            &nbsp;provided by all mainstream libc variants (glibc, musl, BSD libc, Windows CRT, etc.) are thread-safe. They use internal locking or per-thread arenas to avoid corruption.&quot;
		</p>
	</li>
</ul>
<h5
	id="allocator-proc" >
    Allocator Proc
</h5>
<pre><code class="language-odin" data-lang="odin">heap_allocator_proc :: proc(allocator_data: rawptr, mode: Allocator_Mode,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  size, alignment: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  old_memory: rawptr, old_size: int, loc := #caller_location) -&gt; ([]byte, Allocator_Error) {
Â  Â  // NOTE(tetra, 2020-01-14): The heap doesn't respect alignment.
Â  Â  // Instead, we overallocate by `alignment + size_of(rawptr) - 1`, and insert
Â  Â  // padding. We also store the original pointer returned by heap_alloc right before
Â  Â  // the pointer we return to the user.
Â  Â  aligned_alloc :: proc(size, alignment: int, old_ptr: rawptr, old_size: int, zero_memory := true) -&gt; ([]byte, Allocator_Error) {
Â  Â  Â  Â  // Not(flysand): We need to reserve enough space for alignment, which
Â  Â  Â  Â  // includes the user data itself, the space to store the pointer to
Â  Â  Â  Â  // allocation start, as well as the padding required to align both
Â  Â  Â  Â  // the user data and the pointer.
Â  Â  Â  Â  a := max(alignment, align_of(rawptr))
Â  Â  Â  Â  space := a-1 + size_of(rawptr) + size
Â  Â  Â  Â  allocated_mem: rawptr
Â  Â  Â  Â  force_copy := old_ptr != nil && alignment &gt; align_of(rawptr)
Â  Â  Â  Â  if old_ptr != nil && !force_copy {
Â  Â  Â  Â  Â  Â  original_old_ptr := ([^]rawptr)(old_ptr)[-1]
Â  Â  Â  Â  Â  Â  allocated_mem = heap_resize(original_old_ptr, space)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  allocated_mem = heap_alloc(space, zero_memory)
Â  Â  Â  Â  }
Â  Â  Â  Â  aligned_mem := rawptr(([^]u8)(allocated_mem)[size_of(rawptr):])
Â  Â  Â  Â  ptr := uintptr(aligned_mem)
Â  Â  Â  Â  aligned_ptr := (ptr + uintptr(a)-1) & ~(uintptr(a)-1)
Â  Â  Â  Â  if allocated_mem == nil {
Â  Â  Â  Â  Â  Â  aligned_free(old_ptr)
Â  Â  Â  Â  Â  Â  aligned_free(allocated_mem)
Â  Â  Â  Â  Â  Â  return nil, .Out_Of_Memory
Â  Â  Â  Â  }
Â  Â  Â  Â  aligned_mem = rawptr(aligned_ptr)
Â  Â  Â  Â  ([^]rawptr)(aligned_mem)[-1] = allocated_mem
Â  Â  Â  Â  if force_copy {
Â  Â  Â  Â  Â  Â  mem_copy_non_overlapping(aligned_mem, old_ptr, min(old_size, size))
Â  Â  Â  Â  Â  Â  aligned_free(old_ptr)
Â  Â  Â  Â  }
Â  Â  Â  Â  return byte_slice(aligned_mem, size), nil
Â  Â  }
Â  Â  
Â  Â  aligned_free :: proc(p: rawptr) {
Â  Â  Â  Â  if p != nil {
Â  Â  Â  Â  Â  Â  heap_free(([^]rawptr)(p)[-1])
Â  Â  Â  Â  }
Â  Â  }
Â  Â  
Â  Â  aligned_resize :: proc(p: rawptr, old_size: int, new_size: int, new_alignment: int, zero_memory := true) -&gt; (new_memory: []byte, err: Allocator_Error) {
Â  Â  Â  Â  if p == nil {
Â  Â  Â  Â  Â  Â  return aligned_alloc(new_size, new_alignment, nil, old_size, zero_memory)
Â  Â  Â  Â  }
Â  Â  Â  Â  new_memory = aligned_alloc(new_size, new_alignment, p, old_size, zero_memory) or_return
Â  Â  Â  Â  when ODIN_OS != .Windows {
Â  Â  Â  Â  Â  Â  // NOTE: heap_resize does not zero the new memory, so we do it
Â  Â  Â  Â  Â  Â  if zero_memory && new_size &gt; old_size {
Â  Â  Â  Â  Â  Â  Â  Â  new_region := raw_data(new_memory[old_size:])
Â  Â  Â  Â  Â  Â  Â  Â  conditional_mem_zero(new_region, new_size - old_size)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  }
Â  Â  
Â  Â  switch mode {
Â  Â  case .Alloc, .Alloc_Non_Zeroed:
Â  Â  Â  Â  return aligned_alloc(size, alignment, nil, 0, mode == .Alloc)
Â  Â  case .Free:
Â  Â  Â  Â  aligned_free(old_memory)
Â  Â  case .Free_All:
Â  Â  Â  Â  return nil, .Mode_Not_Implemented
Â  Â  case .Resize, .Resize_Non_Zeroed:
Â  Â  Â  Â  return aligned_resize(old_memory, old_size, size, alignment, mode == .Resize)
Â  Â  case .Query_Features:
Â  Â  Â  Â  set := (^Allocator_Mode_Set)(old_memory)
Â  Â  Â  Â  if set != nil {
Â  Â  Â  Â  Â  Â  set^ = {.Alloc, .Alloc_Non_Zeroed, .Free, .Resize, .Resize_Non_Zeroed, .Query_Features}
Â  Â  Â  Â  }
Â  Â  Â  Â  return nil, nil
Â  Â  case .Query_Info:
Â  Â  Â  Â  return nil, .Mode_Not_Implemented
Â  Â  }
Â  Â  return nil, nil
}
</code></pre>
<h5
	id="alloc" >
    Alloc
</h5>
<pre><code class="language-odin" data-lang="odin">heap_alloc :: proc "contextless" (size: int, zero_memory := true) -&gt; rawptr {
Â  Â  return _heap_alloc(size, zero_memory)
}
</code></pre>
<ul>
	<li>
		<p>
            Linux:
		</p>
<pre><code class="language-odin" data-lang="odin"> @(default_calling_convention="c")
 foreign libc {
 Â  Â  @(link_name="malloc") Â  _unix_malloc Â  :: proc(size: int) -&gt; rawptr ---
 Â  Â  @(link_name="calloc") Â  _unix_calloc Â  :: proc(num, size: int) -&gt; rawptr ---
 }
 
 _heap_alloc :: proc "contextless" (size: int, zero_memory := true) -&gt; rawptr {
 Â  Â  if size &lt;= 0 {
 Â  Â  Â  Â  return nil
 Â  Â  }
 Â  Â  if zero_memory {
 Â  Â  Â  Â  return _unix_calloc(1, size)
 Â  Â  } else {
 Â  Â  Â  Â  return _unix_malloc(size)
 Â  Â  }
 }
</code></pre>
		<ul>
			<li>
				<p>
                    Uses the C library allocator (
                    <code>malloc</code>
                    , 
                    <code>calloc</code>
                    ) layered over 
                    <code>brk</code>
                    &nbsp;or 
                    <code>mmap</code>
                    &nbsp;system calls.
				</p>
			</li>
			<li>
				<p>
                    The kernel itself does not expose a &quot;heap&quot; API to user space.
				</p>
			</li>
			<li>
				<p>
                    Each C library (glibc, musl, jemalloc, etc.) implements its own allocator strategy.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Windows:
		</p>
<pre><code class="language-odin" data-lang="odin"> _heap_alloc :: proc "contextless" (size: int, zero_memory := true) -&gt; rawptr {
 Â  Â  HEAP_ZERO_MEMORY :: 0x00000008
 Â  Â  ptr := HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY if zero_memory else 0, uint(size))
 Â  Â  // NOTE(lucas): asan not guarunteed to unpoison win32 heap out of the box, do it ourselves
 Â  Â  sanitizer.address_unpoison(ptr, size)
 Â  Â  return ptr
 }
</code></pre>
		<ul>
			<li>
				<p>
                    The heap system (
                    <code>HeapAlloc</code>
                    , 
                    <code>HeapFree</code>
                    , etc.) is part of the 
					<strong>
                        Win32 API
					</strong>
                    , built over the NT kernelâ€™s virtual memory manager.
				</p>
			</li>
			<li>
				<p>
                    Each process has one or more 
					<strong>
                        heaps
					</strong>
                    &nbsp;managed by the kernel.
				</p>
			</li>
			<li>
				<p>
                    <code>HeapAlloc(GetProcessHeap(), ...)</code>
                    &nbsp;allocates from the process heap directly, with flags controlling behavior (e.g., 
                    <code>HEAP_ZERO_MEMORY</code>
                    &nbsp;for zeroing).
				</p>
			</li>
			<li>
				<p>
                    This unifies allocation across the system and avoids relying on C runtime internals, which can differ between MSVC, MinGW, etc.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="resize" >
    Resize
</h5>
<pre><code class="language-odin" data-lang="odin">heap_resize :: proc "contextless" (ptr: rawptr, new_size: int) -&gt; rawptr {
Â  Â  return _heap_resize(ptr, new_size)
}
</code></pre>
<ul>
	<li>
		<p>
            Linux:
		</p>
<pre><code class="language-odin" data-lang="odin"> @(default_calling_convention="c")
 foreign libc {
 Â  Â  @(link_name="realloc") Â _unix_realloc Â :: proc(ptr: rawptr, size: int) -&gt; rawptr ---
 }
 
 _heap_resize :: proc "contextless" (ptr: rawptr, new_size: int) -&gt; rawptr {
 Â  Â  // NOTE: _unix_realloc doesn't guarantee new memory will be zeroed on
 Â  Â  // POSIX platforms. Ensure your caller takes this into account.
 Â  Â  return _unix_realloc(ptr, new_size)
 }
</code></pre>
	</li>
	<li>
		<p>
            Windows:
		</p>
<pre><code class="language-odin" data-lang="odin"> _heap_resize :: proc "contextless" (ptr: rawptr, new_size: int) -&gt; rawptr {
 Â  Â  if new_size == 0 {
 Â  Â  Â  Â  _heap_free(ptr)
 Â  Â  Â  Â  return nil
 Â  Â  }
 Â  Â  if ptr == nil {
 Â  Â  Â  Â  return _heap_alloc(new_size)
 Â  Â  }
 Â  Â  HEAP_ZERO_MEMORY :: 0x00000008
 Â  Â  new_ptr := HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ptr, uint(new_size))
 Â  Â  // NOTE(lucas): asan not guarunteed to unpoison win32 heap out of the box, do it ourselves
 Â  Â  sanitizer.address_unpoison(new_ptr, new_size)
 Â  Â  return new_ptr
 }
</code></pre>
	</li>
</ul>
<h5
	id="free" >
    Free
</h5>
<pre><code class="language-odin" data-lang="odin">heap_free :: proc "contextless" (ptr: rawptr) {
Â  Â  _heap_free(ptr)
}
</code></pre>
<ul>
	<li>
		<p>
            Linux:
		</p>
<pre><code class="language-odin" data-lang="odin"> @(default_calling_convention="c")
 foreign libc {
 Â  Â  @(link_name="free") Â  Â  _unix_free Â  Â  :: proc(ptr: rawptr) ---
 }
 
 _heap_free :: proc "contextless" (ptr: rawptr) {
 Â  Â  _unix_free(ptr)
 }
</code></pre>
	</li>
	<li>
		<p>
            Windows:
		</p>
<pre><code class="language-odin" data-lang="odin"> _heap_free :: proc "contextless" (ptr: rawptr) {
 Â  Â  if ptr == nil {
 Â  Â  Â  Â  return
 Â  Â  }
 Â  Â  HeapFree(GetProcessHeap(), 0, ptr)
 }
</code></pre>
	</li>
</ul>
<h3
	id="compact-allocator" >
    Compact Allocator
</h3>
<ul>
	<li>
		<p>
            An allocator that keeps track of allocation sizes and passes it along to resizes.
		</p>
	</li>
	<li>
		<p>
            This is useful if you are using a library that needs an equivalent of 
            <code>realloc</code>
            &nbsp;but want to use the Odin allocator interface.
		</p>
	</li>
	<li>
		<p>
            You want to wrap your allocator into this one if you are trying to use any allocator that relies on the old size to work.
		</p>
	</li>
	<li>
		<p>
            The overhead of this allocator is an extra 
            <code>max(alignment, size_of(Header))</code>
            &nbsp;bytes allocated for each allocation, these bytes are used to store the size and alignment.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Compat_Allocator :: struct {
Â  Â  parent: Allocator,
}
</code></pre>
<h5
	id="allocator-procedure" >
    Allocator Procedure
</h5>
<pre><code class="language-odin" data-lang="odin">compat_allocator_proc :: proc(allocator_data: rawptr, mode: Allocator_Mode,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â size, alignment: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â old_memory: rawptr, old_size: int,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â location := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  Header :: struct {
Â  Â  Â  Â  size: Â  Â  Â int,
Â  Â  Â  Â  alignment: int,
Â  Â  }
Â  Â  @(no_sanitize_address)
Â  Â  get_unpoisoned_header :: #force_inline proc(ptr: rawptr) -&gt; Header {
Â  Â  Â  Â  header := ([^]Header)(ptr)[-1]
Â  Â  Â  Â  // a Â  Â  Â := max(header.alignment, size_of(Header))
Â  Â  Â  Â  // sanitizer.address_unpoison(rawptr(uintptr(ptr)-uintptr(a)), a)
Â  Â  Â  Â  return header
Â  Â  }
Â  Â  rra := (^Compat_Allocator)(allocator_data)
Â  Â  switch mode {
Â  Â  case .Alloc, .Alloc_Non_Zeroed:
Â  Â  Â  Â  a Â  Â  Â  Â := max(alignment, size_of(Header))
Â  Â  Â  Â  req_size := size + a
Â  Â  Â  Â  assert(req_size &gt;= 0, "overflow")
Â  Â  Â  Â  allocation := rra.parent.procedure(rra.parent.data, mode, req_size, alignment, old_memory, old_size, location) or_return
Â  Â  Â  Â  #no_bounds_check data = allocation[a:]
Â  Â  Â  Â  ([^]Header)(raw_data(data))[-1] = {
Â  Â  Â  Â  Â  Â  size Â  Â  Â = size,
Â  Â  Â  Â  Â  Â  alignment = alignment,
Â  Â  Â  Â  }
Â  Â  Â  Â  // sanitizer.address_poison(raw_data(allocation), a)
Â  Â  Â  Â  return
Â  Â  case .Free:
Â  Â  Â  Â  header Â  Â := get_unpoisoned_header(old_memory)
Â  Â  Â  Â  a Â  Â  Â  Â  := max(header.alignment, size_of(Header))
Â  Â  Â  Â  orig_ptr Â := rawptr(uintptr(old_memory)-uintptr(a))
Â  Â  Â  Â  orig_size := header.size + a
Â  Â  Â  Â  return rra.parent.procedure(rra.parent.data, mode, orig_size, header.alignment, orig_ptr, orig_size, location)
Â  Â  case .Resize, .Resize_Non_Zeroed:
Â  Â  Â  Â  header Â  Â := get_unpoisoned_header(old_memory)
Â  Â  Â  Â  orig_a Â  Â := max(header.alignment, size_of(Header))
Â  Â  Â  Â  orig_ptr Â := rawptr(uintptr(old_memory)-uintptr(orig_a))
Â  Â  Â  Â  orig_size := header.size + orig_a
Â  Â  Â  Â  new_alignment := max(header.alignment, alignment)
Â  Â  Â  Â  a Â  Â  Â  Â := max(new_alignment, size_of(header))
Â  Â  Â  Â  req_size := size + a
Â  Â  Â  Â  assert(size &gt;= 0, "overflow")
Â  Â  Â  Â  allocation := rra.parent.procedure(rra.parent.data, mode, req_size, new_alignment, orig_ptr, orig_size, location) or_return
Â  Â  Â  Â  #no_bounds_check data = allocation[a:]
Â  Â  Â  Â  ([^]Header)(raw_data(data))[-1] = {
Â  Â  Â  Â  Â  Â  size Â  Â  Â = size,
Â  Â  Â  Â  Â  Â  alignment = new_alignment,
Â  Â  Â  Â  }
Â  Â  Â  Â  // sanitizer.address_poison(raw_data(allocation), a)
Â  Â  Â  Â  return
Â  Â  case .Free_All:
Â  Â  Â  Â  return rra.parent.procedure(rra.parent.data, mode, size, alignment, old_memory, old_size, location)
Â  Â  case .Query_Info:
Â  Â  Â  Â  info := (^Allocator_Query_Info)(old_memory)
Â  Â  Â  Â  if info != nil && info.pointer != nil {
Â  Â  Â  Â  Â  Â  header := get_unpoisoned_header(info.pointer)
Â  Â  Â  Â  Â  Â  info.size Â  Â  Â = header.size
Â  Â  Â  Â  Â  Â  info.alignment = header.alignment
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  case .Query_Features:
Â  Â  Â  Â  data, err = rra.parent.procedure(rra.parent.data, mode, size, alignment, old_memory, old_size, location)
Â  Â  Â  Â  if err != nil {
Â  Â  Â  Â  Â  Â  set := (^Allocator_Mode_Set)(old_memory)
Â  Â  Â  Â  Â  Â  set^ += {.Query_Info}
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  case: unreachable()
Â  Â  }
}
</code></pre>
<h3
	id="mutex-allocator" >
    Mutex Allocator
</h3>
<ul>
	<li>
		<p>
            The mutex allocator is a wrapper for allocators that is used to serialize all allocator requests across multiple threads.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Mutex_Allocator :: struct {
Â  Â  backing: Allocator,
Â  Â  mutex: Â  sync.Mutex,
}

@(require_results)
mutex_allocator :: proc(m: ^Mutex_Allocator) -&gt; Allocator {
Â  Â  return Allocator{
Â  Â  Â  Â  procedure = mutex_allocator_proc,
Â  Â  Â  Â  data = m,
Â  Â  }
}
</code></pre>
<h5
	id="allocator-procedure" >
    Allocator Procedure
</h5>
<pre><code class="language-odin" data-lang="odin">mutex_allocator_proc :: proc(
Â  Â  allocator_data: rawptr,
Â  Â  mode: Allocator_Mode,
Â  Â  size: int,
Â  Â  alignment: int,
Â  Â  old_memory: rawptr,
Â  Â  old_size: int,
Â  Â  loc := #caller_location,
) -&gt; (result: []byte, err: Allocator_Error) {
Â  Â  m := (^Mutex_Allocator)(allocator_data)
Â  Â  sync.mutex_guard(&m.mutex)
Â  Â  return m.backing.procedure(m.backing.data, mode, size, alignment, old_memory, old_size, loc)
}
</code></pre>
<h3
	id="rollback-stack-allocator" >
    Rollback Stack Allocator
</h3>
<ul>
	<li>
		<p>
            The Rollback Stack Allocator was designed for the test runner to be fast, able to grow, and respect the Tracking Allocator's requirement for individual frees. It is not overly concerned with fragmentation, however.
		</p>
	</li>
	<li>
		<p>
            It has support for expansion when configured with a block allocator and limited support for out-of-order frees.
		</p>
	</li>
	<li>
		<p>
            Allocation has constant-time best and usual case performance. At worst, it is linear according to the number of memory blocks.
		</p>
	</li>
	<li>
		<p>
            Allocation follows a first-fit strategy when there are multiple memory blocks.
		</p>
	</li>
	<li>
		<p>
            Freeing has constant-time best and usual case performance. At worst, it is linear according to the number of memory blocks and number of freed items preceding the last item in a block.
		</p>
	</li>
	<li>
		<p>
            Resizing has constant-time performance, if it's the last item in a block, or the new size is smaller. Naturally, this becomes linear-time if there are multiple blocks to search for the pointer's owning block. Otherwise, the allocator defaults to a combined alloc &amp; free operation internally.
		</p>
	</li>
	<li>
		<p>
            Out-of-order freeing is accomplished by collapsing a run of freed items from the last allocation backwards.
		</p>
	</li>
	<li>
		<p>
            Each allocation has an overhead of 8 bytes and any extra bytes to satisfy the requested alignment.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Rollback_Stack_Block :: struct {
Â  Â  next_block: ^Rollback_Stack_Block,
Â  Â  last_alloc: rawptr,
Â  Â  offset: uintptr,
Â  Â  buffer: []byte,
}

Rollback_Stack :: struct {
Â  Â  head: ^Rollback_Stack_Block,
Â  Â  block_size: int,
Â  Â  block_allocator: Allocator,
}
</code></pre>
<h3
	id="wasm-allocator" >
    WASM Allocator
</h3>
<pre><code class="language-odin" data-lang="odin">WASM_Allocator :: struct {
Â  Â  // The minimum alignment of allocations.
Â  Â  alignment: uint,
Â  Â  
Â  Â  // A region that contains as payload a single forward linked list of pointers to
Â  Â  // root regions of each disjoint region blocks.
Â  Â  list_of_all_regions: ^Root_Region,
Â  Â  
Â  Â  // For each of the buckets, maintain a linked list head node. The head node for each
Â  Â  // free region is a sentinel node that does not actually represent any free space, but
Â  Â  // the sentinel is used to avoid awkward testing against (if node == freeRegionHeadNode)
Â  Â  // when adding and removing elements from the linked list, i.e. we are guaranteed that
Â  Â  // the sentinel node is always fixed and there, and the actual free region list elements
Â  Â  // start at free_region_buckets[i].next each.
Â  Â  free_region_buckets: [NUM_FREE_BUCKETS]Region,
Â  Â  
Â  Â  // A bitmask that tracks the population status for each of the 64 distinct memory regions:
Â  Â  // a zero at bit position i means that the free list bucket i is empty. This bitmask is
Â  Â  // used to avoid redundant scanning of the 64 different free region buckets: instead by
Â  Â  // looking at the bitmask we can find in constant time an index to a free region bucket
Â  Â  // that contains free memory of desired size.
Â  Â  free_region_buckets_used: BUCKET_BITMASK_T,
Â  Â  
Â  Â  // Because wasm memory can only be allocated in pages of 64k at a time, we keep any
Â  Â  // spilled/unused bytes that are left from the allocated pages here, first using this
Â  Â  // when bytes are needed.
Â  Â  spill: []byte,
Â  Â  
Â  Â  // Mutex for thread safety, only used if the target feature "atomics" is enabled.
Â  Â  mu: Mutex_State,
}
</code></pre>
<h3
	id="tracking-allocator" >
    Tracking Allocator
</h3>
<ul>
	<li>
		<p>
            The tracking allocator is an allocator wrapper that tracks memory allocations.
		</p>
	</li>
	<li>
		<p>
            This allocator stores all the allocations in a map.
		</p>
	</li>
	<li>
		<p>
            Whenever a pointer that's not inside of the map is freed, the 
            <code>bad_free_array</code>
            &nbsp;entry is added.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Tracking_Allocator :: struct {
Â  Â  backing: Allocator,
Â  Â  allocation_map: map[rawptr]Tracking_Allocator_Entry,
Â  Â  bad_free_callback: Tracking_Allocator_Bad_Free_Callback,
Â  Â  bad_free_array: [dynamic]Tracking_Allocator_Bad_Free_Entry,
Â  Â  mutex: sync.Mutex,
Â  Â  clear_on_free_all: bool,
Â  Â  total_memory_allocated: i64,
Â  Â  total_allocation_count: i64,
Â  Â  total_memory_freed: i64,
Â  Â  total_free_count: i64,
Â  Â  peak_memory_allocated: i64,
Â  Â  current_memory_allocated: i64,
}
</code></pre>
<h5
	id="demo" >
    Demo
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://gist.github.com/kallixtus-git/b9e7c4ee856842e560c3eca0d0aed014" 
				class="external-link" 
				target="_blank" >
                Demo of Tracking Allocators
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/jkJlpPyBdzk?si=6hBBATkB8eOoZsmH&t=1109" 
				class="external-link" 
				target="_blank" >
                Using the Tracking Allocator to detect memory leaks and double free {18:29 -&gt; 30:40}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Very interesting.
				</p>
			</li>
			<li>
				<p>
                    The example includes Raylib.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">package foo

import "core:mem"
import "core:fmt"

main :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;track: mem.Tracking_Allocator
&nbsp;&nbsp;&nbsp;&nbsp;mem.tracking_allocator_init(&track, context.allocator)
&nbsp;&nbsp;&nbsp;&nbsp;defer mem.tracking_allocator_destroy(&track)
&nbsp;&nbsp;&nbsp;&nbsp;context.allocator = mem.tracking_allocator(&track)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;do_stuff()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for _, leak in track.allocation_map {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.printf("%v leaked %m\n", leak.location, leak.size)
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h5
	id="limitations" >
    Limitations
</h5>
<ul>
	<li>
		<p>
            &quot;I'm using the Track Allocator to know where I'm getting memory leaks, but it keeps saying the leak happened at 
            <code>C:/odin/core/strings/builder.odin(171:11) leaked 8 bytes</code>
            , but I have no idea what's the call stack, so I'm revisiting everything.&quot;
		</p>
		<ul>
			<li>
				<p>
                    &quot;It does attempt to log the location where the allocation was done, but it relies on the appropriate location being passed through. Unfortunately, that's 
					<a
						href="https://github.com/odin-lang/Odin/blob/4ec03a2d9b1c88a657829af7dc193fcb73d419bb/core/strings/builder.odin#L167" 
						class="external-link" 
						target="_blank" >
                        not always possible
					</a>
                    , e.g., the 
                    <code>io.Stream</code>
                    &nbsp;interface doesn't pass a location so when using a 
                    <code>strings.Builder</code>
                    &nbsp;as an 
                    <code>io.Stream</code>
                    &nbsp;(or anything else that 
                    <code>Stream</code>
                    s to dynamic memory), it can't easily track where it originated in 
					<em>
                        your
					</em>
                    &nbsp;code
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Virtual Arenas
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>virtual.Arena</code>
                    &nbsp;doesn't use an 
                    <code>Allocator</code>
                    &nbsp;for its backing memory; it makes direct calls to the OS's virtual memory interface. So a 
                    <code>Tracking_Allocator</code>
                    &nbsp;can't be used to back it.
				</p>
			</li>
			<li>
				<p>
                    You can use a 
                    <code>Tracking_Allocator</code>
                    &nbsp;that 
					<em>
                        wraps
					</em>
                    &nbsp;the 
                    <code>Arena</code>
                    , and the 
                    <code>Tracking_Allocator</code>
                    &nbsp;can interpret 
                    <code>free_all</code>
                    &nbsp;on it correctly (you'd have to 
                    <code>free_all</code>
                    &nbsp;before you 
                    <code>destroy</code>
                    &nbsp;the arena, otherwise the tracking allocator will see it as leaking), but personally I don't see the value of using a tracking allocator on allocations made from an arena (regardless of which one).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="allocator-procedure" >
    Allocator Procedure
</h5>
<pre><code class="language-odin" data-lang="odin">@(no_sanitize_address)
tracking_allocator_proc :: proc(
Â  Â  allocator_data: rawptr,
Â  Â  mode: Allocator_Mode,
Â  Â  size, alignment: int,
Â  Â  old_memory: rawptr,
Â  Â  old_size: int,
Â  Â  loc := #caller_location,
) -&gt; (result: []byte, err: Allocator_Error) {
Â  Â  @(no_sanitize_address)
Â  Â  track_alloc :: proc(data: ^Tracking_Allocator, entry: ^Tracking_Allocator_Entry) {
Â  Â  Â  Â  data.total_memory_allocated += i64(entry.size)
Â  Â  Â  Â  data.total_allocation_count += 1
Â  Â  Â  Â  data.current_memory_allocated += i64(entry.size)
Â  Â  Â  Â  if data.current_memory_allocated &gt; data.peak_memory_allocated {
Â  Â  Â  Â  Â  Â  data.peak_memory_allocated = data.current_memory_allocated
Â  Â  Â  Â  }
Â  Â  }
Â  Â  @(no_sanitize_address)
Â  Â  track_free :: proc(data: ^Tracking_Allocator, entry: ^Tracking_Allocator_Entry) {
Â  Â  Â  Â  data.total_memory_freed += i64(entry.size)
Â  Â  Â  Â  data.total_free_count += 1
Â  Â  Â  Â  data.current_memory_allocated -= i64(entry.size)
Â  Â  }
Â  Â  data := (^Tracking_Allocator)(allocator_data)
Â  Â  sync.mutex_guard(&data.mutex)
Â  Â  if mode == .Query_Info {
Â  Â  Â  Â  info := (^Allocator_Query_Info)(old_memory)
Â  Â  Â  Â  if info != nil && info.pointer != nil {
Â  Â  Â  Â  Â  Â  if entry, ok := data.allocation_map[info.pointer]; ok {
Â  Â  Â  Â  Â  Â  Â  Â  info.size = entry.size
Â  Â  Â  Â  Â  Â  Â  Â  info.alignment = entry.alignment
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  info.pointer = nil
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  }
Â  Â  if mode == .Free && old_memory != nil && old_memory not_in data.allocation_map {
Â  Â  Â  Â  if data.bad_free_callback != nil {
Â  Â  Â  Â  Â  Â  data.bad_free_callback(data, old_memory, loc)
Â  Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  Â  result = data.backing.procedure(data.backing.data, mode, size, alignment, old_memory, old_size, loc) or_return
Â  Â  }
Â  Â  result_ptr := raw_data(result)
Â  Â  if data.allocation_map.allocator.procedure == nil {
Â  Â  Â  Â  data.allocation_map.allocator = context.allocator
Â  Â  }
Â  Â  switch mode {
Â  Â  case .Alloc, .Alloc_Non_Zeroed:
Â  Â  Â  Â  data.allocation_map[result_ptr] = Tracking_Allocator_Entry{
Â  Â  Â  Â  Â  Â  memory = result_ptr,
Â  Â  Â  Â  Â  Â  size = size,
Â  Â  Â  Â  Â  Â  mode = mode,
Â  Â  Â  Â  Â  Â  alignment = alignment,
Â  Â  Â  Â  Â  Â  err = err,
Â  Â  Â  Â  Â  Â  location = loc,
Â  Â  Â  Â  }
Â  Â  Â  Â  track_alloc(data, &data.allocation_map[result_ptr])
Â  Â  case .Free:
Â  Â  Â  Â  if old_memory != nil && old_memory in data.allocation_map {
Â  Â  Â  Â  Â  Â  track_free(data, &data.allocation_map[old_memory])
Â  Â  Â  Â  }
Â  Â  Â  Â  delete_key(&data.allocation_map, old_memory)
Â  Â  case .Free_All:
Â  Â  Â  Â  if data.clear_on_free_all {
Â  Â  Â  Â  Â  Â  clear_map(&data.allocation_map)
Â  Â  Â  Â  Â  Â  data.current_memory_allocated = 0
Â  Â  Â  Â  }
Â  Â  case .Resize, .Resize_Non_Zeroed:
Â  Â  Â  Â  if old_memory != nil && old_memory in data.allocation_map {
Â  Â  Â  Â  Â  Â  track_free(data, &data.allocation_map[old_memory])
Â  Â  Â  Â  }
Â  Â  Â  Â  if old_memory != result_ptr {
Â  Â  Â  Â  Â  Â  delete_key(&data.allocation_map, old_memory)
Â  Â  Â  Â  }
Â  Â  Â  Â  data.allocation_map[result_ptr] = Tracking_Allocator_Entry{
Â  Â  Â  Â  Â  Â  memory = result_ptr,
Â  Â  Â  Â  Â  Â  size = size,
Â  Â  Â  Â  Â  Â  mode = mode,
Â  Â  Â  Â  Â  Â  alignment = alignment,
Â  Â  Â  Â  Â  Â  err = err,
Â  Â  Â  Â  Â  Â  location = loc,
Â  Â  Â  Â  }
Â  Â  Â  Â  track_alloc(data, &data.allocation_map[result_ptr])
Â  Â  case .Query_Features:
Â  Â  Â  Â  set := (^Allocator_Mode_Set)(old_memory)
Â  Â  Â  Â  if set != nil {
Â  Â  Â  Â  Â  Â  set^ = {.Alloc, .Alloc_Non_Zeroed, .Free, .Free_All, .Resize, .Query_Features, .Query_Info}
Â  Â  Â  Â  }
Â  Â  Â  Â  return nil, nil
Â  Â  case .Query_Info:
Â  Â  Â  Â  unreachable()
Â  Â  }
Â  Â  return
}
</code></pre>
<h2
	id="memory-operations" >
    Memory: Operations
</h2>
<h3
	id="mem-alloc" >
    Mem Alloc
</h3>
<ul>
	<li>
		<p>
            This function allocates 
            <code>size</code>
            &nbsp;bytes of memory, aligned to a boundary specified by 
            <code>alignment</code>
            &nbsp;using the allocator specified by 
            <code>allocator</code>
            .
		</p>
	</li>
	<li>
		<p>
            If the 
            <code>size</code>
            &nbsp;parameter is 
            <code>0</code>
            , the operation is a no-op.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Inputs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>size</code>
                    : The desired size of the allocated memory region.
				</p>
			</li>
			<li>
				<p>
                    <code>alignment</code>
                    : The desired alignment of the allocated memory region.
				</p>
			</li>
			<li>
				<p>
                    <code>allocator</code>
                    : The allocator to allocate from.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>core:mem</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
alloc :: proc(
Â  Â  size: int,
Â  Â  alignment: int = DEFAULT_ALIGNMENT,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; (rawptr, Allocator_Error) {
Â  Â  data, err := runtime.mem_alloc(size, alignment, allocator, loc)
Â  Â  return raw_data(data), err
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">@(require_results)
alloc_bytes :: proc(
Â  Â  size: int,
Â  Â  alignment: int = DEFAULT_ALIGNMENT,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) {
Â  Â  return runtime.mem_alloc(size, alignment, allocator, loc)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">@(require_results)
alloc_bytes_non_zeroed :: proc(
Â  Â  size: int,
Â  Â  alignment: int = DEFAULT_ALIGNMENT,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) {
Â  Â  return runtime.mem_alloc_non_zeroed(size, alignment, allocator, loc)
}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_alloc :: #force_no_inline proc(size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; ([]byte, Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if size == 0 || allocator.procedure == nil {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  return allocator.procedure(allocator.data, .Alloc, size, alignment, nil, 0, loc)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">mem_alloc_bytes :: #force_no_inline proc(size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; ([]byte, Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if size == 0 || allocator.procedure == nil{
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  return allocator.procedure(allocator.data, .Alloc, size, alignment, nil, 0, loc)
}
</code></pre>
<h3
	id="new" >
    New
</h3>
<ul>
	<li>
		<p>
            Allocates a single object.
		</p>
	</li>
	<li>
		<p>
            Returns a pointer to a newly allocated value of that type using the specified allocator.
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<h5
	id="new" >
    new
</h5>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
new :: proc($T: typeid, allocator := context.allocator, loc := #caller_location) -&gt; (t: ^T, err: Allocator_Error) #optional_allocator_error {
Â  Â  t = (^T)(raw_data(mem_alloc_bytes(size_of(T), align_of(T), allocator, loc) or_return))
Â  Â  return
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> ptr := new(int)
 ptr^ = 123
 x: int = ptr^
</code></pre>
	</li>
</ul>
<h5
	id="new_aligned" >
    new_aligned
</h5>
<pre><code class="language-odin" data-lang="odin">@(require_results)
new_aligned :: proc($T: typeid, alignment: int, allocator := context.allocator, loc := #caller_location) -&gt; (t: ^T, err: Allocator_Error) {
Â  Â  t = (^T)(raw_data(mem_alloc_bytes(size_of(T), alignment, allocator, loc) or_return))
Â  Â  return
}
</code></pre>
<h5
	id="new_clone" >
    new_clone
</h5>
<ul>
	<li>
		<p>
            Allocates a clone of the 
			<em>
                value
			</em>
            &nbsp;passed to it.
		</p>
	</li>
	<li>
		<p>
            The resulting value of the type will be a 
			<em>
                pointer
			</em>
            &nbsp;to the type of the value passed.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
new_clone :: proc(data: $T, allocator := context.allocator, loc := #caller_location) -&gt; (t: ^T, err: Allocator_Error) #optional_allocator_error {
Â  Â  t = (^T)(raw_data(mem_alloc_bytes(size_of(T), align_of(T), allocator, loc) or_return))
Â  Â  if t != nil {
Â  Â  Â  Â  t^ = data
Â  Â  }
Â  Â  return
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> ptr: ^int = new_clone(123)
 assert(ptr^ == 123)
</code></pre>
	</li>
</ul>
<h3
	id="mem-free" >
    Mem Free
</h3>
<ul>
	<li>
		<p>
            Free a single object (opposite of 
            <code>new</code>
            )
		</p>
	</li>
	<li>
		<p>
            Will try to free the passed pointer, with the given 
            <code>allocator</code>
            &nbsp;if the allocator supports this operation.
		</p>
	</li>
	<li>
		<p>
            Only free memory with the allocator it was allocated with.
		</p>
	</li>
</ul>
<h5
	id="cautions" >
    Cautions
</h5>
<ul>
	<li>
		<p>
            Trying to free an object that is &quot;zero-initialized&quot; will not cause a &quot;bad-free&quot;.
		</p>
	</li>
	<li>
		<p>
            <code>free(&...)</code>
            &nbsp;will almost always be wrong, or at best unnecessary.
		</p>
		<ul>
			<li>
				<p>
                    If you need to use 
                    <code>&</code>
                    &nbsp;to get a pointer to something, then that something probably isn't allocated at all.
				</p>
			</li>
			<li>
				<p>
                    If it were allocated, you'd already have a pointer. e.g., in that example, 
                    <code>free(&d)</code>
                    &nbsp;would be trying to free a pointer to the stack--that'll never end well.
				</p>
			</li>
			<li>
				<p>
                    For built-in types like slices, dynamic arrays, maps, and strings, use 
                    <code>delete</code>
                    &nbsp;for those instead. They're not pointers themselves, but they have a pointer internally.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="procs" >
    Procs
</h5>
<ul>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@builtin
free :: proc{mem_free}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_free :: #force_no_inline proc(ptr: rawptr, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  if ptr == nil || allocator.procedure == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  _, err := allocator.procedure(allocator.data, .Free, 0, 0, ptr, 0, loc)
Â  Â  return err
}

mem_free_with_size :: #force_no_inline proc(ptr: rawptr, byte_count: int, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  if ptr == nil || allocator.procedure == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  _, err := allocator.procedure(allocator.data, .Free, 0, 0, ptr, byte_count, loc)
Â  Â  return err
}

mem_free_bytes :: #force_no_inline proc(bytes: []byte, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  if bytes == nil || allocator.procedure == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  _, err := allocator.procedure(allocator.data, .Free, 0, 0, raw_data(bytes), len(bytes), loc)
Â  Â  return err
}
</code></pre>
<ul>
	<li>
		<p>
            <code>core:mem</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">free :: proc(
Â  Â  ptr: rawptr,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; Allocator_Error {
Â  Â  return runtime.mem_free(ptr, allocator, loc)
}
</code></pre>
<h3
	id="mem-free-all" >
    Mem Free All
</h3>
<ul>
	<li>
		<p>
            Will try to free/reset all of the memory of the given 
            <code>allocator</code>
            &nbsp;if the allocator supports this operation.
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// `free_all` will try to free/reset all of the memory of the given `allocator` if the allocator supports this operation.
@builtin
free_all :: proc{mem_free_all}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_free_all :: #force_no_inline proc(allocator := context.allocator, loc := #caller_location) -&gt; (err: Allocator_Error) {
Â  Â  if allocator.procedure != nil {
Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free_All, 0, 0, nil, 0, loc)
Â  Â  }
Â  Â  return
}
</code></pre>
<h3
	id="make" >
    Make
</h3>
<ul>
	<li>
		<p>
            Allocates and initializes a value of type slice, dynamic array, map, or multi-pointer (only).
		</p>
	</li>
	<li>
		<p>
            Unlike 
            <code>new</code>
            , 
            <code>make</code>
            's return value is the same as the type of its argument, not a pointer to it.
		</p>
	</li>
	<li>
		<p>
            Like 
            <code>new</code>
            , the first argument is a type, not a value.
		</p>
	</li>
	<li>
		<p>
            Uses the specified allocator; the default is 
            <code>context.allocator</code>
            .
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@builtin
make :: proc{
Â  Â  make_slice,
Â  Â  make_dynamic_array,
Â  Â  make_dynamic_array_len,
Â  Â  make_dynamic_array_len_cap,
Â  Â  make_map,
Â  Â  make_map_cap,
Â  Â  make_multi_pointer,
Â  Â  make_soa_slice,
Â  Â  make_soa_dynamic_array,
Â  Â  make_soa_dynamic_array_len,
Â  Â  make_soa_dynamic_array_len_cap,
}
</code></pre>
<ul>
	<li>
		<p>
            <code>make_aligned</code>
		</p>
		<ul>
			<li>
				<p>
                    Not included in 
                    <code>make</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>make_soa_aligned</code>
		</p>
		<ul>
			<li>
				<p>
                    Not included in 
                    <code>make</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<pre><code class="language-odin" data-lang="odin">slice := make([]int, 65)

dynamic_array_zero_length := make([dynamic]int)
dynamic_array_with_length := make([dynamic]int, 32)
dynamic_array_with_length_and_capacity := make([dynamic]int, 16, 64)

made_map := make(map[string]int)
made_map_with_reservation := make(map[string]int, 64)
</code></pre>
<h5
	id="allocation-in-structs" >
    Allocation in structs
</h5>
<ul>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    How can I ensure that the 
                    <code>[dynamic]</code>
                    &nbsp;arrays in the struct 
                    <code>physics_packet</code>
                    &nbsp;below use a custom allocator?
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> Physics_Packet :: struct {
 Â  Â  tick_number: u64,
 Â  Â  data: Physics_Data,
 }
 
 Physics_Data :: struct {
 Â  Â  characters: [dynamic]Character_Data,
 Â  Â  creatures: [dynamic]Creature_Data,
 }
 
 physics_packet: Physics_Packet
</code></pre>
		<ul>
			<li>
				<p>
                    When doing something like
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> append(&physics_packet.data.characters, {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; id = personagem.socket,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; pos = personagem.pos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 })
 
</code></pre>
		<ul>
			<li>
				<p>
                    How do I not use the 
                    <code>context.allocator</code>
                    &nbsp;but a custom allocator? I created the struct just by doing 
                    <code>physics_packet: Physics_Packet</code>
                    , so which allocator is used to define the arrays 
                    <code>characters</code>
                    &nbsp;and 
                    <code>creatures</code>
                    ?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    Use 
                    <code>physics_packet.data.characters = make([dynamic]Character_Data, allocator=custom_alloc)</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Chamberlain:
		</p>
		<ul>
			<li>
				<p>
                    The first append actually does the allocation unless you do it explicitly with make.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    What about ZII? Shouldn't I delete the &quot;previous array&quot; before assigning it with a 
                    <code>make</code>
                    ? Or even, is there a way that I define the whole struct using a custom allocator, without having to redefine the arrays, just to use a different allocator? There's also the question of which allocator is used when creating the struct.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Chamberlain:
		</p>
		<ul>
			<li>
				<p>
                    No allocator is used when creating the struct.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    If you declared 
                    <code>physics_packet</code>
                    &nbsp;as a local variable, then it'll be zero-initialized on the stack. No allocation will happen (depending on how technical you are about &quot;allocation&quot;; technically it was allocated on the stack--but that's completely unrelated to 
                    <code>Allocator</code>
                    s). That includes the dynamic arrays in it, where &quot;zero&quot; means &quot;no pointer, 0 length, no allocator&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="slice" >
    slice
</h5>
<ul>
	<li>
		<p>
            Allocates and initializes a slice
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
make_aligned :: proc($T: typeid/[]$E, #any_int len: int, alignment: int, allocator := context.allocator, loc := #caller_location) -&gt; (res: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_aligned_type_erased(&res, size_of(E), len, alignment, allocator, loc)
Â  Â  return
}

@(require_results)
_make_aligned_type_erased :: proc(slice: rawptr, elem_size: int, len: int, alignment: int, allocator: Allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  make_slice_error_loc(loc, len)
Â  Â  data, err := mem_alloc_bytes(elem_size*len, alignment, allocator, loc)
Â  Â  if data == nil && elem_size != 0 {
Â  Â  Â  Â  return err
Â  Â  }
Â  Â  (^Raw_Slice)(slice).data = raw_data(data)
Â  Â  (^Raw_Slice)(slice).len Â = len
Â  Â  return err
}

@(builtin, require_results)
make_slice :: proc($T: typeid/[]$E, #any_int len: int, allocator := context.allocator, loc := #caller_location) -&gt; (res: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_aligned_type_erased(&res, size_of(E), len, align_of(E), allocator, loc)
Â  Â  return
}
</code></pre>
<h5
	id="dynamic-array" >
    dynamic array
</h5>
<ul>
	<li>
		<p>
            Allocates and initializes a dynamic array.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
make_dynamic_array :: proc($T: typeid/[dynamic]$E, allocator := context.allocator, loc := #caller_location) -&gt; (array: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_dynamic_array_len_cap((^Raw_Dynamic_Array)(&array), size_of(E), align_of(E), 0, 0, allocator, loc)
Â  Â  return
}

@(builtin, require_results)
make_dynamic_array_len :: proc($T: typeid/[dynamic]$E, #any_int len: int, allocator := context.allocator, loc := #caller_location) -&gt; (array: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_dynamic_array_len_cap((^Raw_Dynamic_Array)(&array), size_of(E), align_of(E), len, len, allocator, loc)
Â  Â  return
}

@(builtin, require_results)
make_dynamic_array_len_cap :: proc($T: typeid/[dynamic]$E, #any_int len: int, #any_int cap: int, allocator := context.allocator, loc := #caller_location) -&gt; (array: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_dynamic_array_len_cap((^Raw_Dynamic_Array)(&array), size_of(E), align_of(E), len, cap, allocator, loc)
Â  Â  return
}

@(require_results)
_make_dynamic_array_len_cap :: proc(array: ^Raw_Dynamic_Array, size_of_elem, align_of_elem: int, #any_int len: int, #any_int cap: int, allocator := context.allocator, loc := #caller_location) -&gt; (err: Allocator_Error) {
Â  Â  make_dynamic_array_error_loc(loc, len, cap)
Â  Â  array.allocator = allocator // initialize allocator before just in case it fails to allocate any memory
Â  Â  data := mem_alloc_bytes(size_of_elem*cap, align_of_elem, allocator, loc) or_return
Â  Â  use_zero := data == nil && size_of_elem != 0
Â  Â  array.data = raw_data(data)
Â  Â  array.len = 0 if use_zero else len
Â  Â  array.cap = 0 if use_zero else cap
Â  Â  array.allocator = allocator
Â  Â  return
}
</code></pre>
<h5
	id="map" >
    map
</h5>
<ul>
	<li>
		<p>
            Initializes a map with an allocator.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
make_map :: proc($T: typeid/map[$K]$E, allocator := context.allocator, loc := #caller_location) -&gt; (m: T) {
Â  Â  m.allocator = allocator
Â  Â  return m
}

@(builtin, require_results)
make_map_cap :: proc($T: typeid/map[$K]$E, #any_int capacity: int, allocator := context.allocator, loc := #caller_location) -&gt; (m: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  make_map_expr_error_loc(loc, capacity)
Â  Â  context.allocator = allocator
Â  Â  err = reserve_map(&m, capacity, loc)
Â  Â  return
}
</code></pre>
<h5
	id="multi-pointer" >
    Multi-pointer
</h5>
<ul>
	<li>
		<p>
            Allocates and initializes a multi-pointer.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
make_multi_pointer :: proc($T: typeid/[^]$E, #any_int len: int, allocator := context.allocator, loc := #caller_location) -&gt; (mp: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  make_slice_error_loc(loc, len)
Â  Â  data := mem_alloc_bytes(size_of(E)*len, align_of(E), allocator, loc) or_return
Â  Â  if data == nil && size_of(E) != 0 {
Â  Â  Â  Â  return
Â  Â  }
Â  Â  mp = cast(T)raw_data(data)
Â  Â  return
}
</code></pre>
<h3
	id="deletes" >
    Deletes
</h3>
<ul>
	<li>
		<p>
            Free a group of objects (opposite of 
            <code>make</code>
            )
		</p>
	</li>
	<li>
		<p>
            Deletes the backing memory of a value allocated with make or a string that was allocated through an allocator.
		</p>
	</li>
	<li>
		<p>
            Will try to free the underlying data of the passed built-in data structure (string, cstring, dynamic array, slice, or map), with the given 
            <code>allocator</code>
            &nbsp;if the allocator supports this operation.
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@builtin
delete :: proc{
Â  Â  delete_string,
Â  Â  delete_cstring,
Â  Â  delete_dynamic_array,
Â  Â  delete_slice,
Â  Â  delete_map,
Â  Â  delete_soa_slice,
Â  Â  delete_soa_dynamic_array,
Â  Â  delete_string16,
Â  Â  delete_cstring16,
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Recursiveness
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>delete</code>
                    &nbsp;isn't recursive. It has no way of knowing whether you actually 
					<em>
                        want
					</em>
                    &nbsp;to delete the contents or not--you may not always.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> Â  Â  array_args_as_bytes: [dynamic][]u8
 
&nbsp;&nbsp;&nbsp;&nbsp; // Option 1: Don't delete everything.
&nbsp;&nbsp;&nbsp;&nbsp; defer delete(array_args_as_bytes)
 
 Â  Â  // Option 2: Delete everything.
 Â  Â  defer {
 Â  Â  Â  Â  for arg in array_args_as_bytes {
 Â  Â  Â  Â  Â  Â  delete(arg)
 Â  Â  Â  Â  }
 Â  Â  Â  Â  delete(array_args_as_bytes)
 Â  Â  }
</code></pre>
		<ul>
			<li>
				<p>
                    If it's a struct, it's not uncommon to make a 
                    <code>destroy_struct</code>
                    &nbsp;proc that does this for you.
				</p>
				<ul>
					<li>
						<p>
                            Example: 
							<a
								href="https://github.com/odin-lang/Odin/blob/master/core/encoding/json/types.odin#L92" 
								class="external-link" 
								target="_blank" >
                                <code>json.destroy_value</code>
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The way I understand it is that the 
                    <code>data</code>
                    &nbsp;of the object is deleted. The 
                    <code>data</code>
                    &nbsp;itself is a pointer to where the data is stored, so deleting the 
                    <code>data</code>
                    &nbsp;is deleting the pointer.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="string" >
    string
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_string :: proc(str: string, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(str), len(str), allocator, loc)
}
</code></pre>
<h5
	id="cstring" >
    cstring
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_cstring :: proc(str: cstring, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free((^byte)(str), allocator, loc)
}
</code></pre>
<h5
	id="string16" >
    string16
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_string16 :: proc(str: string16, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(str), len(str)*size_of(u16), allocator, loc)
}
</code></pre>
<h5
	id="cstring16" >
    cstring16
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_cstring16 :: proc(str: cstring16, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free((^u16)(str), allocator, loc)
}
</code></pre>
<h5
	id="dynamic-array" >
    dynamic array
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_dynamic_array :: proc(array: $T/[dynamic]$E, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(array), cap(array)*size_of(E), array.allocator, loc)
}
</code></pre>
<h5
	id="slice" >
    slice
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_slice :: proc(array: $T/[]$E, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(array), len(array)*size_of(E), allocator, loc)
}
</code></pre>
<h5
	id="map" >
    Map
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_map :: proc(m: $T/map[$K]$V, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return map_free_dynamic(transmute(Raw_Map)m, map_info(T), loc)
}
</code></pre>
<h3
	id="mem-resize" >
    Mem Resize
</h3>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">_mem_resize :: #force_no_inline proc(
&nbsp;&nbsp;&nbsp;&nbsp;ptr: rawptr, 
&nbsp;&nbsp;&nbsp;&nbsp;old_size, 
&nbsp;&nbsp;&nbsp;&nbsp;new_size: int, 
&nbsp;&nbsp;&nbsp;&nbsp;alignment: int = DEFAULT_ALIGNMENT, 
&nbsp;&nbsp;&nbsp;&nbsp;allocator := context.allocator, 
&nbsp;&nbsp;&nbsp;&nbsp;should_zero: bool, 
&nbsp;&nbsp;&nbsp;&nbsp;loc := #caller_location
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (data: []byte, err: Allocator_Error) {
&nbsp;&nbsp;&nbsp;&nbsp;
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if allocator.procedure == nil {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  if new_size == 0 {
Â  Â  Â  Â  if ptr != nil {
Â  Â  Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  } else if ptr == nil {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  } else if old_size == new_size && uintptr(ptr) % uintptr(alignment) == 0 {
Â  Â  Â  Â  data = ([^]byte)(ptr)[:old_size]
Â  Â  Â  Â  return
Â  Â  }
Â  Â  if should_zero {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize, new_size, alignment, ptr, old_size, loc)
Â  Â  } else {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize_Non_Zeroed, new_size, alignment, ptr, old_size, loc)
Â  Â  }
Â  Â  if err == .Mode_Not_Implemented {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  Â  Â  if err != nil {
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  copy(data, ([^]byte)(ptr)[:old_size])
Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  }
Â  Â  return
}

mem_resize :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;ptr: rawptr, 
&nbsp;&nbsp;&nbsp;&nbsp;old_size, 
&nbsp;&nbsp;&nbsp;&nbsp;new_size: int, 
&nbsp;&nbsp;&nbsp;&nbsp;alignment: int = DEFAULT_ALIGNMENT, 
&nbsp;&nbsp;&nbsp;&nbsp;allocator := context.allocator, 
&nbsp;&nbsp;&nbsp;&nbsp;loc := #caller_location
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, true, loc)
}

non_zero_mem_resize :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;ptr: rawptr, 
&nbsp;&nbsp;&nbsp;&nbsp;old_size, 
&nbsp;&nbsp;&nbsp;&nbsp;new_size: int, 
&nbsp;&nbsp;&nbsp;&nbsp;alignment: int = DEFAULT_ALIGNMENT, 
&nbsp;&nbsp;&nbsp;&nbsp;allocator := context.allocator, 
&nbsp;&nbsp;&nbsp;&nbsp;loc := #caller_location
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, false, loc)
}
</code></pre>
<h3
	id="mem-set" >
    Mem Set
</h3>
<ul>
	<li>
		<p>
            Set a number of bytes (
            <code>len</code>
            ) to a value (
            <code>val</code>
            ), from the address specified (
            <code>ptr</code>
            ).
		</p>
	</li>
</ul>
<h5
	id="using-the-c-runtime-library-crt" >
    Using the 'C Runtime Library' (CRT)
</h5>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">when ODIN_NO_CRT == true && ODIN_OS == .Windows {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memset", linkage="strong", require)
Â  Â  memset :: proc "c" (ptr: rawptr, val: i32, len: int) -&gt; rawptr {
Â  Â  Â  Â  RtlFillMemory(ptr, len, val)
Â  Â  Â  Â  return ptr
Â  Â  }
} else when ODIN_NO_CRT || (ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32)) {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memset", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memset :: proc "c" (ptr: rawptr, val: i32, #any_int len: int_t) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ptr != nil && len != 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b := byte(val)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p := ([^]byte)(ptr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := int_t(0); i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[i] = b
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr
&nbsp;&nbsp;&nbsp;&nbsp;}
} else {
&nbsp;&nbsp;&nbsp;&nbsp;memset :: proc "c" (ptr: rawptr, val: i32, len: int) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ptr != nil && len != 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b := byte(val)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p := ([^]byte)(ptr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[i] = b
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h5
	id="in-c" >
    In C
</h5>
<ul>
	<li>
		<p>
			<a
				href="C.html#Mem%20Set" 
				class="internal-link" 
				target="_self" >
                C#Mem Set
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="mem-copy" >
    Mem Copy
</h3>
<h5
	id="which-one-to-use" >
    Which one to use
</h5>
<ul>
	<li>
		<p>
			<strong>
                TLDR
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Barinzaya / Tetralux / Yawning:
				</p>
				<ul>
					<li>
						<p>
                            Use 
                            <code>copy</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The difference in performance is going to be pretty small between any of them. Anything 
                            <code>non_overlapping</code>
                            &nbsp;is a slight optimization at most if you know 
							<strong>
                                for sure
							</strong>
                            &nbsp;it won't overlap. If it does, it may completely wreck your data.
						</p>
					</li>
					<li>
						<p>
                            Use 
                            <code>intrinsics.mem_copy_non_overlapping</code>
                            &nbsp;or other option if you profile and see 
                            <code>copy</code>
                            &nbsp;to be an issue.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>copy</code>
		</p>
		<ul>
			<li>
				<p>
                    For convenience and safety, but slower.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>intrinsics.mem_copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    For speed and no safety.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>runtime.copy</code>
            &nbsp;/ 
            <code>runtime.copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    A middle ground between the two above, I guess,
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>mem.copy</code>
            &nbsp;/ 
            <code>mem.copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    Just a indirection from 
                    <code>intrinsics.mem_copy</code>
                    &nbsp;/ 
                    <code>intrinsics.mem_copy_non_overlapping</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>mem.copy</code>
                    &nbsp;is a tiny wrapper that will almost certainly end up inlined with any optimization on.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>core:c/libc</code>
		</p>
		<ul>
			<li>
				<p>
                    Ignore this one, is just there for completeness.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="equivalence-to-cs" >
    Equivalence to C's
</h5>
<ul>
	<li>
		<p>
            <code>mem_copy</code>
		</p>
		<ul>
			<li>
				<p>
                    Similar to C's 
                    <code>memmove</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Requires a little bit of additional logic to correctly handle the ranges overlapping.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>mem_copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    Similar to C's 
                    <code>memcopy</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="using-codeintrinsics-code" >
    Using 
    <code>intrinsics</code>
</h5>
<ul>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>intrinsic</code>
                    &nbsp;is handled by the compiler. It does a bit of additional &quot;smart&quot; stuff--if the length is constant, it emits the instructions to do the copy inline (without a call), and it just tells LLVM to do the 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    . LLVM may in fact just call the 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    &nbsp;proc (provided by the CRT or 
                    <code>procs.odin</code>
                    ), if it sees fit.
				</p>
			</li>
			<li>
				<p>
                    But it still allows LLVM to be a little &quot;smarter&quot; about it, AFAIK. Since it 
					<em>
                        knows
					</em>
                    &nbsp;what the proc does, it can potentially elide the copy (though probably less so in the case where the length is variable).
				</p>
			</li>
			<li>
				<p>
                    Every available copy procedure uses 
                    <code>intrinsics.mem_copy</code>
                    &nbsp;or 
                    <code>intrinsics.mem_copy_non_overlapping</code>
                    &nbsp;under the hood, so therefore, all those implementations benefit from possible compiler optimizations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
		<ul>
			<li>
				<p>
                    Builtin.
				</p>
			</li>
			<li>
				<p>
                    Slice / Strings.
				</p>
			</li>
			<li>
				<p>
                    Copies elements from a source slice/string 
                    <code>src</code>
                    &nbsp;to a destination slice 
                    <code>dst</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of 
                    <code>len(src)</code>
                    &nbsp;and 
                    <code>len(dst)</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> @(require_results)
 copy_slice_raw :: proc "contextless" (dst, src: rawptr, dst_len, src_len, elem_size: int) -&gt; int {
 Â  Â  n := min(dst_len, src_len)
 Â  Â  if n &gt; 0 {
 Â  Â  Â  Â  intrinsics.mem_copy(dst, src, n*elem_size)
 Â  Â  }
 Â  Â  return n
 }
 
 @builtin
 copy_slice :: #force_inline proc "contextless" (dst, src: $T/[]$E) -&gt; int {
 Â  Â  return copy_slice_raw(raw_data(dst), raw_data(src), len(dst), len(src), size_of(E))
 }
 
 @builtin
 copy_from_string :: #force_inline proc "contextless" (dst: $T/[]$E/u8, src: $S/string) -&gt; int {
 Â  Â  return copy_slice_raw(raw_data(dst), raw_data(src), len(dst), len(src), 1)
 }
 
 @builtin
 copy :: proc{copy_slice, copy_from_string, copy_from_string16}
</code></pre>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
		<ul>
			<li>
				<p>
                    General.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> mem_copy :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
 Â  Â  if src != nil && dst != src && len &gt; 0 {
 Â  Â  Â  Â  // NOTE(bill): This _must_ be implemented like C's memmove
 Â  Â  Â  Â  intrinsics.mem_copy(dst, src, len)
 Â  Â  }
 Â  Â  return dst
 }
 
 mem_copy_non_overlapping :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
 Â  Â  if src != nil && dst != src && len &gt; 0 {
 Â  Â  Â  Â  // NOTE(bill): This _must_ be implemented like C's memcpy
 Â  Â  Â  Â  intrinsics.mem_copy_non_overlapping(dst, src, len)
 Â  Â  }
 Â  Â  return dst
 }
</code></pre>
	</li>
	<li>
		<p>
            <code>core:mem</code>
		</p>
<pre><code class="language-odin" data-lang="odin"> copy :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp; intrinsics.mem_copy(dst, src, len)
&nbsp;&nbsp;&nbsp;&nbsp; return dst
 }
 
 copy_non_overlapping :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
 Â  Â  intrinsics.mem_copy_non_overlapping(dst, src, len)
 Â  Â  return dst
 }
</code></pre>
	</li>
	<li>
		<p>
            <code>base:intrinsics</code>
		</p>
<pre><code class="language-odin" data-lang="odin"> mem_copy Â  Â  Â  Â  Â  Â  Â  Â  :: proc(dst, src: rawptr, len: int) ---
 mem_copy_non_overlapping :: proc(dst, src: rawptr, len: int) ---
</code></pre>
	</li>
</ul>
<h5
	id="using-codecorec-libc-code" >
    Using 
    <code>core:c/libc</code>
</h5>
<ul>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    It's just procs from libc--part of which is the CRT. So the 
                    <code>libc</code>
                    &nbsp;one is explicitly the CRT implementation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>core:c/libc</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">memcpy Â  :: proc(s1, s2: rawptr, n: size_t) -&gt; rawptr ---

memmove Â :: proc(s1, s2: rawptr, n: size_t) -&gt; rawptr ---

strcpy Â  :: proc(s1: [^]char, s2: cstring) -&gt; [^]char ---
strncpy Â :: proc(s1: [^]char, s2: cstring, n: size_t) -&gt; [^]char ---
</code></pre>
<h5
	id="implementation-from-c-runtime-library-crt" >
    Implementation from 'C Runtime Library' (CRT)
</h5>
<ul>
	<li>
		<p>
            <code>ODIN_NO_CRT</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>true</code>
                    &nbsp;if the 
                    <code>-no-crt</code>
                    &nbsp;command line switch is passed, which inhibits linking with the C Runtime Library, a.k.a. LibC.
				</p>
			</li>
			<li>
				<p>
                    The default is 
                    <code>false</code>
                    , so CRT 
					<strong>
                        is
					</strong>
                    &nbsp;used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
			<input
				type="checkbox" 
				disabled=""
>
            Should I enabled CRT or not? I forgot to ask that, oops
		</p>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    <code>memcpy</code>
                    &nbsp;and 
                    <code>memmove</code>
                    &nbsp;are part of the C run-time, and LLVM 
					<em>
                        needs to have them
					</em>
                    . If you disable the CRT, then they need to be provided--hence, why they're in 
                    <code>procs.odin</code>
                    . Note that they're in 
                    <code>when ODIN_NO_CRT</code>
                    &nbsp;blocks (plus other conditions). So the 
                    <code>procs.odin</code>
                    &nbsp;implementation is used when the CRT isn't linked, because they need to exist
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    Can I say that 
                    <code>procs.odin</code>
                    &nbsp;provides an implementation 
					<strong>
                        for
					</strong>
                    &nbsp;
                    <code>intrinsics</code>
                    &nbsp;copy procedures, considering the conditions defined in the 
                    <code>procs.odin</code>
                    ? As a fallback I mean, I assume 
                    <code>intrinsics</code>
                    &nbsp;already have an implementation somewhere.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    Not entirely, 
                    <code>procs.odin</code>
                    &nbsp;is more &quot;stuff needed for LLVM to work at all when the CRT isn't included&quot;
				</p>
			</li>
			<li>
				<p>
                    <code>intrinsics</code>
                    &nbsp;are all implemented in the compiler itself. In the case of the 
                    <code>copy</code>
                    s, they defer to LLVM intrinsics, which 
					<em>
                        may
					</em>
                    &nbsp;call 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    &nbsp;from the CRT or 
                    <code>procs.odin</code>
                    --but they also may not
				</p>
			</li>
			<li>
				<p>
                    Also, LLVM can call 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    &nbsp;
					<em>
                        without
					</em>
                    &nbsp;those intrinsics too, for sufficiently large copies.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tetralux:
		</p>
		<ul>
			<li>
				<p>
                    Intrinsics are more &quot;compiler hooks&quot; for &quot;I want to do this thing please&quot;
				</p>
			</li>
			<li>
				<p>
                    They are somewhat opaque things if you see what I mean
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">when ODIN_NO_CRT == true && ODIN_OS == .Windows {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memcpy", linkage="strong", require)
Â  Â  memcpy :: proc "c" (dst, src: rawptr, len: int) -&gt; rawptr {
Â  Â  Â  Â  RtlMoveMemory(dst, src, len)
Â  Â  Â  Â  return dst
Â  Â  }
Â  Â  
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memmove", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memmove :: proc "c" (dst, src: rawptr, len: int) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RtlMoveMemory(dst, src, len)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;}
} else when ODIN_NO_CRT || (ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32)) {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memcpy", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memcpy :: proc "c" (dst, src: rawptr, #any_int len: int_t) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d, s := ([^]byte)(dst), ([^]byte)(src)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d != s {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := int_t(0); i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i] = s[i]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return d
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memmove", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memmove :: proc "c" (dst, src: rawptr, #any_int len: int_t) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d, s := ([^]byte)(dst), ([^]byte)(src)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d == s || len == 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d &gt; s && uintptr(d)-uintptr(s) &lt; uintptr(len) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := len-1; i &gt;= 0; i -= 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i] = s[i]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if s &gt; d && uintptr(s)-uintptr(d) &lt; uintptr(len) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := int_t(0); i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i] = s[i]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return memcpy(dst, src, len)
&nbsp;&nbsp;&nbsp;&nbsp;}
} else {
&nbsp;&nbsp;&nbsp;&nbsp;// None.
}
</code></pre>
<h5
	id="in-c" >
    In C
</h5>
<ul>
	<li>
		<p>
			<a
				href="C.html#Mem%20Copy" 
				class="internal-link" 
				target="_self" >
                C#Mem Copy
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="mem-zero" >
    Mem Zero
</h3>
<h5
	id="using-codeintrinsics-code" >
    Using 
    <code>intrinsics</code>
</h5>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_zero :: proc "contextless" (data: rawptr, len: int) -&gt; rawptr {
Â  Â  if data == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  if len &lt;= 0 {
Â  Â  Â  Â  return data
Â  Â  }
Â  Â  intrinsics.mem_zero(data, len)
Â  Â  return data
}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:intrinsics</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_zero Â  Â  Â  Â  Â  Â  Â  Â  :: proc(ptr: rawptr, len: int) ---
mem_zero_volatile Â  Â  Â  Â :: proc(ptr: rawptr, len: int) ---
</code></pre>
<h5
	id="conditionally-mem-zero" >
    Conditionally Mem Zero
</h5>
<ul>
	<li>
		<p>
            When acquiring memory from the OS for the first time it's likely that the OS already gives the zero page mapped multiple times for the request. The actual allocation does not have physical pages allocated to it until those pages are written to which causes a page-fault. This is often called 
			<strong>
                COW (Copy on Write)
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            You do not want to actually zero out memory in this case because it would cause a bunch of page faults decreasing the speed of allocations and increase the amount of actual resident physical memory used.
		</p>
	</li>
	<li>
		<p>
            Instead a better technique is to check if memory is zerored before zeroing it. This turns out to be an important optimization in practice, saving nearly half (or more) the amount of physical memory used by an application.
		</p>
	</li>
	<li>
		<p>
            This is why every implementation of 
            <code>calloc</code>
            &nbsp;in 
            <code>libc</code>
            &nbsp;does this optimization.
		</p>
	</li>
	<li>
		<p>
            It may seem counter-intuitive but most allocations in an application are wasted and never used. When you consider something like a 
            <code>[dynamic]T</code>
            &nbsp;which always doubles in capacity on resize but you rarely ever actually use the full capacity of a dynamic array it means you have a lot of resident waste if you actually zeroed the remainder of the memory.
		</p>
	</li>
	<li>
		<p>
            Keep in mind the OS is already guaranteed to give you zeroed memory by mapping in this zero page multiple times so in the best case there is no need to actually zero anything. As for testing all this memory for a zero value, it costs nothing because the the same zero page is used for the whole allocation and will exist in L1 cache for the entire zero checking process.
		</p>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">conditional_mem_zero :: proc "contextless" (data: rawptr, n_: int) #no_bounds_check {
Â  Â  if n_ &lt;= 0 {
Â  Â  Â  Â  return
Â  Â  }
Â  Â  n := uint(n_)
Â  Â  n_words := n / size_of(uintptr)
Â  Â  p_words := ([^]uintptr)(data)[:n_words]
Â  Â  p_bytes := ([^]byte)(data)[size_of(uintptr) * n_words:n]
Â  Â  for &p_word in p_words {
Â  Â  Â  Â  if p_word != 0 {
Â  Â  Â  Â  Â  Â  p_word = 0
Â  Â  Â  Â  }
Â  Â  }
Â  Â  for &p_byte in p_bytes {
Â  Â  Â  Â  if p_byte != 0 {
Â  Â  Â  Â  Â  Â  p_byte = 0
Â  Â  Â  Â  }
Â  Â  }
}
</code></pre>
<h5
	id="using-the-c-runtime-library-crt" >
    Using the 'C Runtime Library' (CRT)
</h5>
<pre><code class="language-odin" data-lang="odin">when ODIN_NO_CRT && ODIN_OS == .Windows {
&nbsp;&nbsp;&nbsp;&nbsp;// None
} else when ODIN_NO_CRT || (ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32)) {
Â  Â  @(link_name="bzero", linkage="strong", require)
Â  Â  bzero :: proc "c" (ptr: rawptr, #any_int len: int_t) -&gt; rawptr {
Â  Â  Â  Â  if ptr != nil && len != 0 {
Â  Â  Â  Â  Â  Â  p := ([^]byte)(ptr)
Â  Â  Â  Â  Â  Â  for i := int_t(0); i &lt; len; i += 1 {
Â  Â  Â  Â  Â  Â  Â  Â  p[i] = 0
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return ptr
Â  Â  }
Â } else {
&nbsp;&nbsp;&nbsp;&nbsp;Â // None
Â }
</code></pre>
<h5
	id="in-c" >
    In C
</h5>
<ul>
	<li>
		<p>
			<a
				href="C.html#Mem%20Zero" 
				class="internal-link" 
				target="_self" >
                C#Mem Zero
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="resize" >
    Resize
</h3>
<pre><code class="language-odin" data-lang="odin">_mem_resize :: #force_no_inline proc(ptr: rawptr, old_size, new_size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, should_zero: bool, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if allocator.procedure == nil {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  if new_size == 0 {
Â  Â  Â  Â  if ptr != nil {
Â  Â  Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  } else if ptr == nil {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  } else if old_size == new_size && uintptr(ptr) % uintptr(alignment) == 0 {
Â  Â  Â  Â  data = ([^]byte)(ptr)[:old_size]
Â  Â  Â  Â  return
Â  Â  }
Â  Â  if should_zero {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize, new_size, alignment, ptr, old_size, loc)
Â  Â  } else {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize_Non_Zeroed, new_size, alignment, ptr, old_size, loc)
Â  Â  }
Â  Â  if err == .Mode_Not_Implemented {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  Â  Â  if err != nil {
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  copy(data, ([^]byte)(ptr)[:old_size])
Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  }
Â  Â  return
}

mem_resize :: proc(ptr: rawptr, old_size, new_size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, true, loc)
}

non_zero_mem_resize :: proc(ptr: rawptr, old_size, new_size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, false, loc)
}
</code></pre>
<h5
	id="default-resize-procedure" >
    Default resize procedure
</h5>
<ul>
	<li>
		<p>
            When allocator does not support resize operation, but supports 
            <code>.Alloc</code>
            &nbsp;/ 
            <code>.Alloc_Non_Zeroed</code>
            &nbsp;and 
            <code>.Free</code>
            , this procedure is used to implement allocator's default behavior on resize.
		</p>
	</li>
	<li>
		<p>
            The behavior of the function is as follows:
		</p>
		<ul>
			<li>
				<p>
                    If 
                    <code>new_size</code>
                    &nbsp;is 
                    <code>0</code>
                    , the function acts like 
                    <code>free()</code>
                    , freeing the memory region specified by 
                    <code>old_data</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>old_data</code>
                    &nbsp;is 
                    <code>nil</code>
                    , the function acts like 
                    <code>alloc()</code>
                    , allocating 
                    <code>new_size</code>
                    &nbsp;bytes of memory aligned on a boundary specified by 
                    <code>alignment</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Otherwise, a new memory region of size 
                    <code>new_size</code>
                    &nbsp;is allocated, then the data from the old memory region is copied and the old memory region is freed.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
_default_resize_bytes_align :: #force_inline proc(
Â  Â  old_data: []byte,
Â  Â  new_size: int,
Â  Â  alignment: int,
Â  Â  should_zero: bool,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) {
Â  Â  old_memory := raw_data(old_data)
Â  Â  old_size := len(old_data)
Â  Â  if old_memory == nil {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  return alloc_bytes(new_size, alignment, allocator, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  return alloc_bytes_non_zeroed(new_size, alignment, allocator, loc)
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if new_size == 0 {
Â  Â  Â  Â  err := free_bytes(old_data, allocator, loc)
Â  Â  Â  Â  return nil, err
Â  Â  }
Â  Â  if new_size == old_size && is_aligned(old_memory, alignment) {
Â  Â  Â  Â  return old_data, .None
Â  Â  }
Â  Â  new_memory : []byte
Â  Â  err : Allocator_Error
Â  Â  if should_zero {
Â  Â  Â  Â  new_memory, err = alloc_bytes(new_size, alignment, allocator, loc)
Â  Â  } else {
Â  Â  Â  Â  new_memory, err = alloc_bytes_non_zeroed(new_size, alignment, allocator, loc)
Â  Â  }
Â  Â  if new_memory == nil || err != nil {
Â  Â  Â  Â  return nil, err
Â  Â  }
Â  Â  runtime.copy(new_memory, old_data)
Â  Â  free_bytes(old_data, allocator, loc)
Â  Â  return new_memory, err
}
</code></pre>
<h2
	id="multi-threading" >
    Multi-Threading
</h2>
<ul>
	<li>
		<p>
            Ginger Bill: &quot;Odin does have numerous threading and synchronization primitives in its core library. But it does not have any parallelism/concurrency features built directly into the language itself because all of them require some form of automatic memory management which is a no-go.&quot;
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/jakubtomsu/jobs" 
				class="external-link" 
				target="_blank" >
                odin-jobs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Odin handles threads similarly to how Go handles it.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang" 
				class="external-link" 
				target="_blank" >
                Good tutorial
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="coresync" >
    core:sync
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/" 
				class="external-link" 
				target="_blank" >
                core:sync
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            To limit or control the threads' access to shared memory, typically the following approaches are used:
		</p>
		<ul>
			<li>
				<p>
                    Locks
				</p>
			</li>
			<li>
				<p>
                    Lock-free
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            When using locks, sections of the code that access shared memory are guarded by locks, allowing limited access to threads and blocking the execution of other threads.
		</p>
	</li>
	<li>
		<p>
            In lock-free programming, the data itself is organized such that threads don't intervene much. It can be done via segmenting the data between threads, and/or by using atomic operations.
		</p>
	</li>
</ul>
<h5
	id="sync-wait_group" >
    sync.Wait_Group
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#Wait_Group" 
				class="external-link" 
				target="_blank" >
                <code>Wait_Group</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Keep track of our threads.
		</p>
	</li>
	<li>
		<p>
            Used to check if our thread has completed its work or not
		</p>
	</li>
</ul>
<h5
	id="thread-create" >
    thread.create
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/thread/#create" 
				class="external-link" 
				target="_blank" >
                <code>create</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-creating-threads" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Create a thread in a suspended state with the given priority.
		</p>
	</li>
	<li>
		<p>
            This procedure creates a thread that will be set to run the procedure specified by the 
            <code>procedure</code>
            &nbsp;parameter with a specified priority. The returned thread will be in a suspended state until 
            <code>start()</code>
            &nbsp;procedure is called.
		</p>
	</li>
</ul>
<h5
	id="thread-pool" >
    Thread Pool
</h5>
<ul>
	<li>
		<p>
			<strong>
                Via thread.pool
			</strong>
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/thread/#pool_init" 
						class="external-link" 
						target="_blank" >
                        <code>pool_init</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/thread/#Pool" 
						class="external-link" 
						target="_blank" >
                        <code>Pool</code>
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-creating-a-threadpool-using-threadpool" 
						class="external-link" 
						target="_blank" >
                        Tutorial
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Via dynamic array
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Stores pointer to a thread.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-now-lets-try-creating-many-threads" 
						class="external-link" 
						target="_blank" >
                        Tutorial
					</a>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> arr := []int{1,2,3}
 
 main :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp; threadPool := make([dynamic]^thread.Thread, 0, len(arr))
&nbsp;&nbsp;&nbsp;&nbsp; defer delete(threadPool)
 }
</code></pre>
	</li>
</ul>
<h5
	id="coresync-chan" >
    core:sync/chan
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/chan/" 
				class="external-link" 
				target="_blank" >
                core:sync/chan
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The tutorial is useful.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-communicating-between-threads-using-channels" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            This package provides both high-level and low-level channel types for thread-safe communication.
		</p>
	</li>
	<li>
		<p>
            While channels are essentially thread-safe queues under the hood, their primary purpose is to facilitate safe communication between multiple readers and multiple writers. Although they can be used like queues, channels are designed with synchronization and concurrent messaging patterns in mind.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Provided types
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>Chan</code>
                    &nbsp;a high-level channel.
				</p>
			</li>
			<li>
				<p>
                    <code>Raw_Chan</code>
                    &nbsp;a low-level channel.
				</p>
			</li>
			<li>
				<p>
                    <code>Raw_Queue</code>
                    &nbsp;a low-level non-threadsafe queue implementation used internally.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="conditions" >
    Conditions
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#Cond" 
				class="external-link" 
				target="_blank" >
                Cond
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Uses a mutex.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#Auto_Reset_Event" 
				class="external-link" 
				target="_blank" >
                Auto_Reset_Event
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    No mutex.
				</p>
			</li>
			<li>
				<p>
                    Uses a semaphore.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#Sema" 
				class="external-link" 
				target="_blank" >
                Sema
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Semaphore.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sync/#Atomic_Sema" 
				class="external-link" 
				target="_blank" >
                Atomic_Sema
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="directives" >
    Directives
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#record-memory-layout" 
				class="external-link" 
				target="_blank" >
                Record memory layout
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#control-statements" 
				class="external-link" 
				target="_blank" >
                Control statements
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#expressions" 
				class="external-link" 
				target="_blank" >
                Expressions
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#statements" 
				class="external-link" 
				target="_blank" >
                Statements
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#built-in-procedures-1" 
				class="external-link" 
				target="_blank" >
                Built-in Procedures
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>#by_ptr</code>
		</p>
		<ul>
			<li>
				<p>
                    For 
                    <code>const T *</code>
                    &nbsp;arguments in bindings.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="ffi-foreign-function-interface-bindings" >
    FFI (Foreign Function Interface) / Bindings
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#foreign-system" 
				class="external-link" 
				target="_blank" >
                Foreign System
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#calling-conventions" 
				class="external-link" 
				target="_blank" >
                Calling Conventions
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;
                    <code>proc "c"</code>
                    &nbsp;is 
                    <code>__cdecl</code>
                    &quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;A 
                    <code>proc</code>
                    &nbsp;signature, when used as a type, is already a proc pointer&quot;
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=BgBinHwJwgo" 
						class="external-link" 
						target="_blank" >
                        Explanation
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Helps understand Raylib bindings.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#linking-and-foreign-attributes" 
				class="external-link" 
				target="_blank" >
                Linking and Foreign Attributes
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#cstring-type" 
				class="external-link" 
				target="_blank" >
                <code>cstring</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#multi-pointers" 
				class="external-link" 
				target="_blank" >
                Multi-pointers
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#c_vararg" 
				class="external-link" 
				target="_blank" >
                <code>#c_vararg</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#by_ptr" 
				class="external-link" 
				target="_blank" >
                <code>#by_ptr</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=oNZzosryjV8" 
				class="external-link" 
				target="_blank" >
                Explanation
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="web-build" >
    Web Build
</h2>
<h3
	id="not-wasm" >
    Not-WASM
</h3>
<h5
	id="webui" >
    WebUI
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/webui-dev/odin-webui" 
				class="external-link" 
				target="_blank" >
                odin-webui
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Use any web browser as GUI, with Odin in the backend and modern web technologies in the frontend.&quot;.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://webui.me/" 
						class="external-link" 
						target="_blank" >
                        WebUI
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            WebUI's primary focus is using web browsers as GUI, but starting from v2.5, WebUI can also use WebView if you need to use WebView instead of a web browser.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://webui.me/docs/2.5/#/?id=webui-v25-documentation" 
								class="external-link" 
								target="_blank" >
                                Docs
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    [2025/10/12]
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20251012220535.png" width="691" >
                            .
						</p>
					</li>
					<li>
						<p>
                            This screenshot summarizes everything.
						</p>
						<ul>
							<li>
								<p>
                                    I added the repo as a submodule.
								</p>
							</li>
							<li>
								<p>
                                    Ran the 
                                    <code>setup.ps1</code>
                                    &nbsp;inside the submodule.
								</p>
							</li>
							<li>
								<p>
                                    Created a 
                                    <code>main.odin</code>
                                    &nbsp;file.
								</p>
							</li>
							<li>
								<p>
                                    Pasted the code from the &quot;minimal example&quot;.
								</p>
							</li>
							<li>
								<p>
                                    Ran 
                                    <code>odin run</code>
                                    &nbsp;and this window appeared.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            My impression is that everything is exceptionally opaque. I have no idea what happened. The package is just a binding for the C library. Nothing is native, except for some mini-wrapper for a procedure, for error handling.
						</p>
					</li>
					<li>
						<p>
                            I didn't have a good impression.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="templating" >
    Templating
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/nviam/odin-templateless" 
				class="external-link" 
				target="_blank" >
                odin-templateless
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Extremely simple.
				</p>
			</li>
			<li>
				<p>
                    Implements just a procedure to replace content inside a 
                    <code>{{ }}</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Not a template engine by itself.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://github.com/laytan/temple" 
				class="external-link" 
				target="_blank" >
                temple
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    An experimental in-development templating engine for Odin
				</p>
			</li>
			<li>
				<p>
                    Works via 
                    <code>{{ }}</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Supports Odin expressions, based on the given context/data
				</p>
				<ul>
					<li>
						<p>
                            <code>{{ this.name.? or_else "no name" }}</code>
						</p>
					</li>
					<li>
						<p>
                            <code>{{ this.welcome if this.user.new else "" }}</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Sounds better than mustache, at least because it follows Odin's syntax.
				</p>
			</li>
			<li>
				<p>
                    <s>
					<a
						href="https://github.com/laytan/todomvc-odin-htmx" 
						class="external-link" 
						target="_blank" >
                        todomvc-odin-htmx
					</a>
                    </s>.
				</p>
				<ul>
					<li>
						<p>
                            This is mainly here to dogfood the libraries and provide an example.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://todomvc.com/" 
								class="external-link" 
								target="_blank" >
                                TodoMVC
							</a>
                            &nbsp;is a project for comparing web projects, benchmarking, etc. You implement and compare.
						</p>
					</li>
					<li>
						<p>
                            [2025/10/12]
						</p>
						<ul>
							<li>
								<p>
                                    HTMX seemed to be only inside 
                                    <code>.twig</code>
                                    &nbsp;files, i.e., in the templates.
								</p>
							</li>
							<li>
								<p>
                                    I tried to build and had several issues:
								</p>
								<ul>
									<li>
										<p>
                                            Submodules were completely broken, asking for an ssh key, even though the repo is public. I don't know if this makes sense.
										</p>
										<ul>
											<li>
												<p>
                                                    I had to remove the old submodules and get them again using the public address:
												</p>
												<ul>
													<li>
														<p>
                                                            From 
                                                            <code>git@github.com:laytan/temple.git</code>
                                                            &nbsp;to 
                                                            <code>https://github.com/laytan/temple</code>
                                                            , for example.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            The main project simply doesn't compile.
										</p>
										<ul>
											<li>
												<p>
                                                    There are several errors in Odin and usage that simply don't make sense.
												</p>
											</li>
											<li>
												<p>
                                                    I didn't understand. Odin simply doesn't allow what the author tried to do; it's not part of the language.
												</p>
												<ul>
													<li>
														<p>
                                                            Tried calling functions in the global scope, for example.
														</p>
													</li>
												</ul>
<pre><code class="language-sh" data-lang="sh"> Error: Procedures requiring a 'context' cannot be called at the global scope 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... pl_index := temple.compiled("templates/index.temple.twig", List) 
</code></pre>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://github.com/benjamindblock/odin-mustache" 
				class="external-link" 
				target="_blank" >
                odin-mustache
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Native implementation of 
					<a
						href="https://github.com/mustache/mustache" 
						class="external-link" 
						target="_blank" >
                        mustache
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Port of the &quot;Mustache Logic-less Ruby templates&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Works via 
                    <code>{{ }}</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    In theory, I prefer Temple, at least because it follows Odin's syntax.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="wasm" >
    WASM
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=WhRIjmHS-Og" 
				class="external-link" 
				target="_blank" >
                Make a web build
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/karl-zylinski/odin-raylib-web" 
				class="external-link" 
				target="_blank" >
                odin-raylib-web
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/karl-zylinski/odin-sokol-web" 
				class="external-link" 
				target="_blank" >
                odin-sokol-web
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/thetarnav/odin-wasm" 
				class="external-link" 
				target="_blank" >
                odin-wasm
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://gist.github.com/gingerBill/9a6c0a6f0a34a147ff82e9f6047db2ac" 
				class="external-link" 
				target="_blank" >
                wasm-4 odin bindings - GingerBill
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="limitations" >
    Limitations
</h5>
<ul>
	<li>
		<p>
            Virtual memory does not exist on the web, so virtual memory allocators will not work.
		</p>
	</li>
</ul>
<h2
	id="file-system-process-cli-shell" >
    File System / Process / CLI / Shell
</h2>
<h3
	id="load-at-compile-time" >
    Load at compile-time
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#loadstring-path-or-loadstring-path-type" 
				class="external-link" 
				target="_blank" >
                #load
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Returns a 
                    <code>[]u8</code>
                    &nbsp;of the file contents at compile time.
				</p>
			</li>
			<li>
				<p>
                    The loaded data is baked into your program.
				</p>
			</li>
			<li>
				<p>
                    You can provide a type name as a second argument; interpreting the data as being of that type.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#load_directorystring-path" 
				class="external-link" 
				target="_blank" >
                #load_directory
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Loads all files within a directory, at compile time.
				</p>
				<ul>
					<li>
						<p>
                            The data is 
                            <code>name: string</code>
                            &nbsp;and 
                            <code>data: []byte</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    All the data of those files will be baked into your program.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#load_hashstring-path-string-hash" 
				class="external-link" 
				target="_blank" >
                #load_hash
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Returns a constant integer of the hash of a fileâ€™s contents at compile time.
				</p>
			</li>
			<li>
				<p>
                    Available hashes: 
                    <code>"adler32"</code>
                    , 
                    <code>"crc32"</code>
                    , 
                    <code>"crc64"</code>
                    , 
                    <code>"fnv32"</code>
                    , 
                    <code>"fnv64"</code>
                    , 
                    <code>"fnv32a"</code>
                    , 
                    <code>"fnv64a"</code>
                    , 
                    <code>"murmur32"</code>
                    , or 
                    <code>"murmur64"</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="coreos2" >
    core:os2
</h3>
<ul>
	<li>
		<p>
            <code>core:os/os2</code>
		</p>
	</li>
	<li>
		<p>
            It will replace 
            <code>core:os</code>
            &nbsp;in 2026.
		</p>
	</li>
	<li>
		<p>
            [2025/07/07]
		</p>
		<ul>
			<li>
				<p>
                    It's not on the web docs yet. Technically it's still WIP, though some parts of it are quite usable.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>process_exec</code>
		</p>
		<ul>
			<li>
				<p>
                    run with piped output and wait.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="process-execute" >
    Process Execute
</h5>
<ul>
	<li>
		<p>
			<strong>
                Must
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This procedure expects that 
                    <code>stdout</code>
                    &nbsp;and 
                    <code>stderr</code>
                    &nbsp;fields of the 
                    <code>desc</code>
                    &nbsp;parameter are left at default, i.e. a 
                    <code>nil</code>
                    &nbsp;value. You can not capture stdout/stderr and redirect it to a file at the same time.
				</p>
			</li>
			<li>
				<p>
                    <code>assert(desc.stdout == nil, "Cannot redirect stdout when it's being captured", loc)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>assert(desc.stderr == nil, "Cannot redirect stderr when it's being captured", loc)</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Memory
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This procedure does not free 
                    <code>stdout</code>
                    &nbsp;and 
                    <code>stderr</code>
                    &nbsp;slices before an error is returned. Make sure to call 
                    <code>delete</code>
                    &nbsp;on these slices.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="process-start" >
    Process Start
</h5>
<ul>
	<li>
		<p>
            <code>process_start</code>
		</p>
	</li>
	<li>
		<p>
            Asynchronous and more configurable, but requires more setup.
		</p>
	</li>
	<li>
		<p>
            See 
			<a
				href="Shells.html" 
				class="internal-link" 
				target="_self" >
                Shells
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=VmspMXkEhSM" 
						class="external-link" 
						target="_blank" >
                        Further investigations
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="coreos" >
    core:os
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#Handle" 
				class="external-link" 
				target="_blank" >
                <code>Handle</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Used to perform many operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#File_Info" 
				class="external-link" 
				target="_blank" >
                <code>File_Info</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#open" 
				class="external-link" 
				target="_blank" >
                <code>open</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#read" 
				class="external-link" 
				target="_blank" >
                <code>read</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/os/#read_entire_file_from_filename" 
						class="external-link" 
						target="_blank" >
                        <code>read_entire_file_from_filename</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>core/os/os.odin:131</code>
                            : Automatically does 
                            <code>open</code>
                            &nbsp;and then 
                            <code>close</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/core/os/#read_entire_file_from_handle" 
						class="external-link" 
						target="_blank" >
                        <code>read_entire_file_from_handle</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>core/os/os.odin:141</code>
                            : Does not do 
                            <code>open</code>
                            &nbsp;or 
                            <code>close</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#write" 
				class="external-link" 
				target="_blank" >
                <code>write</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#flush" 
				class="external-link" 
				target="_blank" >
                <code>flush</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#close" 
				class="external-link" 
				target="_blank" >
                <code>close</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#exists" 
				class="external-link" 
				target="_blank" >
                <code>exists</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#is_file" 
				class="external-link" 
				target="_blank" >
                <code>if_file</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#make_directory" 
				class="external-link" 
				target="_blank" >
                <code>make_directory</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#remove" 
				class="external-link" 
				target="_blank" >
                <code>remove</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/os/#rename" 
				class="external-link" 
				target="_blank" >
                <code>rename</code>
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="corec-libc" >
    <s>core:c/libc</s>
</h3>
<ul>
	<li>
		<p>
            <code>core:c/libc</code>
		</p>
	</li>
	<li>
		<p>
            Not native in Odin.
		</p>
	</li>
	<li>
		<p>
            Has 
            <code>system</code>
            &nbsp;for just running basic command-line commands
		</p>
	</li>
	<li>
		<p>
            [2025/10/29]
		</p>
	</li>
	<li>
		<p>
            I was using 
            <code>libc.system</code>
            &nbsp;for some basic commands, but once I learned how to use the 
            <code>os2</code>
            , I think is much better and should be the go to for CLI.
		</p>
	</li>
</ul>
<h2
	id="useful-packages" >
    Useful Packages
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/jakubtomsu/awesome-odin" 
				class="external-link" 
				target="_blank" >
                Collection of tools
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="math" >
    Math
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Omair-R/Nuod" 
				class="external-link" 
				target="_blank" >
                Nuod (Numpy Odin)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Omair-R/fftod" 
				class="external-link" 
				target="_blank" >
                FFTOD - Odin
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Fast Fourier Transform (FFT) written in the Odin language.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="geometry" >
    Geometry
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Binasaurus-Hex/PolyMerge" 
				class="external-link" 
				target="_blank" >
                Odin-poly-merge
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="pathfinding" >
    Pathfinding
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/scoobery/odin_pathgrid" 
				class="external-link" 
				target="_blank" >
                Odin-pathgrid
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/ChrisPHP/odin-flowfield" 
				class="external-link" 
				target="_blank" >
                odin-flowfield
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="logger" >
    Logger
</h3>
<ul>
	<li>
		<p>
            By default, there is no logger in the Context.
		</p>
	</li>
</ul>
<h5
	id="using-a-logger" >
    Using a logger
</h5>
<pre><code class="language-odin" data-lang="odin">import "core:log"
</code></pre>
<h5
	id="creating-a-logger" >
    Creating a logger
</h5>
<pre><code class="language-odin" data-lang="odin">context.logger = log.create_console_logger()
// or
context.logger = log.create_file_logger()
</code></pre>
<ul>
	<li>
		<p>
            <img src="assets/image_20250402092216.png" width="1350" >
            .
		</p>
	</li>
</ul>
<h5
	id="options" >
    Options
</h5>
<pre><code class="language-odin" data-lang="odin">context.logger = log.create_console_logger(
&nbsp;&nbsp;&nbsp;&nbsp;opt = log.Options{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Level,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Terminal_Color,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// .Short_File_Path,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Procedure,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// .Line,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// .Thread_Id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
)
</code></pre>
<h3
	id="json" >
    Json
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/encoding/json/" 
				class="external-link" 
				target="_blank" >
                core:encoding/json
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/odin-lang/examples/tree/master/json" 
				class="external-link" 
				target="_blank" >
                Examples
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="marshal-and-unmarshal" >
    Marshal and Unmarshal
</h5>
<ul>
	<li>
		<p>
			<strong>
                Struct field tags
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin"> User :: struct {
&nbsp;&nbsp;&nbsp;&nbsp; flag: bool, // untagged field
&nbsp;&nbsp;&nbsp;&nbsp; age:&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;"custom whatever information",
&nbsp;&nbsp;&nbsp;&nbsp; name: string `json:"username" xml:"user-name" fmt:"q"`, // `core:reflect` layout
 }
</code></pre>
		<ul>
			<li>
				<p>
                    If multiple information is to be passed in the 
                    <code>"value"</code>
                    , usually it is specified by separating it with a comma (
                    <code>,</code>
                    ).
				</p>
<pre><code class="language-odin" data-lang="odin"> name: string `json:"username,omitempty",
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                About unions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>core:encoding/json</code>
                    &nbsp;is pretty simple when it comes to 
                    <code>union</code>
                    s, it just takes the first variant that it can unmarshal without error. For structs it doesn't consider an unknown field to be an error, though, and I don't think there's a way to make it do so
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="comparison" >
    Comparison
</h5>
<ul>
	<li>
		<p>
			<strong>
                In Odin
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Simple layout
					</em>
                    :
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> for tileset_info in mundo["defs"].(json.Object)["tilesets"].(json.Array) {
&nbsp;&nbsp;&nbsp;&nbsp; if tileset_info.(json.Object)["identifier"].(json.String) == "Internal_Icons" {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue 
&nbsp;&nbsp;&nbsp;&nbsp; }
 }
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Practical layout
					</em>
                    :
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> for tileset_info in mundo["defs"].(json.Object)["tilesets"].(json.Array) {
&nbsp;&nbsp;&nbsp;&nbsp; tileset_info := item.(json.Object)
&nbsp;&nbsp;&nbsp;&nbsp; if tileset_info["identifier"].(json.String) == "Internal_Icons" {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue
&nbsp;&nbsp;&nbsp;&nbsp; }
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                In Zig
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Simple layout
					</em>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> for (jsonParsed.value.object.get("defs").?.object.get("tilesets").?.array.items) |item| {
</code></pre>
			</li>
		</ul>
		<p>
            Â  Â  Â  Â  if (std.mem.eql(u8, item.object.get(&quot;identifier&quot;).?.string, &quot;Internal_Icons&quot;)) {
            <br>
            Â  Â  Â  Â  Â  Â  continue;
            <br>
            Â  Â  Â  Â  }
            <br>
            Â  Â  }
            <br>
            ```
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Practical layout
					</em>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> for (jsonParsed.value.object.get("defs").?.object.get("tilesets").?.array.items) |item| {
</code></pre>
			</li>
		</ul>
		<p>
            Â  Â  Â  Â  const info_tileset = item.object;
            <br>
            Â  Â  Â  Â  if (std.mem.eql(u8, info_tileset.get(&quot;identifier&quot;).?.string, &quot;Internal_Icons&quot;)) {
            <br>
            Â  Â  Â  Â  Â  Â  continue;
            <br>
            Â  Â  Â  Â  }
            <br>
            Â  Â  }
            <br>
            ```
		</p>
	</li>
	<li>
		<p>
			<strong>
                In Godot
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Without reinforcing casting
					</em>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> for ts in mundo.get('defs').get('tilesets'):
&nbsp;&nbsp;&nbsp;&nbsp; if (ts.get('identifier') == 'Internal_Icons'):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Slightly reinforcing casting
					</em>
                    : (Using like this atm)
				</p>
<pre><code class="language-odin" data-lang="odin"> for ts: Dictionary in (mundo.get('defs') as Dictionary).get('tilesets'):
&nbsp;&nbsp;&nbsp;&nbsp; if (ts.get('identifier') == 'Internal_Icons'):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Reinforcing casting
					</em>
                    :
				</p>
<pre><code class="language-odin" data-lang="odin"> for ts: Dictionary in ((mundo.get('defs') as Dictionary).get('tilesets') as Array):
&nbsp;&nbsp;&nbsp;&nbsp; if ((ts.get('identifier') as String) == 'Internal_Icons'):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="sql" >
    SQL
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/saenai255/odin-sqlite3" 
				class="external-link" 
				target="_blank" >
                odin-sqlite3
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Skytrias/odin-sqlite" 
				class="external-link" 
				target="_blank" >
                odin-sqlite
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/powerc9000/odin_sqlite" 
				class="external-link" 
				target="_blank" >
                odin_sqlite
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/laytan/odin-mysql" 
				class="external-link" 
				target="_blank" >
                MySQL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/laytan/odin-postgresql" 
				class="external-link" 
				target="_blank" >
                Postgree
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="plotting" >
    Plotting
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/joaocarvalhoopen/Plots_in_Odin/tree/main" 
				class="external-link" 
				target="_blank" >
                Plots_in_Odin
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="network" >
    Network
</h3>
<ul>
	<li>
		<p>
            &quot;0 bytes received means the connection was closed normally/gracefully, and then you have the 
            <code>.Connection_Closed</code>
            &nbsp;error for abnormal closes&quot;.
		</p>
	</li>
	<li>
		<p>
            <code>.Would_Block</code>
		</p>
		<ul>
			<li>
				<p>
                    &quot;it's not an actual error in this case. it just uses the error slot to indicate that you need to wait.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/odin-lang/examples/tree/master/net/tcp_echo_server" 
				class="external-link" 
				target="_blank" >
                Echo server example
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/laytan/odin-http" 
				class="external-link" 
				target="_blank" >
                Odin-http
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Inch4Tk/odinhttp" 
				class="external-link" 
				target="_blank" >
                odinhttp
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="terminal-utilities" >
    Terminal Utilities
</h3>
<h4
	id="capturing-codectrl-c-code-in-the-terminal" >
    Capturing 
    <code>ctrl + C</code>
    &nbsp;in the Terminal
</h4>
<h5
	id="windows" >
    Windows
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://learn.microsoft.com/en-us/windows/console/setconsolectrlhandler?redirectedfrom=MSDN" 
				class="external-link" 
				target="_blank" >
                Info
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">main :: proc() {
Â  Â  win_handler_ok := windows.SetConsoleCtrlHandler(win_handler, windows.TRUE)
Â  Â  if !win_handler_ok {
Â  Â  Â  Â  log.error("win_handler not ok")
Â  Â  Â  Â  return
Â  Â  }

Â  Â  for !wants_to_exit {
Â  Â  }
}


wants_to_exit := false


win_handler :: proc "system" (dwCtrlType: windows.DWORD) -&gt; windows.BOOL {
Â  Â  // fmt.printfln("dwCtrlType: %v", dwCtrlType)
Â  Â  switch dwCtrlType {
Â  Â  case windows.CTRL_C_EVENT, windows.CTRL_BREAK_EVENT, windows.CTRL_CLOSE_EVENT:
Â  Â  Â  Â  wants_to_exit = true
Â  Â  }
Â  Â  return windows.TRUE
}
</code></pre>
<h5
	id="linux" >
    Linux
</h5>
<pre><code class="language-odin" data-lang="odin">package shnt

import "core:fmt"
import "core:sys/linux"

_got_int: bool 

_int_handler :: proc "c" (sig: linux.Signal) {
&nbsp;&nbsp;&nbsp;&nbsp;_got_int = true
}

main :: proc() { 
&nbsp;&nbsp;&nbsp;&nbsp;sigact: linux.Sig_Action(int) = { 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler = _int_handler,
&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;old_sigact: ^linux.Sig_Action(int)
&nbsp;&nbsp;&nbsp;&nbsp;linux.rt_sigaction(.SIGINT, &sigact, old_sigact)
&nbsp;&nbsp;&nbsp;&nbsp;for !_got_int { } 
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("got sigint!")
}
</code></pre>
<h4
	id="colors-and-strings" >
    Colors and Strings
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://forum.odin-lang.org/t/odin-cli-best-practices/175" 
				class="external-link" 
				target="_blank" >
                Post about ANSI Colors and string lengths
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/hrszpuk/odin-color" 
				class="external-link" 
				target="_blank" >
                odin-color
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="formats" >
    Formats
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/hpb0412/odin-mpc" 
				class="external-link" 
				target="_blank" >
                odin-mcpx
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Using 
					<em>
                        mpc
					</em>
                    &nbsp;might be of interest to you if you are...
				</p>
				<ul>
					<li>
						<p>
                            Building a new programming language
						</p>
					</li>
					<li>
						<p>
                            Building a new data format
						</p>
					</li>
					<li>
						<p>
                            Parsing an existing programming language
						</p>
					</li>
					<li>
						<p>
                            Parsing an existing data format
						</p>
					</li>
					<li>
						<p>
                            Embedding a Domain Specific Language
						</p>
					</li>
					<li>
						<p>
                            Implementing 
							<a
								href="http://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule" 
								class="external-link" 
								target="_blank" >
                                Greenspun's Tenth Rule
							</a>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="image-formats" >
    Image Formats
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/CoolDove/odin-assimp/" 
				class="external-link" 
				target="_blank" >
                odin-assimp
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/assimp/assimp" 
						class="external-link" 
						target="_blank" >
                        Assimp
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/assimp/assimp/blob/master/doc/Fileformats.html" 
						class="internal-link" 
						target="_self" >
                        List of all file formats supported
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Support for 
							<a
								href="https://en.wikipedia.org/wiki/.blend_(file_format)" 
								class="external-link" 
								target="_blank" >
                                BLEND
							</a>
                            &nbsp;is deprecated. It is too time-consuming to maintain an undocumented format which contains so much more than we need.
						</p>
					</li>
					<li>
						<p>
                            No 
                            <code>.exr</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Can calculate the tangents for each vertex if used a flag during 
                    <code>readFile</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                png
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In png, the alpha channel is optional.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pkg.odin-lang.org/vendor/stb/image/#load_from_file" 
						class="external-link" 
						target="_blank" >
                        vendor:stb/image
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://github.com/nothings/stb/blob/master/stb_image.h" 
								class="external-link" 
								target="_blank" >
                                Documentation
							</a>
                            .
						</p>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin"> channels, width, height: ^i32
 image.load("file.png", width, height, channels, 4)
</code></pre>
				<ul>
					<li>
						<p>
                            The first 3 are set by the function to read the data, so if you have an RGB image, 
                            <code>channels</code>
                            &nbsp;will be 
                            <code>3</code>
                            &nbsp;but it'll load 4 because 
                            <code>4</code>
                            &nbsp;was specified as the 
                            <code>desired_channels</code>
                            , so you can do 
                            <code>data[:width * height * 4]</code>
                            &nbsp;to get a 
                            <code>[]byte</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The number of components N is 'desired_channels' if desired_channels is non-zero, or 
                            <code>*channels_in_file</code>
                            &nbsp;otherwise. If desired_channels is non-zero, 
                            <code>*channels_in_file</code>
                            &nbsp;has the number of components that would have been output otherwise. E.g. if you set desired_channels to 4, you will always get RGBA output
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<a
						href="https://pkg.odin-lang.org/core/image/png/" 
						class="external-link" 
						target="_blank" >
                        core:image/png
					</a>
                    </s>.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Performance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    hello, I'm using 
                                    <code>core:image/png</code>
                                    &nbsp;to read a 4k png image and it seems 
									<em>
                                        really
									</em>
                                    &nbsp;slow, taking 8-10 seconds to complete. This is the code I'm using: 
                                    <code>png.load_from_file(path, { .alpha_add_if_missing }, context.temp_allocator)</code>
                                    . Is there something here I should be aware of? I'm loading the texture to then send it to the GPU with a vulkan host_visible/host_coherent staging buffer, and then to a device_local image. I profiled the whole process and I'm pretty sure this 
                                    <code>png</code>
                                    &nbsp;is what is slowing things down. Do you have some tips for this? I don't know much about png, so I don't know what to expect, but this seems too much
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Yawning:
						</p>
						<ul>
							<li>
								<p>
                                    if you profile it, my gut feeling is that it is zlib, since we have a naive implementation, but that's just a guess
								</p>
							</li>
							<li>
								<p>
                                    we do try to make core fast, but maintainabily/ease of implementation take priority atm
								</p>
							</li>
							<li>
								<p>
                                    &quot;I think core:image is basically always gonna be slower than stb&quot;, I wouldn't say always, this can be made faster, but it's a time/effort/personel thing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Barinzaya:
						</p>
						<ul>
							<li>
								<p>
                                    Is that in an optimized build? It's pure Odin code, so optimization settings 
									<em>
                                        will
									</em>
                                    &nbsp;affect it, and they're usually significant.
								</p>
							</li>
							<li>
								<p>
                                    That being said, even in an optimized build, AFAIK 
                                    <code>stb_image</code>
                                    &nbsp;is typically faster (though it comes with cautions about using it with untrusted images, if that applies to you)
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    oh yea, with 
                                    <code>-o:speed</code>
                                    &nbsp;the load time drops to ~1s
								</p>
							</li>
							<li>
								<p>
                                    just out of curiosity: with 
                                    <code>-o:speed</code>
                                    , 
                                    <code>image/png</code>
                                    &nbsp;takes 344ms to load the 4k image, vs 6ms from 
                                    <code>stb/image</code>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="3d-models" >
    3D Models
</h5>
<ul>
	<li>
		<p>
			<strong>
                gltf
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-buffer" 
						class="external-link" 
						target="_blank" >
                        gltf spec
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/Pawel82S/glTF2" 
						class="external-link" 
						target="_blank" >
                        gtfl2
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The content is the same as 
                            <code>cgltf</code>
                            , but it seems better, indeed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~
					<a
						href="https://pkg.odin-lang.org/vendor/cgltf/" 
						class="external-link" 
						target="_blank" >
                        cgltf
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/jakubtomsu/odin-vox" 
				class="external-link" 
				target="_blank" >
                Vox loader
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="config-files" >
    Config Files
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/laytan/odin-ini-parser" 
				class="external-link" 
				target="_blank" >
                odin-ini
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Up05/toml_parser" 
				class="external-link" 
				target="_blank" >
                odin-toml-parser
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="general-data-files" >
    General Data Files
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/mabeh19/bml/" 
				class="external-link" 
				target="_blank" >
                odin-bml
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Binary Markup Language (BML) is an XML scheme for describing structured binary data. The library contains a protocol parser, a binary data parser, as well as a C header emitter.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="markdown" >
    Markdown
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/vendor/commonmark/" 
				class="external-link" 
				target="_blank" >
                vendor:commonmark
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Bindings for 
					<a
						href="https://github.com/commonmark/cmark" 
						class="external-link" 
						target="_blank" >
                        CMark
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://github.com/hrszpuk/odin-markdown" 
				class="external-link" 
				target="_blank" >
                odin-markdown
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    [2025/10/14]
				</p>
				<ul>
					<li>
						<p>
                            Really not ready.
						</p>
					</li>
					<li>
						<p>
                            It's useful for creating a markdown file while inside Odin, but it's not a parser.
						</p>
					</li>
					<li>
						<p>
                            If you have an existing md file, it's useless for now.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                In C
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/commonmark/cmark" 
						class="external-link" 
						target="_blank" >
                        CMark
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/mity/md4c" 
						class="external-link" 
						target="_blank" >
                        md4c
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                In Go
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/yuin/goldmark/" 
						class="external-link" 
						target="_blank" >
                        goldmark
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="other-parsers" >
    Other Parsers
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Up05/odin-RFC-3339-date-parser" 
				class="external-link" 
				target="_blank" >
                odin-date-parser
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    RFC-3339.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="debug" >
    Debug
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/DaseinPhaos/pdb" 
				class="external-link" 
				target="_blank" >
                odin-pdb
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Reads Microsoft PDB (Program Database) files. Enables stacktracing on Windows for The Odin Programming Language.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="media" >
    Media
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/numbers-zz/odin-ffmpeg-bindings" 
				class="external-link" 
				target="_blank" >
                Odin-ffmpeg
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Kelimion/odin-file-formats" 
				class="external-link" 
				target="_blank" >
                Odin-file-formats
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Extensible Binary Meta Language (EBML)
				</p>
				<ul>
					<li>
						<p>
                            <code>Matroska</code>
                            &nbsp;and 
                            <code>WebM</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ISO Base Media File Format (BMFF)
				</p>
				<ul>
					<li>
						<p>
                            <code>MP4</code>
                            , 
                            <code>HEIF</code>
                            , 
                            <code>JPEG 2000</code>
                            , and other formats.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/jakubtomsu/odin-fmod" 
				class="external-link" 
				target="_blank" >
                fmod
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="hot-reload" >
    Hot-Reload
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/karl-zylinski/odin-raylib-hot-reload-game-template" 
				class="external-link" 
				target="_blank" >
                Odin + Raylib hotreload
			</a>
            .
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Graphics Programming/Slang.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Low-Level Systems/Memory/Memory.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2025-11-20 ðŸš€
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#about" >
                            About
						</a>
						<ul>
							<li>
								<a
									href="#impressions" >
                                    Impressions
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#installation" >
                            Installation
						</a>
						<ul>
							<li>
								<a
									href="#installation" >
                                    Installation
								</a>
							</li>
							<li>
								<a
									href="#building-from-source" >
                                    Building from source
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#building" >
                            Building
						</a>
						<ul>
							<li>
								<a
									href="#subsystems" >
                                    Subsystems
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#compile-time-stuff" >
                            Compile-time Stuff
						</a>
						<ul>
							<li>
								<a
									href="#compile-time-flags" >
                                    Compile-time Flags
								</a>
							</li>
							<li>
								<a
									href="#when" >
                                    When
								</a>
							</li>
							<li>
								<a
									href="#config" >
                                    #config
								</a>
							</li>
							<li>
								<a
									href="#procedure-disabled" >
                                    Procedure Disabled
								</a>
							</li>
							<li>
								<a
									href="#variable-and-procedure-access" >
                                    Variable and Procedure Access
								</a>
							</li>
							<li>
								<a
									href="#comp-time-loop" >
                                    Comp-time Loop
								</a>
							</li>
							<li>
								<a
									href="#build-tags" >
                                    Build Tags
								</a>
							</li>
							<li>
								<a
									href="#ignore" >
                                    Ignore
								</a>
							</li>
							<li>
								<a
									href="#optimizations" >
                                    Optimizations
								</a>
							</li>
							<li>
								<a
									href="#intrinsics" >
                                    Intrinsics
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#package-system" >
                            Package System
						</a>
						<ul>
							<li>
								<a
									href="#package-collections" >
                                    Package Collections
								</a>
							</li>
							<li>
								<a
									href="#types-of-packages" >
                                    Types of Packages
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#lsp-ols-odin-language-server" >
                            LSP (OLS - Odin Language Server)
						</a>
						<ul>
							<li>
								<a
									href="#check-args" >
                                    Check Args
								</a>
							</li>
							<li>
								<a
									href="#examples" >
                                    Examples
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#operations" >
                            Operations
						</a>
						<ul>
							<li>
								<a
									href="#arithmetic-operations" >
                                    Arithmetic Operations
								</a>
							</li>
							<li>
								<a
									href="#logical-operations" >
                                    Logical Operations
								</a>
							</li>
							<li>
								<a
									href="#bitwise-operations" >
                                    Bitwise Operations
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#control-flow-if-when-switch-for-defer" >
                            Control Flow (if, when, switch, for, defer)
						</a>
						<ul>
							<li>
								<a
									href="#if" >
                                    If
								</a>
							</li>
							<li>
								<a
									href="#if-ternary" >
                                    If Ternary
								</a>
							</li>
							<li>
								<a
									href="#for" >
                                    For
								</a>
							</li>
							<li>
								<a
									href="#when" >
                                    When
								</a>
							</li>
							<li>
								<a
									href="#switch" >
                                    Switch
								</a>
							</li>
							<li>
								<a
									href="#defer" >
                                    Defer
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#procedures" >
                            Procedures
						</a>
						<ul>
							<li>
								<a
									href="#calling-conventions" >
                                    Calling Conventions
								</a>
							</li>
							<li>
								<a
									href="#variadic-arguments" >
                                    Variadic Arguments
								</a>
							</li>
							<li>
								<a
									href="#multiple-returns" >
                                    Multiple returns
								</a>
							</li>
							<li>
								<a
									href="#closures-they-dont-exist" >
                                    Closures (They don't exist)
								</a>
							</li>
							<li>
								<a
									href="#procedure-groups-explicit-overload" >
                                    Procedure Groups (explicit overload)
								</a>
							</li>
							<li>
								<a
									href="#generics" >
                                    Generics
								</a>
							</li>
							<li>
								<a
									href="#force-parameters-to-be-compile-time-constants" >
                                    Force parameters to be compile-time constants
								</a>
							</li>
							<li>
								<a
									href="#deferred" >
                                    Deferred
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#typing" >
                            Typing
						</a>
						<ul>
							<li>
								<a
									href="#declaration" >
                                    Declaration
								</a>
							</li>
							<li>
								<a
									href="#literal-types" >
                                    Literal Types
								</a>
							</li>
							<li>
								<a
									href="#untyped-types" >
                                    Untyped Types
								</a>
							</li>
							<li>
								<a
									href="#zero-value" >
                                    Zero Value
								</a>
							</li>
							<li>
								<a
									href="#broadcasting" >
                                    Broadcasting
								</a>
							</li>
							<li>
								<a
									href="#casting" >
                                    Casting
								</a>
							</li>
							<li>
								<a
									href="#transmute" >
                                    Transmute
								</a>
							</li>
							<li>
								<a
									href="#type-conversions" >
                                    Type Conversions
								</a>
							</li>
							<li>
								<a
									href="#type-typeid-size_of" >
                                    type / typeid / size_of
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#any" >
                            any
						</a>
						<ul>
							<li>
								<a
									href="#comparison-codeany-code-vs-codeunion-code" >
                                    Comparison <code>any</code> vs <code>union</code>
								</a>
							</li>
							<li>
								<a
									href="#structure" >
                                    Structure
								</a>
							</li>
							<li>
								<a
									href="#storing-data" >
                                    Storing data
								</a>
							</li>
							<li>
								<a
									href="#getting-the-underlying-value" >
                                    Getting the underlying value
								</a>
							</li>
							<li>
								<a
									href="#etc" >
                                    Etc
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#primitive-types" >
                            Primitive Types
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#math-types" >
                            Math Types
						</a>
						<ul>
							<li>
								<a
									href="#matrix" >
                                    Matrix
								</a>
							</li>
							<li>
								<a
									href="#quaternion" >
                                    Quaternion
								</a>
							</li>
							<li>
								<a
									href="#complex" >
                                    Complex
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#strings" >
                            Strings
						</a>
						<ul>
							<li>
								<a
									href="#strings" >
                                    Strings
								</a>
							</li>
							<li>
								<a
									href="#manipulation" >
                                    Manipulation
								</a>
							</li>
							<li>
								<a
									href="#slicing" >
                                    Slicing
								</a>
							</li>
							<li>
								<a
									href="#prints" >
                                    Prints
								</a>
							</li>
							<li>
								<a
									href="#formatting" >
                                    Formatting
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#rune" >
                            Rune
						</a>
						<ul>
							<li>
								<a
									href="#untyped-runes-rune-literals" >
                                    Untyped Runes / Rune Literals
								</a>
							</li>
							<li>
								<a
									href="#other-usages" >
                                    Other usages
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#maps-hash-maps" >
                            Maps (Hash Maps)
						</a>
						<ul>
							<li>
								<a
									href="#memory" >
                                    Memory
								</a>
							</li>
							<li>
								<a
									href="#create" >
                                    Create
								</a>
							</li>
							<li>
								<a
									href="#delete" >
                                    Delete
								</a>
							</li>
							<li>
								<a
									href="#insert-update" >
                                    Insert / update
								</a>
							</li>
							<li>
								<a
									href="#access" >
                                    Access
								</a>
							</li>
							<li>
								<a
									href="#remove-element" >
                                    Remove element
								</a>
							</li>
							<li>
								<a
									href="#modify" >
                                    Modify
								</a>
							</li>
							<li>
								<a
									href="#quotcompound-literalsquot" >
                                    &quot;Compound Literals&quot;
								</a>
							</li>
							<li>
								<a
									href="#container-calls" >
                                    Container Calls
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#struct" >
                            Struct
						</a>
						<ul>
							<li>
								<a
									href="#parametric-polymorphism-parapoly" >
                                    Parametric Polymorphism (Parapoly)
								</a>
							</li>
							<li>
								<a
									href="#subtype-polymorphism-keyword-codeusing-code" >
                                    Subtype Polymorphism (Keyword <code>using</code>)
								</a>
							</li>
							<li>
								<a
									href="#memory-layout" >
                                    Memory Layout
								</a>
							</li>
							<li>
								<a
									href="#reflect" >
                                    Reflect
								</a>
							</li>
							<li>
								<a
									href="#etc" >
                                    Etc
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#union" >
                            Union
						</a>
						<ul>
							<li>
								<a
									href="#parametric-polymorphism-parapoly" >
                                    Parametric Polymorphism (Parapoly)
								</a>
							</li>
							<li>
								<a
									href="#print" >
                                    Print
								</a>
							</li>
							<li>
								<a
									href="#casting" >
                                    Casting
								</a>
							</li>
							<li>
								<a
									href="#type-check" >
                                    Type check
								</a>
							</li>
							<li>
								<a
									href="#maybe" >
                                    Maybe
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#bit-sets" >
                            Bit Sets
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#arrays" >
                            Arrays
						</a>
						<ul>
							<li>
								<a
									href="#common-operations" >
                                    Common Operations
								</a>
							</li>
							<li>
								<a
									href="#fixed-arrays-codent-code" >
                                    Fixed Arrays (<code>[n]T</code>)
								</a>
							</li>
							<li>
								<a
									href="#slices-codet-code" >
                                    Slices (<code>[]T</code>)
								</a>
							</li>
							<li>
								<a
									href="#dynamic-arrays-codedynamict-code" >
                                    Dynamic Arrays (<code>[dynamic]T</code>)
								</a>
							</li>
							<li>
								<a
									href="#multi-pointer-codet-code" >
                                    Multi-pointer (<code>[^]T</code>)
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#interfaces-methods-vtables" >
                            Interfaces / Methods / VTables
						</a>
						<ul>
							<li>
								<a
									href="#operator-code-gt-code" >
                                    Operator <code>-&gt;</code>
								</a>
							</li>
							<li>
								<a
									href="#discussion" >
                                    Discussion
								</a>
							</li>
							<li>
								<a
									href="#vtables-virtual-tables" >
                                    VTables (Virtual Tables)
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#error-handling" >
                            Error Handling
						</a>
						<ul>
							<li>
								<a
									href="#definitions" >
                                    Definitions
								</a>
							</li>
							<li>
								<a
									href="#panics" >
                                    Panics
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory" >
                            Memory
						</a>
						<ul>
							<li>
								<a
									href="#assignment" >
                                    Assignment
								</a>
							</li>
							<li>
								<a
									href="#size" >
                                    Size
								</a>
							</li>
							<li>
								<a
									href="#memory-leaks" >
                                    Memory Leaks
								</a>
							</li>
							<li>
								<a
									href="#stack-use-after-return" >
                                    Stack-Use-After-Return
								</a>
							</li>
							<li>
								<a
									href="#use-after-free-uaf" >
                                    Use-After-Free (UAF)
								</a>
							</li>
							<li>
								<a
									href="#context" >
                                    Context
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory-address" >
                            Memory: Address
						</a>
						<ul>
							<li>
								<a
									href="#pointers" >
                                    Pointers
								</a>
							</li>
							<li>
								<a
									href="#zero-by-default" >
                                    Zero by default
								</a>
							</li>
							<li>
								<a
									href="#alignment" >
                                    Alignment
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory-allocators" >
                            Memory: Allocators
						</a>
						<ul>
							<li>
								<a
									href="#implicit-allocator-usage" >
                                    Implicit Allocator Usage
								</a>
							</li>
							<li>
								<a
									href="#default-allocators" >
                                    Default Allocators
								</a>
							</li>
							<li>
								<a
									href="#nil-allocator" >
                                    Nil Allocator
								</a>
							</li>
							<li>
								<a
									href="#panic-allocator" >
                                    Panic Allocator
								</a>
							</li>
							<li>
								<a
									href="#arena-backed-directly-by-virtual-memory-codevmem-arena-code" >
                                    Arena: Backed directly by virtual memory (<code>vmem.Arena</code>)
								</a>
							</li>
							<li>
								<a
									href="#arena-backed-buffer-as-an-arena-codemem-arena-code" >
                                    Arena: Backed buffer as an arena (<code>mem.Arena</code>)
								</a>
							</li>
							<li>
								<a
									href="#arena-growing-codemem-arena-code-codemem-dynamic_arena-code" >
                                    Arena: Growing <code>mem.Arena</code> (<code>mem.Dynamic_Arena</code>)
								</a>
							</li>
							<li>
								<a
									href="#arena-codecontext-temp_allocator-code-coderuntime-default_temp_allocator-code" >
                                    Arena: <code>context.temp_allocator</code> (<code>runtime.Default_Temp_Allocator</code>)
								</a>
							</li>
							<li>
								<a
									href="#scratch-allocator" >
                                    Scratch Allocator
								</a>
							</li>
							<li>
								<a
									href="#stack-allocator-lifo" >
                                    Stack Allocator (LIFO)
								</a>
							</li>
							<li>
								<a
									href="#buddy-memory-allocation" >
                                    Buddy Memory Allocation
								</a>
							</li>
							<li>
								<a
									href="#pool-allocator" >
                                    Pool Allocator
								</a>
							</li>
							<li>
								<a
									href="#general-purpose-free-list-based-allocator" >
                                    General Purpose: Free List Based Allocator
								</a>
							</li>
							<li>
								<a
									href="#general-purpose-heap-allocator" >
                                    General Purpose: Heap Allocator
								</a>
							</li>
							<li>
								<a
									href="#compact-allocator" >
                                    Compact Allocator
								</a>
							</li>
							<li>
								<a
									href="#mutex-allocator" >
                                    Mutex Allocator
								</a>
							</li>
							<li>
								<a
									href="#rollback-stack-allocator" >
                                    Rollback Stack Allocator
								</a>
							</li>
							<li>
								<a
									href="#wasm-allocator" >
                                    WASM Allocator
								</a>
							</li>
							<li>
								<a
									href="#tracking-allocator" >
                                    Tracking Allocator
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory-operations" >
                            Memory: Operations
						</a>
						<ul>
							<li>
								<a
									href="#mem-alloc" >
                                    Mem Alloc
								</a>
							</li>
							<li>
								<a
									href="#new" >
                                    New
								</a>
							</li>
							<li>
								<a
									href="#mem-free" >
                                    Mem Free
								</a>
							</li>
							<li>
								<a
									href="#mem-free-all" >
                                    Mem Free All
								</a>
							</li>
							<li>
								<a
									href="#make" >
                                    Make
								</a>
							</li>
							<li>
								<a
									href="#deletes" >
                                    Deletes
								</a>
							</li>
							<li>
								<a
									href="#mem-resize" >
                                    Mem Resize
								</a>
							</li>
							<li>
								<a
									href="#mem-set" >
                                    Mem Set
								</a>
							</li>
							<li>
								<a
									href="#mem-copy" >
                                    Mem Copy
								</a>
							</li>
							<li>
								<a
									href="#mem-zero" >
                                    Mem Zero
								</a>
							</li>
							<li>
								<a
									href="#resize" >
                                    Resize
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#multi-threading" >
                            Multi-Threading
						</a>
						<ul>
							<li>
								<a
									href="#conditions" >
                                    Conditions
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#directives" >
                            Directives
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#ffi-foreign-function-interface-bindings" >
                            FFI (Foreign Function Interface) / Bindings
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#web-build" >
                            Web Build
						</a>
						<ul>
							<li>
								<a
									href="#not-wasm" >
                                    Not-WASM
								</a>
							</li>
							<li>
								<a
									href="#wasm" >
                                    WASM
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#file-system-process-cli-shell" >
                            File System / Process / CLI / Shell
						</a>
						<ul>
							<li>
								<a
									href="#load-at-compile-time" >
                                    Load at compile-time
								</a>
							</li>
							<li>
								<a
									href="#coreos2" >
                                    core:os2
								</a>
							</li>
							<li>
								<a
									href="#coreos" >
                                    core:os
								</a>
							</li>
							<li>
								<a
									href="#corec-libc" >
                                    <s>core:c/libc</s>
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#useful-packages" >
                            Useful Packages
						</a>
						<ul>
							<li>
								<a
									href="#math" >
                                    Math
								</a>
							</li>
							<li>
								<a
									href="#geometry" >
                                    Geometry
								</a>
							</li>
							<li>
								<a
									href="#pathfinding" >
                                    Pathfinding
								</a>
							</li>
							<li>
								<a
									href="#logger" >
                                    Logger
								</a>
							</li>
							<li>
								<a
									href="#json" >
                                    Json
								</a>
							</li>
							<li>
								<a
									href="#sql" >
                                    SQL
								</a>
							</li>
							<li>
								<a
									href="#plotting" >
                                    Plotting
								</a>
							</li>
							<li>
								<a
									href="#network" >
                                    Network
								</a>
							</li>
							<li>
								<a
									href="#terminal-utilities" >
                                    Terminal Utilities
								</a>
							</li>
							<li>
								<a
									href="#formats" >
                                    Formats
								</a>
							</li>
							<li>
								<a
									href="#hot-reload" >
                                    Hot-Reload
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.js" >
		</script>
	</body>
</html>
