<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.24731.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
					open="">
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering.html" >
                                Font Rendering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Low-Level Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers.html" >
                                Profilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - DOD e COP/Design - DOD e COP.html" >
                                Design - DOD e COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - ECS/Design - ECS.html" >
                                Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Design Patterns/Design - Design Patterns.html" >
                                Design - Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Architecture Patterns.html" >
                                Design - Architecture Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Concepts and Terminology.html" >
                                Design - Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Rules of thumb - Laws - Guidelines and Principles/Design - Rules of thumb - Laws - Guidelines and Principles.html" >
                                Design - Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Paradigms.html" >
                                Design - Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Production Methodologies/Design - Production Methodologies.html" >
                                Design - Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Security.html" >
                                Security
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Game Development
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game AI/Game AI.html" >
                                Game AI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Procedural Animation/Procedural Animation.html" >
                                Procedural Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game Design/Game Design.html" >
                                Game Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Level Design.html" >
                                Level Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Scanning Algorithms.html" >
                                Scanning Algorithms
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Art
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing, Color Theory, Pixel Art/Drawing, Color Theory, Pixel Art.html" >
                                Drawing, Color Theory, Pixel Art
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Low-Poly, PSX.html" >
                                Low-Poly, PSX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Animation.html" >
                                Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Texel Density.html" >
                                Texel Density
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender.html" >
                                Blender
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender - Rigging and Animation.html" >
                                Blender - Rigging and Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench.html" >
                                Blockbench
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench - Source Code.html" >
                                Blockbench - Source Code
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing Softwares.html" >
                                Drawing Softwares
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Aseprite/Aseprite.html" >
                                Aseprite
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Voxel Editors.html" >
                                Voxel Editors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/MagicaVoxel.html" >
                                MagicaVoxel
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 2D/Level Editors 2D.html" >
                                Level Editors 2D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 3D.html" >
                                Level Editors 3D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/LDtk/LDtk.html" >
                                LDtk
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/TrenchBroom.html" >
                                TrenchBroom
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Assets - Sources and References/Assets - Sources and References.html" >
                                Assets - Sources and References
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Frameworks - Libraries
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Frameworks - Libraries/Frameworks - Libraries.html" >
                                Frameworks - Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/RayLib/RayLib.html" >
                                RayLib
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Clay/Clay.html" >
                                Clay
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Physics Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines.html" >
                                Physics Engines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics.html" >
                                Physics Engines - JoltPhysics
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Godot Engine
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot/Godot.html" >
                                Godot
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDScript/Godot - GDScript.html" >
                                Godot - GDScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDExtensions.html" >
                                Godot - GDExtensions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - Source Code.html" >
                                Godot - Source Code
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Embedded Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/RaspiberryPi.html" >
                                RaspiberryPi
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Embedded Systems.html" >
                                Embedded Systems
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Platforms
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Windows/Windows.html" >
                                Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Steam/Steam.html" >
                                Steam
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Android/Android.html" >
                                Android
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/iOS/iOS.html" >
                                iOS
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Terminal
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Code Editors
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim/NeoVim.html" >
                                NeoVim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Etc
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Licenses.html" >
                                Licenses
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Unity/Unity.html" >
                                Unity
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Other Engines.html" >
                                Other Engines
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Vulkan
						</h1>
						<p>
							<time
								datetime="2025-08-01" >
                                üïí Created: 2025-08-01
							</time>
							<time
								datetime="2025-12-10" >
                                | Updated: 2025-12-10
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="starting" >
    Starting
</h2>
<h5
	id="versions" >
    Versions
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/versions.html" 
				class="external-link" 
				target="_blank" >
                Versions and Features Breakdown
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Patch notes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/vulkan_release_summary.html" 
				class="external-link" 
				target="_blank" >
                Version Release Summary
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=7CtjMfDdTdg" 
				class="external-link" 
				target="_blank" >
                Why not use Vulkan 1.0? {12:57 -&gt; end}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    1.0 is harder, with missing features and clunky interfaces.
				</p>
			</li>
			<li>
				<p>
                    The video is pretty nice. I listed the problems it explained about 1.0 and placed them in the documentation below.
				</p>
			</li>
			<li>
				<p>
                    It was well explained and I came to appreciate using Vulkan 1.3+.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="is-oop" >
    Is OOP?
</h5>
<ul>
	<li>
		<p>
            Version 1.3, (2024-02-22).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250801065314.png" width="375" >
            .
		</p>
	</li>
</ul>
<h5
	id="api-structs" >
    API Structs
</h5>
<ul>
	<li>
		<p>
            Many structures in Vulkan require you to explicitly specify the type of structure in the 
            <code>sType</code>
            &nbsp;member.
		</p>
	</li>
	<li>
		<p>
            Functions that create or destroy an object will have a 
            <code>VkAllocationCallbacks</code>
            &nbsp;parameter that allows you to use a custom allocator for driver memory, which will also be left 
            <code>nullptr</code>
            &nbsp;in this tutorial.
		</p>
	</li>
	<li>
		<p>
            Almost all functions return a 
            <code>VkResult</code>
            &nbsp;that is either 
            <code>SUCCESS</code>
            &nbsp;or an error code. The specification describes which error codes each function can return and what they mean.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>KHR</code>
            &nbsp;postfix, which means that these objects are part of a Vulkan extension.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>pNext</code>
            &nbsp;member can point to an extension structure.
		</p>
	</li>
</ul>
<h3
	id="compatibility" >
    Compatibility
</h3>
<h5
	id="support" >
    Support
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/platforms.html" 
				class="external-link" 
				target="_blank" >
                Platform Support
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/checking_for_support.html" 
				class="external-link" 
				target="_blank" >
                Checking for Vulkan support
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Windows (7 and later)
		</p>
		<ul>
			<li>
				<p>
                    Yes, via the official SDK and drivers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Linux
		</p>
		<ul>
			<li>
				<p>
                    Yes. Native support via Mesa and vendor drivers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Android (5.0+)
		</p>
		<ul>
			<li>
				<p>
                    Yes, most devices from Android 7.0+ support Vulkan.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            macOS
		</p>
		<ul>
			<li>
				<p>
                    No native support ‚Äî requires MoltenVK (Vulkan-to-Metal wrapper).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            iOS
		</p>
		<ul>
			<li>
				<p>
                    No native support ‚Äî requires MoltenVK.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Web
		</p>
		<ul>
			<li>
				<p>
                    No native support ‚Äî experimental via WebGPU or Emscripten with translation layers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Consoles.
		</p>
		<ul>
			<li>
				<p>
                    Partially supported; depends on platform SDKs and NDAs (e.g., Nintendo Switch uses a Vulkan-like API).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="driver-support" >
    Driver support
</h5>
<ul>
	<li>
		<p>
            Vulkan requires updated GPU drivers.
		</p>
	</li>
	<li>
		<p>
            Older or integrated GPUs (especially pre-2013) may lack Vulkan support.
		</p>
	</li>
	<li>
		<p>
            Vendor support varies: NVIDIA, AMD, and Intel generally support Vulkan on most modern hardware.
		</p>
	</li>
</ul>
<h5
	id="compatibility-layers" >
    Compatibility Layers
</h5>
<ul>
	<li>
		<p>
            To increase compatibility.
		</p>
	</li>
	<li>
		<p>
			<strong>
                MoltenVK
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Runs Vulkan on Metal (required for macOS/iOS).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                gfx-rs / wgpu / bgfx
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Abstraction layers to use Vulkan when available, fallback to other APIs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ANGLE / Zink
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can translate other APIs (e.g., OpenGL) to Vulkan and vice-versa.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="tutorials" >
    Tutorials
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/" 
				class="external-link" 
				target="_blank" >
                Vulkan Specs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html" 
				class="external-link" 
				target="_blank" >
                Complete Vulkan Spec
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vulkan.lunarg.com/sdk/home" 
				class="external-link" 
				target="_blank" >
                Vulkan SDK
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/vendor/vulkan/" 
				class="external-link" 
				target="_blank" >
                Vulkan Odin
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="tutorials-in-docs" >
    Tutorials in Docs
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://docs.vulkan.org/guide/latest/memory_allocation.html" 
				class="external-link" 
				target="_blank" >
                Docs Vulkan Guide
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I already read everything before the memory allocation section.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://docs.vulkan.org/tutorial/latest/00_Introduction.html" 
				class="external-link" 
				target="_blank" >
                Docs Vulkan Tutorial
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Based on the vulkan-tutorial, with differences:
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.4 as a baseline
						</p>
					</li>
					<li>
						<p>
                            Dynamic rendering instead of render passes
						</p>
					</li>
					<li>
						<p>
                            Timeline semaphores
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://shader-slang.org/" 
								class="external-link" 
								target="_blank" >
                                Slang
							</a>
                            &nbsp;as the primary shading language
						</p>
					</li>
					<li>
						<p>
                            Modern C++ (20) with modules
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/KhronosGroup/Vulkan-Hpp" 
								class="external-link" 
								target="_blank" >
                                Vulkan-Hpp
							</a>
                            &nbsp;with 
							<a
								href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" 
								class="external-link" 
								target="_blank" >
                                RAII
							</a>
						</p>
					</li>
					<li>
						<p>
                            It also contains Vulkan usage clarifications, improved synchronization and new content.
						</p>
					</li>
					<li>
						<p>
                            &quot;This tutorial will use RAII with smart pointers and it will endeavor to demonstrate the latest methods and extensions which should hopefully make Vulkan a joy to use.&quot;
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Does not require knowledge of previous APIs, but you need to know C++ and graphics math.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Holy moly the new C++ API is a pain.
						</p>
					</li>
					<li>
						<p>
                            I preferred to go back to the 
							<em>
                                vulkan-tutorial
							</em>
                            &nbsp;several times and check how it's used in the C API.
						</p>
					</li>
					<li>
						<p>
                            I used this tutorial only as a base to consider the new features.
						</p>
					</li>
					<li>
						<p>
                            I didn't use Slang, I didn't like it; I stayed with GLSL.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://vulkan-tutorial.com/" 
				class="external-link" 
				target="_blank" >
                vulkan-tutorial
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Does not require knowledge of previous APIs, but you need to know C++ and graphics math.
				</p>
			</li>
			<li>
				<p>
                    You can use C, but the tutorial is in C++.
				</p>
			</li>
			<li>
				<p>
                    Vulkan 1.0; shown 
					<a
						href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance" 
						class="external-link" 
						target="_blank" >
                        here
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Uses GLSL for shaders.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://vkguide.dev/" 
				class="external-link" 
				target="_blank" >
                Vulkan Guide
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    For people with previous experience with Graphics APIs.
				</p>
			</li>
			<li>
				<p>
                    I'm not a big fan of this guide.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Uses
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.3.
						</p>
					</li>
					<li>
						<p>
                            C++, Visual Studio, CMake.
						</p>
					</li>
					<li>
						<p>
                            SDL to create a window.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/charles-lunarg/vk-bootstrap/blob/master/src/VkBootstrap.cpp" 
								class="external-link" 
								target="_blank" >
                                Vk Bootstrap
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Abstracts a big amount of boilerplate that Vulkan has when setting up. Most of that code is written once and never touched again, so we will skip most of it using this library. This library simplifies instance creation, swapchain creation, and extension loading. It will be removed from the project eventually in an optional chapter that explains how to initialize that Vulkan boilerplate the ‚Äúmanual‚Äù way.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator" 
								class="external-link" 
								target="_blank" >
                                VMA (Vulkan Memory Allocator)
							</a>
						</p>
						<ul>
							<li>
								<p>
                                    Implements memory allocators for Vulkan, header only. In Vulkan, the user has to deal with the memory allocation of buffers, images, and other resources on their own. This can be very difficult to get right in a performant and safe way. Vulkan Memory Allocator does it for us and allows us to simplify the creation of images and other resources. Widely used in personal Vulkan engines or smaller scale projects like emulators. Very high end projects like Unreal Engine or AAA engines write their own memory allocators.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The tutorial gives you a project with many things already done, and holds your hand for every syntax, file, folder, methodology, etc.
						</p>
						<ul>
							<li>
								<p>
                                    It simply throws a lot of stuff at you.
								</p>
							</li>
							<li>
								<p>
                                    It's a pretty 
									<em>
                                        bloated
									</em>
                                    &nbsp;experience, for sure.
								</p>
							</li>
							<li>
								<p>
                                    I consider that a pain.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/SaschaWillems/Vulkan" 
				class="external-link" 
				target="_blank" >
                Samples Collections in C++
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://gpuopen.com/learn/vulkan-barriers-explained/" 
				class="external-link" 
				target="_blank" >
                Vulkan Barriers Explained
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://gpuopen.com/learn/developing-vulkan-apps/" 
				class="external-link" 
				target="_blank" >
                Vulkan AMD Blog Posts
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/" 
				class="external-link" 
				target="_blank" >
                Writing an Efficient Vulkan Renderer
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="playlists" >
    Playlists
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.youtube.com/watch?v=j7e73AkmFUI&list=PLI3kBEQ3yd-D4CmRqdFoNii4z62t3vK6G&index=2" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan with Odin - Nadako
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Vulkan 1.3, with Dynamic Rendering.
				</p>
			</li>
			<li>
				<p>
                    I watched videos 1 through 11.
				</p>
			</li>
			<li>
				<p>
                    They are good videos.
				</p>
			</li>
			<li>
				<p>
                    I do not recommend them to someone who has never seen anything before, because they are not exactly for beginners and their explanations lack some foundation.
				</p>
			</li>
			<li>
				<p>
                    I recommend them as a reference for how to set up in Odin.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=EsEP9iJKBhU&list=PLA0dXqQjCx0RntJy1pqje9uHRF1Z5vZgA" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan - OGLDEV
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    C++, with Visual Studio.
				</p>
			</li>
			<li>
				<p>
                    Assumes you have seen another GPU API before.
				</p>
			</li>
			<li>
				<p>
                    Video 1:
				</p>
				<ul>
					<li>
						<p>
                            Window with GLFW, not explained.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 8:
				</p>
				<ul>
					<li>
						<p>
                            Theory explanation ok; code explanation meh.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 12:
				</p>
				<ul>
					<li>
						<p>
                            Synchronization with 1 frame in-flight.
						</p>
					</li>
					<li>
						<p>
                            Good video.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Video 16</s>:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor Sets.
						</p>
					</li>
					<li>
						<p>
                            Nope. See the spec, guides, or other videos on the subject, I think it's better.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 21:
				</p>
				<ul>
					<li>
						<p>
                            Dynamic Rendering.
						</p>
					</li>
					<li>
						<p>
                            {0:00 -&gt; 12:14}
						</p>
						<ul>
							<li>
								<p>
                                    Explanation of the code to obtain the EXT for Vulkan 1.2, and ignore it for Vulkan 1.3
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The rest of the video is irrelevant, it does not explain anything beyond what to change if someone is following his code line by line.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/watch?v=Est5AvResbE&list=PLn3eTxaOtL2Nr89hYzKPib7tvce-ZO4yB" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan 2024 - GetIntoGameDev
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Overall
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The person seems nice and I like when he draws things.
						</p>
					</li>
					<li>
						<p>
                            Unfortunately 95% of the series videos are code in C++ and he does not do a good job explaining the code.
						</p>
					</li>
					<li>
						<p>
                            I listed some videos below that I considered interesting.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Vulkan 1.3.
				</p>
			</li>
			<li>
				<p>
                    Video 12:
				</p>
				<ul>
					<li>
						<p>
                            Synchronization, with 1 frame in-flight.
						</p>
					</li>
					<li>
						<p>
                            The drawings are nice.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~Video 13:
				</p>
				<ul>
					<li>
						<p>
                            Multithreaded rendering.
						</p>
					</li>
					<li>
						<p>
                            Nope. See the Multithreading Rendering section to understand why &quot;nope&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Video 26:
				</p>
				<ul>
					<li>
						<p>
                            Barycentric coordinates.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Only code, so nope
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Videos: 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<a
						href="https://www.youtube.com/watch?v=2NVlG9TFT1c&list=PLn3eTxaOtL2NH5nbPHMK7gE07SqhcAjmk&index=3" 
						class="external-link" 
						target="_blank" >
                        Playlist Vulkan - GetIntoGameDev
					</a>
                    </s>.
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.2, (2022-01-22).
						</p>
					</li>
					<li>
						<p>
                            Watch the new 2024 version of the tutorials.
						</p>
					</li>
					<li>
						<p>
                            The person sometimes explains on a sheet of paper, which is nice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/watch?v=tLwbj9qys18&list=PLmIqTlJ6KsE1Jx5HV4sd2jOe3V1KMHHgn&index=1" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan - Computer Graphics at TU Wien
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Vulkan 1.2.
				</p>
			</li>
			<li>
				<p>
                    Video 1:
				</p>
				<ul>
					<li>
						<p>
                            SDK, Instances, extensions, physical devices, logical devices.
						</p>
					</li>
					<li>
						<p>
                            Ok.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 2:
				</p>
				<ul>
					<li>
						<p>
                            Presentation Modes, Swapchain.
						</p>
					</li>
					<li>
						<p>
                            {10:20 -&gt; 21:45}
						</p>
						<ul>
							<li>
								<p>
                                    Explanation of all Presentation Modes.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 3:
				</p>
				<ul>
					<li>
						<p>
                            Explanation of Buffers and Images.
						</p>
					</li>
					<li>
						<p>
                            The explanation seemed s a bit rushed and the definition is poorly established.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            I can return and rewatch the video after reading the documentation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 4:
				</p>
				<ul>
					<li>
						<p>
                            Commands, Command Pools, Command Buffers.
						</p>
					</li>
					<li>
						<p>
                            Ok, sure.
						</p>
					</li>
					<li>
						<p>
                            I skipped the descriptor sets part.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 5:
				</p>
				<ul>
					<li>
						<p>
                            Pipelines.
						</p>
					</li>
					<li>
						<p>
                            I skipped it.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 6:
				</p>
				<ul>
					<li>
						<p>
                            Synchronization.
						</p>
					</li>
					<li>
						<p>
                            Skipped.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I don't like the illustrations, nor the tone of the explanation.
						</p>
					</li>
					<li>
						<p>
                            I simply feel I learn more and feel more confident reading the documentation or the spec.
						</p>
					</li>
					<li>
						<p>
                            The videos are &quot;more technical&quot;, but when that is the case documentation is better.
						</p>
					</li>
					<li>
						<p>
                            I prefer a simpler playlist to learn some basic concepts, and to read the documentation for advanced topics.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/@BrendanGalea/videos" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan - Brendan Galea
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Vulkan 1.0.
				</p>
			</li>
			<li>
				<p>
                    C++, with Visual Studio.
				</p>
			</li>
			<li>
				<p>
                    It's a pain to see C++ code.
				</p>
			</li>
			<li>
				<p>
                    The sketch explanations in the middle of the videos are ok, but the rest is very bad; all code-related parts are unpleasant and with a LOT of mess in C++.
				</p>
			</li>
			<li>
				<p>
                    Video 1:
				</p>
				<ul>
					<li>
						<p>
                            Window with GLFW.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 2:
				</p>
				<ul>
					<li>
						<p>
                            Light explanation of the graphics pipeline.
						</p>
					</li>
					<li>
						<p>
                            {9:54}
						</p>
						<ul>
							<li>
								<p>
                                    Shader compilation, to SPIR-V.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 20:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor Sets
						</p>
					</li>
					<li>
						<p>
                            {0:00 -&gt; 5:35} Nice explanation.
						</p>
					</li>
					<li>
						<p>
                            The rest of the video is nah.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=PDPRhlh44TU&list=PLFAIgTeqcARkeHm-RimFyKET6IZPxlBSt&index=1&pp=iAQB" 
				class="external-link" 
				target="_blank" >
                Vulkan playlist - Cakez
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    C++
				</p>
			</li>
			<li>
				<p>
                    Starts by teaching how to install Visual Studio and Git...
				</p>
			</li>
			<li>
				<p>
                    Does not use GLFW, instead creates its own platform layer on Windows to create a window.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=vURfULK5wH4&list=PLS1lqxOwNjOYcAkRHQRpGCwQvJMMRNyOG&index=1&pp=iAQB" 
				class="external-link" 
				target="_blank" >
                Vulkan playlist - Francesco Piscani
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    He uses the vulkan-tutorial.
				</p>
			</li>
			<li>
				<p>
                    Spends the first 4 episodes doing basically nothing, just setting up CMake and Linux.
				</p>
			</li>
			<li>
				<p>
                    Nope, it sounds bad as tutorials.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="talks" >
    Talks
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=p4iZMbXZbW8" 
				class="external-link" 
				target="_blank" >
                Vulkan in Doom 3
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Use RenderDoc extensively.
				</p>
			</li>
			<li>
				<p>
                    1 Render Pass, 1 subpass, 3 attachments.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250506145949.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Buffers and Images
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250506150028.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations:
				</p>
				<ul>
					<li>
						<p>
                            VMA for allocators.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250506150330.png" width="275" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250506150344.png" width="275" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    28 shaders + changes =&gt; 100 pipelines total at runtime.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250810104501.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Synchronization:
				</p>
				<ul>
					<li>
						<p>
                            Not much of it. Doom 3 was single-threaded, it didn't require multithreading.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="samples" >
    Samples
</h2>
<ul>
	<li>
		<p>
			<strong>
                To run
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Git clone recursively the repo.
				</p>
			</li>
			<li>
				<p>
                    Build the entire solution.
				</p>
			</li>
			<li>
				<p>
                    <code>Vulkan-Samples\build\windows\app\bin\debug\AMD64</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Copy the 
                    <code>shaders</code>
                    &nbsp;and 
                    <code>assets</code>
                    &nbsp;folders from 
                    <code>Vulkan-Samples</code>
                    &nbsp;to the folder above.
				</p>
			</li>
			<li>
				<p>
                    Type 
                    <code>.\vulkan_samples sample sample_name</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Normal and hpp have the same performance; or whatever, it does not matter.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The extension samples were more visually &quot;uninteresting&quot;.
				</p>
			</li>
			<li>
				<p>
                    I saw all API samples, but I didn't see all Extensions.
				</p>
			</li>
			<li>
				<p>
                    There were still other folders besides these two, but I was lazy to check.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="api" >
    API
</h3>
<ul>
	<li>
		<p>
            instancing
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804091417.png" width="375" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Wow, awesome.
				</p>
			</li>
			<li>
				<p>
                    The fps is very high.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            oit_linked_lists (Order Independent Transparency)
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804091728.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            oit_depth_peeling (Order Independent Transparency)
		</p>
		<ul>
			<li>
				<p>
                    The object in the center rotates with the mouse.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250804091553.png" width="550" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            compute_nbody
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090637.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_uniform_buffers.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090448.png" width="425" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            hdr
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090853.png" width="325" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows changing the object, toggling the skybox, changing the exposure, toggling bloom.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            terrain_tessellation
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092025.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Increasing the tessellation factor made it look like the terrain polycount increased.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            timestamp_queries
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092759.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows changing the object, toggling the skybox, changing the exposure, toggling bloom.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            separate_image_sampler
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804091834.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows selecting linear or nearest filtering.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            texture_loading
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092338.png" width="425" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows increasing the LOD bias, reducing image quality.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            texture_mipmap_generation
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092555.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows calibrating the LOD bias, and choosing between mipmap off, bilinear and anisotropic.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            hello_triangle_1_3 / hello_triangle
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090058.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Nothing special
				</p>
			</li>
			<li>
				<p>
                    No dynamic resize.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="extensions" >
    Extensions
</h3>
<ul>
	<li>
		<p
			class="line-emphasis" >
			<input
				type="checkbox" 
				disabled=""
>
            dynamic_line_rasterization
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250908185944.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This sample demonstrates functions from various extensions related to dynamic line rasterization.
				</p>
			</li>
			<li>
				<p>
                    These functions can be useful for developing CAD applications.
				</p>
			</li>
			<li>
				<p>
                    From the 
                    <code>EXT_line_rasterization</code>
                    &nbsp;extension.
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetLineStippleEXT</code>
                            &nbsp;- sets the stipple pattern.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    From the 
                    <code>EXT_extended_dynamic_state3</code>
                    &nbsp;extension:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetPolygonModeEXT</code>
                            &nbsp;- sets how defined primitives should be rasterized.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetLineRasterizationModeEXT</code>
                            &nbsp;- sets the algorithm for line rasterization.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetLineStippleEnableEXT</code>
                            &nbsp;- toggles stippling for lines.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    And also from core Vulkan:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetLineWidth</code>
                            &nbsp;- sets the line width.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetPrimitiveTopologyEXT</code>
                            &nbsp;- defines which type of primitives is being drawn.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            debug utils
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093636.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Toggle bloom, toggle skybox.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>EXT_debug_utils</code>
                    &nbsp;extension to setup a validation layer messenger callback and pass additional debugging information to debuggers like RenderDoc.
				</p>
			</li>
			<li>
				<p>
                    <code>EXT_debug_utils</code>
                    &nbsp;has been introduced based on feedback for the initial Vulkan debugging extensions 
                    <code>EXT_debug_report</code>
                    &nbsp;and 
                    <code>EXT_debug_marker</code>
                    , combining these into a single instance extension with some added functionality.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Procedure examples
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdBeginDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdInsertDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdEndDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkQueueBeginDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkQueueInsertDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkQueueEndDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkSetDebugUtilsObjectNameEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkSetDebugUtilsObjectTagEXT</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            conditional_rendering
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093352.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    A list of 235 parts of the car, which can be disabled to not render.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>EXT_conditional_rendering</code>
                    &nbsp;extension allows the execution of rendering commands to be conditional based on a value taken from a dedicated conditional buffer.
				</p>
			</li>
			<li>
				<p>
                    This may help an application reduce latency by conditionally discarding rendering commands without application intervention.
				</p>
			</li>
			<li>
				<p>
                    This sample demonstrates usage of this extension for conditionally toggling the visibility of sub-meshes of a complex glTF model.
				</p>
			</li>
			<li>
				<p>
                    Instead of having to update command buffers, this is done by updating the aforementioned buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            conservative_rasterization
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093524.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Enabling the conservative rasterization option causes this blending effect.
				</p>
			</li>
			<li>
				<p>
                    <code>EXT_conservative_rasterization</code>
                    &nbsp;changes the way fragments are generated.
				</p>
			</li>
			<li>
				<p>
                    Enables overestimation to generate fragments for every pixel 
					<em>
                        touched
					</em>
                    &nbsp;instead of only pixels that are fully covered.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            color_write_enable
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093158.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Color picker to change the background color.
				</p>
			</li>
			<li>
				<p>
                    Some options for &quot;bit&quot;, changing the triangle color.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>EXT_color_write_enable</code>
                    &nbsp;extension allows toggling the output color attachments using a pipeline dynamic state.
				</p>
			</li>
			<li>
				<p>
                    It allows the program to prepare an additional framebuffer populated with the data from a defined color blend attachment which can be blended dynamically to the final scene.
				</p>
			</li>
			<li>
				<p>
                    The final results are comparable to those obtained with 
                    <code>vkCmdSetColorWriteMaskEXT</code>
                    , but it does not require the GPU driver to support 
                    <code>EXT_extended_dynamic_state3</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_blending
		</p>
		<ul>
			<li>
                <img src="assets/image_20250804094024.png" width="500" >

			</li>
			<li>
				<p>
                    This sample demonstrates the functionality of 
                    <code>EXT_extended_dynamic_state3</code>
                    &nbsp;related to blending.
				</p>
			</li>
			<li>
				<p>
                    It includes the following features:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetColorBlendEnableEXT</code>
                            : toggles blending on and off.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetColorBlendEquationEXT</code>
                            : modifies blending operators and factors.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetColorBlendAdvancedEXT</code>
                            : utilizes more complex blending operators.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetColorWriteMaskEXT</code>
                            : toggles individual channels on and off.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            descriptor_indexing
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093822.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~descriptor_buffer_basic
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093739.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Just boxes rotating, I didn't understand.
				</p>
			</li>
			<li>
				<p>
                    Just textures rotating, I didn't understand.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_multisample_rasterization
		</p>
		<ul>
			<li>
				<p>
                    This sample demonstrates one of the functionalities of 
                    <code>EXT_extended_dynamic_state3</code>
                    &nbsp;related to rasterization samples.
				</p>
			</li>
			<li>
				<p>
                    The extension can be used to dynamically change sampling without the need to swap pipelines.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250908190252.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This thing took quite a while to open, generating binary files, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_primitive_clipping
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250908190422.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This sample demonstrates how to apply 
					<em>
                        depth clipping
					</em>
                    &nbsp;using the 
                    <code>vkCmdSetDepthClipEnableEXT()</code>
                    &nbsp;command which is a part of the 
                    <code>EXT_extended_dynamic_state3</code>
                    &nbsp;extension.
				</p>
			</li>
			<li>
				<p>
                    Additionally it also shows how to apply 
					<em>
                        primitive clipping
					</em>
                    &nbsp;using the 
                    <code>gl_ClipDistance[]</code>
                    &nbsp;builtin shader variable.
				</p>
			</li>
			<li>
				<p>
                    It is worth noting that 
					<em>
                        primitive clipping
					</em>
                    &nbsp;and 
					<em>
                        depth clipping
					</em>
                    &nbsp;are two separate features of the fixed-function vertex post-processing stage.
				</p>
			</li>
			<li>
				<p>
                    They're both described in the same chapter of the Vulkan specification (chapter 27.4, &quot;Primitive clipping&quot;).
				</p>
			</li>
			<li>
				<p>
                    What is primitive clipping
				</p>
				<ul>
					<li>
						<p>
                            Primitives produced by vertex/geometry/tessellation shaders are sent to fixed-function vertex post-processing.
						</p>
					</li>
					<li>
						<p>
                            Primitive clipping is a part of post-processing pipeline in which primitives such as points/lines/triangles are culled against the cull volume and then clipped to the clip volume.
						</p>
					</li>
					<li>
						<p>
                            And then they might be further clipped by results stored in the 
                            <code>gl_ClipDistance[]</code>
                            &nbsp;array - values in this array must be calculated in a vertex/geometry/tessellation shader.
						</p>
					</li>
					<li>
						<p>
                            In the past, the fixed-function version of the OpenGL API provided a method to specify parameters for up to 6 clipping planes (half-spaces) that could perform additional primitive clipping. Fixed-function hardware calculated proper distances to these planes and made a decision - should the primitive be clipped against these planes or not (for historical study - search for the 
                            <code>glClipPlane()</code>
                            &nbsp;description).
						</p>
					</li>
					<li>
						<p>
                            Vulkan inherited the idea of primitive clipping, but with one important difference: the user has to calculate the distance to the clip planes on their own in the vertex shader.
						</p>
					</li>
					<li>
						<p>
                            And - because the user does it in a shader - they do not have to use clip planes at all. It can be any kind of calculation, as long as the results are put in the 
                            <code>gl_ClipDistance[]</code>
                            &nbsp;array.
						</p>
					</li>
					<li>
						<p>
                            Values that are less than 0.0 cause the vertex to be clipped. In the case of a triangle primitive the whole triangle is clipped if all of its vertices have values stored in 
                            <code>gl_ClipDistance[]</code>
                            &nbsp;below 0.0. When some of these values are above 0.0 - the triangle is split into new triangles as described in the Vulkan specification.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    What is depth clipping
				</p>
				<ul>
					<li>
						<p>
                            When depth clipping is disabled then effectively there is no near or far plane clipping.
						</p>
					</li>
					<li>
						<p>
                            Depth values of primitives that are behind the far plane are clamped to the far plane depth value (usually 1.0).
						</p>
					</li>
					<li>
						<p>
                            Depth values of primitives that are in front of the near plane are clamped to the near plane depth value (by default it's 0.0, but may be set to -1.0 if we use settings defined in 
                            <code>VkPipelineViewportDepthClipControlCreateInfoEXT</code>
                            &nbsp;structure. This requires the presence of the 
                            <code>EXT_depth_clip_control</code>
                            &nbsp;extension which is not part of this tutorial).
						</p>
					</li>
					<li>
						<p>
                            In this sample the result of depth clipping (or lack of it) is not clearly visible at first. Try to move the viewer position closer to the object and see how the &quot;use depth clipping&quot; checkbox changes object appearance.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~buffer_device_address.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093016.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    I didn't understand. It's just things moving.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~calibrated_timestamps
		</p>
		<ul>
			<li>
				<p>
                    timestamp_queries, but with other timings.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="core" >
    Core
</h2>
<h3
	id="instance-extensions" >
    Instance / Extensions
</h3>
<h5
	id="instance" >
    Instance
</h5>
<ul>
	<li>
		<p>
            <code>VkInstance</code>
		</p>
		<ul>
			<li>
				<p>
                    The Vulkan context, used to access drivers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The instance is the connection between your application and the Vulkan library.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkApplicationInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkApplicationInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Optional, but it may provide some useful information to the driver to optimize our specific application.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstanceCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>vkInstanceCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Tells the Vulkan driver which global extensions and validation layers we want to use.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="instance-level-extensions" >
    Instance Level Extensions
</h5>
<ul>
	<li>
		<p>
            <code>vkEnumerateInstanceExtensionProperties()</code>
		</p>
		<ul>
			<li>
				<p>
                    Retrieve a list of supported extensions before creating an instance.
				</p>
			</li>
			<li>
				<p>
                    Each 
                    <code>VkExtensionProperties</code>
                    &nbsp;struct contains the name and version of an extension.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="debugging" >
    Debugging
</h3>
<h5
	id="validation-layers" >
    Validation Layers
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/layers.html" 
				class="external-link" 
				target="_blank" >
                Layers
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Vulkan is designed for high performance and low driver overhead, therefore, it will include very limited error checking and debugging capabilities by default.
		</p>
	</li>
	<li>
		<p>
            The driver will often 
			<strong>
                crash
			</strong>
            &nbsp;instead of returning an error code if you do something wrong, or worse, it will appear to work on your graphics card and completely 
			<strong>
                fail
			</strong>
            &nbsp;on others.
		</p>
	</li>
	<li>
		<p>
            Vulkan allows you to enable extensive checks through a feature known as 
			<em>
                validation layers
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Validation layers are pieces of code that can be inserted between the API and the graphics driver to do things like running extra checks on function parameters and tracking memory management problems.
		</p>
	</li>
	<li>
		<p>
            The nice thing is that you can enable them during development and then completely disable them when releasing your application for zero overhead. Anyone can write their own validation layers, but the Vulkan SDK by LunarG provides a standard set of validation layers. You also need to register a callback function to receive debug messages from the layers.
		</p>
	</li>
	<li>
		<p>
            Because Vulkan is so explicit about every operation and the validation layers are so extensive, it can actually be a lot 
			<em>
                easier
			</em>
            &nbsp;to find out why your screen is black compared to OpenGL and Direct3D!
		</p>
	</li>
	<li>
		<p>
            Common operations in validation layers are:
		</p>
		<ul>
			<li>
				<p>
                    Checking the values of parameters against the specification to detect misuse
				</p>
			</li>
			<li>
				<p>
                    Tracking the creation and destruction of objects to find resource leaks
				</p>
			</li>
			<li>
				<p>
                    Checking thread safety by tracking the threads that calls originate from
				</p>
			</li>
			<li>
				<p>
                    Logging every call and its parameters to the standard output
				</p>
			</li>
			<li>
				<p>
                    Tracing Vulkan calls for profiling and replaying
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            There were formerly two different types of validation layers in Vulkan: 
			<em>
                instance
			</em>
            &nbsp;and 
			<em>
                device
			</em>
            &nbsp;specific.
		</p>
	</li>
	<li>
		<p>
            The idea was that instance layers would only check calls related to global Vulkan objects like instances, and device-specific layers would only check calls related to a specific GPU.
		</p>
	</li>
	<li>
		<p>
            Device-specific layers have now been 
			<strong>
                deprecated
			</strong>
            , which means that instance validation layers apply to all Vulkan calls.
		</p>
	</li>
	<li>
		<p>
            We don‚Äôt really need to check for the existence of this extension because it should be implied by the availability of the validation layers.
		</p>
	</li>
	<li>
		<p>
            <code>vkEnumerateInstanceLayerProperties</code>
		</p>
	</li>
	<li>
		<p>
			<strong>
                RenderDoc
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Do not run validation at the same time as RenderDoc, otherwise you'll also be validating RenderDoc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Vulkan Configurator
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Overwrites the normal Layer setup.
				</p>
			</li>
			<li>
				<p>
                    Implicitly loads layers.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        How to use
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            RIGHT-CLICK.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Performance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Ensure validation layers and debug callbacks are off for performance runs. Use pipeline cache objects to avoid repeated pipeline creation cost.
				</p>
			</li>
			<li>
				<p>
                    I notice how each 'push', 'descriptor set bind', 'vertex bind', 'indices bind' and 'draw' were a lot slower with validations on.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="message-callback" >
    Message Callback
</h5>
<ul>
	<li>
		<p>
            The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program.
		</p>
	</li>
	<li>
		<p>
            This will also allow you to decide which kind of messages you would like to see.
		</p>
	</li>
	<li>
		<p>
            <code>messageSeverity</code>
		</p>
	</li>
	<li>
		<p>
            <code>messageType</code>
		</p>
	</li>
	<li>
		<p>
            <code>pfnUserCallback</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>messageSeverity</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Diagnostic message
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>DEBUG_UTILS_MESSAGE_SEVERITY_INFO_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Informational message like the creation of a resource
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Message about behavior that is not necessarily an error, but very likely a bug in your application
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Message about behavior that is invalid and may cause crashes.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>messageType</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>DEBUG_UTILS_MESSAGE_TYPE_GENERAL_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Some event has happened that is unrelated to the specification or performance
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Something has happened that violates the specification or indicates a possible mistake
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Potential non-optimal use of Vulkan
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCallbackData</code>
				</p>
				<ul>
					<li>
						<p>
                            Refers to a 
                            <code>VkDebugUtilsMessengerCallbackDataEXT</code>
                            &nbsp;struct containing the details of the message itself, with the most important members being:
						</p>
					</li>
					<li>
						<p>
                            <code>pMessage</code>
						</p>
						<ul>
							<li>
								<p>
                                    The debug message as a null-terminated string
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pObjects</code>
						</p>
						<ul>
							<li>
								<p>
                                    Array of Vulkan object handles related to the message
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>objectCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Number of objects in the array
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pUserData</code>
				</p>
				<ul>
					<li>
						<p>
                            Contains a pointer specified during the setup of the callback and allows you to pass your own data to it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="debug-utils-codevk_ext_debug_utils-code" >
    Debug Utils (
    <code>VK_EXT_debug_utils</code>
    )
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/debug_utils/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">must(
&nbsp;&nbsp;&nbsp;&nbsp;vk.SetDebugUtilsObjectNameEXT(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dev,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&vk.DebugUtilsObjectNameInfoEXT {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sType = .DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objectType = obj,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objectHandle = handle,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pObjectName = strings.clone_to_cstring(name, context.temp_allocator),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;),
)
</code></pre>
<h3
	id="window-surface-glfw" >
    Window / Surface / GLFW
</h3>
<h5
	id="window" >
    Window
</h5>
<ul>
	<li>
		<p>
            The Vulkan API itself is completely platform-agnostic, which is why we need to use the standardized WSI (Window System Interface) extension to interact with the window manager.
		</p>
	</li>
	<li>
		<p>
            Windows can be created with the native platform APIs or libraries like 
			<a
				href="https://www.glfw.org/" 
				class="external-link" 
				target="_blank" >
                GLFW
			</a>
            &nbsp;and 
			<a
				href="https://www.libsdl.org/" 
				class="external-link" 
				target="_blank" >
                SDL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Some platforms allow you to render directly to a display without interacting with any window manager through the 
            <code>KHR_display</code>
            &nbsp;and 
            <code>KHR_display_swapchain</code>
            &nbsp;extensions.
		</p>
	</li>
	<li>
		<p>
            These allow you to create a surface that represents the entire screen and could be used to implement your own window manager, for example.
		</p>
	</li>
</ul>
<h5
	id="glfw" >
    GLFW
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://www.glfw.org/docs/latest/topics.html" 
				class="external-link" 
				target="_blank" >
                GLFW Reference
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The very first call in 
            <code>initWindow</code>
            &nbsp;should be 
            <code>glfwInit()</code>
            , which initializes the GLFW library. Because GLFW was originally designed to create an OpenGL context, we need to tell it to not create an OpenGL context with a later call:
		</p>
	</li>
	<li>
		<p>
            Because handling resized windows takes special care that we‚Äôll look into later, disable it for now with another window hint call:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
</code></pre>
<ul>
	<li>
		<p>
            All that‚Äôs left now is creating the actual window. Add a 
            <code>GLFWwindow* window;</code>
            &nbsp;private class member to store a reference to it and initialize the window with:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
</code></pre>
<ul>
	<li>
		<p>
            The first three parameters specify the width, height and title of the window. The fourth parameter allows you to optionally specify a monitor to open the window on, and the last parameter is only relevant to OpenGL.
		</p>
	</li>
	<li>
		<p>
            Init:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">void initWindow() {
&nbsp;&nbsp;&nbsp;&nbsp;glfwInit();

&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

&nbsp;&nbsp;&nbsp;&nbsp;window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
}
</code></pre>
<ul>
	<li>
		<p>
            Main loop:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">void mainLoop() {
&nbsp;&nbsp;&nbsp;&nbsp;while (!glfwWindowShouldClose(window)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfwPollEvents();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Destroy:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">void cleanup() {
&nbsp;&nbsp;&nbsp;&nbsp;glfwDestroyWindow(window);

&nbsp;&nbsp;&nbsp;&nbsp;glfwTerminate();
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Blocking the Thread
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.glfw.org/docs/3.3/group__window.html#ga37bd57223967b4211d60ca1a0bf3c832" 
						class="external-link" 
						target="_blank" >
                        glfw.PollEvents
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.glfw.org/docs/3.3/group__window.html#ga1c5c7eb889c33c7f4d10dd35b327654e" 
						class="external-link" 
						target="_blank" >
                        glfw.SetWindowRefreshCallback
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/glfw/glfw/pull/1426" 
						class="external-link" 
						target="_blank" >
                        PR to improve this
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="surface" >
    Surface
</h5>
<ul>
	<li>
		<p>
            A 
            <code>VkSurfaceKHR</code>
            &nbsp;is an opaque handle representing a platform-specific presentation target (for example, a window on Windows, an X11 window on Linux, or a UIView on iOS). It is created directly from the Vulkan instance together with a native window handle. Conceptually, a surface is:
		</p>
		<ul>
			<li>
				<p>
                    Instance-level: it lives above any physical or logical device.
				</p>
			</li>
			<li>
				<p>
                    Window abstraction: it wraps the OS window or drawable so that Vulkan knows where to submit images for display.
				</p>
			</li>
			<li>
				<p>
                    Device-agnostic: you can create a surface before choosing which GPU you will use.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Once created, the surface is used by a chosen physical device to query presentation support, formats and capabilities, and then by the logical device to build a Swapchain.
		</p>
	</li>
	<li>
		<p>
            A surface itself is not intrinsically tied to any particular physical or logical device, because:
		</p>
		<ul>
			<li>
				<p>
                    Creation: you call 
                    <code>vkCreateSurfaceKHR(instance, ‚Ä¶)</code>
                    &nbsp;without involving a 
                    <code>VkPhysicalDevice</code>
                    &nbsp;or 
                    <code>VkDevice</code>
                    &nbsp;handle.
				</p>
			</li>
			<li>
				<p>
                    Lifetime: it exists even before you pick or create a device, and you destroy it with 
                    <code>vkDestroySurfaceKHR(instance, surface, ‚Ä¶)</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lifetime
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The surface is tied to the GLFW window's lifecycle.
				</p>
			</li>
			<li>
				<p>
                    It 
					<em>
                        does not change
					</em>
                    &nbsp;when the window is resized, minimized, or restored.
				</p>
			</li>
			<li>
				<p>
                    The same surface handle remains valid until you destroy it (e.g., when closing the window).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;Window surfaces are part of the larger topic of render targets and presentation&quot;.
		</p>
	</li>
	<li>
		<p>
			<a
				href="http://vulkan2.gpuinfo.org/listsurfaceformats.php?platform=windows" 
				class="external-link" 
				target="_blank" >
                Surface Formats
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="extensions" >
    Extensions
</h5>
<ul>
	<li>
		<p>
            To establish the connection between Vulkan and the window system to present results to the screen, we need to use the WSI (Window System Integration) extensions.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>KHR_surface</code>
            &nbsp;exposes a 
            <code>VkSurfaceKHR</code>
            &nbsp;object that represents an abstract type of surface to present rendered images to.
		</p>
	</li>
	<li>
		<p>
            The surface in our program will be backed by the window that we‚Äôve already opened with GLFW.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>KHR_surface</code>
            &nbsp;extension is an instance level extension, and we‚Äôve actually already enabled it, because it‚Äôs included in the list returned by 
            <code>glfwGetRequiredInstanceExtensions</code>
            . The list also includes some other WSI extensions that we‚Äôll use in the next couple of chapters.
		</p>
	</li>
	<li>
		<p>
            The window surface needs to be created right 
			<strong>
                after
			</strong>
            &nbsp;the instance creation, because it can actually influence the physical device selection.
		</p>
	</li>
	<li>
		<p>
            It should also be noted that window surfaces are an entirely optional component in Vulkan if you just need off-screen rendering.
		</p>
		<ul>
			<li>
				<p>
                    Vulkan allows you to do that without hacks like creating an invisible window (necessary for OpenGL).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Vulkan also allows you to remotely render from a non-presenting GPU or remotely over the internet, or run compute acceleration for AI without a render or presentation target.
		</p>
	</li>
	<li>
		<p>
            Although the 
            <code>VkSurfaceKHR</code>
            &nbsp;object and its usage is platform-agnostic, its creation isn‚Äôt because it depends on window system details. For example, it needs the 
            <code>HWND</code>
            &nbsp;and 
            <code>HMODULE</code>
            &nbsp;handles on Windows. Therefore, there is a platform-specific addition to the extension, which on Windows is called 
            <code>KHR_win32_surface</code>
            &nbsp;and is also automatically included in the list from 
            <code>glfwGetRequiredInstanceExtensions</code>
            .
		</p>
	</li>
	<li>
		<p>
            GLFW actually has 
            <code>glfwCreateWindowSurface</code>
            &nbsp;that handles the platform differences for us.
		</p>
	</li>
</ul>
<h5
	id="blocking-the-thread" >
    Blocking the thread
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://stackoverflow.com/questions/45880238/how-to-draw-while-resizing-glfw-window" 
				class="external-link" 
				target="_blank" >
                Difficulties due to GLFW
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A callback 
            <code>glfw.SetWindowRefreshCallback</code>
            &nbsp;allows the swapchain to be recreated while resizing.
		</p>
		<ul>
			<li>
				<p>
                    See [[#Swapchain Recreation]].
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="physical-device-logical-device" >
    Physical Device / Logical Device
</h3>
<h5
	id="physical-device" >
    Physical Device
</h5>
<ul>
	<li>
		<p>
            <code>VkPhysicalDevice</code>
		</p>
	</li>
	<li>
		<p>
            A GPU. Used to query physical GPU details, like features, capabilities, memory size, etc.
		</p>
	</li>
</ul>
<h5
	id="device-level-extensions" >
    Device Level Extensions
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://vulkan.gpuinfo.org/" 
				class="external-link" 
				target="_blank" >
                Vulkan Hardware Database
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="queue-families" >
    Queue Families
</h5>
<ul>
	<li>
		<p>
            Most operations performed with Vulkan, like draw commands and memory operations, are asynchronously executed by submitting them to a 
            <code>VkQueue</code>
            .
		</p>
	</li>
	<li>
		<p>
            Queues are allocated from queue families, where each queue family supports a specific set of operations in its queues.
		</p>
		<ul>
			<li>
				<p>
                    For example, there could be separate queue families for graphics, compute and memory transfer operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The availability of queue families could also be used as a distinguishing factor in physical device selection.
		</p>
		<ul>
			<li>
				<p>
                    It is possible for a device with Vulkan support to not offer any graphics functionality; however, all graphics cards with Vulkan support today will generally support all queue operations that we‚Äôre interested in.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We need to check which queue families are supported by the device and which one of these supports the commands that we want to use.
		</p>
	</li>
</ul>
<h5
	id="presentation-support" >
    Presentation support
</h5>
<ul>
	<li>
		<p>
            Although the Vulkan implementation may support window system integration, that does not mean that every device in the system supports it. Therefore, we need to extend 
            <code>createLogicalDevice</code>
            &nbsp;to ensure that a device can present images to the surface we created.
		</p>
	</li>
	<li>
		<p>
            Since the presentation is a queue-specific feature, the problem is actually about finding a queue family that supports presenting to the surface we created.
		</p>
	</li>
	<li>
		<p>
            It‚Äôs actually possible that the queue families supporting 
			<strong>
                drawing
			</strong>
            &nbsp;commands and the queue families supporting 
			<strong>
                presentation
			</strong>
            &nbsp;do 
			<em>
                not
			</em>
            &nbsp;overlap.
		</p>
		<ul>
			<li>
				<p>
                    It‚Äôs very likely that these end up being the same queue family after all, but throughout the program we will treat them as if they were separate queues for a uniform approach.
				</p>
			</li>
			<li>
				<p>
                    Nevertheless, you could add logic to explicitly prefer a physical device that supports drawing and presentation in the same queue for 
					<em>
                        improved
					</em>
                    &nbsp;performance.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Therefore, we have to take into account that there could be a distinct presentation queue.
		</p>
	</li>
	<li>
		<p>
            We‚Äôll look for a queue family that has the capability of presenting to our window surface. The function to check for that is 
            <code>vkGetPhysicalDeviceSurfaceSupportKHR</code>
            , which takes the physical device, queue family index and surface as parameters.
		</p>
	</li>
	<li>
		<p>
            It should be noted that the availability of a presentation queue, as we checked in the previous chapter, implies that the Swapchain extension must be supported. However, the extension does have to be 
			<em>
                explicitly
			</em>
            &nbsp;enabled.
		</p>
	</li>
	<li>
		<p>
            Not all graphics cards are capable of presenting images directly to a screen for various reasons, for example, because they are designed for servers and don‚Äôt have any display outputs. Secondly, since image presentation is heavily tied into the window system and the surfaces associated with windows, it is not part of the Vulkan core. You have to enable the 
            <code>KHR_swapchain</code>
            &nbsp;device extension after querying for its support.
		</p>
	</li>
</ul>
<h5
	id="surface-capabilities" >
    Surface Capabilities
</h5>
<ul>
	<li>
		<p>
            The extents can change when resizing and you should requery the surface properties. Note that if it says the current extent is 
            <code>{UINT32_MAX, UINT32_MAX}</code>
            &nbsp;(happens on some platforms) then you'll need to ask the windowing system for an appropriate new size (but I don't know GLFW well enough to know if 
            <code>GetFramebufferSize</code>
            &nbsp;is the right function for that purpose)
		</p>
	</li>
</ul>
<h5
	id="logical-device" >
    Logical Device
</h5>
<ul>
	<li>
		<p>
            <code>VkDevice</code>
		</p>
	</li>
	<li>
		<p>
            The ‚Äúlogical‚Äù GPU context that you actually execute things on.
		</p>
	</li>
	<li>
		<p>
            Where you describe more specifically which VkPhysicalDeviceFeatures you will be using, like multi viewport rendering and 64-bit floats.
		</p>
	</li>
	<li>
		<p>
            You also need to specify which queue families you would like to use.
		</p>
	</li>
</ul>
<h5
	id="queues" >
    Queues
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/queues.html" 
				class="external-link" 
				target="_blank" >
                Queues
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>VkQueue</code>
		</p>
		<ul>
			<li>
				<p>
                    Execution ‚Äúport‚Äù for commands.
				</p>
			</li>
			<li>
				<p>
                    GPUs will have a set of queues with different properties.
				</p>
				<ul>
					<li>
						<p>
                            Some allow only graphics commands, others only allow memory commands, etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Command buffers are executed by submitting them into a queue, which will copy the rendering commands onto the GPU for execution.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The queues are automatically created along with the logical device, but we don‚Äôt have a handle to interface with them yet.
		</p>
	</li>
	<li>
		<p>
            Device queues are implicitly cleaned up when the device is destroyed.
		</p>
	</li>
	<li>
		<p>
            We can use the 
            <code>vkGetDeviceQueue</code>
            &nbsp;function to retrieve queue handles for each queue family. The parameters are the logical device, queue family, queue index and a pointer to the variable to store the queue handle in. Because we‚Äôre only creating a single queue from this family, we‚Äôll simply use index 
            <code>0</code>
            .
		</p>
	</li>
	<li>
		<p>
            Vulkan Guide:
		</p>
		<ul>
			<li>
				<p>
                    It is common to see engines using 3 queue families:
				</p>
				<ul>
					<li>
						<p>
                            One for drawing the frame, other for async compute, and other for data transfer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In this tutorial, we use a single queue that will run all our commands for simplicity.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="multi-queue" >
    Multi-queue
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250731212143.png" width="425" >
            .
		</p>
	</li>
	<li>
		<p>
            Some hardware only has one queue.
		</p>
	</li>
</ul>
<h2
	id="render-loop" >
    Render Loop
</h2>
<ul>
	<li>
		<p>
            Now that everything is ready for rendering, you first ask the 
            <code>VkSwapchainKHR</code>
            &nbsp;for an image to render to. Then you allocate a 
            <code>VkCommandBuffer</code>
            &nbsp;from a 
            <code>VkCommandBufferPool</code>
            &nbsp;or reuse an already allocated command buffer that has finished execution, and ‚Äústart‚Äù the command buffer, which allows you to write commands into it.
		</p>
	</li>
	<li>
		<p>
            Next, you begin rendering by using Dynamic Rendering.
		</p>
	</li>
	<li>
		<p>
            Then create a loop where you bind a 
            <code>VkPipeline</code>
            , bind some 
            <code>VkDescriptorSet</code>
            &nbsp;resources (for the shader parameters), bind the vertex buffers, and then execute a draw call.
		</p>
	</li>
	<li>
		<p>
            If there is nothing more to render, you end the 
            <code>VkCommandBuffer</code>
            . Finally, you submit the command buffer into the queue for rendering. This will begin execution of the commands in the command buffer on the gpu. If you want to display the result of the rendering, you ‚Äúpresent‚Äù the image you have rendered to to the screen. Because the execution may not have finished yet, you use a semaphore to make the presentation of the image to the screen wait until rendering is finished.
		</p>
	</li>
	<li>
		<p>
            At a high level, rendering a frame in Vulkan consists of a common set of steps:
		</p>
		<ul>
			<li>
				<p>
                    Wait for the previous frame to finish
				</p>
			</li>
			<li>
				<p>
                    Acquire an image from the Swapchain
				</p>
			</li>
			<li>
				<p>
                    Record a command buffer which draws the scene onto that image
				</p>
				<ul>
					<li>
						<p>
                            Re-recording every frame doesn't really take up performance.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Submit the recorded command buffer
				</p>
				<ul>
					<li>
						<p>
                            Takes performance.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Present the Swapchain image
				</p>
				<ul>
					<li>
						<p>
                            Puts it up on the screen.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="swapchain" >
    Swapchain
</h3>
<ul>
	<li>
		<p>
            Vulkan does not have the concept of a &quot;default framebuffer,&quot; hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen.
		</p>
	</li>
	<li>
		<p>
            This infrastructure is known as the 
			<em>
                swapchain
			</em>
            &nbsp;and must be created explicitly in Vulkan.
		</p>
	</li>
	<li>
		<p>
            The Swapchain is essentially a queue of images that are waiting to be presented to the screen.
		</p>
	</li>
	<li>
		<p>
            Our application will acquire such an image to draw to it, and then return it to the queue.
		</p>
	</li>
	<li>
		<p>
            The conditions for presenting an image from the queue depend on how the Swapchain is set up.
		</p>
	</li>
	<li>
		<p>
            The general purpose of the Swapchain is to synchronize the presentation of images with the refresh rate of the screen.
		</p>
		<ul>
			<li>
				<p>
                    This is important to make sure that only complete images are shown.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Every time we want to draw a frame, we have to ask the Swapchain to provide us with an image to render to. When we‚Äôve finished drawing a frame, the image is returned to the Swapchain for it to be presented to the screen at some point.
		</p>
	</li>
	<li>
		<p>
            &quot;Is a collection of render targets&quot;.
		</p>
		<ul>
			<li>
				<p>
                    Render Targets is not a well-defined term.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The number of render targets and conditions for presenting finished images to the screen depends on the present mode.
		</p>
	</li>
	<li>
		<p>
            <code>VkSwapchainKHR</code>
		</p>
		<ul>
			<li>
				<p>
                    Holds the images for the screen.
				</p>
			</li>
			<li>
				<p>
                    It allows you to render things into a visible window.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>KHR</code>
                    &nbsp;suffix shows that it comes from an extension, which in this case is 
                    <code>KHR_swapchain</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=mvkHYAu7i6c" 
				class="external-link" 
				target="_blank" >
                Swapchains
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Good video.
				</p>
			</li>
			<li>
				<p>
                    Pre-rotate on mobile.
				</p>
			</li>
			<li>
				<p>
                    When to recreate, recreation problems, recreation strategies, maintenance.
				</p>
			</li>
			<li>
				<p>
                    Present modes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There are basically three kinds of properties we need to check:
				</p>
				<ul>
					<li>
						<p>
                            Basic surface capabilities (min/max number of images in Swapchain, min/max width and height of images)
						</p>
					</li>
					<li>
						<p>
                            Surface formats (pixel format, color space)
						</p>
					</li>
					<li>
						<p>
                            Available presentation modes
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It is important that we only try to query for Swapchain support after verifying that the extension is available.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="swapchain-creation" >
    Swapchain Creation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCreateInfoKHR.html" 
				class="external-link" 
				target="_blank" >
                <code>VkSwapchainCreateInfoKHR</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>surface</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with 
                            <code>surface</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>minImageCount</code>
				</p>
				<ul>
					<li>
						<p>
                            we also have to decide how many images we would like to have in the Swapchain. However, simply sticking to the minimum means that we may sometimes have to wait on the driver to complete internal operations before we can acquire another image to render to. Therefore, it is recommended to request at least one more image than the minimum:
						</p>
					</li>
				</ul>
<pre><code class="language-c" data-lang="c">uint32_t imageCount = surfaceCapabilities.minImageCount + 1;
</code></pre>
				<ul>
					<li>
						<p>
                            We should also make sure to not exceed the maximum number of images while doing this, where 
                            <code>0</code>
                            &nbsp;is a special value that means that there is 
							<strong>
                                no
							</strong>
                            &nbsp;maximum
						</p>
					</li>
				</ul>
<pre><code class="language-c" data-lang="c">if (surfaceCapabilities.maxImageCount &gt; 0 && imageCount &gt; surfaceCapabilities.maxImageCount) {
&nbsp;&nbsp;&nbsp;&nbsp;imageCount = surfaceCapabilities.maxImageCount;
}
</code></pre>
			</li>
			<li>
				<p>
                    <code>imageFormat</code>
				</p>
				<ul>
					<li>
						<p>
                            For the color space we‚Äôll use SRGB if it is available, because it 
							<a
								href="http://stackoverflow.com/questions/12524623/" 
								class="external-link" 
								target="_blank" >
                                results in more accurate perceived colors
							</a>
                            . It is also pretty much the standard color space for images, like the textures we‚Äôll use later on.
						</p>
					</li>
					<li>
						<p>
                            Because of that we should also use an SRGB color format, of which one of the most common ones is 
                            <code>FORMAT_B8G8R8A8_SRGB</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageColorSpace</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkColorSpaceKHR.html" 
								class="external-link" 
								target="_blank" >
                                VkColorSpaceKHR
							</a>
                            &nbsp;value specifying the way the swapchain interprets image data.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageExtent</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the size (in pixels) of the swapchain image(s).
						</p>
					</li>
					<li>
						<p>
                            The swap extent is the 
							<em>
                                resolution
							</em>
                            &nbsp;of the Swapchain images. It‚Äôs almost always exactly equal to the resolution of the window that we‚Äôre drawing to 
							<em>
                                in pixels
							</em>
                            .
						</p>
					</li>
					<li>
						<p>
                            The range of the possible resolutions is defined in the 
                            <code>VkSurfaceCapabilitiesKHR</code>
                            &nbsp;structure.
						</p>
					</li>
					<li>
						<p>
                            On some platforms, it is normal that 
                            <code>maxImageExtent</code>
                            &nbsp;
							<strong>
                                may
							</strong>
                            &nbsp;become 
                            <code>(0, 0)</code>
                            , for example when the window is minimized. In such a case, it is not possible to create a swapchain due to the Valid Usage requirements , unless scaling is selected through 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentScalingCreateInfoKHR.html" 
								class="external-link" 
								target="_blank" >
                                VkSwapchainPresentScalingCreateInfoKHR
							</a>
                            , if supported .
						</p>
					</li>
					<li>
						<p>
                            We‚Äôll pick the resolution that best matches the window within the 
                            <code>minImageExtent</code>
                            &nbsp;and 
                            <code>maxImageExtent</code>
                            &nbsp;bounds. But we must specify the resolution in the correct unit.
						</p>
					</li>
					<li>
						<p>
                            GLFW uses two units when measuring sizes: pixels and 
							<a
								href="https://www.glfw.org/docs/latest/intro_guide.html#coordinate_systems" 
								class="external-link" 
								target="_blank" >
                                screen coordinates
							</a>
                            . For example, the resolution 
                            <code>{WIDTH, HEIGHT}</code>
                            &nbsp;that we specified earlier when creating the window is measured in screen coordinates. But Vulkan works with pixels, so the Swapchain extent must be specified in pixels as well.
						</p>
					</li>
					<li>
						<p>
                            Unfortunately, if you are using a high DPI display (like Apple‚Äôs Retina display), screen coordinates don‚Äôt correspond to pixels. Instead, due to the higher pixel density, the resolution of the window in pixel will be larger than the resolution in screen coordinates. So if Vulkan doesn‚Äôt fix the swap extent for us, we can‚Äôt just use the original 
                            <code>{WIDTH, HEIGHT}</code>
                            . Instead, we must use 
                            <code>glfwGetFramebufferSize</code>
                            &nbsp;to query the resolution of the window in pixel before matching it against the minimum and maximum image extent.
						</p>
					</li>
					<li>
						<p>
                            The surface capabilities changes every time the window resizes, and it's only used for creating the Swapchain, so it doesn't make sense to cache.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageUsage</code>
				</p>
			</li>
			<li>
				<p>
                    <code>imageSharingMode</code>
                    &nbsp;(Handling multiple queues):
				</p>
				<ul>
					<li>
						<p>
                            We need to specify how to handle Swapchain images that will be used across multiple queue families. That will be the case in our application if the graphics queue family is different from the presentation queue. We‚Äôll be drawing on the images in the Swapchain from the graphics queue and then submitting them on the presentation queue. There are two ways to handle images that are accessed from multiple queues:
						</p>
						<ul>
							<li>
								<p>
                                    <code>SHARING_MODE_EXCLUSIVE</code>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            An image is owned by one queue family at a time, and ownership must be explicitly transferred before using it in another queue family.
										</p>
									</li>
									<li>
										<p>
                                            This option offers the 
											<strong>
                                                best
											</strong>
                                            &nbsp;performance.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>SHARING_MODE_CONCURRENT</code>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Images can be used across multiple queue families without explicit ownership transfers.
										</p>
									</li>
									<li>
										<p>
                                            Concurrent mode requires you to specify in advance between which queue families ownership will be shared using the 
                                            <code>queueFamilyIndexCount</code>
                                            &nbsp;and 
                                            <code>pQueueFamilyIndices</code>
                                            &nbsp;parameters.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If the queue families differ, then we‚Äôll be using the concurrent mode in this tutorial to avoid having to do the ownership chapters, because these involve some concepts that are better explained at a later time.
						</p>
					</li>
					<li>
						<p>
                            If the graphics queue family and presentation queue family are the same, which will be the case on most hardware, then we should stick to exclusive mode. Concurrent mode requires you to specify at least two distinct queue families.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>queueFamilyIndexCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of queue families having access to the image(s) of the swapchain when 
                            <code>imageSharingMode</code>
                            &nbsp;is 
                            <code>SHARING_MODE_CONCURRENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pQueueFamilyIndices</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of queue family indices having access to the images(s) of the swapchain when 
                            <code>imageSharingMode</code>
                            &nbsp;is 
                            <code>SHARING_MODE_CONCURRENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageArrayLayers</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of views in a multiview/stereo surface. For non-stereoscopic-3D applications, this value is 1.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>presentMode</code>
				</p>
			</li>
			<li>
				<p>
                    <code>preTransform</code>
				</p>
				<ul>
					<li>
						<p>
                            We can specify that a certain transform should be applied to images in the Swapchain if it is supported (
                            <code>supportedTransforms</code>
                            &nbsp;in 
                            <code>capabilities</code>
                            ), like a 90-degree clockwise rotation or horizontal flip. To specify that you do not want any transformation, simply specify the current transformation.
						</p>
					</li>
					<li>
						<p>
                            <code>IDENTITY</code>
						</p>
						<ul>
							<li>
								<p>
                                    This would 
									<strong>
                                        not
									</strong>
                                    &nbsp;be optimal on devices that support rotation and will lead to measurable performance loss.
								</p>
							</li>
							<li>
								<p>
                                    It is strongly recommended that 
                                    <code>surface_properties.currentTransform</code>
                                    &nbsp;be used instead. However, the application is required to handle 
                                    <code>preTransform</code>
                                    &nbsp;elsewhere accordingly.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>compositeAlpha</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies if the alpha channel should be used for blending with other windows in the window system.
						</p>
					</li>
					<li>
						<p>
                            You‚Äôll almost always want to simply ignore the alpha channel, hence 
                            <code>OPAQUE</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>clipped</code>
				</p>
				<ul>
					<li>
						<p>
                            If set to 
                            <code>TRUE</code>
                            , then that means that we don‚Äôt care about the color of pixels that are obscured, for example, because another window is in front of them.
						</p>
					</li>
					<li>
						<p>
                            Unless you really need to be able to read these pixels back and get predictable results, you‚Äôll get the best performance by enabling clipping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>oldSwapChain</code>
				</p>
				<ul>
					<li>
						<p>
                            Can be an existing 
							<em>
                                non-retired
							</em>
                            &nbsp;swapchain currently associated with 
                            <code>surface</code>
                            , or 
                            <code>NULL_HANDLE</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If the 
                            <code>oldSwapchain</code>
                            &nbsp;is 
                            <code>NULL_HANDLE</code>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    And if the native window referred to by 
                                    <code>pCreateInfo-&gt;surface</code>
                                    &nbsp;is already associated with a Vulkan swapchain, 
                                    <code>ERROR_NATIVE_WINDOW_IN_USE</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be returned.
								</p>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            If the 
                            <code>oldSwapchain</code>
                            &nbsp;is valid:
						</p>
						<ol>
							<li>
								<p>
                                    This 
									<strong>
                                        may
									</strong>
                                    &nbsp;aid in the resource reuse, and also allows the application to still present any images that are already acquired from it.
								</p>
							</li>
							<li>
								<p>
                                    And the 
                                    <code>oldSwapchain</code>
                                    &nbsp;has exclusive full-screen access, that access is released from 
                                    <code>pCreateInfo-&gt;oldSwapchain</code>
                                    . If the command succeeds in this case, the newly created swapchain will automatically acquire exclusive full-screen access from 
                                    <code>pCreateInfo-&gt;oldSwapchain</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    And there are outstanding calls to 
                                    <code>vkWaitForPresent2KHR</code>
                                    , then 
                                    <code>vkCreateSwapchainKHR</code>
                                    &nbsp;
									<strong>
                                        may
									</strong>
                                    &nbsp;block until those calls complete.
								</p>
							</li>
							<li>
								<p>
                                    Any images from 
                                    <code>oldSwapchain</code>
                                    &nbsp;that are not acquired by the application 
									<strong>
                                        may
									</strong>
                                    &nbsp;be freed by the implementation, upon calling 
                                    <code>vkCreateSwapchainKHR</code>
                                    , which 
									<strong>
                                        may
									</strong>
                                    &nbsp;occur even if creation of the new swapchain fails.
								</p>
							</li>
							<li>
								<p>
                                    The 
                                    <code>oldSwapchain</code>
                                    &nbsp;will be retired upon calling 
                                    <code>vkCreateSwapchainKHR</code>
                                    ,‚Äâeven if creation of the new swapchain fails.
								</p>
								<ul>
									<li>
										<p>
                                            After 
                                            <code>oldSwapchain</code>
                                            &nbsp;is retired, the application 
											<strong>
                                                can
											</strong>
                                            &nbsp;pass to 
                                            <code>vkQueuePresentKHR</code>
                                            &nbsp;any images it had already acquired from 
                                            <code>oldSwapchain</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    An application may present an image from the old swapchain before an image from the new swapchain is ready to be presented.
												</p>
											</li>
											<li>
												<p>
                                                    As usual, 
                                                    <code>vkQueuePresentKHR</code>
                                                    &nbsp;
													<strong>
                                                        may
													</strong>
                                                    &nbsp;fail if 
                                                    <code>oldSwapchain</code>
                                                    &nbsp;has entered a state that causes 
                                                    <code>ERROR_OUT_OF_DATE</code>
                                                    &nbsp;to be returned.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The application 
									<strong>
                                        can
									</strong>
                                    &nbsp;continue to use a shared presentable image obtained from 
                                    <code>oldSwapchain</code>
                                    &nbsp;until a presentable image is acquired from the new swapchain, as long as it has not entered a state that causes it to return 
                                    <code>ERROR_OUT_OF_DATE</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The application 
									<strong>
                                        can
									</strong>
                                    &nbsp;destroy 
                                    <code>oldSwapchain</code>
                                    &nbsp;to free all memory associated with 
                                    <code>oldSwapchain</code>
                                    .
								</p>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            Regardless if the 
                            <code>oldSwapchain</code>
                            &nbsp;is valid or not:
						</p>
						<ol>
							<li>
								<p>
                                    The new swapchain is created in the 
									<em>
                                        non-retired
									</em>
                                    &nbsp;state.
								</p>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitmask of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCreateFlagBitsKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkSwapchainCreateFlagBitsKHR</code>
							</a>
                            &nbsp;indicating parameters of the swapchain creation.
						</p>
					</li>
					<li>
						<p>
                            <code>SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    When 
                                    <code>EXT_swapchain_maintenance1</code>
                                    &nbsp;is available, you can optionally amortize the cost of swapchain image allocations over multiple frames.
								</p>
							</li>
							<li>
								<p>
                                    When this is used, image views cannot be created until the first time the image is acquired.
								</p>
								<ul>
									<li>
										<p>
                                            The idea is that normally the images and image views are acquired when a Swapchain recreation happens, but if this flag is enabled it is necessary to acquire them after 
                                            <code>result == SUCCESS || result == SUBOPTIMAL_KHR</code>
                                            &nbsp;as the result of 
                                            <code>vkAcquireNextImageKHR</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="present-modes" >
    Present Modes
</h5>
<ul>
	<li>
		<p>
            Common present modes are double buffering (vsync) and triple buffering.
		</p>
	</li>
	<li>
		<p>
            The presentation mode is arguably the most important setting for the Swapchain, because it represents the actual conditions for showing images to the screen. There are four possible modes available in Vulkan:
		</p>
		<ul>
			<li>
				<p>
                    <code>PRESENT_MODE_IMMEDIATE_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            Images submitted by your application are transferred to the screen right away, which may result in tearing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>PRESENT_MODE_FIFO_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            The Swapchain is a queue where the display takes an image from the front of the queue when the display is refreshed, and the program inserts rendered images at the back of the queue. If the queue is full, then the program has to wait. This is most similar to vertical sync as found in modern games. The moment that the display is refreshed is known as &quot;vertical blank&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>PRESENT_MODE_FIFO_RELAXED_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank. Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>PRESENT_MODE_MAILBOX_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones. This mode can be used to render frames as fast as possible while still avoiding tearing, resulting in fewer latency issues than standard vertical sync. This is commonly known as &quot;triple buffering,&quot; although the existence of three buffers alone does not necessarily mean that the framerate is unlocked.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Only the 
            <code>PRESENT_MODE_FIFO_KHR</code>
            &nbsp;mode is guaranteed to be available, so we‚Äôll again have to write a function that looks for the best mode that is available:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250729081154.png" width="375" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Options
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I think that 
                    <code>PRESENT_MODE_MAILBOX_KHR</code>
                    &nbsp;is a very nice trade-off if energy usage is not a concern. It allows us to avoid tearing while still maintaining fairly low latency by rendering new images that are as up to date as possible right until the vertical blank.
				</p>
			</li>
			<li>
				<p>
                    On mobile devices, where energy usage is more important, you will probably want to use 
                    <code>PRESENT_MODE_FIFO_KHR</code>
                    &nbsp;instead.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250731211715.png" width="375" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250818181535.png" width="375" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Slide from the Samsung talk on (2025-02-25).
						</p>
					</li>
					<li>
						<p>
                            It recommends FIFO and says that mailbox is not as good as it seems because it induces a lot of stutter.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="drawing-directly-to-the-swapchain-vs-blitting-to-the-swapchain" >
    Drawing directly to the Swapchain vs Blitting to the Swapchain
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://vkguide.dev/docs/new_chapter_2/vulkan_new_rendering/#new-draw-loop" 
				class="external-link" 
				target="_blank" >
                Source
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Drawing directly into the swapchain
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is fine for many projects, and it can even be optimal in some cases such as phones.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Restrictions
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Their resolution is fixed to whatever your window size is.
						</p>
						<ul>
							<li>
								<p>
                                    If you want to have higher or lower resolution, and then do some scaling logic, you need to draw into a different image.
								</p>
							</li>
							<li>
								<p>
                                    Swapchain image size (imageExtent / surface extent) is part of swapchain creation and is tied to the surface. If you want an internal render at a different resolution (supersampling, dynamic resolution, lower-res upscaling), you create an offscreen image/render-target at the desired size and then copy/blit/resolve/tone-map into the swapchain image for presentation. The spec and WSI notes treat imageExtent as the surface-presentable size.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The formats of the image used in the swapchain are not guaranteed.
						</p>
						<ul>
							<li>
								<p>
                                    Different OS, drivers, and windowing modes can have different optimal swapchain formats.
								</p>
							</li>
							<li>
								<p>
                                    The WSI model exposes the surface‚Äôs supported formats to the application via 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html" 
										class="external-link" 
										target="_blank" >
                                        <code>vkGetPhysicalDeviceSurfaceFormatsKHR</code>
									</a>
                                    &nbsp;(or equivalent WSI queries); the returned list is implementation- and surface-dependent, so you must choose from what the platform/driver exposes. That means formats available for swapchains vary by OS, driver, and surface.
								</p>
							</li>
							<li>
								<p>
                                    Vulkan explicitly states this via 
                                    <code>VkSurfaceFormatKHR</code>
                                    &nbsp;and 
                                    <code>vkGetPhysicalDeviceSurfaceFormatsKHR</code>
                                    . The specification (Section 30.5 &quot;WSI Swapchain&quot;, Vulkan 1.3.275) and tutorials emphasize that the application must query and choose from available formats supported by the surface/device combination. Android documentation (Vulkan on Android) and Windows (DXGI_FORMAT) similarly highlight platform-specific format requirements and HDR needs (e.g., 
                                    <code>FORMAT_A2B10G10R10_UNORM_PACK32</code>
                                    &nbsp;or 
                                    <code>DXGI_FORMAT_R10G10B10A2_UNORM</code>
                                    &nbsp;for HDR10). This variability makes direct rendering inflexible.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            HDR support needs its own very specific formats.
						</p>
						<ul>
							<li>
								<p>
                                    HDR output requires specific color formats and color-space metadata (examples: 10-bit packed UNORM formats or explicit HDR color-space support such as ST2084/Perceptual Quantizer). WSI and sample repos treat HDR as a distinct case (e.g. A2B10G10 formats and HDR color spaces). Support is platform- and driver-dependent.
								</p>
							</li>
							<li>
								<p>
									<a
										href="https://github.com/KhronosGroup/Vulkan-Samples/issues/638" 
										class="external-link" 
										target="_blank" >
                                        HDR Sample discussion
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Swapchain formats are, for the most part, low precision.
						</p>
						<ul>
							<li>
								<p>
                                    Some platforms with High Dynamic Range rendering have higher precision formats, but you will often default to 8 bits per color.
								</p>
							</li>
							<li>
								<p>
                                    So if you want high precision light calculations, systems that would prevent banding, or to be able to go past 1.0 on the normalized color range, you will need a separate image for drawing.
								</p>
								<ul>
									<li>
										<p>
                                            HDR/high-dynamic-range lighting typically uses floating-point or extended-range render targets (e.g. 
                                            <code>R16G16B16A16_SFLOAT</code>
                                            &nbsp;or higher) for intermediate lighting accumulation; final tonemapping reduces values into the presentable format. Because presentable swapchain images are often limited (8-bit), the offscreen high-precision image plus a conversion/tonemap pass is the usual pattern.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Many surfaces expose 8-bit UNORM or sRGB formats (e.g. 
                                    <code>B8G8R8A8_UNORM</code>
                                    /
                                    <code>SRGB</code>
                                    ) as commonly returned swapchain formats. Higher-precision formats (16-bit float per channel or 10-bit packed) exist and are used for HDR/high-precision pipelines, but they are not guaranteed by every surface/driver. Therefore applications that need high-precision lighting/accumulation commonly render into a 16-bit-float render target and tonemap/convert for presentation.
								</p>
							</li>
							<li>
								<p>
                                    Banding artifacts in gradients or low-light scenes are a well-known consequence of limited precision. High-precision rendering (HDR, complex lighting, deferred shading G-Buffers) requires formats like 
                                    <code>FORMAT_R16G16B16A16_SFLOAT</code>
                                    &nbsp;(RGBA16F) to store values outside the [0.0, 1.0] range and prevent banding. While 
									<em>
                                        some
									</em>
                                    &nbsp;swapchains 
									<em>
                                        can
									</em>
                                    &nbsp;support HDR formats (e.g., 10:10:10:2), they are less universally available and not the default. Using RGBA16F directly in a swapchain is often unsupported or inefficient for presentation.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Drawing to a different image and copying/blitting to the swapchain image
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Advantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Decouples tonemapping from presentation timing
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Tonemap into an intermediate LDR image that you control. You can finish the tonemap pass earlier and defer the actual transfer/present of the swapchain image to a later point, reducing risk of stalling the present path or blocking on swapchain ownership.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Avoids writing directly to the swapchain
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Writing directly into the swapchain can introduce stalls (wait-for-acquire or present-time synchronization). Using an intermediate LDR image lets you do the heavy work off-swapchain and only do a cheap transfer/present step when convenient.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Enables batching / chaining of postprocesses without touching the swapchain
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    If you need further LDR processing (dithering, temporal AA, UI composite, overlays, readback for screenshots, or additional filters), do those against the intermediate image. This allows composing multiple passes without repeatedly transitioning the swapchain.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Easier support for multiple outputs or different sizes/formats
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You can tonemap once to an LDR image and then blit/copy to different-size or different-format targets (screenshots, streaming encoder, secondary displays) without re-running tonemap.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Allows use of transient/optimized memory for the intermediate
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    The intermediate image can be created as transient (e.g., 
                                    <code>MEMORY_PROPERTY_LAZILY_ALLOCATED</code>
                                    &nbsp;or tiled transient attachment) to reduce memory pressure and bandwidth compared with always keeping a full persistent LDR buffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Better control over final conversion semantics
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    In shader you control quantization, gamma conversion, ordered/temporal dithering, and color-space tagging. After producing the controlled LDR image you can choose the transfer method (exact copy vs scaled blit) that matches target capabilities, improving visual consistency across vendors.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Improved cross-queue / async workflows
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You can produce the LDR image on a graphics/compute queue and then perform a transfer on a transfer-only queue (or use a dedicated present queue) with explicit ownership transfers, possibly improving throughput if hardware supports it.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Facilitates deterministic screenshots / capture
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Saving an intermediate LDR image for file export is safer (format/bit-depth known) than capturing the swapchain which may have platform-specific transforms applied.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Trade-offs
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Extra GPU memory usage
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You need memory for the intermediate LDR image (unless you use transient attachments), which increases resident memory footprint.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Extra GPU bandwidth and a copy step
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Creating an LDR image then copying/blitting to the swapchain costs memory bandwidth and GPU cycles. This can increase frame time if the transfer is on the critical path.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                More layout transitions and synchronization complexity
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You must manage transitions and possibly ownership transfers (if different queues are used). Incorrect synchronization can cause stalls or correctness bugs.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Potential increased latency if done poorly
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    If the copy/blit is done synchronously right before present, it can add latency compared with rendering directly to the swapchain; the intended decoupling only helps if scheduling is arranged to avoid the critical path.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Implementation complexity
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Managing an extra render target, transient allocation, and copy logic is more code than rendering directly to the swapchain.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="swapchain-recreation" >
    Swapchain Recreation
</h3>
<h5
	id="when-to-recreate" >
    When to recreate
</h5>
<ul>
	<li>
		<p>
            If the window surface changed such that the Swapchain is no longer compatible with it.
		</p>
	</li>
	<li>
		<p>
            If the window resizes.
		</p>
	</li>
	<li>
		<p>
            If the window minimizes.
		</p>
		<ul>
			<li>
				<p>
                    This case is special because it will result in a framebuffer size of 
                    <code>0</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    We can handle by waiting for the framebuffer size to be back to something greater than 
                    <code>0</code>
                    , indicating that the window is no longer minimized.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If the swapchain image format changed during an application's lifetime, for example, when moving a window from a standard range to a high dynamic range monitor.
		</p>
	</li>
</ul>
<h5
	id="finding-out-that-a-recreation-is-needed" >
    Finding out that a recreation is needed
</h5>
<ul>
	<li>
		<p>
            The 
            <code>vkAcquireNextImageKHR</code>
            &nbsp;and 
            <code>vkQueuePresentKHR</code>
            &nbsp;functions can return the following special values to indicate this.
		</p>
		<ul>
			<li>
				<p>
                    <code>ERROR_OUT_OF_DATE_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            The Swapchain has become incompatible with the surface and can no longer be used for rendering. Usually happens after a window resize.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SUBOPTIMAL_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            The Swapchain can still be used to successfully present to the surface, but the surface properties are no longer matched exactly.
						</p>
					</li>
					<li>
						<p>
                            You should 
							<strong>
                                ALWAYS
							</strong>
                            &nbsp;recreate the swapchain if the result is suboptimal.
						</p>
					</li>
					<li>
						<p>
                            This result means that it's a &quot;success&quot; but there will be performance penalties.
						</p>
					</li>
					<li>
						<p>
                            Both 
                            <code>SUCCESS</code>
                            &nbsp;and 
                            <code>SUBOPTIMAL_KHR</code>
                            &nbsp;are considered &quot;success&quot; return codes.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If the Swapchain turns out to be out of date when attempting to acquire an image, then it is no longer possible to present to it. Therefore, we should immediately recreate the Swapchain and try again in the next 
            <code>drawFrame</code>
            &nbsp;call.
		</p>
	</li>
	<li>
		<p>
            You could also decide to do that if the Swapchain is suboptimal, but I‚Äôve chosen to proceed anyway in that case because we‚Äôve already acquired an image.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">result = presentQueue.presentKHR( presentInfoKHR );
if (result == vk::Result::eErrorOutOfDateKHR || result == vk::Result::eSuboptimalKHR) {
&nbsp;&nbsp;&nbsp;&nbsp;framebufferResized = false;
&nbsp;&nbsp;&nbsp;&nbsp;recreateSwapChain();
} else if (result != vk::Result::eSuccess) {
&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("failed to present Swapchain image!");
}

currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
</code></pre>
<ul>
	<li>
		<p>
            The 
            <code>vkQueuePresentKHR</code>
            &nbsp;function returns the same values with the same meaning. In this case, we will also recreate the Swapchain if it is suboptimal, because we want the best possible result.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Finding out explicitly
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Although many drivers and platforms trigger 
                    <code>ERROR_OUT_OF_DATE_KHR</code>
                    &nbsp;automatically after a window resize, it is not guaranteed to happen.
				</p>
			</li>
			<li>
				<p>
                    That‚Äôs why we‚Äôll add some 
					<em>
                        extra
					</em>
                    &nbsp;code to also handle resizes explicitly:
				</p>
<pre><code class="language-c" data-lang="c">glfw.SetWindowUserPointer(vulkan_context.glfw_window, vulkan_context)
glfw.SetFramebufferSizeCallback(vulkan_context.glfw_window, proc "c" (window: glfw.WindowHandle, _, _: i32) {s
&nbsp;&nbsp;&nbsp;&nbsp;vulkan_context := cast(^Vulkan_Context)glfw.GetWindowUserPointer(window)
&nbsp;&nbsp;&nbsp;&nbsp;vulkan_context.glfw_framebuffer_resized = true
})
</code></pre>
			</li>
			<li>
				<p>
                    &quot;Usually it's not the best idea to depend on this&quot;.
				</p>
				<ul>
					<li>
						<p>
                            Problems with multithreading.
						</p>
					</li>
					<li>
						<p>
                            You depend on the windowing system to notify changes correctly; this can be really tricky on mobile.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="recreating" >
    Recreating
</h5>
<pre><code class="language-c" data-lang="c">void recreateSwapChain() {
&nbsp;&nbsp;&nbsp;&nbsp;device.waitIdle();

&nbsp;&nbsp;&nbsp;&nbsp;cleanupSwapChain();

&nbsp;&nbsp;&nbsp;&nbsp;createSwapChain();
&nbsp;&nbsp;&nbsp;&nbsp;createImageViews();
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Synchronization
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    ~Flush and Recreate:
				</p>
				<ul>
					<li>
						<p>
                            &quot;We first call 
                            <code>vkDeviceWaitIdle</code>
                            , because just like in the last chapter, we shouldn‚Äôt touch resources that may still be in use.&quot;
						</p>
						<ul>
							<li>
								<p>
                                    This is not enough.
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250818175059.png" width="525" >
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The whole app has to stop and wait for synchronization.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250818180311.png" width="425" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250818180351.png" width="475" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Recreate and check:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250818180214.png" width="375" >
                            .
						</p>
					</li>
					<li>
						<p>
                            You do 
							<strong>
                                not
							</strong>
                            &nbsp;need to stop your rendering at any given point.
						</p>
					</li>
					<li>
						<p>
                            The reason why you are allowed to pass the old swapchain when recreating the new swapchain, is due to this strategy.
						</p>
					</li>
					<li>
						<p>
                            This is the recommendation.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/swapchain_recreation#swapchain-recreation-1" 
								class="external-link" 
								target="_blank" >
                                Strategy
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    This issue is resolved by deferring the destruction of the old swapchain and its remaining present semaphores to the time when the semaphore corresponding to the first present of the new swapchain can be destroyed. Because once the first present semaphore of the new swapchain can be destroyed, the first present operation of the new swapchain is done, which means the old swapchain is no longer being presented.
								</p>
							</li>
							<li>
								<p>
                                    The destruction of both old swapchains must now be deferred to when the first QP of the new swapchain has been processed. If an application resizes the window constantly and at a high rate, we would keep accumulating old swapchains and not free them until it stops.
								</p>
								<ul>
									<li>
										<p>
                                            This potentially accumulates a lot of memory, I think.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    So what's the correct moment then? Only after the new swapchain has completed one full cycle of presentations, that is, when I acquire image index 
                                    <code>0</code>
                                    &nbsp;for the 
									<em>
                                        second
									</em>
                                    &nbsp;time.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Analysis
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    (2025-08-19)
								</p>
							</li>
							<li>
								<p>
                                    Holy, now I understand the problem.
								</p>
							</li>
							<li>
								<p>
                                    I cannot delete anything from the old swapchain until I am sure that everything from the previous one has been presented. I thought that by acquiring the first image of the new swapchain, that would already indicate that it was safe to delete the old swapchain, but that's not true; by doing that, I only guarantee that 1 (ONE) image from the old swapchain has been presented, but the old swapchain may have several images in the queue.
								</p>
							</li>
							<li>
								<p>
                                    However, as made clear, that is not the case.
								</p>
							</li>
							<li>
								<p>
                                    Dealing with this can be a nightmare. Potentially having to handle multiple old swapchains at the same time in case of very frequent resizes (smooth swapchain).
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/EXT_swapchain_maintenance1.html" 
						class="external-link" 
						target="_blank" >
                        <code>EXT_swapchain_maintenance1</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            &quot;You should always use this extension if available&quot;.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Support
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Introduced in 2023.
								</p>
							</li>
							<li>
								<p>
                                    (2025-02-25)
								</p>
								<ul>
									<li>
										<p>
                                            Only 25% of Android devices and 20% of desktop GPUs use it.
										</p>
									</li>
									<li>
										<p>
                                            It was added on Android 14.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Adds a collection of window system integration features that were intentionally left out or overlooked in the original 
                            <code>KHR_swapchain</code>
                            &nbsp;extension.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Features
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Allow applications to release previously acquired images without presenting them.
								</p>
							</li>
							<li>
								<p>
                                    Allow applications to defer swapchain memory allocation for improved startup time and memory footprint.
								</p>
							</li>
							<li>
								<p>
                                    Specify a fence that will be signaled when the resources associated with a present operation 
									<strong>
                                        can
									</strong>
                                    &nbsp;be safely destroyed.
								</p>
							</li>
							<li>
								<p>
                                    Allow changing the present mode a swapchain is using at per-present granularity.
								</p>
							</li>
							<li>
								<p>
                                    Allow applications to define the behavior when presenting a swapchain image to a surface with different dimensions than the image.
								</p>
								<ul>
									<li>
										<p>
                                            Using this feature 
											<strong>
                                                may
											</strong>
                                            &nbsp;allow implementations to avoid returning 
                                            <code>ERROR_OUT_OF_DATE_KHR</code>
                                            &nbsp;in this situation.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    This extension makes 
                                    <code>vkQueuePresentKHR</code>
                                    &nbsp;more similar to 
                                    <code>vkQueueSubmit</code>
                                    , allowing it to specify a fence that the application can wait on.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                The problem with 
                                <code>vkDeviceWaitIdle</code>
                                &nbsp;or 
                                <code>vkQueueWaitIdle</code>
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Typically, applications call these functions and assume it‚Äôs safe to delete swapchain semaphores and the swapchain itself.
								</p>
							</li>
							<li>
								<p>
                                    The problem is that 
                                    <code>WaitIdle</code>
                                    &nbsp;functions are defined in terms of fences - they only wait for workloads submitted through functions that accept a fence.
								</p>
							</li>
							<li>
								<p>
                                    Unextended 
                                    <code>vkQueuePresent</code>
                                    &nbsp;does not provide a fence parameter.
								</p>
							</li>
							<li>
								<p>
                                    The 
                                    <code>vkDeviceWaitIdle</code>
                                    &nbsp;can‚Äôt guarantee that it‚Äôs safe to delete swapchain resources.
								</p>
								<ul>
									<li>
										<p>
                                            The validation layers don't trigger errors in this case, but it's just because so many people use it and there's no good alternative.
										</p>
									</li>
									<li>
										<p>
                                            When 
                                            <code>EXT_swapchain_maintenance1</code>
                                            &nbsp;is enabled the validation layer will report an error if the application shutdown sequence relies on 
                                            <code>vkDeviceWaitIdle</code>
                                            &nbsp;or 
                                            <code>vkQueueWaitIdle</code>
                                            &nbsp;to release swapchain resources instead of using a presentation fence.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The extension fixes this problem.
								</p>
							</li>
							<li>
								<p>
                                    By waiting on the presentation fence, the application can safely release swapchain resources.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    To avoid a deadlock, only reset the fence if we are submitting work:
				</p>
				<ul>
					<li>
						<p>
                            If reset is made right after wait for the fence, but the window was resized, then it will happen a deadlock.
						</p>
					</li>
					<li>
						<p>
                            The fence is opened by the signaling of 
                            <code>QueueSubmit</code>
                            , and closed by the 
                            <code>ResetFences</code>
                            .
						</p>
					</li>
				</ul>
<pre><code class="language-cpp" data-lang="cpp">vkWaitForFences(device, 1, &inFlightFences[currentFrame], TRUE, UINT64_MAX);

uint32_t imageIndex;
VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], NULL_HANDLE, &imageIndex);

if (result == ERROR_OUT_OF_DATE_KHR) {
&nbsp;&nbsp;&nbsp;&nbsp;recreateSwapChain();
&nbsp;&nbsp;&nbsp;&nbsp;return;
} else if (result != SUCCESS && result != SUBOPTIMAL_KHR) {
&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("failed to acquire Swapchain image!");
}

// Only reset the fence if we are submitting work
vkResetFences(device, 1, &inFlightFences[currentFrame]);
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                What to recreate
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The image views need to be recreated because they are based directly on the Swapchain images.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Smooth Swapchain Resizing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Don't bother with smooth swapchain resizing, it's not worth it&quot;.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        My experience
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            (2025-08-04)
						</p>
					</li>
					<li>
						<p>
                            A callback 
                            <code>glfw.SetWindowRefreshCallback</code>
                            &nbsp;allows the swapchain to be recreated while resizing.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Synchronization
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Since the swapchain is recreated all the time, it becomes difficult to manage when the old swapchain should be destroyed along with its resources.
								</p>
							</li>
							<li>
								<p>
                                    <s>At the moment I'm handling the old_swapchain in a &quot;bad&quot; way, and I feel that recreating it every resize frame only worsens synchronization</s>.
								</p>
								<ul>
									<li>
										<p>
                                            It is not necessary to deal with the old_swapchain when using 
                                            <code>vkDeviceWaitIdle()</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            My current implementation:
						</p>
<pre><code class="language-odin" data-lang="odin">eng.window_init(1280, 720, "Expedicao Hover", proc "c" (window: glfw.WindowHandle) {
&nbsp;&nbsp;&nbsp;&nbsp;context = eng.global_context
&nbsp;&nbsp;&nbsp;&nbsp;// fmt.printfln("REFRESHED")
&nbsp;&nbsp;&nbsp;&nbsp;eng.swapchain_resize()
&nbsp;&nbsp;&nbsp;&nbsp;game_draw(&game, game.cycle_draw.dt_cycles_s)
})
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="updating-resources-after-recreating" >
    Updating resources after recreating
</h5>
<ul>
	<li>
		<p>
            Destroy every image and view created from the old swapchain (the swapchain destroys its own images).
		</p>
	</li>
	<li>
		<p>
            Update everything that holds a reference to either of those.
		</p>
		<ul>
			<li>
				<p>
                    If anything was created using the swapchain's size you also have to destroy and recreate those and update anything that references them.
				</p>
			</li>
			<li>
				<p>
                    There's no getting around it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="frames-in-flight" >
    Frames In-Flight
</h3>
<h5
	id="motivation" >
    Motivation
</h5>
<ul>
	<li>
		<p>
            The render loop has one glaring flaw: unnecessary 
			<strong>
                idling
			</strong>
            &nbsp;of the host. We are required to wait on the previous frame to finish before we can start rendering the next.
		</p>
	</li>
	<li>
		<p>
            To fix this we allow multiple frames to be in-flight at once, allowing the rendering of one frame to not interfere with the recording of the next.
		</p>
	</li>
	<li>
		<p>
            This control over the number of frames in flight is another example of Vulkan being explicit.
		</p>
	</li>
</ul>
<h5
	id="frame" >
    Frame
</h5>
<ul>
	<li>
		<p>
            There is no concept of a frame in Vulkan. This means that the way you render is entirely up to you. The only thing that matters is when you have to display the frame to the screen, which is done through a swapchain. But there is no fundamental difference between rendering and then sending the images over the network, or saving the images into a file, or displaying it on the screen through the swapchain.
		</p>
	</li>
	<li>
		<p>
            This means it is possible to use Vulkan in an entirely headless mode, where nothing is displayed to the screen. You can render the images and then store them on disk (very useful for testing) or use Vulkan as a way to perform GPU calculations such as a raytracer or other compute tasks.
		</p>
	</li>
</ul>
<h5
	id="how-many-frames-in-flight" >
    How many Frames In-Flight
</h5>
<ul>
	<li>
		<p>
            We choose the number 2 because we don‚Äôt want the CPU to get 
			<em>
                too
			</em>
            &nbsp;far ahead of the GPU.
		</p>
		<ul>
			<li>
				<p>
                    With two frames in flight, the CPU and the GPU can be working on their own tasks at the same time. If the CPU finishes early, it will wait till the GPU finishes rendering before submitting more work.
				</p>
			</li>
			<li>
				<p>
                    With three or more frames in flight, the CPU could get ahead of the GPU, adding frames of latency. Generally, extra latency isn‚Äôt desired.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="one-per-frame-in-flight" >
    One Per Frame In-Flight
</h5>
<ul>
	<li>
		<p>
			<strong>
                Duplicate
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Resources
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Uniform Buffers.
						</p>
						<ul>
							<li>
								<p>
                                    If modified while a previous frame uses it, corruption occurs.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Dynamic Storage Buffers.
						</p>
						<ul>
							<li>
								<p>
                                    GPU-computed results (e.g., particle positions). Writing to a buffer while an older frame reads it causes hazards.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Color/Depth Attachments.
						</p>
					</li>
					<li>
						<p>
                            Staging Buffers
						</p>
						<ul>
							<li>
								<p>
                                    If updated per frame (e.g., 
                                    <code>vkMapMemory</code>
                                    ), duplication avoids overwriting mid-transfer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Compute Shader Output Buffers:
						</p>
						<ul>
							<li>
								<p>
                                    If frame 
                                    <code>N</code>
                                    &nbsp;writes, and frame 
                                    <code>N+1</code>
                                    &nbsp;reads, duplicate to prevent read-before-write.
								</p>
							</li>
							<li>
								<p>
                                    Use ping-pong buffers (count = frames in-flight).
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Command pool.
				</p>
				<ul>
					<li>
						<p>
                            I have doubts about this; some people do it differently.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Command buffer.
				</p>
			</li>
			<li>
				<p>
                    'present_finished_semaphore'.
				</p>
			</li>
			<li>
				<p>
                    'render_finished_fence'.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Don't duplicate
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Resources
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Static Vertex/Index Buffers:
						</p>
						<ul>
							<li>
								<p>
                                    Initialized once, read-only. No per-frame updates.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Immutable Textures
						</p>
						<ul>
							<li>
								<p>
                                    Loaded once (e.g., via 
                                    <code>VkDeviceMemory</code>
                                    ).
								</p>
							</li>
							<li>
								<p>
                                    Not mapped for change.
								</p>
							</li>
							<li>
								<p>
                                    It's device local.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Static BRDF LUTs.
				</p>
				<ul>
					<li>
						<p>
                            Initialized once, read by all frames.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="advancing-a-frame" >
    Advancing a frame
</h5>
<pre><code class="language-c" data-lang="c">void drawFrame() {
&nbsp;&nbsp;&nbsp;&nbsp;...

&nbsp;&nbsp;&nbsp;&nbsp;currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}
</code></pre>
<ul>
	<li>
		<p>
            By using the modulo (
            <code>%</code>
            ) operator, we ensure that the frame index loops around after every 
            <code>MAX_FRAMES_IN_FLIGHT</code>
            &nbsp;enqueued frames.
		</p>
	</li>
</ul>
<h3
	id="acquire-next-image" >
    Acquire Next Image
</h3>
<ul>
	<li>
		<p>
            <code>vkWaitForFences()</code>
		</p>
		<ul>
			<li>
				<p>
                    Waits on the previous frame.
				</p>
			</li>
			<li>
				<p>
                    Takes an array of fences and waits on the host for either any or all of the fences to be signaled before returning.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>TRUE</code>
                    &nbsp;we pass here indicates that we want to wait for all fences, but in the case of a single one it doesn‚Äôt matter.
				</p>
			</li>
			<li>
				<p>
                    This function also has a timeout parameter that we set to the maximum value of a 64 bit unsigned integer, 
                    <code>UINT64_MAX</code>
                    , which effectively disables the timeout.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkAcquireNextImageKHR()</code>
		</p>
		<ul>
			<li>
				<p>
                    Acquire the index of an available image from the swapchain for 
					<strong>
                        rendering
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    If an image was acquired, then it means that this image is 
					<strong>
                        idle
					</strong>
                    &nbsp;(i.e., 
					<strong>
                        not
					</strong>
                    &nbsp;currently being displayed or written to).
				</p>
			</li>
			<li>
				<p>
                    If no image is ready, the call blocks (or returns an error if non-blocking).
				</p>
			</li>
			<li>
				<p>
                    The returned image index is now &quot;
					<em>
                        owned
					</em>
                    &quot; by your app for rendering.
				</p>
			</li>
			<li>
				<p>
                    We only get a swapchain image index from the windowing present system.
				</p>
			</li>
			<li>
				<p>
                    A semaphore/fence is signaled when the image is safe to use.
				</p>
			</li>
			<li>
				<p>
                    <code>timeout</code>
				</p>
				<ul>
					<li>
						<p>
                            If the swapchain doesn‚Äôt have any image we can use, it will block the thread with a maximum for the timeout set.
						</p>
					</li>
					<li>
						<p>
                            The measurement unit is nanoseconds.
						</p>
					</li>
					<li>
						<p>
                            1 second is fine: 
                            <code>1_000_000_000</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>semaphore</code>
				</p>
				<ul>
					<li>
						<p>
                            Semaphore to signal.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>fence</code>
				</p>
				<ul>
					<li>
						<p>
                            Fence to signal.
						</p>
					</li>
					<li>
						<p>
                            It is possible to specify a semaphore, fence or both.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pImageIndex</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a variable to output the index of the Swapchain image that has 
							<em>
                                become available
							</em>
                            &nbsp;to use.
						</p>
					</li>
					<li>
						<p>
                            The index refers to the 
                            <code>VkImage</code>
                            &nbsp;in the 
                            <code>swapChainImages</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="image-layout-transitions" >
    Image Layout Transitions
</h5>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#images">
            Vulkan#Images
            </a>
            .
		</p>
	</li>
	<li>
		<p>
            Before we can start rendering to an image, we need to transition its layout to one that is suitable for rendering.
		</p>
	</li>
	<li>
		<p>
            Before rendering, we transition the image layout to 
            <code>IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Before starting rendering, transition the swapchain image to COLOR_ATTACHMENT_OPTIMAL
transition_image_layout(
&nbsp;&nbsp;&nbsp;&nbsp;imageIndex,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::eUndefined,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::eColorAttachmentOptimal,
&nbsp;&nbsp;&nbsp;&nbsp;{},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // srcAccessMask (no need to wait for previous operations)
&nbsp;&nbsp;&nbsp;&nbsp;vk::AccessFlagBits2::eColorAttachmentWrite,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstAccessMask
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eTopOfPipe,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // srcStage
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eColorAttachmentOutput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstStage
);
</code></pre>
<ul>
	<li>
		<p>
            After rendering, we need to transition the image layout back to 
            <code>IMAGE_LAYOUT_PRESENT_SRC_KHR</code>
            &nbsp;so it can be presented to the screen:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// After rendering, transition the swapchain image to PRESENT_SRC
transition_image_layout(
&nbsp;&nbsp;&nbsp;&nbsp;imageIndex,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::eColorAttachmentOptimal,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::ePresentSrcKHR,
&nbsp;&nbsp;&nbsp;&nbsp;vk::AccessFlagBits2::eColorAttachmentWrite,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // srcAccessMask
&nbsp;&nbsp;&nbsp;&nbsp;{},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstAccessMask
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eColorAttachmentOutput,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// srcStage
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eBottomOfPipe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstStage
);
</code></pre>
<h3
	id="render-targets" >
    Render Targets
</h3>
<h5
	id="attachments" >
    Attachments
</h5>
<ul>
	<li>
		<p>
            Nvidia: Use 
            <code>storeOp = DONT_CARE</code>
            &nbsp;rather than 
            <code>UNDEFINED</code>
            &nbsp;layouts to skip unneeded render target writes.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Don't transition color attachments from &quot;safe&quot; to &quot;unsafe&quot; unless required by the algorithm.
		</p>
	</li>
</ul>
<h5
	id="transient-resources" >
    Transient Resources
</h5>
<ul>
	<li>
		<p>
            Transient attachments (or Transient Resources) are render targets (like color/depth buffers) designed to exist only temporarily during a render pass, with their contents discarded afterward. They're optimized for fast on-chip memory access and avoid unnecessary memory operations.
		</p>
	</li>
</ul>
<h5
	id="render-target" >
    Render Target
</h5>
<ul>
	<li>
		<p>
            A Render Target is not a term in Vulkan but it's a term in graphics programming.
		</p>
	</li>
	<li>
		<p>
            It's a term for an image you render into. In Vulkan this is an 
            <code>VkImage</code>
            &nbsp;+ 
            <code>VkImageView</code>
            &nbsp;used as a color/depth attachment in a render pass or as a color attachment in dynamic rendering.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#drawing-to-a-high-precision-image-r16g16b16a16_sfloat">
                    Vulkan#Drawing to a High Precision Image (
                    <code>R16G16B16A16_SFLOAT</code>
                    )
                    </a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            It's a Render Target technique to draw into a high-precision image and then copy the result to an SDR image for the swapchain.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Drawing a UI
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The UI texture must preserve alpha in the areas you want to be transparent, for later compositing.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<strong>
                        Draw UI directly to the final render target (swapchain image, or image to blit to the swapchain image)
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            After tonemap, enable blending and draw UI.
						</p>
					</li>
					<li>
						<p>
                            Oni:
						</p>
						<ul>
							<li>
								<p>
                                    For the scene, I render into an RGBA16 image, then I draw 
									<em>
                                        on the swapchain
									</em>
                                    &nbsp;with a tonemapper, then I draw the UI 
									<em>
                                        on the swapchain
									</em>
                                    &nbsp;with blending enabled.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Composite in a shader
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Sample scene image and UI image, compute 
                            <code>out = scene * (1 - alpha_ui) + ui * alpha_ui</code>
                            &nbsp;(or use premultiplied alpha: 
                            <code>out = scene + ui</code>
                            ).
						</p>
						<ul>
							<li>
								<p>
                                    Both ways work; premultiplied alpha avoids some edge artifacts if UI already uses premultiplied data.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<strong>
                Compositing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used to combine render targets, or any other images.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<em>
                        Fragment shader
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Render to an image and draw a full-screen triangle/quad that samples the HDR image and outputs LDR color.
						</p>
						<ul>
							<li>
								<p>
                                    Could be the swapchain image if supported, or an intermediate image then blit/copy to swapchain.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Pros
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Simple and guaranteed compatible with swapchain color attachment usage.
								</p>
							</li>
							<li>
								<p>
                                    Useful if you want to draw the UI while making this final composition.
								</p>
								<ul>
									<li>
										<p>
                                            Seems like I'm mixing responsibilities, even though I'm reducing one render pass.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Cons
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Less flexible for arbitrary per-pixel work that requires many conditionals or random write patterns.
								</p>
							</li>
							<li>
								<p>
                                    Need to issue a draw call and set up graphics pipeline.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Compute shader
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Sample HDR image(s), write the LDR pixels to an output image.
						</p>
						<ul>
							<li>
								<p>
                                    Could be the swapchain image if supported, or an intermediate image then blit/copy to swapchain.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Pros
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Flexible: can read multiple inputs and write arbitrary outputs (random writes, multiple passes) without needing geometry.
								</p>
							</li>
							<li>
								<p>
                                    Easy to implement multi-image compositing in one dispatch (read N sampled images + write to storage image).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Cons
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    On some GPUs a simple full-screen fragment pass can be faster due to fixed-function hardware for rasterization and blending.
								</p>
							</li>
						</ul>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(set=0, binding=0) uniform sampler2D gameTex;
layout(set=0, binding=1) uniform sampler2D uiTex;
layout(set=0, binding=2, rgba8) uniform writeonly image2D swapchainImg;

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;vec2 uv = vec2(coord) / textureSize(gameTex, 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Sample inputs
&nbsp;&nbsp;&nbsp;&nbsp;vec3 game = texture(gameTex, uv).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 ui = texture(uiTex, uv);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Tonemap game (example: Reinhard)
&nbsp;&nbsp;&nbsp;&nbsp;game = game / (game + vec3(1.0));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Composite: UI over game
&nbsp;&nbsp;&nbsp;&nbsp;vec3 final = mix(game, ui.rgb, ui.a);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Write to swapchain
&nbsp;&nbsp;&nbsp;&nbsp;imageStore(swapchainImg, coord, vec4(final, 1.0));
}
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D uSceneHDR;
layout(binding = 1) uniform sampler2D uUI; // optional
layout(binding = 2, rgba8) writeonly uniform image2D outImage; // target LDR image (could be swapchain-compatible image)

vec3 reinhardTonemap(vec3 c) {
&nbsp;&nbsp;&nbsp;&nbsp;return c / (1.0 + c);
}

vec3 toSRGB(vec3 linear) {
&nbsp;&nbsp;&nbsp;&nbsp;return pow(linear, vec3(1.0/2.2));
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;ivec2 size = imageSize(outImage);
&nbsp;&nbsp;&nbsp;&nbsp;if (pix.x &gt;= size.x || pix.y &gt;= size.y) return;

&nbsp;&nbsp;&nbsp;&nbsp;vec2 uv = (vec2(pix) + 0.5) / vec2(size);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 hdr = texture(uSceneHDR, uv).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;float exposure = 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 mapped = reinhardTonemap(hdr * exposure);
&nbsp;&nbsp;&nbsp;&nbsp;mapped = toSRGB(mapped);

&nbsp;&nbsp;&nbsp;&nbsp;// Optionally composite UI
&nbsp;&nbsp;&nbsp;&nbsp;// vec4 ui = texture(uUI, uv);
&nbsp;&nbsp;&nbsp;&nbsp;// vec3 outc = mix(mapped, ui.rgb, ui.a);

&nbsp;&nbsp;&nbsp;&nbsp;imageStore(outImage, pix, vec4(mapped, 1.0));
}
</code></pre>
<pre><code class="language-c" data-lang="c">// Dispatch
vkCmdBindPipeline(cmd, PIPELINE_BIND_POINT_COMPUTE, computePipe);
vkCmdBindDescriptorSets(cmd, PIPELINE_BIND_POINT_COMPUTE, ...);
vkCmdDispatch(cmd, swapchain_width/16, swapchain_height/16, 1);
</code></pre>
			</li>
		</ol>
	</li>
</ul>
<h3
	id="dynamic-rendering" >
    Dynamic Rendering
</h3>
<ul>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=KHR_dynamic_rendering" 
						class="external-link" 
						target="_blank" >
                        Dynamic Rendering
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=KHR_dynamic_rendering_local_read" 
						class="external-link" 
						target="_blank" >
                        Dynamic Rendering Local Read
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Used for tiling GPUs.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=EXT_dynamic_rendering_unused_attachments" 
						class="external-link" 
						target="_blank" >
                        Dynamic Rendering Unused Attachments
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/EXT_dynamic_rendering_unused_attachments.html" 
								class="external-link" 
								target="_blank" >
                                EXT_dynamic_rendering_unused_attachments
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Requires Vulkan 1.3+.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/proposals/EXT_dynamic_rendering_unused_attachments.adoc" 
								class="external-link" 
								target="_blank" >
                                Proposal
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html" 
								class="external-link" 
								target="_blank" >
                                VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            It relaxes the strict matching rules so a rendering instance and the bound pipelines may disagree about an attachment being ‚Äúunused‚Äù in one but not the other (and relaxes some format/NULL mixing rules described in the extension).
						</p>
					</li>
					<li>
						<p>
							<em>
                                Support
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Pass 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
									</a>
                                    &nbsp;in the 
                                    <code>pNext</code>
                                    &nbsp;chain of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceFeatures2
									</a>
                                    &nbsp;structure passed to 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        vkGetPhysicalDeviceFeatures2
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The struct will be filled in to indicate whether each corresponding feature is supported.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Enabling
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Enable the corresponding feature in 
                                    <code>VkDeviceCreateInfo</code>
                                    &nbsp;(via 
                                    <code>VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT</code>
                                    )
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            This extension lifts some restrictions in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/KHR_dynamic_rendering.html" 
								class="external-link" 
								target="_blank" >
                                KHR_dynamic_rendering
							</a>
                            &nbsp;extension to allow render pass instances and bound pipelines within those render pass instances to have an unused attachment specified in one but not the other. It also allows pipelines to use different formats in a render pass as long as the attachment is NULL.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkRenderingAttachmentInfo</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Structure specifying attachment information
				</p>
			</li>
			<li>
				<p>
                    <code>imageView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the image view that will be used for rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the layout that 
                            <code>imageView</code>
                            &nbsp;will be in during rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveMode</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlagBits.html" 
								class="external-link" 
								target="_blank" >
                                VkResolveModeFlagBits
							</a>
                            &nbsp;value defining how data written to 
                            <code>imageView</code>
                            &nbsp;will be resolved into 
                            <code>resolveImageView</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is an image view used to write resolved data at the end of rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the layout that 
                            <code>resolveImageView</code>
                            &nbsp;will be in during rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>loadOp</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies what to do with the image before rendering.
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentLoadOp.html" 
								class="external-link" 
								target="_blank" >
                                VkAttachmentLoadOp
							</a>
                            &nbsp;value defining the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-load-operations" 
								class="external-link" 
								target="_blank" >
                                load operation
							</a>
                            &nbsp;for the attachment.
						</p>
					</li>
					<li>
						<p>
                            We‚Äôre using 
                            <code>ATTACHMENT_LOAD_OP_CLEAR</code>
                            &nbsp;to clear the image to black before rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>storeOp</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies what to do with the image after rendering.
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentStoreOp.html" 
								class="external-link" 
								target="_blank" >
                                VkAttachmentStoreOp
							</a>
                            &nbsp;value defining the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-store-operations" 
								class="external-link" 
								target="_blank" >
                                store operation
							</a>
                            &nbsp;for the attachment.
						</p>
					</li>
					<li>
						<p>
                            We're using 
                            <code>ATTACHMENT_STORE_OP_STORE</code>
                            &nbsp;to store the rendered image for later use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>clearValue</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkClearValue.html" 
								class="external-link" 
								target="_blank" >
                                VkClearValue
							</a>
                            &nbsp;structure defining values used to clear 
                            <code>imageView</code>
                            &nbsp;when 
                            <code>loadOp</code>
                            &nbsp;is 
                            <code>ATTACHMENT_LOAD_OP_CLEAR</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkRenderingInfo</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Structure specifying render pass instance begin info.
				</p>
			</li>
			<li>
				<p>
                    Specifies the attachments to render to and the render area.
				</p>
			</li>
			<li>
				<p>
                    Combines the 
                    <code>RenderingAttachmentInfo</code>
                    &nbsp;with other rendering parameters.
				</p>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitmask of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFlagBits.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingFlagBits
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>renderArea</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the render area that is affected by the render pass instance.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Extent Requirements
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The 
                                    <code>rendering_info.renderArea.extent</code>
                                    &nbsp;has to fit inside the 
                                    <code>rendering_attachment.imageView</code>
                                    &nbsp;and hence the image.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If there is an instance of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupRenderPassBeginInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDeviceGroupRenderPassBeginInfo
							</a>
                            &nbsp;included in the 
                            <code>pNext</code>
                            &nbsp;chain and its 
                            <code>deviceRenderAreaCount</code>
                            &nbsp;member is not 
                            <code>0</code>
                            , then 
                            <code>renderArea</code>
                            &nbsp;is ignored, and the render area is defined per-device by that structure.
						</p>
					</li>
					<li>
						<p>
                            CharlesG - LunarG:
						</p>
						<ul>
							<li>
								<p>
                                    Viewports &amp; scissors let you specify a size smaller than the full image, as well as redefining the origin &amp; scale to use. Whereas the renderArea is specifying the actual image dimensions to use. This allows flexibility in how the backing VkImage is used in contrast to the viewport/scissor needs of the rendering itself. In most cases they are going to be ‚Äúfull‚Äù so its not like it comes into play always
								</p>
							</li>
							<li>
								<p>
                                    More clarity: viewport &amp; scissor are inputs to the rasterization stage, while the render area is an input for the attachment read/write.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    So, when comparing these two cases:
								</p>
								<ul>
									<li>
										<p>
                                            1- I use a 1080p image for the 
                                            <code>renderArea</code>
                                            &nbsp;and a 
                                            <code>640p</code>
                                            &nbsp;viewport and center the offset
										</p>
									</li>
									<li>
										<p>
                                            2- I use a 640p image for the 
                                            <code>renderArea</code>
                                            &nbsp;and a 
                                            <code>640p</code>
                                            &nbsp;viewport and center the offset
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Is there a difference between the quality and performance of these two? Or even, is there a visual difference?
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            CharlesG - LunarG:
						</p>
						<ul>
							<li>
								<p>
                                    I don't know tbh.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>colorAttachmentCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in 
                            <code>pColorAttachments</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pColorAttachments</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>colorAttachmentCount</code>
                            &nbsp;
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingAttachmentInfo
							</a>
                            &nbsp;structures describing any color attachments used.
						</p>
					</li>
					<li>
						<p>
                            Each element of the 
                            <code>pColorAttachments</code>
                            &nbsp;array corresponds to an output location in the shader, i.e. if the shader declares an output variable decorated with a 
                            <code>Location</code>
                            &nbsp;value of 
							<strong>
                                X
							</strong>
                            , then it uses the attachment provided in 
                            <code>pColorAttachments[X]</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If the 
                            <code>imageView</code>
                            &nbsp;member of any element of 
                            <code>pColorAttachments</code>
                            &nbsp;is 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/NULL_HANDLE.html" 
								class="external-link" 
								target="_blank" >
                                NULL_HANDLE
							</a>
                            , and 
                            <code>resolveMode</code>
                            &nbsp;is not 
                            <code>RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID</code>
                            , writes to the corresponding location by a fragment are discarded.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDepthAttachment</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingAttachmentInfo
							</a>
                            &nbsp;structure describing a depth attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pStencilAttachment</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingAttachmentInfo
							</a>
                            &nbsp;structure describing a stencil attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>viewMask</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitfield of view indices describing which views are active during rendering, when it is not 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>layerCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of layers rendered to in each attachment when 
                            <code>viewMask</code>
                            &nbsp;is 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Specifies the number of layers to render to, which is 1 for a non-layered image.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="multi-view" >
    Multi-view
</h5>
<ul>
	<li>
		<p>
            If 
            <code>VkRenderingInfo.viewMask</code>
            &nbsp;is not 
            <code>0</code>
            , multiview is enabled.
		</p>
	</li>
	<li>
		<p>
            If multiview is enabled, and the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-multiviewPerViewRenderAreas" 
				class="external-link" 
				target="_blank" >
                <code>multiviewPerViewRenderAreas</code>
			</a>
            &nbsp;feature is enabled, and there is an instance of 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM.html" 
				class="external-link" 
				target="_blank" >
                VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
			</a>
            &nbsp;included in the 
            <code>pNext</code>
            &nbsp;chain with 
            <code>perViewRenderAreaCount</code>
            &nbsp;not equal to 
            <code>0</code>
            , then the elements of 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM.html" 
				class="external-link" 
				target="_blank" >
                VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
			</a>
            ::
            <code>pPerViewRenderAreas</code>
            &nbsp;override 
            <code>renderArea</code>
            &nbsp;and define a render area for each view. In this case, 
            <code>renderArea</code>
            &nbsp;
			<strong>
                must
			</strong>
            &nbsp;be an area at least as large as the union of all the per-view render areas.
		</p>
	</li>
</ul>
<h5
	id="render-cmds" >
    Render Cmds
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdBeginRendering</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdEndRendering</code>
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="drawing-commands" >
    Drawing Commands
</h3>
<h5
	id="draw-direct" >
    Draw Direct
</h5>
<ul>
	<li>
		<p>
            Specify the Viewport and Scissor.
		</p>
	</li>
	<li>
		<p>
            Bind the pipeline.
		</p>
	</li>
	<li>
		<p>
            Bind the descriptor sets.
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdDraw()</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>vertexCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Even though we don‚Äôt have a vertex buffer, we technically still have 3 vertices to draw.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>instanceCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Used for instanced rendering, use 
                            <code>1</code>
                            &nbsp;if you‚Äôre not doing that.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstVertex</code>
				</p>
				<ul>
					<li>
						<p>
                            Used as an offset into the vertex buffer, defines the lowest value of 
                            <code>SV_VertexId</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstInstance</code>
				</p>
				<ul>
					<li>
						<p>
                            Used as an offset for instanced rendering, defines the lowest value of 
                            <code>SV_InstanceID</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexed.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdDrawIndexed</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>indexCount</code>
				</p>
				<ul>
					<li>
						<p>
                            The number of vertices to draw.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>instanceCount</code>
				</p>
				<ul>
					<li>
						<p>
                            The number of instances to draw.
						</p>
					</li>
					<li>
						<p>
                            We‚Äôre not using instancing, so just specify 
                            <code>1</code>
                            &nbsp;instance.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstIndex</code>
				</p>
				<ul>
					<li>
						<p>
                            The base index within the index buffer.
						</p>
					</li>
					<li>
						<p>
                            Specifies an offset into the index buffer, using a value of 
                            <code>1</code>
                            &nbsp;would cause the graphics card to start reading at the second index.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>vertexOffset</code>
				</p>
				<ul>
					<li>
						<p>
                            The value added to the vertex index before indexing into the vertex buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstInstance</code>
				</p>
				<ul>
					<li>
						<p>
                            The instance ID of the first instance to draw.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="draw-indirect" >
    Draw Indirect
</h5>
<ul>
	<li>
		<p>
            &quot;In some ways, Indirect Rendering is a more advanced form of instancing&quot;.
		</p>
	</li>
	<li>
		<p>
            <code>buffer + offset + (stride * index)</code>
		</p>
	</li>
	<li>
		<p>
            Executing a draw-indirect call will be equivalent to doing this.
		</p>
<pre><code class="language-cpp" data-lang="cpp">void FakeDrawIndirect(VkCommandBuffer commandBuffer,void* buffer,VkDeviceSize offset, uint32_t drawCount,uint32_t stride);

&nbsp;&nbsp;&nbsp;&nbsp;char* memory = (char*)buffer + offset;

&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; drawCount; i++)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VkDrawIndexedIndirectCommand* command = VkDrawIndexedIndirectCommand*(memory + (i * stride));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VkCmdDrawIndexed(commandBuffer, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command-&gt;indexCount, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command-&gt;instanceCount, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command-&gt;firstIndex, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command-&gt;vertexOffset,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command-&gt;firstInstance);
&nbsp;&nbsp;&nbsp;&nbsp;}
} 
</code></pre>
	</li>
	<li>
		<p>
            It does not carry vertex data itself ‚Äî it only supplies counts and base indices/instances. The actual vertex data and indices come from the buffers you previously bound with 
            <code>vkCmdBindVertexBuffers</code>
            &nbsp;and 
            <code>vkCmdBindIndexBuffer</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Vertex
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    To move vertex and index buffers to bindless, generally you do it by merging the meshes into really big buffers. Instead of having 1 buffer per vertex buffer and index buffer pair, you have 1 buffer for all vertex buffers in a scene. When rendering, then you use BaseVertex offsets in the drawcalls. In some engines, they remove vertex attributes from the pipelines entirely, and instead grab the vertex data from buffers in the vertex shader. Doing that makes it much easier to keep 1 big vertex buffer for all drawcalls in the engine even if they use different vertex attribute formats. It also allows some advanced unpacking/compression techniques, and it‚Äôs the main use case for Mesh Shaders.
				</p>
			</li>
			<li>
				<p>
                    We also change the way the meshes work. After loading a scene, we create a BIG vertex buffer, and stuff all of the meshes of the entire map into it. This way we will avoid having to rebind vertex buffers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Implementation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If the device supports multi-draw indirect (
                    <code>VkPhysicalDeviceFeatures2::multiDrawIndirect</code>
                    ), then the entire array of draw commands can be executed through a single call to 
                    <code>VkDrawIndexedIndirectCommand</code>
                    . Otherwise, each draw call must be executed through a separate call to 
                    <code>VkDrawIndexIndirectCommand</code>
                    :
				</p>
<pre><code class="language-cpp" data-lang="cpp">// m_enable_mci: supports multiDrawIndirect
if (m_enable_mci && m_supports_mci)
{
&nbsp;&nbsp;&nbsp;&nbsp;vkCmdDrawIndexedIndirect(draw_cmd_buffers[i], indirect_call_buffer-&gt;get_handle(), 0, cpu_commands.size(), sizeof(cpu_commands[0]));
}
else
{
&nbsp;&nbsp;&nbsp;&nbsp;for (size_t j = 0; j &lt; cpu_commands.size(); ++j)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vkCmdDrawIndexedIndirect(draw_cmd_buffers[i], indirect_call_buffer-&gt;get_handle(), j * sizeof(cpu_commands[0]), 1, sizeof(cpu_commands[0]));
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
			</li>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/refpages/latest/refpages/source/vkCmdDrawIndexedIndirectCount.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCmdDrawIndexedIndirectCount</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Behaves similarly to vkCmdDrawIndexedIndirect except that the draw count is read by the device from a buffer during execution. The command will read an unsigned 32-bit integer from countBuffer located at countBufferOffset and use this as the draw count.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Textures
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Due to the fact that you want to have as much things on the GPU as possible, this pipeline maps very well if you combine it with ‚ÄúBindless‚Äù techniques, where you stop needing to bind descriptor sets per material or changing vertex buffers. Having a bindless renderer also makes Raytracing much more performant and effective.
				</p>
			</li>
			<li>
				<p>
                    On this guide we will not use bindless textures as their support is limited, so we will do 1 draw-indirect call per material used.
				</p>
			</li>
			<li>
				<p>
                    To move textures into bindless, you use texture arrays.
				</p>
			</li>
			<li>
				<p>
                    With the correct extension, the size of the texture array can be unbounded in the shader, like when you use SSBOs.
				</p>
			</li>
			<li>
				<p>
                    Then, when accessing the textures in the shader, you access them by index which you grab from another buffer. If you don‚Äôt use the Descriptor Indexing extensions, you can still use texture arrays, but they will need a bounded size. Check your device limits to see how big can that be.
				</p>
			</li>
			<li>
				<p>
                    To make materials bindless, you need to stop having 1 pipeline per material. Instead, you want to move the material parameters into SSBOs, and go with an 
					<strong>
                        ubershader
					</strong>
                    &nbsp;approach.
				</p>
			</li>
			<li>
				<p>
                    In the Doom engines, they have a very low amount of pipelines for the entire game. Doom eternal has less than 500 pipelines, while Unreal Engine games often have 100.000+ pipelines. If you use ubershaders to massively lower the amount of unique pipelines, you will be able to increase efficiency in a huge way, as VkCmdBindPipeline is one of the most expensive calls when drawing objects in vulkan.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Push Constants and Dynamic Descriptors can be used, but they have to be ‚Äúglobal‚Äù. Using push constants for things like camera location is perfectly fine, but you cant use them for object ID as that‚Äôs a per-object call and you specifically want to draw as many objects as possible in 1 draw.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="multithreading-rendering" >
    <s>Multithreading Rendering</s>
</h3>
<ul>
	<li>
		<p>
            I'm not sure, I don't think it's necessary.
		</p>
	</li>
	<li>
		<p>
            From what I understand, it's about using multiple CPU threads to handle submissions and presentations, etc.
		</p>
	</li>
	<li>
		<p>
            It has nothing to do with frames in flight, btw.
		</p>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=a49AWmIfjdo" 
				class="external-link" 
				target="_blank" >
                Explanation
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    The video explains okay, but nah.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        -&gt;
					</strong>
                    &nbsp;In the next video he says it wasn't exactly a good idea and 
					<em>
                        reverted
					</em>
                    &nbsp;what he did in that video.
				</p>
				<ul>
					<li>
						<p>
                            &quot;It was technically slower and more confusing to do synchronizations&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="render-passes-and-framebuffers" >
    <s>Render Passes and Framebuffers</s>
</h3>
<h5
	id="dynamic-rendering-features-and-differences-from-render-passes" >
    Dynamic Rendering: Features and differences from Render Passes
</h5>
<ul>
	<li>
		<p>
            Replaces 
            <code>VkRenderPass</code>
            &nbsp;and Framebuffers.
		</p>
		<ul>
			<li>
				<p>
                    Instead, we can specify the color, depth, and stencil attachments directly when we begin rendering.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Describe renderpasses inline with command buffer recording.
		</p>
	</li>
	<li>
		<p>
            Provides more flexibility by allowing us to change the attachments we‚Äôre rendering to without creating new render pass objects.
		</p>
	</li>
	<li>
		<p>
            Greatly simplifies application architecture.
		</p>
	</li>
	<li>
		<p>
            Synchronization still needs to be done, but now it's even more explicit, truer to its stated nature.
		</p>
		<ul>
			<li>
				<p>
                    We had to do that with Render Passes, but that was bound up in the Render Pass creation.
				</p>
			</li>
			<li>
				<p>
                    Now, the synchronization is more explicit.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tiling GPUs aren't left behind.
		</p>
		<ul>
			<li>
				<p>
                    The v1.4 
                    <code>dynamicRenderingLocalRead</code>
                    , 
                    <code>KHR_dynamic_rendering_local_read</code>
                    &nbsp;brings tiling GPUs to the same capabilities, and they don't need to state the Render Passes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            I wouldn't say that &quot;You should use Render Passes if your hardware isn't new enough&quot;, because it isn't fun.
		</p>
	</li>
	<li>
		<p>
            Better compatibility with modern rendering techniques.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731211439.png" width="425" >
            .
		</p>
	</li>
</ul>
<h5
	id="subpasses" >
    Subpasses
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250930090957.png" width="480" >
            .
		</p>
	</li>
	<li>
		<p>
            <s>
			<strong>
                External subpass dependencies
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Explained by TheMaister 2019; he is part of the Khronos Group.
				</p>
			</li>
			<li>
				<p>
                    The main purpose of external subpass dependencies is to deal with initialLayout and finalLayout of an attachment reference. If initialLayout != layout used in the first subpass, the render pass is forced to perform a layout transition.
				</p>
			</li>
			<li>
				<p>
                    If you don‚Äôt specify anything else, that layout transition will wait for nothing before it performs the transition. Or rather, the driver will inject a dummy subpass dependency for you with srcStageMask = TOP_OF_PIPE. This is not what you want since it‚Äôs almost certainly going to be a race condition. You can set up a subpass dependency with the appropriate srcStageMask and srcAccessMask.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        The external subpass dependency is basically just a vkCmdPipelineBarrier injected for you by the driver.
					</strong>
				</p>
			</li>
			<li>
				<p>
                    The whole premise here is that it‚Äôs theoretically better to do it this way because the driver has more information, but this is questionable, at least on current hardware and drivers.
				</p>
			</li>
			<li>
				<p>
                    There is a very similar external subpass dependency setup for finalLayout. If finalLayout differs from the last use in a subpass, driver will transition into the final layout automatically. Here you get to change 
                    <code>dstStageMask</code>
                    /
                    <code>dstAccessMask</code>
                    . If you do nothing here, you get 
                    <code>BOTTOM_OF_PIPE</code>
                    , which can actually be just fine. A prime use case here is swapchain images which have 
                    <code>finalLayout = PRESENT_SRC_KHR</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Essentially, 
					<strong>
                        you can ignore external subpass dependencies
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    Their added complexity gives very little gain. Render pass compatibility rules also imply that if you change even minor things like which stages to wait for, you need to create new pipelines!
				</p>
			</li>
			<li>
				<p>
                    This is dumb, and will hopefully be fixed at some point in the spec.
				</p>
			</li>
			<li>
				<p>
                    However, while the usefulness of external subpass dependencies is questionable, they have some convenient use cases I‚Äôd like to go over:
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Automatically transitioning 
                                <code>TRANSIENT_ATTACHMENT</code>
                                &nbsp;images
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    If you‚Äôre on mobile, you should be using transient images where possible. When using these attachments in a render pass, it makes sense to always have them as initialLayout = UNDEFINED. Since we know that these images can only ever be used in 
                                    <code>COLOR_ATTACHMENT_OUTPUT</code>
                                    &nbsp;or 
                                    <code>EARLY</code>
                                    /
                                    <code>LATE_FRAGMENT_TEST</code>
                                    &nbsp;stages depending on their image format, the external subpass dependency writes itself, and we can just use transient attachments without having to think too hard about how to synchronize them. This is what I do in my Granite engine, and it‚Äôs quite useful. Of course, we could just inject a pipeline barrier for this exact same purpose, but that‚Äôs more boilerplate.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Automatically transitioning swapchain images
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Typically, swapchain images are always just used once per frame, and we can deal with all synchronization using external subpass dependencies. We want 
                                    <code>initialLayout = UNDEFINED</code>
                                    , and 
                                    <code>finalLayout = PRESENT_SRC_KHR</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
                                    &nbsp;is 
                                    <code>COLOR_ATTACHMENT_OUTPUT</code>
                                    &nbsp;which lets us link up with the swapchain acquire semaphore. For this case, we will need an external subpass dependency. For the 
                                    <code>finalLayout</code>
                                    &nbsp;transition after the render pass, we are fine with 
                                    <code>BOTTOM_OF_PIPE</code>
                                    &nbsp;being used. We‚Äôre going to use semaphores here anyways.
								</p>
							</li>
							<li>
								<p>
                                    I also do this in Granite.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="framebuffers" >
    Framebuffers
</h5>
<ul>
	<li>
		<p>
            <code>VkFrameBuffer</code>
		</p>
		<ul>
			<li>
				<p>
                    Holds the target images for a renderpass.
				</p>
			</li>
			<li>
				<p>
                    Only used in legacy tutorials.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Just wrappers to image views.
		</p>
	</li>
	<li>
		<p>
            The attachments of a Framebuffer are the Image Views.
		</p>
	</li>
	<li>
		<p>
            The Framebuffers are used within a Render Pass.
		</p>
	</li>
	<li>
		<p>
            LunarG / Vulkan: &quot;Kinda of a bad name, it's just a couple of image views&quot;.
		</p>
	</li>
	<li>
		<p>
            Only exists to combine images and renderpasses.
		</p>
	</li>
</ul>
<h5
	id="render-passes" >
    Render Passes
</h5>
<ul>
	<li>
		<p>
            <code>VkRenderPass</code>
		</p>
		<ul>
			<li>
				<p>
                    Holds information about the images you are rendering into. All drawing commands have to be done inside a renderpass.
				</p>
			</li>
			<li>
				<p>
                    Only used in legacy tutorials.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Render passes in Vulkan describe the 
			<em>
                type
			</em>
            &nbsp;of images that are used during rendering operations, 
			<em>
                how
			</em>
            &nbsp;they will be used, and 
			<em>
                how
			</em>
            &nbsp;their contents should be treated.
		</p>
	</li>
	<li>
		<p>
            All drawing commands happen inside a &quot;render pass&quot;.
		</p>
	</li>
	<li>
		<p>
            Acts as pseudo render graph.
		</p>
	</li>
	<li>
		<p>
            Allows tiling GPUs to use memory efficiently.
		</p>
		<ul>
			<li>
				<p>
                    Efficient scheduling.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Describe images attachments.
		</p>
	</li>
	<li>
		<p>
            Defines the subpasses.
		</p>
	</li>
	<li>
		<p>
            Declare dependencies between subpasses.
		</p>
	</li>
	<li>
		<p>
            Require 
            <code>VkFrameBuffers</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    Whereas a render pass only describes the type of images, a 
                    <code>VkFramebuffer</code>
                    &nbsp;actually binds specific images to these slots.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250730160923.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Problem
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Great in theory, not so great to use in practice.
				</p>
			</li>
			<li>
				<p>
                    Single object with many responsibilities.
				</p>
				<ul>
					<li>
						<p>
                            Made the API harder to reason about when looking at the code.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Hard to architect into a renderer.
				</p>
				<ul>
					<li>
						<p>
                            Yet another input for pipelines.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The main benefit is for tiling based GPUs.
				</p>
				<ul>
					<li>
						<p>
                            Commonly found in mobile.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;Use Dynamic Rendering, it's much better&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="submit" >
    Submit
</h3>
<ul>
	<li>
		<p>
            Submits the Command Buffers recorded.
		</p>
	</li>
	<li>
		<p>
            <code>vkSubmitInfo</code>
		</p>
		<ul>
			<li>
				<p>
                    The first three parameters specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait.
				</p>
			</li>
			<li>
				<p>
                    We want to wait for writing colors to the image until it‚Äôs available, so we‚Äôre specifying the stage of the graphics pipeline that writes to the color attachment.
				</p>
			</li>
			<li>
				<p>
                    That means that theoretically, the implementation can already start executing our vertex shader and such while the image is not yet available.
				</p>
			</li>
			<li>
				<p>
                    Each entry in the 
                    <code>waitStages</code>
                    &nbsp;array corresponds to the semaphore with the same index in 
                    <code>pWaitSemaphores</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>pCommandBuffers</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies which command buffers to actually submit for execution. We simply submit the single command buffer we have.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSignalSemaphores</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies which semaphores to signal once the command buffer(s) have finished execution.
						</p>
					</li>
					<li>
						<p>
                            In our case we‚Äôre using the 
                            <code>renderFinishedSemaphore</code>
                            &nbsp;for that purpose.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkQueueSubmit()</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>fence</code>
				</p>
				<ul>
					<li>
						<p>
                            Is an optional handle to a fence to be 
							<em>
                                signaled
							</em>
                            &nbsp;once all submitted command buffers have completed execution.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The function takes an array of 
                    <code>VkSubmitInfo</code>
                    &nbsp;structures as argument for efficiency when the workload is much larger.
				</p>
			</li>
			<li>
				<p>
                    The last parameter references an optional fence that will be signaled when the command buffers finish execution.
				</p>
			</li>
			<li>
				<p>
                    This allows us to know when it is safe for the command buffer to be reused, thus we want to give it 
                    <code>drawFence</code>
                    . Now we want the CPU to wait while the GPU finishes rendering that frame we just submitted:
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="presentation" >
    Presentation
</h3>
<ul>
	<li>
		<p>
            The last step of drawing a frame is submitting the result back to the Swapchain to have it 
			<em>
                eventually show up
			</em>
            &nbsp;on the screen.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Presentation Engine
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250818172910.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkPresentInfoKHR</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>pWaitSemaphores</code>
				</p>
				<ul>
					<li>
						<p>
                            Which semaphores to wait on before presentation can happen, just like 
                            <code>VkSubmitInfo</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Since we want to wait on the command buffer to finish execution, thus our triangle being drawn, we take the semaphores which will be signaled and wait on them, thus we use 
                            <code>signalSemaphores</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The next two parameters specify the Swapchains to present images to and the index of the image for each Swapchain.
				</p>
			</li>
			<li>
				<p>
                    This will almost always be single.
				</p>
			</li>
			<li>
				<p>
                    <code>pResults</code>
				</p>
				<ul>
					<li>
						<p>
                            It allows you to specify an array of 
                            <code>VkResult</code>
                            &nbsp;values to check for every Swapchain if presentation was successful.
						</p>
					</li>
					<li>
						<p>
                            It‚Äôs not necessary if you‚Äôre only using a single Swapchain, because you can use the return value of the present function.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>QueuePresentKHR()</code>
		</p>
		<ul>
			<li>
				<p>
                    Submits a rendered image to the presentation queue.
				</p>
			</li>
			<li>
				<p>
                    Used after queueing all rendering commands and transitioning the image to the correct layout.
				</p>
			</li>
			<li>
				<p>
                    Vulkan transfers ownership of the image to the 'presentation engine'.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How a presentation happens
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Who
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
							<em>
                                GPU
							</em>
                            &nbsp;(via the display controller/hardware), orchestrated by the 
							<em>
                                OS/window system
							</em>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        When
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            At the next vertical blanking interval (
							<strong>
                                Vblank
							</strong>
                            ).
						</p>
						<ul>
							<li>
								<p>
									<strong>
                                        Vblank
									</strong>
                                    &nbsp;is the moment between screen refreshes (e.g., at 60 Hz, every 16.67 ms).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            In a Vulkan workflow, we can be sure that the presentation happened between the 
                            <code>QueuePresentKHR()</code>
                            &nbsp;and the 
                            <code>vkAcquireNextImageKHR()</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    The job of the 
                                    <code>present_complete_semaphore</code>
                                    &nbsp;is to hold this information.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        How
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The GPU's 
							<em>
                                display controller
							</em>
                            &nbsp;reads the image from GPU memory.
						</p>
					</li>
					<li>
						<p>
                            The OS/window system (e.g., X11/Wayland on Linux, Win32 on Windows) composites the image into the application window.
						</p>
					</li>
					<li>
						<p>
                            The final output is scanned out to the display.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Image recycling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    After presentation, the image is released back to the swapchain.
				</p>
			</li>
			<li>
				<p>
                    It becomes available for re-acquisition via 
                    <code>vkAcquireNextImageKHR</code>
                    &nbsp;(after the next vblank).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="synchronization-and-cache-control" >
    Synchronization and Cache Control
</h2>
<ul>
	<li>
		<p>
            <img src="assets/image_20250801134239.png" width="540" >
            .
		</p>
	</li>
</ul>
<h5
	id="khr_synchronization2" >
    KHR_synchronization2
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/extensions/KHR_synchronization2.html#KHR_synchronization2" 
				class="external-link" 
				target="_blank" >
                <code>KHR_synchronization2</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Nvidia: Use 
            <code>KHR_synchronization2</code>
            , the new functions allow the application to describe barriers more accurately.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Highlights
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    One main change with the extension is to have pipeline stages and access flags now specified together in memory barrier structures.
				</p>
				<ul>
					<li>
						<p>
                            This makes the connection between the two more obvious.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Due to running out of the 32 bits for 
                    <code>VkAccessFlag</code>
                    &nbsp;the 
                    <code>VkAccessFlags2KHR</code>
                    &nbsp;type was created with a 64-bit range. To prevent the same issue for 
                    <code>VkPipelineStageFlags</code>
                    , the 
                    <code>VkPipelineStageFlags2KHR</code>
                    &nbsp;type was also created with a 64-bit range.
				</p>
			</li>
			<li>
				<p>
                    Adds 2 new image layouts 
                    <code>IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR</code>
                    &nbsp;and 
                    <code>IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR</code>
                    &nbsp;to help with making layout transition easier.
				</p>
			</li>
			<li>
				<p>
                    etc.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="queues" >
    Queues
</h3>
<ul>
	<li>
		<p>
            Any synchronization applies globally to a 
            <code>VkQueue</code>
            , there is no concept of a only-inside-this-command-buffer synchronization.
		</p>
	</li>
	<li>
		<p>
            Graphics pipelines are executable on queues supporting 
            <code>QUEUE_GRAPHICS</code>
            . Stages executed by graphics pipelines 
			<strong>
                can
			</strong>
            &nbsp;only be specified in commands recorded for queues supporting 
            <code>QUEUE_GRAPHICS</code>
            .
		</p>
	</li>
</ul>
<h5
	id="queueidle-and-deviceidle" >
    QueueIdle and DeviceIdle
</h5>
<ul>
	<li>
		<p>
            These functions can be used as a very rudimentary way to perform synchronization.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Closing the program
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We should wait for the logical device to finish operations before exiting 
                    <code>mainLoop</code>
                    &nbsp;and destroying the window.
				</p>
			</li>
			<li>
				<p>
                    You can also wait for operations in a specific command queue to be finished with 
                    <code>vkQueueWaitIdle</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    You‚Äôll see that the program now exits without problems when closing the window.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Problem
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The problem of 
                    <code>vkDeviceWaitIdle</code>
                    &nbsp;or 
                    <code>vkQueueWaitIdle</code>
                    , due to the lack of fences for 
                    <code>vkQueuePresent</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            See 
                            <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#recreating">
                            Vulkan#Recreating
                            </a>
                            , about 
                            <code>EXT_swapchain_maintenance1</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use 
                    <code>EXT_swapchain_maintenance1</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    See 
                    <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#recreating">
                    Vulkan#Recreating
                    </a>
                    , for usage with swapchain.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731212325.png" width="425" >
            .
		</p>
	</li>
</ul>
<h5
	id="queue-family-ownership-transfer" >
    Queue Family Ownership Transfer
</h5>
<ul>
	<li>
		<p>
            Resources created with a 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkSharingMode" 
				class="external-link" 
				target="_blank" >
                VkSharingMode
			</a>
            &nbsp;of 
            <code>SHARING_MODE_EXCLUSIVE</code>
            &nbsp;
			<strong>
                must
			</strong>
            &nbsp;have their ownership explicitly transferred from one queue family to another in order to access their content in a well-defined manner on a queue in a different queue family.
		</p>
	</li>
	<li>
		<p>
            Resources shared with external APIs or instances using external memory 
			<strong>
                must
			</strong>
            &nbsp;also explicitly manage ownership transfers between local and external queues (or equivalent constructs in external APIs) regardless of the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkSharingMode" 
				class="external-link" 
				target="_blank" >
                VkSharingMode
			</a>
            &nbsp;specified when creating them.
		</p>
	</li>
	<li>
		<p>
            If you need to transfer ownership to a different queue family, you need memory barriers, one in each queue to release/acquire ownership.
		</p>
	</li>
	<li>
		<p>
            If memory dependencies are correctly expressed between uses of such a resource between two queues in different families, but no ownership transfer is defined, the contents of that resource are undefined for any read accesses performed by the second queue family.
		</p>
	</li>
	<li>
		<p>
            A queue family ownership transfer consists of two distinct parts:
		</p>
		<ol>
			<li>
				<p>
                    Release exclusive ownership from the source queue family
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers-release" 
								class="external-link" 
								target="_blank" >
                                queue family release operation
							</a>
						</p>
					</li>
					<li>
						<p>
                            Is defined when 
                            <code>dstQueueFamilyIndex</code>
                            &nbsp;is one of those values.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Acquire exclusive ownership for the destination queue family
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers-acquire" 
								class="external-link" 
								target="_blank" >
                                queue family acquire operation
							</a>
						</p>
					</li>
					<li>
						<p>
                            Is defined when 
                            <code>srcQueueFamilyIndex</code>
                            &nbsp;is one of those values.
						</p>
					</li>
				</ul>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    Is defined if the values 
					<strong>
                        are not equal,
					</strong>
                    &nbsp;and either is one of the special queue family values reserved for external memory ownership transfers
				</p>
			</li>
			<li>
				<p>
                    An application 
					<strong>
                        must
					</strong>
                    &nbsp;ensure that these operations occur in the correct order by defining an execution dependency between them, e.g. using a semaphore.
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        release operation
					</em>
                    &nbsp;is used to release exclusive ownership of a range of a buffer or image subresource range. A release operation is defined by executing a 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-buffer-memory-barriers" 
						class="external-link" 
						target="_blank" >
                        buffer memory barrier
					</a>
                    &nbsp;(for a buffer range) or an 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-image-memory-barriers" 
						class="external-link" 
						target="_blank" >
                        image memory barrier
					</a>
                    &nbsp;(for an image subresource range) using a pipeline barrier command, on a queue from the source queue family.
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Etc, I haven't read much about it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="command-buffers" >
    Command Buffers
</h5>
<ul>
	<li>
		<p>
            The specification states that commands start execution in-order, but complete out-of-order. Don‚Äôt get confused by this. The fact that commands start in-order is simply convenient language to make the spec language easier to write.
		</p>
	</li>
	<li>
		<p>
            Unless you add synchronization yourself, all commands in a queue execute out of order. Reordering may happen across command buffers and even 
            <code>vkQueueSubmits</code>
            .
		</p>
	</li>
	<li>
		<p>
            This makes sense, considering that Vulkan only sees a linear stream of commands once you submit, it is a pitfall to assume that splitting command buffers or submits adds some magic synchronization for you.
		</p>
	</li>
	<li>
		<p>
            Frame buffer operations inside a render pass happen in API-order, of course. This is a special exception which the spec calls out.
		</p>
	</li>
</ul>
<h5
	id="queue-submissions-vkqueuesubmit" >
    Queue Submissions (vkQueueSubmit)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#devsandqueues-submission" 
				class="external-link" 
				target="_blank" >
                Queue submission commands
			</a>
		</p>
	</li>
	<li>
		<p>
            It automatically performs a 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-submission-host-writes" 
				class="external-link" 
				target="_blank" >
                domain operation from host to device
			</a>
            &nbsp;for all writes performed before the command executes, so in most cases an explicit memory barrier is not needed for this case.
		</p>
	</li>
	<li>
		<p>
            In the few circumstances where a submit does not occur between the host write and the device read access, writes 
			<strong>
                can
			</strong>
            &nbsp;be made available by using an explicit memory barrier.
		</p>
	</li>
</ul>
<h5
	id="example" >
    Example
</h5>
<ul>
	<li>
		<p>
            <code>vkCmdDispatch (PIPELINE_STAGE_COMPUTE_SHADER)</code>
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdCopyBuffer (PIPELINE_STAGE_TRANSFER)</code>
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdDispatch (PIPELINE_STAGE_COMPUTE_SHADER)</code>
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdPipelineBarrier (srcStageMask = PIPELINE_STAGE_COMPUTE_SHADER)</code>
		</p>
	</li>
	<li>
		<p>
            We would be referring to the two 
            <code>vkCmdDispatch</code>
            &nbsp;commands, as they perform their work in the COMPUTE stage. Even if we split these 4 commands into 4 different 
            <code>vkQueueSubmits</code>
            , we would still consider the same commands for synchronization.
		</p>
	</li>
	<li>
		<p>
            Essentially, the work we are waiting for is 
			<em>
                all commands which have ever been submitted to the queue including any previous commands in the command buffer we‚Äôre recording.
			</em>
		</p>
	</li>
</ul>
<h3
	id="blocking-operations" >
    Blocking Operations
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250929150320.png" width="600" >
            .
		</p>
		<ul>
			<li>
				<p>
                    By Samsung 2019.
				</p>
			</li>
			<li>
				<p>
                    I don't know if this information is still valid.
				</p>
			</li>
			<li>
				<p>
                    See the Mobile section for optimizations of 
                    <code>vkQueuePresent</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="examples" >
    Examples
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/synchronization_examples.html" 
				class="external-link" 
				target="_blank" >
                Synchronization examples
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Example 1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
                    &nbsp;‚Äì writes to an SSBO, 
                    <code>ACCESS_SHADER_WRITE</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = TRANSFER, srcAccessMask = SHADER_WRITE, dstAccessMask = 0)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = TRANSFER, dstStageMask = COMPUTE, srcAccessMask = 0, dstAccessMask = SHADER_READ)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
                    &nbsp;‚Äì read from the same SSBO, 
                    <code>ACCESS_SHADER_READ</code>
				</p>
			</li>
			<li>
				<p>
                    While 
                    <code>StageMask</code>
                    &nbsp;cannot be 0, 
                    <code>AccessMask</code>
                    &nbsp;can be 0.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Recently allocated image, to use in a compute shader as a storage image
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The pipeline barrier looks like:
				</p>
				<ul>
					<li>
						<p>
                            <code>oldLayout = UNDEFINED</code>
						</p>
						<ul>
							<li>
								<p>
                                    Input is garbage
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>newLayout = GENERAL</code>
						</p>
						<ul>
							<li>
								<p>
                                    Storage image compatible layout
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcStageMask = TOP_OF_PIPE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Wait for nothing
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcAccessMask = 0</code>
						</p>
						<ul>
							<li>
								<p>
                                    This is key, there are no pending writes to flush out.
								</p>
							</li>
							<li>
								<p>
                                    This is the only way to use 
                                    <code>TOP_OF_PIPE</code>
                                    &nbsp;in a memory barrier.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstStageMask = COMPUTE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Unblock compute after the layout transition is done
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstAccessMask = SHADER_READ | SHADER_WRITE</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Swapchain Image Transition to PRESENT_SRC
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We have to transition them into 
                    <code>IMAGE_LAYOUT_PRESENT_SRC</code>
                    &nbsp;before passing the image over to the presentation engine.
				</p>
			</li>
			<li>
				<p>
                    Having 
                    <code>dstStageMask = BOTTOM_OF_PIPE</code>
                    &nbsp;and 
                    <code>dstAccessMask = 0</code>
                    &nbsp;is perfectly fine. We don‚Äôt care about making this memory 
					<strong>
                        visible
					</strong>
                    &nbsp;to any stage beyond this point. We will use semaphores to synchronize with the presentation engine anyways.
				</p>
			</li>
			<li>
				<p>
                    The pipeline barrier looks like:
				</p>
				<ul>
					<li>
						<p>
                            <code>srcStageMask = COLOR_ATTACHMENT_OUTPUT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Assuming we rendered to swapchain in a render pass.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcAccessMask = COLOR_ATTACHMENT_WRITE</code>
						</p>
					</li>
					<li>
						<p>
                            <code>dstStageMask = BOTTOM_OF_PIPE</code>
						</p>
						<ul>
							<li>
								<p>
                                    After transitioning into this 
                                    <code>PRESENT</code>
                                    &nbsp;layout, we‚Äôre not going to touch the image again until we reacquire the image, so 
                                    <code>dstStageMask = BOTTOM_OF_PIPE</code>
                                    &nbsp;is appropriate.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstAccessMask = 0</code>
						</p>
					</li>
					<li>
						<p>
                            <code>oldLayout = COLOR_ATTACHMENT_OPTIMAL</code>
						</p>
					</li>
					<li>
						<p>
                            <code>newLayout = PRESENT_SRC_KHR</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Setting 
                    <code>dstAccessMask = 0</code>
                    &nbsp;on the final 
                    <code>TRANSFER_DST ‚Üí PRESENT_SRC_KHR</code>
                    &nbsp;barrier means ‚Äúthere is no 
					<em>
                        GPU
					</em>
                    &nbsp;access after this barrier that we are ordering/expressing.‚Äù For swapchain-present that is intentional and common: presentation is outside the GPU pipeline, so the barrier only needs to make the 
					<em>
                        producer
					</em>
                    &nbsp;writes (e.g. your blit 
                    <code>TRANSFER_WRITE</code>
                    ) available/visible; the presentation engine performs its own, external visibility semantics.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example 1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = FRAGMENT_SHADER, dstStageMask = ?)</code>
				</p>
			</li>
			<li>
				<p>
                    Vertex shading for future commands can begin executing early, we only need to wait once 
                    <code>FRAGMENT_SHADER</code>
                    &nbsp;is reached.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example 2
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    {5, 6, 7} must wait for {1, 2, 3}.
				</p>
			</li>
			<li>
				<p>
                    A possible execution order here could be:
				</p>
				<ul>
					<li>
						<p>
                            #3
						</p>
					</li>
					<li>
						<p>
                            #2
						</p>
					</li>
					<li>
						<p>
                            #1
						</p>
					</li>
					<li>
						<p>
                            #7
						</p>
					</li>
					<li>
						<p>
                            #6
						</p>
					</li>
					<li>
						<p>
                            #5
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {1, 2, 3} can execute out-of-order, and so can {5, 6, 7}, but these two sets of commands can not interleave execution.
				</p>
			</li>
			<li>
				<p>
                    In spec lingo {1, 2, 3} 
					<em>
                        happens-before
					</em>
                    &nbsp;{5, 6, 7}.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Chain of Dependencies (1)
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = TRANSFER)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = TRANSFER, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    {5, 6} must wait for {1, 2}.
				</p>
			</li>
			<li>
				<p>
                    We created a chain of dependencies between COMPUTE -&gt; TRANSFER -&gt; COMPUTE.
				</p>
			</li>
			<li>
				<p>
                    When we wait for TRANSFER in 4, we must also wait for anything which is currently blocking TRANSFER.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Chain of dependencies (2)
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = TRANSFER)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdMagicDummyTransferOperation</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = TRANSFER, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    {4} must wait for {1, 2}.
				</p>
			</li>
			<li>
				<p>
                    {6, 7} must wait for {4}.
				</p>
			</li>
			<li>
				<p>
                    The chain is {1, 2} -&gt; {4} -&gt; {6, 7}, and if {4} is noop (no operation), {1, 2} -&gt; {6, 7} is achieved.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="execution-dependencies-memory-dependencies-memory-model" >
    Execution Dependencies, Memory Dependencies, Memory Model
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-model" 
				class="external-link" 
				target="_blank" >
                Memory Model
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-model-availability-visibility" 
						class="external-link" 
						target="_blank" >
                        Availability and Visibility
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="data-hazards" >
    Data hazards
</h5>
<ul>
	<li>
		<p>
			<em>
                Execution dependencies
			</em>
            &nbsp;and 
			<em>
                memory dependencies
			</em>
            &nbsp;are used to solve data hazards, i.e. to ensure that read and write operations occur in a well-defined order.
		</p>
		<ul>
			<li>
				<p>
                    An 
					<em>
                        operation
					</em>
                    &nbsp;is an arbitrary amount of work to be executed on the host, a device, or an external entity such as a presentation engine.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Write-after-read hazards
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can be solved with just an execution dependency
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Read-after-write hazards
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Need appropriate memory dependencies to be included between them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Write-after-write hazards
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Need appropriate memory dependencies to be included between them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If an application does not include dependencies to solve these hazards, the results and execution orders of memory accesses are 
			<strong>
                undefined
			</strong>
            .
		</p>
	</li>
</ul>
<h5
	id="execution-dependencies" >
    Execution Dependencies
</h5>
<ul>
	<li>
		<p>
            An 
			<em>
                execution dependency
			</em>
            &nbsp;is a guarantee that for two sets of operations, the first set 
			<strong>
                must
			</strong>
            &nbsp;happen-before the second set. If an operation happens-before another operation, then the first operation 
			<strong>
                must
			</strong>
            &nbsp;complete before the second operation is initiated.
		</p>
	</li>
	<li>
		<p>
			<em>
                Execution dependencies
			</em>
            &nbsp;alone are not sufficient to guarantee that values resulting from writes in one set of operations 
			<strong>
                can
			</strong>
            &nbsp;be read from another set of operations.
		</p>
	</li>
</ul>
<h5
	id="memory-available" >
    Memory Available
</h5>
<ul>
	<li>
		<p>
            Availability operations cause the values generated by specified memory write accesses to become 
			<em>
                available
			</em>
            &nbsp;for future access.
		</p>
	</li>
	<li>
		<p>
            Any 
			<em>
                available
			</em>
            &nbsp;value remains available until a subsequent write to the same memory location occurs (whether it is made available or not) or the memory is freed.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Availability operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cause the values generated by specified memory write accesses to become 
					<em>
                        available
					</em>
                    &nbsp;to a memory domain for future access. Any available value remains available until a subsequent write to the same memory location occurs (whether it is made available or not) or the memory is freed.
				</p>
			</li>
			<li>
				<p>
                    Even with coherent mapping, you still need to have a dependency between the host writing that memory and the GPU operation reading it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We can say ‚Äúmaking memory available‚Äù is all about flushing caches.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#vkFlushMappedMemoryRanges" 
				class="external-link" 
				target="_blank" >
                <code>vkFlushMappedMemoryRanges()</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Guarantees that host writes to the memory ranges described by 
                    <code>pMemoryRanges</code>
                    &nbsp;
					<strong>
                        can
					</strong>
                    &nbsp;be made 
					<em>
                        available
					</em>
                    &nbsp;to device access, via 
					<em>
                        availability operations
					</em>
                    &nbsp;from the 
                    <code>ACCESS_HOST_WRITE</code>
                    &nbsp;access type.
				</p>
			</li>
			<li>
				<p>
                    This is required for CPU writes, which 
                    <code>HOST_COHERENT</code>
                    &nbsp;effectively provides.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Cache example
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    When our L2 cache contains the most up-to-date data there is, we can say that memory is 
					<em>
                        available
					</em>
                    , as L1 caches connected to L2 can pull in the most up-to-date data there is.
				</p>
			</li>
			<li>
				<p>
                    Once a shader stage writes to memory, the L2 cache no longer has the most up-to-date data there is, so that memory is no longer considered 
					<em>
                        available
					</em>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If other caches try to read from L2, it will see undefined data.
						</p>
					</li>
					<li>
						<p>
                            Whatever wrote that data must make those writes 
							<em>
                                available
							</em>
                            &nbsp;before the data can be made 
							<em>
                                visible
							</em>
                            &nbsp;again.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-domain" >
    Memory Domain
</h5>
<ul>
	<li>
		<p>
			<em>
                Memory domain operations
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cause writes that are available to a source memory domain to become available to a destination memory domain (an example of this is making writes available to the host domain available to the device domain).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-visible" >
    Memory Visible
</h5>
<ul>
	<li>
		<p>
			<strong>
                Visibility operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cause values 
					<em>
                        available
					</em>
                    &nbsp;to a memory domain to become 
					<em>
                        visible
					</em>
                    &nbsp;to specified memory accesses.
				</p>
			</li>
			<li>
				<p>
                    Memory barriers are visibility operations. Without them, you wouldn‚Äôt have visibility of the memory.
				</p>
				<ul>
					<li>
						<p>
                            The execution barrier ensures the completion of a command, but the 
                            <code>srcStageMask</code>
                            , 
                            <code>dstStageMask</code>
                            , 
                            <code>srcAccessMask</code>
                            &nbsp;and 
                            <code>dstAccessMask</code>
                            &nbsp;are what handles availability.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Once written values are made visible to a particular type of memory access, they 
			<strong>
                can
			</strong>
            &nbsp;be read or written by that type of memory access.
		</p>
	</li>
	<li>
		<p>
            We can say ‚Äúmaking memory visible‚Äù is all about invalidating caches.
		</p>
	</li>
	<li>
		<p>
            Availability is a necessary part of visibility, but availability alone is not sufficient.
		</p>
		<ul>
			<li>
				<p>
                    You can do things that might have caused visibility, but because the write was not available, they don‚Äôt actually make the write visible.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Under the hood, visibility is implementation-specific. The pure-visibility parts typically involve forcing lines out of caches and/or invalidating them. But some kinds of visibility may not require even that.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkInvalidateMappedMemoryRanges.html" 
				class="external-link" 
				target="_blank" >
                <code>vkInvalidateMappedMemoryRanges()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Guarantees that device writes to the memory ranges described by 
                    <code>pMemoryRanges</code>
                    , which have been made 
					<em>
                        available
					</em>
                    &nbsp;to the host memory domain using the 
                    <code>ACCESS_HOST_WRITE</code>
                    &nbsp;and 
                    <code>ACCESS_HOST_READ</code>
                    &nbsp;access types, are made 
					<em>
                        visible
					</em>
                    &nbsp;to the host.
				</p>
			</li>
			<li>
				<p>
                    If a range of non-coherent memory is written by the host and then invalidated without first being flushed, its contents are undefined.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="host-coherent" >
    Host Coherent
</h5>
<ul>
	<li>
		<p>
            <code>MEMORY_PROPERTY_HOST_COHERENT</code>
		</p>
		<ul>
			<li>
				<p>
                    If a memory object 
					<em>
                        does
					</em>
                    &nbsp;have this property:
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Writes
							</em>
                            &nbsp;to the memory object from the host are automatically made 
							<em>
                                available
							</em>
                            &nbsp;to the host domain.
						</p>
					</li>
					<li>
						<p>
                            It says that you don't need 
                            <code>vkFlushMappedMemoryRanges()</code>
                            &nbsp;or 
                            <code>vkInvalidateMappedMemoryRanges()</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            This property alone is insufficient for availability. You still need to use synchronization to make sure that reads and writes from CPU and GPU happen in the right order, and you need memory barriers on the GPU side to manage GPU caches (make CPU writes visible to GPU reads, and make GPU writes available to CPU reads).
						</p>
					</li>
					<li>
						<p>
                            Coherency is about &quot;visibility&quot;, but you still need availability.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If a memory object 
					<em>
                        does not
					</em>
                    &nbsp;have this property:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkFlushMappedMemoryRanges()</code>
							<strong>
                                must
							</strong>
                            &nbsp;be called in order to guarantee that writes to the memory object from the host are made 
							<em>
                                available
							</em>
                            &nbsp;to the host domain, where they 
							<strong>
                                can
							</strong>
                            &nbsp;be further made available to the device domain via a domain operation.
						</p>
					</li>
					<li>
						<p>
                            <code>vkInvalidateMappedMemoryRanges()</code>
                            &nbsp;
							<strong>
                                must
							</strong>
                            &nbsp;be called to guarantee that writes which are available to the host domain are made 
							<em>
                                visible
							</em>
                            &nbsp;to host operations.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-dependency" >
    Memory Dependency
</h5>
<ul>
	<li>
		<p>
			<em>
                Memory Dependency
			</em>
            &nbsp;is an 
			<em>
                execution dependency
			</em>
            &nbsp;which includes 
			<em>
                availability
			</em>
            &nbsp;and 
			<em>
                visibility
			</em>
            &nbsp;operations such that:
		</p>
		<ul>
			<li>
				<p>
                    The first set of operations happens-before the 
					<em>
                        availability
					</em>
                    &nbsp;operation.
				</p>
			</li>
			<li>
				<p>
                    The availability operation happens-before the 
					<em>
                        visibility
					</em>
                    &nbsp;operation.
				</p>
			</li>
			<li>
				<p>
                    The visibility operation happens-before the second set of operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It enforces 
			<em>
                availability
			</em>
            &nbsp;and 
			<em>
                visibility
			</em>
            &nbsp;of memory accesses and 
			<em>
                execution order
			</em>
            &nbsp;between two sets of operations.
		</p>
	</li>
	<li>
		<p>
            Most synchronization commands in Vulkan define a memory dependency.
		</p>
	</li>
	<li>
		<p>
            The specific memory accesses that are made 
			<em>
                available
			</em>
            &nbsp;and 
			<em>
                visible
			</em>
            &nbsp;are defined by the 
			<em>
                access scopes
			</em>
            &nbsp;of a memory dependency.
		</p>
	</li>
	<li>
		<p>
            Any type of access that is in a memory dependency‚Äôs 
			<em>
                first access scope
			</em>
            &nbsp;is made 
			<em>
                available
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Any type of access that is in a memory dependency‚Äôs 
			<em>
                second access scope
			</em>
            &nbsp;has any available writes made 
			<em>
                visible
			</em>
            &nbsp;to it.
		</p>
	</li>
	<li>
		<p>
            Any type of operation that is not in a synchronization command‚Äôs access scopes will not be included in the resulting dependency.
		</p>
	</li>
</ul>
<h3
	id="execution-stages" >
    Execution Stages
</h3>
<ul>
	<li>
		<p>
            The Stage Masks are a bit-mask, so it‚Äôs perfectly fine to wait for both X and Y work.
		</p>
	</li>
	<li>
		<p>
            By specifying the source and target stages, you tell the driver what operations need to finish before the transition can execute, and what must not have started yet.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Use optimal 
            <code>srcStageMask</code>
            &nbsp;and 
            <code>dstStageMask</code>
            . Most important cases: If the specified resources are accessed only in compute or fragment shaders, use the compute or the fragment stage bits for both masks, to make the barrier fragment-only or compute-only.
		</p>
	</li>
	<li>
		<p>
            Caio: &quot;Wait for 
            <code>srcStageMask</code>
            &nbsp;to finish, before 
            <code>dstStageMask</code>
            &nbsp;can start&quot;.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929151911.png" width="459" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929142618.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929154614.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929154642.png" width="600" >
            .
		</p>
	</li>
</ul>
<h5
	id="first-synchronization-scope" >
    First synchronization scope
</h5>
<ul>
	<li>
		<p>
            <code>srcStageMask</code>
		</p>
	</li>
	<li>
		<p>
            This represents what we are waiting for.
		</p>
	</li>
	<li>
		<p>
            &quot;What operations need to finish before the transition can execute&quot;.
		</p>
	</li>
</ul>
<h5
	id="second-synchronization-scope" >
    Second synchronization scope
</h5>
<ul>
	<li>
		<p>
            <code>dstStageMask</code>
		</p>
	</li>
	<li>
		<p>
            &quot;What operations must not have started yet&quot;.
		</p>
	</li>
	<li>
		<p>
            Any work submitted after this barrier will need to wait for the work represented by 
            <code>srcStageMask</code>
            &nbsp;before it can execute.
		</p>
	</li>
</ul>
<h5
	id="stages" >
    Stages
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlagBits2.html" 
				class="external-link" 
				target="_blank" >
                VkPipelineStageFlagBits2
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>TOP_OF_PIPE</code>
            &nbsp;and 
            <code>BOTTOM_OF_PIPE</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    These stages are essentially ‚Äúhelper‚Äù stages, which do no actual work, but serve some important purposes. Every command will first execute the 
                    <code>TOP_OF_PIPE</code>
                    &nbsp;stage. This is basically the command processor on the GPU parsing the command. 
                    <code>BOTTOM_OF_PIPE</code>
                    &nbsp;is where commands retire after all work has been done.
				</p>
			</li>
			<li>
				<p>
                    Both these pipeline stages are deprecated, and applications should prefer 
                    <code>ALL_COMMANDS</code>
                    &nbsp;and 
                    <code>NONE</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Memory Access
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Never use 
                            <code>AccessMask != 0</code>
                            &nbsp;with these stages. These stages 
							<strong>
                                do not perform memory accesses
							</strong>
                            . Any 
                            <code>srcAccessMask</code>
                            &nbsp;and 
                            <code>dstAccessMask</code>
                            &nbsp;combination with either stage will be meaningless, and spec disallows this.
						</p>
					</li>
					<li>
						<p>
                            <code>TOP_OF_PIPE</code>
                            &nbsp;and 
                            <code>BOTTOM_OF_PIPE</code>
                            &nbsp;are purely there for the sake of execution barriers, not memory barriers.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>TOP_OF_PIPE</code>
		</p>
		<ul>
			<li>
				<p>
                    In the first scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>NONE</code>
						</p>
					</li>
					<li>
						<p>
                            Is basically saying ‚Äúwait for nothing‚Äù, or to be more precise, we‚Äôre waiting for the GPU to parse all commands.
						</p>
						<ul>
							<li>
								<p>
                                    We had to parse all commands before getting to the pipeline barrier command to begin with.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In the second scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>ALL_COMMANDS</code>
                            &nbsp;with 
                            <code>VkAccessFlags2</code>
                            &nbsp;set to 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>BOTTOM_OF_PIPE</code>
		</p>
		<ul>
			<li>
				<p>
                    In the first scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>ALL_COMMANDS</code>
                            , with 
                            <code>VkAccessFlags2</code>
                            &nbsp;set to 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In the second scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>NONE</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Basically translates to ‚Äúblock the last stage of execution in the pipeline‚Äù.
						</p>
					</li>
					<li>
						<p>
                            ‚ÄúNo work after this barrier is going to wait for us‚Äù.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>NONE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies no stages of execution.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>ALL_COMMANDS</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies all operations performed by all commands supported on the queue it is used with.
				</p>
			</li>
			<li>
				<p>
                    Basically drains the entire queue for work.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>ALL_GRAPHICS</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies the execution of all graphics pipeline stages.
				</p>
			</li>
			<li>
				<p>
                    It's the same as 
                    <code>ALL_COMMANDS</code>
                    , but only for render passes.
				</p>
			</li>
			<li>
				<p>
                    Is equivalent to the logical OR of:
				</p>
				<ul>
					<li>
						<p>
                            <code>DRAW_INDIRECT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>COPY_INDIRECT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TASK_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>MESH_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>VERTEX_INPUT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>VERTEX_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TESSELLATION_CONTROL_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TESSELLATION_EVALUATION_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>GEOMETRY_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>FRAGMENT_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>EARLY_FRAGMENT_TESTS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>LATE_FRAGMENT_TESTS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>COLOR_ATTACHMENT_OUTPUT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>CONDITIONAL_RENDERING</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TRANSFORM_FEEDBACK</code>
						</p>
					</li>
					<li>
						<p>
                            <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>FRAGMENT_DENSITY_PROCESS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>SUBPASS_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>INVOCATION_MASK</code>
						</p>
					</li>
					<li>
						<p>
                            <code>CLUSTER_CULLING_SHADER</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="order-of-execution-stages" >
    Order of execution stages
</h5>
<ul>
	<li>
		<p>
            Ignoring 
            <code>TOP_OF_PIPE</code>
            &nbsp;and 
            <code>BOTTOM_OF_PIPE</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Graphics primitive pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
				<ul>
					<li>
						<p>
                            Parses indirect buffers.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>COPY_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>INDEX_INPUT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>VERTEX_ATTRIBUTE_INPUT</code>
				</p>
				<ul>
					<li>
						<p>
                            Consumes fixed function VBOs and IBOs
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VERTEX_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TESSELLATION_CONTROL_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TESSELLATION_EVALUATION_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>GEOMETRY_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TRANSFORM_FEEDBACK</code>
				</p>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>EARLY_FRAGMENT_TESTS</code>
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Early
							</em>
                            &nbsp;depth/stencil tests.
						</p>
					</li>
					<li>
						<p>
                            Render pass performs its 
                            <code>loadOp</code>
                            &nbsp;of a depth/stencil attachment.
						</p>
					</li>
					<li>
						<p>
                            This stage isn‚Äôt all that useful or meaningful except in some very obscure scenarios with frame buffer self-dependencies (aka, 
                            <code>GL_ARB_texture_barrier</code>
                            ).
						</p>
					</li>
					<li>
						<p>
                            When blocking a render pass with 
                            <code>dstStageMask</code>
                            , just use a mask of 
                            <code>EARLY_FRAGMENT_TESTS | LATE_FRAGMENT_TESTS</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>dstStageMask = EARLY_FRAGMENT_TESTS</code>
                            &nbsp;alone might work since that will block 
                            <code>loadOp</code>
                            , but there might be shenanigans with memory barriers if you are 100% pedantic about any memory access happening in 
                            <code>LATE_FRAGMENT_TESTS</code>
                            . If you‚Äôre blocking an early stage, it never hurts to block a later stage as well.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>LATE_FRAGMENT_TESTS</code>
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Late
							</em>
                            &nbsp;depth-stencil tests.
						</p>
					</li>
					<li>
						<p>
                            Render pass performs its 
                            <code>storeOp</code>
                            &nbsp;of a depth/stencil attachment when a render pass is done.
						</p>
					</li>
					<li>
						<p>
                            When you‚Äôre waiting for a depth map to have been rendered in an earlier render pass, you should use 
                            <code>srcStageMask = LATE_FRAGMENT_TESTS</code>
                            , as that will wait for the 
                            <code>storeOp</code>
                            &nbsp;to finish its work.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>COLOR_ATTACHMENT_OUTPUT</code>
				</p>
				<ul>
					<li>
						<p>
                            This one is where 
                            <code>loadOp</code>
                            , 
                            <code>storeOp</code>
                            , MSAA resolves and frame buffer blend stage takes place.
						</p>
					</li>
					<li>
						<p>
                            Basically anything that touches a color attachment in a render pass in some way.
						</p>
					</li>
					<li>
						<p>
                            If you‚Äôre waiting for a render pass which uses color to be complete, use 
                            <code>srcStageMask = COLOR_ATTACHMENT_OUTPUT</code>
                            , and similar for 
                            <code>dstStageMask</code>
                            &nbsp;when blocking render passes from execution.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Usage as 
                                <code>dstStageMask</code>
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <code>COLOR_ATTACHMENT_OUTPUT</code>
                                    &nbsp;is the appropriate 
                                    <code>dstStageMask</code>
                                    &nbsp;when you are transitioning an image so it can be written as a color attachment.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Graphics mesh pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TASK_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>MESH_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>EARLY_FRAGMENT_TESTS</code>
				</p>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>LATE_FRAGMENT_TESTS</code>
				</p>
			</li>
			<li>
				<p>
                    <code>COLOR_ATTACHMENT_OUTPUT</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Compute pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>COPY_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>COMPUTE_SHADER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transfer pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>COPY_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TRANSFER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Subpass shading pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>SUBPASS_SHADER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Graphics pipeline commands executing in a render pass with a fragment density map attachment
			</strong>
            : (almost unordered)
		</p>
		<ul>
			<li>
				<p>
                    The following pipeline stage where the fragment density map read happens has 
					<em>
                        no particular order
					</em>
                    &nbsp;relative to the other stages.
				</p>
			</li>
			<li>
				<p>
                    It is logically earlier than 
                    <code>EARLY_FRAGMENT_TESTS</code>
                    , so:
				</p>
				<ul>
					<li>
						<p>
                            <code>FRAGMENT_DENSITY_PROCESS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>EARLY_FRAGMENT_TESTS</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Conditional rendering stage
			</strong>
            : (unordered)
		</p>
		<ul>
			<li>
				<p>
                    Is formally part of both the graphics, and the compute pipeline.
				</p>
			</li>
			<li>
				<p>
                    The predicate read has unspecified order relative to other stages of these pipelines:
				</p>
			</li>
			<li>
				<p>
                    <code>CONDITIONAL_RENDERING</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Host operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>HOST</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Command preprocessing pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>COMMAND_PREPROCESS</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Acceleration structure build operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>ACCELERATION_STRUCTURE_BUILD</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Acceleration structure copy operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>ACCELERATION_STRUCTURE_COPY</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Opacity micromap build operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>MICROMAP_BUILD</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ray tracing pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>RAY_TRACING_SHADER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Video decode pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VIDEO_DECODE</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Video encode pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VIDEO_ENCODE</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Data graph pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DATA_GRAPH</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="memory-access" >
    Memory Access
</h3>
<ul>
	<li>
		<p>
			<em>
                Access scopes
			</em>
            &nbsp;do not interact with the logically earlier or later stages for either scope - only the stages the application specifies are considered part of each access scope.
		</p>
	</li>
	<li>
		<p>
            These flags represent memory access that can be performed.
		</p>
	</li>
	<li>
		<p>
            Each pipeline stage can perform certain memory accesses, and thus we take the combination of pipeline stage + access mask and we get potentially a very large number of incoherent caches on the system.
		</p>
	</li>
	<li>
		<p>
            Each GPU core has its own set of L1 caches as well.
		</p>
	</li>
	<li>
		<p>
            Real GPUs will only have a fraction of the possible caches here, but as long as we are explicit about this in the API, any GPU driver can simplify this as needed.
		</p>
	</li>
	<li>
		<p>
            Access masks either read from a cache, or write to an L1 cache in our mental model.
		</p>
	</li>
	<li>
		<p>
            Certain access types are only performed by a subset of pipeline stages.
		</p>
	</li>
	<li>
		<p>
            &quot;Had this access (
            <code>srcAccessMask</code>
            ) and it's going to have this access (
            <code>dstAccessMask</code>
            )&quot;.
		</p>
	</li>
	<li>
		<p>
            <code>srcAccessMask</code>
		</p>
		<ul>
			<li>
				<p>
                    Lists the access types that happened 
					<em>
                        before
					</em>
                    &nbsp;the barrier (the producer accesses) and that must be made available/visible by the barrier.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Must describe the kinds of accesses that actually happened before the barrier (the producer accesses you need to make available/visible)
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    It does 
					<em>
                        not
					</em>
                    &nbsp;describe what you want the resource to become after the barrier ‚Äî that is expressed by 
                    <code>dstAccessMask</code>
                    &nbsp;(what will happen after).
				</p>
			</li>
			<li>
				<p>
                    The stage masks (src/dst stage) specify the pipeline stages that contain those accesses.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        <code>srcAccessMask = 0</code>
					</strong>
                    &nbsp;means ‚Äúthere are no prior GPU memory accesses that this barrier needs to make available‚Äù (i.e. nothing to claim as the producer side).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>dstAccessMask</code>
		</p>
		<ul>
			<li>
				<p>
                    Lists the access types that will happen 
					<em>
                        after
					</em>
                    &nbsp;the barrier (the consumer accesses) and that must see the producer‚Äôs writes.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        <code>dstAccessMask = 0</code>
					</strong>
                    &nbsp;means ‚Äúthere are no subsequent GPU memory accesses that this barrier needs to order/make visible to‚Äù (i.e. no GPU consumer to describe with access bits).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="access-flags" >
    Access Flags
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlagBits2.html" 
				class="external-link" 
				target="_blank" >
                <code>VkAccessFlagBits2</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>MEMORY_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies all read accesses.
				</p>
			</li>
			<li>
				<p>
                    It is always valid in any access mask, and is treated as equivalent to setting all 
                    <code>READ</code>
                    &nbsp;access flags that are valid where it is used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEMORY_WRITE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies all write accesses.
				</p>
			</li>
			<li>
				<p>
                    It is always valid in any access mask, and is treated as equivalent to setting all 
                    <code>WRITE</code>
                    &nbsp;access flags that are valid where it is used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>SHADER_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Same as 
                    <code>SAMPLED_READ</code>
                    &nbsp;+ 
                    <code>STORAGE_READ</code>
                    &nbsp;+ 
                    <code>TILE_ATTACHMENT_READ</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>SHADER_SAMPLED_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies read access to a 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-uniformtexelbuffer" 
						class="external-link" 
						target="_blank" >
                        uniform texel buffer
					</a>
                    &nbsp;or 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-sampledimage" 
						class="external-link" 
						target="_blank" >
                        sampled image
					</a>
                    &nbsp;in any shader pipeline stage.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>HOST_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies read access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.
				</p>
			</li>
			<li>
				<p>
                    Such access occurs in the 
                    <code>PIPELINE_STAGE_2_HOST</code>
                    &nbsp;pipeline stage.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>HOST_WRITE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies write access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.
				</p>
			</li>
			<li>
				<p>
                    Such access occurs in the 
                    <code>PIPELINE_STAGE_2_HOST</code>
                    &nbsp;pipeline stage.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="access-flag-gt-pipeline-stages" >
    Access Flag -&gt; Pipeline Stages
</h5>
<p
	class="table" >
    | Access flag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Pipeline stages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    |-----------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    <br>
    | 
    <code>NONE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Any&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INDIRECT_COMMAND_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DRAW_INDIRECT</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>COPY_INDIRECT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INDEX_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_INPUT</code>
    , 
    <code>INDEX_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>VERTEX_ATTRIBUTE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_INPUT</code>
    , 
    <code>VERTEX_ATTRIBUTE_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INPUT_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>SHADER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>MICROMAP_BUILD</code>
    , 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COLOR_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COLOR_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>EARLY_FRAGMENT_TESTS</code>
    , 
    <code>LATE_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DEPTH_STENCIL_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>EARLY_FRAGMENT_TESTS</code>
    , 
    <code>LATE_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ALL_TRANSFER</code>
    , 
    <code>COPY</code>
    , 
    <code>RESOLVE</code>
    , 
    <code>BLIT</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    , 
    <code>MICROMAP_BUILD</code>
    , 
    <code>CONVERT_COOPERATIVE_VECTOR_MATRIX</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ALL_TRANSFER</code>
    , 
    <code>COPY</code>
    , 
    <code>RESOLVE</code>
    , 
    <code>BLIT</code>
    , 
    <code>CLEAR</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    , 
    <code>MICROMAP_BUILD</code>
    , 
    <code>CONVERT_COOPERATIVE_VECTOR_MATRIX</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>HOST_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>HOST</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>HOST_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>HOST</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MEMORY_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Any&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MEMORY_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Any&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_SAMPLED_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_STORAGE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_STORAGE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_DECODE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VIDEO_DECODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_DECODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_DECODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_ENCODE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VIDEO_ENCODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_ENCODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_ENCODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>TRANSFORM_FEEDBACK_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>TRANSFORM_FEEDBACK_COUNTER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DRAW_INDIRECT</code>
    , 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFORM_FEEDBACK_COUNTER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>CONDITIONAL_RENDERING_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>CONDITIONAL_RENDERING</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>COMMAND_PREPROCESS_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>COMMAND_PREPROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COMMAND_PREPROCESS_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>COMMAND_PREPROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT_READ</code>
    &nbsp;| 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    , 
    <code>SUBPASS_SHADER</code>
    &nbsp;|
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>FRAGMENT_DENSITY_MAP_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_DENSITY_PROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COLOR_ATTACHMENT_READ_NONCOHERENT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>DESCRIPTOR_BUFFER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INVOCATION_MASK_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>INVOCATION_MASK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>MICROMAP_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>MICROMAP_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MICROMAP_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>MICROMAP_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>OPTICAL_FLOW_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>OPTICAL_FLOW</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>OPTICAL_FLOW_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>OPTICAL_FLOW</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_TILE_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>SHADER_TILE_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>DATA_GRAPH_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DATA_GRAPH</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DATA_GRAPH_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>DATA_GRAPH</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<h5
	id="pipeline-stage-gt-access-flags" >
    Pipeline Stage -&gt; Access Flags
</h5>
<p
	class="table" >
    | Pipeline stage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Access flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>ACCELERATION_STRUCTURE_WRITE</code>
    , 
    <code>INDIRECT_COMMAND_READ</code>
    , 
    <code>MICROMAP_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>ACCELERATION_STRUCTURE_WRITE</code>
    , 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>ALL_TRANSFER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>ANY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>MEMORY_READ</code>
    , 
    <code>MEMORY_WRITE</code>
    , 
    <code>NONE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>BLIT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>CLEAR</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>COLOR_ATTACHMENT_READ</code>
    , 
    <code>COLOR_ATTACHMENT_READ_NONCOHERENT</code>
    , 
    <code>COLOR_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>COMMAND_PREPROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>COMMAND_PREPROCESS_READ</code>
    , 
    <code>COMMAND_PREPROCESS_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COMPUTE_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_READ</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>CONDITIONAL_RENDERING</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>CONDITIONAL_RENDERING_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>CONVERT_COOPERATIVE_VECTOR_MATRIX</code>
    &nbsp;| 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COPY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COPY_INDIRECT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INDIRECT_COMMAND_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DATA_GRAPH</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>DATA_GRAPH_READ</code>
    , 
    <code>DATA_GRAPH_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DRAW_INDIRECT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INDIRECT_COMMAND_READ</code>
    , 
    <code>TRANSFORM_FEEDBACK_COUNTER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>EARLY_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    , 
    <code>DEPTH_STENCIL_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>FRAGMENT_DENSITY_PROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>FRAGMENT_DENSITY_MAP_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>FRAGMENT_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>COLOR_ATTACHMENT_READ</code>
    , 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>INPUT_ATTACHMENT_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_READ</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;|
    <br>
    | 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
    &nbsp; | 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>GEOMETRY_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>HOST</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>HOST_READ</code>
    , 
    <code>HOST_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INDEX_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INDEX_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>INVOCATION_MASK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INVOCATION_MASK_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>LATE_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    , 
    <code>DEPTH_STENCIL_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MESH_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>MICROMAP_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>MICROMAP_READ</code>
    , 
    <code>MICROMAP_WRITE</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>OPTICAL_FLOW</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>OPTICAL_FLOW_READ</code>
    , 
    <code>OPTICAL_FLOW_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>RAY_TRACING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>RESOLVE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SUBPASS_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>INPUT_ATTACHMENT_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>TASK_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TESSELLATION_CONTROL_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    &nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFORM_FEEDBACK_COUNTER_READ</code>
    , 
    <code>TRANSFORM_FEEDBACK_COUNTER_WRITE</code>
    , 
    <code>TRANSFORM_FEEDBACK_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VERTEX_ATTRIBUTE_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_ATTRIBUTE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VERTEX_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>INDEX_READ</code>
    , 
    <code>VERTEX_ATTRIBUTE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VERTEX_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>VIDEO_DECODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_DECODE_READ</code>
    , 
    <code>VIDEO_DECODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_ENCODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_ENCODE_READ</code>
    , 
    <code>VIDEO_ENCODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<h3
	id="pipeline-barriers" >
    Pipeline Barriers
</h3>
<ul>
	<li>
		<p>
            Pipeline barriers also provide synchronization control within a command buffer, but at a single point, rather than with separate signal and wait operations. Pipeline barriers 
			<strong>
                can
			</strong>
            &nbsp;be used to control resource access within a single queue.
		</p>
	</li>
	<li>
		<p>
            Gives control over which pipeline stages need to wait on previous pipeline stages when a command buffer is executed.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Minimize the use of barriers. A barrier may cause a GPU pipeline flush. We have seen redundant barriers and associated wait for idle operations as a major performance problem for ports to modern APIs.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Prefer a buffer/image barrier rather than a memory barrier to allow the driver to better optimize and schedule the barrier, unless the memory barrier allows to merge many buffer/image barriers together.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Group barriers in one call to 
            <code>vkCmdPipelineBarrier2()</code>
            . This way, the worst case can be picked instead of sequentially going through all barriers.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Don‚Äôt insert redundant barriers; this limits parallelism; avoid read-to-read barriers.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdPipelineBarrier2()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    When submitted to a queue, it defines memory dependencies between commands that were submitted to the same queue 
					<em>
                        before
					</em>
                    &nbsp;it, and those submitted to the same queue 
					<em>
                        after
					</em>
                    &nbsp;it.
				</p>
			</li>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the command buffer into which the command is recorded.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDependencyInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDependencyInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Specifies the dependency information for a synchronization command.
						</p>
					</li>
					<li>
						<p>
                            This structure defines a set of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
								class="external-link" 
								target="_blank" >
                                memory dependencies
							</a>
                            , as well as 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
								class="external-link" 
								target="_blank" >
                                queue family ownership transfer operations
							</a>
                            &nbsp;and 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-image-layout-transitions" 
								class="external-link" 
								target="_blank" >
                                image layout transitions
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Each member of 
                            <code>pMemoryBarriers</code>
                            , 
                            <code>pBufferMemoryBarriers</code>
                            , and 
                            <code>pImageMemoryBarriers</code>
                            &nbsp;defines a separate 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
								class="external-link" 
								target="_blank" >
                                memory dependency
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>dependencyFlags</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkDependencyFlagBits</code>
									</a>
								</p>
							</li>
							<li>
								<p>
                                    Specifies how execution and memory dependencies are formed.
								</p>
							</li>
							<li>
								<p>
                                    <code>DEPENDENCY_BY_REGION</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that dependencies will be 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-framebuffer-regions" 
												class="external-link" 
												target="_blank" >
                                                framebuffer-local
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>DEPENDENCY_VIEW_LOCAL</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that dependencies will be 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-view-local-dependencies" 
												class="external-link" 
												target="_blank" >
                                                view-local
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>DEPENDENCY_DEVICE_GROUP</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that dependencies are 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-device-local-dependencies" 
												class="external-link" 
												target="_blank" >
                                                non-device-local
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>DEPENDENCY_FEEDBACK_LOOP_EXT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that the render pass will write to and read from the same image with 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-feedbackloop" 
												class="external-link" 
												target="_blank" >
                                                feedback loop enabled
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_KHR</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that source and destination stages are not ignored when performing a 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
												class="external-link" 
												target="_blank" >
                                                queue family ownership transfer
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>DEPENDENCY_ASYMMETRIC_EVENT_KHR</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2.html" 
												class="external-link" 
												target="_blank" >
                                                vkCmdSetEvent2
											</a>
                                            &nbsp;
											<strong>
                                                must
											</strong>
                                            &nbsp;only include the 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-pipeline-stages-masks" 
												class="external-link" 
												target="_blank" >
                                                source stage mask
											</a>
                                            &nbsp;of the first synchronization scope, and that 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2.html" 
												class="external-link" 
												target="_blank" >
                                                vkCmdWaitEvents2
											</a>
                                            &nbsp;
											<strong>
                                                must
											</strong>
                                            &nbsp;specify the complete barrier.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryBarrierCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pMemoryBarriers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pMemoryBarriers</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrier2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkMemoryBarrier2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies a global memory barrier.
								</p>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstAccessMask</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>bufferMemoryBarrierCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pBufferMemoryBarriers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pBufferMemoryBarriers</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferMemoryBarrier2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkBufferMemoryBarrier2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies a buffer memory barrier.
								</p>
							</li>
							<li>
								<p>
                                    Defines a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
										class="external-link" 
										target="_blank" >
                                        memory dependency
									</a>
                                    &nbsp;limited to a range of a buffer, and 
									<strong>
                                        can
									</strong>
                                    &nbsp;define a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
										class="external-link" 
										target="_blank" >
                                        queue family ownership transfer operation
									</a>
                                    &nbsp;for that range.
								</p>
							</li>
							<li>
								<p>
                                    Both 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-access-scopes" 
										class="external-link" 
										target="_blank" >
                                        access scopes
									</a>
                                    &nbsp;are limited to only memory accesses to 
                                    <code>buffer</code>
                                    &nbsp;in the range defined by 
                                    <code>offset</code>
                                    &nbsp;and 
                                    <code>size</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>buffer</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a handle to the buffer whose backing memory is affected by the barrier.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>offset</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is an offset in bytes into the backing memory for 
                                            <code>buffer</code>
                                            ; this is relative to the base offset as bound to the buffer (see 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory.html" 
												class="external-link" 
												target="_blank" >
                                                vkBindBufferMemory
											</a>
                                            ).
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>size</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a size in bytes of the affected area of backing memory for 
                                            <code>buffer</code>
                                            , or 
                                            <code>WHOLE_SIZE</code>
                                            &nbsp;to use the range from 
                                            <code>offset</code>
                                            &nbsp;to the end of the buffer.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>imageMemoryBarrierCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pImageMemoryBarriers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pImageMemoryBarriers</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkImageMemoryBarrier2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies an image memory barrier.
								</p>
							</li>
							<li>
								<p>
                                    Defines a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
										class="external-link" 
										target="_blank" >
                                        memory dependency
									</a>
                                    &nbsp;limited to an image subresource range, and 
									<strong>
                                        can
									</strong>
                                    &nbsp;define a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
										class="external-link" 
										target="_blank" >
                                        queue family ownership transfer operation
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-image-layout-transitions" 
										class="external-link" 
										target="_blank" >
                                        image layout transition
									</a>
                                    &nbsp;for that subresource range.
								</p>
							</li>
							<li>
								<p>
									<strong>
                                        Image Transition
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If 
                                            <code>oldLayout</code>
                                            &nbsp;is not equal to 
                                            <code>newLayout</code>
                                            , then the memory barrier defines an image layout transition for the specified image subresource range.
										</p>
									</li>
									<li>
										<p>
                                            If this memory barrier defines a 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
												class="external-link" 
												target="_blank" >
                                                queue family ownership transfer operation
											</a>
                                            , the layout transition is only executed once between the queues.
										</p>
									</li>
									<li>
										<p>
                                            When the old and new layout are equal, the layout values are ignored - data is preserved no matter what values are specified, or what layout the image is currently in.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>oldLayout</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>newLayout</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>image</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a handle to the image affected by this barrier.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>subresourceRange</code>
								</p>
								<ul>
									<li>
										<p>
                                            Describes the 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-image-views" 
												class="external-link" 
												target="_blank" >
                                                image subresource range
											</a>
                                            &nbsp;within 
                                            <code>image</code>
                                            &nbsp;that is affected by this barrier.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="execution-barrier" >
    Execution Barrier
</h4>
<ul>
	<li>
		<p>
            Every command you submit to Vulkan goes through a set of stages. Draw calls, copy commands and compute dispatches all go through pipeline stages one by one. This represents the heart of the Vulkan synchronization model.
		</p>
	</li>
	<li>
		<p>
            Operations performed by synchronization commands (e.g. 
			<em>
                availability operations
			</em>
            &nbsp;and 
			<em>
                visibility operations
			</em>
            ) are not executed by a defined pipeline stage. However other commands can still synchronize with them by using the synchronization scopes to create a dependency chain.
		</p>
	</li>
	<li>
		<p>
            When we synchronize work in Vulkan, we synchronize work happening in these pipeline stages as a whole, and not individual commands of work.
		</p>
	</li>
	<li>
		<p>
            Vulkan does not let you add fine-grained dependencies between individual commands. Instead you get to look at all work which happens in certain pipeline stages.
		</p>
	</li>
</ul>
<h4
	id="memory-barriers" >
    Memory Barriers
</h4>
<ul>
	<li>
		<p>
            Execution order and memory order are two different things.
		</p>
	</li>
	<li>
		<p>
            Memory barriers are the tools we can use to ensure that caches are flushed and our memory writes from commands executed before the barrier are available to the pending after-barrier commands. They are also the tool we can use to invalidate caches so that the latest data is visible to the cores that will execute after-barrier commands.
		</p>
	</li>
	<li>
		<p>
            In contrast to execution barriers, these access masks only apply to the precise stages set in the stage masks, and are not extended to logically earlier and later stages.
		</p>
	</li>
	<li>
		<p>
            GPUs are notorious for having multiple, incoherent caches which all need to be carefully managed to avoid glitched out rendering.
		</p>
	</li>
	<li>
		<p>
            This means that just synchronizing execution alone is not enough to ensure that different units on the GPU can transfer data between themselves.
		</p>
	</li>
	<li>
		<p>
            Memory being 
			<strong>
                available
			</strong>
            &nbsp;and memory being 
			<strong>
                visible
			</strong>
            &nbsp;are an abstraction over the fact that GPUs have incoherent caches.
		</p>
	</li>
	<li>
		<p>
            For GPU reading operations from CPU-written data, a call to 
            <code>vkQueueSubmit</code>
            &nbsp;acts as a host memory dependency on any CPU writes to GPU-accessible memory, so long as those writes were made 
			<em>
                prior
			</em>
            &nbsp;to the function call.
		</p>
	</li>
	<li>
		<p>
            If you need more fine-grained write dependency (you want the GPU to be able to execute some stuff in a batch while you're writing data, for example), or if you need to read data written by the GPU, you need an explicit dependency.
		</p>
	</li>
	<li>
		<p>
            For in-batch GPU reading, this could be handled by an event; the host sets the event after writing the memory, and the command buffer operation that reads the memory first issues 
            <code>vkCmdWaitEvents</code>
            &nbsp;for that event. And you'll need to set the appropriate memory barriers and source/destination stages.
		</p>
	</li>
	<li>
		<p>
            For CPU reading of GPU-written data, this could be an event, a timeline semaphore, or a fence.
		</p>
	</li>
	<li>
		<p>
            But overall, CPU writes to GPU-accessible memory still need some form of synchronization.
		</p>
	</li>
</ul>
<h4
	id="global-memory-barriers" >
    Global Memory Barriers
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrier2.html" 
				class="external-link" 
				target="_blank" >
                <code>VkMemoryBarrier2</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A global memory barrier deals with access to any resource, and it‚Äôs the simplest form of a memory barrier.
		</p>
	</li>
	<li>
		<p>
            In 
            <code>vkCmdPipelineBarrier2</code>
            , we are specifying 4 things to happen in order:
		</p>
		<ul>
			<li>
				<p>
                    Wait for 
                    <code>srcStageMask</code>
                    &nbsp;to complete
				</p>
			</li>
			<li>
				<p>
                    Make all writes performed in possible combinations of 
                    <code>srcStageMask</code>
                    &nbsp;+ 
                    <code>srcAccessMask</code>
                    &nbsp;
					<strong>
                        available
					</strong>
				</p>
			</li>
			<li>
				<p>
                    Make 
					<strong>
                        available
					</strong>
                    &nbsp;memory 
					<strong>
                        visible
					</strong>
                    &nbsp;to possible combinations of 
                    <code>dstStageMask</code>
                    &nbsp;+ 
                    <code>dstAccessMask</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Unblock work in dstStageMask.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A common misconception I see is that 
            <code>_READ</code>
            &nbsp;flags are passed into 
            <code>srcAccessMask</code>
            , but this is 
			<em>
                redundant
			</em>
            .
		</p>
		<ul>
			<li>
				<p>
                    It does not make sense to make reads available.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Ex
					</strong>
                    : you don‚Äôt flush caches when you‚Äôre done reading data.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="buffer-memory-barrier" >
    Buffer Memory Barrier
</h4>
<ul>
	<li>
		<p>
            We‚Äôre just restricting memory availability and visibility to a specific buffer.
		</p>
	</li>
	<li>
		<p>
            TheMaister: No GPU I know of actually cares, I think it makes more sense to just use VkMemoryBarrier rather than bothering with buffer barriers.
		</p>
	</li>
</ul>
<h4
	id="image-memory-barrier-image-layout-transition" >
    Image Memory Barrier / Image Layout Transition
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageLayout.html" 
				class="external-link" 
				target="_blank" >
                <code>VkImageLayout</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Image subresources can be transitioned from one layout to another as part of a 
			<em>
                memory dependency
			</em>
            &nbsp;(e.g. by using an 
			<em>
                image memory barrier
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
            Image layouts transitions are done as part of an image memory barrier.
		</p>
	</li>
	<li>
		<p>
            The layout transition happens in-between the 
			<strong>
                make available
			</strong>
            &nbsp;and 
			<strong>
                make visible
			</strong>
            &nbsp;stages of a memory barrier.
		</p>
	</li>
	<li>
		<p>
            The layout transition itself is considered a read/write operation, and the rules are basically that memory for the image must be 
			<strong>
                available
			</strong>
            &nbsp;before the layout transition takes place.
		</p>
	</li>
	<li>
		<p>
            After a layout transition, that memory is automatically made 
			<strong>
                available
			</strong>
            &nbsp;(but not 
			<strong>
                visible
			</strong>
            !).
		</p>
	</li>
	<li>
		<p>
            Basically, think of the layout transition as some kind of in-place data munging which happens in L2 cache somehow.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If a layout transition is specified in a memory dependency.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                When
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It happens-after the 
					<em>
                        availability
					</em>
                    &nbsp;operations in the memory dependency, and happens-before the 
					<em>
                        visibility
					</em>
                    &nbsp;operations.
				</p>
			</li>
			<li>
				<p>
                    Layout transitions that are performed via image memory barriers execute in their entirety in 
					<em>
                        submission order
					</em>
                    , relative to other image layout transitions submitted to the same queue, including those performed by render passes.
				</p>
			</li>
			<li>
				<p>
                    This ordering of image layout transitions only applies if the implementation performs actual read/write operations during the transition.
				</p>
			</li>
			<li>
				<p>
                    An application 
					<strong>
                        must
					</strong>
                    &nbsp;not rely on ordering of image layout transitions to influence ordering of other commands.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ensure
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Image layout transitions may perform read and write accesses on all memory bound to the image subresource range, so applications 
					<strong>
                        must
					</strong>
                    &nbsp;ensure that all memory writes have been made 
					<em>
                        available
					</em>
                    &nbsp;before a layout transition is executed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Available
			</em>
            &nbsp;memory is automatically made 
			<em>
                visible
			</em>
            &nbsp;to a layout transition, and writes performed by a layout transition are automatically made 
			<em>
                available
			</em>
            .
		</p>
	</li>
</ul>
<h5
	id="old-layout" >
    Old Layout
</h5>
<ul>
	<li>
		<p>
            The old layout 
			<strong>
                must
			</strong>
            &nbsp;either be 
            <code>UNDEFINED</code>
            , or match the current layout of the image subresource range.
		</p>
		<ul>
			<li>
				<p>
                    If the old layout matches the current layout of the image subresource range, the transition preserves the contents of that range.
				</p>
			</li>
			<li>
				<p>
                    If the old layout is 
                    <code>UNDEFINED</code>
                    , the contents of that range 
					<strong>
                        may
					</strong>
                    &nbsp;be discarded. This can provide performance or power benefits.
				</p>
				<ul>
					<li>
						<p>
                            Nvidia: Use 
                            <code>UNDEFINED</code>
                            &nbsp;when the previous content of the image is not needed.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tile-based architectures may be able to avoid flushing tile data to memory, and immediate style renderers may be able to achieve fast metadata clears to reinitialize frame buffer compression state, or similar.
		</p>
	</li>
	<li>
		<p>
            If the contents of an attachment are not needed after a render pass completes, then applications 
			<strong>
                should
			</strong>
            &nbsp;use 
            <code>DONT_CARE</code>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=RPKu3U9uDF4" 
				class="external-link" 
				target="_blank" >
                Why Need the Old Layout in Vulkan Image Transitions
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Cool.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="recently-allocated-image" >
    Recently allocated image
</h5>
<ul>
	<li>
		<p>
            If we just allocated an image and want to start using it, what we want to do is to just perform a layout transition, but we don‚Äôt need to wait for anything in order to do this transition.
		</p>
	</li>
	<li>
		<p>
            It‚Äôs important to note that freshly allocated memory in Vulkan is always considered 
			<strong>
                available
			</strong>
            &nbsp;and 
			<strong>
                visible
			</strong>
            &nbsp;to all stages and access types. You cannot have stale caches when the memory was never accessed.
		</p>
	</li>
</ul>
<h3
	id="events-quotsplit-barriersquot" >
    Events / &quot;Split Barriers&quot;
</h3>
<ul>
	<li>
		<p>
            A way to get overlapping work in-between barriers.
		</p>
	</li>
	<li>
		<p>
            The idea of 
            <code>VkEvent</code>
            &nbsp;is to get some unrelated commands in-between the ‚Äúbefore‚Äù and ‚Äúafter‚Äù set of commands
		</p>
	</li>
	<li>
		<p>
            For advanced compute, this is a very important thing to know about, but not all GPUs and drivers can take advantage of this feature.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Use 
            <code>vkCmdSetEvent2</code>
            &nbsp;and 
            <code>vkCmdWaitEvents2</code>
            &nbsp;to issue an asynchronous barrier to avoid blocking execution.
		</p>
	</li>
</ul>
<h5
	id="example" >
    Example
</h5>
<ul>
	<li>
		<p>
			<strong>
                Example 1
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdSetEvent(event, srcStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdWaitEvent(event, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    The &quot;
					<em>
                        before
					</em>
                    &quot; set is now {
                    <code>1</code>
                    , 
                    <code>2</code>
                    }, and the &quot;
					<em>
                        after
					</em>
                    &quot; set is {
                    <code>6</code>
                    , 
                    <code>7</code>
                    }.
				</p>
			</li>
			<li>
				<p>
                    <code>4</code>
                    &nbsp;here is not affected by any synchronization and it can fill in the parallelism ‚Äúbubble‚Äù we get when draining the GPU of work from 
                    <code>1</code>
                    , 
                    <code>2</code>
                    , 
                    <code>3</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250930091327.png" width="461" >
            .
		</p>
	</li>
</ul>
<h3
	id="semaphores-and-fences" >
    Semaphores and Fences
</h3>
<ul>
	<li>
		<p>
            These objects are signaled as part of a 
            <code>vkQueueSubmit</code>
            .
		</p>
	</li>
	<li>
		<p>
            To signal a semaphore or fence, all previously submitted commands to the queue must complete.
		</p>
	</li>
	<li>
		<p>
            If this were a regular pipeline barrier, we would have 
            <code>srcStageMask = ALL_COMMANDS</code>
            . However, 
			<strong>
                we also get a full memory barrier, in the sense that all pending writes are made available.
			</strong>
            &nbsp;Essentially, 
            <code>srcAccessMask = MEMORY_WRITE</code>
            .
		</p>
	</li>
	<li>
		<p>
            Signaling a fence or semaphore works like a full cache flush. Submitting commands to the Vulkan queue makes all memory access performed by host visible to all stages and access masks. Basically, submitting a batch issues a cache invalidation on host visible memory.
		</p>
	</li>
	<li>
		<p>
            A common mistake is to think that you need to do this invalidation manually when the CPU is writing into staging buffers or similar:
		</p>
		<ul>
			<li>
				<p>
                    <code>srcStageMask = HOST</code>
				</p>
			</li>
			<li>
				<p>
                    <code>dstStageMask = TRANSFER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>srcAccessMask = HOST_WRITE</code>
				</p>
			</li>
			<li>
				<p>
                    <code>dstAccessMask = TRANSFER_READ</code>
				</p>
			</li>
			<li>
				<p>
                    If the write happened before 
                    <code>vkQueueSubmit</code>
                    , this is automatically done for you.
				</p>
			</li>
			<li>
				<p>
                    This kind of barrier is necessary if you are using 
                    <code>vkCmdWaitEvents</code>
                    &nbsp;where you wait for host to signal the event with 
                    <code>vkSetEvent</code>
                    . In that case, you might be writing the necessary host data 
					<strong>
                        after
					</strong>
                    &nbsp;
                    <code>vkQueueSubmit</code>
                    &nbsp;was called, which means you need a pipeline barrier like this. This is not exactly a common use case, but it‚Äôs important to understand when these API constructs are useful.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="semaphore" >
    Semaphore
</h5>
<ul>
	<li>
		<p>
            <code>VkSemaphore</code>
		</p>
	</li>
	<li>
		<p>
            Semaphores facilitate GPU &lt;-&gt; GPU synchronization across Vulkan queues.
		</p>
		<ul>
			<li>
				<p>
                    Used for syncing multiple command buffer submissions one after other.
				</p>
			</li>
			<li>
				<p>
                    The CPU continues running without blocking.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Implicit memory guarantees when waiting for a Semaphore
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    While signalling a semaphore makes all memory 
					<strong>
                        available
					</strong>
                    , waiting for a semaphore makes memory 
					<strong>
                        visible
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    This basically means you do not need a memory barrier if you use synchronization with semaphores since signal/wait pairs of semaphores works like a full memory barrier.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Example
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Queue 1 writes to an SSBO in compute, and consumes that buffer as a UBO in a fragment shader in queue 2.
						</p>
					</li>
					<li>
						<p>
                            We‚Äôre going to assume the buffer was created with 
                            <code>QUEUE_FAMILY_CONCURRENT</code>
                            .
						</p>
					</li>
					<li>
						<p>
							<em>
                                Queue 1
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    <code>vkCmdDispatch</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkQueueSubmit(signal = my_semaphore)</code>
								</p>
							</li>
							<li>
								<p>
                                    There is no pipeline barrier needed here.
								</p>
							</li>
							<li>
								<p>
                                    Signalling the semaphore waits for all commands, and all writes in the dispatch are made 
									<strong>
                                        available
									</strong>
                                    &nbsp;to the device before the semaphore is actually signaled.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Queue 2
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    <code>vkCmdBeginRenderPass</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkCmdDraw</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkCmdEndRenderPass</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkQueueSubmit(wait = my_semaphore, pDstWaitStageMask = FRAGMENT_SHADER)</code>
								</p>
							</li>
							<li>
								<p>
                                    When we wait for the semaphore, we specify which stages should wait for this semaphore, in this case the 
                                    <code>FRAGMENT_SHADER</code>
                                    &nbsp;stage.
								</p>
							</li>
							<li>
								<p>
                                    All relevant memory access is automatically made 
									<strong>
                                        visible
									</strong>
                                    , so we can safely access 
                                    <code>UNIFORM_READ</code>
                                    &nbsp;in 
                                    <code>FRAGMENT_SHADER</code>
                                    &nbsp;stage, without having extra barriers.
								</p>
							</li>
							<li>
								<p>
                                    The semaphores take care of this automatically, nice!
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Basic signaling / waiting
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Let‚Äôs say we have semaphore S and queue operations A and B that we want to execute in order.
						</p>
					</li>
					<li>
						<p>
                            What we tell Vulkan is that operation A will 'signal' semaphore S when it finishes executing, and operation B will 'wait' on semaphore S before it begins executing.
						</p>
					</li>
					<li>
						<p>
                            When operation A finishes, semaphore S will be signaled, while operation B wont start until S is signaled.
						</p>
					</li>
					<li>
						<p>
                            After operation B begins executing, semaphore S is automatically reset back to being unsignaled, allowing it to be used again.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Image Transition on Swapchain Images
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            We need to wait for the image to be acquired, and only then can we perform a layout transition.
						</p>
					</li>
					<li>
						<p>
                            The best way to do this is to use 
                            <code>pDstWaitStageMask = COLOR_ATTACHMENT_OUTPUT</code>
                            , and then use 
                            <code>srcStageMask = COLOR_ATTACHMENT_OUTPUT</code>
                            &nbsp;in a pipeline barrier which transitions the swapchain image after semaphore is signaled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Types of Semaphores
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Binary Semaphores
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            A binary semaphore is either unsignaled or signaled.
						</p>
					</li>
					<li>
						<p>
                            It begins life as unsignaled.
						</p>
					</li>
					<li>
						<p>
                            The way we use a binary semaphore to order queue operations is by providing the same semaphore as a 'signal' semaphore in one queue operation and as a 'wait' semaphore in another queue operation.
						</p>
					</li>
					<li>
						<p>
                            Only binary semaphores will be used in this tutorial, further mention of the term semaphore exclusively refers to binary semaphores.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Timeline Semaphores
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250730164111.png" width="425" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Correctly using the Semaphore for 
                <code>vkQueuePresent</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/swapchain_semaphore_reuse.html" 
						class="external-link" 
						target="_blank" >
                        Swapchain Semaphore Reuse
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Since Vulkan SDK 
					<em>
                        1.4.313
					</em>
                    , the validation layer reports cases where the present wait semaphore is not used safely:
				</p>
				<ul>
					<li>
						<p>
                            This is currently reported as 
                            <code>VUID-vkQueueSubmit-pSignalSemaphores-00067</code>
                            &nbsp;or you may see &quot;your VkSemaphore is being signaled by VkQueue, but it may still be in use by VkSwapchainKHR&quot;
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In this context, 
					<em>
                        safely
					</em>
                    &nbsp;means that the Vulkan specification guarantees the semaphore is no longer in use and can be reused.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        The problem
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>vkQueuePresentKHR</code>
                            &nbsp;is different from the 
                            <code>vkQueueSubmit</code>
                            &nbsp;family of functions in that it does not provide a way to signal a semaphore or a fence (without additional extensions).
						</p>
					</li>
					<li>
						<p>
                            This means there is no way to wait for the presentation signal directly. It also means we don‚Äôt know whether 
                            <code>VkPresentInfoKHR::pWaitSemaphores</code>
                            &nbsp;are still in use by the presentation operation.
						</p>
					</li>
					<li>
						<p>
                            If 
                            <code>vkQueuePresentKHR</code>
                            &nbsp;could signal, then waiting on that signal would confirm that the present queue operation has finished‚Äâ‚Äî‚Äâincluding the wait on 
                            <code>VkPresentInfoKHR::pWaitSemaphores</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            In summary, it‚Äôs not obvious when it‚Äôs safe to reuse present wait semaphores.
						</p>
					</li>
					<li>
						<p>
                            The Vulkan specification does not guarantee that waiting on a 
                            <code>vkQueueSubmit</code>
                            &nbsp;fence also synchronizes presentation operations.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The reuse of presentation resources should rely on 
                    <code>vkAcquireNextImageKHR</code>
                    &nbsp;or additional extensions, rather than on 
                    <code>vkQueueSubmit</code>
                    &nbsp;fences.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Solution options
					</strong>
                    :
				</p>
				<ol>
					<li>
						<p>
                            Allocate one &quot;submit finished&quot; semaphore per swapchain image instead of per in-flight frame.
						</p>
						<ul>
							<li>
								<p>
                                    Allocate the 
                                    <code>submit_semaphores</code>
                                    &nbsp;array based on the number of swapchain images (instead of the number of in-flight frames)
								</p>
							</li>
							<li>
								<p>
                                    Index this array using the acquired swapchain image index (instead of the current in-flight frame index)
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Using 
                            <code>EXT_swapchain_maintenance1</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    See 
                                    <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#recreating">
                                    Vulkan#Recreating
                                    </a>
                                    , for use with the swapchain.
								</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fences" >
    Fences
</h5>
<ul>
	<li>
		<p>
            <code>VkFence</code>
		</p>
	</li>
	<li>
		<p>
            Fences facilitate GPU -&gt; CPU synchronization.
		</p>
		<ul>
			<li>
				<p>
                    Used to know if a command buffer has finished being executed on the GPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            While signalling a fence makes all memory available, it does not make them available to the CPU, just within the device. This is where 
            <code>dstStageMask = PIPELINE_STAGE_HOST</code>
            &nbsp;and 
            <code>dstAccessMask = ACCESS_HOST_READ</code>
            &nbsp;flags come in. If you intend to read back data to the CPU, you must issue a pipeline barrier which makes memory available to the HOST as well.
		</p>
	</li>
	<li>
		<p>
            In our mental model, we can think of this as flushing the GPU L2 cache out to GPU main memory, so that CPU can access it over some bus interface.
		</p>
	</li>
	<li>
		<p>
            In order to signal that fence, any pending writes to that memory must have been made available, so even recycled memory can be safely reused without a memory barrier. This point is kind of subtle, but it really helps your sanity not having to inject memory barriers everywhere.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Similar to semaphores, fences are either in a signaled or unsignaled state.
				</p>
			</li>
			<li>
				<p>
                    Whenever we submit work to execute, we can attach a fence to that work. When the work is finished, the fence will be signaled.
				</p>
			</li>
			<li>
				<p>
                    Then we can make the CPU wait for the fence to be signaled, guaranteeing that the work has finished before the CPU continues.
				</p>
			</li>
			<li>
				<p>
                    Fences must be reset manually to put them back into the unsignaled state.
				</p>
				<ul>
					<li>
						<p>
                            This is because fences are used to control the execution of the CPU, and so the CPU gets to decide when to reset the fence.
						</p>
					</li>
					<li>
						<p>
                            Contrast this to semaphores which are used to order work on the GPU without the CPU being involved.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Unlike the semaphore, the fence 
					<em>
                        does
					</em>
                    &nbsp;block CPU execution.
				</p>
				<ul>
					<li>
						<p>
                            In general, it is preferable to not block the host unless necessary.
						</p>
					</li>
					<li>
						<p>
                            We want to feed the GPU and the host with useful work to do. Waiting on fences to signal is not useful work.
						</p>
					</li>
					<li>
						<p>
                            Thus, we prefer semaphores, or other synchronization primitives not yet covered, to synchronize our work.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Taking a screenshot
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Once we have already done the necessary work on the GPU, we now need to transfer the image from the GPU over to the host and then save the memory to a file.
						</p>
					</li>
					<li>
						<p>
                            We have command buffer A which executes the transfer and fence F. We submit command buffer A with fence F, then immediately tell the host to wait for F to signal. This causes the host to block until command buffer A finishes execution.
						</p>
					</li>
					<li>
						<p>
                            Thus, we are safe to let the host save the file to disk, as the memory transfer has completed.
						</p>
					</li>
					<li>
						<p>
                            Unlike the semaphore example, this example 
							<em>
                                does
							</em>
                            &nbsp;block host execution. This means the host won‚Äôt do anything except wait until the execution has finished. For this case, we had to make sure the transfer was complete before we could save the screenshot to disk.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="main-loop-synchronization" >
    Main Loop Synchronization
</h5>
<ul>
	<li>
        <img src="assets/vulkan_sync.excalidraw" width="475" alt="<excalidraw_not_loaded>" >

	</li>
	<li>
		<p>
            <img src="assets/image_20250730182437.png" width="475" >
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=SjhpwVTJON8" 
						class="external-link" 
						target="_blank" >
                        Explanation
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The entire video is just drawings.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250801083016.png" width="475" >
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=FDHpCVN9nis" 
						class="external-link" 
						target="_blank" >
                        Explanation {0:00 -&gt; 6:38}
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Good illustration.
						</p>
					</li>
					<li>
						<p>
                            The rest of the video is just code.
						</p>
					</li>
					<li>
						<p>
                            Does not comment on Multiple Frames In Flight.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="command-buffers" >
    Command Buffers
</h2>
<ul>
	<li>
		<p>
            Commands in Vulkan, like drawing operations and memory transfers, are not executed directly using function calls. You have to record all the operations you want to perform in command buffer objects.
		</p>
	</li>
	<li>
		<p>
            The advantage of this is that when we are ready to tell Vulkan what we want to do, all the commands are submitted together. Vulkan can more efficiently process the commands since all of them are available together.
		</p>
	</li>
	<li>
		<p>
            In addition, this allows command recording to happen in 
			<em>
                multiple threads
			</em>
            &nbsp;if so desired.
		</p>
	</li>
</ul>
<h3
	id="command-pools" >
    Command Pools
</h3>
<ul>
	<li>
		<p>
            Create and allocate Command Buffers.
		</p>
	</li>
	<li>
		<p>
            Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation across multiple command buffers.
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCommandPool.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCreateCommandPool()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>device</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the logical device that creates the command pool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAllocator</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls host memory allocation as described in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-allocation" 
								class="external-link" 
								target="_blank" >
                                Memory Allocation
							</a>
                            &nbsp;chapter.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCommandPool</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPool.html" 
								class="external-link" 
								target="_blank" >
                                VkCommandPool
							</a>
                            &nbsp;handle in which the created pool is returned.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCreateInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkCommandPoolCreateInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>queueFamilyIndex</code>
						</p>
						<ul>
							<li>
								<p>
                                    Designates a queue family as described in section 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#devsandqueues-queueprops" 
										class="external-link" 
										target="_blank" >
                                        Queue Family Properties
									</a>
                                    . All command buffers allocated from this command pool 
									<strong>
                                        must
									</strong>
                                    &nbsp;be submitted on queues from the same queue family.
								</p>
							</li>
							<li>
								<p>
                                    Command buffers are executed by submitting them on one of the device queues (graphics and presentation queues, for example).
								</p>
							</li>
							<li>
								<p>
                                    Each command pool can only allocate command buffers that are submitted on a single type of queue.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask indicating usage behavior for the pool and command buffers allocated from it.
								</p>
							</li>
							<li>
								<p>
                                    <code>COMMAND_POOL_CREATE_TRANSIENT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Hint that command buffers are rerecorded with new commands very often (may change memory allocation behavior)
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER</code>
								</p>
								<ul>
									<li>
										<p>
                                            Allow command buffers to be rerecorded individually, without this flag they all have to be reset together
										</p>
									</li>
									<li>
										<p>
                                            If we record a command buffer every frame, we want to be able to reset and rerecord over it, thus, this flag should be enabled so a command buffer can be reset individually.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>COMMAND_POOL_CREATE_PROTECTED</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that command buffers allocated from the pool are protected command buffers.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="management" >
    Management
</h5>
<ul>
	<li>
		<p>
            Manages the memory that is used to store the buffers and command buffers are allocated from them.
		</p>
	</li>
	<li>
		<p>
            Destroying a Command Pool, destroys the Command Buffers associated.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Reset the whole Command Pool
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandPool.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkResetCommandPool</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                initial state
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Any primary command buffer allocated from another 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPool.html" 
								class="external-link" 
								target="_blank" >
                                VkCommandPool
							</a>
                            &nbsp;that is in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                recording or executable state
							</a>
                            &nbsp;and has a secondary command buffer allocated from 
                            <code>commandPool</code>
                            &nbsp;recorded into it, becomes 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                invalid
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Free individual Command Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkFreeCommandBuffers()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>device</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the logical device that owns the command pool.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>commandPool</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the command pool from which the command buffers were allocated.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>commandBufferCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pCommandBuffers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pCommandBuffers</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of handles of command buffers to free.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Any primary command buffer that is in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                recording or executable state
							</a>
                            &nbsp;and has any element of 
                            <code>pCommandBuffers</code>
                            &nbsp;recorded into it, becomes 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                invalid
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="command-buffer" >
    Command Buffer
</h3>
<h5
	id="creation-allocation" >
    Creation / Allocation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>VkCommandBuffer</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Encodes GPU commands.
				</p>
			</li>
			<li>
				<p>
                    All execution that is performed on the GPU itself (not in the driver) has to be encoded in a command buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html" 
				class="external-link" 
				target="_blank" >
                <code>vkAllocateCommandBuffers()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>pAllocateInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkCommandBufferAllocateInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>commandPool</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the command pool from which the command buffers are allocated.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>level</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferLevel.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkCommandBufferLevel</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies if the allocated command buffers are primary or secondary command buffers.
								</p>
							</li>
							<li>
								<p>
                                    `COMMAND_BUFFER_LEVEL_PRIMARY
								</p>
								<ul>
									<li>
										<p>
                                            Command Buffer Primary.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    `COMMAND_BUFFER_LEVEL_SECONDARY
								</p>
								<ul>
									<li>
										<p>
                                            Command Buffer Secondary.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>commandBufferCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of command buffers to allocate from the pool.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCommandBuffers</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of Command Buffer handles in which the resulting command buffer objects are returned. The array 
							<em>
                                must
							</em>
                            &nbsp;be at least the length specified by the 
                            <code>commandBufferCount</code>
                            &nbsp;member of 
                            <code>pAllocateInfo</code>
                            . Each allocated command buffer begins in the initial state.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="lifecycle" >
    Lifecycle
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#commandbuffers-lifecycle" 
				class="external-link" 
				target="_blank" >
                Lifecycle
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731200744.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Reset an single Command Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Once a command buffer has been submitted, it‚Äôs still ‚Äúalive‚Äù, and being consumed by the GPU, at this point it is NOT safe to reset the command buffer yet. You need to make sure that the GPU has finished executing all of the commands from that command buffer until you can reset and reuse it.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandBuffer.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkResetCommandBuffer()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>commandBuffer</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the command buffer to reset. The command buffer 
									<strong>
                                        can
									</strong>
                                    &nbsp;be in any state other than 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
										class="external-link" 
										target="_blank" >
                                        pending
									</a>
                                    , and is moved into the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
										class="external-link" 
										target="_blank" >
                                        initial state
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferResetFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkCommandBufferResetFlagBits
									</a>
                                    &nbsp;controlling the reset operation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Any primary command buffer that is in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                recording or executable state
							</a>
                            &nbsp;and has 
                            <code>commandBuffer</code>
                            &nbsp;recorded into it, becomes 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                invalid
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            After a command buffer is reset, any objects or memory specified by commands recorded into the command buffer 
							<strong>
                                must
							</strong>
                            &nbsp;no longer be accessed when the command buffer is accessed by the implementation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If the command buffer was already recorded once, then a call to it will implicitly reset it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="levels" >
    Levels
</h5>
<ul>
	<li>
		<p>
			<strong>
                Primary
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only these can be submitted to queues for execution.
				</p>
			</li>
			<li>
				<p>
                    Cannot be called from other command buffers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Secondary
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cannot be submitted directly, but can be called from primary command buffers.
				</p>
			</li>
			<li>
				<p>
                    &quot;We won‚Äôt make use of the secondary command buffer functionality here, but you can imagine that it‚Äôs helpful to reuse common operations from primary command buffers.&quot;
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteCommands.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCmdExecuteCommands()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            A primary command buffer would use this to execute a secondary command buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Re-recording
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If a secondary moves to the invalid state or the initial state, then all primary buffers it is recorded in move to the invalid state. A primary moving to any other state does not affect the state of a secondary recorded in it.
						</p>
					</li>
					<li>
						<p>
                            So, when a secondary command is re-recorded, the primary becomes invalid.
						</p>
					</li>
					<li>
						<p>
                            Eve: &quot;It is not capturing a reference to a command buffer, it is going through and copying all the commands in the command buffer into itself.&quot;
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="command-types" >
    Command Types
</h5>
<ul>
	<li>
		<p>
            Action-Type, State-Type, Sync-Type.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731202609.png" width="500" >
            .
		</p>
	</li>
</ul>
<h3
	id="command-buffer-recording" >
    Command Buffer Recording
</h3>
<ul>
	<li>
		<p>
            Writes the commands we want to execute into a command buffer.
		</p>
	</li>
	<li>
		<p>
            It‚Äôs not possible to append commands to a buffer at a later time.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkBeginCommandBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>vkBeginCommandBuffer()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the handle of the command buffer which is to be put in the recording state.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pBeginInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferBeginInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkCommandBufferBeginInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Specifies some details about the usage of this specific command buffer.
						</p>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferUsageFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkCommandBufferUsageFlagBits</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies how we‚Äôre going to use the command buffer.
								</p>
							</li>
							<li>
								<p>
                                    <code>COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            The command buffer will be rerecorded right after executing it once.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE</code>
								</p>
								<ul>
									<li>
										<p>
                                            This is a secondary command buffer that will be entirely within a single render pass.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE</code>
								</p>
								<ul>
									<li>
										<p>
                                            The command buffer can be resubmitted while it is also already pending execution.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    None of these flags are applicable for us right now.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pInheritanceInfo</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceInfo.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkCommandBufferInheritanceInfo</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            If the command buffer is a secondary command buffer, then the 
                                            <code>VkCommandBufferInheritanceInfo</code>
                                            &nbsp;structure defines any state that will be inherited from the primary command buffer:
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Used if 
                                    <code>commandBuffer</code>
                                    &nbsp;is a secondary command buffer. If this is a primary command buffer, then this value is ignored.
								</p>
							</li>
							<li>
								<p>
                                    It specifies which state to inherit from the calling primary command buffers.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkEndCommandBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>vkEndCommandBuffer()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The command buffer 
					<strong>
                        must
					</strong>
                    &nbsp;have been in the 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
						class="external-link" 
						target="_blank" >
                        recording state
					</a>
                    , and, if successful, is moved to the 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
						class="external-link" 
						target="_blank" >
                        executable state
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    If there was an error during recording, the application will be notified by an unsuccessful return code returned by 
                    <code>vkEndCommandBuffer</code>
                    , and the command buffer will be moved to the 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
						class="external-link" 
						target="_blank" >
                        invalid state
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="pre-recording" >
    Pre-recording
</h3>
<ul>
	<li>
		<p>
            &quot;Many early Vulkan tutorials and documents recommended writing a command buffer once and re-using it wherever possible. In practice however re-use rarely has the advertized performance benefit while incurring a non-trivial development burden due to the complexity of implementation. While it may appear counterintuitive, as re-using computed data is a common optimization, managing a scene with objects being added and removed as well as techniques such as frustum culling which vary the draw calls issued on a per frame basis make reusing command buffers a serious design challenge. It requires a caching scheme to manage command buffers and maintaining state for determining if and when re-recording becomes necessary. Instead, prefer to re-record fresh command buffers every frame. If performance is a problem, recording can be multithreaded as well as using secondary command buffers for non-variable draw calls, like post processing.&quot;
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/common_pitfalls.html#_recording_command_buffers" 
						class="external-link" 
						target="_blank" >
                        Source
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="multi-threading-recording" >
    Multi-threading Recording
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/command_buffer_usage/README.html#_secondary_command_buffers" 
				class="external-link" 
				target="_blank" >
                Usage of secondary command buffers for Vulkan Multithreaded Recording
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vkguide.dev/docs/extra-chapter/multithreading/#multithreading-vulkan" 
				class="external-link" 
				target="_blank" >
                Usage of secondary command buffers for Vulkan Multithreaded Recording
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    There's a example code section.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                External synchronization
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    A type of synchronization 
					<strong>
                        required
					</strong>
                    &nbsp;of the application, where parameters defined to be externally synchronized 
					<strong>
                        must
					</strong>
                    &nbsp;not be used simultaneously in multiple threads.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Internal Synchronization
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    A type of synchronization 
					<strong>
                        required
					</strong>
                    &nbsp;of the implementation, where parameters not defined to be externally synchronized 
					<strong>
                        may
					</strong>
                    &nbsp;require internal mutexing to avoid multithreaded race conditions.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Any object parameters that are not labeled as externally synchronized are either not mutated by the command or are internally synchronized.
		</p>
	</li>
	<li>
		<p>
            Additionally, certain objects related to a command‚Äôs parameters (e.g. command pools and descriptor pools) 
			<strong>
                may
			</strong>
            &nbsp;be affected by a command, and 
			<strong>
                must
			</strong>
            &nbsp;also be externally synchronized.
		</p>
	</li>
</ul>
<h5
	id="queues" >
    Queues
</h5>
<ul>
	<li>
		<p>
            Only a single thread can be submitting to a given queue at any time. If you want multiple threads doing 
            <code>VkQueueSubmit</code>
            , then you need to create multiple queues.
		</p>
	</li>
	<li>
		<p>
            As the number of queues can be as low as 1 in some devices, what engines tend to do for this is to do something similar to the pipeline compile thread or the OpenGL api call thread, and have a thread dedicated to just doing 
            <code>VkQueueSubmit</code>
            .
		</p>
	</li>
	<li>
		<p>
            As 
            <code>VkQueueSubmit</code>
            &nbsp;is a very expensive operation, this can bring a very nice speedup as the time spent executing that call is done in a second thread and the main logic of the engine doesn‚Äôt have to stop.
		</p>
	</li>
	<li>
		<p>
            Data upload is another section that is very often multithreaded. In here, you have a dedicated IO thread that will load assets to disk, and said IO thread will have its own queue and command allocators, hopefully a transfer queue. This way it is possible to upload assets at a speed completely separated from the main frame loop, so if it takes half a second to upload a set of big textures, you don‚Äôt have a hitch. To do that, you need to create a transfer or async-compute queue (if available), and dedicate that one to the loader thread. Once you have that, it‚Äôs similar to what was commented on the pipeline compiler thread, and you have an IO thread that communicates through a parallel queue with the main simulation loop to upload data in an asynchronous way. Once a transfer has been uploaded, and checked that it has finished with a Fence, then the IO thread can send the info to the main loop, and then the engine can connect the new textures or models into the renderer.
		</p>
	</li>
</ul>
<h5
	id="command-pools" >
    Command Pools
</h5>
<ul>
	<li>
		<p>
            When you record command buffers, their command pools can only be used from one thread at a time. While you can create multiple command buffers from a command pool, you cant fill those commands from multiple threads. If you want to record command buffers from multiple threads, then you will need more command pools, one per thread.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Secondary Command Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vulkan command buffers have a system for primary and secondary command buffers. The primary buffers are the ones that open and close RenderPasses, and can get directly submitted to a queue. Secondary command buffers are used as ‚Äúchild‚Äù command buffers that execute as part of a primary one.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Their main purpose is multithreading.
					</em>
				</p>
			</li>
			<li>
				<p>
                    Secondary command buffers cant be submitted into a queue on their own.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Command Pools are a system to allow recording command buffers across multiple threads.
		</p>
		<ul>
			<li>
				<p>
                    They enable different threads to use different allocators, without internal synchronization on each use.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A single command pool must be 
			<em>
                externally synchronized
			</em>
            ; it must not be accessed simultaneously from multiple threads.
		</p>
		<ul>
			<li>
				<p>
                    That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, free, and reset command buffers or the pool itself.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you want multithreaded command recording, you need more 
            <code>VkCommandPool</code>
            &nbsp;objects. By using a separate command pool in each host-thread the application can create multiple command buffers in parallel without any costly locks.
		</p>
		<ul>
			<li>
				<p>
                    For that reason, we will pair a command buffer with its command allocator.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            You can allocate as many 
            <code>VkCommandBuffer</code>
            &nbsp;as you want from a given pool, but you can only record commands from one thread at a time.
		</p>
	</li>
	<li>
		<p>
            Command buffers can be recorded on multiple threads while having a relatively light thread handle the submissions.
		</p>
	</li>
	<li>
		<p>
            If two commands access the same object or memory and at least one of the commands declares the object to be externally synchronized, then the caller 
			<strong>
                must
			</strong>
            &nbsp;guarantee not only that the commands do not execute simultaneously, but also that the two commands are separated by an appropriate memory barrier (if needed).
		</p>
	</li>
	<li>
		<p>
            Similarly, if a Vulkan command accesses a non-const memory parameter and the application also accesses that memory, or if the application writes to that memory and the command accesses it as a const memory parameter, the application 
			<strong>
                must
			</strong>
            &nbsp;ensure the accesses are properly synchronized with a memory barrier if needed.
		</p>
	</li>
	<li>
		<p>
            Memory barriers are particularly relevant for hosts based on the ARM CPU architecture, which is more weakly ordered than many developers are accustomed to from x86/x64 programming. Fortunately, most higher-level synchronization primitives (like the pthread library) perform memory barriers as a part of mutual exclusion, so mutexing Vulkan objects via these primitives will have the desired effect.
		</p>
	</li>
</ul>
<h2
	id="pipelines" >
    Pipelines
</h2>
<ul>
	<li>
		<p>
            In Vulkan, to execute code on the GPU, we need to set up a pipeline.
		</p>
	</li>
	<li>
		<p>
            There are two types of pipelines, Graphics and Compute:
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Compute pipelines
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Are much simpler, because they only require the data for the shader code, and the layout for the descriptors used for data bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Graphics pipelines
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Have to configure a considerable amount of state for all of the fixed-function hardware in the GPU such as color blending, depth testing, or geometry formats.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Both types of pipelines share the shader modules and the layouts, which are built in the same way.
		</p>
	</li>
	<li>
		<p>
            <code>VkPipeline</code>
		</p>
	</li>
</ul>
<h5
	id="pipeline-layout" >
    Pipeline Layout
</h5>
<ul>
	<li>
		<p>
            A collection of 
            <code>DescriptorSetLayouts</code>
            &nbsp;and 
            <code>PushConstantRange</code>
            &nbsp;defining its push constant usage.
		</p>
	</li>
	<li>
		<p>
            PipelineLayouts for a graphics and compute pipeline are made in the same way, and they must be created before the pipeline itself.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayout.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineLayout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPipelineLayoutCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Structure specifying the parameters of a newly created pipeline layout object
						</p>
					</li>
					<li>
						<p>
                            <code>setLayoutCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of descriptor sets included in the pipeline layout.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pSetLayouts</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
                                    <code>VkDescriptorSetLayout</code>
                                    &nbsp;objects.
								</p>
							</li>
							<li>
								<p>
                                    The implementation 
									<em>
                                        must
									</em>
                                    &nbsp;not access these objects outside of the duration of the command this structure is passed to.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCreatePipelineLayout()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>pCreateInfo</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkPipelineLayoutCreateInfo
									</a>
                                    &nbsp;structure specifying the state of the pipeline layout object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkPipelineLayoutCreateFlagBits
									</a>
                                    &nbsp;specifying options for pipeline layout creation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>setLayoutCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    See 
                                    <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#descriptor-set-layout">
                                    Vulkan#Descriptor Set Layout
                                    </a>
                                    &nbsp;for more information.
								</p>
							</li>
							<li>
								<p>
                                    Is the number of descriptor sets included in the pipeline layout.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pSetLayouts</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
                                    <code>VkDescriptorSetLayout</code>
                                    &nbsp;objects. The implementation 
									<strong>
                                        must
									</strong>
                                    &nbsp;not access these objects outside of the duration of the command this structure is passed to.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pushConstantRangeCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of push constant ranges included in the pipeline layout.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pPushConstantRanges</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushConstantRange.html" 
										class="external-link" 
										target="_blank" >
                                        VkPushConstantRange
									</a>
                                    &nbsp;structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants 
									<strong>
                                        can
									</strong>
                                    &nbsp;be accessed by each stage of the pipeline.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="mesh-shaders" >
    Mesh Shaders
</h3>
<h5
	id="support" >
    Support
</h5>
<ul>
	<li>
		<p>
            (2025-09-12)
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912094010.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            It is important to note that while portability between APIs can be achieved, portability in performance among vendors is much harder. This is one of the reasons why this extension has not been released as a ratified KHR extension and Khronos continues to investigate improvements to geometry rasterization.
		</p>
	</li>
	<li>
		<p>
            There are further aspects that can influence the performance of mesh shaders in a vendor dependent way:
		</p>
		<ul>
			<li>
				<p>
                    The number of maximum output vertices and primitives that a mesh shader is compiled with.
				</p>
			</li>
			<li>
				<p>
                    The number of per-vertex and per-primitive output attributes that are passed to fragment shaders. For example, it may be beneficial to fetch additional attributes in the fragment shader and interpolate them via hardware barycentrics to reduce the output space of the mesh shader.
				</p>
			</li>
			<li>
				<p>
                    The complexity of the culling performed in the mesh shader. For example details regarding the per-vertex and/or per-primitive culling with compact outputs compared to letting the hardware perform culling.
				</p>
			</li>
			<li>
				<p>
                    The usage of additional shared memory. If possible developers should use subgroup operations (such as shuffle) instead.
				</p>
			</li>
			<li>
				<p>
                    The task payload size.
				</p>
			</li>
			<li>
				<p>
                    Task shaders may add overhead, use them only when they can cull a meaningful number of primitives or when actual geometry amplification is desired.
				</p>
			</li>
			<li>
				<p>
                    Do not try to reimplement the fixed-function pipeline, strive for simpler algorithms instead.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909103948.png" width="137" >
            .
		</p>
	</li>
</ul>
<h5
	id="motivation" >
    Motivation
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250912093325.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912092257.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The current state of the Graphics Pipeline is not a direct mapping of how a GPU operates.
		</p>
	</li>
	<li>
		<p>
            There's a lot of Per Vertex -&gt; Per Primitive -&gt; Per Vertex -&gt; Per Primitive happening inside a Graphics Pipeline.
		</p>
	</li>
	<li>
		<p>
            The idea is to use the flexibility of Compute Shaders and use the GPU more closely as it operates.
		</p>
	</li>
	<li>
		<p>
            Mesh and Task shaders follow the compute programming model and use threads cooperatively to generate meshes within a workgroup. The vertex and index data for these meshes are written similarly to shared memory in compute shaders.
		</p>
	</li>
	<li>
		<p>
            Mesh shader output is directly consumed by the rasterizer, as opposed to the previous approach of using a compute dispatch followed by an indirect draw.
		</p>
	</li>
	<li>
		<p>
            Mesh Shading applications can avoid preallocation of output buffers.
		</p>
	</li>
	<li>
		<p>
            Before deciding to use mesh shaders, developers should ensure they are a good fit for their application. The traditional pipeline may still be best suited to many use cases, and it may not be trivial to improve performance using the mesh shading pipeline given the long evolution and optimization efforts applied to the traditional pipeline stages.
		</p>
	</li>
	<li>
		<p>
            Applications and games dealing with 
			<em>
                high geometric complexity
			</em>
            &nbsp;can, however, benefit from the flexibility of the two-stage approach, which allows 
			<em>
                efficient culling
			</em>
            , 
			<em>
                level-of-detail
			</em>
            &nbsp;techniques as well as 
			<em>
                procedural generation
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Compared to the traditional pipeline, the mesh shaders allow easy access to the topology of the generated primitives and developers are free to repurpose the threads to do both vertex shading and primitive shading work. This is in contrast to tessellation shaders, which, while fast, provide very limited control over the triangles created, and geometry shaders, which use a single-thread programming model that is inefficient for modern streaming processors.
		</p>
	</li>
</ul>
<h5
	id="task-shader" >
    Task Shader
</h5>
<ul>
	<li>
		<p>
            Is optional and provides a way to implement geometry amplification by creating variable mesh shader workgroups directly in the pipeline. Task shader workgroups can output an optional payload, which is visible as read-only input to all its child mesh shader workgroups.
		</p>
	</li>
	<li>
		<p>
            A Task Shader decides how many Mesh Shaders you would like to run.
		</p>
	</li>
</ul>
<h5
	id="meshlets-triangle-clusters" >
    Meshlets / Triangle Clusters
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250912093822.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            When rasterizing geometry, mesh shaders typically make use of pre-computed triangle clusters of an upper bound in the number of vertices and triangles, also sometimes referred to as meshlets. Because task and mesh shaders, like compute, have only workgroup and invocation indices as input, all data fetching is handled by the application directly, which entirely removes fixed-function vertex processing and input assembly. This allows developers to be flexible in the storage of mesh data in both vertex and primitive topology representations. Another very common technique is to leverage the task shader and let one local invocation test one cluster for visibility. Through the use of subgroup operations developers can compute and write out information about the visible clusters into the task shader payload.
		</p>
	</li>
	<li>
		<p>
            The meshlet / primitive cluster dimensions can have an especially big impact for the developer, as when streaming it is ideal to store assets with a fixed clustering in advance. Vendors may have different performance recommendations and so we suggest the use of smaller cluster sizes that work equally well across multiple vendors and process multiple small clusters at once on implementations that perform better with larger clusters. In this area we advise developers to experiment and consult with their hardware vendors for recommendations.
		</p>
	</li>
</ul>
<h5
	id="using-it" >
    Using it
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/NV_mesh_shader/mesh.html" 
				class="external-link" 
				target="_blank" >
                Mesh Shading
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The URL comes from 
                    <code>NV_mesh_shader</code>
                    ; maybe it's relevant?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://github.com/nvpro-samples/gl_meshlet_cadscene" 
				class="external-link" 
				target="_blank" >
                gl_meshlet_cadscene
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This OpenGL/Vulkan sample illustrates the use of &quot;mesh shaders&quot; for rendering CAD models.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.gamedev.net/blogs/entry/2293837-insane-draw-call-reduction-with-mesh-shaders-in-vulkan/" 
				class="external-link" 
				target="_blank" >
                Use of Mesh Shader to improve performance - 2024
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912092500.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The recommended idea is a Mesh Shader to operate on a Meshlet.
		</p>
	</li>
</ul>
<h5
	id="what-a-mesh-shader-enables" >
    What a Mesh Shader enables
</h5>
<ul>
	<li>
		<p>
            You can do very early culling.
		</p>
	</li>
	<li>
		<p>
            It can be faster than the classical Graphics Pipeline, if correctly optimized.
		</p>
	</li>
	<li>
		<p>
			<em>
                Mesh Shader output Execution Mode
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The mesh stage will set either 
                    <code>OutputPoints</code>
                    , 
                    <code>OutputLinesEXT</code>
                    , or 
                    <code>OutputTrianglesEXT</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#extension GL_EXT_mesh_shader : require

// Only 1 of the 3 is allowed
layout(points) out;
layout(lines) out;
layout(triangles) out;
</code></pre>
	</li>
</ul>
<h3
	id="cluster-culling-shader" >
    Cluster Culling Shader
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/HUAWEI_cluster_culling_shader/clusterculling.html" 
				class="external-link" 
				target="_blank" >
                Cluster Culling Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>HUAWEI_cluster_culling_shader</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="graphics-pipeline" >
    Graphics Pipeline
</h2>
<ul>
	<li>
		<p>
            The graphics pipeline is required for all common drawing operations.
		</p>
	</li>
	<li>
		<p>
            Holds the state of the GPU needed to draw. For example: shaders, rasterization options, depth settings.
		</p>
	</li>
	<li>
		<p>
            It describes the configurable state of the graphics card, like the viewport size and depth buffer operation and the programmable state using VkShaderModule objects.
		</p>
	</li>
</ul>
<h5
	id="stages" >
    Stages
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250730155932.png" width="600" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250730083345.png" width="218" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Disabling stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The tessellation and geometry stages can be disabled if you are just drawing simple geometry.
				</p>
			</li>
			<li>
				<p>
                    If you are only interested in depth values, then you can disable the fragment shader stage, which is useful for 
					<a
						href="https://en.wikipedia.org/wiki/Shadow_mapping" 
						class="external-link" 
						target="_blank" >
                        shadow map
					</a>
                    &nbsp;generation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Fixed-function stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Allow you to tweak their operations using parameters, but the way they work is predefined.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Dynamic State
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            While 
							<em>
                                most
							</em>
                            &nbsp;of the pipeline state needs to be baked into the pipeline state, a limited amount of the state can actually be changed without recreating the pipeline at draw time.
						</p>
					</li>
					<li>
						<p>
                            Examples are the size of the viewport, line width and blend constants.
						</p>
					</li>
					<li>
						<p>
                            If you want to use dynamic state and keep these properties out, then you‚Äôll have to fill in a 
                            <code>VkPipelineDynamicStateCreateInfo</code>
                            &nbsp;struct.
						</p>
					</li>
					<li>
						<p>
                            This will cause the configuration of these values to be 
							<strong>
                                ignored
							</strong>
                            , and you will be able (and required) to specify the data at drawing time.
						</p>
					</li>
					<li>
						<p>
                            This results in a more flexible setup and is widespread for things like viewport and scissor state, which would result in a more complex setup when being baked into the pipeline state.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Programmable stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Means that you can upload your own code to the graphics card to apply exactly the operations you want.
				</p>
			</li>
			<li>
				<p>
                    This allows you to use fragment shaders, for example, to implement anything from texturing and lighting to ray tracers. These programs run on many GPU cores simultaneously to process many objects, like vertices and fragments in parallel.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Immutability
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is almost completely immutable, so you must recreate the pipeline from scratch if you want to change shaders, bind different framebuffers or change the blend function.
				</p>
			</li>
			<li>
				<p>
                    The disadvantage is that you‚Äôll have to create a number of pipelines (many VkPipeline objects) that represent all the different combinations of states you want to use in your rendering operations. However, because all the operations you‚Äôll be doing in the pipeline are known in advance, the driver can optimize for it much better.
				</p>
				<ul>
					<li>
						<p>
                            Runtime performance is more predictable because large state changes like switching to a different graphics pipeline are made very explicit.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Only some basic configuration, like viewport size and clear color, can be changed dynamically.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="shader-compilation" >
    Shader Compilation
</h3>
<h5
	id="shader-module" >
    Shader Module
</h5>
<ul>
	<li>
		<p>
            A 
            <code>VkShaderModule</code>
            &nbsp;is a processed shader file.
		</p>
	</li>
	<li>
		<p>
            We create it from a pre-compiled SPIR-V file.
		</p>
	</li>
	<li>
		<p>
            We can call 
            <code>vkDestroyShaderModule</code>
            &nbsp;after they are used for the graphics pipeline creation.
		</p>
	</li>
</ul>
<h3
	id="input-assembly" >
    Input Assembly
</h3>
<ul>
	<li>
		<p>
            Fixed-function stage.
		</p>
	</li>
	<li>
		<p>
            Collects the raw vertex data from the buffers you specify and may also use an index buffer to repeat certain elements without having to duplicate the vertex data itself.
		</p>
	</li>
	<li>
		<p>
            <code>VkPipelineVertexInputStateCreateInfo</code>
		</p>
		<ul>
			<li>
				<p>
                    Describes the format of the vertex data that will be passed to the vertex shader.
				</p>
			</li>
			<li>
				<p>
                    <code>pVertexBindingDescriptions</code>
				</p>
				<ul>
					<li>
						<p>
                            Spacing between data and whether the data is per-vertex or per-instance (see 
							<a
								href="https://en.wikipedia.org/wiki/Geometry_instancing" 
								class="external-link" 
								target="_blank" >
                                instancing
							</a>
                            ).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pVertexAttributeDescriptions</code>
				</p>
				<ul>
					<li>
						<p>
                            Type of the attributes passed to the vertex shader, which binding to load them from and at which offset.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineInputAssemblyStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineInputAssemblyStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Describes two things: what kind of geometry will be drawn from the vertices and if primitive restart should be enabled.
				</p>
			</li>
			<li>
				<p>
                    <code>topology</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>PRIMITIVE_TOPOLOGY_POINT_LIST</code>
						</p>
						<ul>
							<li>
								<p>
                                    points from vertices
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>PRIMITIVE_TOPOLOGY_LINE_LIST</code>
						</p>
						<ul>
							<li>
								<p>
                                    line from every two vertices without reuse
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>PRIMITIVE_TOPOLOGY_LINE_STRIP</code>
						</p>
						<ul>
							<li>
								<p>
                                    the end vertex of every line is used as start vertex for the next line
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>
						</p>
						<ul>
							<li>
								<p>
                                    triangle from every three vertices without reuse
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP</code>
						</p>
						<ul>
							<li>
								<p>
                                    the second and third vertex of every triangle is used as first two vertices of the next triangle
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>primitiveRestartEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Normally, the vertices are loaded from the vertex buffer by index in sequential order, but with an 
							<em>
                                element buffer
							</em>
                            &nbsp;you can specify the indices to use yourself.
						</p>
						<ul>
							<li>
								<p>
                                    This allows you to perform optimizations like reusing vertices.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If you set this to 
                            <code>TRUE</code>
                            , then it‚Äôs possible to break up lines and triangles in the 
                            <code>_STRIP</code>
                            &nbsp;topology modes by using a special index of 
                            <code>0xFFFF</code>
                            &nbsp;or 
                            <code>0xFFFFFFFF</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="primitive-topology" >
    Primitive Topology
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250908151239.png" width="450" >
            .
		</p>
	</li>
</ul>
<h3
	id="vertex-shader" >
    Vertex Shader
</h3>
<ul>
	<li>
		<p>
            Programmable stage.
		</p>
	</li>
	<li>
		<p>
            Is run for every vertex and generally applies transformations to turn vertex positions from model space to screen space. It also passes per-vertex data down the pipeline.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VkShaderModule</code>
            &nbsp;objects are created from shader byte code.
		</p>
	</li>
	<li>
		<p>
            Accesses and computes one vertex at a time.
		</p>
	</li>
</ul>
<h3
	id="tessellation-shader" >
    Tessellation Shader
</h3>
<ul>
	<li>
		<p>
            Is run for every vertex and generally applies transformations to turn vertex positions from model space to screen space. It also passes per-vertex data down the pipeline.
		</p>
	</li>
	<li>
		<p>
            You can do tessellation in the Geometry Shader, but the Tessellation Shader is more appropriate and efficient.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081803.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Sending this amount of vertices to the Vertex Shader would be quite more expensive than generating them in the Tessellation Shader.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912082627.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            Tessellation Evaluation Shader.
		</p>
		<ul>
			<li>
				<p>
                    Kinda like a Vertex Shader, after the Tessellation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=OqRMNrvu6TE" 
				class="external-link" 
				target="_blank" >
                Tessellation Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I was too lazy to watch it all.
				</p>
			</li>
			<li>
				<p>
                    The inputs are complicated, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Tessellation output Execution Mode
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The tessellation evaluation stage will set either 
                    <code>Triangles</code>
                    , 
                    <code>Quads</code>
                    , or 
                    <code>Isolines</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Only 1 of the 3 is allowed
layout(quads) in;
layout(isolines) in;
layout(triangles) in;
</code></pre>
	</li>
</ul>
<h3
	id="geometry-shader" >
    Geometry Shader
</h3>
<ul>
	<li>
		<p>
            Programmable stage.
		</p>
	</li>
	<li>
		<p>
            It operates on 
			<strong>
                primitives
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            Is run on every primitive (triangle, line, point) and can discard it or output more primitives than came in. This is similar to the tessellation shader but much more flexible.
		</p>
	</li>
	<li>
		<p>
            However, it is used little in today‚Äôs applications because the 
			<em>
                performance is not that good
			</em>
            &nbsp;on most graphics cards except for Intel‚Äôs integrated GPUs.
		</p>
		<ul>
			<li>
				<p>
                    Also, almost all geometry shader use cases can be replaced with a more modern Mesh shader pipeline, which like ray tracing is a wholly new pipeline solution, so it exists outside the standard graphics pipeline setup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912001248.png" width="450" >
            .
		</p>
	</li>
	<li>
        <img src="assets/image_20250912001941.png" width="400" >

	</li>
	<li>
		<p>
            A Vertex Shader is more parallelized than a Geometry Shader.
		</p>
	</li>
	<li>
		<p>
            A Vertex Shader computes one vertex at a time, while a geometry shader gets all the vertices 
			<strong>
                that compose a primitive
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    It does 
					<strong>
                        not
					</strong>
                    &nbsp;have access to the whole mesh, just the vertices that compose the current primitive.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                OpenGL Primitives
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    May be useful.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912002205.png" width="250" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912002244.png" width="250" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Think of the Primitive Inputs as just the amount of vertices you are sending at a time.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912075205.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            The reason for this is that you can get any primitive input and have any primitive output.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912075909.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Use 
                    <code>EndPrimitive()</code>
                    &nbsp;so the line strips are separated.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912080208.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The Vertex Shader can output data to the Geometry Shader, in the form of an array.
				</p>
			</li>
			<li>
				<p>
                    The Geometry Shader can output data to the Fragment Shader, in a form of an interpolated value, using barycentric coordinates.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Instancing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250912080636.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    You can have many instances of a Geometry Shader, where the input is the same but the output changes.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912080739.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912080803.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081145.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The smoke is a quad facing the camera (billboard).
				</p>
			</li>
			<li>
				<p>
                    The points are converted to quads.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081304.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081335.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Geometry output Execution Mode
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    A geometry stage will set either 
                    <code>OutputPoints</code>
                    , 
                    <code>OutputLineStrip</code>
                    , or 
                    <code>OutputTriangleStrip</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Only 1 of the 3 is allowed
layout(points) out;
layout(line_strip) out;
layout(triangle_strip) out;
</code></pre>
	</li>
</ul>
<h3
	id="rasterization" >
    Rasterization
</h3>
<ul>
	<li>
		<p>
            Fixed-function stage.
		</p>
	</li>
	<li>
		<p>
            Breaks the primitives into 
			<em>
                fragments
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            These are the pixel elements that they fill on the framebuffer.
		</p>
	</li>
	<li>
		<p>
            Any fragments that fall outside the screen are discarded, and the attributes outputted by the vertex shader are interpolated across the fragments.
		</p>
	</li>
	<li>
		<p>
            Fragments that are behind other primitive fragments can also be discarded here because of depth testing.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineRasterizationStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>polygonMode</code>
				</p>
			</li>
			<li>
				<p>
                    <code>lineWidth</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the width of rasterized line segments.
						</p>
					</li>
					<li>
						<p>
                            The maximum line width that is supported depends on the hardware.
						</p>
					</li>
					<li>
						<p>
                            Any line thicker than 
                            <code>1.0f</code>
                            &nbsp;requires you to enable the 
                            <code>wideLines</code>
                            &nbsp;GPU feature.
						</p>
					</li>
					<li>
						<p>
                            If set to 
                            <code>0.0f</code>
                            , you get: 
                            <code>lineWidth</code>
                            &nbsp;is 0.0, but the line width state is static (
                            <code>pCreateInfos[0].pDynamicState-&gt;pDynamicStates</code>
                            &nbsp;does not contain 
                            <code>DYNAMIC_STATE_LINE_WIDTH</code>
                            ) and 
                            <code>wideLines</code>
                            &nbsp;feature was not enabled. The Vulkan spec states: If the pipeline requires pre-rasterization shader state, and the 
                            <code>wideLines</code>
                            &nbsp;feature is not enabled, and no element of the 
                            <code>pDynamicStates</code>
                            &nbsp;member of 
                            <code>pDynamicState</code>
                            &nbsp;is 
                            <code>DYNAMIC_STATE_LINE_WIDTH</code>
                            , the lineWidth member of pRasterizationState 
							<strong>
                                must
							</strong>
                            &nbsp;be 1.0.
						</p>
					</li>
					<li>
						<p>
                            So, set it to 
                            <code>1.0f</code>
                            &nbsp;by default.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>cullMode</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>NONE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that no triangles are discarded
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>FRONT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that front-facing triangles are discarded
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>BACK</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that back-facing triangles are discarded
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>FRONT_AND_BACK</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that all triangles are discarded.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Following culling, fragments are produced for any triangles which have not been discarded.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>frontFace</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the vertex order for the faces to be considered front-facing.
						</p>
					</li>
					<li>
						<p>
                            <code>COUNTER_CLOCKWISE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that a triangle with positive area is considered front-facing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>CLOCKWISE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that a triangle with negative area is considered front-facing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Any triangle which is not front-facing is back-facing, including zero-area triangles.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>rasterizerDiscardEnable</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            When enabled, primitives are discarded after they are processed by the last active shader stage in the pipeline before rasterization.
						</p>
					</li>
					<li>
						<p>
                            Controls whether primitives are discarded immediately before the rasterization stage. This is important because when this is set to 
                            <code>TRUE</code>
                            &nbsp;the rasterization hardware is not executed.
						</p>
					</li>
					<li>
						<p>
                            There are many Validation Usage errors that will not occur if this is set to 
                            <code>TRUE</code>
                            &nbsp;because some topology hardware is unused and can be ignored.
						</p>
					</li>
					<li>
						<p>
                            Enabling this state is meant for very specific use cases. Prior to compute shaders, this was a common technique for writting geometry shader output to a buffer.
						</p>
					</li>
					<li>
						<p>
                            It can be used to debug/profile non-rasterization bottlenecks.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthClampEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasConstantFactor</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasSlopeFactor</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasClamp</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="polygon-mode" >
    Polygon Mode
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250908152312.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            Determines how fragments are generated for geometry.
		</p>
	</li>
	<li>
		<p>
            These modes affect only the 
			<em>
                final
			</em>
            &nbsp;rasterization of polygons. The polygon‚Äôs vertices are shaded and the polygon is clipped and possibly culled before these modes are applied.
		</p>
	</li>
	<li>
		<p>
            <code>FILL</code>
		</p>
		<ul>
			<li>
				<p>
                    Fill the area of the polygon with fragments.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>LINE</code>
		</p>
		<ul>
			<li>
				<p>
                    Polygon edges are drawn as lines
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>POINT</code>
		</p>
		<ul>
			<li>
				<p>
                    Polygon vertices are drawn as points
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>VkPhysicalDeviceMaintenance5Properties</code>
                    ::
                    <code>polygonModePointSize</code>
                    &nbsp;is 
                    <code>TRUE</code>
                    , the point size of the final rasterization of polygons is taken from 
                    <code>PointSize</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Otherwise, the point size of the final rasterization of polygons is 1.0.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>FILL_RECTANGLE_NV</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies that polygons are rendered using polygon rasterization rules, modified to consider a sample within the primitive if the sample location is inside the axis-aligned bounding box of the triangle after projection.
				</p>
			</li>
			<li>
				<p>
                    Note that the barycentric weights used in attribute interpolation 
					<strong>
                        can
					</strong>
                    &nbsp;extend outside the range 
                    <code>[0,1]</code>
                    &nbsp;when these primitives are shaded.
				</p>
			</li>
			<li>
				<p>
                    Special treatment is given to a sample position on the boundary edge of the bounding box. In such a case, if two rectangles lie on either side of a common edge (with identical endpoints) on which a sample position lies, then exactly one of the triangles 
					<strong>
                        must
					</strong>
                    &nbsp;produce a fragment that covers that sample during rasterization.
				</p>
			</li>
			<li>
				<p>
                    Polygons rendered in 
                    <code>FILL_RECTANGLE_NV</code>
                    &nbsp;mode 
					<strong>
                        may
					</strong>
                    &nbsp;be clipped by the frustum or by user clip planes. If clipping is applied, the triangle is culled rather than clipped.
				</p>
			</li>
			<li>
				<p>
                    Area calculation and facingness are determined for 
                    <code>FILL_RECTANGLE_NV</code>
                    &nbsp;mode using the triangle‚Äôs vertices.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you have a vertex shader that has 
            <code>PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>
            &nbsp;input and then during rasterization uses 
            <code>POLYGON_MODE_LINE</code>
            , the effective topology is the Line 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/drawing.html#drawing-primitive-topology-class" 
				class="external-link" 
				target="_blank" >
                Topology Class
			</a>
            &nbsp;at that time. This means something like 
            <code>lineWidth</code>
            &nbsp;would be applied when filling in the polygon with 
            <code>POLYGON_MODE_LINE</code>
            .
		</p>
	</li>
</ul>
<h3
	id="fragment-operations" >
    Fragment Operations
</h3>
<h5
	id="order" >
    Order
</h5>
<ol>
	<li>
		<p>
            Discard rectangles test
		</p>
	</li>
	<li>
		<p>
            Scissor test
		</p>
	</li>
	<li>
		<p>
            Exclusive scissor test
		</p>
	</li>
	<li>
		<p>
            Sample mask test
		</p>
	</li>
	<li>
		<p>
            Certain Fragment shading operations:
		</p>
		<ul>
			<li>
				<p>
                    Sample Mask Accesses
				</p>
			</li>
			<li>
				<p>
                    Tile Image Reads
				</p>
			</li>
			<li>
				<p>
                    Depth Replacement
				</p>
			</li>
			<li>
				<p>
                    Stencil Reference Replacement
				</p>
			</li>
			<li>
				<p>
                    Interlocked Operations
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Multisample coverage
		</p>
	</li>
	<li>
		<p>
            Depth bounds test
		</p>
	</li>
	<li>
		<p>
            Stencil test
		</p>
	</li>
	<li>
		<p>
            Depth test
		</p>
	</li>
	<li>
		<p>
            Representative fragment test
		</p>
	</li>
	<li>
		<p>
            Sample counting
		</p>
	</li>
	<li>
		<p>
            Coverage to color
		</p>
	</li>
	<li>
		<p>
            Coverage reduction
		</p>
	</li>
	<li>
		<p>
            Coverage modulation
		</p>
	</li>
</ol>
<h5
	id="early-per-fragment-tests" >
    Early Per-Fragment Tests
</h5>
<ul>
	<li>
		<p>
            OpenGL 4.6:
		</p>
		<ul>
			<li>
				<p>
                    Once fragments are produced by rasterization, a number of per-fragment operations are performed prior to fragment shader execution. If a fragment is discarded during any of these operations, it will not be processed by any subsequent Stage, including fragment shader execution.
				</p>
			</li>
			<li>
				<p>
                    Three fragment operations are performed, and a further three are optionally performed on each fragment, in the following order:
				</p>
				<ul>
					<li>
						<p>
                            the pixel ownership test (see section 14.9.1);
						</p>
					</li>
					<li>
						<p>
                            the scissor test (see section 14.9.2);
						</p>
					</li>
					<li>
						<p>
                            multisample fragment operations (see section 14.9.3);
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If early per-fragment operations are enabled, these tests are also performed:
				</p>
				<ul>
					<li>
						<p>
                            the stencil test (see section 17.3.3);
						</p>
					</li>
					<li>
						<p>
                            the depth buffer test (see section 17.3.4);
						</p>
						<ul>
							<li>
								<p>
                                    The depth buffer test discards the incoming fragment if a depth comparison fails. The comparison is enabled or disabled with the generic Enable and Disable commands using target DEPTH_TEST. When disabled, the depth comparison and subsequent possible updates to the depth buffer value are bypassed and the fragment is passed to the next operation. The stencil value, however, is modified as indicated below as if the depth buffer test passed. If enabled, the comparison takes place and the depth buffer and stencil value may subsequently be modified.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            occlusion query sample counting (see section 17.3.5)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Early fragment tests, as an optimization, exist to prevent unnecessary executions of the Fragment Shader. If a fragment will be discarded based on the Depth Test (due perhaps to being behind other geometry), it saves performance to avoid executing the fragment shader. There is specialized hardware that makes this particularly efficient in many GPUs.
				</p>
			</li>
			<li>
				<p>
                    The most effective way to use early depth test hardware is to run a depth-only pre-processing pass. This means to render all available geometry, using minimal shaders and a rendering pipeline that only writes to the depth buffer. The Vertex Shader should do nothing more than transform positions, and the Fragment Shader does not even need to exist.
				</p>
			</li>
			<li>
				<p>
                    This provides the best performance gain if the fragment shader is expensive, or if you intend to use multiple passes across the geometry.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Limitations
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The Spec states that these operations happen after fragment processing. However, a specification only defines apparent behavior, so the implementation is only required to behave &quot;as if&quot; it happened afterwards.
						</p>
					</li>
					<li>
						<p>
                            Therefore, an implementation is free to apply early fragment tests if the Fragment Shader being used does not do anything that would impact the results of those tests. So if a fragment shader writes to glFragDepth, thus changing the fragment's depth value, then early testing cannot take place, since the test must use the new computed value.
						</p>
					</li>
					<li>
						<p>
                            Do recall that if a fragment shader writes to gl_FragDepth, even conditionally, it must write to it at least once on all codepaths.
						</p>
					</li>
					<li>
						<p>
                            There can be other hardware-based limitations as well. For example, some hardware will not execute an early depth test if the (deprecated) alpha test is active, as these use the same hardware on that platform. Because this is a hardware-based optimization, OpenGL has no direct controls that will tell you if early depth testing will happen.
						</p>
					</li>
					<li>
						<p>
                            Similarly, if the fragment shader discards the fragment with the discard keyword, this will almost always turn off early depth tests on some hardware. Note that even 
							<em>
                                conditional
							</em>
                            &nbsp;use of discard will mean that the FS will turn off early depth tests.
						</p>
					</li>
					<li>
						<p>
                            All of the above limitations apply only to early testing as an optimization. They do not apply to anything below.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    More recent hardware can force early depth tests, using a special fragment shader layout qualifier:
				</p>
				<ul>
					<li>
						<p>
                            <code>layout(early_fragment_tests)</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Vulkan:
								</p>
								<ul>
									<li>
										<p>
                                            Specifying is a way of the application programmer providing a promise to the implementation that it is algorithmically safe to kill the fragments, so you explicitly allow the change in application-visible behavior.
										</p>
									</li>
									<li>
										<p>
                                            Specifying this will make per-fragment tests be performed before fragment shader execution. If this is not declared, per-fragment tests will be performed after fragment shader execution. Only one fragment shader (compilation unit) need declare this, though more than one can. If at least one declares this, then it is enabled.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    OpenGL 4.6:
								</p>
								<ul>
									<li>
										<p>
                                            An explicit control is provided to allow fragment shaders to enable early fragment tests. If the fragment shader specifies the 
                                            <code>early_fragment_tests</code>
                                            &nbsp;layout qualifier, the per-fragment tests will be performed prior to fragment shader execution. Otherwise, they will be performed after fragment shader execution.
										</p>
									</li>
									<li>
										<p>
                                            This will also perform early stencil tests.
										</p>
									</li>
									<li>
										<p>
                                            There is a caveat with this. This feature 
											<em>
                                                cannot
											</em>
                                            &nbsp;be used to violate the sanctity of the depth test. When this is activated, any writes to 
                                            <code>gl_FragDepth</code>
                                            &nbsp;will be 
											<em>
                                                ignored
											</em>
                                            . The value written to the depth buffer will be exactly what was tested 
											<em>
                                                against
											</em>
                                            &nbsp;the depth buffer: the fragment's depth computed through rasterization.
										</p>
									</li>
									<li>
										<p>
                                            This feature exists to ensure proper behavior when using 
											<a
												href="https://wikis.khronos.org/opengl/Image_Load_Store" 
												class="external-link" 
												target="_blank" >
                                                Image Load Store
											</a>
                                            &nbsp;or other 
											<a
												href="https://wikis.khronos.org/opengl/Incoherent_Memory_Access" 
												class="external-link" 
												target="_blank" >
                                                incoherent memory writing
											</a>
                                            . Without turning this on, fragments that fail the depth test would still perform their Image Load/Store operations, since the fragment shader that performed those operations successfully executed. However, with early fragment tests, those tests were run before the fragment shader. So this ensures that image load/store operations will only happen on fragments that pass the depth test.
										</p>
									</li>
									<li>
										<p>
                                            Enabling this feature has consequences for 
											<a
												href="https://wikis.khronos.org/opengl/Fragment_Discarding" 
												class="external-link" 
												target="_blank" >
                                                the results of a discarded fragment.
											</a>
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="viewport-and-scissors" >
    Viewport and Scissors
</h4>
<ul>
	<li>
		<p>
            A viewport basically describes the region of the framebuffer that the output will be rendered to.
		</p>
	</li>
	<li>
		<p>
            Viewports define the transformation from the image to the framebuffer, scissor rectangles define in which region pixels will actually be stored. The rasterizer will discard any pixels outside the scissored rectangles. They function like a filter rather than a transformation.
		</p>
		<ul>
			<li>
				<p>
                    The difference is illustrated below.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250730113603.png" width="475" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Note that the left scissored rectangle is just one of the many possibilities that would result in that image, as long as it‚Äôs larger than the viewport.
				</p>
			</li>
			<li>
				<p>
                    So if we wanted to draw to the entire framebuffer, we would specify a scissor rectangle that covers it entirely:
				</p>
<pre><code class="language-cpp" data-lang="cpp">vk::Rect2D{ vk::Offset2D{ 0, 0 }, swapChainExtent }
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Parameters
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This will almost always be the rectangle 
                    <code>(0, 0)</code>
                    , 
                    <code>(width, height)</code>
                    &nbsp;and in this tutorial that will also be the case.
				</p>
				<ul>
					<li>
						<p>
                            Remember that the size of the Swapchain and its images may differ from the 
                            <code>WIDTH</code>
                            &nbsp;and 
                            <code>HEIGHT</code>
                            &nbsp;of the window.
						</p>
					</li>
					<li>
						<p>
                            The Swapchain images will be used as framebuffers later on, so we should stick to their size.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The 
                    <code>minDepth</code>
                    &nbsp;and 
                    <code>maxDepth</code>
                    &nbsp;values specify the range of depth values to use for the framebuffer. These values must be within the 
                    <code>[0.0f, 1.0f]</code>
                    &nbsp;range, but 
                    <code>minDepth</code>
                    &nbsp;may be higher than 
                    <code>maxDepth</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If you aren‚Äôt doing anything special, then you should stick to the standard values of 
                            <code>0.0f</code>
                            &nbsp;and 
                            <code>1.0f</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                As a Dynamic State or Static State
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Viewport(s) and scissor rectangle(s) can either be specified as a static part of the pipeline or as a dynamic state set in the command buffer.
				</p>
			</li>
			<li>
				<p>
                    Independent of how you set them, it‚Äôs possible to use multiple viewports and scissor rectangles on some graphics cards, so the structure members reference an array of them. Using multiple requires enabling a GPU feature (see logical device creation).
				</p>
			</li>
			<li>
				<p>
                    It‚Äôs often convenient to make viewport and scissor state dynamic as it gives you a lot more flexibility.
				</p>
			</li>
			<li>
				<p>
					<em>
                        With dynamic state
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It‚Äôs even possible to specify different viewports and or scissor rectangles within a single command buffer.
						</p>
					</li>
					<li>
						<p>
                            This is widespread and all implementations can handle this dynamic state 
							<em>
                                without
							</em>
                            &nbsp;a performance penalty.
						</p>
					</li>
					<li>
						<p>
                            When opting for dynamic viewport(s) and scissor rectangle(s), you need to enable the respective dynamic states for the pipeline:
						</p>
<pre><code class="language-cpp" data-lang="cpp">std::vector dynamicStates = {
&nbsp;&nbsp;&nbsp;&nbsp;vk::DynamicState::eViewport,
&nbsp;&nbsp;&nbsp;&nbsp;vk::DynamicState::eScissor
};
vk::PipelineDynamicStateCreateInfo dynamicState({}, dynamicStates.size(), dynamicStates.data());
</code></pre>
					</li>
					<li>
						<p>
                            And then you only need to specify their count at pipeline creation time:
						</p>
<pre><code class="language-cpp" data-lang="cpp">vk::PipelineViewportStateCreateInfo viewportState({}, 1, {}, 1);
</code></pre>
					</li>
					<li>
						<p>
                            The actual viewport(s) and scissor rectangle(s) will then later be set up at drawing time.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<em>
                        Without dynamic state
					</em>
                    </s>:
				</p>
				<ul>
					<li>
						<p>
                            The viewport and scissor rectangle need to be set in the pipeline using the 
                            <code>VkPipelineViewportStateCreateInfo</code>
                            &nbsp;struct. This makes the viewport and scissor rectangle for this pipeline immutable. Any changes required to these values would require a new pipeline to be created with the new values.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        What should you use?
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            USE DYNAMIC. There's 
							<strong>
                                no
							</strong>
                            &nbsp;performance penalty.
						</p>
					</li>
					<li>
						<p>
                            Supported since launch.
						</p>
					</li>
					<li>
						<p>
                            LunarG:
						</p>
						<ul>
							<li>
								<p>
                                    <img src="assets/image_20250731211321.png" width="350" >
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="multi-sampling" >
    Multi-Sampling
</h4>
<h5
	id="setup" >
    Setup
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineMultisampleStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineMultisampleStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>rasterizationSamples</code>
				</p>
				<ul>
					<li>
						<p>
                            If the bound pipeline was created without a 
                            <code>VkAttachmentSampleCountInfoAMD</code>
                            &nbsp;or 
                            <code>VkAttachmentSampleCountInfoNV</code>
                            &nbsp;structure, and the 
                            <code>multisampledRenderToSingleSampled</code>
                            &nbsp;feature is not enabled, and the current render pass instance was begun with 
                            <code>vkCmdBeginRendering</code>
                            &nbsp;with a 
                            <code>VkRenderingInfo:colorAttachmentCount</code>
                            &nbsp;parameter greater than 0, then each element of the 
                            <code>VkRenderingInfo:pColorAttachments</code>
                            &nbsp;array with a 
                            <code>imageView</code>
                            &nbsp;not equal to 
                            <code>NULL_HANDLE</code>
                            &nbsp;must have been created with a sample count equal to the value of 
                            <code>rasterizationSamples</code>
                            &nbsp;for the bound graphics pipeline.
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/limits.html#VkSampleCountFlagBits" 
								class="external-link" 
								target="_blank" >
                                VkSampleCountFlagBits
							</a>
                            &nbsp;value specifying the number of samples used in rasterization. This value is ignored for the purposes of setting the number of samples used in rasterization if the pipeline is created with the 
                            <code>DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT</code>
                            &nbsp;dynamic state set, but if 
                            <code>DYNAMIC_STATE_SAMPLE_MASK_EXT</code>
                            &nbsp;dynamic state is not set, it is still used to define the size of the 
                            <code>pSampleMask</code>
                            &nbsp;array as described below.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>sampleShadingEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                can
							</strong>
                            &nbsp;be used to enable 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/primsrast.html#primsrast-sampleshading" 
								class="external-link" 
								target="_blank" >
                                Sample Shading
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>minSampleShading</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a minimum fraction of sample shading if 
                            <code>sampleShadingEnable</code>
                            &nbsp;is 
                            <code>TRUE</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSampleMask</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkSampleMask</code>
                            &nbsp;values used in the 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/fragops.html#fragops-samplemask" 
								class="external-link" 
								target="_blank" >
                                sample mask test
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>alphaToCoverageEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls whether a temporary coverage value is generated based on the alpha component of the fragment‚Äôs first color output as specified in the 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/fragops.html#fragops-covg" 
								class="external-link" 
								target="_blank" >
                                Multisample Coverage
							</a>
                            &nbsp;section.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>alphaToOneEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls whether the alpha component of the fragment‚Äôs first color output is replaced with one as described in 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/fragops.html#fragops-covg" 
								class="external-link" 
								target="_blank" >
                                Multisample Coverage
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="resolving" >
    Resolving
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkRenderingAttachmentInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>resolveMode</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlagBits.html" 
								class="external-link" 
								target="_blank" >
                                VkResolveModeFlagBits
							</a>
                            &nbsp;value defining how data written to 
                            <code>imageView</code>
                            &nbsp;will be resolved into 
                            <code>resolveImageView</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If 
                            <code>resolveMode</code>
                            &nbsp;is not 
                            <code>RESOLVE_MODE_NONE</code>
                            , and 
                            <code>resolveImageView</code>
                            &nbsp;is not 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/NULL_HANDLE.html" 
								class="external-link" 
								target="_blank" >
                                NULL_HANDLE
							</a>
                            , a render pass multisample resolve operation is defined for the attachment subresource.
						</p>
					</li>
					<li>
						<p>
                            <code>RESOLVE_MODE_NONE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that no resolve operation is done.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>RESOLVE_MODE_SAMPLE_ZERO</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is equal to the value of sample 0.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>RESOLVE_MODE_AVERAGE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is the average of the sample values.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>RESOLVE_MODE_MIN</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is the minimum of the sample values.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>RESOLVE_MODE_MAX</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is the maximum of the sample values.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that rather than a multisample resolve, a single sampled color attachment will be downsampled into a Y‚Ä≤CBCR format image specified by an external Android format. Unlike other resolve modes, implementations can resolve multiple times during rendering, or even bypass writing to the color attachment altogether, as long as the final value is resolved to the resolve attachment. Values in the G, B, and R channels of the color attachment will be written to the Y, CB, and CR channels of the external format image, respectively. Chroma values are calculated as if sampling with a linear filter from the color attachment at full rate, at the location the chroma values sit according to 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkPhysicalDeviceExternalFormatResolvePropertiesANDROID" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
									</a>
                                    ::
                                    <code>externalFormatResolveChromaOffsetX</code>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkPhysicalDeviceExternalFormatResolvePropertiesANDROID" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
									</a>
                                    ::
                                    <code>externalFormatResolveChromaOffsetY</code>
                                    , and the chroma sample rate of the resolved image.
								</p>
							</li>
							<li>
								<p>
                                    No range compression or Y‚Ä≤CBCR model conversion is performed by 
                                    <code>RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID</code>
                                    ; applications have to do these conversions themselves. Value outputs are expected to match those that would be read through a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#textures-sampler-YCbCr-conversion-modelconversion" 
										class="external-link" 
										target="_blank" >
                                        Y‚Ä≤CBCR sampler using 
                                        <code>SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY</code>
									</a>
                                    . The color space that the values should be in is defined by the platform and is not exposed via Vulkan.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is an image view used to write resolved data at the end of rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the layout that 
                            <code>resolveImageView</code>
                            &nbsp;will be in during rendering.
						</p>
					</li>
					<li>
						<p>
                            If 
                            <code>imageView</code>
                            &nbsp;is not 
                            <code>NULL_HANDLE</code>
                            &nbsp;and 
                            <code>resolveMode</code>
                            &nbsp;is not 
                            <code>RESOLVE_MODE_NONE</code>
                            , 
                            <code>resolveImageLayout</code>
                            &nbsp;must not be 
                            <code>IMAGE_LAYOUT_UNDEFINED</code>
                            , 
                            <code>IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>
                            , 
                            <code>IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>
                            , 
                            <code>IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code>
                            , 
                            <code>IMAGE_LAYOUT_ZERO_INITIALIZED_EXT</code>
                            , 
                            <code>IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>
                            , or 
                            <code>IMAGE_LAYOUT_PREINITIALIZED</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            From Multisample, to Singlesample.
		</p>
	</li>
	<li>
		<p>
            Combine sample values from a single pixel in a multisample attachment and store the result to the corresponding pixel in a single sample attachment.
		</p>
	</li>
	<li>
		<p>
            Multisample resolve operations for attachments execute in the 
            <code>PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT</code>
            &nbsp;pipeline stage. A final resolve operation for all pixels in the render area happens-after any recorded command which writes a pixel via the multisample attachment to be resolved or an explicit alias of it in the subpass that it is specified.
		</p>
	</li>
	<li>
		<p>
            Any single sample attachment specified for use in a multisample resolve operation 
			<strong>
                may
			</strong>
            &nbsp;have its contents modified at any point once rendering begins for the render pass instance.
		</p>
	</li>
	<li>
		<p>
            Reads from the multisample attachment can be synchronized with 
            <code>ACCESS_COLOR_ATTACHMENT_READ</code>
            . Access to the single sample attachment can be synchronized with 
            <code>ACCESS_COLOR_ATTACHMENT_READ</code>
            &nbsp;and 
            <code>COLOR_ATTACHMENT_WRITE</code>
            . These pipeline stage and access types are used whether the attachments are color or depth/stencil attachments.
		</p>
	</li>
	<li>
		<p>
            When using render pass objects, a subpass dependency specified with the above pipeline stages and access flags will ensure synchronization with multisample resolve operations for any attachments that were last accessed by that subpass. This allows later subpasses to read resolved values as input attachments.
		</p>
	</li>
	<li>
		<p>
            Resolve operations only update values within the defined render area for the render pass instance. However, any writes performed by a resolve operation (as defined by its access masks) to a given attachment 
			<strong>
                may
			</strong>
            &nbsp;read and write back any memory locations within the image subresource bound for that attachment. For depth/stencil images, if 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-separateDepthStencilAttachmentAccess" 
				class="external-link" 
				target="_blank" >
                <code>separateDepthStencilAttachmentAccess</code>
			</a>
            &nbsp;is 
            <code>FALSE</code>
            , writes to one aspect 
			<strong>
                may
			</strong>
            &nbsp;also result in read-modify-write operations for the other aspect. If the subresource is bound to an attachment with 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-feedbackloop" 
				class="external-link" 
				target="_blank" >
                feedback loop enabled
			</a>
            , implementations 
			<strong>
                must
			</strong>
            &nbsp;not access pixels outside of the render area.
		</p>
	</li>
	<li>
		<p>
            As entire subresources could be accessed by multisample resolve operations, applications cannot safely access values outside of the render area via aliased resources during a render pass instance when a multisample resolve operation is performed.
		</p>
	</li>
	<li>
		<p>
            If 
            <code>RESOLVE_MODE_AVERAGE</code>
            &nbsp;is used, and the source format is a floating-point or normalized type, the sample values for each pixel are resolved with implementation-defined numerical precision.
		</p>
	</li>
	<li>
		<p>
            If the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#formats-numericformat" 
				class="external-link" 
				target="_blank" >
                numeric format
			</a>
            &nbsp;of the resolve attachment uses sRGB encoding, the implementation 
			<strong>
                should
			</strong>
            &nbsp;convert samples from nonlinear to linear before averaging samples as described in the ‚ÄúsRGB EOTF‚Äù section of the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#data-format" 
				class="external-link" 
				target="_blank" >
                Khronos Data Format Specification
			</a>
            . In this case, the implementation 
			<strong>
                must
			</strong>
            &nbsp;convert the linear averaged value to nonlinear before writing the resolved result to resolve attachment.
		</p>
	</li>
	<li>
		<p>
            The resolve mode and store operation are independent; it is valid to write both resolved and unresolved values, and equally valid to discard the unresolved values while writing the resolved ones.
		</p>
	</li>
</ul>
<h5
	id="multisampling-anti-aliasing-msaa" >
    Multisampling Anti-Aliasing (MSAA)
</h5>
<ul>
	<li>
		<p>
            Using only one sample per pixel which is equivalent to no multisampling.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Maximum supported
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can be extracted from 
                    <code>VkPhysicalDeviceProperties</code>
                    &nbsp;associated with our selected physical device.
				</p>
			</li>
			<li>
				<p>
                    The highest sample count that Color Image and Depth Image (Buffer) will be the maximum we can support.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                What to Multisample
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The render target.
				</p>
			</li>
			<li>
				<p>
                    If using a depth image, it should also be multisampled.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The multisampled image should only have one mip level.
				</p>
				<ul>
					<li>
						<p>
                            This is enforced by the Vulkan specification in case of images with more than one sample per pixel.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Multi-sampled images cannot be presented directly.
				</p>
				<ul>
					<li>
						<p>
                            This requirement does not apply to the depth buffer, since it won‚Äôt be presented at any point.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                DOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use 4x MSAA if possible; it‚Äôs not expensive and provides good image quality improvements.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>loadOp = LOAD_OP_CLEAR</code>
                    &nbsp;or 
                    <code>loadOp = LOAD_OP_DONT_CARE</code>
                    &nbsp;for multisampled images.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>storeOp = STORE_OP_DONT_CARE</code>
                    &nbsp;for multisampled images.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>LAZILY_ALLOCATED</code>
                    &nbsp;memory to back the allocated multisampled images; they do not need to be persisted into main memory and therefore do not need physical backing storage.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>pResolveAttachments</code>
                    &nbsp;in a subpass to automatically resolve a multisampled color buffer into a single-sampled color buffer.
				</p>
			</li>
			<li>
				<p>
                    Use 
					<a
						href="http://khronos.org/registry/vulkan/specs/1.2-khr-extensions/html/chap40.html#KHR_depth_stencil_resolve" 
						class="external-link" 
						target="_blank" >
                        <code>KHR_depth_stencil_resolve</code>
					</a>
                    &nbsp;in a subpass to automatically resolve a multisampled depth buffer into a single-sampled depth buffer. Typically this is only useful if the depth buffer is going to be used further, in most cases it is transient and does not need to be resolved.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Avoid
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Avoid using 
                    <code>vkCmdResolveImage()</code>
                    ; this has a significant negative impact on bandwidth and performance.
				</p>
			</li>
			<li>
				<p>
                    Avoid using 
                    <code>loadOp = LOAD_OP_LOAD</code>
                    &nbsp;for multisampled image attachments.
				</p>
			</li>
			<li>
				<p>
                    Avoid using 
                    <code>storeOp = STORE_OP_STORE</code>
                    &nbsp;for multisampled image attachments.
				</p>
			</li>
			<li>
				<p>
                    Avoid using more than 4x MSAA without checking performance.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Failing to get an inline resolve can result in substantially higher memory bandwidth and reduced performance.
				</p>
				<ul>
					<li>
						<p>
                            Manually writing and resolving a 4x MSAA 1080p surface at 60 FPS requires 3.9GB/s of memory bandwidth compared to just 500MB/s when using an inline resolve.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Sample Shading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There are certain limitations of our current MSAA implementation which may impact the quality of the output image in more detailed scenes. For example, we're currently not solving potential problems caused by shader aliasing, i.e. MSAA only smoothens out the edges of geometry but not the interior filling. This may lead to a situation when you get a smooth polygon rendered on screen but the applied texture will still look aliased if it contains high contrasting colors. One way to approach this problem is to enable 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap27.html#primsrast-sampleshading" 
						class="external-link" 
						target="_blank" >
                        Sample Shading
					</a>
                    &nbsp;which will improve the image quality even further, though at an additional performance cost:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">void createLogicalDevice() {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;deviceFeatures.sampleRateShading = TRUE; // enable sample shading feature for the device
&nbsp;&nbsp;&nbsp;&nbsp;...
}

void createGraphicsPipeline() {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;multisampling.sampleShadingEnable = TRUE; // enable sample shading in the pipeline
&nbsp;&nbsp;&nbsp;&nbsp;multisampling.minSampleShading = .2f; // min fraction for sample shading; closer to one is smoother
&nbsp;&nbsp;&nbsp;&nbsp;...
}
</code></pre>
		<p>
            <img src="assets/image_20250907201921.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Performance Tests
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2025-09-07)
				</p>
				<ul>
					<li>
						<p>
                            Done anyway, very approximate.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    MSAAx8 = 900 fps
				</p>
			</li>
			<li>
				<p>
                    MSAAx4 = 1250fps
				</p>
			</li>
			<li>
				<p>
                    MSAAx2 = 1550fps
				</p>
			</li>
			<li>
				<p>
                    MSAA off = 2100fps
				</p>
			</li>
			<li>
				<p>
                    As samples increase, frame time increases approximately by factors 1.35 (x2), 1.68 (x4) and 2.33 (x8) compared to the case without MSAA ‚Äî this is consistent with substantial per-sample cost increase, but 
					<strong>
                        is not
					</strong>
                    &nbsp;strictly linear with the number of samples (e.g.: x4 is not exactly 4√ó nor x8 exactly 8√ó).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="fragment-shader" >
    Fragment Shader
</h3>
<ul>
	<li>
		<p>
            Programmable stage.
		</p>
	</li>
	<li>
		<p>
            Is invoked for every fragment that survives and determines which framebuffer(s) the fragments are written to and with which color and depth values. It can do this using the interpolated data from the vertex shader, which can include things like texture coordinates and normals for lighting.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VkShaderModule</code>
            &nbsp;objects are created from shader byte code.
		</p>
	</li>
</ul>
<h3
	id="color-blending" >
    Color Blending
</h3>
<ul>
	<li>
		<p>
            Fixed-function stage.
		</p>
	</li>
	<li>
		<p>
            Controls how the GPU combines the fragment shader‚Äôs output with what is already in the framebuffer.
		</p>
	</li>
	<li>
		<p>
            Applies operations to mix different fragments that map to the same pixel in the framebuffer. Fragments can simply overwrite each other, add up or be mixed based upon transparency.
		</p>
	</li>
	<li>
		<p>
            After a fragment shader has returned a color, it needs to be combined with the color that is already in the framebuffer.
		</p>
	</li>
	<li>
		<p>
            This transformation is known as color blending, and there are two ways to do it:
		</p>
		<ul>
			<li>
				<p>
                    Mix the old and new value to produce a final color
				</p>
			</li>
			<li>
				<p>
                    Combine the old and new value using a bitwise operation
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If enabled blending in the pipeline, it will blend the frag shader result with the render_target previous visual.
				</p>
			</li>
			<li>
				<p>
                    So if the frag result has alpha &lt; 1.0, it will blend the clear color with the frag shader result, giving it a &quot;transparent visual&quot; against the clear color.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendAttachmentState.html" 
				class="external-link" 
				target="_blank" >
                <code>vkPipelineColorBlendAttachmentState</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Contains the configuration per attached framebuffer.
				</p>
			</li>
			<li>
				<p>
                    This per-framebuffer struct allows you to configure the first way of color blending:
				</p>
<pre><code class="language-c" data-lang="c">// Pseudo-code
if (blendEnable) {
&nbsp;&nbsp;&nbsp;&nbsp;finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);
&nbsp;&nbsp;&nbsp;&nbsp;finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);
} else {
&nbsp;&nbsp;&nbsp;&nbsp;finalColor = newColor;
}

finalColor = finalColor & colorWriteMask;
</code></pre>
			</li>
			<li>
				<p>
                    The most common way to use color blending is to implement alpha blending, where we want the new color to be blended with the old color based on its opacity.
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>finalColor</code>
                            &nbsp;should then be computed as follows:
						</p>
<pre><code class="language-c" data-lang="c">finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor;
finalColor.a = newAlpha.a;
</code></pre>
					</li>
					<li>
						<p>
                            This can be achieved with the following parameters:
						</p>
<pre><code class="language-cpp" data-lang="cpp">colorBlendAttachment.blendEnable = vk::True;
colorBlendAttachment.srcColorBlendFactor = vk::BlendFactor::eSrcAlpha;
colorBlendAttachment.dstColorBlendFactor = vk::BlendFactor::eOneMinusSrcAlpha;
colorBlendAttachment.colorBlendOp = vk::BlendOp::eAdd;
colorBlendAttachment.srcAlphaBlendFactor = vk::BlendFactor::eOne;
colorBlendAttachment.dstAlphaBlendFactor = vk::BlendFactor::eZero;
colorBlendAttachment.alphaBlendOp = vk::BlendOp::eAdd;
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>blendEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            If set to 
                            <code>FALSE</code>
                            , then the new color from the fragment shader is passed through unmodified. Otherwise, the two mixing operations are performed to compute a new color.
						</p>
					</li>
					<li>
						<p>
                            The resulting color is AND‚Äôd with the 
                            <code>colorWriteMask</code>
                            &nbsp;to determine which channels are actually passed through.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineColorBlendStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Contains the 
					<em>
                        global
					</em>
                    &nbsp;color blending settings.
				</p>
			</li>
			<li>
				<p>
                    References the array of structures for all the framebuffers and allows you to set blend constants that you can use as blend factors in the aforementioned calculations.
				</p>
			</li>
			<li>
				<p>
                    <code>attachmentCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of 
                            <code>VkPipelineColorBlendAttachmentState</code>
                            &nbsp;elements in 
                            <code>pAttachments</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            It is ignored if the pipeline is created with 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ENABLET</code>
                            , 
                            <code>DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT</code>
                            , and 
                            <code>DYNAMIC_STATE_COLOR_WRITE_MASK_EXT</code>
                            &nbsp;dynamic states set, and either 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT</code>
                            &nbsp;set or the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-advancedBlendCoherentOperations" 
								class="external-link" 
								target="_blank" >
                                advancedBlendCoherentOperations
							</a>
                            &nbsp;feature is not enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAttachments</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkPipelineColorBlendAttachmentState</code>
                            &nbsp;structures defining blend state for each color attachment.
						</p>
					</li>
					<li>
						<p>
                            It is ignored if the pipeline is created with 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ENABLET</code>
                            , 
                            <code>DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT</code>
                            , and 
                            <code>DYNAMIC_STATE_COLOR_WRITE_MASK_EXT</code>
                            &nbsp;dynamic states set, and either 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT</code>
                            &nbsp;set or the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-advancedBlendCoherentOperations" 
								class="external-link" 
								target="_blank" >
                                advancedBlendCoherentOperations
							</a>
                            &nbsp;feature is not enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>logicOpEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls whether to apply 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#framebuffer-logicop" 
								class="external-link" 
								target="_blank" >
                                Logical Operations
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>logicOp</code>
				</p>
				<ul>
					<li>
						<p>
                            Selects which logical operation to apply.
						</p>
					</li>
					<li>
						<p>
                            If you want to use the second method of blending (a bitwise combination), then you should set 
                            <code>logicOpEnable</code>
                            &nbsp;to 
                            <code>TRUE</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Note that this will automatically disable the first method, as if you had set 
                                    <code>blendEnable</code>
                                    &nbsp;to 
                                    <code>FALSE</code>
                                    &nbsp;for every attached framebuffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>colorWriteMask</code>
                            &nbsp;will also be used in this mode to determine which channels in the framebuffer will actually be affected.
						</p>
					</li>
					<li>
						<p>
                            If disabled both modes, the fragment colors will be written to the framebuffer unmodified.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>blendConstants</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#framebuffer-blendfactors" 
								class="external-link" 
								target="_blank" >
                                blend factor
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="creation" >
    Creation
</h3>
<h5
	id="setup" >
    Setup
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>vkGraphicsPipelineCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>DISABLE_OPTIMIZATION</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that the created pipeline will not be optimized.
								</p>
							</li>
							<li>
								<p>
                                    Using this flag 
									<strong>
                                        may
									</strong>
                                    &nbsp;reduce the time taken to create the pipeline.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>renderPass</code>
				</p>
				<ul>
					<li>
						<p>
                            Is set to 
                            <code>nullptr</code>
                            &nbsp;because we‚Äôre using dynamic rendering instead of a traditional render pass.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>basePipelineHandle</code>
				</p>
			</li>
			<li>
				<p>
                    <code>basePipelineIndex</code>
				</p>
			</li>
			<li>
				<p>
					<em>
                        Graphics Pipelines Inheritance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Vulkan allows you to create a new graphics pipeline by deriving from an existing pipeline.
						</p>
					</li>
					<li>
						<p>
                            The idea of pipeline derivatives is that it is less expensive to set up pipelines when they have much functionality in common with an existing pipeline and switching between pipelines from the same parent can also be done quicker.
						</p>
					</li>
					<li>
						<p>
                            You can either specify the handle of an existing pipeline with 
                            <code>basePipelineHandle</code>
                            &nbsp;or reference another pipeline that is about to be created by index with 
                            <code>basePipelineIndex</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            These values are only used if the 
                            <code>VPIPELINE_CREATE_DERIVATIVE</code>
                            &nbsp;flag is also specified in the 
                            <code>flags</code>
                            &nbsp;field of 
                            <code>VkGraphicsPipelineCreateInfo</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCreateGraphicsPipelines()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>device</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the logical device that creates the graphics pipelines.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pipelineCache</code>
				</p>
				<ul>
					<li>
						<p>
                            Is either 
                            <code>NULL_HANDLE</code>
                            , indicating that pipeline caching is disabled, or to enable caching, the handle of a valid 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCache.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineCache
							</a>
                            &nbsp;object. The implementation 
							<strong>
                                must
							</strong>
                            &nbsp;not access this object outside of the duration of this command.
						</p>
					</li>
					<li>
						<p>
                            A pipeline cache can be used to store and reuse data relevant to pipeline creation across multiple calls to 
                            <code>vkCreateGraphicsPipelines</code>
                            &nbsp;and even across program executions if the cache is stored to a file. This makes it possible to significantly speed up pipeline creation at a later time.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>createInfoCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the length of the 
                            <code>pCreateInfos</code>
                            &nbsp;and 
                            <code>pPipelines</code>
                            &nbsp;arrays.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCreateInfos</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkGraphicsPipelineCreateInfo
							</a>
                            &nbsp;structures.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAllocator</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls host memory allocation as described in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-allocation" 
								class="external-link" 
								target="_blank" >
                                Memory Allocation
							</a>
                            &nbsp;chapter.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pPipelines</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipeline.html" 
								class="external-link" 
								target="_blank" >
                                VkPipeline
							</a>
                            &nbsp;handles in which the resulting graphics pipeline objects are returned.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="dynamic-rendering-extra-steps" >
    Dynamic Rendering Extra Steps
</h5>
<ul>
	<li>
		<p>
            Changes to the 
            <code>vkGraphicsPipelineCreateInfo</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>vkGraphicsPipelineCreateInfo</code>
                    &nbsp;must be created without a 
                    <code>VkRenderPass</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>VkPipelineRenderingCreateInfo</code>
                    &nbsp;must be included in the 
                    <code>pNext</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If a graphics pipeline is created with a valid 
                            <code>VkRenderPass</code>
                            , the parameters of the 
                            <code>VkPipelineRenderingCreateInfo</code>
                            &nbsp;are ignored.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRenderingCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineRenderingCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>colorAttachmentCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of entries in 
                            <code>pColorAttachmentFormats</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pColorAttachmentFormats</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkFormat</code>
                            &nbsp;values defining the format of color attachments used in this pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthAttachmentFormat</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
                            <code>VkFormat</code>
                            &nbsp;value defining the format of the depth attachment used in this pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>stencilAttachmentFormat</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
                            <code>VkFormat</code>
                            &nbsp;value defining the format of the stencil attachment used in this pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>viewMask</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitfield of view indices describing which views are active during rendering.
						</p>
					</li>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;match 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingInfo.viewMask
							</a>
                            &nbsp;when rendering.
						</p>
						<ul>
							<li>
								<p>
                                    As defined in 
                                    <code>VkRenderingInfo</code>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Is a bitfield of view indices describing which views are active during rendering, when it is not 
                                            <code>0</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            If 
                                            <code>viewMask</code>
                                            &nbsp;is not 
                                            <code>0</code>
                                            , multiview is enabled.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Formats
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If 
                            <code>depthAttachmentFormat</code>
                            , 
                            <code>stencilAttachmentFormat</code>
                            , or any element of 
                            <code>pColorAttachmentFormats</code>
                            &nbsp;is 
                            <code>UNDEFINED</code>
                            , it indicates that the corresponding attachment is unused within the render pass.
						</p>
					</li>
					<li>
						<p>
                            Valid formats indicate that an attachment 
							<strong>
                                can
							</strong>
                            &nbsp;be used - but it is still valid to set the attachment to 
                            <code>NULL</code>
                            &nbsp;when beginning rendering.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="managing-pipelines-and-reducing-overhead" >
    Managing Pipelines and Reducing overhead
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://devblogs.nvidia.com/vulkan-dos-donts/" 
				class="external-link" 
				target="_blank" >
                Tips and Tricks: Vulkan Dos and Don‚Äôts
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Use pipeline cache.
				</p>
			</li>
			<li>
				<p>
                    Use specialization constants.
				</p>
				<ul>
					<li>
						<p>
                            This may cause a possible decrease in the number of instructions and registers used by the shader.
						</p>
					</li>
					<li>
						<p>
                            Specialization constants can also be used instead of offline shader permutations to minimize the amount of bytecode that needs to be shipped with an application.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Switching pipelines:
				</p>
				<ul>
					<li>
						<p>
                            Avoid frequently switching between pipelines that use different sets of pipeline stages.
						</p>
					</li>
					<li>
						<p
							class="line-emphasis" >
                            Minimize the number of 
                            <code>vkCmdBindPipeline</code>
                            &nbsp;calls, each call has significant CPU cost and GPU cost.
						</p>
						<ul>
							<li>
								<p
									class="line-emphasis" >
                                    Consider 
									<em>
                                        sorting
									</em>
                                    &nbsp;of drawcalls and/or using a low number of dynamic states.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Switching on/off the tessellation, geometry, task and mesh shaders is an expensive operation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Draw calls:
				</p>
				<ul>
					<li>
						<p>
                            Group draw calls, taking into account what kinds of shaders they use.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h6
	id="the-problem" >
    The Problem
</h6>
<ul>
	<li>
		<p>
            Immutable Pipelines.
		</p>
	</li>
	<li>
		<p>
            Each combination of inputs require a dedicated pipeline.
		</p>
		<ul>
			<li>
				<p>
                    Shader, topology, blend mode, vertex layout, cull mode, etc.
				</p>
			</li>
			<li>
				<p>
                    So if we want to do things like toggle depth-testing on and off, we will need 2 pipelines.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Causes a combinatorial explosion of variants.
		</p>
		<ul>
			<li>
				<p>
                    10.000's of pipelines for shipping titles.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Building pipelines is a very expensive operation, and we want to minimize the number of pipelines used as its critical for performance.
		</p>
	</li>
</ul>
<h6
	id="my-decisions" >
    My decisions
</h6>
<ul>
	<li>
		<p>
            (2025-08-10)
		</p>
	</li>
	<li>
		<p>
            Dynamic State is a must.
		</p>
	</li>
	<li>
		<p>
            The use of Shader Object still seems new and may introduce some extra complexity in certain cases.
		</p>
		<ul>
			<li>
				<p>
                    I don't know about mobile support.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The use of Graphics Pipeline Libraries sounds interesting, but at the same time it seems limiting in some moments, for Geometry and Tessellation Shaders.
		</p>
		<ul>
			<li>
				<p>
                    I don't know about mobile support.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Overall, I believe that refactoring a game object to use Shader Object or Graphics Pipeline Libraries sounds &quot;simple&quot;, since it's more about how the pipeline is constructed than how one interacts with shaders or descriptor sets. In other words, it seems like an okay decision to make in the future.
		</p>
	</li>
	<li>
		<p>
            Considering the low support, and the fact that I don't have so many pipelines in mind that actually make these solutions necessary, I prefer to use graphics pipelines manually, in the &quot;default&quot; way.
		</p>
	</li>
	<li>
		<p>
            Regardless, I believe that using Shader Object or Graphics Pipeline 
			<em>
                does not
			</em>
            &nbsp;remove the need to worry about pipeline caching or precautions to avoid switching the pipeline binding all the time.
		</p>
		<ul>
			<li>
				<p>
                    Correct. Extensions change how pipelines are created/linked but do not remove the performance considerations around pipeline creation, pipeline cache usage, or minimizing pipeline re-binding at draw time. Vendors and platform docs recommend pipeline caches, pre-creation, and minimizing pipeline binds.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            What I will do, therefore: caching and sorting of pipelines based on similarity. I will worry more about binding the pipeline in command buffers and their descriptor sets, than the process of facilitating the creation of new pipelines.
		</p>
		<ul>
			<li>
				<p>
                    This plan aligns with widely recommended practical strategies: use pipeline caches (persist to disk where possible), sort and batch by pipeline/descriptor similarity, and create pipelines asynchronously (background threads) to avoid stutter. These practices address the main runtime pain points regardless of whether you later adopt shader-object or pipeline-library extensions.
				</p>
			</li>
			<li>
				<p>
                    Your current decisions are internally consistent and align with common, pragmatic industry practice: prefer stable/default graphics pipelines with pipeline caching, sorting, and background creation as the primary strategy, while keeping code organized so you can adopt 
                    <code>EXT_shader_object</code>
                    &nbsp;or 
                    <code>EXT_graphics_pipeline_library</code>
                    &nbsp;later if/when device support and measured benefits justify the switch.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="mutability-with-codevkdynamicstate-code" >
    Mutability with 
    <code>VkDynamicState</code>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Implemented.
		</p>
	</li>
	<li>
		<p>
            It's a 
			<em>
                must
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Not everything has to be immutable.
		</p>
	</li>
	<li>
		<p>
            Set desired state while recording command buffers.
		</p>
	</li>
	<li>
		<p>
            Over 70 states can be dynamic.
		</p>
	</li>
	<li>
		<p>
            If we don't use this, we would need to create new pipelines if we wanted to change the resolution of our rendering.
		</p>
	</li>
</ul>
<h5
	id="no-pipelines-with-codeext_shader_object-code" >
    No pipelines, with 
    <code>EXT_shader_object</code>
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/features/latest/features/proposals/EXT_shader_object.html" 
				class="external-link" 
				target="_blank" >
                EXT_shader_object
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/shader_object/README.html#_overview" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/blog/you-can-use-vulkan-without-pipelines-today" 
				class="external-link" 
				target="_blank" >
                Article
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=EXT_shader_object" 
						class="external-link" 
						target="_blank" >
                        Coverage
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    (2025-09-08) 11.29%.
				</p>
				<ul>
					<li>
						<p>
                            33.8% Windows.
						</p>
					</li>
					<li>
						<p>
                            26.3% Linux.
						</p>
					</li>
					<li>
						<p>
                            0% Android.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/vQPN3I040Cs?si=lLHBYbfTle9RHQSx&t=452" 
				class="external-link" 
				target="_blank" >
                Shader Object and implementation in Odin {7:30 -&gt; 11:56}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Questions
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I don't know where 
                            <code>pColorAttachmentFormats</code>
                            &nbsp;and 
                            <code>depthAttachmentFormat</code>
                            &nbsp;are specified.
						</p>
						<ul>
							<li>
								<p>
                                    I don't know if it's even necessary to specify them anywhere.
								</p>
							</li>
							<li>
								<p>
                                    The words 
                                    <code>attachment</code>
                                    &nbsp;or 
                                    <code>format</code>
                                    &nbsp;do not appear anywhere in the sample or in the spec of the extension.
								</p>
							</li>
						</ul>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin">&nbsp;&nbsp;&nbsp;&nbsp;pipeline_rendering_create_info := vk.PipelineRenderingCreateInfo{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = .PIPELINE_RENDERING_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorAttachmentCount&nbsp;&nbsp;&nbsp;&nbsp;= 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pColorAttachmentFormats = format,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depthAttachmentFormat&nbsp;&nbsp; = .D24_UNORM_S8_UINT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stencilAttachmentFormat = {},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewMask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0,
&nbsp;&nbsp;&nbsp;&nbsp;}
</code></pre>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/nadako/hello-vulkan-odin/blob/master/src/main.odin" 
						class="external-link" 
						target="_blank" >
                        Code
					</a>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">create_shaders :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;push_constant_ranges := []vk.PushConstantRange {&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stageFlags = {.VERTEX, .FRAGMENT},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size = 128,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;This is not used in the Shader Object.
&nbsp;&nbsp;&nbsp;&nbsp;The only place that needs this in its code, is when making the call `vk.CmdPushConstants(cmd, g.pipeline_layout, {.VERTEX, .FRAGMENT}, 0, size_of(push), &push)`.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;pipeline_layout_ci := vk.PipelineLayoutCreateInfo {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sType = .PIPELINE_LAYOUT_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// flags ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†= {},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setLayoutCount ¬† ¬† ¬† ¬† = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pSetLayouts ¬† ¬† ¬† ¬† ¬† ¬†= {},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushConstantRangeCount = u32(len(push_constant_ranges)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pPushConstantRanges = raw_data(push_constant_ranges),
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;check(vk.CreatePipelineLayout(g.device, &pipeline_layout_ci, nil, &g.pipeline_layout))&nbsp;&nbsp;// Pipeline


&nbsp;&nbsp;&nbsp;&nbsp;vert_code := load_file("shaders/shader.vert.spv", context.temp_allocator)&nbsp;&nbsp;// Shader_Info
&nbsp;&nbsp;&nbsp;&nbsp;frag_code := load_file("shaders/shader.frag.spv", context.temp_allocator)&nbsp;&nbsp;// Shader_Info
&nbsp;&nbsp;&nbsp;&nbsp;shader_cis := [2]vk.ShaderCreateInfoEXT {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sType = .SHADER_CREATE_INFO_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codeType = .SPIRV,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codeSize = len(vert_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pCode = raw_data(vert_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pName = "main",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stage = {.VERTEX},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextStage = {.FRAGMENT},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags = {.LINK_STAGE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setLayoutCount: ¬† ¬† ¬† ¬† u32,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬† ¬† // pSetLayouts: ¬† ¬† ¬† ¬† ¬† ¬†[^]DescriptorSetLayout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushConstantRangeCount = u32(len(push_constant_ranges)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pPushConstantRanges = raw_data(push_constant_ranges),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pSpecializationInfo: ¬† ¬†^SpecializationInfo,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sType = .SHADER_CREATE_INFO_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codeType = .SPIRV,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codeSize = len(frag_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pCode = raw_data(frag_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pName = "main",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stage = {.FRAGMENT},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// nextStage: ¬† ¬† ¬† ¬† ¬† ¬† ¬†ShaderStageFlags,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags = {.LINK_STAGE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setLayoutCount: ¬† ¬† ¬† ¬† u32,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬† ¬† // pSetLayouts: ¬† ¬† ¬† ¬† ¬† ¬†[^]DescriptorSetLayout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushConstantRangeCount = u32(len(push_constant_ranges)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pPushConstantRanges = raw_data(push_constant_ranges),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pSpecializationInfo: ¬† ¬†^SpecializationInfo,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;check(vk.CreateShadersEXT(g.device, 2, raw_data(&shader_cis), nil, raw_data(&g.shaders)))
}

destroy_shaders :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;vk.DestroyPipelineLayout(g.device, g.pipeline_layout, nil)
&nbsp;&nbsp;&nbsp;&nbsp;for shader in g.shaders do vk.DestroyShaderEXT(g.device, shader, nil)
}

render :: proc(cmd: vk.CommandBuffer) {
&nbsp;&nbsp;&nbsp;&nbsp;shader_stages := [2]vk.ShaderStageFlags { {.VERTEX}, {.FRAGMENT} }
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdBindShadersEXT(cmd, 2, raw_data(&shader_stages), raw_data(&g.shaders))
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetVertexInputEXT(cmd, 0, nil, 0, nil) // Shader_Info: vk.VertexInputBindingDescription, vk.VertexInputAttributeDescription.

&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetViewportWithCount(cmd, 1, &vk.Viewport {&nbsp;&nbsp;// Dynamic
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width = f32(g.swapchain.width),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = f32(g.swapchain.height),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minDepth = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxDepth = 1,
&nbsp;&nbsp;&nbsp;&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetScissorWithCount(cmd, 1, &vk.Rect2D {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extent = {width = g.swapchain.width, height = g.swapchain.height}&nbsp;&nbsp;// Dynamic
&nbsp;&nbsp;&nbsp;&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetRasterizerDiscardEnable(cmd, false) // Pipeline

&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetPrimitiveTopology(cmd, .TRIANGLE_LIST)&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetPrimitiveRestartEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline

&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetRasterizationSamplesEXT(cmd, {._1})&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;sample_mask := vk.SampleMask(1)
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetSampleMaskEXT(cmd, {._1}, &sample_mask) // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetAlphaToCoverageEnableEXT(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline

&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetPolygonModeEXT(cmd, .FILL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetCullMode(cmd, {})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetFrontFace(cmd, .COUNTER_CLOCKWISE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline

&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetDepthTestEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetDepthWriteEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetDepthBiasEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetStencilTestEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline

&nbsp;&nbsp;&nbsp;&nbsp;b32_false := b32(false)
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetColorBlendEnableEXT(cmd, 0, 1, &b32_false) // Pipeline

&nbsp;&nbsp;&nbsp;&nbsp;color_mask := vk.ColorComponentFlags { .R, .G, .B, .A }
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdSetColorWriteMaskEXT(cmd, 0, 1, &color_mask)&nbsp;&nbsp;// Pipeline

&nbsp;&nbsp;&nbsp;&nbsp;Push :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: [3]f32,
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;push := Push { color = { 0, 0.5, 0 } }
&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdPushConstants(cmd, g.pipeline_layout, {.VERTEX, .FRAGMENT}, 0, size_of(push), &push)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// vk.CmdBindDescriptorSets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Dynamic

&nbsp;&nbsp;&nbsp;&nbsp;vk.CmdDraw(cmd, 3, 1, 0, 0)
}
</code></pre>
	</li>
	<li>
		<p>
            Ditch pipelines entirely.
		</p>
	</li>
	<li>
		<p>
            Bind compiled shader stages.
		</p>
	</li>
	<li>
		<p>
            It was created primarily for the Nintendo Switch, to reduce the performance gap between Vulkan and NVN (the Switch's native API), which doesn't even have the concept of pipeline state objects and map almost 1:1 to how Nvidia hardware works.
		</p>
	</li>
	<li>
		<p>
            If you want to use Shader Objects, the reason should be &quot;I find it much easier to use/maintain&quot;. Because once you grow you'll encounter friction as the extension is meant for porting old engines, and goes against new features.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Hard to recommend, as for limited support.
				</p>
			</li>
			<li>
				<p>
                    Currently only available on AMD &amp; Nvidia.
				</p>
			</li>
			<li>
				<p>
                    It provides an emulation layer, which make them usable on any device not natively supporting them. but you need to provide the dll file for the layer along with the application.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Shaders
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This extension introduces a new object type 
                    <code>VkShaderEXT</code>
                    &nbsp;which represents a single compiled shader stage. 
                    <code>VkShaderEXT</code>
                    &nbsp;objects may be created either independently or linked with other 
                    <code>VkShaderEXT</code>
                    &nbsp;objects created at the same time. To create 
                    <code>VkShaderEXT</code>
                    &nbsp;objects, applications call 
                    <code>vkCreateShadersEXT()</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This function compiles the source code for one or more shader stages into 
                    <code>VkShaderEXT</code>
                    &nbsp;objects.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Optional Linking
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Whenever 
                            <code>createInfoCount</code>
                            &nbsp;is greater than one, the shaders being created may optionally be linked together. Linking allows the implementation to perform cross-stage optimizations based on a promise by the application that the linked shaders will always be used together.
						</p>
					</li>
					<li>
						<p>
                            Though a set of linked shaders may perform anywhere between the same to substantially better than equivalent unlinked shaders, this tradeoff is left to the application and linking is never mandatory.
						</p>
					</li>
					<li>
						<p>
                            To specify that shaders should be linked, include the 
                            <code>SHADER_CREATE_LINK_STAGE_EXT</code>
                            &nbsp;flag in each of the 
                            <code>VkShaderCreateInfoEXT</code>
                            &nbsp;structures passed to 
                            <code>vkCreateShadersEXT()</code>
                            . The presence or absence of 
                            <code>SHADER_CREATE_LINK_STAGE_EXT</code>
                            &nbsp;must match across all 
                            <code>VkShaderCreateInfoEXT</code>
                            &nbsp;structures passed to a single 
                            <code>vkCreateShadersEXT()</code>
                            &nbsp;call: i.e., if any member of 
                            <code>pCreateInfos</code>
                            &nbsp;includes 
                            <code>SHADER_CREATE_LINK_STAGE_EXT</code>
                            &nbsp;then all other members must include it too. 
                            <code>SHADER_CREATE_LINK_STAGE_EXT</code>
                            &nbsp;is ignored if 
                            <code>createInfoCount</code>
                            &nbsp;is one, and a shader created this way is considered unlinked.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The stage of the shader being compiled is specified by 
                    <code>stage</code>
                    . Applications must also specify which stage types will be allowed to immediately follow the shader being created. For example, a vertex shader might specify a 
                    <code>nextStage</code>
                    &nbsp;value of 
                    <code>SHADER_STAGE_FRAGMENT</code>
                    &nbsp;to indicate that the vertex shader being created will always be followed by a fragment shader (and never a geometry or tessellation shader). Applications that do not know this information at shader creation time or need the same shader to be compatible with multiple subsequent stages can specify a mask that includes as many valid next stages as they wish. For example, a vertex shader can specify a 
                    <code>nextStage</code>
                    &nbsp;mask of 
                    <code>SHADER_STAGE_GEOMETRY | SHADER_STAGE_FRAGMENT</code>
                    &nbsp;to indicate that the next stage could be either a geometry shader or fragment shader (but not a tessellation shader).
				</p>
			</li>
			<li>
				<p>
                    etc, see the 
					<a
						href="https://docs.vulkan.org/features/latest/features/proposals/EXT_shader_object.html#_shaders" 
						class="external-link" 
						target="_blank" >
                        spec
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="reducing-compilation-overhead-with-codeext_graphics_pipeline_libraries-code" >
    Reducing compilation overhead, with 
    <code>EXT_graphics_pipeline_libraries</code>
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/features/latest/features/proposals/EXT_graphics_pipeline_library.html" 
				class="external-link" 
				target="_blank" >
                EXT_graphics_pipeline_library
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/graphics_pipeline_library/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Release: (2022-06-03).
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=EXT_graphics_pipeline_library" 
						class="external-link" 
						target="_blank" >
                        Coverage
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    (2025-09-08) 18.7% coverage.
				</p>
				<ul>
					<li>
						<p>
                            40.7% Windows.
						</p>
					</li>
					<li>
						<p>
                            40.6% Linux.
						</p>
					</li>
					<li>
						<p>
                            4.88% Android.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.khronos.org/blog/reducing-draw-time-hitching-with-vk-ext-graphics-pipeline-library" 
				class="external-link" 
				target="_blank" >
                Extra info
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I've read until the Dynamic State header.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Allows separate compilation of different parts of the graphics pipeline. With this it‚Äôs now possible to split up the monolithic pipeline creation into different steps and re-use common parts shared across different pipelines.
		</p>
	</li>
	<li>
		<p>
            Compared to monolithic pipeline state, this results in faster pipeline creation times, making this extension a good fit for applications and games that do a lot of pipeline creation at runtime.
		</p>
	</li>
	<li>
		<p>
            Libraries are partial pipeline objects which cannot be bound directly; they are linked together to form a final executable pipeline.
		</p>
	</li>
	<li>
		<p>
            Encourages reuse of compilation work and reduces startup/runtime stutter for games with many similar pipelines.
		</p>
	</li>
	<li>
		<p>
            Because libraries are precompiled partial pipelines, linking is generally cheaper than compiling whole pipelines from scratch.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Individual pipelines stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The monolithic pipeline state has been split into distinct parts that can be compiled independently.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Vertex Input Interface
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains the information that would normally be provided to the full pipeline state object by VkPipelineVertexInputStateCreateInfo and VkPipelineInputAssemblyStateCreateInfo.
						</p>
					</li>
					<li>
						<p>
                            &quot;For our engine, this information is not known until draw time, so a pipeline for this stage is still hashed and created at draw time.&quot;
						</p>
					</li>
					<li>
						<p>
                            This stage has no shader code and thus the driver can create it quickly and there are also a fairly small number of these objects.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Pre-Rasterization Shaders
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains vertex, tessellation, and geometry shader stages along with the state associated with 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineViewportStateCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineViewportStateCreateInfo
							</a>
                            , 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineRasterizationStateCreateInfo
							</a>
                            , 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineTessellationStateCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineTessellationStateCreateInfo
							</a>
                            , and 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPass.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderPass
							</a>
                            &nbsp;(or dynamic rendering).
						</p>
					</li>
					<li>
						<p>
                            The only information you actually need to create the pre-rasterization shader is the SPIR-V code and pipeline layout.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Fragment Shader
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains the fragment shader along with the state in VkPipelineDepthStencilStateCreateInfo and VkRenderPass (or dynamic rendering - although in that case only the viewMask is required).
						</p>
					</li>
					<li>
						<p>
                            If combined with dynamic rendering you can create the fragment shader pipeline with only the SPIR-V and the pipeline layout.
                            <br>
                            This allows the driver to do the heavy lifting of lowering to hardware instructions for the pre-rasterization and fragment shaders with very little information.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Fragment Output Interface
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains the VkPipelineColorBlendStateCreateInfo, VkPipelineMultisampleStateCreateInfo, and VkRenderPass (or dynamic rendering)
						</p>
					</li>
					<li>
						<p>
                            Like with the Vertex Input Interface, this stage requires information that we don‚Äôt know until draw time, so this state is also hashed and the Fragment Output Interface pipeline is created at draw time.
						</p>
					</li>
					<li>
						<p>
                            It is expected to be very quick to create and also relatively small in number.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Final link
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    With all four individual pipeline library stages created, an application can perform a final link to a full pipeline. This final link is expected to be extremely fast - the driver will have done the shader compilation for the individual stages and thus the link can be performed at draw time at a reasonable cost.
				</p>
			</li>
			<li>
				<p>
                    This is where the big benefit of the extension comes in: we‚Äôve pre-created all of our pre-rasterization and fragment shaders, hashed the small number of vertex input/fragment output interfaces, and can on-demand create a fast linked pipeline library at draw time, thus avoiding a dreaded hitch.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If shader compilation stutter is your concern, this extension is the way to go. This extension lets you create partially-constructed PSOs (Pipeline State Objects) (e.g. one for Vertex another for Pixel Shader), and then combine them to generate the final PSO. This allows splitting the huge monolithic block into smaller monolithic blocks that are easier to handle and design around, making the API more D3D11-like (D3D11 has monolithic Rasterizer State blocks and Blend State blocks).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Creating pipeline libraries
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Creating a pipeline library (part) is similar to creating a pipeline, with the difference that you only need to specify the properties required for that specific pipeline state.
				</p>
				<ul>
					<li>
						<p>
                            E.g. for the vertex input interface you only specify input assembly and vertex input state, which is all required to define the interfaces to a vertex shader.
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">VkGraphicsPipelineLibraryCreateInfoEXT library_info{};
library_info.sType = STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
library_info.flags = GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_EXT;

VkPipelineInputAssemblyStateCreateInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input_assembly_state&nbsp;&nbsp;= vkb::initializers::pipeline_input_assembly_state_create_info(PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, 0, FALSE);
VkPipelineVertexInputStateCreateInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertex_input_state&nbsp;&nbsp;&nbsp;&nbsp;= vkb::initializers::pipeline_vertex_input_state_create_info();
std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = {
&nbsp;&nbsp;&nbsp;&nbsp;vkb::initializers::vertex_input_binding_description(0, sizeof(Vertex), VERTEX_INPUT_RATE_VERTEX),
};
std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = {
&nbsp;&nbsp;&nbsp;&nbsp;vkb::initializers::vertex_input_attribute_description(0, 0, FORMAT_R32G32B32_SFLOAT, 0),
&nbsp;&nbsp;&nbsp;&nbsp;vkb::initializers::vertex_input_attribute_description(0, 1, FORMAT_R32G32B32_SFLOAT, sizeof(float) * 3),
&nbsp;&nbsp;&nbsp;&nbsp;vkb::initializers::vertex_input_attribute_description(0, 2, FORMAT_R32G32_SFLOAT, sizeof(float) * 6),
};
vertex_input_state.vertexBindingDescriptionCount&nbsp;&nbsp; = static_cast&lt;uint32_t&gt;(vertex_input_bindings.size());
vertex_input_state.pVertexBindingDescriptions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= vertex_input_bindings.data();
vertex_input_state.vertexAttributeDescriptionCount = static_cast&lt;uint32_t&gt;(vertex_input_attributes.size());
vertex_input_state.pVertexAttributeDescriptions&nbsp;&nbsp;&nbsp;&nbsp;= vertex_input_attributes.data();

VkGraphicsPipelineCreateInfo pipeline_library_create_info{};
pipeline_library_create_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
pipeline_library_create_info.flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = PIPELINE_CREATE_LIBRARY_KHR | PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_EXT;
pipeline_library_create_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
pipeline_library_create_info.pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &library_info;
pipeline_library_create_info.pInputAssemblyState = &input_assembly_state;
pipeline_library_create_info.pVertexInputState&nbsp;&nbsp; = &vertex_input_state;

vkCreateGraphicsPipelines(get_device().get_handle(), pipeline_cache, 1, &pipeline_library_create_info, nullptr, &pipeline_library.vertex_input_interface);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Deprecating shader modules
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    With this extension, creating shader modules with 
                    <code>vkCreateShaderModule</code>
                    &nbsp;has been deprecated and you can instead just pass the shader module create info via 
                    <code>pNext</code>
                    &nbsp;into your pipeline shader stage create info. This change bypasses a useless copy and is recommended.
				</p>
			</li>
			<li>
				<p>
                    You can see this in the pre-rasterization and fragment shader library setup parts of the sample below.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">VkShaderModuleCreateInfo shader_module_create_info{};
shader_module_create_info.sType&nbsp;&nbsp;&nbsp;&nbsp;= STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
shader_module_create_info.codeSize = static_cast&lt;uint32_t&gt;(spirv.size()) * sizeof(uint32_t);
shader_module_create_info.pCode&nbsp;&nbsp;&nbsp;&nbsp;= spirv.data();

VkPipelineShaderStageCreateInfo shader_Stage_create_info{};
shader_Stage_create_info.sType = STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
// Chain the shader module create info
shader_Stage_create_info.pNext = &shader_module_create_info;
shader_Stage_create_info.stage = SHADER_STAGE_VERTEX;
shader_Stage_create_info.pName = "main";

VkGraphicsPipelineCreateInfo pipeline_library_create_info{};
pipeline_library_create_info.stageCount = 1;
pipeline_library_create_info.pStages&nbsp;&nbsp;&nbsp;&nbsp;= &shader_Stage_create_info;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Linking executables
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Once all pipeline (library) parts have been created, the pipeline executable can be linked together from them:
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">std::vector&lt;VkPipeline&gt; libraries = {
&nbsp;&nbsp;&nbsp;&nbsp;pipeline_library.vertex_input_interface,
&nbsp;&nbsp;&nbsp;&nbsp;pipeline_library.pre_rasterization_shaders,
&nbsp;&nbsp;&nbsp;&nbsp;fragment_shader,
&nbsp;&nbsp;&nbsp;&nbsp;pipeline_library.fragment_output_interface
};

// Link the library parts into a graphics pipeline
VkPipelineLibraryCreateInfoKHR linking_info{};
linking_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
linking_info.libraryCount = static_cast&lt;uint32_t&gt;(libraries.size());
linking_info.pLibraries&nbsp;&nbsp; = libraries.data();

VkGraphicsPipelineCreateInfo executable_pipeline_create_info{};
executable_pipeline_create_info.sType = STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
executable_pipeline_create_info.pNext = &linking_info;
executable_pipeline_create_info.flags = PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_EXT;

VkPipeline executable = NULL_HANDLE;
vkCreateGraphicsPipelines(get_device().get_handle(), thread_pipeline_cache, 1, &executable_pipeline_create_info, nullptr, &executable);
</code></pre>
		<ul>
			<li>
				<p>
                    This will result in the pipeline state object to be used at draw time.
				</p>
			</li>
			<li>
				<p>
                    A note on 
                    <code>PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_EXT</code>
                    : This is an optimization flag. If specified, implementations are allowed to do additional optimization passes. This may increase build times but can in turn result in lower runtime costs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Independent Descriptor Sets
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Imagine a situation where the vertex and fragment stage accesses two different descriptor sets.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Vertex Shader
layout(set = 0) UBO_X;

// Fragment Shader
layout(set = 1) UBO_Y;
</code></pre>
		<ul>
			<li>
				<p>
                    Normally when compiling a pipeline, both stages are together and internally a driver will reserve 2 separate descriptor slots for 
                    <code>UBO_X</code>
                    &nbsp;and 
                    <code>UBO_Y</code>
                    . When using graphics pipeline libraries, the driver will see the fragment shader only uses a single descriptor set. It might internally map it to 
                    <code>set 0</code>
                    , but when linking the two libraries, there will be a collision. The 
                    <code>PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_EXT</code>
                    &nbsp;flag ensures the driver will be able to handle this case and not have any collisions. There are some extra constraints when using this flag, but the Validation Layers will detect them for you.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=o1cdo3d2FQk" 
				class="external-link" 
				target="_blank" >
                Explanation
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250810112555.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250810112706.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Same number of pipelines, but acquired through reuse, instead of recompilation.
						</p>
					</li>
					<li>
						<p>
                            Think of the link step as additive, instead of multiplicative.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250810112848.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250810112905.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Considerations
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            At the time it was said there would be an impact on CPU.
						</p>
					</li>
					<li>
						<p>
                            It was unknown whether it was compatible with mobile or not.
						</p>
					</li>
					<li>
						<p>
                            No libraries were made for Geometry and Tessellation Shaders, as they are difficult.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="one-pipeline-per-shader-variant" >
    ~One pipeline per shader variant
</h5>
<ul>
	<li>
		<p>
            It is the cause of the problem listed above.
		</p>
	</li>
	<li>
		<p>
            Causes a combinatorial explosion of variants.
		</p>
	</li>
</ul>
<h5
	id="single-pipeline-branch-inside-shader-material-id-push-constant" >
    <s>Single pipeline, branch inside shader (material ID / push constant)</s>
</h5>
<ul>
	<li>
		<p>
            No way, seems horrible.
		</p>
	</li>
</ul>
<h3
	id="optimizations" >
    Optimizations
</h3>
<h5
	id="pipeline-cache-with-codevkpipelinecache-code" >
    Pipeline Cache, with 
    <code>VkPipelineCache</code>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://github.com/KhronosGroup/Vulkan-Samples/blob/main/samples/performance/pipeline_cache/README.adoc#vulkan-pipeline-cache" 
				class="external-link" 
				target="_blank" >
                Pipeline cache sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/pipeline_cache.html" 
				class="external-link" 
				target="_blank" >
                Pipeline Cache
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/pipelines.html#pipelines-cache" 
				class="external-link" 
				target="_blank" >
                Pipeline Cache
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It allows the driver to reuse previously computed pipeline artifacts across pipeline creations (and you can persist cache data between runs).
		</p>
	</li>
	<li>
		<p>
            Avoids repeating expensive 
			<em>
                driver
			</em>
            &nbsp;work; shortens startup time by reusing previously compiled artifacts.
		</p>
	</li>
	<li>
		<p>
            Creating a Vulkan pipeline requires compiling 
            <code>VkShaderModule</code>
            &nbsp;internally. This will have a significant increase in frame time if performed at runtime. To reduce this time, you can provide a previously initialised 
            <code>VkPipelineCache</code>
            &nbsp;object when calling the 
            <code>vkCreateGraphicsPipelines</code>
            &nbsp;or 
            <code>vkCreateComputePipelines</code>
            &nbsp;functions. This object behaves like a cache container which stores the pipeline internal representation for reuse. In order to benefit from using a 
            <code>VkPipelineCache</code>
            &nbsp;object, the data recorded during pipeline creation needs to be saved to disk and reused between application runs.
		</p>
	</li>
	<li>
		<p>
            Vulkan allows an application to obtain the binary data of a 
            <code>VkPipelineCache</code>
            &nbsp;object and save it to a file on disk before terminating the application. This operation can be achieved using two calls to the 
            <code>vkGetPipelineCacheData</code>
            &nbsp;function to obtain the size and 
            <code>VkPipelineCache</code>
            &nbsp;object‚Äôs binary data. In the next application run, the 
            <code>VkPipelineCache</code>
            &nbsp;can be initialised with the previous run‚Äôs data. This will allow the 
            <code>vkCreateGraphicsPipelines</code>
            &nbsp;or 
            <code>vkCreateComputePipelines</code>
            &nbsp;functions to reuse the baked state and avoid repeating costly operations such as shader compilation.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How to use it
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Create one 
                    <code>VkPipelineCache</code>
                    &nbsp;for related pipeline creation operations (often one per device).
				</p>
			</li>
			<li>
				<p>
                    Pass it into 
                    <code>vkCreateGraphicsPipelines</code>
                    &nbsp;for every create call.
				</p>
			</li>
			<li>
				<p>
                    On exit (or periodically) call 
                    <code>vkGetPipelineCacheData</code>
                    &nbsp;and write to disk; on startup feed that blob into 
                    <code>vkCreatePipelineCache</code>
                    &nbsp;to prepopulate the cache.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>KHR_pipeline_binary</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>VkPipelineCache</code>
                    &nbsp;objects were designed to enable a Vulkan driver to reuse blobs of state or shader code between different pipelines. Originally, the idea was that the driver would know best which parts of state could be reused, and applications only needed to manage storage and threading, simplifying developer code.
				</p>
			</li>
			<li>
				<p>
                    Over time however, 
                    <code>VkPipelineCache</code>
                    &nbsp;objects proved to be too opaque, prompting the Vulkan Working Group to release a number of extensions to provide more application control over them. The current capabilities of 
                    <code>VkPipelineCache</code>
                    &nbsp;objects satisfies many applications, but has shortcomings in more advanced use cases.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Previous difficulties
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>VkPipelineCache</code>
                            &nbsp;API provides no control over the lifetime of the binary objects that it contains. An application wanting to implement an LRU cache, for example, has a hard time using 
                            <code>VkPipelineCache</code>
                            &nbsp;objects.
						</p>
					</li>
					<li>
						<p>
                            Some applications maintain a cache of VkPipeline objects. The VkPipelineCache API makes it impossible to efficiently associate the cached binary objects within a VkPipelineCache object with the application‚Äôs own cache entries.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    What‚Äôs more, most drivers maintain an internal cache of pipeline-derived binary objects. In some cases, it would be beneficial for the application to directly interact with that internal cache, especially on some specialized platforms.
				</p>
			</li>
			<li>
				<p>
                    The new 
                    <code>KHR_pipeline_binary</code>
                    &nbsp;extension introduces a clean new approach that provides applications with access to binary blobs and the information necessary for optimal caching, while smoothly integrating with the application‚Äôs own caching mechanisms.
				</p>
			</li>
			<li>
				<p>
                    It‚Äôs worth noting that the 
					<a
						href="https://www.khronos.org/blog/you-can-use-vulkan-without-pipelines-today" 
						class="external-link" 
						target="_blank" >
                        <code>EXT_shader_object</code>
					</a>
                    &nbsp;extension already includes analogous functionality to 
                    <code>KHR_pipeline_binary</code>
                    . The two extensions were worked on concurrently to provide a universally available solution, including devices where the 
                    <code>EXT_shader_object</code>
                    &nbsp;extension cannot yet be supported.
				</p>
			</li>
			<li>
				<p>
                    Applications that do not need the advanced functionality of the new KHR_pipeline_binary extension can continue to use VkPipelineCache objects for their simplicity and optimized implementation. But developers that are not satisfied with the VkPipelineCache API should read on to learn more about this powerful new approach.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.khronos.org/blog/bringing-explicit-pipeline-caching-control-to-vulkan?utm_source=chatgpt.com" 
						class="external-link" 
						target="_blank" >
                        Article
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Read up to 'Caching With KHR_pipeline_binary'.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="optimizing-the-shader-with-codekhr_buffer_device_address-code" >
    Optimizing the Shader with 
    <code>KHR_buffer_device_address</code>
</h5>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#physical-storage-buffer-khr_buffer_device_address">
            Vulkan#Physical Storage Buffer (KHR_buffer_device_address)
            </a>
            .
		</p>
	</li>
	<li>
		<h2
			id="strongsupport-strong" >
			<strong>
                Support
			</strong>
            :
		</h2>
	</li>
</ul>
<h5
	id="pipeline-derivatives" >
    <s>Pipeline derivatives</s>
</h5>
<ul>
	<li>
		<p>
            A creation mechanism to tell the driver that one pipeline is a parent and others are children (derivatives).
		</p>
	</li>
	<li>
		<p>
            The driver may avoid redoing expensive compile/link steps and reuse intermediate data from the parent, reducing creation time.
		</p>
	</li>
	<li>
		<p>
            The intent is faster creation of children by reusing work/data from the parent.
		</p>
	</li>
	<li>
		<p>
            The pipeline creation API provides no way to tell it what state will change. The idea being that, since the implementation can see the parent's state, and it can see what you ask of the child's state, it can tell what's different.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Is it worth it?
			</strong>
            &nbsp;NO.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            No vendor is actually recommending the use of pipeline derivatives, except maybe to speed up pipeline creation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://devblogs.nvidia.com/vulkan-dos-donts/" 
						class="external-link" 
						target="_blank" >
                        Tips and Tricks: Vulkan Dos and Don‚Äôts
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Don‚Äôt expect speedup from Pipeline Derivatives.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://developer.samsung.com/game/usage" 
						class="external-link" 
						target="_blank" >
                        Vulkan Usage Recommendations
					</a>
                    , Samsung
				</p>
				<ul>
					<li>
						<p>
                            Pipeline derivatives let applications express &quot;child&quot; pipelines as incremental state changes from a similar &quot;parent&quot;; on some architectures, this can reduce the cost of switching between similar states.
						</p>
					</li>
					<li>
						<p>
                            Many mobile GPUs gain performance primarily through pipeline caches, so pipeline derivatives often provide 
							<strong>
                                no
							</strong>
                            &nbsp;benefit to portable mobile applications.
						</p>
					</li>
					<li>
						<p>
                            Recommendations:
						</p>
						<ul>
							<li>
								<p>
                                    Create pipelines early in application execution. Avoid pipeline creation at draw time.
								</p>
							</li>
							<li>
								<p>
                                    Use a 
									<em>
                                        single pipeline cache
									</em>
                                    &nbsp;for all pipeline creation.
								</p>
							</li>
							<li>
								<p>
                                    Write the pipeline cache to a file between application runs.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Avoid pipeline derivatives.
									</em>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers/blob/master/samples/performance/pipeline_cache/pipeline_cache_tutorial.html" 
						class="internal-link" 
						target="_self" >
                        Vulkan Best Practice for Mobile Developers - Pipeline Management
					</a>
                    , Arm Software, Jul 11, 2019
				</p>
				<ul>
					<li>
						<p>
                            Don't create pipelines at draw time without a pipeline cache (introduces performance stutters).
						</p>
					</li>
					<li>
						<p>
                            Don't use pipeline derivatives as they are not supported.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/LunarG/VulkanSamples/blob/master/API-Samples/pipeline_derivative/pipeline_derivative.cpp" 
						class="external-link" 
						target="_blank" >
                        Vulkan Samples, LunarG - API-Samples/pipeline_derivative/pipeline_derivative.cpp
					</a>
				</p>
				<ul>
					<li>
						<p>
                            This sample creates pipeline derivative and draws with it. Pipeline derivatives should allow for faster creation of pipelines.
						</p>
					</li>
					<li>
						<p>
                            In this sample, we'll create the default pipeline, but then modify it slightly and create a derivative.
						</p>
					</li>
					<li>
						<p>
                            The derivative will be used to render a simple cube. We may later find that the pipeline is too simple to show any speedup, or that replacing the fragment shader is too expensive, so this sample can be updated then.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Typical use case
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Many pipelines that differ only by a few fields (e.g., different specializations or small state changes).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How to use
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Create a base pipeline with 
                    <code>PIPELINE_CREATE_ALLOW_DERIVATIVES</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    For similar pipelines (small shader or state differences), create child pipelines with 
                    <code>PIPELINE_CREATE_DERIVATIVE</code>
                    &nbsp;and set 
                    <code>basePipelineHandle</code>
                    &nbsp;or 
                    <code>basePipelineIndex</code>
                    &nbsp;pointing to the base.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How it affects the pipeline workflow
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can materially reduce pipeline creation cost when many similar pipelines are needed.
				</p>
			</li>
			<li>
				<p>
                    Useful at runtime if you must create many variants quickly.
				</p>
			</li>
			<li>
				<p>
                    Still creates separate pipeline objects (state memory + driver bookkeeping).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Not guaranteed to be implemented with identical performance gains on all drivers; behavior is driver-dependent.
		</p>
	</li>
</ul>
<h2
	id="compute-pipeline" >
    Compute Pipeline
</h2>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://vkguide.dev/docs/new_chapter_2/vulkan_shader_code/#initializing-the-layout-and-descriptors" 
				class="external-link" 
				target="_blank" >
                Compute Pipeline Vulkan
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=pzAZ0xjWDv8" 
				class="external-link" 
				target="_blank" >
                Compute Shader in OpenGL
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Cool.
				</p>
			</li>
			<li>
				<p>
                    A compute shader is used to determine an array of positions, then render each point in a graphics pipeline using POINTS as the primitive.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=KN9nHo9kvZs" 
				class="external-link" 
				target="_blank" >
                Poor explanation, with possibly useful code, in Vulkan
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The video's code may be useful based on what I saw.
				</p>
			</li>
			<li>
				<p>
                    Though, the video itself is meh.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A compute shader maps pretty well of how a GPU operates; which is not really the case of a Graphics Pipeline.
		</p>
	</li>
</ul>
<h5
	id="use-cases" >
    Use cases
</h5>
<ul>
	<li>
		<p>
            Calculate images from complex postprocessing chains.
		</p>
	</li>
	<li>
		<p>
            Raytracing or other non-geometry drawing.
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<ul>
	<li>
		<p>
            We need to create first the pipeline layout for it, and then hook a single shader module for its code.
		</p>
	</li>
	<li>
		<p>
            Once its built, we can execute the compute shader by first calling 
            <code>VkCmdBindPipeline</code>
            &nbsp;and then calling 
            <code>VkCmdDispatch</code>
            .
		</p>
	</li>
</ul>
<h5
	id="using" >
    Using
</h5>
<ul>
	<li>
		<p>
            You generally want to use a memory barrier after the dispatch of the compute shader, so you wait for the compute shader to finish to finally access its data; if that's what you want to do.
		</p>
		<ul>
			<li>
				<p>
                    In OpenGL the 
                    <code>GL_SHADER_STORAGE_BARRIER</code>
                    &nbsp;is used.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="workgroup" >
    Workgroup
</h5>
<ul>
	<li>
		<p>
            <code>vkCmdDispatch</code>
            .
		</p>
	</li>
	<li>
		<p>
            For an image, I had the decision to only use 2 of those dimensions, that way we can execute one workgroup per group of pixels in the image.
		</p>
	</li>
	<li>
		<p>
            When executing compute shaders, they will get executed in groups of N lanes/threads.
		</p>
	</li>
	<li>
		<p>
            The most difficult part is the decision of partitioning the compute shader between Workgroups and Local Size.
		</p>
	</li>
	<li>
		<p>
            Local Size is also called Workgroup Size, representing the number of threads inside each Workgroup.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912085913.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The code is in OpenGL, but the concept is the same.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The size of the local_size should be ideally related to the size of a warp/wavefront from the GPU, so you don't waste processing power.
		</p>
	</li>
	<li>
		<p>
            For 
            <code>layout(local_size_x = 3, local_size_y = 4, local_size_z = 2)</code>
            , you'll use 
            <code>3 * 4 * 2 = 24</code>
            &nbsp;threads, which is not ideal for a NVIDIA warp size.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912090019.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="glsl-built-in-variables" >
    GLSL Built-in Variables
</h5>
<ul>
	<li>
        <img src="assets/image_20250912090324.png" width="500" >

	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
            The shader code is a very simple shader that will create a gradient from the coordinates of the global invocation ID.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">//GLSL version to use
#version 460

//size of a workgroup for compute
layout (local_size_x = 16, local_size_y = 16) in;

//descriptor bindings for the pipeline
layout(rgba16f,set = 0, binding = 0) uniform image2D image;


void main() 
{
&nbsp;&nbsp;&nbsp;&nbsp;ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;ivec2 size = imageSize(image);

&nbsp;&nbsp;&nbsp;&nbsp;if(texelCoord.x &lt; size.x && texelCoord.y &lt; size.y)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(gl_LocalInvocationID.x != 0 && gl_LocalInvocationID.y != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color.x = float(texelCoord.x)/(size.x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color.y = float(texelCoord.y)/(size.y); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(image, texelCoord, color);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Inside the shader itself, we can see 
            <code>layout (local_size_x = 16, local_size_y = 16) in;</code>
            &nbsp;(z=1 by default).
		</p>
		<ul>
			<li>
				<p>
                    By doing that, we are setting the size of a single workgroup.
				</p>
			</li>
			<li>
				<p>
                    This means that for every work unit from the 
                    <code>vkCmdDispatch</code>
                    , we will have 16x16 lanes of execution, which works well to write into a 16x16 pixel square.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The next layout statement is for the shader input through descriptor sets. We are setting a single image2D as set 0 and binding 0 within that set.
		</p>
	</li>
	<li>
		<p>
            If local invocation ID is 0 on either X or Y, we will just default to black. This is going to create a grid that will directly display our shader workgroup invocations.
		</p>
	</li>
	<li>
		<p>
            On the shader code, we can access what the lane index is through 
            <code>gl_LocalInvocationID</code>
            &nbsp;variable.
		</p>
	</li>
	<li>
		<p>
            There is also 
            <code>gl_GlobalInvocationID</code>
            &nbsp;and 
            <code>gl_WorkGroupID</code>
            . By using those variables we can find out what pixel exactly do we write from each lane.
		</p>
	</li>
</ul>
<h5
	id="compute-shader-raytracing" >
    Compute Shader Raytracing
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=ioazpKQwWPs&list=PLn3eTxaOtL2NkCvARUlpqJU9pLGhFalK9" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan Compute Shader Raytracing
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="resources" >
    Resources
</h2>
<ul>
	<li>
		<p>
            Resources are views of memory with associated formatting and dimensionality.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Make sure to always use the minimum set of resource usage flags. Redundant flags may trigger redundant flushes and stalls in barriers and slow down your app unnecessarily.
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html" 
				class="external-link" 
				target="_blank" >
                Resource Creation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="primary-resources" >
    Primary resources
</h5>
<ul>
	<li>
		<p>
            Buffers.
		</p>
		<ul>
			<li>
				<p>
                    Provide access to raw arrays of bytes
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Images.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Can
					</em>
                    &nbsp;be multidimensional and 
					<em>
                        may
					</em>
                    &nbsp;have associated metadata.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tensors.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Can
					</em>
                    &nbsp;be multidimensional, contain format information like images and 
					<em>
                        may
					</em>
                    &nbsp;have associated metadata.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Samplers.
		</p>
		<ul>
			<li>
				<p>
                    Used to sample from images at certain coordinates, producing interpolated color values.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-micromaps" 
				class="external-link" 
				target="_blank" >
                Micromaps
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Uses buffers as the backing store for opaque data structures.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-acceleration-structures" 
				class="external-link" 
				target="_blank" >
                Acceleration Structures
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Uses buffers as the backing store for opaque data structures.
				</p>
			</li>
			<li>
				<p>
                    Used for realtime raytracing.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="buffers" >
    Buffers
</h3>
<ul>
	<li>
		<p>
            Buffers in Vulkan are regions of memory used for storing arbitrary data that can be read by the graphics card.
		</p>
	</li>
	<li>
		<p>
            They are essentially unformatted arrays of bytes.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Types of Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Unformatted array
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Uniform Buffer
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It remains uniform during the execution of a command (like a draw call).
						</p>
					</li>
					<li>
						<p>
                            Only load operations (read only).
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Read&quot; == &quot;Load&quot;.
								</p>
							</li>
							<li>
								<p>
                                    This allows the GPU to cache them efficiently.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Loaded into L2, and further, into a L1 cache.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Storage Buffers
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allow Load and Store operations.
						</p>
					</li>
					<li>
						<p>
                            Supports atomic operations.
						</p>
					</li>
					<li>
						<p>
                            Data can be loaded from GPU memory into L2-&gt;L1 caches, but can also store data from shaders into memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Texel Buffers
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Uniform Texel Buffer.
						</p>
					</li>
					<li>
						<p>
                            Storage Texel Buffer.
						</p>
					</li>
					<li>
						<p>
                            Formatted view.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Dynamic Buffers
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Dynamic Uniform Buffer.
						</p>
					</li>
					<li>
						<p>
                            Dynamic Texel Buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Queues
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Just like the images in the Swapchain, buffers can also be owned by a specific queue family or be shared between multiple at the same time.
				</p>
				<ul>
					<li>
						<p>
                            The buffer will only be used from the graphics queue, so we can stick to exclusive access.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="create" >
    Create
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCreateBuffer()</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    <code>VkBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            A chunk of GPU visible memory
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VkBufferCreateInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>size</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies the size of the buffer in bytes. Calculating the byte size of the vertex data is straightforward with 
                                    <code>sizeof</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>usage</code>
						</p>
						<ul>
							<li>
								<p>
                                    Indicates for which purposes the data in the buffer is going to be used.
								</p>
							</li>
							<li>
								<p>
                                    It is possible to specify multiple purposes using a bitwise or.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is used to configure sparse buffer memory, which is not relevant right now. We'll leave it at the default value of 
                                    <code>0</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>sharingMode</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifying the sharing mode of the buffer when it will be accessed by multiple queue families.
								</p>
							</li>
							<li>
								<p>
                                    The buffer will only be used from the graphics queue, so we can stick to exclusive access.
								</p>
							</li>
							<li>
								<p>
                                    NVIDIA:
								</p>
								<ul>
									<li>
										<p>
                                            <code>VkSharingMode</code>
                                            &nbsp;is ignored by the driver, so 
                                            <code>SHARING_MODE_CONCURRENT</code>
                                            &nbsp;incurs no overhead relative to 
                                            <code>SHARING_MODE_EXCLUSIVE</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>SHARING_MODE_EXCLUSIVE</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>SHARING_MODE_CONCURRENT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="copy" >
    Copy
</h5>
<ul>
	<li>
		<p>
			<strong>
                Minimum Alignment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceLimits</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>optimalBufferCopyOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the optimal buffer offset alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage2
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer2
									</a>
                                    , and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This value is also the optimal host memory offset alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyMemoryToImage
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyImageToMemory
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The per texel alignment requirements are enforced, but applications 
									<strong>
                                        should
									</strong>
                                    &nbsp;use the optimal alignment for optimal performance and power use.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>optimalBufferCopyRowPitchAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the optimal buffer row pitch alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage2
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer2
									</a>
                                    , and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This value is also the optimal host memory row pitch alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyMemoryToImage
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyImageToMemory
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are enforced, but applications 
									<strong>
                                        should
									</strong>
                                    &nbsp;use the optimal alignment for optimal performance and power use.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="images" >
    Images
</h3>
<ul>
	<li>
		<p>
            Images contain format information. Can be multidimensional and may have associated metadata.
		</p>
	</li>
	<li>
		<p>
            An Image, unlike a Buffer, is almost always used within a View.
		</p>
	</li>
	<li>
		<p>
            A texture you can write to and read from.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImage.html" 
				class="external-link" 
				target="_blank" >
                <code>VkImage</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Stored as
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909135026.png" width="300" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="create" >
    Create
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkImageCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>ImageType</code>
				</p>
			</li>
			<li>
				<p>
                    <code>extent</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the dimensions of the image, basically how many texels there are on each axis.
						</p>
					</li>
					<li>
						<p>
                            That‚Äôs why 
                            <code>extent.depth</code>
                            &nbsp;must be 
                            <code>1</code>
                            &nbsp;instead of 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>format</code>
				</p>
			</li>
			<li>
				<p>
                    <code>tiling</code>
				</p>
			</li>
			<li>
				<p>
                    <code>initialLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Can 
							<strong>
                                only
							</strong>
                            &nbsp;be one of these 3:
						</p>
						<ul>
							<li>
								<p>
                                    <code>UNDEFINED</code>
								</p>
								<ul>
									<li>
										<p>
                                            Not usable by the GPU and the very first transition will discard the texels.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>PREINITIALIZED</code>
								</p>
								<ul>
									<li>
										<p>
                                            Not usable by the GPU, but the first transition will preserve the texels.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>ZERO_INITIALIZED_EXT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Only if 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-zeroInitializeDeviceMemory" 
												class="external-link" 
												target="_blank" >
                                                zeroInitializeDeviceMemory
											</a>
                                            &nbsp;feature is enabled.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            There are a few situations where it is necessary for the texels to be preserved during the first transition.
						</p>
						<ul>
							<li>
								<p>
                                    One example would be if you wanted to use an image as a staging image in combination with the 
                                    <code>TILING_LINEAR</code>
                                    &nbsp;layout. In that case, you‚Äôd want to upload the texel data to it and then transition the image to be a transfer source without losing the data.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            However, we usually don't need this property and can use 
                            <code>UNDEFINED</code>
                            , as we can transition the image to be a transfer destination and then copy texel data to it from a buffer object.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>usage</code>
				</p>
			</li>
			<li>
				<p>
                    <code>samples</code>
				</p>
				<ul>
					<li>
						<p>
                            For multisampling.
						</p>
					</li>
					<li>
						<p>
                            Only relevant for images that will be used as attachments.
						</p>
					</li>
					<li>
						<p>
                            The default for non-multisampled images is one sample.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>mipLevels</code>
				</p>
				<ul>
					<li>
						<p>
                            For mipmapping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Related to sparse images.
						</p>
					</li>
					<li>
						<p>
                            Sparse images are images where only certain regions are actually backed by memory.
						</p>
					</li>
					<li>
						<p>
                            If you were using a 3D texture for a voxel terrain, for example, then you could use this to avoid allocating memory to store large volumes of &quot;air&quot; values.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>sharingMode</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the sharing mode of the image when it will be accessed by multiple queue families.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>queueFamilyIndexCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of entries in the 
                            <code>pQueueFamilyIndices</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pQueueFamilyIndices</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of queue families that will access this image. It is ignored if 
                            <code>sharingMode</code>
                            &nbsp;is not 
                            <code>SHARING_MODE_CONCURRENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="types" >
    Types
</h5>
<ul>
	<li>
		<p>
            Tells Vulkan with what kind of coordinate system the texels in the image are going to be addressed.
		</p>
	</li>
	<li>
		<p>
            1D images
		</p>
		<ul>
			<li>
				<p>
                    Can be used to store an array of data or a gradient.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            2D images
		</p>
		<ul>
			<li>
				<p>
                    Are mainly used for textures.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            3D images
		</p>
		<ul>
			<li>
				<p>
                    Can be used to store voxel volumes, for example.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="usages" >
    Usages
</h5>
<ul>
	<li>
		<p>
			<em>
                Storage Image
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Load and Store.
				</p>
			</li>
			<li>
				<p>
                    Similar to a Storage Buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Sampled Image
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only load operations (read only).
				</p>
			</li>
			<li>
				<p>
                    Similar to Uniform Buffers.
				</p>
			</li>
			<li>
				<p>
                    The coordinates are between 0.0 and 1.0.
				</p>
			</li>
			<li>
				<p>
                    If a coordinate doesn't match exactly a pixel, then the result is an interpolation between the neighbouring pixels.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Input Attachment
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only load operations (read only).
				</p>
			</li>
			<li>
				<p>
                    Within a renderpass.
				</p>
			</li>
			<li>
				<p>
                    Framebuffer-local.
				</p>
				<ul>
					<li>
						<p>
                            Access to single coordinate only.
						</p>
					</li>
					<li>
						<p>
                            No access to other coordinates in that image.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="formats" >
    Formats
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/formats.html" 
				class="external-link" 
				target="_blank" >
                Formats
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/formats.html#formats-compatibility-classes" 
				class="external-link" 
				target="_blank" >
                Compatible Formats
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/formats.html#formats-numericformat" 
				class="external-link" 
				target="_blank" >
                Numeric Format
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>R8G8B8_SRGB</code>
		</p>
		<ul>
			<li>
				<p>
                    Channels stored as 0‚Äì255.
				</p>
			</li>
			<li>
				<p>
                    After conversion, the values are in the 0-1 floating-point range.
				</p>
			</li>
			<li>
				<p>
                    Interpreted using the sRGB nonlinear transfer function (gamma correction).
				</p>
			</li>
			<li>
				<p>
                    When sampled, values are converted to linear color space in the shader automatically.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>R8G8B8_UNORM</code>
		</p>
		<ul>
			<li>
				<p>
                    Each 8-bit channel is an 
					<em>
                        unsigned
					</em>
                    &nbsp;normalized integer.
				</p>
			</li>
			<li>
				<p>
                    Storage range: 0‚Äì255.
				</p>
			</li>
			<li>
				<p>
                    Interpreted as floating-point in the shader:
				</p>
				<ul>
					<li>
						<p>
                            0 ‚Üí 0.0
						</p>
					</li>
					<li>
						<p>
                            255 ‚Üí 1.0
						</p>
					</li>
					<li>
						<p>
                            Linear mapping between.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>R8G8B8_SNORM</code>
		</p>
		<ul>
			<li>
				<p>
                    Each 8-bit channel is a 
					<em>
                        signed
					</em>
                    &nbsp;normalized integer.
				</p>
			</li>
			<li>
				<p>
                    Storage range: ‚Äì128 to +127.
				</p>
			</li>
			<li>
				<p>
                    Interpreted as floating-point in the shader:
				</p>
				<ul>
					<li>
						<p>
                            ‚Äì128 ‚Üí ‚Äì1.0
						</p>
					</li>
					<li>
						<p>
                            +127 ‚Üí +1.0
						</p>
					</li>
					<li>
						<p>
                            Linear mapping between.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tiling" >
    Tiling
</h5>
<ul>
	<li>
		<p>
            Nvidia: Always use 
            <code>TILING_OPTIMAL</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>TILING_LINEAR</code>
                    &nbsp;is not optimal. Use a staging buffer and 
                    <code>vkCmdCopyBufferToImage()</code>
                    &nbsp;to update images on the device.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Unlike the layout of an image, the tiling mode 
			<strong>
                cannot
			</strong>
            &nbsp;be changed at a later time.
		</p>
	</li>
	<li>
		<p>
            <code>TILING_OPTIMAL</code>
		</p>
		<ul>
			<li>
				<p>
                    The layout is opaque/driver-chosen.
				</p>
			</li>
			<li>
				<p>
                    Is described as an implementation-dependent (opaque) arrangement that the driver/GPU may reorder/tile texels for efficient access; it is the intended layout for GPU use.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        When to use
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Image is used as a framebuffer attachment, sampled texture, or otherwise heavily used by the GPU (most rendering targets).
						</p>
					</li>
					<li>
						<p>
                            You want the GPU/driver to choose a layout that maximizes memory locality and bandwidth for rendering.
						</p>
					</li>
					<li>
						<p>
                            You will perform GPU-side post-processing / tonemapping / sampling / blits before presentation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>TILING_LINEAR</code>
		</p>
		<ul>
			<li>
				<p>
                    The layout is row-major/predictable.
				</p>
			</li>
			<li>
				<p>
                    Lays out texels in row-major order (with row padding possible) and is the layout for which 
                    <code>vkGetImageSubresourceLayout</code>
                    &nbsp;returns meaningful offsets for host access; that is the mechanism used when an application needs direct CPU mapping/reading of image memory.
				</p>
				<ul>
					<li>
						<p>
                            However, in practice applications usually do GPU render ‚Üí copy to a host-visible staging buffer/image rather than render directly into a linear-host-visible image.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    LINEAR tiling does have functional and performance limitations (fewer supported formats/usages and worse GPU access patterns), which is why it‚Äôs rarely used for main rendering; typical use cases are CPU upload/download, debugging, or very small offscreen images. It is not only theoretically usable for CPU readback, but that is the primary practical use. You must query format/usage support for linear tiling because many formats or usages are unsupported in LINEAR.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        When to use
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            You explicitly need to map the image memory from the CPU (direct host read/write) and the driver reports support for the requested format/usage in linear tiling.
						</p>
					</li>
					<li>
						<p>
                            Use cases: readback for screenshots/debugging, direct CPU uploads for small resources, or special interop scenarios where a row-major layout is required.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                GPU OPTIMAL to Host-Visible
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://vulkan-tutorial.com/Texture_mapping/Images" 
						class="external-link" 
						target="_blank" >
                        Strategy applied for 'creating a texture from file'
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If you want to be able to directly access texels in the memory of the image, then you must use 
                            <code>TILING_LINEAR</code>
                            . We will be using a staging buffer instead of a staging image, so this won't be necessary. We will be using 
                            <code>TILING_OPTIMAL</code>
                            &nbsp;for efficient access from the shader.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    : 
                    <code>OPTIMAL</code>
                    &nbsp;+ explicit transfer to a host-visible staging resource when needed.
				</p>
			</li>
			<li>
				<p>
                    Create your render target as 
                    <code>OPTIMAL</code>
                    &nbsp;and allocate 
                    <code>DEVICE_LOCAL</code>
                    &nbsp;memory (fast GPU local). After rendering, 
					<strong>
                        copy
					</strong>
                    &nbsp;or 
					<strong>
                        blit
					</strong>
                    &nbsp;the image to a host-visible staging resource (either a buffer via 
                    <code>vkCmdCopyImageToBuffer</code>
                    &nbsp;or a LINEAR image) and map that staging resource for CPU access. This avoids depending on limited linear support and keeps the GPU path fast.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="layouts" >
    Layouts
</h5>
<ul>
	<li>
		<p>
            <code>GENERAL</code>
		</p>
		<ul>
			<li>
				<p>
                    Supports all types of device access, unless specified otherwise.
				</p>
			</li>
			<li>
				<p>
                    If the 
                    <code>unifiedImageLayouts</code>
                    &nbsp;feature is enabled, the 
                    <code>GENERAL</code>
                    &nbsp;image layout 
					<strong>
                        may
					</strong>
                    &nbsp;be used in place of the other layouts where allowed with no loss of performance.
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Can be included in the 
                                    <code>pNext</code>
                                    &nbsp;chain of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkPhysicalDeviceFeatures2</code>
									</a>
                                    &nbsp;structure passed to 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>vkGetPhysicalDeviceFeatures2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>KHR_unified_image_layouts</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            This extension significantly simplifies synchronization in Vulkan by removing the need for image layout transitions in most cases. In particular, it guarantees that using the 
                                            <code>GENERAL</code>
                                            &nbsp;layout everywhere possible is just as efficient as using the other layouts.
										</p>
									</li>
									<li>
										<p>
                                            In the interest of simplifying synchronization in Vulkan, this extension removes image layouts altogether as much as possible. As such, this extension is fairly simple.
										</p>
									</li>
									<li>
										<p>
											<a
												href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/proposals/KHR_unified_image_layouts.adoc" 
												class="external-link" 
												target="_blank" >
                                                Proposal
											</a>
                                            .
										</p>
									</li>
									<li>
										<p>
											<a
												href="https://www.khronos.org/blog/so-long-image-layouts-simplifying-vulkan-synchronisation" 
												class="external-link" 
												target="_blank" >
                                                Article
											</a>
                                            .
										</p>
									</li>
									<li>
										<p>
											<em>
                                                Interacts with
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    VERSION_1_3
												</p>
											</li>
											<li>
												<p>
                                                    EXT_attachment_feedback_loop_layout
												</p>
											</li>
											<li>
												<p>
                                                    KHR_dynamic_rendering
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<em>
                                                Support
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
													<a
														href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=KHR_unified_image_layouts" 
														class="external-link" 
														target="_blank" >
                                                        KHR_unified_image_layouts
													</a>
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>unifiedImageLayouts</code>
                                    &nbsp;(boolean)
								</p>
								<ul>
									<li>
										<p>
                                            Specifies whether usage of 
                                            <code>GENERAL</code>
                                            , where valid, incurs no loss in efficiency.
										</p>
									</li>
									<li>
										<p>
                                            Additionally, it indicates whether it 
											<strong>
                                                can
											</strong>
                                            &nbsp;be used in place of 
                                            <code>ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>unifiedImageLayoutsVideo</code>
                                    &nbsp;(boolean)
								</p>
								<ul>
									<li>
										<p>
                                            Specifies whether 
                                            <code>GENERAL</code>
                                            &nbsp;can be used in place of any of the following image layouts with no loss in efficiency.
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_DECODE_DST</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_DECODE_SRC</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_DECODE_DPB</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_DST</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_SRC</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_DPB</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_QUANTIZATION_MAP</code>
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It can be a useful catch-all image layout, but there are situations where a dedicated image layout must be used instead. For example:
				</p>
				<ul>
					<li>
						<p>
                            <code>PRESENT_SRC</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>SHARED_PRESENT</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>VIDEO_DECODE_SRC</code>
                            , 
                            <code>VIDEO_DECODE_DST</code>
                            , and 
                            <code>VIDEO_DECODE_DPB</code>
                            &nbsp;without the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-unifiedImageLayoutsVideo" 
								class="external-link" 
								target="_blank" >
                                <code>unifiedImageLayoutsVideo</code>
							</a>
                            &nbsp;feature.
						</p>
					</li>
					<li>
						<p>
                            <code>VIDEO_ENCODE_SRC</code>
                            , 
                            <code>VIDEO_ENCODE_DST</code>
                            , and 
                            <code>VIDEO_ENCODE_DPB</code>
                            &nbsp;without the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-unifiedImageLayoutsVideo" 
								class="external-link" 
								target="_blank" >
                                <code>unifiedImageLayoutsVideo</code>
							</a>
                            &nbsp;feature.
						</p>
					</li>
					<li>
						<p>
                            <code>VIDEO_ENCODE_QUANTIZATION_MAP</code>
                            &nbsp;without the 
                            <code>unifiedImageLayoutsVideo</code>
                            &nbsp;feature.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    While 
                    <code>GENERAL</code>
                    &nbsp;suggests that all types of device access are possible, it does not mean that all patterns of memory accesses are safe in all situations.
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#common-render-pass-data-races" 
								class="external-link" 
								target="_blank" >
                                Common Render Pass Data Races
							</a>
                            &nbsp;outlines some situations where data races are unavoidable. For example, when a subresource is used as both an attachment and a sampled image (i.e., not an input attachment), 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-feedbackloop" 
								class="external-link" 
								target="_blank" >
                                enabling feedback loop
							</a>
                            &nbsp;adds extra guarantees which 
                            <code>GENERAL</code>
                            &nbsp;alone does not.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Only in 
                <code>initialLayout</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>UNDEFINED</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that the layout is unknown.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used as the 
                            <code>initialLayout</code>
                            &nbsp;member of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkImageCreateInfo
							</a>
                            .&nbsp;&nbsp;Image memory 
							<strong>
                                cannot
							</strong>
                            &nbsp;be transitioned into this layout.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used in place of the current image layout in a layout transition, but doing so will cause the contents of the image‚Äôs memory to be undefined.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
                    <code>PREINITIALIZED</code>
                    </s>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that an image‚Äôs memory is in a defined layout and 
							<strong>
                                can
							</strong>
                            &nbsp;be populated by data, but that it has not yet been initialized by the driver.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used as the 
                            <code>initialLayout</code>
                            &nbsp;member of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkImageCreateInfo
							</a>
                            .&nbsp;&nbsp;Image memory 
							<strong>
                                cannot
							</strong>
                            &nbsp;be transitioned into this layout.
						</p>
					</li>
					<li>
						<p>
                            This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data 
							<strong>
                                can
							</strong>
                            &nbsp;be written to memory immediately, without first executing a layout transition.
						</p>
					</li>
					<li>
						<p>
                            Currently, 
                            <code>PREINITIALIZED</code>
                            &nbsp;is only useful with 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#glossary-linear-resource" 
								class="external-link" 
								target="_blank" >
                                linear
							</a>
                            &nbsp;images because there is not a standard layout defined for 
                            <code>TILING_OPTIMAL</code>
                            &nbsp;images.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
                    <code>ZERO_INITIALIZED_EXT</code>
                    </s>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that an image‚Äôs memory is in a defined layout and is zeroed, but that it has not yet been initialized by the driver.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used as the 
                            <code>initialLayout</code>
                            &nbsp;member of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkImageCreateInfo
							</a>
                            . Image memory 
							<strong>
                                cannot
							</strong>
                            &nbsp;be transitioned into this layout.
						</p>
					</li>
					<li>
						<p>
                            This layout is intended to be used as the initial layout for an image whose contents are already zeroed, either from being explicitly set to zero by an application or from being allocated with 
                            <code>MEMORY_ALLOCATE_ZERO_INITIALIZE_EXT</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Only if 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-zeroInitializeDeviceMemory" 
								class="external-link" 
								target="_blank" >
                                zeroInitializeDeviceMemory
							</a>
                            &nbsp;feature is enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transfer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>TRANSFER_SRC_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a source image of a transfer command (see the definition of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-pipeline-stages-transfer" 
								class="external-link" 
								target="_blank" >
                                <code>PIPELINE_STAGE_TRANSFER</code>
							</a>
                            ).
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_TRANSFER_SRC</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>TRANSFER_DST_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a destination image of a transfer command.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid only for image subresources of images created with the 
                            <code>USAGE_TRANSFER_DST</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Present
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>PRESENT_SRC</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used for presenting a presentable image for display.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SHARED_PRESENT</code>
				</p>
				<ul>
					<li>
						<p>
                            Is valid only for shared presentable images, and 
							<strong>
                                must
							</strong>
                            &nbsp;be used for any usage the image supports.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Read
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout allowing read only access as an attachment, or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the depth aspect of a depth/stencil format image allowing read-only access as a depth attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>STENCIL_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the stencil aspect of a depth/stencil format image allowing read-only access as a stencil attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for 
							<em>
                                both
							</em>
                            &nbsp;the depth and stencil aspects of a depth/stencil format image allowing read only access as a depth/stencil attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            It is equivalent to 
                            <code>DEPTH_READ_ONLY_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_READ_ONLY_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SHADER_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout allowing read-only access in a shader as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_SAMPLED</code>
                            &nbsp;or 
                            <code>USAGE_INPUT_ATTACHMENT</code>
                            &nbsp;usage bits enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Attachments
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout that 
							<em>
                                must
							</em>
                            &nbsp;only be used with attachment accesses in the graphics pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>COLOR_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a color or resolve attachment in a 
                            <code>VkFramebuffer</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid only for image subresources of images created with the 
                            <code>COLOR_ATTACHMENT</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
					<li>
						<p>
                            Nvidia: Use 
                            <code>COLOR_ATTACHMENT_OPTIMAL</code>
                            &nbsp;image layout for color attachments.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the depth aspect of a depth/stencil format image allowing read and write access as a depth attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>STENCIL_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the stencil aspect of a depth/stencil format image allowing read and write access as a stencil attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for 
							<em>
                                both
							</em>
                            &nbsp;the depth and stencil aspects of a depth/stencil format image allowing read and write access as a depth/stencil attachment.
						</p>
					</li>
					<li>
						<p>
                            Equivalent to 
                            <code>DEPTH_ATTACHMENT_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_ATTACHMENT_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as either a color attachment or depth/stencil attachment and/or read-only access in a shader as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_ATTACHMENT_FEEDBACK_LOOP</code>
                            &nbsp;usage bit enabled and either the 
                            <code>USAGE_COLOR_ATTACHMENT</code>
                            &nbsp;or 
                            <code>USAGE_DEPTH_STENCIL_ATTACHMENT</code>
                            &nbsp;and either the 
                            <code>USAGE_INPUT_ATTACHMENT</code>
                            &nbsp;or 
                            <code>USAGE_SAMPLED</code>
                            &nbsp;usage bits enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>LAYOUT_RENDERING_LOCAL_READ</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as either a storage image, or a color or depth/stencil attachment and an input attachment.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with either 
                            <code>USAGE_STORAGE</code>
                            , or both 
                            <code>USAGE_INPUT_ATTACHMENT</code>
                            &nbsp;and either of 
                            <code>USAGE_COLOR_ATTACHMENT</code>
                            &nbsp;or 
                            <code>USAGE_DEPTH_STENCIL_ATTACHMENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Attachment Fragment Shading Rate
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            <code>FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL</code>
						</p>
						<ul>
							<li>
								<p>
                                    It 
									<strong>
                                        must
									</strong>
                                    &nbsp;only be used as a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#primsrast-fragment-shading-rate-attachment" 
										class="external-link" 
										target="_blank" >
                                        fragment shading rate attachment
									</a>
                                    &nbsp;or 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#primsrast-shading-rate-image" 
										class="external-link" 
										target="_blank" >
                                        shading rate image
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This layout is valid 
									<em>
                                        only
									</em>
                                    &nbsp;for image subresources of images created with the 
                                    <code>USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT</code>
                                    &nbsp;usage bit enabled.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Fragment Density Map
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>FRAGMENT_DENSITY_MAP_OPTIMAL_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    It 
									<strong>
                                        must
									</strong>
                                    &nbsp;only be used as a fragment density map attachment in a 
                                    <code>VkRenderPass</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This layout is valid 
									<em>
                                        only
									</em>
                                    &nbsp;for image subresources of images created with the 
                                    <code>USAGE_FRAGMENT_DENSITY_MAP</code>
                                    &nbsp;usage bit enabled.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Read / Attachment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for depth/stencil format images allowing read and write access to the stencil aspect as a stencil attachment, and read only access to the depth aspect as a depth attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            Equivalent to 
                            <code>DEPTH_READ_ONLY_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_ATTACHMENT_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for depth/stencil format images allowing read and write access to the depth aspect as a depth attachment, and read only access to the stencil aspect as a stencil attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            Equivalent to 
                            <code>DEPTH_ATTACHMENT_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_READ_ONLY_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Video
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VIDEO_DECODE_DST</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#decode-output-picture" 
								class="external-link" 
								target="_blank" >
                                decode output picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-decode-operations" 
								class="external-link" 
								target="_blank" >
                                video decode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>VIDEO_DECODE_DST</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_DECODE_SRC</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_DECODE_DPB</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as an output 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reconstructed-picture" 
								class="external-link" 
								target="_blank" >
                                reconstructed picture
							</a>
                            &nbsp;or an input 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reference-picture" 
								class="external-link" 
								target="_blank" >
                                reference picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-decode-operations" 
								class="external-link" 
								target="_blank" >
                                video decode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_VIDEO_DECODE_DPB</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_DST</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_SRC</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as an 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#encode-input-picture" 
								class="external-link" 
								target="_blank" >
                                encode input picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-encode-operations" 
								class="external-link" 
								target="_blank" >
                                video encode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_VIDEO_ENCODE_SRC</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_DPB</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as an output 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reconstructed-picture" 
								class="external-link" 
								target="_blank" >
                                reconstructed picture
							</a>
                            &nbsp;or an input 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reference-picture" 
								class="external-link" 
								target="_blank" >
                                reference picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-encode-operations" 
								class="external-link" 
								target="_blank" >
                                video encode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_VIDEO_ENCODE_DPB</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_QUANTIZATION_MAP</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#encode-quantization-map" 
								class="external-link" 
								target="_blank" >
                                quantization map
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-encode-operations" 
								class="external-link" 
								target="_blank" >
                                video encode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>VIDEO_ENCODE_QUANTIZATION_DELTA_MAP</code>
                            &nbsp;or 
                            <code>VIDEO_ENCODE_EMPHASIS_MAP</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>TENSOR_ALIASING_ARM</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies the layout that an image created with 
                    <code>TILING_OPTIMAL</code>
                    &nbsp;
					<strong>
                        must
					</strong>
                    &nbsp;be in for it and a tensor bound to the same aliased range of memory to consistently interpret the data in memory.
				</p>
			</li>
			<li>
				<p>
                    See 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-memory-aliasing" 
						class="external-link" 
						target="_blank" >
                        https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-memory-aliasing
					</a>
                    &nbsp;for a complete set of rules for tensor/image aliasing.
				</p>
			</li>
			<li>
				<p>
                    This layout is valid 
					<em>
                        only
					</em>
                    &nbsp;for image subresources of images created with 
                    <code>USAGE_TENSOR_ALIASING</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="image-views" >
    Image Views
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-image-views" 
				class="external-link" 
				target="_blank" >
                Image Views
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            An image view references a specific part of an image to be used.
		</p>
	</li>
	<li>
		<p>
            <code>VkImageViewCreateInfo</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>viewType</code>
				</p>
				<ul>
					<li>
						<p>
                            Allows you to treat images as 1D textures, 2D textures, 3D textures and cube maps.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>format</code>
				</p>
			</li>
			<li>
				<p>
                    <code>components</code>
				</p>
				<ul>
					<li>
						<p>
                            Allows you to swizzle the color channels around. For example, you can map all of the channels to the red channel for a monochrome texture. You can also map constant values of 
                            <code>0</code>
                            &nbsp;and 
                            <code>1</code>
                            &nbsp;to a channel. In our case we'll stick to the default mapping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>subresourceRange</code>
				</p>
				<ul>
					<li>
						<p>
                            Describes what the image's purpose is and which part of the image should be accessed. Our images will be used as color targets without any mipmapping levels or multiple layers.
						</p>
					</li>
					<li>
						<p>
                            If you were working on a stereographic 3D application, then you would create a Swapchain with multiple layers. You could then create multiple image views for each image representing the views for the left and right eyes by accessing different layers.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="copy-blit-copy-image-to-image" >
    Copy: Blit (Copy image to image)
</h5>
<ul>
	<li>
		<p>
            Transfer a rectangular region of pixel data from one image to another.
		</p>
	</li>
	<li>
		<p>
            Unlike a raw copy (
            <code>vkCmdCopyImage</code>
            ), a blit can perform scaling and apply filtering (
            <code>FILTER_LINEAR</code>
            &nbsp;or 
            <code>FILTER_NEAREST</code>
            ), which is consistent with the historical meaning of bit block transfer with optional transformations.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Name
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Comes from 
					<em>
                        bit block transfer
					</em>
                    &nbsp;(sometimes shortened to blt_).
				</p>
			</li>
			<li>
				<p>
                    It was introduced in the 1970s in the context of 2D graphics systems, particularly at Xerox PARC.
				</p>
			</li>
			<li>
				<p>
                    The idea was to copy rectangular 
					<strong>
                        blocks of bits (pixels)
					</strong>
                    &nbsp;from one place in memory to another, often with operations like scaling, masking, or raster operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdBlitImage2</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
			</li>
			<li>
				<p>
                    <code>pBlitImageInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlitImageInfo2.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkBlitImageInfo2</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>srcImage</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the source image.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcImageLayout</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the layout of the source image subresources for the blit.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstImage</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the destination image.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstImageLayout</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the layout of the destination image subresources for the blit.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>regionCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of regions to blit.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pRegions</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageBlit2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkImageBlit2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Defines source and destination subresources, offsets, and extents.
								</p>
							</li>
							<li>
								<p>
                                    Can define multiple regions in a single blit call.
								</p>
							</li>
							<li>
								<p>
                                    For each element of the 
                                    <code>pRegions</code>
                                    &nbsp;array, a blit operation is performed for the specified source and destination regions.
								</p>
							</li>
							<li>
								<p>
									<strong>
                                        Offset
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            The offset entries specify two corners of the rectangular/box region to blit (one corner and the opposite corner).
										</p>
									</li>
									<li>
										<p>
                                            You normally set 
                                            <code>offsets[0]</code>
                                            &nbsp;to the region origin (frequently 
                                            <code>{0,0,0}</code>
                                            ) and 
                                            <code>offsets[1]</code>
                                            &nbsp;to the region end (
                                            <code>{width, height, depth}</code>
                                            ), i.e. the bounds.
										</p>
									</li>
									<li>
										<p>
                                            If left unspecified, that produces the common 
                                            <code>{0,0,0} -&gt; {w,h,1}</code>
                                            &nbsp;box.
										</p>
									</li>
									<li>
										<p>
                                            The Vulkan spec requires both offsets be provided and documents constraints on them (e.g. for 2D images 
                                            <code>z</code>
                                            &nbsp;must be 0/1).
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>srcSubresource</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the subresource to blit from.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>srcOffsets</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a pointer to an array of two 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkOffset3D.html" 
												class="external-link" 
												target="_blank" >
                                                VkOffset3D
											</a>
                                            &nbsp;structures specifying the bounds of the source region within 
                                            <code>srcSubresource</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>dstSubresource</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the subresource to blit into.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>dstOffsets</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a pointer to an array of two 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkOffset3D.html" 
												class="external-link" 
												target="_blank" >
                                                VkOffset3D
											</a>
                                            &nbsp;structures specifying the bounds of the destination region within 
                                            <code>dstSubresource</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>filter</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFilter.html" 
										class="external-link" 
										target="_blank" >
                                        VkFilter
									</a>
                                    &nbsp;specifying the filter to apply if the blits require scaling.
								</p>
							</li>
							<li>
								<p>
                                    Determines how pixels are sampled if scaling occurs.
								</p>
							</li>
							<li>
								<p>
                                    <code>FILTER_NEAREST</code>
                                    &nbsp;for nearest-neighbor scaling.
								</p>
							</li>
							<li>
								<p>
                                    <code>FILTER_LINEAR</code>
                                    &nbsp;for linear interpolation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Their layouts must be valid for transfer operations (
                            <code>TRANSFER_SRC_OPTIMAL</code>
                            &nbsp;and 
                            <code>TRANSFER_DST_OPTIMAL</code>
                            ).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Restrictions
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Blit operations are supported only if the format and the physical device support 
                    <code>FORMAT_FEATURE_BLIT_SRC</code>
                    &nbsp;and 
                    <code>FORMAT_FEATURE_BLIT_DST</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Some formats (like depth/stencil) do not support blitting.
				</p>
			</li>
			<li>
				<p>
                    Multisampled images cannot be used directly as source or destination.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="compression" >
    Compression
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/image_compression_control/README.html" 
				class="external-link" 
				target="_blank" >
                Sample - Image Compression Control
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/texture_compression_comparison" 
				class="external-link" 
				target="_blank" >
                Sample - Texture Compression Comparison
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="depth" >
    Depth
</h2>
<h3
	id="depth-tests" >
    Depth Tests
</h3>
<h5
	id="shader" >
    Shader
</h5>
<ul>
	<li>
		<p>
            <code>gl_FragDepth</code>
		</p>
		<ul>
			<li>
				<p>
                    Available only in the fragment shader.
				</p>
			</li>
			<li>
				<p>
                    Is an 
					<strong>
                        output
					</strong>
                    &nbsp;variable that is used to establish the depth value for the current fragment.
				</p>
			</li>
			<li>
				<p>
                    It is a 
                    <code>float</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If depth buffering is enabled and no shader writes to 
                    <code>gl_FragDepth</code>
                    , then the fixed function value for depth will be used (this value is contained in the z component of 
                    <code>gl_FragCoord</code>
                    ) otherwise, the value written to 
                    <code>gl_FragDepth</code>
                    &nbsp;is used.
				</p>
			</li>
			<li>
				<p>
                    If a shader statically assigns to 
                    <code>gl_FragDepth</code>
                    , then the value of the fragment's depth may be undefined for executions of the shader that don't take that path. That is, if the set of linked fragment shaders statically contain a write to 
                    <code>gl_FragDepth</code>
                    , then it is responsible for always writing it.
				</p>
			</li>
			<li>
				<p>
                    Available in all versions of glsl.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>gl_FragCoord</code>
		</p>
		<ul>
			<li>
				<p>
                    Available only in the fragment shader.
				</p>
			</li>
			<li>
				<p>
                    Is an 
					<strong>
                        input
					</strong>
                    &nbsp;variable that contains the window relative coordinate (x, y, z, 1/w) values for the fragment.
				</p>
			</li>
			<li>
				<p>
                    This value is the result of fixed functionality that interpolates primitives after vertex processing to generate fragments.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Multi-sampling
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If multi-sampling, this value can be for any location within the pixel, or one of the fragment samples.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Depth
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>z</code>
                            &nbsp;component is the depth value that would be used for the fragment's depth if no shader contained any writes to 
                            <code>gl_FragDepth</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>gl_FragCoord.z</code>
                            &nbsp;is the depth value of the fragment that your shader is operating on, 
							<strong>
                                not
							</strong>
                            &nbsp;the current value of the depth buffer at the fragment position.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Changing the origin, by redeclaring it
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>gl_FragCoord</code>
                            &nbsp;may be redeclared with the additional layout qualifier identifiers 
                            <code>origin_upper_left</code>
                            &nbsp;or 
                            <code>pixel_center_integer</code>
                            . By default, 
                            <code>gl_FragCoord</code>
                            &nbsp;assumes a lower-left origin for window coordinates and assumes pixel centers are located at half-pixel centers.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Example
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The 
                                    <code>(x, y)</code>
                                    &nbsp;location 
                                    <code>(0.5, 0.5)</code>
                                    &nbsp;is returned for the lower-left-most pixel in a window. The origin of 
                                    <code>gl_FragCoord</code>
                                    &nbsp;may be changed by redeclaring 
                                    <code>gl_FragCoord</code>
                                    &nbsp;with the 
                                    <code>origin_upper_left</code>
                                    &nbsp;identifier. The values returned can also be shifted by half a pixel in both x and y by 
                                    <code>pixel_center_integer</code>
                                    &nbsp;so it appears the pixels are centered at whole number pixel offsets. This moves the (x, y) value returned by 
                                    <code>gl_FragCoord</code>
                                    &nbsp;of 
                                    <code>(0.5, 0.5)</code>
                                    &nbsp;by default to 
                                    <code>(0.0, 0.0)</code>
                                    &nbsp;with 
                                    <code>pixel_center_integer</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If 
                            <code>gl_FragCoord</code>
                            &nbsp;is redeclared in any fragment shader in a program, it must be redeclared in all fragment shaders in that program that have static use of 
                            <code>gl_FragCoord</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Redeclaring 
                            <code>gl_FragCoord</code>
                            &nbsp;with any accepted qualifier affects only 
                            <code>gl_FragCoord.x</code>
                            &nbsp;and 
                            <code>gl_FragCoord.y</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            It has no effect on rasterization, transformation or any other part of the OpenGL pipeline or language features.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Available in all versions of glsl.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Depth Execution Modes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2025-10-07) Vulkan supports this.
				</p>
				<ul>
					<li>
						<p>
                            Conservative depth can be enabled in Vulkan the same way as in OpenGL (i.e. with 
                            <code>layout(depth_&lt;condition&gt;) out float gl_FragDepth</code>
                            ).
						</p>
					</li>
					<li>
						<p>
                            You can test it and look at the SPIR-V output.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allows for a possible optimization for implementations that relies on an early depth test to be run before the fragment.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// assume it may be modified in any way
layout(depth_any) out float gl_FragDepth;

// assume it may be modified such that its value will only increase
layout(depth_greater) out float gl_FragDepth;

// assume it may be modified such that its value will only decrease
layout(depth_less) out float gl_FragDepth;

// assume it will not be modified
layout(depth_unchanged) out float gl_FragDepth;
</code></pre>
		<ul>
			<li>
				<p>
                    <code>GL_ARB_conservative_depth</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Violating the condition‚Äã yields undefined behavior.
				</p>
			</li>
			<li>
				<p>
                    The layout qualifier for 
                    <code>gl_FragDepth</code>
                    &nbsp;specifies constraints on the final value of 
                    <code>gl_FragDepth</code>
                    &nbsp;written by any shader invocation.&nbsp;&nbsp;GL implementations may perform optimizations assuming that the depth test fails (or passes)&nbsp;&nbsp;for a given fragment if all values of 
                    <code>gl_FragDepth</code>
                    &nbsp;consistent with the layout qualifier would fail (or pass).&nbsp;&nbsp;If the final value of 
                    <code>gl_FragDepth</code>
                    &nbsp;is inconsistent with its layout qualifier, the result of the depth test for the corresponding fragment is undefined.&nbsp;&nbsp;However, no error will be generated in this case.&nbsp;&nbsp;When the depth test passes and depth writes are enabled, the value written to the depth buffer is always the value of 
                    <code>gl_FragDepth</code>
                    , whether or not it is consistent with the layout qualifier.
				</p>
			</li>
			<li>
				<p>
                    <code>&lt;depth_any&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The shader compiler will note any assignment to 
                            <code>gl_FragDepth</code>
                            &nbsp;modifying it in an unknown way, and depth testing will always be performed after the shader has executed.
						</p>
					</li>
					<li>
						<p>
                            By default, 
                            <code>gl_FragDepth</code>
                            &nbsp;assumes the 
                            <code>&lt;depth_any&gt;</code>
                            &nbsp;layout qualifier.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>&lt;depth_greater&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The GL will assume that the final value of 
                            <code>gl_FragDepth</code>
                            &nbsp;is greater than or equal to the fragment's interpolated depth value, as given by the 
                            <code>&lt;z&gt;</code>
                            &nbsp;component of 
                            <code>gl_FragCoord</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>&lt;depth_less&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The GL will assume that any modification of 
                            <code>gl_FragDepth</code>
                            &nbsp;will only decrease its value.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>&lt;depth_unchanged&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The shader compiler will honor any modification to 
                            <code>gl_FragDepth</code>
                            , but the rest of the GL assume that 
                            <code>gl_FragDepth</code>
                            &nbsp;is not assigned a new value.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If 
                    <code>gl_FragDepth</code>
                    &nbsp;is redeclared in any fragment shader in a program, it must be redeclared in all fragment shaders in that program that have static assignments to 
                    <code>gl_FragDepth</code>
                    . All redeclarations of 
                    <code>gl_FragDepth</code>
                    &nbsp;in all fragment shaders in a single program must have the same set of qualifiers. Within any shader, the first redeclarations of 
                    <code>gl_FragDepth</code>
                    &nbsp;must appear before any use of 
                    <code>gl_FragDepth</code>
                    . The built-in 
                    <code>gl_FragDepth</code>
                    &nbsp;is only predeclared in fragment shaders, so redeclaring it in any other shader stage will be illegal.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="depth-test" >
    Depth Test
</h5>
<ul>
	<li>
		<p>
            If the test fails, the fragment is discarded.
		</p>
	</li>
	<li>
		<p>
            If the test passes, the depth attachment will be updated with the fragment‚Äôs output depth.
		</p>
	</li>
</ul>
<h5
	id="depth-bias" >
    Depth Bias
</h5>
<ul>
	<li>
		<p>
            Requires the 
            <code>VkPhysicalDeviceFeatures::depthBiasClamp</code>
            &nbsp;feature to be supported otherwise 
            <code>VkPipelineRasterizationStateCreateInfo::depthBiasClamp</code>
            &nbsp;must be 
            <code>0.0f</code>
            .
		</p>
	</li>
	<li>
		<p>
            The depth bias values can be set 
			<a
				href="https://docs.vulkan.org/guide/latest/dynamic_state.html" 
				class="external-link" 
				target="_blank" >
                dynamically
			</a>
            &nbsp;using 
            <code>DYNAMIC_STATE_DEPTH_BIAS</code>
            &nbsp;or the 
            <code>DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT</code>
            &nbsp;from 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/EXT_extended_dynamic_state2.html" 
				class="external-link" 
				target="_blank" >
                EXT_extended_dynamic_state2
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The rasterizer can alter the depth values by adding a constant value or biasing them based on a fragment‚Äôs slope.
		</p>
	</li>
	<li>
		<p>
            Controls whether to bias fragment depth values.
		</p>
	</li>
	<li>
		<p>
            This is sometimes used for shadow mapping.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Bias Constant Factor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a scalar factor controlling the constant depth value added to each fragment.
				</p>
			</li>
			<li>
				<p>
                    Scales the parameter 
                    <code>r</code>
                    &nbsp;of the depth attachment
				</p>
			</li>
			<li>
				<p>
                    &quot;
                    <code>depthBiasConstantFactor</code>
                    &nbsp;is a scalar factor controlling the constant depth value added to each fragment. The value is in floating point and a typical value seems to be around 2.0-3.0.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bias Slope Factor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a scalar factor applied to a fragment‚Äôs slope in depth bias calculations.
				</p>
			</li>
			<li>
				<p>
                    Scales the maximum depth slope 
                    <code>m</code>
                    &nbsp;of the polygon.
				</p>
			</li>
			<li>
				<p>
                    &quot;I stumbled upon some Vulkan samples that used a much smaller constant bias, but the slope bias was quite high. However, because the slope bias has a much larger weight than the constant one it pretty much worked the same.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bias Clamp
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is the maximum (or minimum) depth bias of a fragment.
				</p>
			</li>
			<li>
				<p>
                    The scaled terms 
                    <code>depthBiasConstantFactor</code>
                    &nbsp;and 
                    <code>depthBiasSlopeFactor</code>
                    &nbsp;are summed to produce a value which is then clamped to a minimum or maximum value specified.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="depth-bounds" >
    Depth Bounds
</h5>
<ul>
	<li>
		<p>
            If the value is not within the depth bounds, the coverage mask is set to zero.
		</p>
	</li>
	<li>
		<p>
            Requires the 
            <code>VkPhysicalDeviceFeatures::depthBounds</code>
            &nbsp;feature to be supported.
		</p>
	</li>
	<li>
		<p>
            The depth bound values can be set 
			<a
				href="https://docs.vulkan.org/guide/latest/dynamic_state.html" 
				class="external-link" 
				target="_blank" >
                dynamically
			</a>
            &nbsp;using 
            <code>DYNAMIC_STATE_DEPTH_BOUNDS</code>
            &nbsp;or the 
            <code>DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT</code>
            &nbsp;from 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/EXT_extended_dynamic_state.html" 
				class="external-link" 
				target="_blank" >
                EXT_extended_dynamic_state
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="depth-clamp" >
    Depth Clamp
</h5>
<ul>
	<li>
		<p>
            Controls whether to clamp the fragment‚Äôs depth values as described in Depth Test.
		</p>
	</li>
	<li>
		<p>
            Before the sample‚Äôs 
            <code>Zf</code>
            &nbsp;is compared to 
            <code>Za</code>
            , 
            <code>Zf</code>
            &nbsp;is clamped to 
            <code>[min(n,f), max(n,f)]</code>
            , where 
            <code>n</code>
            &nbsp;and 
            <code>f</code>
            &nbsp;are the 
            <code>minDepth</code>
            &nbsp;and 
            <code>maxDepth</code>
            &nbsp;depth range values of the viewport used by this fragment, respectively.
		</p>
	</li>
	<li>
		<p>
            If set to 
            <code>TRUE</code>
            , then fragments that are beyond the near and far planes are clamped to them as opposed to discarding them.
		</p>
	</li>
	<li>
		<p>
            This is useful in some special cases like 
			<em>
                shadow maps
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Requires the 
            <code>VkPhysicalDeviceFeatures::depthClamp</code>
            &nbsp;feature to be supported.
		</p>
	</li>
</ul>
<h3
	id="depth-attachment" >
    Depth Attachment
</h3>
<h5
	id="clearing" >
    Clearing
</h5>
<ul>
	<li>
		<p>
            It is always better to clear a depth buffer at the start of the pass with 
            <code>loadOp</code>
            &nbsp;set to 
            <code>ATTACHMENT_LOAD_OP_CLEAR</code>
            .
		</p>
	</li>
	<li>
		<p>
            Depth images can also be cleared outside a render pass using 
            <code>vkCmdClearDepthStencilImage</code>
            .
		</p>
	</li>
	<li>
		<p>
            When clearing, notice that 
            <code>VkClearValue</code>
            &nbsp;is a union and 
            <code>VkClearDepthStencilValue depthStencil</code>
            &nbsp;should be set instead of the color clear value.
		</p>
	</li>
</ul>
<h5
	id="multi-sampling" >
    Multi-sampling
</h5>
<ul>
	<li>
		<p>
            The following post-rasterization occurs as a &quot;per-sample&quot; operation. This means when doing multisampling with a color attachment, any &quot;depth buffer&quot; 
            <code>VkImage</code>
            &nbsp;used as well must also have been created with the same 
            <code>VkSampleCountFlagBits</code>
            &nbsp;value.
		</p>
	</li>
	<li>
		<p>
            A 
			<em>
                coverage mask
			</em>
            &nbsp;is generated for each fragment, based on which samples within that fragment are determined to be within the area of the primitive that generated the fragment.
		</p>
	</li>
	<li>
		<p>
            If a fragment operation results in all bits of the coverage mask being 
            <code>0</code>
            , the fragment is discarded.
		</p>
	</li>
	<li>
		<p>
			<em>
                Resolving
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is possible in Vulkan using the 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/cleanup.html#khr_depth_stencil_resolve" 
						class="external-link" 
						target="_blank" >
                        KHR_depth_stencil_resolve
					</a>
                    &nbsp;extension (promoted to Vulkan core in 1.2) to resolve multisampled depth/stencil attachments in a subpass in a similar manner as for color attachments.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="depth-image" >
    Depth Image
</h3>
<h5
	id="formats" >
    Formats
</h5>
<ul>
	<li>
		<p>
            Nvidia: Prefer using 
            <code>D24_UNORM_S8_UINT</code>
            &nbsp;or 
            <code>D32_SFLOAT</code>
            &nbsp;depth formats, 
            <code>D32_SFLOAT_S8_UINT</code>
            &nbsp;is not optimal.
		</p>
	</li>
	<li>
		<p>
            There are a few different depth formats and an implementation may expose support for in Vulkan.
		</p>
	</li>
	<li>
		<p>
            For 
			<strong>
                reading
			</strong>
            &nbsp;from a depth image only 
            <code>D16_UNORM</code>
            &nbsp;and 
            <code>D32_SFLOAT</code>
            &nbsp;are required to support being read via sampling or blit operations.
		</p>
	</li>
	<li>
		<p>
            For 
			<strong>
                writing
			</strong>
            &nbsp;to a depth image 
            <code>FORMAT_D16_UNORM</code>
            &nbsp;is required to be supported. From here at least one of (
            <code>FORMAT_X8_D24_UNORM_PACK32</code>
            &nbsp;
			<strong>
                or
			</strong>
            &nbsp;
            <code>FORMAT_D32_SFLOAT</code>
            ) 
			<strong>
                and
			</strong>
            &nbsp;(
            <code>FORMAT_D24_UNORM_S8_UINT</code>
            &nbsp;
			<strong>
                or
			</strong>
            &nbsp;
            <code>FORMAT_D32_SFLOAT_S8_UINT</code>
            ) must also be supported. This will involve some extra logic when trying to find which format to use if 
			<strong>
                both
			</strong>
            &nbsp;the depth and stencil are needed in the same format.
		</p>
	</li>
</ul>
<h5
	id="aspect-masks" >
    Aspect Masks
</h5>
<ul>
	<li>
		<p>
            Required when performing operations such as image barriers or clearing.
		</p>
	</li>
	<li>
		<p>
            <code>DEPTH</code>
		</p>
	</li>
</ul>
<h5
	id="sharing-mode" >
    Sharing Mode
</h5>
<ul>
	<li>
		<p>
            Nvidia: 
            <code>VkSharingMode</code>
            &nbsp;is ignored by the driver, so 
            <code>SHARING_MODE_CONCURRENT</code>
            &nbsp;incurs no overhead relative to 
            <code>SHARING_MODE_EXCLUSIVE</code>
            .
		</p>
	</li>
</ul>
<h5
	id="layout-transition" >
    Layout Transition
</h5>
<pre><code class="language-c" data-lang="c">// Example of going from undefined layout to a depth attachment to be read and written to

// Core Vulkan example
srcAccessMask = 0;
dstAccessMask = ACCESS_DEPTH_STENCIL_ATTACHMENT_READ | ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE;
sourceStage = PIPELINE_STAGE_TOP_OF_PIPE;
destinationStage = PIPELINE_STAGE_EARLY_FRAGMENT_TESTS | PIPELINE_STAGE_LATE_FRAGMENT_TESTS;

// KHR_synchronization2
srcAccessMask = ACCESS_2_NONE_KHR;
dstAccessMask = ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_KHR | ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_KHR;
sourceStage = PIPELINE_STAGE_2_NONE_KHR;
destinationStage = PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_KHR | PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_KHR;
</code></pre>
<ul>
	<li>
		<p>
            If unsure to use only early or late fragment tests for your application, use both.
		</p>
	</li>
</ul>
<h5
	id="copying" >
    Copying
</h5>
<ul>
	<li>
		<p>
            Nvidia: Copy both depth and stencil to avoid a slow path for copying.
		</p>
	</li>
</ul>
<h5
	id="reverse-depth-buffer" >
    Reverse Depth Buffer
</h5>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html#projection-matrix">
            Graphics Programming, Shaders#Projection Matrix
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="normal-reconstruction-from-depth" >
    Normal Reconstruction from Depth
</h3>
<ul>
	<li>
		<p>
            You can infer the normals by calculating the derivatives on x and y between pixels of the depth buffer.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.reddit.com/r/GraphicsProgramming/comments/14fevz1/faster_to_calculate_normals_from_depth_than_to/" 
				class="external-link" 
				target="_blank" >
                Discussion
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2019/09/improved-normal-reconstruction-from-depth/" 
				class="external-link" 
				target="_blank" >
                Implementation - Wicked Engine (J√°nos Tur√°nszki (turanszkij))
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://atyuwen.github.io/posts/normal-reconstruction/" 
				class="external-link" 
				target="_blank" >
                Implementation - Yuwen Wu (atyuwen)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Need
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;In screen-space decals rendering, normal buffer is required to reject pixels projected onto near-perpendicular surfaces. But back then I was working on a forward pipeline, so no normal buffer was outputted. It seemed the best choice was to reconstruct it directly from depth buffer, as long as we could avoid introducing errors, which was not easy though.&quot;
				</p>
			</li>
			<li>
				<p>
                    So, for a forward shading, this 
					<em>
                        could
					</em>
                    &nbsp;be necessary.
				</p>
			</li>
			<li>
				<p>
                    It could be avoided if saving the normals in a texture to be sent to a post-processing pass; aka, if introduced a bit of deferred in the forward renderer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Performance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There's a lot of discussion if this is worthwhile. On a deferred renderer, this could be good, but the gain in performance is not obvious. It really depends on how it was implemented.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="stencil" >
    Stencil
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250929094247.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            1 or 0, if have a fragment from our object.
		</p>
	</li>
</ul>
<h5
	id="used-in" >
    Used in
</h5>
<ul>
	<li>
		<p>
            Portals.
		</p>
	</li>
	<li>
		<p>
            Mirrors.
		</p>
	</li>
	<li>
		<p>
            Outlining
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=SlV7nxqCX8Y" 
				class="external-link" 
				target="_blank" >
                Non-Euclidean - demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=xj3Pi6QmXQc" 
				class="external-link" 
				target="_blank" >
                See through - demo
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="stencil-attachment" >
    Stencil Attachment
</h3>
<ul>
	<li>
		<p>
            The 
            <code>PipelineRenderingCreateInfo</code>
            &nbsp;asks for a 
            <code>stencilAttachmentFormat</code>
            , and 
            <code>RenderingInfo</code>
            &nbsp;asks for 
            <code>pStencilAttachment</code>
            .
		</p>
	</li>
	<li>
		<p>
            This is for cases where you want separate depth and stencil images, instead of merged together, like when having a depth image with 
            <code>D24_UNORM_S8_UINT</code>
            , where the 
            <code>S8_UINT</code>
            &nbsp;is for the stencil.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/KHR_separate_depth_stencil_layouts.html" 
				class="external-link" 
				target="_blank" >
                <code>KHR_separate_depth_stencil_layouts</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.2.
				</p>
			</li>
			<li>
				<p>
                    This extension allows image memory barriers for 'depth+stencil' images to have just one of the 
                    <code>IMAGE_ASPECT_DEPTH</code>
                    &nbsp;or 
                    <code>IMAGE_ASPECT_STENCIL</code>
                    &nbsp;aspect bits set, rather than require both. This allows their layouts to be set independently. Image Layouts 
                    <code>IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL</code>
                    , 
                    <code>IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL</code>
                    , 
                    <code>IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL</code>
                    , or 
                    <code>IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL</code>
                    &nbsp;can be used.
				</p>
			</li>
			<li>
				<p>
                    To support depth+stencil images with different layouts for the depth and stencil aspects, the depth+stencil attachment interface has been updated to support a separate layout for stencil.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Structure describing whether the implementation can do depth and stencil image barriers separately.
						</p>
					</li>
					<li>
						<p>
                            It's just a struct with a bool telling if the feature is supported.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>For render passes / subpasses</s>:
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescriptionStencilLayoutKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkAttachmentDescriptionStencilLayout</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Deprecated in Vulkan 1.4.
								</p>
							</li>
							<li>
								<p>
                                    Extends 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkAttachmentDescription2</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Deprecated in Vulkan 1.4.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReferenceStencilLayoutKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkAttachmentReferenceStencilLayout</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Not deprecated.
								</p>
							</li>
							<li>
								<p>
                                    Extends 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReference2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkAttachmentReference2</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Deprecated in Vulkan 1.4.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="formats" >
    Formats
</h5>
<ul>
	<li>
		<p>
            <code>S8_UINT</code>
		</p>
		<ul>
			<li>
				<p>
                    It makes sense, as it's the same format used for stencil in the depth format 
                    <code>D24_UNORM_S8_UINT</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="mapping-data-to-shaders" >
    Mapping Data to Shaders
</h2>
<h3
	id="shader-alignment" >
    Shader Alignment
</h3>
<h5
	id="minimum-dynamic-offset-cbv-allocation-granularity" >
    Minimum Dynamic-Offset / CBV Allocation Granularity
</h5>
<ul>
	<li>
		<p>
            GPUs and drivers require that when you bind or use a portion of a large buffer as a uniform/constant buffer the start address and/or size line up to an alignment.
		</p>
	</li>
	<li>
		<p>
            That alignment is the ‚Äúminimum dynamic-offset‚Äù (Vulkan) or the CBV/constant buffer granularity (D3D12).
		</p>
	</li>
	<li>
		<p>
            It lets the driver map many small logical buffers into a single big GPU buffer efficiently.
		</p>
	</li>
	<li>
		<p>
            If you bind at an unaligned offset the API/driver will reject it or you will get wrong data or degraded performance.
		</p>
	</li>
	<li>
		<p>
            Drivers can report 64, 128, 256, or other powers of two.
		</p>
	</li>
	<li>
		<p>
            UBO alignment is usually larger than SSBO alignment because UBO usage and caches are handled differently by the hardware.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Value
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Many APIs and drivers use 256 bytes as the Minimum Dynamic-Offset on common desktop GPUs.
				</p>
				<ul>
					<li>
						<p>
                            VkGuide:
						</p>
					</li>
				</ul>
<pre><code class="language-cpp" data-lang="cpp">struct MaterialConstants {&nbsp;&nbsp;// written into uniform buffers later
&nbsp;&nbsp;&nbsp;&nbsp;glm::vec4 colorFactors; // multiply the color texture
&nbsp;&nbsp;&nbsp;&nbsp;glm::vec4 metal_rough_factors;
&nbsp;&nbsp;&nbsp;&nbsp;glm::vec4 extra[14];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding, we need it anyway for uniform buffers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it needs to meet a minimum requirement for its alignment. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;256 bytes is a good default alignment for this which all the gpus we target meet, so we are adding those vec4s to pad the structure to 256 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
};
</code></pre>
			</li>
			<li>
				<p>
                    But not every platform or GPU guarantees 256. Mobile or integrated GPUs may have different values.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceLimits</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>minUniformBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
                                    <code>VkDescriptorBufferInfo</code>
                                    &nbsp;structure for uniform buffers.
								</p>
							</li>
							<li>
								<p>
                                    When a descriptor of type 
                                    <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
                                    &nbsp;or 
                                    <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                    &nbsp;is updated, the 
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    Similarly, dynamic offsets for uniform buffers 
									<strong>
                                        must
									</strong>
                                    &nbsp;be multiples of this limit.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minStorageBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
                                    <code>VkDescriptorBufferInfo</code>
                                    &nbsp;structure for storage buffers.
								</p>
							</li>
							<li>
								<p>
                                    When a descriptor of type 
                                    <code>DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
                                    &nbsp;or 
                                    <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                    &nbsp;is updated, the 
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    Similarly, dynamic offsets for storage buffers 
									<strong>
                                        must
									</strong>
                                    &nbsp;be multiples of this limit.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minTexelBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkBufferViewCreateInfo
									</a>
                                    &nbsp;structure for texel buffers.
								</p>
							</li>
							<li>
								<p>
                                    If the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-texelBufferAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>texelBufferAlignment</code>
									</a>
                                    &nbsp;feature is enabled, this limit is equivalent to the maximum of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-uniformTexelBufferOffsetAlignmentBytes" 
										class="external-link" 
										target="_blank" >
                                        <code>uniformTexelBufferOffsetAlignmentBytes</code>
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-storageTexelBufferOffsetAlignmentBytes" 
										class="external-link" 
										target="_blank" >
                                        <code>storageTexelBufferOffsetAlignmentBytes</code>
									</a>
                                    &nbsp;members of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceTexelBufferAlignmentProperties
									</a>
                                    , but smaller alignment is 
									<strong>
                                        optionally
									</strong>
                                    &nbsp;allowed by 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-storageTexelBufferOffsetSingleTexelAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>storageTexelBufferOffsetSingleTexelAlignment</code>
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-uniformTexelBufferOffsetSingleTexelAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>uniformTexelBufferOffsetSingleTexelAlignment</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    If the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-texelBufferAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>texelBufferAlignment</code>
									</a>
                                    &nbsp;feature is not enabled, 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkBufferViewCreateInfo
									</a>
                                    ::
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be a multiple of this value.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Best practice
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Query the GPU at runtime and align your buffer ranges to the reported value.
				</p>
			</li>
			<li>
				<p>
                    Assert size at compile time:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">static_assert(sizeof(MaterialConstants) == 256, "MaterialConstants must be 256 bytes");
</code></pre>
	</li>
</ul>
<h5
	id="default-layouts" >
    Default Layouts
</h5>
<ul>
	<li>
		<p>
			<strong>
                UBOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std140.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SSBOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std430.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std430 (Vulkan).
				</p>
			</li>
			<li>
				<p>
                    Source: 
					<a
						href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf" 
						class="external-link" 
						target="_blank" >
                        GLSL Spec 4.60.8
					</a>
                    , page 90.
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.pdf" 
								class="external-link" 
								target="_blank" >
                                OpenGL Spec 4.6
							</a>
                            , page 146 (7.6.2.2).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="alignment-options" >
    Alignment Options
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/interfaces.html#interfaces-resources-layout" 
				class="external-link" 
				target="_blank" >
                Offset and Stride Assignment
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            There are different alignment requirements depending on the specific resources and on the features enabled.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platform dependency
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        32-bit IEEE-754
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 4 bytes.
						</p>
					</li>
					<li>
						<p>
                            The standard for desktop, mobile, OpenGL ES and Vulkan.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        16-bit half precision
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 2 bytes.
						</p>
					</li>
					<li>
						<p>
                            In rare cases, like embedded or custom OpenGL drivers.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        64-bit IEEE-754 double
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 8 bytes.
						</p>
					</li>
					<li>
						<p>
                            Non-standard case.
						</p>
					</li>
					<li>
						<p>
                            Would require headers redefining 
                            <code>GLfloat</code>
                            &nbsp;as 
                            <code>double</code>
                            , not compliant with spec.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            C layout ‚âà 
            <code>std430</code>
            &nbsp;only if you manually match packing and alignment. Otherwise, it‚Äôs platform-dependent.
		</p>
	</li>
</ul>
<p
	class="table" >
    | GLSL type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| C equivalent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Typical C (x86_64) - Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Typical C (x86_64) - Size | Typical C (x86_64) - Stride |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std140 - Base Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std140 - Occupied Size |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std140 - Stride | std430 - Base Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std430 - Occupied Size |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std430 - Stride |
    <br>
    | -------------------------------- | --------------------------------------------------- | -----------------------------: | -----------------------------------: | --------------------------: | -----------------------------------------------------------------------------------------: | ------------------------------------: | ---------------------------------------: | ----------------------: | ----------------------------------------------------: | ------------------------------------------: |
    <br>
    | 
    <code>bool</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| C 
    <code>_Bool</code>
    &nbsp;(native) ‚Äî or use 
    <code>int32_t</code>
    &nbsp;to match GLSL |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 | 16 (std140 rounds scalar arrays to vec4) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>int</code>
    &nbsp;/ 
    <code>uint</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>int32_t</code>
    &nbsp;/ 
    <code>uint32_t</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>float</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>double</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>double</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 (rounded to dvec4 alignment) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |
    <br>
    | 
    <code>vec2</code>
    &nbsp;/ 
    <code>ivec2</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[2]</code>
    &nbsp;/ 
    <code>int32_t[2]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |
    <br>
    | 
    <code>vec3</code>
    &nbsp;/ 
    <code>ivec3</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[3]</code>
    &nbsp;/ 
    <code>int32_t[3]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>vec4</code>
    &nbsp;/ 
    <code>ivec4</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[4]</code>
    &nbsp;/ 
    <code>int32_t[4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>dvec2</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[2]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>dvec3</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[3]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |
    <br>
    | 
    <code>dvec4</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |
    <br>
    | 
    <code>mat2</code>
    &nbsp;(2√ó2 float, column-major) | 
    <code>float[2][2]</code>
    &nbsp;(2 columns of 
    <code>vec2</code>
    )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 2 = 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 √ó 2 = 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec2 as stride (8) |
    <br>
    | 
    <code>mat3</code>
    &nbsp;(3√ó3 float, column-major) | 
    <code>float[3][3]</code>
    &nbsp;(3 columns of 
    <code>vec3</code>
    )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 36 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 3 = 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 3 = 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each column has vec3 as stride (16) |
    <br>
    | 
    <code>mat4</code>
    &nbsp;(4√ó4 float)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float[4][4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 x 4 = 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 4 = 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each column has vec4 as stride (16) |
    <br>
    | 
    <code>T[]</code>
    &nbsp;(Array of T)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>T[]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alignof(T) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(T) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(T) | base_align(T), rounded up to vec4 base align (16 for 32-bit scalars; 32 for 64-bit/double) | occupied per element = rounded stride |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base_align(T), rounded up to 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_align(T) | occupied per element = sizeof(T) rounded to alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_align(T) |
    <br>
    | 
    <code>vec3[]</code>
    &nbsp;(Array of vec3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float[3][]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>struct</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>struct { ... }</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(member alignment) | struct size padded to that alignment |&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct) (padded) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(member align) rounded up to vec4 (16) |&nbsp;&nbsp;struct size padded to multiple of 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(struct) rounded up to 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max(member align) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct size padded to that alignment | sizeof(struct) (padded to member alignment) |
</p>
<h5
	id="scalar-alignment" >
    Scalar Alignment
</h5>
<ul>
	<li>
		<p>
            Looks like 
			<em>
                std430
			</em>
            , but its vectors are even more compact?
		</p>
	</li>
	<li>
		<p>
            Also known as (?) The spec doesn't say.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#EXT_scalar_block_layout" 
				class="external-link" 
				target="_blank" >
                <code>EXT_scalar_block_layout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.2.
				</p>
			</li>
			<li>
				<p>
                    This extension allows most storage types to be aligned in 
                    <code>scalar</code>
                    &nbsp;alignment.
				</p>
			</li>
			<li>
				<p>
                    Make sure to set 
                    <code>--scalar-block-layout</code>
                    &nbsp;when running the SPIR-V Validator.
				</p>
			</li>
			<li>
				<p>
                    A big difference is being able to straddle the 16-byte boundary.
				</p>
			</li>
			<li>
				<p>
                    In GLSL this can be used with 
                    <code>scalar</code>
                    &nbsp;keyword and extension
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="extended-alignment-std140" >
    Extended Alignment (std140)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.oreilly.com/library/view/opengl-programming-guide/9780132748445/app09lev1sec2.html" 
				class="external-link" 
				target="_blank" >
                Source
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Conservative, padded layout used for uniform blocks.
		</p>
	</li>
	<li>
		<p>
            Widely supported.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Caveats
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Avoiding usage of vec3&quot;
				</p>
				<ul>
					<li>
						<p>
                            Usually applies to std140, because some hardware vendors seem to not follow the spec strictly. Although, everything should work when using std430.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Array of 
                                <code>vec3</code>
                                &nbsp;(ARRAY)
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Alignment will be 4x of a 
                                    <code>float</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Size will be 
                                    <code>alignment * amount of elements</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">// Scalars
&nbsp;&nbsp;&nbsp;&nbsp;float -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp; -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;
// Vectors
&nbsp;&nbsp;&nbsp;&nbsp;// Base alignments
&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;&nbsp;-&gt;&nbsp;&nbsp;8 bytes&nbsp;&nbsp;// 2 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;
// Arrays
&nbsp;&nbsp;&nbsp;&nbsp;// Size of the element type, rounded up to a multiple of the size of `vec4` (behave like `vec4` slots).
&nbsp;&nbsp;&nbsp;&nbsp;// Arrays of types are not necessarily tightly packed.
&nbsp;&nbsp;&nbsp;&nbsp;// An array of floats in such a block will not be the equivalent to an array of floats in C/C++. Arrays will only match their C/C++ definitions if the type is a multiple of 16 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;// Ex: `float arr[N]` uses 16 bytes per element.

// Matrices
&nbsp;&nbsp;&nbsp;&nbsp;// Treated as arrays of vectors. 
&nbsp;&nbsp;&nbsp;&nbsp;// They are column-major by default; you can change it with `layout(row_major)` or `layout(column_major)`.

// Struct
&nbsp;&nbsp;&nbsp;&nbsp;// The biggest struct member, rounded up to multiples of the size of `vec4` (behave like `vec4` slots).
&nbsp;&nbsp;&nbsp;&nbsp;// Struct members are effectively padded so that each member starts on a 16-byte boundary when necessary.
&nbsp;&nbsp;&nbsp;&nbsp;// The struct size will be the space needed by its members.
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">layout(std140) uniform U { float a[3]; }; // size = 3 * 16 = 48 bytes
</code></pre>
	</li>
</ul>
<h5
	id="base-alignment-std430" >
    Base Alignment (std430)
</h5>
<ul>
	<li>
		<p>
			<strong>
                Allowed usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    SSBOs, Push Constants.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#KHR_uniform_buffer_standard_layout" 
						class="external-link" 
						target="_blank" >
                        <code>KHR_uniform_buffer_standard_layout</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Core in Vulkan 1.2.
						</p>
					</li>
					<li>
						<p>
                            Allows the use of 
                            <code>std430</code>
                            &nbsp;memory layout in UBOs.
						</p>
					</li>
					<li>
						<p>
                            These memory layout changes are only applied to 
                            <code>Uniforms</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#KHR_relaxed_block_layout" 
						class="external-link" 
						target="_blank" >
                        <code>KHR_relaxed_block_layout</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Core in Vulkan 1.1; all Vulkan 1.1+ devices support relaxed block layout.
						</p>
					</li>
					<li>
						<p>
                            This extension allows implementations to indicate they can support more variation in block 
                            <code>Offset</code>
                            &nbsp;decorations.
						</p>
					</li>
					<li>
						<p>
                            This comes up when using 
                            <code>std430</code>
                            &nbsp;memory layout where a 
                            <code>vec3</code>
                            &nbsp;(which is 12 bytes) is still defined as a 16 byte alignment.
						</p>
					</li>
					<li>
						<p>
                            With relaxed block layout an application can fit a 
                            <code>float</code>
                            &nbsp;on either side of the 
                            <code>vec3</code>
                            &nbsp;and maintain the 16 byte alignment between them.
						</p>
					</li>
					<li>
						<p>
                            Currently there is no way in GLSL to legally express relaxed block layout, but a developer can use the 
                            <code>--hlsl-offsets</code>
                            &nbsp;with 
                            <code>glslang</code>
                            &nbsp;to produce the desired offsets.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Relaxed layout used for shader-storage blocks and allows much tighter packing.
		</p>
	</li>
	<li>
		<p>
            Requires newer GLSL 4.3+ or equivalent support.
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">// Scalars
&nbsp;&nbsp;&nbsp;&nbsp;float -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp; -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;
// Vectors
&nbsp;&nbsp;&nbsp;&nbsp;// Base alignments
&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;&nbsp;-&gt;&nbsp;&nbsp;8 bytes&nbsp;&nbsp;// 2 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;
// Arrays
&nbsp;&nbsp;&nbsp;&nbsp;// array stride is the natural alignment of the element. 
&nbsp;&nbsp;&nbsp;&nbsp;// Ex: `float arr[N]` uses 4 bytes per element.

// Matrices
&nbsp;&nbsp;&nbsp;&nbsp;// Treated as arrays of vectors. 
&nbsp;&nbsp;&nbsp;&nbsp;// They are column-major by default; you can change it with `layout(row_major)` or `layout(column_major)`.
&nbsp;&nbsp;&nbsp;&nbsp;
// Struct
&nbsp;&nbsp;&nbsp;&nbsp;// Struct packing is tighter and follows natural alignments (less padding).
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, binding=0) buffer B { float a[3]; }; // size = 3 * 4 = 12 bytes
</code></pre>
	</li>
</ul>
<h3
	id="comparisons" >
    Comparisons
</h3>
<ul>
	<li>
		<p>
			<strong>
                Input Attributes vs Uniform Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;If you want a shader to access a resource that is 
					<em>
                        not
					</em>
                    &nbsp;on vertex buffers, they must go through a descriptor set&quot;.
				</p>
			</li>
			<li>
				<p>
                    With Vertex Buffers we can pass arbitrary attributes to the vertex shader for each vertex.
				</p>
			</li>
			<li>
				<p>
                    Including global variables as vertex data would be a waste of memory, and it would require us to update the vertex buffer whenever the transformation changes.
				</p>
			</li>
			<li>
				<p>
                    The right way to tackle this in Vulkan is to use Resource Descriptors
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Uniform Buffers vs Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ChatGPT...
				</p>
			</li>
			<li>
				<p>
                    &quot;Lets say I want to send the time, would it be optimal to send it as a ubo or a push constant? The time should not change between draw calls (it's irrelevant) in the same frame. Seems like a UBO I only need to set it once and every object would benefit from it, but a push constant needs to be send for every object?&quot;
				</p>
				<ul>
					<li>
						<p>
                            Exactly. For your ‚Äútime‚Äù value, a Uniform Buffer is generally the more optimal choice in this scenario.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Push Constants
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You must call 
                                    <code>vkCmdPushConstants</code>
                                    &nbsp;for each command buffer section where shaders need it.
								</p>
							</li>
							<li>
								<p>
                                    Since push constants are set per draw/dispatch scope, if you have many objects, you‚Äôd be redundantly re-sending the same value (time) multiple times in the same frame.
								</p>
							</li>
							<li>
								<p>
                                    There‚Äôs no automatic ‚Äúshared‚Äù state ‚Äî every pipeline that uses it must get the value pushed explicitly.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Uniform Buffers
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You can store the time in a uniform buffer once per frame, bind it once in a descriptor set, and then every draw call will see the same value without re-uploading.
								</p>
							</li>
							<li>
								<p>
                                    Works well for ‚Äúglobal‚Äù frame data (view/proj matrices, time, frame index, etc.).
								</p>
							</li>
							<li>
								<p>
                                    Binding a pre-allocated UBO in a descriptor set has low overhead and avoids per-draw constant pushing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Performance implication:
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    If the data is the same for all draws in a frame, a UBO avoids redundant driver calls and state changes, and makes it easier to keep the command buffer lean. Push constants are better suited for per-object or per-draw small data.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Storage Image vs. Storage Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    While both storage images and storage buffers allow for read-write access in shaders, they have different use cases:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Storage Images
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Ideal for 2D or 3D data that benefits from texture operations like filtering or addressing modes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Storage Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Better for arbitrary structured data or when you need to access data in a non-uniform pattern.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Texel Buffer vs. Storage Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Texel buffers and storage buffers also have different strengths:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Texel Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Provide texture-like access to buffer data, allowing for operations like filtering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Storage Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            More flexible for general-purpose data storage and manipulation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Do keep constant data small, where 128 bytes is a good rule of thumb.
				</p>
			</li>
			<li>
				<p>
                    Do use push constants if you do not want to set up a descriptor set/UBO system.
				</p>
			</li>
			<li>
				<p>
                    Do make constant data directly available in the shader if it is pre-determinable, such as with the use of specialization constants.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Avoid
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Avoid indexing in the shader if possible, such as dynamically indexing into 
                    <code>buffer</code>
                    &nbsp;or 
                    <code>uniform</code>
                    &nbsp;arrays, as this can disable shader optimisations in some platforms.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Failing to use the correct method of constant data will negatively impact performance, causing either reduced FPS and/or increased BW and load/store activity.
				</p>
			</li>
			<li>
				<p>
                    On Mali, register mapped uniforms are effectively free. Any spilling to buffers in memory will increase load/store cache accesses to the per thread uniform fetches.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="input-attributes" >
    Input Attributes
</h3>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            The only shader stage in core Vulkan that has an input attribute controlled by Vulkan is the vertex shader stage (
            <code>SHADER_STAGE_VERTEX</code>
            ).
		</p>
<pre><code class="language-glsl" data-lang="glsl">#version 450
layout(location = 0) in vec3 inPosition;

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position = vec4(inPosition, 1.0);
}
</code></pre>
	</li>
	<li>
		<p>
            Other shader stages, such as a fragment shader stage, have input attributes, but the values are determined from the output of the previous stages run before it.
		</p>
	</li>
	<li>
		<p>
            This involves declaring the interface slots when creating the 
            <code>VkPipeline</code>
            &nbsp;and then binding the 
            <code>VkBuffer</code>
            &nbsp;before draw time with the data to map.
		</p>
	</li>
	<li>
		<p>
            Before calling 
            <code>vkCreateGraphicsPipelines</code>
            &nbsp;a 
            <code>VkPipelineVertexInputStateCreateInfo</code>
            &nbsp;struct will need to be filled out with a list of 
            <code>VkVertexInputAttributeDescription</code>
            &nbsp;mappings to the shader.
		</p>
<pre><code class="language-c" data-lang="c">VkVertexInputAttributeDescription input = {};
input.location = 0;
input.binding&nbsp;&nbsp;= 0;
input.format&nbsp;&nbsp; = FORMAT_R32G32B32_SFLOAT; // maps to vec3
input.offset&nbsp;&nbsp; = 0;
</code></pre>
	</li>
	<li>
		<p>
            The only thing left to do is bind the vertex buffer and optional index buffer prior to the draw call.
		</p>
<pre><code class="language-c" data-lang="c">vkBeginCommandBuffer();
// ...
vkCmdBindVertexBuffer();
vkCmdDraw();
// ...
vkCmdBindVertexBuffer();
vkCmdBindIndexBuffer();
vkCmdDrawIndexed();
// ...
vkEndCommandBuffer();
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxVertexInputAttributes</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxVertexInputAttributeOffset</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-layout" >
    Memory Layout
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250908081102.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081144.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081235.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Single binding.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081301.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    One binding per attribute.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            One binding or many bindings? It doesn't matter that much. In some cases one is better, etc, don't worry too much about it.
		</p>
	</li>
</ul>
<h5
	id="vertex-input-binding-vertex-buffer" >
    Vertex Input Binding / Vertex Buffer
</h5>
<ul>
	<li>
		<p>
            Tell Vulkan how to pass this data format to the vertex shader once it's been uploaded into GPU memory
		</p>
	</li>
	<li>
		<p>
            A vertex binding describes at which rate to load data from memory throughout the vertices.
		</p>
	</li>
	<li>
		<p>
            It specifies the number of bytes between data entries and whether to move to the next data entry after each vertex or after each instance.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputBindingDescription.html" 
				class="external-link" 
				target="_blank" >
                <code>VkVertexInputBindingDescription</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>binding</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the index of the binding in the array of bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>stride</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the number of bytes from one entry to the next.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>inputRate</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>VERTEX_INPUT_RATE_VERTEX</code>
						</p>
						<ul>
							<li>
								<p>
                                    Move to the next data entry after each vertex.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VERTEX_INPUT_RATE_INSTANCE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Move to the next data entry after each instance.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            We're not going to use instanced rendering, so we'll stick to per-vertex data.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputAttributeDescription.html" 
				class="external-link" 
				target="_blank" >
                <code>VkVertexInputAttributeDescription</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Describes how to handle vertex input.
				</p>
			</li>
			<li>
				<p>
                    An attribute description struct describes how to extract a vertex attribute from a chunk of vertex data originating from a binding description.
				</p>
			</li>
			<li>
				<p>
                    We have two attributes, position and color, so we need two attribute description structs.
				</p>
			</li>
			<li>
				<p>
                    <code>binding</code>
				</p>
				<ul>
					<li>
						<p>
                            Tells Vulkan from which binding the per-vertex data comes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>location</code>
				</p>
				<ul>
					<li>
						<p>
                            References the 
                            <code>location</code>
                            &nbsp;directive of the input in the vertex shader.
						</p>
						<ul>
							<li>
								<p>
                                    The input in the vertex shader with location 
                                    <code>0</code>
                                    &nbsp;is the position, which has two 32-bit float components.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>format</code>
				</p>
				<ul>
					<li>
						<p>
                            Describes the type of data for the attribute.
						</p>
					</li>
					<li>
						<p>
                            Implicitly defines the byte size of attribute data.
						</p>
					</li>
					<li>
						<p>
                            A bit confusingly, the formats are specified using the same enumeration as color formats.
						</p>
					</li>
					<li>
						<p>
                            The following shader types and formats are commonly used together:
						</p>
						<ul>
							<li>
								<p>
                                    <code>float</code>
                                    : 
                                    <code>FORMAT_R32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec2</code>
                                    : 
                                    <code>FORMAT_R32G32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec3</code>
                                    : 
                                    <code>FORMAT_R32G32B32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec4</code>
                                    : 
                                    <code>FORMAT_R32G32B32A32_SFLOAT</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            As you can see, you should use the format where the amount of color channels matches the number of components in the shader data type.
						</p>
					</li>
					<li>
						<p>
                            It is allowed to use more channels than the number of components in the shader, but they will be silently discarded.
						</p>
						<ul>
							<li>
								<p>
                                    If the number of channels is lower than the number of components, then the BGA components will use default values of 
                                    <code>(0, 0, 1)</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The color type (
                            <code>SFLOAT</code>
                            , 
                            <code>UINT</code>
                            , 
                            <code>SINT</code>
                            ) and bit width should also match the type of the shader input. See the following examples:
						</p>
						<ul>
							<li>
								<p>
                                    <code>ivec2</code>
                                    : 
                                    <code>FORMAT_R32G32_SINT</code>
                                    , a 2-component vector of 32-bit signed integers
								</p>
							</li>
							<li>
								<p>
                                    <code>uvec4</code>
                                    : 
                                    <code>FORMAT_R32G32B32A32_UINT</code>
                                    , a 4-component vector of 32-bit unsigned integers
								</p>
							</li>
							<li>
								<p>
                                    <code>double</code>
                                    : 
                                    <code>FORMAT_R64_SFLOAT</code>
                                    , a double-precision (64-bit) float
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>offset</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the number of bytes since the start of the per-vertex data to read from.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Graphics Pipeline Vertex Input Binding
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    For the following vertices:
				</p>
<pre><code class="language-odin" data-lang="odin">Vertex :: struct {
¬† ¬† pos: ¬† eng.Vec2,
¬† ¬† color: eng.Vec3,
}

vertices := [?]Vertex{
¬† ¬† { { ¬†0.0, -0.5 }, { 1.0, 0.0, 0.0 } },
¬† ¬† { { ¬†0.5, ¬†0.5 }, { 0.0, 1.0, 0.0 } },
¬† ¬† { { -0.5, ¬†0.5 }, { 0.0, 0.0, 1.0 } },
}
</code></pre>
			</li>
			<li>
				<p>
                    We setup this in the Graphics Pipeline creation:
				</p>
<pre><code class="language-odin" data-lang="odin">vertex_binding_descriptor := vk.VertexInputBindingDescription{
&nbsp;&nbsp;&nbsp;&nbsp;binding ¬† = 0,
&nbsp;&nbsp;&nbsp;&nbsp;stride ¬† ¬†= size_of(Vertex),
&nbsp;&nbsp;&nbsp;&nbsp;inputRate = .VERTEX,
}
vertex_attribute_descriptor := [?]vk.VertexInputAttributeDescription{
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binding ¬†= 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format ¬† = .R32G32_SFLOAT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset ¬† = cast(u32)offset_of(Vertex, pos),
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binding ¬†= 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format ¬† = .R32G32B32_SFLOAT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset ¬† = cast(u32)offset_of(Vertex, color),
&nbsp;&nbsp;&nbsp;&nbsp;},
}
vertex_input_create_info := vk.PipelineVertexInputStateCreateInfo {
&nbsp;&nbsp;&nbsp;&nbsp;sType ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† = .PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;vertexBindingDescriptionCount ¬† = 1,
&nbsp;&nbsp;&nbsp;&nbsp;pVertexBindingDescriptions ¬† ¬† ¬†= &vertex_binding_descriptor,
&nbsp;&nbsp;&nbsp;&nbsp;vertexAttributeDescriptionCount = len(vertex_attribute_descriptor),
&nbsp;&nbsp;&nbsp;&nbsp;pVertexAttributeDescriptions ¬† ¬†= &vertex_attribute_descriptor[0],
}
</code></pre>
			</li>
			<li>
				<p>
                    The pipeline is now ready to accept vertex data in the format of the 
                    <code>vertices</code>
                    &nbsp;container and pass it on to our vertex shader.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Vertex Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If you run the program now with validation layers enabled, you'll see that it complains that there is no vertex buffer bound to the binding.
				</p>
			</li>
			<li>
				<p>
                    The next step is to create a vertex buffer and move the vertex data to it so the GPU is able to access it.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Creating
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Follow the tutorial for creating a buffer, specifying 
                            <code>BUFFER_USAGE_VERTEX_BUFFER</code>
                            &nbsp;as the 
                            <code>BufferCreateInfo</code>
                            &nbsp;
                            <code>usage</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="index-buffer" >
    Index Buffer
</h5>
<ul>
	<li>
		<p>
			<strong>
                Motivation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Drawing a rectangle takes two triangles, which means that we need a vertex buffer with six vertices. The problem is that the data of two vertices needs to be duplicated, resulting in redundancies.
				</p>
			</li>
			<li>
				<p>
                    The solution to this problem is to use an index buffer.
				</p>
			</li>
			<li>
				<p>
                    An index buffer is essentially an array of pointers into the vertex buffer.
				</p>
			</li>
			<li>
				<p>
                    It allows you to reorder the vertex data, and reuse existing data for multiple vertices.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250806072114.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            The first three indices define the upper-right triangle, and the last three indices define the vertices for the bottom-left triangle.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It is possible to use either 
                    <code>uint16_t</code>
                    &nbsp;or 
                    <code>uint32_t</code>
                    &nbsp;for your index buffer depending on the number of entries in 
                    <code>vertices</code>
                    . We can stick to 
                    <code>uint16_t</code>
                    &nbsp;for now because we‚Äôre using less than 65535 unique vertices.
				</p>
			</li>
			<li>
				<p>
                    Just like the vertex data, the indices need to be uploaded into a 
                    <code>VkBuffer</code>
                    &nbsp;for the GPU to be able to access them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Creating
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Follow the tutorial for creating a buffer, specifying 
                    <code>BUFFER_USAGE_INDEX_BUFFER</code>
                    &nbsp;as the 
                    <code>BufferCreateInfo</code>
                    &nbsp;
                    <code>usage</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Using
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We first need to bind the index buffer, just like we did for the vertex buffer.
				</p>
			</li>
			<li>
				<p>
                    The difference is that you can only have a 
					<strong>
                        single
					</strong>
                    &nbsp;index buffer. It‚Äôs unfortunately not possible to use different indices for each vertex attribute, so we do still have to completely duplicate vertex data even if just one attribute varies.
				</p>
			</li>
			<li>
				<p>
                    An index buffer is bound with 
                    <code>vkCmdBindIndexBuffer</code>
                    &nbsp;which has the index buffer, a byte offset into it, and the type of index data as parameters.
				</p>
				<ul>
					<li>
						<p>
                            As mentioned before, the possible types are 
                            <code>INDEX_TYPE_UINT16</code>
                            &nbsp;and 
                            <code>INDEX_TYPE_UINT32</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Just binding an index buffer doesn‚Äôt change anything yet, we also need to change the drawing command to tell Vulkan to use the index buffer.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Remove
					</em>
                    &nbsp;the 
                    <code>vkCmdDraw</code>
                    &nbsp;line and replace it with 
                    <code>vkCmdDrawIndexed</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="push-constants" >
    Push Constants
</h3>
<ul>
	<li>
		<p>
            A Push Constant is a small bank of values accessible in shaders.
		</p>
	</li>
	<li>
		<p>
            These are designed for small amount (a few dwords) of high frequency data to be updated per-recording of the command buffer.
		</p>
	</li>
	<li>
		<p>
            So that the shader can understand where this data will be sent, we specify a special push constants 
            <code>&lt;layout&gt;</code>
            &nbsp;in our shader code.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(push_constant) uniform MeshData {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 model;
} mesh_data;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Choosing to use Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In early implementations of Vulkan on Arm Mali, this was usually the fastest way of pushing data to your shaders. In more recent times, we have observed on Mali devices that 
					<em>
                        overall
					</em>
                    &nbsp;they can be slower. If performance is something you are trying to maximise on Mali devices, descriptor sets may be the way to go. However, other devices may still favour push constants.
				</p>
			</li>
			<li>
				<p>
                    Having said this, descriptor sets are one of the more complex features of Vulkan, making the convenience of push constants still worth considering as a go-to method, especially if working with trivial data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxPushConstantsSize</code>
				</p>
				<ul>
					<li>
						<p>
                            guaranteed at least 
                            <code>128</code>
                            &nbsp;bytes on all devices.
						</p>
					</li>
					<li>
						<p
							class="line-emphasis" >
                            If you're using Vulkan 1.4 the minimum was increased to 256.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/push_constants.html#push-constants" 
				class="external-link" 
				target="_blank" >
                Push Constants
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="offsets" >
    Offsets
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250829073932.png" width="525" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">layout(push_constant, std430) uniform pc {
&nbsp;&nbsp;&nbsp;&nbsp;layout(offset = 32) vec4 data;
};

layout(location = 0) out vec4 outColor;

void main() {
&nbsp;&nbsp; outColor = data;
}
</code></pre>
<pre><code class="language-c" data-lang="c">VkPushConstantRange range = {};
range.stageFlags = SHADER_STAGE_FRAGMENT;
range.offset = 32;
range.size = 16;
</code></pre>
	</li>
</ul>
<h5
	id="updating" >
    Updating
</h5>
<ul>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Push constants can be incrementally updated over the course of a command buffer.
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">// vkBeginCommandBuffer()
vkCmdBindPipeline();
vkCmdPushConstants(offset: 0, size: 16, value = [0, 0, 0, 0]);
vkCmdDraw(); // values = [0, 0, 0, 0]

vkCmdPushConstants(offset: 4, size: 8, value = [1 ,1]);
vkCmdDraw(); // values = [0, 1, 1, 0]

vkCmdPushConstants(offset: 8, size: 8, value = [2, 2]);
vkCmdDraw(); // values = [0, 1, 2, 2]
// vkEndCommandBuffer()
</code></pre>
		<ul>
			<li>
				<p>
                    Interesting how old values are kept. Values that were not changed are preserved.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="lifetime" >
    Lifetime
</h5>
<ul>
	<li>
		<p>
            <code>vkCmdPushConstants</code>
            &nbsp;is tied to the 
            <code>VkPipelineLayout</code>
            &nbsp;usage and therefore why they must match before a call to a command such as 
            <code>vkCmdDraw()</code>
            .
		</p>
	</li>
	<li>
		<p>
            Because push constants are not tied to descriptors, the use of 
            <code>vkCmdBindDescriptorSets</code>
            &nbsp;has no effect on the lifetime or 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#descriptorsets-compatibility" 
				class="external-link" 
				target="_blank" >
                pipeline layout compatibility
			</a>
            &nbsp;of push constants.
		</p>
	</li>
	<li>
		<p>
            The same way it is possible to bind descriptor sets that are never used by the shader, the same is true for push constants.
		</p>
	</li>
</ul>
<h5
	id="cpu-performance" >
    CPU Performance
</h5>
<ul>
	<li>
		<p>
            Push one struct once per draw instead of many separate vkCmdPushConstants calls (one call writing a small struct is far cheaper).
		</p>
	</li>
	<li>
		<p>
            Many small state changes cause the driver to update internal tables, validate, or patch commands ‚Äî that‚Äôs CPU work and cannot be avoided without batching.
		</p>
	</li>
	<li>
		<p>
			<em>
                Observations
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    5 push calls were taking 7.65us. I groupped all them in 1 single push call, now taking 3.08us.
				</p>
			</li>
			<li>
				<p>
                    This was substancial, as at the time I was issuing this push calls hundreds of time per frame; I later reduced this number, but anyway, could be significant.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="descriptors-sets" >
    Descriptors Sets
</h3>
<h4
	id="about" >
    About
</h4>
<ul>
	<li>
		<p>
            <code>VkDescriptorSet</code>
		</p>
	</li>
	<li>
		<p>
            One Descriptor -&gt; One Resource.
		</p>
	</li>
	<li>
		<p>
            They are always organized in Descriptor Sets.
		</p>
		<ul>
			<li>
				<p>
                    One or more descriptors contained.
				</p>
			</li>
			<li>
				<p>
                    Combine descriptors which are used in conjunction.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A handle or pointer into a resource.
		</p>
		<ul>
			<li>
				<p>
                    Note that is not just a pointer, but a pointer + metadata.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A core mechanism used to bind resources to shaders.
		</p>
	</li>
	<li>
		<p>
            Holds the binding information that connects shader inputs to data such as 
            <code>VkBuffer</code>
            &nbsp;resources and 
            <code>VkImage</code>
            &nbsp;textures.
		</p>
	</li>
	<li>
		<p>
            Think of it as a set of GPU-side pointers that you bind once.
		</p>
	</li>
	<li>
		<p>
            The internal representation of a descriptor set is whatever the driver wants it to be.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/" 
				class="external-link" 
				target="_blank" >
                Article by Arseny Kapoulkine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/descriptor_management/README.html" 
				class="external-link" 
				target="_blank" >
                Sample talking about best practices
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Content
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Where to find a Resource.
				</p>
			</li>
			<li>
				<p>
                    Usage type of a Resource.
				</p>
			</li>
			<li>
				<p>
                    Offsets, sometimes.
				</p>
			</li>
			<li>
				<p>
                    Some metadata, sometimes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250813080426.png" width="500" >
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Note - only set 0 and 2 are used in this shader
layout(set = 0, binding = 0) uniform sampler2D myTextureSampler;

layout(set = 0, binding = 2) uniform uniformBuffer0 {
&nbsp;&nbsp;&nbsp;&nbsp;float someData;
} ubo_0;

layout(set = 0, binding = 3) uniform uniformBuffer1 {
&nbsp;&nbsp;&nbsp;&nbsp;float moreData;
} ubo_1;

layout(set = 2, binding = 0) buffer storageBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float myResults;
} ssbo;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                API
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/screenshot_2025-08-06_162739.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250807073221.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxBoundDescriptorSets</code>
				</p>
			</li>
			<li>
				<p>
                    Per stage limit
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorSamplers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorUniformBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorStorageBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorSampledImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorStorageImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorInputAttachments</code>
				</p>
			</li>
			<li>
				<p>
                    Per type limit
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageResources</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetSamplers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetUniformBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetUniformBuffersDynamic</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageBuffersDynamic</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetSampledImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetInputAttachments</code>
				</p>
			</li>
			<li>
				<p>
                    <code>VkPhysicalDeviceDescriptorIndexingProperties</code>
                    &nbsp;if using 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/EXT_descriptor_indexing.html#EXT_descriptor_indexing" 
						class="external-link" 
						target="_blank" >
                        Descriptor Indexing
					</a>
				</p>
			</li>
			<li>
				<p>
                    <code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>
                    &nbsp;if using 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/EXT_inline_uniform_block.html#EXT_inline_uniform_block" 
						class="external-link" 
						target="_blank" >
                        Inline Uniform Block
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=d5p44idnZLQ" 
				class="external-link" 
				target="_blank" >
                Visual explanation {0:00 -&gt; 5:35}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Nice.
				</p>
			</li>
			<li>
				<p>
                    The rest of the video is meh.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="difficulties" >
    Difficulties
</h5>
<ul>
	<li>
		<p>
			<strong>
                Problems
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;They are not bad but they very much force a specific rendering style: you have triple / quadrupled nested for loops, binding your things based on usage and then rebind descriptor sets as needed.&quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;Many of us are moving towards bindless rendering, where you just bind everything once in one big descriptor set, and then index into it at will; tho, Vulkan 1.0 does not greatly support, and also the descriptor count for it was quite low&quot;.
				</p>
			</li>
			<li>
				<p>
                    Cannot update descriptors after binding in a command buffer.
				</p>
			</li>
			<li>
				<p>
                    All descriptors must be valid, even if not used.
				</p>
			</li>
			<li>
				<p>
                    Descriptor arrays must be sampled uniformly.
				</p>
				<ul>
					<li>
						<p>
                            Different invocations can‚Äôt use different indices.
						</p>
					</li>
					<li>
						<p>
                            Can sample ‚Äúdynamically uniform‚Äù, e.g. runtime-based index.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Upper limit on descriptor counts.
				</p>
			</li>
			<li>
				<p>
                    Discourages GPU-driven rendering architectures.
				</p>
				<ul>
					<li>
						<p>
                            Due to the need to set up descriptor sets per draw call it‚Äôs hard to adapt any of the aforementioned schemes to GPU-based culling or command submission.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solutions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Descriptor Indexing
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Available in 1.3, optional in 1.2, or 
                            <code>EXT_descriptor_indexing</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Update descriptors after binding.
						</p>
					</li>
					<li>
						<p>
                            Update unused descriptors.
						</p>
					</li>
					<li>
						<p>
                            Relax requirement that all descriptors must be valid, even if unused.
						</p>
					</li>
					<li>
						<p>
                            Non-uniform array indexing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Buffer Device Address
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Available in 1.3, optional in 1.2, or 
                            <code>KHR_buffer_device_address</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Directly access buffers through addresses without a descriptor.
						</p>
					</li>
					<li>
						<p>
                            See [[#Physical Storage Buffer]] below.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Descriptor Buffers ‚Äì EXT_descriptor_buffer
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Manage descriptors directly.
						</p>
					</li>
					<li>
						<p>
                            <s>Similar to D3D12‚Äôs descriptor model </s>.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="allocation" >
    Allocation
</h4>
<ul>
	<li>
		<p>
            A scheme that works well is to use free lists of descriptor set pools; whenever you need a descriptor set pool, you allocate one from the free list and use it for subsequent descriptor set allocations in the current frame on the current thread. Once you run out of descriptor sets in the current pool, you allocate a new pool. Any pools that were used in a given frame need to be kept around; once the frame has finished rendering, as determined by the associated fence objects, the descriptor set pools can reset via 
            <code>vkResetDescriptorPool</code>
            &nbsp;and returned to free lists. While it‚Äôs possible to free individual descriptors from a pool via 
            <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
            , this complicates the memory management on the driver side and is not recommended.
		</p>
	</li>
	<li>
		<p>
            When a descriptor set pool is created, application specifies the maximum number of descriptor sets allocated from it, as well as the maximum number of descriptors of each type that can be allocated from it. In Vulkan 1.1, the application doesn‚Äôt have to handle accounting for these limits ‚Äì it can just call vkAllocateDescriptorSets and handle the error from that call by switching to a new descriptor set pool. Unfortunately, in Vulkan 1.0 without any extensions, it‚Äôs an error to call vkAllocateDescriptorSets if the pool does not have available space, so application must track the number of sets and descriptors of each type to know beforehand when to switch to a different pool.
		</p>
	</li>
	<li>
		<p>
            Different pipeline objects may use different numbers of descriptors, which raises the question of pool configuration. A straightforward approach is to create all pools with the same configuration that uses the worst-case number of descriptors for each type ‚Äì for example, if each set can use at most 16 texture and 8 buffer descriptors, one can allocate all pools with maxSets=1024, and pool sizes 16
			<em>
                1024 for texture descriptors and 8
			</em>
            1024 for buffer descriptors. This approach can work but in practice it can result in very significant memory waste for shaders with different descriptor count ‚Äì you can‚Äôt allocate more than 1024 descriptor sets out of a pool with the aforementioned configuration, so if most of your pipeline objects use 4 textures, you‚Äôll be wasting 75% of texture descriptor memory.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Strategies
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Two alternatives that provide a better balance memory use:
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    Measure an average number of descriptors used in a shader pipeline per type for a characteristic scene and allocate pool sizes accordingly. For example, if in a given scene we need 3000 descriptor sets, 13400 texture descriptors, and 1700 buffer descriptors, then the average number of descriptors per set is 4.47 textures (rounded up to 5) and 0.57 buffers (rounded up to 1), so a reasonable configuration of a pool is maxSets=1024, 5*1024 texture descriptors, 1024 buffer descriptors. When a pool is out of descriptors of a given type, we allocate a new one ‚Äì so this scheme is guaranteed to work and should be reasonably efficient on average.
				</p>
			</li>
			<li>
				<p>
                    Group shader pipeline objects into size classes, approximating common patterns of descriptor use, and pick descriptor set pools using the appropriate size class. This is an extension of the scheme described above to more than one size class. For example, it‚Äôs typical to have large numbers of shadow/depth prepass draw calls, and large numbers of regular draw calls in a scene ‚Äì but these two groups have different numbers of required descriptors, with shadow draw calls typically requiring 0 to 1 textures per set and 0 to 1 buffers when dynamic buffer offsets are used. To optimize memory use, it‚Äôs more appropriate to allocate descriptor set pools separately for shadow/depth and other draw calls. Similarly to general-purpose allocators that can have size classes that are optimal for a given application, this can still be managed in a lower-level descriptor set management layer as long as it‚Äôs configured with application specific descriptor set usages beforehand.
				</p>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            Descriptors are like pointers, so as any pointer they need to allocate space to live ahead of time.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How many
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Its possible to have 1 very big descriptor pool that handles the entire engine, but that means we need to know what descriptors we will be using for everything ahead of time.
				</p>
			</li>
			<li>
				<p>
                    That can be very tricky to do at scale. Instead, we will keep it simpler, and we will have 
					<em>
                        multiple descriptor pools for different parts of the project
					</em>
                    , and try to be more accurate with them.
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            I don't know what that actually means in practice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPool.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorPool</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Maintains a pool of descriptors, from which descriptor sets are allocated.
				</p>
			</li>
			<li>
				<p>
                    Descriptor pools are externally synchronized, meaning that the application 
					<strong>
                        must
					</strong>
                    &nbsp;not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.
				</p>
			</li>
			<li>
				<p>
                    They are very opaque.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorPoolCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Contains a type of descriptor (same 
                            <code>VkDescriptorType</code>
                            &nbsp;as on the bindings above ), alongside a ratio to multiply the 
                            <code>maxSets</code>
                            &nbsp;parameter is.
						</p>
					</li>
					<li>
						<p>
                            This lets us directly control how big the pool is going to be. 
                            <code>maxSets</code>
                            &nbsp;controls how many 
                            <code>VkDescriptorSets</code>
                            &nbsp;we can create from the pool in total, and the pool sizes give how many individual bindings of a given type are owned.
						</p>
					</li>
					<li>
						<p>
                            <code>flags</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorPoolCreateFlagBits
									</a>
                                    &nbsp;specifying certain supported operations on the pool.
								</p>
							</li>
							<li>
								<p>
                                    <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
								</p>
								<ul>
									<li>
										<p>
                                            Determines if individual descriptor sets can be freed or not:
										</p>
									</li>
									<li>
										<p>
                                            We're not going to touch the descriptor set after creating it, so we don't need this flag. You can leave 
                                            <code>flags</code>
                                            &nbsp;to its default value of 
                                            <code>0</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND</code>
								</p>
								<ul>
									<li>
										<p>
                                            Descriptor pool creation 
											<strong>
                                                may
											</strong>
                                            &nbsp;fail with the error 
                                            <code>ERROR_FRAGMENTATION</code>
                                            &nbsp;if the total number of descriptors across all pools (including this one) created with this bit set exceeds 
                                            <code>maxUpdateAfterBindDescriptorsInAllPools</code>
                                            , or if fragmentation of the underlying hardware resources occurs.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>maxSets</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the maximum number of descriptor sets that 
									<strong>
                                        can
									</strong>
                                    &nbsp;be allocated from the pool.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>poolSizeCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of elements in 
                                    <code>pPoolSizes</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pPoolSizes</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorPoolSize
									</a>
                                    &nbsp;structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
								</p>
							</li>
							<li>
								<p>
                                    If multiple 
                                    <code>VkDescriptorPoolSize</code>
                                    &nbsp;structures containing the same descriptor type appear in the 
                                    <code>pPoolSizes</code>
                                    &nbsp;array then the pool will be created with enough storage for the total number of descriptors of each type.
								</p>
							</li>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkDescriptorPoolSize</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            <code>type</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is the type of descriptor.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>descriptorCount</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is the number of descriptors of that type to allocate. If 
                                                    <code>type</code>
                                                    &nbsp;is 
                                                    <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                                    &nbsp;then 
                                                    <code>descriptorCount</code>
                                                    &nbsp;is the number of bytes to allocate for descriptors of this type.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetAllocateInfo</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    <code>descriptorPool</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the pool which the sets will be allocated from.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorSetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Determines the number of descriptor sets to be allocated from the pool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSetLayouts</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkAllocateDescriptorSets()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The allocated descriptor sets are returned in 
                    <code>pDescriptorSets</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    When a descriptor set is allocated, the initial state is largely uninitialized and all descriptors are undefined, with the exception that samplers with a non-null 
                    <code>pImmutableSamplers</code>
                    &nbsp;are initialized on allocation.
				</p>
			</li>
			<li>
				<p>
                    Descriptors also become undefined if the underlying resource or view object is destroyed.
				</p>
			</li>
			<li>
				<p>
                    Descriptor sets containing undefined descriptors 
					<strong>
                        can
					</strong>
                    &nbsp;still be bound and used, subject to the following conditions:
				</p>
				<ul>
					<li>
						<p>
                            For descriptor set bindings created with the 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;bit set:
						</p>
						<ul>
							<li>
								<p>
                                    All descriptors in that binding that are dynamically used 
									<strong>
                                        must
									</strong>
                                    &nbsp;have been populated before the descriptor set is 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
										class="external-link" 
										target="_blank" >
                                        consumed
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            For descriptor set bindings created without the 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;bit set:
						</p>
						<ul>
							<li>
								<p>
                                    All descriptors in that binding that are statically used 
									<strong>
                                        must
									</strong>
                                    &nbsp;have been populated before the descriptor set is 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
										class="external-link" 
										target="_blank" >
                                        consumed
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Descriptor bindings with descriptor type of 
                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            &nbsp;
							<strong>
                                can
							</strong>
                            &nbsp;be undefined when the descriptor set is 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
								class="external-link" 
								target="_blank" >
                                consumed
							</a>
                            ; though values in that block will be undefined.
						</p>
					</li>
					<li>
						<p>
                            Entries that are not used by a pipeline 
							<strong>
                                can
							</strong>
                            &nbsp;have undefined descriptors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAllocateInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSetAllocateInfo
							</a>
                            &nbsp;structure describing parameters of the allocation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorSets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSet
							</a>
                            &nbsp;handles in which the resulting descriptor set objects are returned.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Multithreading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor pools are externally synchronized, meaning that the application 
					<strong>
                        must
					</strong>
                    &nbsp;not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.
				</p>
			</li>
			<li>
				<p>
                    Command Pools are used to allocate, free, reset, and update descriptor sets. By creating multiple descriptor pools, each application host thread is able to manage a descriptor set in each descriptor pool at the same time.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="best-practices" >
    Best Practices
</h5>
<ul>
	<li>
		<p>
            Don‚Äôt allocate descriptor sets if nothing in the set changed. In the model with slots that are shared between different stages, this can mean that if no textures are set between two draw calls, you don‚Äôt need to allocate the descriptor set with texture descriptors.
		</p>
	</li>
	<li>
		<p>
            Don't allocate descriptor sets from descriptor pools on performance critical code paths.
		</p>
	</li>
	<li>
		<p>
            Don't allocate, free or update descriptor sets every frame, unless it is necessary.
		</p>
	</li>
	<li>
		<p>
            Don't set 
            <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
            &nbsp;if you do not need to free individual descriptor sets.
		</p>
		<ul>
			<li>
				<p>
                    Setting 
                    <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
                    &nbsp;may prevent the implementation from using a simpler (and faster) allocator.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="descriptor-types" >
    Descriptor Types
</h4>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#descriptorsets-types" 
				class="external-link" 
				target="_blank" >
                Descriptor Types
			</a>
            .
		</p>
	</li>
</ul>
<h6
	id="overview" >
    Overview
</h6>
<ul>
	<li>
		<p>
            For buffers, application must choose between uniform and storage buffers, and whether to use dynamic offsets or not. Uniform buffers have a limit on the maximum addressable size ‚Äì on desktop hardware, you get up to 64 KB of data, however on mobile hardware some GPUs only provide 16 KB of data (which is also the guaranteed minimum by the specification). The buffer resource can be larger than that, but shader can only access this much data through one descriptor.
		</p>
	</li>
	<li>
		<p>
            On some hardware, there is no difference in access speed between uniform and storage buffers, however for other hardware depending on the access pattern uniform buffers can be significantly faster. Prefer uniform buffers for small to medium sized data especially if the access pattern is fixed (e.g. for a buffer with material or scene constants). Storage buffers are more appropriate when you need large arrays of data that need to be larger than the uniform buffer limit and are indexed dynamically in the shader.
		</p>
	</li>
	<li>
		<p>
            For textures, if filtering is required, there is a choice of combined image/sampler descriptor (where, like in OpenGL, descriptor specifies both the source of the texture data, and the filtering/addressing properties), separate image and sampler descriptors (which maps better to Direct3D 11 model), and image descriptor with an immutable sampler descriptor, where the sampler properties must be specified when pipeline object is created.
		</p>
	</li>
	<li>
		<p>
            The relative performance of these methods is highly dependent on the usage pattern; however, in general immutable descriptors map better to the recommended usage model in other newer APIs like Direct3D 12, and give driver more freedom to optimize the shader. This does alter renderer design to a certain extent, making it necessary to implement certain dynamic portions of the sampler state, like per-texture LOD bias for texture fade-in during streaming, using shader ALU instructions.
		</p>
	</li>
</ul>
<h5
	id="storage-images" >
    Storage Images
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
		</p>
	</li>
	<li>
		<p>
            Is a descriptor type that allows shaders to read from and write to an image without using a fixed-function graphics pipeline.
		</p>
	</li>
	<li>
		<p>
            This is particularly useful for compute shaders and advanced rendering techniques.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_storage_images" 
				class="external-link" 
				target="_blank" >
                Storage Images and Implementation
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// FORMAT_R32_UINT
layout(set = 0, binding = 0, r32ui) uniform uimage2D storageImage;

// example usage for reading and writing in GLSL
const uvec4 texel = imageLoad(storageImage, ivec2(0, 0));
imageStore(storageImage, ivec2(1, 1), texel);
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Use cases
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Image Processing
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Storage images are ideal for image processing tasks like filters, blurs, and other post-processing effects.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="sampler" >
    Sampler
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_SAMPLER</code>
            &nbsp;and 
            <code>DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler samplerDescriptor;
layout(set = 0, binding = 1) uniform texture2D sampledImage;

// example usage of using texture() in GLSL
vec4 data = texture(sampler2D(sampledImage,&nbsp;&nbsp;samplerDescriptor), vec2(0.0, 0.0));
</code></pre>
<h5
	id="combined-image-sampler" >
    Combined Image Sampler
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
		</p>
	</li>
	<li>
		<p>
            On some implementations, it 
			<em>
                may
			</em>
            &nbsp;be more efficient to sample from an image using a combination of sampler and sampled image that are stored together in the descriptor set in a combined descriptor.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D combinedImageSampler;

// example usage of using texture() in GLSL
vec4 data = texture(combinedImageSampler, vec2(0.0, 0.0));
</code></pre>
<h5
	id="uniform-buffer-ubo-uniform-buffer-object" >
    Uniform Buffer / UBO (Uniform Buffer Object)
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
		</p>
	</li>
	<li>
		<p>
            Uniform buffers can also have 
			<a
				href="https://docs.vulkan.org/guide/latest/descriptor_dynamic_offset.html" 
				class="external-link" 
				target="_blank" >
                dynamic offsets at bind time
			</a>
            &nbsp;(
            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
            ).
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform uniformBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float a;
&nbsp;&nbsp;&nbsp;&nbsp;int b;
} ubo;

// example of reading from UBO in GLSL
int x = ubo.b + 1;
vec3 y = vec3(ubo.a);
</code></pre>
<ul>
	<li>
		<p>
            Uniform Buffers commonly use 
            <code>std140</code>
            &nbsp;layout (strict alignment rules, predictable padding).
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Source: ChatGPT. I want to confirm.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">/* UBO: small read-only data (std140) */
layout(set = 0, binding = 0, std140) uniform SceneParams {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 viewProj;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 lightPos;
&nbsp;&nbsp;&nbsp;&nbsp;float time;
} scene;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                UBO (Uniform Buffer Object)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ‚ÄúUniform buffer object‚Äù is more of an OpenGL-era name, but some Vulkan tutorials and developers still use it informally to mean the same thing ‚Äî the buffer that holds uniform data.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="storage-buffer-ssbo-shader-storage-buffer-object" >
    Storage Buffer / SSBO (Shader Storage Buffer Object)
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
		</p>
	</li>
	<li>
		<p>
            GLSL uses distinct address spaces: 
            <code>uniform</code>
            &nbsp;‚Üí UBO, 
            <code>buffer</code>
            &nbsp;‚Üí SSBO.
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>std430</code>
            &nbsp;layout by default (tighter packing, fewer padding requirements).
		</p>
	</li>
	<li>
		<p>
            SSBO (Shader Storage Buffer Object) is a OpenGL term.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// Implicit std430 (default)
layout(set = 0, binding = 0) buffer storageBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float a;
&nbsp;&nbsp;&nbsp;&nbsp;int b;
} ssbo;

// Explicit std430
layout(set = 0, binding = 1, std430) buffer ParticleData {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 pos[];
} particles;

// Reading and writing to a SSBO in GLSL
ssbo.a = ssbo.a + 1.0;
ssbo.b = ssbo.b + 1;
</code></pre>
<ul>
	<li>
		<p>
            <code>BufferBlock</code>
            &nbsp;and 
            <code>Uniform</code>
            &nbsp;would have been seen prior to 
			<a
				href="https://docs.vulkan.org/guide/latest/extensions/shader_features.html#KHR_storage_buffer_storage_class" 
				class="external-link" 
				target="_blank" >
                <code>KHR_storage_buffer_storage_class</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Storage buffers can also have dynamic offsets at bind time 
			<a
				href="https://docs.vulkan.org/guide/latest/descriptor_dynamic_offset.html" 
				class="external-link" 
				target="_blank" >
                <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Why SSBO for dynamic arrays
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>std430</code>
                    &nbsp;allows tight packing and runtime-sized arrays 
                    <code>(T data[])</code>
                    , which is ideal for dynamic-length storage.
				</p>
			</li>
			<li>
				<p>
                    SSBOs allow arbitrary indexing, read/write, and atomics.
				</p>
			</li>
			<li>
				<p>
                    maxStorageBufferRange is usually much larger than 
                    <code>maxUniformBufferRange</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    You can use 
                    <code>*_DYNAMIC</code>
                    &nbsp;descriptors to bind multiple subranges of one large backing buffer cheaply.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Many arrays
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A buffer block may contain multiple arrays, but only the last member of the block may be a runtime-sized (unsized) array 
                    <code>T x[]</code>
                    . All other arrays must be fixed-size (compile-time constant) or you must implement sizing/offsets yourself.
				</p>
				<ul>
					<li>
						<p>
                            This is 
							<strong>
                                invalid
							</strong>
                            , even with descriptor indexing:
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set = 0, binding = 0) buffer FixedArrays { 
&nbsp;&nbsp;&nbsp;&nbsp;vec4 A[]; 
&nbsp;&nbsp;&nbsp;&nbsp;vec2 B[]; 
&nbsp;&nbsp;&nbsp;&nbsp;mat4 C[]; 
&nbsp;&nbsp;&nbsp;&nbsp;some_struct D[];
} fixedArrays;
</code></pre>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    Use a 
                    <code>uint x[]</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            32-bit words; simplest and portable.
						</p>
					</li>
					<li>
						<p>
                            This is effectively an untyped byte/word blob stored in the SSBO and you manually reinterpret (cast) it in the shader
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set = 0, binding = 0) buffer PackedBytes {
&nbsp;&nbsp;&nbsp;&nbsp;uint countA;&nbsp;&nbsp; // number of A elements
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetA;&nbsp;&nbsp;// offset into data[] in uint words
&nbsp;&nbsp;&nbsp;&nbsp;uint countB;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetB;&nbsp;&nbsp;// offset into data[] in uint words
&nbsp;&nbsp;&nbsp;&nbsp;uint countC;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetC;

&nbsp;&nbsp;&nbsp;&nbsp;uint data[];&nbsp;&nbsp; // payload in 32-bit words
} pb;

// helpers
float readFloat(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return uintBitsToFloat(pb.data[baseWordIndex]);
}

vec2 readVec2(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return vec2(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 0]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 1])
&nbsp;&nbsp;&nbsp;&nbsp;);
}

vec3 readVec3(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return vec3(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 0]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 1]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 2])
&nbsp;&nbsp;&nbsp;&nbsp;);
}

vec4 readVec4(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 0]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 1]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 2]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 3])
&nbsp;&nbsp;&nbsp;&nbsp;);
}

mat4 readMat4(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;// mat4 stored column-major as 16 floats (4 columns of vec4)
&nbsp;&nbsp;&nbsp;&nbsp;return mat4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 4),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 8),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 12)
&nbsp;&nbsp;&nbsp;&nbsp;);
}
</code></pre>
			</li>
			<li>
				<p>
                    Use a 
                    <code>vec4 x[]</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            128-bit blocks; simpler alignment for vec4/mat4 data.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">// Pack everything into vec4 blocks for simple alignment
layout(std430, set = 0, binding = 0) buffer Packed {
&nbsp;&nbsp;&nbsp;&nbsp;uint countA;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetA; // in vec4-blocks
&nbsp;&nbsp;&nbsp;&nbsp;uint countB;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetB; // in vec4-blocks
&nbsp;&nbsp;&nbsp;&nbsp;uint countC;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetC; // in vec4-blocks
&nbsp;&nbsp;&nbsp;&nbsp;uint countD;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetD; // in vec4-blocks

&nbsp;&nbsp;&nbsp;&nbsp;vec4 blocks[]; // single runtime-sized array (last member)
} packed;

// helpers
vec4 getA(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;return packed.blocks[packed.offsetA + i];
}

vec2 getB(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;return packed.blocks[packed.offsetB + i].xy; // we store each B in one vec4 block
}

mat4 getC(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;uint base = packed.offsetC + i * 4; // mat4 occupies 4 vec4 blocks
&nbsp;&nbsp;&nbsp;&nbsp;return mat4(packed.blocks[base + 0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packed.blocks[base + 1],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packed.blocks[base + 2],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packed.blocks[base + 3]);
}

// for some_struct D that we store as 1 vec4 per element:
some_struct getD(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 v = packed.blocks[packed.offsetD + i];
&nbsp;&nbsp;&nbsp;&nbsp;// decode v -&gt; some_struct fields
}
</code></pre>
			</li>
			<li>
				<p>
                    Use many SSBOs:
				</p>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set=0, binding=0) buffer BufA { vec4 A[]; } bufA;
layout(std430, set=0, binding=1) buffer BufB { vec2 B[]; } bufB;
layout(std430, set=0, binding=2) buffer BufC { mat4 C[]; } bufC;
layout(std430, set=0, binding=3) buffer BufD { some_struct D[]; } bufD;
</code></pre>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="texel-buffer" >
    Texel Buffer
</h5>
<ul>
	<li>
		<p>
            Texel buffers are a way to access buffer data with texture-like operations in shaders.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_texel_buffers" 
				class="external-link" 
				target="_blank" >
                Texel Buffers and Implementation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_format_compatibility_requirements" 
				class="external-link" 
				target="_blank" >
                Compatibility Requirements
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The format specified in the shader (SPIR-V Image Format) must 
					<strong>
                        exactly match
					</strong>
                    &nbsp;the format used when creating the VkImageView (Vulkan Format).
				</p>
			</li>
			<li>
				<p>
                    Require exact format matching between the shader and the view. The views must always match the shader exactly.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_best_practices" 
				class="external-link" 
				target="_blank" >
                Best Practices
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Uniform Texel Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>
				</p>
			</li>
			<li>
				<p>
                    Read-only access.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform textureBuffer uniformTexelBuffer;

// example of reading texel buffer in GLSL
vec4 data = texelFetch(uniformTexelBuffer, 0);
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Use cases
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Lookup Tables
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Uniform texel buffers are useful for implementing lookup tables that need to be accessed with texture-like operations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Storage Texel Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>
				</p>
			</li>
			<li>
				<p>
                    Read-write access.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// FORMAT_R8G8B8A8_UINT
layout(set = 0, binding = 0, rgba8ui) uniform uimageBuffer storageTexelBuffer;

// example of reading and writing texel buffer in GLSL
int offset = int(gl_GlobalInvocationID.x);
vec4 data = imageLoad(storageTexelBuffer, offset);
imageStore(storageTexelBuffer, offset, uvec4(0));
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Use cases
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Particle Systems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Storage texel buffers can be used to store and update particle data in a compute shader, which can then be read by a vertex shader for rendering.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="input-attachment" >
    Input Attachment
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout (input_attachment_index = 0, set = 0, binding = 0) uniform subpassInput inputAttachment;

// example loading the attachment data in GLSL
vec4 data = subpassLoad(inputAttachment);
</code></pre>
<h4
	id="updates" >
    Updates
</h4>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            A Descriptor Set, even though created and allocated, is still empty. We need to fill it up with data.
		</p>
	</li>
	<li>
		<p>
            Updates 
			<strong>
                must
			</strong>
            &nbsp;happen outside of a command record and execution.
		</p>
		<ul>
			<li>
				<p>
                    No update after 
                    <code>vkCmdBindDescriptorSets()</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Usually you update before 
                    <code>vkBeginCommandBuffer()</code>
                    &nbsp;or after the 
                    <code>vkQueueSubmit()</code>
                    &nbsp;(if we know the sync is done for cmd).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                If using Descriptor Indexing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptors can be updated after binding in command buffers.
				</p>
				<ul>
					<li>
						<p>
                            Command buffer execution will use most recent updates.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250807094326.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSet.html" 
				class="external-link" 
				target="_blank" >
                <code>VkWriteDescriptorSet</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>dstSet</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the destination descriptor set to update.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dstBinding</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the descriptor binding within that set.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dstArrayElement</code>
				</p>
				<ul>
					<li>
						<p>
                            Remember that descriptors can be arrays, so we also need to specify the first index in the array that we want to update.
						</p>
					</li>
					<li>
						<p>
                            If not using an array, the index is simply 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Is the starting element in that array.
						</p>
					</li>
					<li>
						<p>
                            If the descriptor binding identified by 
                            <code>dstSet</code>
                            &nbsp;and 
                            <code>dstBinding</code>
                            &nbsp;has a descriptor type of 
                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            &nbsp;then 
                            <code>dstArrayElement</code>
                            &nbsp;specifies the starting byte offset within the binding.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorCount</code>
				</p>
				<ul>
					<li>
						<p>
                            It's a descriptor count, 
							<strong>
                                not
							</strong>
                            &nbsp;a descriptor SET count!!
						</p>
					</li>
					<li>
						<p>
                            Is the number of descriptors to update.
						</p>
					</li>
					<li>
						<p>
                            If the descriptor binding identified by 
                            <code>dstSet</code>
                            &nbsp;and 
                            <code>dstBinding</code>
                            &nbsp;has a descriptor type of 
                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            , then 
                            <code>descriptorCount</code>
                            &nbsp;specifies the number of bytes to update.
						</p>
					</li>
					<li>
						<p>
                            Otherwise, 
                            <code>descriptorCount</code>
                            &nbsp;is one of
						</p>
						<ul>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pImageInfo</code>
								</p>
							</li>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pBufferInfo</code>
								</p>
							</li>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pTexelBufferView</code>
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>dataSize</code>
                                    &nbsp;member of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetInlineUniformBlock.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetInlineUniformBlock
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>accelerationStructureCount</code>
                                    &nbsp;of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetAccelerationStructureKHR
									</a>
                                    &nbsp;or 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureNV.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetAccelerationStructureNV
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>descriptorCount</code>
                                    &nbsp;of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetTensorARM.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetTensorARM
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorType</code>
				</p>
				<ul>
					<li>
						<p>
                            We need to specify the type of descriptor again
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorType.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorType
							</a>
                            &nbsp;specifying the type of each descriptor in 
                            <code>pImageInfo</code>
                            , 
                            <code>pBufferInfo</code>
                            , or 
                            <code>pTexelBufferView</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;be the same type as the 
                            <code>descriptorType</code>
                            &nbsp;specified in 
                            <code>VkDescriptorSetLayoutBinding</code>
                            &nbsp;for 
                            <code>dstSet</code>
                            &nbsp;at 
                            <code>dstBinding</code>
                            , 
							<strong>
                                except
							</strong>
                            &nbsp;if 
                            <code>VkDescriptorSetLayoutBinding</code>
                            &nbsp;for 
                            <code>dstSet</code>
                            &nbsp;at 
                            <code>dstBinding</code>
                            &nbsp;is equal to 
                            <code>DESCRIPTOR_TYPE_MUTABLE_EXT</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The type of the descriptor also controls which array the descriptors are taken from.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pBufferInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorBufferInfo
							</a>
                            &nbsp;structures or is ignored, as described below.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDescriptorBufferInfo</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Structure specifying descriptor buffer information
								</p>
							</li>
							<li>
								<p>
                                    Specifies the buffer and the region within it that contains the data for the descriptor.
								</p>
							</li>
							<li>
								<p>
                                    <code>buffer</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the buffer resource or 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/NULL_HANDLE.html" 
												class="external-link" 
												target="_blank" >
                                                NULL_HANDLE
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>offset</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the offset in bytes from the start of 
                                            <code>buffer</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.
										</p>
									</li>
									<li>
										<p>
                                            For 
                                            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                            &nbsp;and 
                                            <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                            &nbsp;descriptor types:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>offset</code>
                                                    &nbsp;is the base offset from which the dynamic offset is applied.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>range</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the size in bytes that is used for this descriptor update, or 
                                            <code>WHOLE_SIZE</code>
                                            &nbsp;to use the range from 
                                            <code>offset</code>
                                            &nbsp;to the end of the buffer.
										</p>
										<ul>
											<li>
												<p>
                                                    When 
                                                    <code>range</code>
                                                    &nbsp;is 
                                                    <code>WHOLE_SIZE</code>
                                                    &nbsp;the effective range is calculated at 
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html" 
														class="external-link" 
														target="_blank" >
                                                        vkUpdateDescriptorSets
													</a>
                                                    &nbsp;by taking the size of 
                                                    <code>buffer</code>
                                                    &nbsp;minus the 
                                                    <code>offset</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            For 
                                            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                            &nbsp;and 
                                            <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                            &nbsp;descriptor types:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>range</code>
                                                    &nbsp;is the static size used for all dynamic offsets.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pImageInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorImageInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorImageInfo
							</a>
                            &nbsp;structures or is ignored, as described below.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorImageInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDescriptorImageInfo</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    <code>imageLayout</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the layout that the image subresources accessible from 
                                            <code>imageView</code>
                                            &nbsp;will be in at the time this descriptor is accessed.
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            , and 
                                            <code>DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>imageView</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is an image view handle or 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/NULL_HANDLE.html" 
												class="external-link" 
												target="_blank" >
                                                NULL_HANDLE
											</a>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            , and 
                                            <code>DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>sampler</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a sampler handle.
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>DESCRIPTOR_TYPE_SAMPLER</code>
                                            &nbsp;and 
                                            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            &nbsp;if the binding being updated does not use immutable samplers.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pTexelBufferView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferView.html" 
								class="external-link" 
								target="_blank" >
                                VkBufferView
							</a>
                            &nbsp;handles as described in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-buffer-views" 
								class="external-link" 
								target="_blank" >
                                Buffer Views
							</a>
                            &nbsp;section or is ignored, as described below.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkUpdateDescriptorSets()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>descriptorWriteCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorWrites</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorWrites</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkWriteDescriptorSet
							</a>
                            &nbsp;structures describing the descriptor sets to write to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorCopyCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorCopies</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorCopies</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkCopyDescriptorSet
							</a>
                            &nbsp;structures describing the descriptor sets to copy between.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="best-practices" >
    Best Practices
</h5>
<ul>
	<li>
		<p>
            Don‚Äôt update descriptor sets if nothing in the set changed. In the model with slots that are shared between different stages, this can mean that if no textures are set between two draw calls, you don‚Äôt need to update the descriptor set with texture descriptors.
		</p>
	</li>
	<li>
		<p>
            When rendering dynamic objects the application will need to push some amount of per-object data to the GPU, such as the MVP matrix. This data may not fit into the push constant limit for the device, so it becomes necessary to send it to the GPU by putting it into a 
            <code>VkBuffer</code>
            &nbsp;and binding a descriptor set that points to it.
		</p>
	</li>
	<li>
		<p>
            Materials also need their own descriptor sets, which point to the textures they use. We can either bind per-material and per-object descriptor sets separately or collate them into a single set. Either way, complex applications will have a large amount of descriptor sets that may need to change on the fly, for example due to textures being streamed in or out.
		</p>
	</li>
	<li>
		<p>
			<em>
                Not-good Solution: One or more pools per-frame, resetting the pool
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The simplest approach to circumvent the issue is to have one or more 
                    <code>VkDescriptorPool</code>
                    s per frame, reset them at the beginning of the frame and allocate the required descriptor sets from it. This approach will consist of a 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkResetDescriptorPool.html" 
						class="external-link" 
						target="_blank" >
                        vkResetDescriptorPool()
					</a>
                    &nbsp;call at the beginning, followed by a series of 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkAllocateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkAllocateDescriptorSets()
					</a>
                    &nbsp;and 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkUpdateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkUpdateDescriptorSets()
					</a>
                    &nbsp;to fill them with data.
				</p>
			</li>
			<li>
				<p>
                    This is very useful for things like per-frame descriptors. That way we can have descriptors that are used just for one frame, allocated dynamically, and then before we start the frame we completely delete all of them in one go.
				</p>
			</li>
			<li>
				<p>
                    This is confirmed to be a fast path by GPU vendors, and recommended to use when you need to handle per-frame descriptor sets.
				</p>
			</li>
			<li>
				<p>
                    The issue is that these calls can add a significant overhead to the CPU frame time, especially on mobile. In the worst cases, for example calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkUpdateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkUpdateDescriptorSets()
					</a>
                    &nbsp;for each draw call, the time it takes to update descriptors can be longer than the time of the draws themselves.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution: Caching descriptor sets
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A major way to reduce descriptor set updates is to re-use them as much as possible. Instead of calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkResetDescriptorPool.html" 
						class="external-link" 
						target="_blank" >
                        vkResetDescriptorPool()
					</a>
                    &nbsp;every frame, the app will keep the 
                    <code>VkDescriptorSet</code>
                    &nbsp;handles stored with some caching mechanism to access them.
				</p>
			</li>
			<li>
				<p>
                    The cache could be a hashmap with the contents of the descriptor set (images, buffers) as key. This approach is used in our framework by default. It is possible to remove another level of indirection by storing descriptor set handles directly in the materials and/or meshes.
				</p>
			</li>
			<li>
				<p>
                    Caching descriptor sets has a dramatic effect on frame time for our CPU-heavy scene.
				</p>
			</li>
			<li>
				<p>
                    In this game on a 2019 mobile phone it went from 44ms (23fps) to 27ms (37fps). This is a 38% decrease in frame time.
				</p>
			</li>
			<li>
				<p>
                    This system is reasonably easy to implement for a static scene, but it becomes harder when you need to delete descriptor sets. Complex engines may implement techniques to figure out which descriptor sets have not been accessed for a certain number of frames, so they can be removed from the map.
				</p>
			</li>
			<li>
				<p>
                    This may correspond to calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkFreeDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkFreeDescriptorSets()
					</a>
                    , but this solution poses another issue: in order to free individual descriptor sets the pool has to be created with the 
                    <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
                    &nbsp;flag. Mobile implementations may use a simpler allocator if that flag is not set, relying on the fact that pool memory will only be recycled in block.
				</p>
			</li>
			<li>
				<p>
                    It is possible to avoid using that flag by updating descriptor sets instead of deleting them. The application can keep track of recycled descriptor sets and re-use one of them when a new one is requested.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution: One buffer per-frame
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We will now explore an alternative approach, that is complementary to descriptor caching in some way. Especially for applications in which descriptor caching is not quite feasible, buffer management is another lever for optimizing performance.
				</p>
			</li>
			<li>
				<p>
                    As discussed at the beginning, each rendered object will typically need some uniform data along with it, that needs to be pushed to the GPU somehow. A straightforward approach is to store a 
                    <code>VkBuffer</code>
                    &nbsp;per object and update that data for each frame.
				</p>
			</li>
			<li>
				<p>
                    This already poses an interesting question: is one buffer enough? The problem is that this data will change dynamically and will be in use by the GPU while the frame is in flight.
				</p>
			</li>
			<li>
				<p>
                    Since we do not want to flush the GPU pipeline between each frame, we will need to keep several copies of each buffer, one for each frame in flight.
				</p>
			</li>
			<li>
				<p>
                    Another similar option is to use just one buffer per object, but with a size equal to 
                    <code>num_frames * buffer_size</code>
                    , then offset it dynamically based on the frame index.
				</p>
				<ul>
					<li>
						<p>
                            For each frame, one buffer per object is created and filled with data. This means that we will have many descriptor sets to create, since every object will need one that points to its 
                            <code>VkBuffer</code>
                            . Furthermore, we will have to update many buffers separately, meaning we cannot control their memory layout and we might lose some optimization opportunities with caching.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    We can address both problems by reverting the approach: instead of having a 
                    <code>VkBuffer</code>
                    &nbsp;per object containing per-frame data, we will have a 
                    <code>VkBuffer</code>
                    &nbsp;per frame containing per-object data. The buffer will be cleared at the beginning of the frame, then each object will record its data and will receive a dynamic offset to be used at 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCmdBindDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkCmdBindDescriptorSets()
					</a>
                    &nbsp;time.
				</p>
			</li>
			<li>
				<p>
                    With this approach we will need fewer descriptor sets, as more objects can share the same one: they will all reference the same 
                    <code>VkBuffer</code>
                    , but at different dynamic offsets. Furthermore, we can control the memory layout within the buffer.
				</p>
			</li>
			<li>
				<p>
                    Using a single large 
                    <code>VkBuffer</code>
                    &nbsp;in this case shows a performance improvement similar to descriptor set caching.
				</p>
			</li>
			<li>
				<p>
                    For this relatively simple scene stacking the two approaches does not provide a further performance boost, but for a more complex case they do stack nicely:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor caching is necessary when the number of descriptor sets is not just due to 
                            <code>VkBuffer</code>
                            s with uniform data, for example if the scene uses a large amount of materials/textures.
						</p>
					</li>
					<li>
						<p>
                            Buffer management will help reduce the overall number of descriptor sets, thus cache pressure will be reduced and the cache itself will be smaller.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2025-09-08)
				</p>
				<ul>
					<li>
						<p>
                            I personally liked this technique much more than descriptor caching.
						</p>
					</li>
					<li>
						<p>
                            It sounds more concrete than fiddling with descriptor sets.
						</p>
					</li>
					<li>
						<p>
                            Reminds me of Buffer Device Address.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Update already allocated but no longer referenced descriptor sets, instead of resetting descriptor pools and reallocating new descriptor sets.
				</p>
			</li>
			<li>
				<p>
                    Prefer reusing already allocated descriptor sets, and not updating them with the same information every time.
				</p>
			</li>
			<li>
				<p>
                    Consider caching your descriptor sets when feasible.
				</p>
			</li>
			<li>
				<p>
                    Consider using a single (or few) 
                    <code>VkBuffer</code>
                    &nbsp;per frame with dynamic offsets.
				</p>
			</li>
			<li>
				<p>
                    Batch calls to vkAllocateDescriptorSets if possible ‚Äì on some drivers, each call has measurable overhead, so if you need to update multiple sets, allocating both in one call can be faster;
				</p>
			</li>
			<li>
				<p>
                    To update descriptor sets, either use vkUpdateDescriptorSets with descriptor write array, or use 
                    <code>vkUpdateDescriptorSetWithTemplate</code>
                    &nbsp;from Vulkan 1.1. Using the descriptor copy functionality of 
                    <code>vkUpdateDescriptorSets</code>
                    &nbsp;is tempting with dynamic descriptor management for copying most descriptors out of a previously allocated array, but this can be slow on drivers that allocate descriptors out of write-combined memory. Descriptor templates can reduce the amount of work application needs to do to perform updates ‚Äì since in this scheme you need to read descriptor information out of shadow state maintained by application, descriptor templates allow you to tell the driver the layout of your shadow state, making updates substantially faster on some drivers.
				</p>
			</li>
			<li>
				<p>
                    Prefer dynamic uniform buffers to updating uniform buffer descriptors. Dynamic uniform buffers allow to specify offsets into buffer objects using pDynamicOffsets argument of vkCmdBindDescriptorSets without allocating and updating new descriptors. This works well with dynamic constant management where constants for draw calls are allocated out of large uniform buffers, substantially reduce CPU overhead, and can be more efficient on GPU. While on some GPUs the number of dynamic buffers must be kept small to avoid extra overhead in the driver, one or two dynamic uniform buffers should work well in this scheme on all architectures.
				</p>
			</li>
			<li>
				<p>
                    On some drivers, unfortunately the allocate &amp; update path is not very optimal ‚Äì on some mobile hardware, it may make sense to cache descriptor sets based on the descriptors they contain if they can be reused later in the frame.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="descriptor-set-layout" >
    Descriptor Set Layout
</h4>
<ul>
	<li>
		<p>
            Contains the information about what that descriptor set holds.
		</p>
	</li>
	<li>
		<p>
            Specifies the types of resources that are going to be accessed by the pipeline, just like a render pass specifies the types of attachments that will be accessed.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How many
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You need to specify a descriptor set layout for each descriptor set when creating the pipeline layout.
				</p>
				<ul>
					<li>
						<p>
                            You can use this feature to put descriptors that vary per-object and descriptors that are shared into separate descriptor sets.
						</p>
					</li>
					<li>
						<p>
                            In that case, you avoid rebinding most of the descriptors across draw calls which are potentially more efficient.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Since the buffer structure is identical across frames, one layout suffices.
				</p>
				<ul>
					<li>
						<p>
                            Create only 1 descriptor set layout, regardless of frames in-flight.
						</p>
					</li>
					<li>
						<p>
                            This layout defines the type of resource (e.g., 
                            <code>VKDESCRIPTORTYPEUNIFORMBUFFER</code>
                            ) and its binding point.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetLayout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Opaque handle to a descriptor set layout object.
				</p>
			</li>
			<li>
				<p>
                    Is defined by an array of zero or more descriptor bindings.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Where it's used
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkPipelineLayoutCreateInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>vkDescriptorSetAllocateInfo</code>
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorSetLayoutBinding</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Structure specifying a descriptor set layout binding.
						</p>
					</li>
					<li>
						<p>
                            Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that can access the binding, and (if using immutable samplers) an array of sampler descriptors.
						</p>
					</li>
					<li>
						<p>
                            Bindings that are not specified have a 
                            <code>descriptorCount</code>
                            &nbsp;and 
                            <code>stageFlags</code>
                            &nbsp;of zero, and the value of 
                            <code>descriptorType</code>
                            &nbsp;is undefined.
						</p>
					</li>
					<li>
						<p>
                            <code>binding</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
								</p>
							</li>
							<li>
								<p>
                                    Used in the shader and the type of descriptor, which is a uniform buffer object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>descriptorType</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorType.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorType
									</a>
                                    &nbsp;specifying which type of resource descriptors are used for this binding.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>descriptorCount</code>
						</p>
						<ul>
							<li>
								<p>
									<strong>
                                        Insight
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            It's a descriptor count, 
											<strong>
                                                not a descriptor SET count
											</strong>
                                            !! It's just to specify how many resources is expected to be in that binding.
										</p>
									</li>
									<li>
										<p>
                                            It makes complete sense to be used for arrays.
										</p>
									</li>
									<li>
										<p>
                                            Caio:
										</p>
										<ul>
											<li>
												<p>
                                                    What happens if the values don't match? For example, trying to get the index 5 of the array, when the binding was described having 
                                                    <code>descriptorCount = 1</code>
                                                    &nbsp;?
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Oni:
										</p>
										<ul>
											<li>
												<p>
                                                    I don't know if this is specified. I guess it's only going to update the first element. So you're going to read bogus data. Maybe it changes between different drivers, no idea.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<strong>
                                        What value to use
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            A MVP transformation is in a single uniform buffer, so we using a 
                                            <code>descriptorCount</code>
                                            &nbsp;of 
                                            <code>1</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            In other words, a whole struct counts as 
                                            <code>1</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Is the number of descriptors contained in the binding, accessed in a shader as an array.
								</p>
								<ul>
									<li>
										<p>
                                            Except if 
                                            <code>descriptorType</code>
                                            &nbsp;is 
                                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                            &nbsp;in which case 
                                            <code>descriptorCount</code>
                                            &nbsp;is the size in bytes of the inline uniform block.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorCount</code>
                                    &nbsp;is zero this binding entry is reserved and the resource 
									<em>
                                        must
									</em>
                                    &nbsp;not be accessed from any stage via this binding within any pipeline using the set layout.
								</p>
							</li>
							<li>
								<p>
                                    It is possible for the shader variable to represent an array of uniform buffer objects, and this property specifies the number of values in the array.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Examples
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            This could be used to specify a transformation for each of the bones in a skeleton for skeletal animation.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>stageFlags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderStageFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkShaderStageFlagBits
									</a>
                                    &nbsp;specifying which pipeline shader stages 
									<strong>
                                        can
									</strong>
                                    &nbsp;access a resource for this binding.
								</p>
								<ul>
									<li>
										<p>
                                            <code>SHADER_STAGE_ALL</code>
                                            &nbsp;is a shorthand specifying all defined shader stages, including any additional stages defined by extensions.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If a shader stage is not included in 
                                    <code>stageFlags</code>
                                    , then a resource 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be accessed from that stage via this binding within any pipeline using the set layout.
								</p>
							</li>
							<li>
								<p>
                                    Other than input attachments which are limited to the fragment shader, there are no limitations on what combinations of stages 
									<strong>
                                        can
									</strong>
                                    &nbsp;use a descriptor binding, and in particular a binding 
									<strong>
                                        can
									</strong>
                                    &nbsp;be used by both graphics stages and the compute stage.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pImmutableSamplers</code>
						</p>
						<ul>
							<li>
								<p>
                                    Affects initialization of samplers.
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorType</code>
                                    &nbsp;specifies a 
                                    <code>DESCRIPTOR_TYPE_SAMPLER</code>
                                    &nbsp;or 
                                    <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                    &nbsp;type descriptor, then 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;
									<strong>
                                        can
									</strong>
                                    &nbsp;be used to initialize a set of 
									<em>
                                        immutable samplers
									</em>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorType</code>
                                    &nbsp;is not one of these descriptor types, then 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is 
									<strong>
                                        ignored
									</strong>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Immutable samplers are permanently bound into the set layout and 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be changed; updating a 
                                    <code>DESCRIPTOR_TYPE_SAMPLER</code>
                                    &nbsp;descriptor with immutable samplers is not allowed and updates to a 
                                    <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                    &nbsp;descriptor with immutable samplers does not modify the samplers (the image views are updated, but the sampler updates are ignored).
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is not 
                                    <code>NULL</code>
                                    , then it is a pointer to an array of sampler handles that will be copied into the set layout and used for the corresponding binding. Only the sampler handles are copied; the sampler objects 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be destroyed before the final use of the set layout and any descriptor pools and sets created using it.
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is 
                                    <code>NULL</code>
                                    , then the sampler slots are dynamic and sampler handles 
									<strong>
                                        must
									</strong>
                                    &nbsp;be bound into descriptor sets using this layout. ]
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorSetLayoutCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>pBindings</code>
						</p>
						<ul>
							<li>
								<p>
                                    A pointer to an array of 
                                    <code>VkDescriptorSetLayoutBinding</code>
                                    &nbsp;structures.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>bindingCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of elements in 
                                    <code>pBindings</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayoutCreateFlagBits
									</a>
                                    &nbsp;specifying options for descriptor set layout creation.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCreateDescriptorSetLayout()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Create a new descriptor set layout.
						</p>
					</li>
					<li>
						<p>
                            <code>pCreateInfo</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayoutCreateInfo
									</a>
                                    &nbsp;structure specifying the state of the descriptor set layout object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pAllocator</code>
						</p>
						<ul>
							<li>
								<p>
                                    Controls host memory allocation as described in the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-allocation" 
										class="external-link" 
										target="_blank" >
                                        Memory Allocation
									</a>
                                    &nbsp;chapter.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pSetLayout</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayout
									</a>
                                    &nbsp;handle in which the resulting descriptor set layout object is returned.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineLayoutCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Structure specifying the parameters of a newly created pipeline layout object
				</p>
			</li>
			<li>
				<p>
                    <code>setLayoutCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of descriptor sets included in the pipeline layout.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                How it works
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It's possible to have multiple descriptor sets (
                                    <code>set = 0</code>
                                    , 
                                    <code>set = 1</code>
                                    , etc).
								</p>
							</li>
							<li>
								<p>
                                    &quot;You can have set = 0 being a set that is always bound and never changes, set = 1 is something specific to the current object being rendered, etc.&quot;
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSetLayouts</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkDescriptorSetLayout</code>
                            &nbsp;objects.
						</p>
					</li>
					<li>
						<p>
                            The implementation 
							<em>
                                must
							</em>
                            &nbsp;not access these objects outside of the duration of the command this structure is passed to.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="binding" >
    Binding
</h4>
<ul>
	<li>
		<p>
            A Descriptor state is tracked only inside a command buffer; they are always bound at command buffer level; their state is local to command buffers.
		</p>
		<ul>
			<li>
				<p>
                    They are not bound at queue level or global level, only to command buffers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250806153655.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Which set index to choose
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    According to GPU vendors, each descriptor set slot has a cost, so the fewer we have, the better.
				</p>
			</li>
			<li>
				<p>
                    &quot;Organize shader inputs into &quot;sets&quot; by update frequency.&quot;
				</p>
			</li>
			<li>
				<p>
                    Rarely changes -&gt; low index.
				</p>
			</li>
			<li>
				<p>
                    Changes frequently -&gt; high index.
				</p>
			</li>
			<li>
				<p>
                    Usually Descriptor Set 0 is used to always bind some global scene data, which will contain some uniform buffers and some special textures, and Descriptor Set 1 will be used for per-object data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdBindDescriptorSets</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It needs to be done before the 
                    <code>vkCmdDrawIndexed()</code>
                    &nbsp;calls, for example.
				</p>
			</li>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the command buffer that the descriptor sets will be bound to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pipelineBindPoint</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBindPoint.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineBindPoint
							</a>
                            &nbsp;indicating the type of the pipeline that will use the descriptors. There is a separate set of bind points for each pipeline type, so binding one does not disturb the others.
						</p>
					</li>
					<li>
						<p>
                            Unlike vertex and index buffers, descriptor sets are not unique to graphics pipelines, therefore, we need to specify if we want to bind descriptor sets to the graphics or compute pipeline.
						</p>
					</li>
					<li>
						<p>
                            Indicates the type of the pipeline that will use the descriptor.
						</p>
					</li>
					<li>
						<p>
                            There is a separate set of bind points for each pipeline type, so binding one does not disturb the others.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250806154129.png" width="425" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    A raytracing command takes the currently bound descriptors from the raytracing bind point.
								</p>
							</li>
							<li>
								<p>
                                    A draw command takes the currently bound descriptors from the graphics bind point.
								</p>
							</li>
							<li>
								<p>
                                    The two don't interfere with each other.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>layout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayout.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineLayout
							</a>
                            &nbsp;object used to program the bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstSet</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the 
							<em>
                                set number
							</em>
                            &nbsp;of the 
							<em>
                                first descriptor set
							</em>
                            &nbsp;to be bound.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorSetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorSets</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorSets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of handles to 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSet
							</a>
                            &nbsp;objects describing the descriptor sets to bind to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dynamicOffsetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of dynamic offsets in the 
                            <code>pDynamicOffsets</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDynamicOffsets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>uint32_t</code>
                            &nbsp;values specifying dynamic offsets.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="strategy-descriptor-indexing-codeext_descriptor_indexing-code" >
    Strategy: Descriptor Indexing (
    <code>EXT_descriptor_indexing</code>
    )
</h4>
<h5
	id="plan" >
    Plan
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            SSBOs and UBOs.
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    Can I just put different data without restriction?
				</p>
				<ul>
					<li>
						<p>
                            Yes. See the SSBO section for that.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    SSBOs or UBOs?
				</p>
				<ul>
					<li>
						<p>
                            Using storage buffers exclusively instead of uniform buffers can increase GPU time on some architectures.
						</p>
					</li>
					<li>
						<p>
                            I'll use SSBO, as that was the general recommendation.
						</p>
					</li>
					<li>
						<p>
                            Maybe I'll mix both.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Material Data:
		</p>
		<ul>
			<li>
				<p>
                    The Material index is used to look up material data from material storage buffer. The textures can then be accessed using the indices from the material data and the descriptor array.
				</p>
			</li>
			<li>
				<p>
                    Could be sent via push constants, but if I choose to go for indirect rendering (I should), then I cannot use push constants. I'd use the instance index (or similar) to index into a 
                    <code>[]Material_Data</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Model Matrix / Transforms:
		</p>
		<ul>
			<li>
				<p>
                    Same as material data. I can send via push constants if direct drawing, or via 
                    <code>[]model_matrix</code>
                    &nbsp;if indirect drawing.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Globals:
		</p>
		<ul>
			<li>
				<p>
                    Camera view/proj, lights, ambient, etc.
				</p>
			</li>
			<li>
				<p>
                    I could just bind this once as well.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Vertex:
		</p>
		<ul>
			<li>
				<p>
                    Indirect vs Full bindless:
				</p>
				<ul>
					<li>
						<p>
                            I'm not sure. I'll use Indirect Drawing for now. ChatGPU deep search didn't give me much.
						</p>
					</li>
				</ul>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    Indirect Drawing:
				</p>
				<ul>
					<li>
						<p>
                            For indirect drawing, it makes sense to just 
                            <code>vkCmdBindIndexBuffer</code>
                            , as I NEED the vertex shader to be called by the number of times I specified
						</p>
					</li>
					<li>
						<p>
                            Plan: go for bindless first, drawing direct. instead of using the 
                            <code>instanceID</code>
                            &nbsp;or similar, I just send the draw_data index via push constants. this way, the shader will be completely finalized, but then I batch the draws via draw indirect and use the 
                            <code>instanceID</code>
                            &nbsp;instead of the push constants ID
						</p>
					</li>
					<li>
						<p>
                            Indirect Drawing will be the last thing
						</p>
					</li>
					<li>
						<p>
                            What not invert and do indirect first? I cannot do that, as the 
                            <code>instanceID</code>
                            &nbsp;is useless without a bindless design! I NEED to have use for the ID, as I cannot bind desc sets or push constants for each individual draw! bindless first is a MUST.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Full bindless:
				</p>
				<ul>
					<li>
						<p>
                            Using a large index buffer: We need to bind index data. If just like the vertex data, index data is allocated in one large index buffer, we only need to bind it once using 
                            <code>vkCmdBindIndexBuffer</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            While Vulkan provides a first-class way to specify vertex data by calling 
                            <code>vkCmdBindVertexBuffers</code>
                            , having to bind vertex buffers per-draw would not work for a fully bindless design.
						</p>
						<ul>
							<li>
								<p>
                                    Additionally, some hardware doesn‚Äôt support vertex buffers as a first-class entity, and the driver has to emulate vertex buffer binding, which causes some CPU-side slowdowns when using 
                                    <code>vkCmdBindVertexBuffers</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            In a fully bindless design, we need to assume that all vertex buffers are suballocated in one large buffer and either use per-draw vertex offsets (
                            <code>vertexOffset</code>
                            &nbsp;argument to 
                            <code>vkCmdDrawIndexed</code>
                            ) to have hardware fetch data from it, or pass an offset in this buffer to the shader with each draw call and fetch data from the buffer in the shader. Both approaches can work well, and might be more or less efficient depending on the GPU.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Mesh Shaders.
				</p>
				<ul>
					<li>
						<p>
                            Mesh Shaders is probably what is most true to the bindless strategy, but I won't go that way yet (too soon, too new).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Compute</s>
				</p>
				<ul>
					<li>
						<p>
                            Maybe I could use a compute to do this for me, but then I'd lose the rasterizer.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
            Draw Data:
		</p>
		<ul>
			<li>
				<p>
                    Indices to index into the other arrays.
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">struct DrawData
{
&nbsp;&nbsp;&nbsp;&nbsp;uint materialIndex;
&nbsp;&nbsp;&nbsp;&nbsp;uint transformOffset;
&nbsp;&nbsp;&nbsp;&nbsp;uint vertexOffset;
&nbsp;&nbsp;&nbsp;&nbsp;uint unused0; // vec4 padding

&nbsp;&nbsp;&nbsp;&nbsp;// ... extra gameplay data goes here
};
</code></pre>
		<ul>
			<li>
				<p>
                    Vertex Shader:
				</p>
<pre><code class="language-glsl" data-lang="glsl">DrawData dd = drawData[gl_DrawIDARB];
TransformData td = transformData[dd.transformOffset];
vec4 positionLocal = vec4(positionData[gl_VertexIndex + dd.vertexOffset], 1.0);
vec3 positionWorld = mat4x3(td.transform[0], td.transform[1], td.transform[2]) * positionLocal;
</code></pre>
			</li>
			<li>
				<p>
                    Frag Shader:
				</p>
<pre><code class="language-glsl" data-lang="glsl">DrawData dd = drawData[drawId];
MaterialData md = materialData[dd.materialIndex];
vec4 albedo = texture(sampler2D(materialTextures[md.albedoTexture], albedoSampler), uv * vec2(md.tilingX, md.tilingY));
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Slots:
		</p>
		<ul>
			<li>
				<p>
                    tex buffer and material data buffer will be in the same set 0, or should they be 0/1?
				</p>
			</li>
			<li>
				<p>
                    Probably every bind is on desc set 0
				</p>
			</li>
			<li>
				<p>
                    The slots are based on frequency, but every single binding I'm talking about might just be bound once globally without problems
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Overall:
		</p>
		<ul>
			<li>
				<p>
                    <code>[]textures</code>
				</p>
			</li>
			<li>
				<p>
                    <code>[]material_data</code>
				</p>
				<ul>
					<li>
						<p>
                            uv, flip, modulate, etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>[]model_matrices</code>
				</p>
				<ul>
					<li>
						<p>
                            transforms.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>[]draw_data</code>
				</p>
				<ul>
					<li>
						<p>
                            Indices to index into the other arrays.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    vertex/indices
				</p>
				<ul>
					<li>
						<p>
                            As input attributes, to then use Indirect Drawing.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            Descriptor indexing is also known by the term &quot;bindless&quot;, which refers to the fact that binding individual descriptor sets and descriptors is no longer the primary way we keep shader pipelines fed. Instead, we can bind a huge descriptor set once and just index into a large number of descriptors.
		</p>
	</li>
	<li>
		<p>
            Adds a 
			<strong>
                lot
			</strong>
            &nbsp;of flexibility to how resources are accessed.
		</p>
	</li>
	<li>
		<p>
            &quot;Bindless algorithms&quot; are generally built around this flexibility where we either index freely into a lot of descriptors at once, or update descriptors where we please. In this model, &quot;binding&quot; descriptors is not a concern anymore.
		</p>
	</li>
	<li>
		<p>
            The core functionality of this extension is that we can treat descriptor memory as one massive array, and we can freely access any resource we want at any time, by indexing.
		</p>
	</li>
	<li>
		<p>
            If an array is large enough, an index into that array is indistinguishable from a pointer.
		</p>
	</li>
	<li>
		<p>
            At most, we need to write/copy descriptors to where we need them and we can now consider descriptors more like memory blobs rather than highly structured API objects.
		</p>
	</li>
	<li>
		<p>
            The introduction of descriptor indexing revealed that the descriptor model is all just smoke and mirrors. A descriptor is just a blob of binary data that the GPU can interpret in some meaningful way. The API calls to manage descriptors really just boils down to ‚Äúcopy magic bits here.‚Äù
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor Indexing was created in 2018, so all hardware 2018+ should support it.
				</p>
			</li>
			<li>
				<p>
                    Core in Vulkan 1.2+
				</p>
			</li>
			<li>
				<p>
                    Limits queried using 
                    <code>VkPhysicalDeviceDescriptorIndexingPropertiesEXT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Features queried using 
                    <code>VkPhysicalDeviceDescriptorIndexingFeaturesEXT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Features toggled using 
                    <code>VkPhysicalDeviceDescriptorIndexingFeaturesEXT</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Required for
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Raytracing.
				</p>
			</li>
			<li>
				<p>
                    Many GPU Driven Rendering approaches.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    No costly transfer of descriptor to GPU every frame. Shows up as spending a lot of time in 
                    <code>vkUpdateDescriptorSets</code>
                    &nbsp;(Vulkan)
				</p>
			</li>
			<li>
				<p>
                    More flexible / dynamic rendering architecture
				</p>
			</li>
			<li>
				<p>
                    No manual tracking of per-object resource groups
				</p>
			</li>
			<li>
				<p>
                    Updating matrices and material data can be done in bulk before command recording
				</p>
			</li>
			<li>
				<p>
                    CPU and GPU refer to resources the same way, by index
				</p>
			</li>
			<li>
				<p>
                    GPU can store Texture IDs in a buffer for reference later in the frame ‚Äì many uses
				</p>
			</li>
			<li>
				<p>
                    Easy Vertex Pulling ‚Äì gets rid of binding vertex buffers
				</p>
			</li>
			<li>
				<p>
                    Write resource indexes from one shader into a buffer that another shader reads &amp; uses
				</p>
			</li>
			<li>
				<p>
                    G-Buffer can use material ID instead of values
				</p>
			</li>
			<li>
				<p>
                    Terrain Splatmap contains material IDs allowing many materials to be used, instead of 4
				</p>
			</li>
			<li>
				<p>
                    And more‚Ä¶
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Requires hardware support
				</p>
				<ul>
					<li>
						<p>
                            May be too new for widespread use
						</p>
					</li>
					<li>
						<p>
                            Different ‚Äúfeature levels‚Äù can help ease transition
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Different Performance Penalties
				</p>
				<ul>
					<li>
						<p>
                            Arrays indexing can cause memory indirections
						</p>
						<ul>
							<li>
								<p>
                                    Fetching texture descriptors from an array indexed by material data indexed by material index can add an extra indirection on GPU compared to some alternative designs
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ‚ÄúWith great power comes great responsibility‚Äù
				</p>
				<ul>
					<li>
						<p>
                            GPU can't verify that valid descriptors are bound
						</p>
					</li>
					<li>
						<p>
                            Validation is costlier: happens inside shaders
						</p>
					</li>
					<li>
						<p>
                            Can be difficult to debug
						</p>
					</li>
					<li>
						<p>
                            Descriptor management is up to the Application
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    On some hardware, various descriptor set limits may make this technique impractical to implement; to be able to index an arbitrary texture dynamically from the shader, 
                    <code>maxPerStageDescriptorSampledImages</code>
                    &nbsp;should be large enough to accomodate all material textures - while many desktop drivers expose a large limit here, the specification only guarantees a limit of 16, so bindless remains out of reach on some hardware that otherwise supports Vulkan.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Comparison: Indexing resources without the extension
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250814083757.png" width="600" >
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://chunkstories.xyz/blog/a-note-on-descriptor-indexing/" 
						class="external-link" 
						target="_blank" >
                        Descriptor Indexing, explanation of &quot;dynamic non-uniform&quot;
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Good read.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Constant Indexing
					</em>
                    :
				</p>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D Tex[4];

texture(Tex[0], ...);
texture(Tex[2], ...);

// We can trivially flatten a constant-indexed array into individual resources,
// so, constant indexing requires no fancy hardware indexing support.
layout(set = 0, binding = 0) uniform sampler2D Tex0;
layout(set = 0, binding = 1) uniform sampler2D Tex1;
layout(set = 0, binding = 2) uniform sampler2D Tex2;
layout(set = 0, binding = 3) uniform sampler2D Tex3;
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Image Array Dynamic Indexing
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The dynamic indexing features allow us to use a non-constant expression to index an array.
						</p>
						<ul>
							<li>
								<p>
                                    This has been supported since Vulkan 1.0.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The restriction is that the index must be 
							<em>
                                dynamically uniform
							</em>
                            .
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D Tex[4];

texture(Tex[dynamically_uniform_expression], ...);
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Non-uniform vs Texture Atlas vs Texture Array
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Accessing arbitrary textures in a draw call is not a new problem, and graphics programmers have found ways over the years to workaround restrictions in older APIs. Rather than having multiple textures, it is technically possible to pack multiple textures into one texture resource, and sample from the correct part of the texture. This kind of technique is typically referred to as &quot;texture atlas&quot;. Texture arrays (e.g. sampler2DArray) is another feature which can be used for similar purposes.
						</p>
					</li>
					<li>
						<p>
                            Problems with atlas:
						</p>
						<ul>
							<li>
								<p>
                                    Mip-mapping is hard to implement, and must likely be done manually with derivatives and math.
								</p>
							</li>
							<li>
								<p>
                                    Anisotropic filtering is basically impossible.
								</p>
							</li>
							<li>
								<p>
                                    Any other sampler addressing than 
                                    <code>CLAMP_TO_EDGE</code>
                                    &nbsp;is very awkward to implement.
								</p>
							</li>
							<li>
								<p>
                                    Cannot use different texture formats.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Problems with texture array:
						</p>
						<ul>
							<li>
								<p>
                                    All resolutions must match.
								</p>
							</li>
							<li>
								<p>
                                    Number of array layers is limited (just 256 in min-spec).
								</p>
							</li>
							<li>
								<p>
                                    Cannot use different texture formats.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Non-uniform indexing solves these issues since we can freely use multiple sampled image descriptors instead. Atlases and texture arrays still have their place. There are many use cases where these restrictions do not cause problems.
						</p>
					</li>
					<li>
						<p>
                            Non-uniform indexing is not just limited to textures (although that is the most relevant use case). Any descriptor type can be used as long as the device supports it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="features" >
    Features
</h5>
<ul>
	<li>
		<p>
			<strong>
                Update-after-bind
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In Vulkan, you generally have to create a 
                    <code>VkDescriptorSet</code>
                    &nbsp;and update it with all descriptors before you call 
                    <code>vkCmdBindDescriptorSets</code>
                    . After a set is bound, the descriptor set cannot be updated again until the GPU is done using it. This gives drivers a lot of flexibility in how they access the descriptors. They are free to copy the descriptors and pack them somewhere else, promote them to hardware registers, the list goes on.
				</p>
			</li>
			<li>
				<p>
                    Update-After-Bind gives flexibility to applications instead. Descriptors can be updated at any time as long as they are not actually accessed by the GPU. Descriptors can also be updated while the descriptor set is bound to a command buffer, which enables a &quot;streaming&quot; use case.
				</p>
				<ul>
					<li>
						<p>
                            This means the application doesn‚Äôt have to unbind or re-record command buffers just to change descriptors‚Äîreducing CPU overhead in some streaming-resource scenarios.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Concurrent Updates
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Another &quot;hidden&quot; feature of update-after-bind is that it is possible to update the descriptor set from multiple threads. This is very useful for true &quot;bindless&quot; since unrelated tasks might want to update descriptors in different parts of the streamed/bindless descriptor set.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        After and after
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250816104712.png" width="275" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Non-uniform indexing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    While update-after-bind adds flexibility to descriptor management, non-uniform indexing adds great flexibility for shaders.
				</p>
			</li>
			<li>
				<p>
                    It completely removes all restrictions on how we index into arrays, but we must notify our intent to the compiler.
				</p>
			</li>
			<li>
				<p>
                    Normally, drivers and hardware can assume that the dynamically uniform guarantee holds, and optimize for that case.
				</p>
			</li>
			<li>
				<p>
                    If we use the 
                    <code>nonuniformEXT</code>
                    &nbsp;decoration in 
                    <code>GL_EXT_nonuniform_qualifier</code>
                    &nbsp;we can let the compiler know that the guarantee does not necessarily hold, and the compiler will deal with it in the most efficient way possible for the target hardware. The rationale for having to annotate like this is that driver compiler backends would be forced to be more conservative than necessary if applications were not required to use 
                    <code>nonuniformEXT</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        When to use it
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                The invocation group
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The invocation group is a set of threads (invocations) which work together to perform a task.
								</p>
							</li>
							<li>
								<p>
                                    In graphics pipelines, the invocation group is all threads which are spawned as part of a single draw command. This includes multiple instances, and for multi-draw-indirect it is limited to a single 
                                    <code>gl_DrawID</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    In compute pipelines, the invocation group is a single workgroup, so it‚Äôs very easy to know when it is safe to avoid nonuniformEXT.
								</p>
							</li>
							<li>
								<p>
                                    An expression is considered 
									<strong>
                                        dynamically uniform
									</strong>
                                    &nbsp;if all invocations in an invocation group have the same value.
								</p>
								<ul>
									<li>
										<p>
                                            In other words, 
											<strong>
                                                dynamically uniform
											</strong>
                                            &nbsp;means that the index is the same across all threads spawned by a draw command.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Interaction with Subgroups
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It is very easy to think that dynamically uniform just means &quot;as long as the index is uniform in the subgroup, it‚Äôs fine!&quot;. This is certainly true for most (desktop) architectures, but not all.
								</p>
							</li>
							<li>
								<p>
                                    It is technically possible that a value can be subgroup uniform, but still not dynamically uniform. Consider a case where we have a workgroup size of 128 threads, with a subgroup size of 32. Even if each subgroup does 
                                    <code>subgroupBroadcastFirst()</code>
                                    &nbsp;on the index, each subgroup might have different values, and thus, we still technically need 
                                    <code>nonuniformEXT</code>
                                    &nbsp;here. If you know that you have only one subgroup per workgroup however, 
                                    <code>subgroupBroadcastFirst()</code>
                                    &nbsp;is good enough.
								</p>
							</li>
							<li>
								<p>
                                    The safe thing to do is to just add 
                                    <code>nonuniformEXT</code>
                                    &nbsp;if you cannot prove the dynamically uniform property. If the compiler knows that it only really cares about subgroup uniformity, it could trivially optimize away 
                                    <code>nonuniformEXT(subgroupBroadcastFirst())</code>
                                    &nbsp;anyways.
								</p>
							</li>
							<li>
								<p>
                                    The common reason to use subgroups in the first place, is that it was an old workaround for lack of true non-uniform indexing, especially for desktop GPUs. A common pattern would be something like:
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
			<strong>
                Exemples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    odin_cool_engine:
				</p>
				<ul>
					<li>
						<p>
                            <code>odin_cool_engine/src/rp_ui.odin</code>
						</p>
						<ul>
							<li>
								<p>
                                    It just sends an index to the compute pipeline via push constants.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>odin_cool_engine/src/renderer.odin:725</code>
						</p>
						<ul>
							<li>
								<p>
                                    It just sends an index to the compute pipeline via push constants.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
					<a
						href="https://docs.vulkan.org/samples/latest/samples/extensions/descriptor_indexing/README.html#_the_sample" 
						class="external-link" 
						target="_blank" >
                        Descriptor Indexing Sample
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Setup
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    Check availability of the extension through 
                    <code>vk.EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME</code>
                    &nbsp;+ 
                    <code>vk.EnumerateDeviceExtensionProperties</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Check supported features of the extension through 
                    <code>vk.GetPhysicalDeviceFeatures2</code>
                    &nbsp;+ 
                    <code>vk.PhysicalDeviceDescriptorIndexingFeatures</code>
                    &nbsp;as the 
                    <code>pNext</code>
                    &nbsp;term.
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/refpages/latest/refpages/source/VkDescriptorSetLayoutCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetLayoutCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>UPDATE_AFTER_BIND_POOL</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that descriptor sets using this layout must be allocated from a descriptor pool created with the 
                                    <code>UPDATE_AFTER_BIND</code>
                                    &nbsp;bit set.
								</p>
							</li>
							<li>
								<p>
                                    Descriptor set layouts created with this bit set have alternate limits for the maximum number of descriptors per-stage and per-pipeline layout.
								</p>
							</li>
							<li>
								<p>
                                    The non-UpdateAfterBind limits only count descriptors in sets created without this flag. The UpdateAfterBind limits count all descriptors, but the limits may be higher than the non-UpdateAfterBind limits.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/refpages/latest/refpages/source/VkDescriptorBindingFlagBits.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorBindingFlagBits</code>
			</a>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>PARTIALLY_BOUND</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that descriptors in this binding that are not dynamically used, don't need to contain valid descriptors at the time the descriptors are consumed.
						</p>
						<ul>
							<li>
								<p>
                                    A descriptor is 'dynamically used' if any shader invocation executes an instruction that performs any memory access using the descriptor.
								</p>
							</li>
							<li>
								<p>
                                    If a descriptor is not dynamically used, any resource referenced by the descriptor is not considered to be referenced during command execution.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            This provides so it's not necessary to bind every descriptor. Allows a descriptor array binding to function even when not all array elements are written or valid.
						</p>
					</li>
					<li>
						<p>
                            This is critical if we want to make use of descriptor &quot;streaming&quot;. A descriptor only has to be bound if it is actually used by a shader.
						</p>
					</li>
					<li>
						<p>
                            Without this feature, if you have an array of N descriptors and your shader indexes [0..N-1], all descriptors must be valid; otherwise behavior is undefined even if the shader never touches the uninitialized ones.
						</p>
					</li>
					<li>
						<p>
                            When enabled, you only need to write descriptors that the shader will index. ‚ÄúHoles‚Äù in the array are allowed, provided shader indices never touch them.
						</p>
					</li>
					<li>
						<p>
                            Use this when you want to leave ‚Äúholes‚Äù in a large descriptor array (i.e. not update every element) without pre-filling unused slots with a fallback texture. When this flag is set, descriptors that are not dynamically used by the shader need not contain valid descriptors ‚Äî but if the shader actually accesses an unwritten descriptor you still get undefined/invalid results. This is a convenience to avoid writing N fallback descriptors each time.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>VARIABLE_DESCRIPTOR_COUNT</code>
				</p>
				<ul>
					<li>
						<p>
                            Allows a descriptor binding to have a variable number of descriptors.
						</p>
					</li>
					<li>
						<p>
                            Use a variable amount of descriptors in an array.
						</p>
					</li>
					<li>
						<p>
                            Specifies that this is a variable-sized descriptor binding, whose size will be specified when a descriptor set is allocated using this layout.
						</p>
					</li>
					<li>
						<p>
                            This must 
							<strong>
                                only
							</strong>
                            &nbsp;be used for the last binding in the descriptor set layout (i.e. the binding with the largest value of binding).
						</p>
					</li>
					<li>
						<p>
                            <code>vk.DescriptorSetLayoutBinding.descriptorCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    The value is treated as an upper bound on the size of the binding.
								</p>
							</li>
							<li>
								<p>
                                    The actual count is supplied at allocation time via 
                                    <code>VkDescriptorSetVariableDescriptorCountAllocateInfo</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    For the purposes of counting against limits such as 
                                    <code>maxDescriptorSet</code>
                                    &nbsp;and 
                                    <code>maxPerStageDescriptor</code>
                                    , the full value of 
                                    <code>descriptorCount</code>
                                    &nbsp;is counted, except for descriptor bindings with a descriptor type of 
                                    <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                    , when 
                                    <code>VkDescriptorSetLayoutCreateInfo.flags</code>
                                    &nbsp;does not contain 
                                    <code>DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER</code>
                                    . In this case, 
                                    <code>descriptorCount</code>
                                    &nbsp;specifies the upper bound on the byte size of the binding; thus it counts against the 
                                    <code>maxInlineUniformBlockSize</code>
                                    &nbsp;and 
                                    <code>maxInlineUniformTotalSize</code>
                                    &nbsp;limits instead.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            When we later allocate the descriptor set, we can declare how large we want the array to be.
						</p>
					</li>
					<li>
						<p>
                            Be aware that there is a global limit to the number of descriptors can be allocated at any one time.
						</p>
					</li>
					<li>
						<p>
                            This is extremely useful when using 
                            <code>EXT_descriptor_indexing</code>
                            , since we do not have to allocate a fixed amount of descriptors for each descriptor set.
						</p>
					</li>
					<li>
						<p>
                            In many cases, it is far more flexible to use runtime sized descriptor arrays.
						</p>
					</li>
					<li>
						<p>
                            Use this when you want the shader-visible length of a descriptor-array binding to be allocatable per-descriptor-set (i.e. different sets expose different array lengths) instead of using a single compile-time/ layout upper bound. At allocation you pass the actual count with VkDescriptorSetVariableDescriptorCountAllocateInfo. This reduces bookkeeping/pool usage and lets you avoid allocating the full upper bound for every set. Requires the descriptor-indexing feature be enabled and the variable-size binding must be the last binding in the set
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>UPDATE_AFTER_BIND</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that if descriptors in this binding are updated between when the descriptor set is bound in a command buffer and when that command buffer is submitted to a queue, then the submission will use the most recently set descriptors for this binding and the updates do not invalidate the command buffer. Descriptor bindings created with this flag are also partially exempt from the external synchronization requirement in 
                            <code>vkUpdateDescriptorSetWithTemplateKHR</code>
                            &nbsp;and 
                            <code>vkUpdateDescriptorSets</code>
                            . Multiple descriptors with this flag set can be updated concurrently in different threads, though the same descriptor must not be updated concurrently by two threads. Descriptors with this flag set can be updated concurrently with the set being bound to a command buffer in another thread, but not concurrently with the set being reset or freed.
						</p>
					</li>
					<li>
						<p>
                            Update-after-bind is another critical component of descriptor indexing, which allows us to update descriptors after a descriptor set has been bound to a command buffer.
						</p>
					</li>
					<li>
						<p>
                            This is critical for streaming descriptors, but it also relaxed threading requirements. Multiple threads can update descriptors concurrently on the same descriptor set.
						</p>
					</li>
					<li>
						<p>
                            <code>UPDATE_AFTER_BIND</code>
                            &nbsp;descriptors is somewhat of a precious resource, but min-spec in Vulkan is at least 500k descriptors, which should be more than enough.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>UPDATE_UNUSED_WHILE_PENDING</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that descriptors in this binding can be updated after a command buffer has bound this descriptor set, or while a command buffer that uses this descriptor set is pending execution, as long as the descriptors that are updated are not used by those command buffers. Descriptor bindings created with this flag are also partially exempt from the external synchronization requirement in vkUpdateDescriptorSetWithTemplateKHR and vkUpdateDescriptorSets in the same way as for 
                            <code>UPDATE_AFTER_BIND</code>
                            . If 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;is also set, then descriptors can be updated as long as they are not dynamically used by any shader invocations. If 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;is not set, then descriptors can be updated as long as they are not statically used by any shader invocations.
						</p>
					</li>
					<li>
						<p>
                            Update-Unused-While-Pending is somewhat subtle, and allows you to update a descriptor while a command buffer is executing.
						</p>
					</li>
					<li>
						<p>
                            The only restriction is that the descriptor cannot actually be accessed by the GPU.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>UPDATE_AFTER_BIND</code>
                    &nbsp;vs 
                    <code>UPDATE_UNUSED_WHILE_PENDING</code>
				</p>
				<ul>
					<li>
						<p>
                            Both involve updates to descriptor sets after they are bound, 
                            <code>UPDATE_UNUSED_WHILE_PENDING</code>
                            &nbsp;is a weaker requirement since it is only about descriptors that are not used, whereas 
                            <code>UPDATE_AFTER_BIND</code>
                            &nbsp;requires the implementation to observe updates to descriptors that are used.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Enabling Non-Uniform Indexing
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    Enable 
                    <code>runtimeDescriptorArray</code>
                    &nbsp;and 
                    <code>shaderSampledImageArrayNonUniformIndexing</code>
                    &nbsp;(required for indexing an array of 
                    <code>COMBINED_IMAGE_SAMPLER</code>
                    ), 
                    <code>descriptorBindingPartiallyBound</code>
                    &nbsp;(optional, to avoid undefined behavior on not fully populated arrays).
				</p>
				<ul>
					<li>
						<p>
                            If in Vulkan &lt;1.2, then the features must be enabled in the 
                            <code>vk.PhysicalDeviceDescriptorIndexingFeatures</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If in Vulkan &gt;=1.2, then the features must be enabled in the 
                            <code>vk.PhysicalDeviceVulkan12Features</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    If this is not followed, you'll get:
								</p>
							</li>
						</ul>
<pre><code class="language-txt" data-lang="txt">[ERROR] --- vkCreateDevice(): pCreateInfo-&gt;pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not include a VkPhysicalDeviceDescriptorIndexingFeatures structure. The features in VkPhysicalDeviceDescriptorIndexingFeatures were promoted in Vulkan 1.2 and is also found in VkPhysicalDeviceVulkan12Features. To prevent one feature setting something to TRUE and the other to FALSE, only one struct containing the feature is allowed.
pNext chain: VkDeviceCreateInfo::pNext -&gt; [STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO] -&gt; [STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO] -&gt; [VkPhysicalDeviceVulkan13Features] -&gt; [VkPhysicalDeviceVulkan12Features] -&gt; [VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT] -&gt; [VkPhysicalDeviceDescriptorIndexingFeatures].
The Vulkan spec states: If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not include a VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures, or VkPhysicalDeviceVulkanMemoryModelFeatures structure (https://vulkan.lunarg.com/doc/view/1.4.328.0/windows/antora/spec/latest/chapters/devsandqueues.html#VUID-VkDeviceCreateInfo-pNext-02830)
</code></pre>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin">vulkan12_features := vk.PhysicalDeviceVulkan12Features{
&nbsp;&nbsp;&nbsp;&nbsp;// etc

&nbsp;&nbsp;&nbsp;&nbsp;descriptorIndexing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Todo: Is this only for VK 1.2?

&nbsp;&nbsp;&nbsp;&nbsp;runtimeDescriptorArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing:

&nbsp;&nbsp;&nbsp;&nbsp;shaderSampledImageArrayNonUniformIndexing = true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing: required for indexing an array of `COMBINED_IMAGE_SAMPLER`.

&nbsp;&nbsp;&nbsp;&nbsp;descriptorBindingPartiallyBound&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing: optional, to avoid undefined behavior on not fully populated arrays.

&nbsp;&nbsp;&nbsp;&nbsp;descriptorBindingVariableDescriptorCount&nbsp;&nbsp;= true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing: Allows a descriptor binding to have a variable number of descriptors.

&nbsp;&nbsp;&nbsp;&nbsp;// etc
}
</code></pre>
			</li>
			<li>
				<p>
                    In GLSL use the 
                    <code>GL_EXT_nonuniform_qualifier</code>
                    &nbsp;extension and wrap the index with 
                    <code>nonuniformEXT(...)</code>
                    &nbsp;(or apply 
                    <code>nonuniformEXT</code>
                    &nbsp;to the loaded value) so the compiler emits the SPIR-V 
                    <code>NonUniformEXT</code>
                    &nbsp;decoration.
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
					<strong>
                        In the shader
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Constructors and builtin functions, which all have return types that are not qualified by 
                            <code>nonuniformEXT</code>
                            , will not generate nonuniform results.
						</p>
						<ul>
							<li>
								<p>
                                    Shaders need to use the constructor syntax (or assignment to a 
                                    <code>nonuniformEXT</code>
                                    -qualified variable) to re-add the 
                                    <code>nonuniformEXT</code>
                                    &nbsp;qualifier to the result of builtin functions.
								</p>
							</li>
							<li>
								<p>
                                    Correct:
								</p>
								<ul>
									<li>
										<p>
                                            It is important to note that to be 100% correct, we must use:
										</p>
									</li>
									<li>
										<p>
                                            <code>nonuniformEXT(sampler2D())</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            It is the final argument to a call like 
                                            <code>texture()</code>
                                            &nbsp;which determines if the access is to be considered non-uniform.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Wrong:
								</p>
								<ul>
									<li>
										<p>
                                            It is very common in the wild to see code like:
										</p>
									</li>
									<li>
										<p>
                                            <code>sampler2D(Textures[nonuniformEXT(in_texture_index)], ...)</code>
										</p>
									</li>
									<li>
										<p>
                                            This looks very similar to HLSL, but it is somewhat wrong.
										</p>
									</li>
									<li>
										<p>
                                            Generally, it will work on drivers, but it is not technically correct.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Examples:
								</p>
								<ul>
									<li>
										<p>
                                            <code>sampler2D()</code>
                                            &nbsp;is such a constructor, so we must add 
                                            <code>nonuniformEXT</code>
                                            &nbsp;afterwards.
										</p>
										<ul>
											<li>
												<p>
                                                    <code>out_frag_color = texture(nonuniformEXT(sampler2D(Textures[in_texture_index], ImmutableSampler)), in_uv);</code>
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Other use cases:
						</p>
						<ul>
							<li>
								<p>
                                    The nonuniform qualifier will propagate up to the final argument which is used in the load/store or atomic operation.
								</p>
							</li>
							<li>
								<p>
                                    Examples:
								</p>
<pre><code class="language-glsl" data-lang="glsl">// At the top
#extension GL_EXT_nonuniform_qualifier : require

uniform UBO { vec4 data; } UBOs[];&nbsp;&nbsp; 
vec4 foo = UBOs[nonuniformEXT(index)].data;

buffer&nbsp;&nbsp;SSBO { vec4 data; } SSBOs[]; 
vec4 foo = SSBOs[nonuniformEXT(index)].data;

uniform sampler2D Tex[];
vec4 foo = texture(Tex[nonuniformEXT(index)], uv);

uniform uimage2D Img[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
uint count = imageAtomicAdd(Img[nonuniformEXT(index)], uv, val);
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(local_size_x = 64) in;

layout(set = 0, binding = 0) uniform sampler2D Combined[];
layout(set = 1, binding = 0) uniform texture2D Tex[];
layout(set = 2, binding = 0) uniform sampler Samp[];
layout(set = 3, binding = 0) uniform U { vec4 v; } UBO[];
layout(set = 4, binding = 0) buffer S { vec4 v; } SSBO[];
layout(set = 5, binding = 0, r32ui) uniform uimage2D Img[];

void main()
{
&nbsp;&nbsp;&nbsp;&nbsp;uint index = gl_GlobalInvocationID.x;
&nbsp;&nbsp;&nbsp;&nbsp;vec2 uv = vec2(gl_GlobalInvocationID.yz) / 1024.0;

&nbsp;&nbsp;&nbsp;&nbsp;vec4 a = textureLod(Combined[nonuniformEXT(index)], uv, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec4 b = textureLod(nonuniformEXT(sampler2D(Tex[index], Samp[index])), uv, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec4 c = UBO[nonuniformEXT(index)].v;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 d = SSBO[nonuniformEXT(index)].v;

&nbsp;&nbsp;&nbsp;&nbsp;imageAtomicAdd(Img[nonuniformEXT(index)], ivec2(0), floatBitsToUint(a.x + b.y + c.z + d.w));
}
</code></pre>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caviats:
						</p>
						<ul>
							<li>
								<p>
                                    LOD:
								</p>
								<ul>
									<li>
										<p>
                                            Using implicit LOD with nonuniformEXT can be spicy! If the threads in a quad do not have the same index, LOD might not be computed correctly.
										</p>
									</li>
									<li>
										<p>
                                            The 
                                            <code>quadDivergentImplicitLOD</code>
                                            &nbsp;property lets you know if it will work.
										</p>
									</li>
									<li>
										<p>
                                            In this case however, it is completely fine, since the helper lanes in a quad must come from the same primitive, which all have the same flat fragment input.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Avoinding 
                            <code>nonuniformEXT</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    You might consider using subgroup operations to implement 
                                    <code>nonuniformEXT</code>
                                    &nbsp;on your own.
								</p>
							</li>
							<li>
								<p>
                                    This is technically out of spec, since the SPIR-V specification states that to avoid 
                                    <code>nonuniformEXT</code>
                                    ,
								</p>
							</li>
							<li>
								<p>
                                    the shader must guarantee that the index is &quot;dynamically uniform&quot;.
								</p>
							</li>
							<li>
								<p>
                                    &quot;Dynamically uniform&quot; means the value is the same across all invocations in an &quot;invocation group&quot;.
								</p>
							</li>
							<li>
								<p>
                                    The invocation group is defined to be all invocations (threads) for:
								</p>
								<ul>
									<li>
										<p>
                                            An entire draw command (for graphics)
										</p>
									</li>
									<li>
										<p>
                                            A single workgroup (for compute).
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Avoiding 
                                    <code>nonuniformEXT</code>
                                    &nbsp;with clever programming is far more likely to succeed when writing compute shaders,
								</p>
							</li>
							<li>
								<p>
                                    since the workgroup boundary serves as a much easier boundary to control than entire draw commands.
								</p>
							</li>
							<li>
								<p>
                                    It is often possible to match workgroup to subgroup 1:1, unlike graphics where you cannot control how
								</p>
							</li>
							<li>
								<p>
                                    quads are packed into subgroups at all.
								</p>
							</li>
							<li>
								<p>
                                    The recommended approach here is to just let the compiler do its thing to avoid horrible bugs in the future.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Enabling Update-After-Bind
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    In 
                    <code>VkDescriptorSetLayoutCreateInfo</code>
                    &nbsp;we must pass down binding flags in a separate struct with 
                    <code>pNext</code>
                    .
				</p>
<pre><code class="language-odin" data-lang="odin">bindings_count := len(stage_set_layout.bindings)
descriptor_bindings_flags := make([]vk.DescriptorBindingFlagsEXT, bindings_count, context.temp_allocator)
for i in 0..&lt;len(descriptor_bindings_flags) {
&nbsp;&nbsp;&nbsp;&nbsp;descriptor_bindings_flags[i] = { .PARTIALLY_BOUND }
}
descriptor_bindings_flags[bindings_count - 1] += { .VARIABLE_DESCRIPTOR_COUNT }
&nbsp;&nbsp;&nbsp;&nbsp;// Only the last binding supports VARIABLE_DESCRIPTOR_COUNT.

descriptor_binding_flags_create_info := vk.DescriptorSetLayoutBindingFlagsCreateInfoEXT{
&nbsp;&nbsp;&nbsp;&nbsp;sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = .DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;bindingCount&nbsp;&nbsp;= u32(bindings_count),
&nbsp;&nbsp;&nbsp;&nbsp;pBindingFlags = raw_data(descriptor_bindings_flags),
&nbsp;&nbsp;&nbsp;&nbsp;pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = nil,
}
descriptor_set_layout_create_info := vk.DescriptorSetLayoutCreateInfo{
&nbsp;&nbsp;&nbsp;&nbsp;sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= .DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= {&nbsp;&nbsp;},

&nbsp;&nbsp;&nbsp;&nbsp;bindingCount = u32(bindings_count),
&nbsp;&nbsp;&nbsp;&nbsp;pBindings&nbsp;&nbsp;&nbsp;&nbsp;= raw_data(stage_set_layout.bindings),

&nbsp;&nbsp;&nbsp;&nbsp;pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &descriptor_binding_flags_create_info,
}
</code></pre>
<pre><code class="language-c" data-lang="c">// Num Descriptors
static constexpr uint32_t NumDescriptorsStreaming&nbsp;&nbsp;= 2048;
static constexpr uint32_t NumDescriptorsNonUniform = 64;

// Pool
uint32_t poolCount = NumDescriptorsStreaming + NumDescriptorsNonUniform;
VkDescriptorPoolSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool_size = vkb::initializers::descriptor_pool_size(DESCRIPTOR_TYPE_SAMPLED_IMAGE, poolCount);
VkDescriptorPoolCreateInfo pool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= vkb::initializers::descriptor_pool_create_info(1, &pool_size, 2);

// Allocate
VkDescriptorSetVariableDescriptorCountAllocateInfoEXT variable_info{};
allocate_info.pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &variable_info;

variable_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT;
variable_info.descriptorSetCount = 1;
variable_info.pDescriptorCounts = &NumDescriptorsStreaming;
CHECK(vkAllocateDescriptorSets(get_device().get_handle(), &allocate_info, &descriptors.descriptor_set_update_after_bind));
variable_info.pDescriptorCounts = &NumDescriptorsNonUniform;
CHECK(vkAllocateDescriptorSets(get_device().get_handle(), &allocate_info, &descriptors.descriptor_set_nonuniform));
</code></pre>
			</li>
			<li>
				<p>
                    The 
                    <code>VkDescriptorPool</code>
                    &nbsp;must also be created with 
                    <code>UPDATE_AFTER_BIND</code>
                    . Note that there is global limit to how many UPDATE_AFTER_BIND descriptors can be allocated at any point. The min-spec here is 500k, which should be good enough.
				</p>
			</li>
		</ol>
	</li>
</ul>
<h4
	id="strategy-descriptor-buffers-codeext_descriptor_buffer-code" >
    Strategy: Descriptor Buffers (
    <code>EXT_descriptor_buffer</code>
    )
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://www.khronos.org/blog/vk-ext-descriptor-buffer" 
				class="external-link" 
				target="_blank" >
                Article
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/descriptor_buffer_basic/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Released on (2022-11-21).
		</p>
	</li>
	<li>
		<p>
			<em>
                TLDR
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor sets are now backed by 
                    <code>VkBuffer</code>
                    &nbsp;objects where you 
                    <code>memcpy</code>
                    &nbsp;in descriptors. Delete 
                    <code>VkDescriptorPool</code>
                    &nbsp;and 
                    <code>VkDescriptorSet</code>
                    &nbsp;from the API, and have fun!
				</p>
			</li>
			<li>
				<p>
                    Performance is either equal or better.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Coming from Descriptor Indexing, we use plain uints instead of actual descriptor sets, there are some design questions that come up.
		</p>
	</li>
	<li>
		<p>
            Do we assign one uint per descriptor, or do we try to group them together such that we only need to push one base offset?
		</p>
	</li>
	<li>
		<p>
            If we go with the latter, we might end up having to copy descriptors around. If we go with one uint per descriptor, we just added extra indirection on the GPU. GPU throughput might suffer with the added latency.
		</p>
	</li>
	<li>
		<p>
            On the other hand, having to group descriptors linearly one after the other can easily lead to copy hell. Copying descriptors is still an abstracted operation that requires API calls to perform, and we cannot perform it on the GPU. The overhead of all these calls in the driver can be quite significant, especially in API layering. I‚Äôve seen up to 10 million calls to ‚Äúcopy descriptor‚Äù per second which adds up.
		</p>
	</li>
	<li>
		<p>
            Managing descriptors really starts looking more and more like just any other memory management problem. Let‚Äôs try translating existing API concepts into what they really are under the hood.
		</p>
	</li>
	<li>
		<p>
            <code>vkCreateDescriptorPool</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>vkAllocateMemory</code>
                    . Memory type unknown, but likely 
                    <code>HOST_VISIBLE</code>
                    &nbsp;and 
                    <code>DEVICE_LOCAL</code>
                    . Size of pool computed from pool entries.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkAllocateDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Linear or arena allocation from pool. Size and alignment computed from 
                    <code>VkDescriptorSetLayout</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkUpdateDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Writes raw descriptor data by copying payload from 
                    <code>VkImageView</code>
                    &nbsp;/ 
                    <code>VkSampler</code>
                    &nbsp;/ 
                    <code>VkBufferView</code>
                    . Write offset is deduced from 
                    <code>VkDescriptorSetLayout</code>
                    &nbsp;and binding. The 
                    <code>VkDescriptorSet</code>
                    &nbsp;contains a pointer to 
                    <code>HOST_VISIBLE</code>
                    &nbsp;mapped CPU memory. Copies are similar.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkCmdBindDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Binds the GPU VA of the 
                    <code>VkDescriptorSet</code>
                    &nbsp;somehow.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The descriptor buffer API effectively removes 
            <code>VkDescriptorPool</code>
            &nbsp;and 
            <code>VkDescriptorSet</code>
            . The APIs now expose lower level detail.
		</p>
	</li>
	<li>
		<p>
            For example, there‚Äôs now a bunch of properties to query:
		</p>
<pre><code class="language-c" data-lang="c">typedef struct VkPhysicalDeviceDescriptorBufferPropertiesEXT {
&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¶
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; samplerDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; combinedImageSamplerDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sampledImageDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageImageDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniformTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustUniformTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustStorageTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniformBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustUniformBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustStorageBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputAttachmentDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accelerationStructureDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¶
} VkPhysicalDeviceDescriptorBufferPropertiesEXT;
</code></pre>
	</li>
</ul>
<h4
	id="strategy-push-descriptor-codevk_khr_push_descriptor-code" >
    Strategy: Push Descriptor (
    <code>VK_KHR_push_descriptor</code>
    )
</h4>
<ul>
	<li>
		<p>
            Promoted to core in Vulkan 1.4.
		</p>
	</li>
	<li>
		<p>
            Last modified date: (2017-09-12).
		</p>
	</li>
	<li>
		<p>
            This extension allows descriptors to be written into the command buffer, while the implementation is responsible for managing their memory. Push descriptors may enable easier porting from older APIs and in some cases can be more efficient than writing descriptors into descriptor sets.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/extensions/push_descriptors" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            New Commands
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdPushDescriptorSetKHR</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If Vulkan Version 1.1 or 
            <code>VK_KHR_descriptor_update_template</code>
            &nbsp;is supported:
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdPushDescriptorSetWithTemplateKHR</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            New Structures
		</p>
		<ul>
			<li>
				<p>
                    Extending 
                    <code>VkPhysicalDeviceProperties2</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>VkPhysicalDevicePushDescriptorPropertiesKHR</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            New Enum Constants
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME</code>
				</p>
			</li>
			<li>
				<p>
                    <code>VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION</code>
				</p>
			</li>
			<li>
				<p>
                    Extending 
                    <code>VkDescriptorSetLayoutCreateFlagBits</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Extending VkStructureType:
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If Vulkan Version 1.1 or VK_KHR_descriptor_update_template is supported:
		</p>
		<ul>
			<li>
				<p>
                    Extending 
                    <code>VkDescriptorUpdateTemplateType</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="strategy-bindful-classic-strategy-slot-based-frequency-based" >
    <s>Strategy: Bindful / Classic strategy (Slot-based / Frequency-based)</s>
</h4>
<ul>
	<li>
		<p>
            mna (midmidmid):
		</p>
		<ul>
			<li>
				<p>
                    The reason you split up resources into multiple sets is actually to 
					<em>
                        reduce
					</em>
                    &nbsp;the cost of 
                    <code>vkCmdBindDescriptorSets</code>
                    . The idea being that if you've got one set that holds scene-wide data and a different set that holds object-specific data, you only bind the scene stuff 
					<em>
                        once
					</em>
                    &nbsp;and then just leave it bound. Then the per-object updates go faster because you're pushing much smaller descriptor sets into whatever special silicon descriptor sets map to on your particular GPU. Note: there are rules about how you have to arrange your sets (so like the scene-wide one has to be at a lower index than the per-object one), and all of the pipelines you use must have 
					<em>
                        compatible
					</em>
                    &nbsp;layouts for the sets you aren't rebinding every time you switch to a different pipeline. Someone can correct me if I'm wrong, but if you switch to a pipeline that's got an incompatible layout for some descriptor set at index 
					<em>
                        n
					</em>
                    &nbsp;then 
					<em>
                        all
					</em>
                    &nbsp;descriptor sets at indices 
					<em>
                        &gt;= n
					</em>
                    &nbsp;need to be rebound.
				</p>
			</li>
			<li>
				<p>
                    I think the only reason I'd change any of my stuff to bindless is if I hit however many hundreds of thousands of calls to 
                    <code>vkCmdBindDescriptorSets</code>
                    &nbsp;it takes for descriptors to be a per-frame bottleneck.
				</p>
			</li>
			<li>
				<p>
                    But I find descriptors pretty intuitive and easy to work with.
				</p>
			</li>
			<li>
				<p>
                    I 
					<em>
                        didn't
					</em>
                    &nbsp;find them easy to work with when I 
					<em>
                        first
					</em>
                    &nbsp;came to VK (from GL/D3D11-world), but now that I've got some scaffolding set up to manage them, they're easy sauce.
				</p>
			</li>
			<li>
				<p>
                    (They actually map pretty well to having worked with 
					<em>
                        old
					</em>
                    &nbsp;console GPUs where you manage the command queue directly and have to think about resource bindings in terms of physical registers on the GPU. It was helpful to have that background.)
				</p>
			</li>
			<li>
				<p>
                    If you're working with descriptor sets, then you have lots of little objects whose lifetimes you need to track and manage. Getting them grouped into the appropriate set of 
					<em>
                        pools
					</em>
                    &nbsp;cuts that number down to something that's not hard to manage. So, for me, I've got a dynamically allocated and recycled set of descriptor pools for stuff that changes every frame, and then I've got my materials grouped into pack files (for fast content loading) and each of those has one descriptor pool for all the sets for all of its materials. Easy peasy. For bindless, you need to figure out how you're going to divide up the big array of descriptors in your one mega set. There's different strategies for doing that. But you'll get a better description of them out of the bindless fans on the server.
				</p>
			</li>
			<li>
				<p>
                    Implementation-wise, 
					<em>
                        I
					</em>
                    &nbsp;don't think there's a huge complexity difference between the two approaches. Bindless might be 
					<em>
                        conceptually
					</em>
                    &nbsp;simpler since &quot;it's just a big array&quot; doesn't require as big of a mental shift as dividing resources up by usage and update frequency and thinking in 
					<em>
                        those
					</em>
                    &nbsp;terms.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In the ‚Äúclassic‚Äù model, before you draw or dispatch, you must bind each resource to a specific descriptor binding or slot.
		</p>
	</li>
	<li>
		<p>
            Example:
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdBindDescriptorSets(...)</code>
				</p>
			</li>
			<li>
				<p>
                    Binding texture #0 for this draw, texture #1 for that draw, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The shader uses a fixed binding index:
		</p>
		<ul>
			<li>
				<p>
                    <code>layout(set = 0, binding = 3) uniform sampler2D tex;</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you want to change which texture is used, you re-bind that descriptor.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250806171334.png" width="475" >
            .
		</p>
	</li>
</ul>
<h3
	id="specialization-constants" >
    Specialization Constants
</h3>
<ul>
	<li>
		<p>
            Allows a constant value in SPIR-V to be specified at 
            <code>VkPipeline</code>
            &nbsp;creation time.
		</p>
	</li>
	<li>
		<p>
            This is powerful as it replaces the idea of doing preprocessor macros in the high level shading language (GLSL, HLSL, etc).
		</p>
	</li>
	<li>
		<p>
            A way to provide constant values to a SPIR-V shader at pipeline creation time so the compiler can constant-fold, inline, and eliminate branches.
		</p>
		<ul>
			<li>
				<p>
                    This yields code equivalent to having compiled separate shader variants with those constant values baked in.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This is not Vulkan exclusive, but an optimization from SPIR-V. OpenGL 4.6 can also use this feature.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/specialization_constants/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            UBOs and Push Constants suffer from limited optimizations during shader compilation. Specialization Constants can provide those optimizations:
		</p>
		<ul>
			<li>
				<p>
                    Uniform buffer objects (UBOs) are one of the most common approaches when it is necessary to set values within a shader at run-time and are used in many tutorials. UBOs are pushed to the shader just prior to its execution, this is after shader compilation which occurs during 
                    <code>vkCreateGraphicsPipelines</code>
                    . As these values are set after the shader has been compiled, the driver‚Äôs shader compiler has limited scope to perform optimizations to the shader during its compilation. This is because optimizations such as loop unrolling or unused code removal require the compiler to have knowledge of the values controlling them which is not possible with UBOs. Push constants also suffer from the same problems as UBOs, as they are also provided after the shader has been compiled.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Specialization Constants
					</em>
                    &nbsp;are set before pipeline creation meaning these values are known during shader compilation, this allows the driver‚Äôs shader compiler to perform optimizations. In this optimisation process the compiler has the ability to remove unused code blocks and statically unroll which reduces the fragment cycles required by the shader which results in increased performance.
				</p>
			</li>
			<li>
				<p>
                    While specialization constants rely on knowing the required values before pipeline creation occurs, by trading off this flexibility and allowing the compiler to perform these optimizations you can increase the performance of your application easily and reduce shader code size.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use compile-time specialization constants for all control flow. This allows compilation to completely remove unused code blocks and statically unroll loops.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Don‚Äôt
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use control-flow which is parameterized by uniform values; specialize shaders for each control path needed instead.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reduced performance due to less efficient shader programs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">#version 450
layout (constant_id = 0) const float myColor = 1.0;
layout(location = 0) out vec4 outColor;

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;outColor = vec4(myColor);
}
</code></pre>
<pre><code class="language-c" data-lang="c">struct myData {
&nbsp;&nbsp;&nbsp;&nbsp;float myColor = 1.0f;
} myData;

VkSpecializationMapEntry mapEntry = {};
mapEntry.constantID = 0; // matches constant_id in GLSL and SpecId in SPIR-V
mapEntry.offset&nbsp;&nbsp;&nbsp;&nbsp; = 0;
mapEntry.size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sizeof(float);

VkSpecializationInfo specializationInfo = {};
specializationInfo.mapEntryCount = 1;
specializationInfo.pMapEntries&nbsp;&nbsp; = &mapEntry;
specializationInfo.dataSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= sizeof(myData);
specializationInfo.pData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &myData;

VkGraphicsPipelineCreateInfo pipelineInfo = {};
pipelineInfo.pStages[fragIndex].pSpecializationInfo = &specializationInfo;

// Create first pipeline with myColor as 1.0
vkCreateGraphicsPipelines(&pipelineInfo);

// Create second pipeline with same shader, but sets different value
myData.myColor = 0.5f;
vkCreateGraphicsPipelines(&pipelineInfo);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Use cases
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Toggling features:
				</p>
				<ul>
					<li>
						<p>
                            Support for a feature in Vulkan isn‚Äôt known until runtime. This usage of specialization constants is to prevent writing two separate shaders, but instead embedding a constant runtime decision.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Improving backend optimizations:
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Optimizing shader compilation
							</em>
                            &nbsp;from SPIR-V to GPU.
						</p>
					</li>
					<li>
						<p>
                            The ‚Äúbackend‚Äù here refers to the implementation‚Äôs compiler that takes the resulting SPIR-V and lowers it down to some ISA to run on the device.
						</p>
					</li>
					<li>
						<p>
                            Constant values allow a set of optimizations such as 
							<a
								href="https://en.wikipedia.org/wiki/Constant_folding" 
								class="external-link" 
								target="_blank" >
                                constant folding
							</a>
                            , 
							<a
								href="https://en.wikipedia.org/wiki/Dead_code_elimination" 
								class="external-link" 
								target="_blank" >
                                dead code elimination
							</a>
                            , etc. to occur.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Affecting types and memory sizes:
				</p>
				<ul>
					<li>
						<p>
                            It is possible to set the length of an array or a variable type used through a specialization constant.
						</p>
					</li>
					<li>
						<p>
                            It is important to notice that a compiler will need to allocate registers depending on these types and sizes. This means it is likely that a pipeline cache will fail if the difference is significant in registers allocated.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How they work
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The values are supplied using 
                    <code>VkSpecializationInfo</code>
                    &nbsp;attached to the 
                    <code>VkPipelineShaderStageCreateInfo</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    In GLSL (or HLSL ‚Üí SPIR-V) mark a constant with a constant id, e.g. 
                    <code>layout(constant_id = 0) const int MATERIAL_MODE = 0;</code>
				</p>
			</li>
			<li>
				<p>
                    Create 
                    <code>VkSpecializationMapEntry</code>
                    &nbsp;entries mapping 
                    <code>constantID</code>
                    &nbsp;‚Üí offset/size in your data block.
				</p>
			</li>
			<li>
				<p>
                    Fill a contiguous data buffer with the specialization values and set up 
                    <code>VkSpecializationInfo</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Put the 
                    <code>VkSpecializationInfo*</code>
                    &nbsp;into the shader stage 
                    <code>VkPipelineShaderStageCreateInfo</code>
                    &nbsp;before calling 
                    <code>vkCreateGraphicsPipelines</code>
                    . The backend finalizes (specializes/compiles) the shader at pipeline creation time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How it affects the pipeline workflow
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It does not solve the pipeline workflow problem. It provides a system for shader optimization at SPIR-V‚ÜíGPU compile time.
						</p>
					</li>
					<li>
						<p>
                            Specialization lets you get near-compile-time optimizations while still selecting variants at runtime, but it does not avoid having multiple created pipelines if you need multiple different specialized behaviors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    They do not, by themselves, precompile every possible branch permutation and keep them all resident for you. Each distinct set of specialization values that you want available at runtime normally corresponds to a separately created pipeline (the specialization values are applied during pipeline creation).
				</p>
			</li>
			<li>
				<p>
                    If you need multiple variants you must create (or reuse) the pipelines for those values.
				</p>
			</li>
			<li>
				<p>
                    If you have N independent boolean specialization choices, the number of possible specialized pipelines is 2^N (exponential growth). Creating many pipelines increases driver/state memory and creation time; use caching/derivatives/libraries if creation cost or count is a concern.
				</p>
			</li>
			<li>
				<p>
                    You cannot change a specialization constant per draw without binding a different pipeline: the specialization is fixed for the pipeline object, so per-draw changes require binding another pipeline or using a different strategy (uniforms, push constants, dynamic branching).
				</p>
			</li>
			<li>
				<p>
                    Different values mean different pipeline creation (driver work / memory).
				</p>
			</li>
			<li>
				<p>
                    &quot;Is this a way to precompile every branching of a shader?&quot;
				</p>
				<ul>
					<li>
						<p>
                            Yes, but only if you actually create a pipeline for each variant.
						</p>
					</li>
					<li>
						<p>
                            Specialization constants let the driver compile-away branches at pipeline-creation time, but they do not magically produce all variants for you at draw time.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Recommendations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://blogs.igalia.com/itoral/2018/03/20/improving-shader-performance-with-vulkans-specialization-constants/?utm_source=chatgpt.com" 
						class="external-link" 
						target="_blank" >
                        Improving shader performance with vulkan's specialization constants
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            When we create the Vulkan pipeline, we pass this specialization information using the 
                            <code>pSpecializationInfo</code>
                            &nbsp;field of 
                            <code>VkPipelineShaderStageCreateInfo</code>
                            . At that point, the driver will override the default value of the specialization constant with the value provided here before the shader code is optimized and native GPU code is generated, which allows the driver compiler backend to generate optimal code.
						</p>
					</li>
					<li>
						<p>
                            It is possible to compile the same shader with different constant values in different pipelines, so even if a value changes often, so long as we have a finite number of combinations, we can generate optimized pipelines for each one ahead of the start of the rendering loop and just swap pipelines as needed while rendering.
						</p>
					</li>
					<li>
						<p>
                            &quot;promote the UBO array to a push constant&quot;.
						</p>
					</li>
					<li>
						<p>
                            Applying specialization constants in a small number of shaders allowed me to benefit from loop unrolling and, most importantly, UBO promotion to push constants in the SSAO pass, obtaining performance improvements that ranged from 10% up to 20% depending on the configuration.
						</p>
					</li>
					<li>
						<p>
                            In other words:
						</p>
						<ul>
							<li>
								<p>
                                    The article shows how it's possible to pass a value to the shader during graphics pipeline creation so the shader is compiled from SPIR-V to GPU with that constant altered.
								</p>
							</li>
							<li>
								<p>
                                    This helps by allowing the SPIR-V‚ÜíGPU compiler to make optimization choices such as unrolling loops and removing branches; it can also enable UBO promotion.
								</p>
							</li>
							<li>
								<p>
                                    The article does not suggest specialization constants solve the pipeline workflow problem. It focuses on compile-time shader optimizations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="physical-storage-buffer-codekhr_buffer_device_address-code" >
    Physical Storage Buffer (
    <code>KHR_buffer_device_address</code>
    )
</h3>
<ul>
	<li>
		<p>
			<em>
                Impressions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2025-09-08)
				</p>
			</li>
			<li>
				<p>
                    No descriptor sets.
				</p>
				<ul>
					<li>
						<p>
                            Cool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Very easy to set up.
				</p>
			</li>
			<li>
				<p>
                    Shader usage is a bit tricky; push constants are required to access buffers in many patterns.
				</p>
			</li>
			<li>
				<p>
                    More prone to programmer errors because there is no automatic bounds checking.
				</p>
			</li>
			<li>
				<p>
                    Hmm, idk, for now not sure.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Adds the ability to have ‚Äúpointers in the shader‚Äù.
		</p>
	</li>
	<li>
		<p>
            Buffer device address is a powerful and unique feature of Vulkan. It exposes GPU virtual addresses directly to the application, and the application can then use those addresses to access buffer data freely through pointers rather than descriptors.
		</p>
	</li>
	<li>
		<p>
            This feature lets you place addresses in buffers and load and store to them inside shaders, with full capability to perform pointer arithmetic and other tricks.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.3.
				</p>
			</li>
			<li>
				<p>
                    Submitted at (2019-01-06), core at (2019-11-25).
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=KHR_buffer_device_address" 
						class="external-link" 
						target="_blank" >
                        Coverage
					</a>
                    :
				</p>
				<ul>
					<li>
						<p>
                            (2025-09-08) 71.6%
						</p>
					</li>
					<li>
						<p>
                            79.8% Windows
						</p>
					</li>
					<li>
						<p>
                            70.9% Linux
						</p>
					</li>
					<li>
						<p>
                            68.7% Android
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lack of safety
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A critical thing to note is that a raw pointer has no idea of how much memory is safe to access. Unlike SSBOs when bounds-checking features are enabled, you must either do range checks yourself or avoid relying on out-of-bounds behavior.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Creating a buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    To be able to grab a device address from a 
                    <code>VkBuffer</code>
                    , you must create the buffer with 
                    <code>SHADER_DEVICE_ADDRESS</code>
                    &nbsp;usage.
				</p>
			</li>
			<li>
				<p>
                    The memory you bind that buffer to must be allocated with the corresponding flag via 
                    <code>pNext</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">VkMemoryAllocateFlagsInfoKHR flags_info{STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR};
flags_info.flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = MEMORY_ALLOCATE_DEVICE_ADDRESS_KHR;
memory_allocation_info.pNext = &flags_info;
</code></pre>
		<ul>
			<li>
				<p>
                    After allocating and binding the buffer, query the address:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">VkBufferDeviceAddressInfoKHR address_info{STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR};
address_info.buffer = buffer.buffer;
buffer.gpu_address&nbsp;&nbsp;= vkGetBufferDeviceAddressKHR(device, &address_info);
</code></pre>
		<ul>
			<li>
				<p>
                    This address behaves like a normal address; you can offset the 
                    <code>VkDeviceAddress</code>
                    &nbsp;value as you see fit since it is a 
                    <code>uint64_t</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    There is no host-side alignment requirement enforced by the API for this value.
				</p>
			</li>
			<li>
				<p>
                    When using this pointer in shaders, you must provide and respect alignment semantics yourself, because the shader compiler cannot infer anything about a raw pointer loaded from memory.
				</p>
			</li>
			<li>
				<p>
                    You can place this pointer inside another buffer and use it as an indirection.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                <code>GL_EXT_buffer_reference</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In Vulkan GLSL, the 
                    <code>GL_EXT_buffer_reference</code>
                    &nbsp;extension allows declaring buffer blocks as pointer-like types rather than SSBOs. GLSL lacks true pointer types, so this extension exposes pointer-like behavior.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#extension GL_EXT_buffer_reference : require
</code></pre>
		<ul>
			<li>
				<p>
                    You can forward-declare types. Useful for linked lists and similar structures.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(buffer_reference) buffer Position;
</code></pre>
		<ul>
			<li>
				<p>
                    You can declare a buffer reference type. This is not an SSBO declaration, but effectively a pointer-to-struct.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, buffer_reference, buffer_reference_align = 8) writeonly buffer Position {
&nbsp;&nbsp;&nbsp;&nbsp;vec2 positions[];
};
</code></pre>
		<ul>
			<li>
				<p>
                    <code>buffer_reference</code>
                    &nbsp;tags the type accordingly. 
                    <code>buffer_reference_align</code>
                    &nbsp;marks the minimum alignment for pointers of this type.
				</p>
			</li>
			<li>
				<p>
                    You can place the 
                    <code>Position</code>
                    &nbsp;type inside another buffer or another buffer reference type:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer PositionReferences {
&nbsp;&nbsp;&nbsp;&nbsp;Position buffers[];
};
</code></pre>
		<ul>
			<li>
				<p>
                    Now you have an array of pointers.
				</p>
			</li>
			<li>
				<p>
                    You can also place a buffer reference inside push constants, an SSBO, or a UBO.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set = 0, binding = 0) readonly buffer Pointers {
&nbsp;&nbsp;&nbsp;&nbsp;Positions positions[];
};

layout(std430, push_constant) uniform Registers {
&nbsp;&nbsp;&nbsp;&nbsp;PositionReferences references;
} registers;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Casting pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A key aspect of buffer device address is that we gain the capability to cast pointers freely.
				</p>
			</li>
			<li>
				<p>
                    While it is technically possible (and useful in some cases!) to &quot;cast pointers&quot; with SSBOs with clever use of aliased declarations like so:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) buffer SSBO { float v1[]; };
layout(set = 0, binding = 0) buffer SSBO2 { vec4 v4[]; };
</code></pre>
		<ul>
			<li>
				<p>
                    It gets kind of hairy quickly, and not as flexible when dealing with composite types.
				</p>
			</li>
			<li>
				<p>
                    When we have casts between integers and pointers, we get the full 
					<strong>
                        madness
					</strong>
                    &nbsp;that is pointer arithmetic. Nothing stops us from doing:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#extension GL_EXT_buffer_reference : require
layout(buffer_reference) buffer PointerToFloat { float v; };

PointerToFloat pointer = load_pointer();
uint64_t int_pointer = uint64_t(pointer);
int_pointer += offset;
pointer = PointerToFloat(int_pointer);
pointer.v = 42.0;
</code></pre>
		<ul>
			<li>
				<p>
                    Not all GPUs support 64-bit integers, so it is also possible to use 
                    <code>uvec2</code>
                    &nbsp;to represent pointers. This way, we can do raw pointer arithmetic in 32-bit, which might be more optimal anyways.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#extension GL_EXT_buffer_reference_uvec2 : require
layout(buffer_reference) buffer PointerToFloat { float v; };
PointerToFloat pointer = load_pointer();
uvec2 int_pointer = uvec2(pointer);
uint carry;
uint lo = uaddCarry(int_pointer.x, offset, carry);
uint hi = int_pointer.y + carry;
pointer = PointerToFloat(uvec2(lo, hi));
pointer.v = 42.0;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Debugging
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    When debugging or capturing an application that uses buffer device addresses, there are some special driver requirements that are not universally supported. Essentially, to be able to capture application buffers which contain raw pointers, we must ensure that the device address for a given buffer remains stable when the capture is replayed in a new process. Applications do not have to do anything here, since tools like RenderDoc will enable the 
                    <code>bufferDeviceAddressCaptureReplay</code>
                    &nbsp;feature for you, and deal with all the magic associated with address capture behind the scenes. If the 
                    <code>bufferDeviceAddressCaptureReplay</code>
                    &nbsp;is not present however, tools like RenderDoc will mask out the 
                    <code>bufferDeviceAddress</code>
                    &nbsp;feature, so beware.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/buffer_device_address/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250813093236.png" width="500" >
            .
		</p>
	</li>
</ul>
<h2
	id="memory-allocation" >
    Memory Allocation
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/memory.html" 
				class="external-link" 
				target="_blank" >
                Memory Allocation
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="info" >
    Info
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=rXSdDE7NWmA" 
				class="external-link" 
				target="_blank" >
                Memory Management
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Talk by AMD.
				</p>
			</li>
			<li>
				<p>
                    Shows no code.
				</p>
			</li>
			<li>
				<p>
                    The video is useful.
				</p>
			</li>
			<li>
				<p>
                    Memory Heaps, Memory Types.
				</p>
			</li>
			<li>
				<p>
                    Memory Blocks.
				</p>
			</li>
			<li>
				<p>
                    Suballocations.
				</p>
			</li>
			<li>
				<p>
                    Dos and Don'ts.
				</p>
			</li>
			<li>
				<p>
                    VMA.
				</p>
			</li>
			<li>
				<p>
                    VmaDumpVis.py to visualize the json file dumped by VMA.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=zSG6dPq57P8" 
				class="external-link" 
				target="_blank" >
                Memory Management
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Sounds more technical; I only saw parts of the talk.
				</p>
			</li>
			<li>
				<p>
                    Talk by AMD.
				</p>
			</li>
			<li>
				<p>
                    Shows code.
				</p>
			</li>
			<li>
				<p>
                    Memory Heaps, Memory Types.
				</p>
			</li>
			<li>
				<p>
                    Dos and Don'ts.
				</p>
			</li>
			<li>
				<p>
                    VMA.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            There is additional level of indirection: 
            <code>VkDeviceMemory</code>
            &nbsp;is allocated separately from creating 
            <code>VkBuffer</code>
            /
            <code>VkImage</code>
            &nbsp;and they must be bound together.
		</p>
	</li>
	<li>
		<p>
            Driver must be queried for supported memory heaps and memory types. Different GPU vendors provide different types of it.
		</p>
	</li>
	<li>
		<p>
            It is recommended to allocate bigger chunks of memory and assign parts of them to particular resources, as there is a limit on maximum number of memory blocks that can be allocated.
		</p>
	</li>
	<li>
		<p>
            When memory is over-committed on Windows, the OS memory manager may move allocations from video memory to system memory, the OS also may temporarily suspend a process from the GPU runlist in order to page out its allocations to make room for a different process‚Äô allocations. There is no OS memory manager on Linux that mitigates over-commitment by automatically performing paging operations on memory objects.
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>EXT_pageable_device_local_memory</code>
            &nbsp;to avoid demotion of critical resources by assigning memory priority. It‚Äôs also a good idea to set low priority to non-critical resources such as vertex and index buffers; the app can verify the performance impact by placing the resources in system memory.¬†
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>EXT_pageable_device_local_memory</code>
            &nbsp;to also disable automatic promotion of allocations from system memory to video memory.
		</p>
	</li>
	<li>
		<p>
            Use dedicated memory allocations (
            <code>KHR_dedicated_allocation</code>
            , core in VK 1.1) when appropriate.
		</p>
	</li>
	<li>
		<p>
            Using dedicated memory may improve performance for color and depth attachments, especially on pre-Turing GPUs.
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>KHR_get_memory_requirements2</code>
            &nbsp;(core in VK 1.1) to check whether an image/buffer requires dedicated allocation.
		</p>
	</li>
	<li>
		<p>
            Use host visible video memory to write data directly to video memory from the CPU. Such heap can be detected using 
            <code>DEVICE_LOCAL | HOST_VISIBLE</code>
            . Take into account that CPU writes to such memory may be slower compared to normal memory. CPU reads are significantly slower. Check BAR1 traffic using Nsight Systems for possible issues.
		</p>
	</li>
	<li>
		<p>
            Explicitly look for the 
            <code>MEMORY_PROPERTY_DEVICE_LOCAL</code>
            &nbsp;when picking a memory type for resources, which should be stored in video memory.
		</p>
	</li>
	<li>
		<p>
            Don‚Äôt assume fixed heap configuration, always query and use the memory properties using 
            <code>vkGetPhysicalDeviceMemoryProperties()</code>
            .
		</p>
	</li>
	<li>
		<p>
            Don‚Äôt assume memory requirements of an image/buffer, use 
            <code>vkGet*MemoryRequirements()</code>
            .¬†
		</p>
	</li>
	<li>
		<p>
            Don‚Äôt put every resource into a Dedicated Allocation.
		</p>
	</li>
	<li>
		<p>
            For memory objects that are intended to be in device-local, do not just pick the first memory type. Pick one that is actually device-local.
		</p>
	</li>
	<li>
		<p>
            The benefit is that we avoid CPU memory costs for lots of tiny buffers, as well as cache misses by using just the same buffer object and varying the offset.
		</p>
	</li>
	<li>
		<p>
            This optimization applies to all buffers, but in the previous blog post on shader resource binding it was mentioned that the offsets are particularly good for uniform buffers.
		</p>
	</li>
	<li>
		<p>
            Software developers use custom memory management for various reasons:
		</p>
		<ul>
			<li>
				<p>
                    Making allocations often involves the operating system which is rather costly.
				</p>
			</li>
			<li>
				<p>
                    It is usually faster to re-use existing allocations rather than to free and reallocate new ones.
				</p>
			</li>
			<li>
				<p>
                    Objects that live in a continuous chunk of memory can enjoy better cache utilization.
				</p>
			</li>
			<li>
				<p>
                    Data that is aligned well for the hardware can be processed faster.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Memory is a precious resource, and it can involve several indirect costs by the operating systems. For example some operating systems have a linear cost over the number of allocations for each submission to a Vulkan Queue. Another scenario is that the operating system also handles the paging state of allocations depending on other proceses, we therefore encourage not using too many allocations and organizing them ‚Äúwisely‚Äù.
		</p>
	</li>
	<li>
		<p>
            Device Memory: This memory is used for buffers and images and the developer is responsible for their content.
		</p>
	</li>
	<li>
		<p>
            Resource Pools: Objects such as CommandBuffers and DescriptorSets are allocated from pools, the actual content is indirectly written by the driver.
		</p>
	</li>
	<li>
		<p>
            Custom Host Allocators: Depending on your control-freak level you may also want to provide your own host allocator that the driver can use for the api objects.
		</p>
	</li>
	<li>
		<p>
            Heap: Depending on the hardware and platform, the device will expose a fixed number of heaps, from which you can allocate certain amount of memory in total. Discrete GPUs with dedicated memory will be different to mobile or integrated solutions that share memory with the CPU. Heaps support different memory types which must be queried from the device.
		</p>
	</li>
	<li>
		<p>
            Memory type: When creating a resource such as a buffer, Vulkan will provide information about which memory types are compatible with the resource. Depending on additional usage flags, the developer must pick the right type, and based on the type, the appropriate heap.
		</p>
	</li>
	<li>
		<p>
            Memory property flags: These flags encode caching behavior and whether we can map the memory to the host (CPU), or if the GPU has fast access to the memory.
		</p>
	</li>
	<li>
		<p>
            Memory: This object represents an allocation from a certain heap with a user-defined size.
		</p>
	</li>
	<li>
		<p>
            Resource (Buffer/Image): After querying for the memory requirements and picking a compatible allocation, the memory is associated with the resource at a certain offset. This offset must fulfill the provided alignment requirements. After this we can start using our resource for actual work.
		</p>
	</li>
	<li>
		<p>
            Sub-Resource (Offsets/View): It is not required to use a resource only in its full extent, just like in OpenGL we can bind ranges (e.g. varying the starting offset of a vertex-buffer) or make use of views (e.g. individual slice and mipmap of a texture array).
		</p>
	</li>
	<li>
		<p>
            The fact that we can manually bind resources to actual memory addresses, gives rise to the following points:
		</p>
		<ul>
			<li>
				<p>
                    Resources may alias (share) the same region of memory.
				</p>
			</li>
			<li>
				<p>
                    Alignment requirements for offsets into an allocation must be manually managed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Store multiple buffers, like the vertex and index buffer, into a single 
            <code>VkBuffer</code>
            &nbsp;and use offsets in commands like 
            <code>vkCmdBindVertexBuffers</code>
            .
		</p>
	</li>
	<li>
		<p>
            The advantage is that your data is more cache friendly in that case, because it‚Äôs closer together. It is even possible to reuse the same chunk of memory for multiple resources if they are not used during the same render operations, provided that their data is refreshed, of course.
		</p>
	</li>
	<li>
		<p>
            This is known as aliasing and some Vulkan functions have explicit flags to specify that you want to do this.
		</p>
	</li>
	<li>
		<p>
            Uniform Buffer Binding: As part of a DescriptorSet this would be the equivalent of an arbitrary glBindBufferRange(GL_UNIFORM_BUFFER, dset.binding, dset.bufferOffset, dset.bufferSize) in OpenGL. All information for the actual binding by the CommandBuffer is stored within the DescriptorSet itself.
		</p>
	</li>
	<li>
		<p>
            Uniform Buffer Dynamic Binding: Similar as above, but with the ability to provide the bufferOffset later when recording the CommandBuffer, a bit like this pseudo code: CommandBuffer-&gt;BindDescriptorSet(setNumber, descriptorSet, &amp;offset). It is very practical to use when sub-allocating uniform buffers from a larger buffer allocation.
		</p>
	</li>
	<li>
		<p>
            Push Constants: PushConstants are uniform values that are stored within the CommandBuffer and can be accessed from the shaders similar to a single global uniform buffer. They provide enough bytes to hold some matrices or index values and the interpretation of the raw data is up the shader. You may recall glProgramEnvParameter from OpenGL providing something similar. The values are recorded with the CommandBuffer and cannot be altered afterwards: CommandBuffer-&gt;PushConstant(offset, size, &amp;data)
		</p>
	</li>
	<li>
		<p>
            Dynamic offsets are very fast for NVIDIA hardware. Re-using the same DescriptorSet with just different offsets is rather CPU-cache friendly as well compared to using and managing many DescriptorSets. NVIDIA‚Äôs OpenGL driver actually also optimizes uniform buffer binds where just the range changes for a binding unit.
		</p>
	</li>
</ul>
<h5
	id="sub-allocation" >
    Sub-allocation
</h5>
<ul>
	<li>
		<p>
            In a real world application, you‚Äôre not supposed to actually call 
            <code>vkAllocateMemory</code>
            &nbsp;for every individual buffer.
		</p>
	</li>
	<li>
		<p>
            The maximum number of simultaneous memory allocations is limited by the 
            <code>maxMemoryAllocationCount</code>
            &nbsp;physical device limit, which may be as low as 
            <code>4096</code>
            &nbsp;even on high end hardware like an NVIDIA GTX 1080.
		</p>
	</li>
	<li>
		<p>
            The right way to allocate memory for a large number of objects at the same time is to create a custom allocator that splits up a single allocation among many different objects by using the 
            <code>offset</code>
            &nbsp;parameters that we‚Äôve seen in many functions.
		</p>
	</li>
	<li>
		<p>
            You can either implement such an allocator yourself, or use the 
			<a
				href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator" 
				class="external-link" 
				target="_blank" >
                VMA
			</a>
            &nbsp;library provided by the GPUOpen initiative.
		</p>
	</li>
	<li>
		<p>
            Sub-allocation is a first-class approach when working in Vulkan.
		</p>
	</li>
	<li>
		<p>
            Memory is allocated in pages with a fixed size; sub-allocation reduces the number of OS-level allocations.
		</p>
	</li>
	<li>
		<p>
            You should use memory sub-allocation.
		</p>
	</li>
	<li>
		<p>
            Memory allocation and deallocation at OS/driver level is expensive.
		</p>
	</li>
	<li>
		<p>
            <code>vkAllocateMemory()</code>
            &nbsp;is costly on the CPU.
		</p>
	</li>
	<li>
		<p>
            Cost can be reduced by suballocating from a large memory object.
		</p>
	</li>
	<li>
		<p>
            Also note the 
            <code>maxMemoryAllocationCount</code>
            &nbsp;limit which constrains the number of simultaneous allocations an application can have.
		</p>
	</li>
	<li>
		<p>
            A Vulkan app should aim to create large allocations and then manage them itself.
		</p>
	</li>
	<li>
        <img src="assets/image_20250813094009.png" width="400" >

	</li>
</ul>
<h3
	id="arenas" >
    Arenas
</h3>
<h5
	id="discussion-around-the-availability-of-arenas-in-vulkan" >
    Discussion around the availability of arenas in Vulkan
</h5>
<ul>
	<li>
		<p>
            (2025-12-07)
		</p>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    hello, is it possible to create a memory arena, placing all new objects in this region, and then freeing all this region without having to call the vkDestroyX functions? I'm having the impression that Vulkan memory management is rooted in RAII, which I don't like. All my games are managed through arenas, which I think is perfect, but for Vulkan I'm having to track each individual allocation and free each one at a time. I'm already treating memory as a big arena, but I'm having the overhead of calling the destruction of each resource separately.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            CharlesG:
		</p>
		<ul>
			<li>
				<p>
                    You don‚Äôt own the memory that backs vulkan objects. For command buffers and descriptors there are pools so the driver can do a good job with the backing memory scheme.
				</p>
			</li>
			<li>
				<p>
                    For VkDeviceMemory, you decide how to sub allocate them
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    do I need to call destroy for objects like vkPipeline, VkPipelineLayout, VkDescriptorSetLayout, VkShaderModule, VkRenderPass, etc? I have lots of objects that should die exacly at the same time, but I'm having to free them one by one. I heard about suballocations for buffers and images, but what about these types of objects I mentioned?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            VkIpotrick:
		</p>
		<ul>
			<li>
				<p>
                    they require actualy cleanup, they are not just some memory
				</p>
			</li>
			<li>
				<p>
                    they might be referenced within other internal structures of the driver and have to be removed from those for example
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            CharlesG:
		</p>
		<ul>
			<li>
				<p>
                    anything that you vkCreate must be vkDestroyed; Except command buffers and descriptors where it is sufficient to just destroy the pools.
				</p>
			</li>
			<li>
				<p>
                    Using Vulkan is a lot like networking with a remote server, lots of driver internals have implementation requirements that make arenas not the ‚Äúobvious choice‚Äù (otherwise we‚Äôd see more of them)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    Is there a future in Vulkan where the decision of how to free the memory is not bound to the driver, but for the programmer? You mentioned how this is limited by what the driver allows, but could this change in the future and move towards being more low-level?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            VkIpotrick:
		</p>
		<ul>
			<li>
				<p>
                    no. i dont think that is feasable.
				</p>
			</li>
			<li>
				<p>
                    that would handcuff drivers so bad that you would be too low level. At that point a propper spec could be impossibly hard to create and maintain between vendors
				</p>
			</li>
			<li>
				<p>
                    vulkan drivers still have to do a loooot of things internally. its still highish level api
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            CharlesG:
		</p>
		<ul>
			<li>
				<p>
                    I concur.
				</p>
			</li>
			<li>
				<p>
                    I want to reiterate that drivers deal with much more than host memory allocations, but device memory, external memory (to the process), OS api‚Äôs, display hardware, shader compilers. Some objects don‚Äôt actually DO anything on deletion (sampler come to mind because the handle stores the entire state for some implementations, when the private data ext isnt active)
				</p>
			</li>
			<li>
				<p>
                    Drivers get to ask the os on your behalf to map device memory into the host address space. And deal with you forgetting to unmap it during shutdown (though the OS is more likely to also clean up after user lode drivers‚Ä¶)
				</p>
			</li>
			<li>
				<p>
                    I mention that some objects are ‚Äúfree‚Äù to leak cause they didn‚Äôt allocate anything internally because that is an implementation detail that isnt possible on all hardware, so the API cant guarantee ‚Äúfree‚Äù sampler cleanup without screwing over some hardware. And it just ties their hands when it is no longer possible to put all the state into the handle any more in the future with extensions to the API
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    well, I imagine this was the case, but still, I was hopeful there was some alternative for bulk deletion. Currently I just wrapped around the concept of shared lifetimes and created a pseudo-arena, which internally frees all the memory for me by calling each respective destructor. Still, it annoys me a bit knowing the design could be faster if I could bulk delete the content instead of being bound by what the driver exposes
				</p>
			</li>
			<li>
				<p>
                    I understand why it's not possible due to the current design by drivers, but I wish it were
				</p>
			</li>
			<li>
				<p>
                    my concern now is not the performance per se, but more about the freedom of having the option of managing memory in a way that could logically be faster (logically, as freeing a memory region is quite obviously faster than having to manage the state of different objects before deleting each of them individually). I'm not currently bound by the deletion times of those calls. I'm speaking more from a philosophical standpoint.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            CharlesG:
		</p>
		<ul>
			<li>
				<p>
                    Inb4 going all in on bindless and gpu driven where there just arent as many vulkan objects to manage
				</p>
			</li>
			<li>
				<p>
                    Fences and semaphores come to mind as prime examples of not just memory
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    I'm trying to move it that way after trying bindful for a while, it's being much nicer and aligns with the vision I have of how memory is better managed;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            CharlesG:
		</p>
		<ul>
			<li>
				<p>
                    Suggestions for the API can be made in the vulkan-pain-points channel (although itd be good to link to this convo) and an issue can be made in the Vulkan-Docs github repo as thats the home of the specification. That said, this ask is not easily actionable so hard to quantify what ‚Äúsuccess‚Äù means.
				</p>
			</li>
			<li>
				<p>
                    All good, and going towards bindless is definitely going to suite your tastes better!
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            VkIpotrick:
		</p>
		<ul>
			<li>
				<p>
                    bindless is simply better at this point
				</p>
			</li>
			<li>
				<p>
                    descriptor sets, layouts, pools etc made sense for old hardware, but now they are just very clunky oddly behaving abstractions
				</p>
			</li>
			<li>
				<p>
                    also with bindless you can have one static allocation for all descriptors
				</p>
			</li>
			<li>
				<p>
                    the ultimate memory management is static lifetime after all.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="alternatives-and-half-solutions" >
    Alternatives and half-solutions
</h5>
<ul>
	<li>
		<p>
            You cannot safely get the behavior you want ‚Äî i.e. allocate many Vulkan resources and then legally free one big memory region while leaving the Vulkan object handles alive and never calling their destruction; on a conformant Vulkan implementation. Freeing VkDeviceMemory that backs resources while those resources are still live or still in use is undefined behavior / validation errors unless you guarantee the resources are never used again and the driver allows that. The Vulkan spec requires you to manage object lifetimes; drivers may have internal bookkeeping tied to those object handles that won‚Äôt be cleaned just by freeing the raw memory.
		</p>
	</li>
	<li>
		<p>
            That said, you can achieve the practical ‚Äúfree everything by freeing a small number of objects/regions‚Äù without peppering vkDestroy* calls everywhere by changing how you structure resources. options that actually give you region-like semantics:
		</p>
	</li>
	<li>
		<p>
            Mega-backings (buffers)
		</p>
		<ul>
			<li>
				<p>
                    Never creating one Vulkan resource handle per logical allocation. In practice that means: create a small number of real Vulkan resources (big backing buffers / big images or sparse resources), suballocate from them, and operate using offsets/array-layer indices. When the region should die you destroy the backing objects (a few destroys) and free their VkDeviceMemory. No per-suballocation vkDestroy* calls are necessary because there are no per-suballocation Vulkan handles to destroy.
				</p>
			</li>
			<li>
				<p>
                    Create a small set of large backing VkDeviceMemory + VkBuffer objects (one per memory type/usage class you need).
				</p>
			</li>
			<li>
				<p>
                    Suballocate ranges from those big buffers and use offsets everywhere:
				</p>
			</li>
			<li>
				<p>
                    For vertex/index bindings: vkCmdBindVertexBuffers(..., firstBinding, 1, &amp;bigBuffer, &amp;offset).
				</p>
			</li>
			<li>
				<p>
                    For descriptors: VkDescriptorBufferInfo{ bigBuffer, offset, range } ‚Äî descriptors can point at a buffer + offset without creating new VkBuffer handles.
				</p>
			</li>
			<li>
				<p>
                    When you‚Äôre done, you only need to vkDestroyBuffer / vkFreeMemory for a few big buffers, not for every tiny allocation.
				</p>
			</li>
			<li>
				<p>
                    Constraints: alignment, memoryRequirements and usage flags must be compatible for all suballocations placed in a given big buffer. If two allocations need different usage flags or memory types, they must go into different backing buffers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Texture atlases / arrays (images)
		</p>
		<ul>
			<li>
				<p>
                    Replace many small VkImage objects with a single large image (or texture array/array layers / atlas) and pack multiple textures into it. Use UV/array-layer indices in shader, or use VkImageView / descriptor indexing accordingly.
				</p>
			</li>
			<li>
				<p>
                    You then destroy and free one big image rather than many small ones. Tradeoffs: packing, mipmapping, filtering artifacts, and sampler/view creation.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="host-memory" >
    Host Memory
</h3>
<h5
	id="allocator-codevkallocationcallbacks-code" >
    Allocator (
    <code>VkAllocationCallbacks</code>
    )
</h5>
<ul>
	<li>
		<p>
            <code>VkAllocationCallbacks</code>
            &nbsp;only control host (CPU) allocations the loader/driver makes for Vulkan bookkeeping and temporary object.
		</p>
	</li>
	<li>
		<p>
            They do not give you a direct view or control of device (GPU) memory payloads.
		</p>
	</li>
	<li>
		<p>
            Passing a non-NULL 
            <code>pAllocator</code>
            &nbsp;to a 
            <code>vkCreateX</code>
            &nbsp;function causes the driver to call your callbacks for those host allocations. They do not switch the driver from using device heaps to host malloc; they only replace the host allocator functions used by the implementation. The allocation scope rules determine whether the allocation is command-scoped or object-scoped.
		</p>
	</li>
	<li>
		<p>
            Passing a custom 
            <code>VkAllocationCallbacks</code>
            &nbsp;to 
            <code>vkCreateBuffer</code>
            &nbsp;lets you intercept and control the host memory the driver uses to represent the buffer object ‚Äî but it does not tell you how many bytes of GPU heap were (or will be) consumed by the buffer‚Äôs storage. For the latter you must intercept device allocations (see below).
		</p>
	</li>
	<li>
		<p>
            To track real GPU memory you must track 
            <code>vkAllocateMemory</code>
            /
            <code>vkFreeMemory</code>
            &nbsp;(and any driver-internal device allocations) and/or use 
            <code>VK_EXT_memory_report</code>
            &nbsp;/ 
            <code>VK_EXT_memory_budget</code>
            &nbsp;to observe what the driver actually commits.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCreateBuffer(...)</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            This call creates a buffer object handle and the driver's host-side bookkeeping for that object (descriptor, small metadata).
						</p>
					</li>
					<li>
						<p>
                            Those host allocations are the things 
                            <code>pAllocator</code>
                            &nbsp;on 
                            <code>vkCreateBuffer</code>
                            &nbsp;controls.
						</p>
					</li>
					<li>
						<p>
                            The call does 
							<strong>
                                not
							</strong>
                            &nbsp;allocate GPU payload memory for the buffer contents.
						</p>
					</li>
					<li>
						<p>
                            The buffer becomes usable on the device only after you allocate 
                            <code>VkDeviceMemory</code>
                            &nbsp;and 
							<strong>
                                bind
							</strong>
                            &nbsp;it (or the driver performs some implicit allocation in non-standard implementations).
						</p>
					</li>
					<li>
						<p>
                            The implementation goes as:
						</p>
						<ul>
							<li>
								<p>
                                    <code>vk.CreateBuffer</code>
								</p>
								<ul>
									<li>
										<p>
                                            Create buffer. Host Visible handle. CPU Memory.
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">vk_check(vk.CreateBuffer(_device.handle, &buffer_create_info, &arena.gpu_alloc, &buffer_handle))

</code></pre>
							</li>
							<li>
								<p>
                                    <code>vk.GetBufferMemoryRequirements</code>
								</p>
								<ul>
									<li>
										<p>
                                            Prepare allocation_info for VkDeviceMemory. Choose a memoryTypeIndex with the desired properties
										</p>
									</li>
									<li>
										<p>
                                            allocationSize and memoryTypeIndex determine whether the allocation will be device-local, host-visible, coherent, etc.
										</p>
									</li>
									<li>
										<p>
                                            This properties decide if the memory is mappable from the CPU.
										</p>
									</li>
									<li>
										<p>
                                            This call doesn't allocate anything.
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">mem_requirements: vk.MemoryRequirements
vk.GetBufferMemoryRequirements(_device.handle, buffer_handle, &mem_requirements)
mem_allocation_info := vk.MemoryAllocateInfo{
&nbsp;&nbsp;&nbsp;&nbsp;sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = .MEMORY_ALLOCATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;allocationSize&nbsp;&nbsp;= mem_requirements.size,
&nbsp;&nbsp;&nbsp;&nbsp;memoryTypeIndex = device_find_memory_type(mem_requirements.memoryTypeBits, properties),
}
</code></pre>
							</li>
							<li>
								<p>
                                    <code>vk.AllocateMemory</code>
								</p>
								<ul>
									<li>
										<p>
                                            This is the call that requests a 
                                            <code>VkDeviceMemory</code>
                                            &nbsp;allocation from a particular memory type/heap.
										</p>
									</li>
									<li>
										<p>
                                            Memory type is 
                                            <code>HOST_VISIBLE</code>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    The driver will allocate from the heap that provides host mappings (which is typically system RAM or a host-visible region).
												</p>
											</li>
											<li>
												<p>
                                                    Effect: device payload is created ‚Äî the 
                                                    <code>VkDeviceMemory</code>
                                                    &nbsp;object represents committed device memory (counts against the heap‚Äôs budget).
												</p>
											</li>
											<li>
												<p>
                                                    On discrete GPUs this is often a segment of system memory that is mapped by the driver, or on integrated GPUs it may be the same physical RAM but treated as both host- and device-accessible.
												</p>
											</li>
											<li>
												<p>
                                                    The 
                                                    <code>pAllocator</code>
                                                    &nbsp;you pass to vkAllocateMemory only affects host-side allocations the driver does while processing the call; it does not change whether the allocation consumes device heap bytes.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Memory type is 
                                            <code>DEVICE_LOCAL</code>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    Driver allocates a VkDeviceMemory from the device-local heap (on discrete GPUs this is the GPU VRAM heap). That is the device payload and consumes heap budget. The allocation is not host-visible, so you cannot vkMapMemory this memory.
												</p>
											</li>
											<li>
												<p>
                                                    Note: on integrated GPUs device-local may still be mappable because physical memory is shared ‚Äî but that depends entirely on memory type flags exposed by the driver.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Memory type is 
                                            <code>HOST VISIBLE + DEVICE_LOCAL</code>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    The allocation is created in a heap that the driver marks both device-local and host-visible. Physically this can mean: shared system RAM (integrated GPU) or a special heap the driver exposes that is accessible by both CPU and GPU. The VkDeviceMemory is committed and counts against that heap‚Äôs budget.
												</p>
											</li>
											<li>
												<p>
                                                    You may be able to 
                                                    <code>vkMapMemory</code>
                                                    &nbsp;this memory because it is host-visible. Performance characteristics vary: host-visible+device-local memory can be slower to CPU-access than pure host memory or slower to GPU-access than pure device-local VRAM.
												</p>
											</li>
											<li>
												<p>
                                                    On PC discrete GPUs this commonly corresponds to the GPU memory that is accessible through the PCIe BAR (Resizible-BAR / ReBAR) or a special small window the driver exposes. Allocation behavior: vkAllocateMemory allocates from that BAR-exposed heap (it consumes VRAM or a BAR-mapped window of VRAM).
												</p>
											</li>
										</ul>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">vk_check(vk.AllocateMemory(_device.handle, &mem_allocation_info, nil, &buffer_memory))
</code></pre>
							</li>
							<li>
								<p>
                                    <code>vk.BindBufferMemory</code>
								</p>
								<ul>
									<li>
										<p>
                                            Binds one with the other (memory aliasing). Doesn't allocate anything
										</p>
									</li>
									<li>
										<p>
                                            Binds the previously allocated device memory to the buffer object. Binding itself normally does not allocate additional device heap bytes; it just associates that payload region with the buffer handle.
										</p>
									</li>
									<li>
										<p>
                                            After bind the buffer is usable for CPU mapping (if host-visible) and/or device operations.
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">vk_check(vk.BindBufferMemory(_device.handle, buffer_handle, buffer_memory, 0))
</code></pre>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>vkCreateGraphicsPipelines(...)</code>
				</p>
				<ul>
					<li>
						<p>
                            Pipeline creation can be expensive and opaque.
						</p>
					</li>
					<li>
						<p>
                            During pipeline creation the driver may:
						</p>
						<ul>
							<li>
								<p>
                                    allocate host-side structures for the pipeline object (controlled by 
                                    <code>pAllocator</code>
                                    &nbsp;passed to 
                                    <code>vkCreateGraphicsPipelines</code>
                                    ),
								</p>
							</li>
							<li>
								<p>
                                    compile/optimize shaders, build internal representations,
								</p>
							</li>
							<li>
								<p>
                                    and may allocate internal device resources (driver-controlled device memory, shader/kernel upload, caches) that are not the same as application 
                                    <code>VkDeviceMemory</code>
                                    &nbsp;allocations. The spec explicitly allows drivers to perform internal device allocations for things like pipelines; those allocations are not controlled by 
                                    <code>VkAllocationCallbacks</code>
                                    . If you need to see them, use 
                                    <code>VK_EXT_device_memory_report</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="allocation-reallocation-free-internal-alloc-internal-free" >
    Allocation, Reallocation, Free, Internal Alloc, Internal Free
</h5>
<ul>
	<li>
		<p>
            <code>pfnAllocation</code>
            &nbsp;or 
            <code>pfnReallocation</code>
            &nbsp;may be called in the following situations:
		</p>
		<ul>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkDevice</code>
                    &nbsp;or 
                    <code>VkInstance</code>
                    &nbsp;may be allocated from any API command.
				</p>
			</li>
			<li>
				<p>
                    Allocations scoped to a command may be allocated from any API command.
				</p>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkPipelineCache</code>
                    &nbsp;may only be allocated from:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCreatePipelineCache</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkMergePipelineCaches</code>
                            &nbsp;for 
                            <code>dstCache</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkCreateGraphicsPipelines</code>
                            &nbsp;for 
                            <code>pipelineCache</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkCreateComputePipelines</code>
                            &nbsp;for 
                            <code>pipelineCache</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkValidationCacheEXT</code>
                    &nbsp;may only be allocated from:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCreateValidationCacheEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkMergeValidationCachesEXT</code>
                            &nbsp;for 
                            <code>dstCache</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkCreateShaderModule</code>
                            &nbsp;for validationCache in 
                            <code>VkShaderModuleValidationCacheCreateInfoEXT</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkDescriptorPool</code>
                    &nbsp;may only be allocated from:
				</p>
				<ul>
					<li>
						<p>
                            any command that takes the pool as a direct argument
						</p>
					</li>
					<li>
						<p>
                            <code>vkAllocateDescriptorSets</code>
                            &nbsp;for the 
                            <code>descriptorPool</code>
                            &nbsp;member of its 
                            <code>pAllocateInfo</code>
                            &nbsp;parameter
						</p>
					</li>
					<li>
						<p>
                            <code>vkCreateDescriptorPool</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkCommandPool</code>
                    &nbsp;may only be allocated from:
				</p>
				<ul>
					<li>
						<p>
                            any command that takes the pool as a direct argument
						</p>
					</li>
					<li>
						<p>
                            <code>vkCreateCommandPool</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkAllocateCommandBuffers</code>
                            &nbsp;for the 
                            <code>commandPool</code>
                            &nbsp;member of its 
                            <code>pAllocateInfo</code>
                            &nbsp;parameter
						</p>
					</li>
					<li>
						<p>
                            any 
                            <code>vkCmd*</code>
                            &nbsp;command whose 
                            <code>commandBuffer</code>
                            &nbsp;was allocated from that 
                            <code>VkCommandPool</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations scoped to any other object may only be allocated in that object‚Äôs 
                    <code>vkCreate*</code>
                    &nbsp;command.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>pfnFree</code>
            , or 
            <code>pfnReallocation</code>
            &nbsp;with zero size, may be called in the following situations:
		</p>
		<ul>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkDevice</code>
                    &nbsp;or VkInstance may be freed from any API command.
				</p>
			</li>
			<li>
				<p>
                    Allocations scoped to a command must be freed by any API command which allocates such memory.
				</p>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkPipelineCache</code>
                    &nbsp;may be freed from 
                    <code>vkDestroyPipelineCache</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkValidationCacheEXT</code>
                    &nbsp;may be freed from 
                    <code>vkDestroyValidationCacheEXT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkDescriptorPool</code>
                    &nbsp;may be freed from
				</p>
				<ul>
					<li>
						<p>
                            any command that takes the pool as a direct argument
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations scoped to a 
                    <code>VkCommandPool</code>
                    &nbsp;may be freed from:
				</p>
				<ul>
					<li>
						<p>
                            any command that takes the pool as a direct argument
						</p>
					</li>
					<li>
						<p>
                            <code>vkResetCommandBuffer</code>
                            &nbsp;whose 
                            <code>commandBuffer</code>
                            &nbsp;was allocated from that 
                            <code>VkCommandPool</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations scoped to any other object may be freed in that object‚Äôs 
                    <code>vkDestroy*</code>
                    &nbsp;command.
				</p>
			</li>
			<li>
				<p>
                    Any command that allocates host memory may also free host memory of the same scope.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>pfnAllocation</code>
		</p>
		<ul>
			<li>
				<p>
                    If 
                    <code>pfnAllocation</code>
                    &nbsp;is unable to allocate the requested memory, it must return NULL.
				</p>
			</li>
			<li>
				<p>
                    If the allocation was successful, it must return a valid pointer to memory allocation containing at least 
                    <code>size</code>
                    &nbsp;bytes, and with the pointer value being a multiple of 
                    <code>alignment</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            `pfnReallocation``
		</p>
		<ul>
			<li>
				<p>
                    If the reallocation was successful, 
                    <code>pfnReallocation</code>
                    &nbsp;must return an allocation with enough space for size bytes, and the contents of the original allocation from bytes zero to min(original size, new size) - 1 must be preserved in the returned allocation.
				</p>
			</li>
			<li>
				<p>
                    If size is larger than the old size, the contents of the additional space are 
					<strong>
                        undefined
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    If satisfying these requirements involves creating a new allocation, then the old allocation should be freed.
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>pOriginal</code>
                    &nbsp;is NULL, then 
                    <code>pfnReallocation</code>
                    &nbsp;must behave equivalently to a call to 
                    <code>PFN_vkAllocationFunction</code>
                    &nbsp;with the same parameter values (without 
                    <code>pOriginal</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>size</code>
                    &nbsp;is zero, then 
                    <code>pfnReallocation</code>
                    &nbsp;must behave equivalently to a call to 
                    <code>PFN_vkFreeFunction</code>
                    &nbsp;with the same 
                    <code>pUserData</code>
                    &nbsp;parameter value, and 
                    <code>pMemory</code>
                    &nbsp;equal to 
                    <code>pOriginal</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>pOriginal</code>
                    &nbsp;is non-NULL, the implementation must ensure that 
                    <code>alignment</code>
                    &nbsp;is equal to the 
                    <code>alignment</code>
                    &nbsp;used to originally allocate 
                    <code>pOriginal</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If this function fails and 
                    <code>pOriginal</code>
                    &nbsp;is non-NULL the application must not free the old allocation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>pfnFree</code>
		</p>
		<ul>
			<li>
				<p>
                    May be 
                    <code>NULL</code>
                    , which the callback must handle safely.
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>pMemory</code>
                    &nbsp;is non-NULL, it must be a pointer previously allocated by 
                    <code>pfnAllocation</code>
                    &nbsp;or 
                    <code>pfnReallocation</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The application should free this memory.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>pfnInternalAllocation</code>
		</p>
		<ul>
			<li>
				<p>
                    Upon allocation of executable memory, 
                    <code>pfnInternalAllocation</code>
                    &nbsp;will be called.
				</p>
			</li>
			<li>
				<p>
                    This is a purely informational callback.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>pfnInternalFree</code>
		</p>
		<ul>
			<li>
				<p>
                    Upon freeing executable memory, 
                    <code>pfnInternalFree</code>
                    &nbsp;will be called.
				</p>
			</li>
			<li>
				<p>
                    This is a purely informational callback.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If either of 
            <code>pfnInternalAllocation</code>
            &nbsp;or 
            <code>pfnInternalFree</code>
            &nbsp;is not NULL, both must be valid callbacks
		</p>
	</li>
</ul>
<h5
	id="creating-the-allocator" >
    Creating the allocator
</h5>
<ul>
	<li>
		<p>
            <code>VkAllocationCallbacks</code>
            &nbsp;are for host-side allocations the Vulkan loader/driver makes (CPU memory for driver bookkeeping, staging buffers, etc.).
		</p>
	</li>
	<li>
		<p>
            Using 
            <code>malloc</code>
            /
            <code>free</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is common and acceptable for many apps ‚Äî but you must meet Vulkan‚Äôs callback semantics (alignment, reallocation behavior, thread-safety) and consider performance.
				</p>
			</li>
			<li>
				<p>
                    This is a normal, valid approach. It satisfies most apps and is what many people do in practice.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://stackoverflow.com/questions/36944492/vulkans-vkallocationcallbacks-implemented-with-malloc-free" 
						class="external-link" 
						target="_blank" >
                        Discussion
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Caviats
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Alignment:
						</p>
						<ul>
							<li>
								<p>
                                    Vulkan allocators must return memory suitably aligned for any type the driver might need. Use posix_memalign/aligned_alloc on POSIX, _aligned_malloc on Windows, or otherwise ensure alignment. The Vulkan spec expects allocation functions to behave like platform allocators.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Reallocation semantics:
						</p>
						<ul>
							<li>
								<p>
                                    <code>pfnReallocation</code>
                                    &nbsp;must implement C-like realloc semantics (grow/shrink, preserve contents if requested). If your platform realloc does not support required alignment, implement reallocation by allocating new aligned memory, copying the old contents, freeing the old pointer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Thread-safety &amp; performance:
						</p>
						<ul>
							<li>
								<p>
                                    Drivers can call the callbacks from multiple threads. The system malloc is usually thread-safe but can have global locks and contention. For high-frequency allocation patterns, a custom pool or thread-local allocator can reduce contention and improve predictable performance.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Internal allocation tracking:
						</p>
						<ul>
							<li>
								<p>
                                    <code>VkAllocationCallbacks</code>
                                    &nbsp;provide 
                                    <code>pUserData</code>
                                    &nbsp;so you can route allocations to a custom pool/context for tracking or to implement more efficient pooling per object type.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The GPU VkDeviceMemory allocations (the ones created with vkAllocateMemory) are a separate resource and must be managed with Vulkan APIs and counted against the appropriate memory heap
		</p>
	</li>
	<li>
		<p>
            If you use malloc for 
            <code>VkAllocationCallbacks</code>
            , you are only providing host-allocator behavior for driver/loader-side allocations.
		</p>
	</li>
</ul>
<h5
	id="scope" >
    Scope
</h5>
<ul>
	<li>
		<p>
            Each allocation has an allocation scope defining its lifetime and which object it is associated with. Possible values passed to the allocationScope parameter of the callback functions specified by 
            <code>VkAllocationCallbacks</code>
            , indicating the allocation scope, are:
		</p>
	</li>
	<li>
		<p>
            <code>COMMAND</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies that the allocation is scoped to the duration of the Vulkan command.
				</p>
			</li>
			<li>
				<p>
                    The most specific allocator available is used (
                    <code>DEVICE</code>
                    , else 
                    <code>INSTANCE</code>
                    ).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>OBJECT</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies that the allocation is scoped to the lifetime of the Vulkan object that is being created or used.
				</p>
			</li>
			<li>
				<p>
                    The most specific allocator available is used (
                    <code>OBJECT</code>
                    , else 
                    <code>DEVICE</code>
                    , else 
                    <code>INSTANCE</code>
                    ).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>CACHE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies that the allocation is scoped to the lifetime of a 
                    <code>VkPipelineCache</code>
                    &nbsp;or 
                    <code>VkValidationCacheEXT</code>
                    &nbsp;object.
				</p>
			</li>
			<li>
				<p>
                    If an allocation is associated with a 
                    <code>VkValidationCacheEXT</code>
                    &nbsp;or 
                    <code>VkPipelineCache</code>
                    &nbsp;object, the allocator will use the 
                    <code>CACHE</code>
                    &nbsp;allocation scope.
				</p>
			</li>
			<li>
				<p>
                    The most specific allocator available is used (
                    <code>CACHE</code>
                    , else 
                    <code>DEVICE</code>
                    , else 
                    <code>INSTANCE</code>
                    ).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>DEVICE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies that the allocation is scoped to the lifetime of the Vulkan device.
				</p>
			</li>
			<li>
				<p>
                    If an allocation is scoped to the lifetime of a device, the allocator will use an allocation scope of 
                    <code>DEVICE</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The most specific allocator available is used (
                    <code>DEVICE</code>
                    , else 
                    <code>INSTANCE</code>
                    ).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>INSTANCE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies that the allocation is scoped to the lifetime of the Vulkan instance.
				</p>
			</li>
			<li>
				<p>
                    If the allocation is scoped to the lifetime of an instance and the instance has an allocator, its allocator will be used with an allocation scope of 
                    <code>INSTANCE</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Otherwise an implementation will allocate memory through an alternative mechanism that is unspecified.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Most Vulkan commands operate on a single object, or there is a sole object that is being created or manipulated. When an allocation uses an allocation scope of 
            <code>OBJECT</code>
            &nbsp;or 
            <code>CACHE</code>
            , the allocation is scoped to the object being created or manipulated.
		</p>
	</li>
	<li>
		<p>
            When an implementation requires host memory, it will make callbacks to the application using the most specific allocator and allocation scope available:
		</p>
	</li>
	<li>
		<p>
			<strong>
                Pools
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Objects that are allocated from pools do not specify their own allocator. When an implementation requires host memory for such an object, that memory is sourced from the object‚Äôs parent pool‚Äôs allocator.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="device-memory" >
    Device Memory
</h3>
<ul>
	<li>
		<p>
            Device memory is memory that is visible to the device‚Äâ‚Äî‚Äâfor example the contents of the image or buffer objects, which can be natively used by the device.
		</p>
	</li>
	<li>
		<p>
            A Vulkan device operates on data in device memory via memory objects that are represented in the API by a 
            <code>VkDeviceMemory</code>
            &nbsp;handle.
		</p>
	</li>
	<li>
		<p>
            <code>VkDeviceMemory</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    Opaque handle to a device memory object.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="properties" >
    Properties
</h5>
<ul>
	<li>
		<p>
            Memory properties of a physical device describe the memory heaps and memory types available.
		</p>
	</li>
	<li>
		<p>
            To query memory properties, call 
            <code>vkGetPhysicalDeviceMemoryProperties</code>
            .
		</p>
	</li>
	<li>
		<p>
            <code>VkPhysicalDeviceMemoryProperties </code>
		</p>
		<ul>
			<li>
				<p>
                    Describes a number of memory heaps as well as a number of memory types that can be used to access memory allocated in those heaps.
				</p>
			</li>
			<li>
				<p>
                    Each heap describes a memory resource of a particular size, and each memory type describes a set of memory properties (e.g. host cached vs. uncached) that can be used with a given memory heap. Allocations using a particular memory type will consume resources from the heap indicated by that memory type‚Äôs heap index. More than one memory type may share each heap, and the heaps and memory types provide a mechanism to advertise an accurate size of the physical memory resources while allowing the memory to be used with a variety of different properties.
				</p>
			</li>
			<li>
				<p>
                    At least one heap must include 
                    <code>MEMORY_HEAP_DEVICE_LOCAL</code>
                    &nbsp;in 
                    <code>VkMemoryHeap.flags</code>
				</p>
			</li>
			<li>
				<p>
                    <code>memoryTypeCount</code>
                    &nbsp;is the number of valid elements in the 
                    <code>memoryTypes</code>
                    &nbsp;array.
				</p>
			</li>
			<li>
				<p>
                    <code>memoryTypes</code>
                    &nbsp;is an array of 
                    <code>MAX_MEMORY_TYPES</code>
                    &nbsp;
                    <code>VkMemoryType</code>
                    &nbsp;structures describing the memory types that can be used to access memory allocated from the heaps specified by memoryHeaps.
				</p>
			</li>
			<li>
				<p>
                    <code>memoryHeapCount</code>
                    &nbsp;is the number of valid elements in the 
                    <code>memoryHeaps</code>
                    &nbsp;array.
				</p>
			</li>
			<li>
				<p>
                    <code>memoryHeaps</code>
                    &nbsp;is an array of 
                    <code>MAX_MEMORY_HEAPS</code>
                    &nbsp;
                    <code>VkMemoryHeap</code>
                    &nbsp;structures describing the memory heaps from which memory can be allocated.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="device-memory-allocation" >
    Device Memory Allocation
</h5>
<ul>
	<li>
		<p>
			<strong>
                Memory requirements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vkGetBufferMemoryRequirements</code>
				</p>
				<ul>
					<li>
						<p>
                            Returns the memory requirements for specified Vulkan object
						</p>
					</li>
					<li>
						<p>
                            <code>device</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the logical device that owns the buffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>buffer</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the buffer to query.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pMemoryRequirements</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
                                    <code>VkMemoryRequirements</code>
                                    &nbsp;structure in which the memory requirements of the buffer object are returned.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VkMemoryRequirements</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>size</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the size, in bytes, of the memory allocation required for the resource.
								</p>
							</li>
							<li>
								<p>
                                    The size of the required memory in bytes may differ from 
                                    <code>bufferInfo.size</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>alignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    The offset in bytes where the buffer begins in the allocated region of memory, depends on 
                                    <code>bufferInfo.usage</code>
                                    &nbsp;and 
                                    <code>bufferInfo.flags</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryTypeBits</code>
						</p>
						<ul>
							<li>
								<p>
                                    Bit field of the memory types that are suitable for the buffer.
								</p>
							</li>
							<li>
								<p>
                                    Bit 
                                    <code>i</code>
                                    &nbsp;is set if and only if the memory type 
                                    <code>i</code>
                                    &nbsp;in the 
                                    <code>VkPhysicalDeviceMemoryProperties</code>
                                    &nbsp;structure for the physical device is supported for the resource.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>vkGetPhysicalDeviceMemoryProperties</code>
				</p>
				<ul>
					<li>
						<p>
                            Reports memory information for the specified physical device
						</p>
					</li>
					<li>
						<p>
                            We'll use it to find a memory type that is suitable for the buffer itself.
						</p>
					</li>
					<li>
						<p>
                            <code>vkGetPhysicalDeviceMemoryProperties2</code>
                            &nbsp;behaves similarly to 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties.html" 
								class="external-link" 
								target="_blank" >
                                vkGetPhysicalDeviceMemoryProperties
							</a>
                            , with the ability to return extended information in a 
                            <code>pNext</code>
                            &nbsp;chain of output structures.
						</p>
					</li>
					<li>
						<p>
                            <code>memoryHeaps</code>
						</p>
						<ul>
							<li>
								<p>
                                    Are distinct memory resources like dedicated VRAM and swap space in RAM for when VRAM runs out.
								</p>
							</li>
							<li>
								<p>
                                    The different types of memory exist within these heaps.
								</p>
							</li>
							<li>
								<p>
                                    Right now we‚Äôll only concern ourselves with the type of memory and not the heap it comes from, but you can imagine that this can affect performance.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryTypes</code>
						</p>
						<ul>
							<li>
								<p>
                                    Consists of 
                                    <code>VkMemoryType</code>
                                    &nbsp;structs that specify the heap and properties of each memory type.
								</p>
							</li>
							<li>
								<p>
                                    The properties define special features of the memory, like being able to map it so we can write to it from the CPU.
								</p>
							</li>
							<li>
								<p>
                                    <code>VkMemoryType</code>
								</p>
								<ul>
									<li>
										<p>
                                            Structure specifying memory type
										</p>
									</li>
									<li>
										<p>
                                            <code>heapIndex</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Describes which memory heap this memory type corresponds to, and 
													<em>
                                                        must
													</em>
                                                    &nbsp;be less than 
                                                    <code>memoryHeapCount</code>
                                                    &nbsp;from the 
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryProperties.html" 
														class="external-link" 
														target="_blank" >
                                                        VkPhysicalDeviceMemoryProperties
													</a>
                                                    &nbsp;structure.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>propertyFlags</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is a bitmask of 
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryPropertyFlagBits.html" 
														class="external-link" 
														target="_blank" >
                                                        VkMemoryPropertyFlagBits
													</a>
                                                    &nbsp;of properties for this memory type.
												</p>
											</li>
											<li>
												<p>
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryPropertyFlagBits.html" 
														class="external-link" 
														target="_blank" >
                                                        VkMemoryPropertyFlagBits
													</a>
                                                    .
												</p>
												<ul>
													<li>
														<p>
                                                            The most optimal memory has the 
                                                            <code>MEMORY_PROPERTY_DEVICE_LOCAL</code>
                                                            &nbsp;flag and is usually not accessible by the CPU on dedicated graphics cards.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>typeFilter</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specify the bit field of memory types that are suitable.
								</p>
							</li>
							<li>
								<p>
                                    That means that we can find the index of a suitable memory type by simply iterating over them and checking if the corresponding bit is set to 
                                    <code>1</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    However, we‚Äôre not just interested in a memory type that is suitable for the vertex buffer.
								</p>
							</li>
							<li>
								<p>
                                    We also need to be able to write our vertex data to that memory.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            We may have more than one desirable property, so we should check if the result of the bitwise AND is not just non-zero, but equal to the desired properties bit field. If there is a memory type suitable for the buffer that also has all the properties we need, then we return its index, otherwise we throw an exception.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VkMemoryAllocateInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>allocationSize</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the size of the allocation in bytes.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryTypeIndex</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is an index identifying a memory type from the 
                                    <code>memoryTypes</code>
                                    &nbsp;array of the 
                                    <code>vkGetPhysicalDeviceMemoryProperties</code>
                                    &nbsp;struct, as defined in the 'memory requirements'.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>vkAllocateMemory</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            To allocate memory objects.
						</p>
					</li>
					<li>
						<p>
                            <code>device</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the logical device that owns the memory.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pAllocateInfo</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
                                    <code>VkMemoryAllocateInfo</code>
                                    &nbsp;structure describing parameters of the allocation. A successfully returned allocation must use the requested parameters‚Äâ‚Äî‚Äâno substitution is permitted by the implementation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pAllocator</code>
						</p>
						<ul>
							<li>
								<p>
                                    Controls 
									<strong>
                                        host
									</strong>
                                    &nbsp;memory allocation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pMemory</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
                                    <code>VkDeviceMemory</code>
                                    &nbsp;handle in which information about the allocated memory is returned.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations returned by 
                    <code>vkAllocateMemory</code>
                    &nbsp;are guaranteed to meet any alignment requirement of the implementation. For example, if an implementation requires 128 byte alignment for images and 64 byte alignment for buffers, the device memory returned through this mechanism would be 128-byte aligned. This ensures that applications can correctly suballocate objects of different types (with potentially different alignment requirements) in the same memory object.
				</p>
			</li>
			<li>
				<p>
                    When memory is allocated, its contents are undefined with the following constraint:
				</p>
				<ul>
					<li>
						<p>
                            The contents of unprotected memory must not be a function of the contents of data protected memory objects, even if those memory objects were previously freed.
						</p>
					</li>
					<li>
						<p>
                            The contents of memory allocated by one application should not be a function of data from protected memory objects of another application, even if those memory objects were previously freed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The maximum number of valid memory allocations that can exist simultaneously within a VkDevice may be restricted by implementation- or platform-dependent limits. The maxMemoryAllocationCount feature describes the number of allocations that can exist simultaneously before encountering these internal limits.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Freeing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    To free a memory object, call 
                    <code>vkFreeMemory</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Before freeing a memory object, an application must ensure the memory object is no longer in use by the device‚Äâ‚Äî‚Äâfor example by command buffers in the pending state. Memory can be freed whilst still bound to resources, but those resources must not be used afterwards. Freeing a memory object releases the reference it held, if any, to its payload. If there are still any bound images or buffers, the memory object‚Äôs payload may not be immediately released by the implementation, but must be released by the time all bound images and buffers have been destroyed. Once all references to a payload are released, it is returned to the heap from which it was allocated.
				</p>
			</li>
			<li>
				<p>
                    How memory objects are bound to Images and Buffers is described in detail in the [Resource Memory Association] section.
				</p>
			</li>
			<li>
				<p>
                    If a memory object is mapped at the time it is freed, it is implicitly unmapped.
				</p>
			</li>
			<li>
				<p>
                    Host writes are not implicitly flushed when the memory object is unmapped, but the implementation must guarantee that writes that have not been flushed do not affect any other memory.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="resource-memory-association" >
    Resource Memory Association
</h5>
<ul>
	<li>
		<p>
            Resources are initially created as virtual allocations with no backing memory. Device memory is allocated separately and then associated with the resource. This association is done differently for sparse and non-sparse resources.
		</p>
	</li>
	<li>
		<p>
            Resources created with any of the sparse creation flags are considered sparse resources. Resources created without these flags are non-sparse. The details on resource memory association for sparse resources is described in Sparse Resources.
		</p>
	</li>
	<li>
		<p>
            Non-sparse resources must be bound completely and contiguously to a single VkDeviceMemory object before the resource is passed as a parameter to any of the following operations:
		</p>
		<ul>
			<li>
				<p>
                    creating buffer, image, or tensor views
				</p>
			</li>
			<li>
				<p>
                    updating descriptor sets
				</p>
			</li>
			<li>
				<p>
                    recording commands in a command buffer
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Once bound, the memory binding is immutable for the lifetime of the resource.
		</p>
	</li>
	<li>
		<p>
            In a logical device representing more than one physical device, buffer and image resources exist on all physical devices but can be bound to memory differently on each. Each such replicated resource is an instance of the resource. For sparse resources, each instance can be bound to memory arbitrarily differently. For non-sparse resources, each instance can either be bound to the local or a peer instance of the memory, or for images can be bound to rectangular regions from the local and/or peer instances. When a resource is used in a descriptor set, each physical device interprets the descriptor according to its own instance‚Äôs binding to memory.
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/sparse_resources.html" 
				class="external-link" 
				target="_blank" >
                Sparse Resources
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/sparsemem.html" 
				class="external-link" 
				target="_blank" >
                Sparse Resources
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Sparse resources let you create 
            <code>VkBuffer</code>
            &nbsp;and 
            <code>VkImage</code>
            &nbsp;objects which are bound non-contiguously to one or more 
            <code>VkDeviceMemory</code>
            &nbsp;allocations.
		</p>
	</li>
</ul>
<h4
	id="host-access" >
    Host Access
</h4>
<ul>
	<li>
		<p>
            Also check 
            <a href="/studies/Graphics Programming/GPU/GPU.html">
            GPU
            </a>
            .
		</p>
	</li>
	<li>
		<p>
            Memory objects created with 
            <code>vkAllocateMemory</code>
            &nbsp;are not directly host accessible.
		</p>
	</li>
	<li>
		<p>
            Memory objects created with the memory property 
            <code>MEMORY_PROPERTY_HOST_VISIBLE</code>
            &nbsp;are considered mappable. Memory objects must be mappable in order to be successfully mapped on the host.
		</p>
	</li>
	<li>
		<p>
            <code>vkMapMemory</code>
		</p>
		<ul>
			<li>
				<p>
                    This function allows us to access a region of the specified memory resource defined by an offset and size.
				</p>
			</li>
			<li>
				<p>
                    Used to retrieve a host virtual address pointer to a region of a mappable memory object.
				</p>
			</li>
			<li>
				<p>
                    It is also possible to specify the special value 
                    <code>WHOLE_SIZE</code>
                    &nbsp;to map all of the memory.
				</p>
			</li>
			<li>
				<p>
                    <code>device</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the logical device that owns the memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>memory</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the 
                            <code>VkDeviceMemory</code>
                            &nbsp;object to be mapped.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>offset</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a zero-based byte offset from the beginning of the memory object.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>size</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the size of the memory range to map, or 
                            <code>WHOLE_SIZE</code>
                            &nbsp;to map from offset to the end of the allocation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitmask of 
                            <code>VkMemoryMapFlagBits</code>
                            &nbsp;specifying additional parameters of the memory map operation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>ppData</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
                            <code>void*</code>
                            &nbsp;variable in which a host-accessible pointer to the beginning of the mapped range is returned. The value of the returned pointer minus offset must be aligned to 
                            <code>VkPhysicalDeviceLimits.minMemoryMapAlignment</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Acts like regular RAM, but physically points to GPU memory.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            After a successful call to 
            <code>vkMapMemory</code>
            &nbsp;the memory object memory is considered to be currently host mapped.
		</p>
	</li>
	<li>
		<p>
            It is an application error to call vkMapMemory on a memory object that is already host mapped.
		</p>
	</li>
	<li>
		<p>
            <code>vkMapMemory</code>
            &nbsp;does not check whether the device memory is currently in use before returning the host-accessible pointer.
		</p>
	</li>
	<li>
		<p>
            If the device memory was allocated without the 
            <code>MEMORY_PROPERTY_HOST_COHERENT</code>
            &nbsp;set, these guarantees must be made for an extended range: the application must round down the start of the range to the nearest multiple of 
            <code>VkPhysicalDeviceLimits.nonCoherentAtomSize</code>
            , and round the end of the range up to the nearest multiple of 
            <code>VkPhysicalDeviceLimits.nonCoherentAtomSize</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Problem
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The driver may not immediately copy the data into the buffer memory, for example, because of caching.
				</p>
			</li>
			<li>
				<p>
                    It is also possible that writes to the buffer are not visible in the mapped memory yet.
				</p>
			</li>
			<li>
				<p>
                    There are two ways to deal with that problem:
				</p>
				<ul>
					<li>
						<p>
                            Use a memory heap that is host coherent, indicated with 
                            <code>MEMORY_PROPERTY_HOST_COHERENT</code>
						</p>
					</li>
					<li>
						<p>
                            Call 
                            <code>vkFlushMappedMemoryRanges</code>
                            &nbsp;after writing to the mapped memory, and call 
                            <code>vkInvalidateMappedMemoryRanges</code>
                            &nbsp;before reading from the mapped memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Flushing memory ranges or using a coherent memory heap means that the driver will be aware of our writings to the buffer, but it doesn‚Äôt mean that they are actually visible on the GPU yet. The transfer of data to the GPU is an operation that happens in the background, and the specification simply 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap7.html#synchronization-submission-host-writes" 
						class="external-link" 
						target="_blank" >
                        tells us
					</a>
                    &nbsp;that it is guaranteed to be complete as of the next call to 
                    <code>vkQueueSubmit</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Minimum Alignment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceLimits</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>minMemoryMapAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, of host visible memory allocations within the host address space.
								</p>
							</li>
							<li>
								<p>
                                    When mapping a memory allocation with 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory.html" 
										class="external-link" 
										target="_blank" >
                                        vkMapMemory
									</a>
                                    , subtracting 
                                    <code>offset</code>
                                    &nbsp;bytes from the returned pointer will always produce an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    See 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-device-hostaccess" 
										class="external-link" 
										target="_blank" >
                                        https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-device-hostaccess
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>nonCoherentAtomSize</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the size and alignment in bytes that bounds 
									<em>
                                        concurrent
									</em>
                                    &nbsp;access to 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-device-hostaccess" 
										class="external-link" 
										target="_blank" >
                                        host-mapped device memory
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ChatGPT:
				</p>
				<ul>
					<li>
						<p>
                            Dynamic offsets:
						</p>
						<ul>
							<li>
								<p>
                                    If you used 
                                    <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                    &nbsp;or 
                                    <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                    &nbsp;in your 
                                    <code>VkDescriptorSetLayoutBinding</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            That is the definition of a dynamic descriptor.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If you call 
                                    <code>vkCmdBindDescriptorSets(..., dynamicOffsetCount, pDynamicOffsets)</code>
                                    . If 
                                    <code>dynamicOffsetCount &gt; 0</code>
                                    &nbsp;and 
                                    <code>pDynamicOffsets</code>
                                    &nbsp;is non-null you are supplying dynamic offsets at bind time.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            How offsets are applied:
						</p>
						<ul>
							<li>
								<p>
                                    Non-dynamic descriptor:
								</p>
								<ul>
									<li>
										<p>
                                            The 
                                            <code>VkDescriptorBufferInfo.offset</code>
                                            &nbsp;you gave to 
                                            <code>vkUpdateDescriptorSets</code>
                                            &nbsp;is baked into the descriptor.
										</p>
									</li>
									<li>
										<p>
                                            That 
                                            <code>offset</code>
                                            &nbsp;must be a multiple of 
                                            <code>minUniformBufferOffsetAlignment</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Dynamic descriptor:
								</p>
								<ul>
									<li>
										<p>
                                            The descriptor stores a base 
                                            <code>offset</code>
                                            /
                                            <code>range</code>
                                            , and the runtime adds the dynamic offset(s) you pass to 
                                            <code>vkCmdBindDescriptorSets</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Each dynamic offset must be a multiple of 
                                            <code>minUniformBufferOffsetAlignment</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If you are not using Dynamic Offsets in the 
                            <code>vkCmdBindDescriptorSets</code>
                            , nor using offsets in the 
                            <code>VkDescriptorBufferInfo</code>
                            , then you don't need to worry about this limit.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="staging-buffer" >
    Staging buffer
</h5>
<ul>
	<li>
		<p>
            Use a 
			<em>
                host visible buffer
			</em>
            &nbsp;as temporary buffer and use a 
			<em>
                device local buffer
			</em>
            &nbsp;as actual buffer.
		</p>
	</li>
	<li>
		<p>
            The host visible buffer should have use 
            <code>BUFFER_USAGE_TRANSFER_SRC</code>
            , and the device local buffer should have use 
            <code>BUFFER_USAGE_TRANSFER_DST</code>
            .
		</p>
	</li>
	<li>
		<p>
            The contents of the host visible buffer is copied to the device local buffer using 
            <code>vkCmdCopyBuffer</code>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250813094230.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/memory_allocation.html#_transfer" 
				class="external-link" 
				target="_blank" >
                Data Transfer
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Buffer copy requirements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Requires a queue family that supports transfer operations, which is indicated using 
                    <code>QUEUE_TRANSFER</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Any queue family with 
                            <code>QUEUE_GRAPHICS</code>
                            &nbsp;or 
                            <code>QUEUE_COMPUTE</code>
                            &nbsp;capabilities already implicitly support 
                            <code>QUEUE_TRANSFER</code>
                            &nbsp;operations.
						</p>
					</li>
					<li>
						<p>
                            A different queue family specifically for transfer operations could be used.
						</p>
						<ul>
							<li>
								<p>
                                    It will require you to make the following modifications to your program:
								</p>
								<ul>
									<li>
										<p>
                                            Modify 
                                            <code>QueueFamilyIndices</code>
                                            &nbsp;and 
                                            <code>findQueueFamilies</code>
                                            &nbsp;to explicitly look for a queue family with the 
                                            <code>QUEUE_TRANSFER</code>
                                            &nbsp;bit, but not the 
                                            <code>QUEUE_GRAPHICS</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Modify 
                                            <code>createLogicalDevice</code>
                                            &nbsp;to request a handle to the transfer queue
										</p>
									</li>
									<li>
										<p>
                                            Create a second command pool for command buffers that are submitted on the transfer queue family
										</p>
									</li>
									<li>
										<p>
                                            Change the 
                                            <code>sharingMode</code>
                                            &nbsp;of resources to be 
                                            <code>SHARING_MODE_CONCURRENT</code>
                                            &nbsp;and specify both the graphics and transfer queue families
										</p>
									</li>
									<li>
										<p>
                                            Submit any transfer commands like 
                                            <code>vkCmdCopyBuffer</code>
                                            &nbsp;(which we‚Äôll be using in this chapter) to the transfer queue instead of the graphics queue
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            This will teach you a lot about how resources are shared between queue families.
						</p>
					</li>
					<li>
						<p>
                            Caio: Ok, but what's the benefits of using different queues? I don't know.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="bar-base-address-register" >
    BAR (Base Address Register)
</h5>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Graphics Programming/GPU/GPU.html">
            GPU
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="memory-aliasing" >
    Memory Aliasing
</h5>
<ul>
	<li>
		<p>
            A range of a VkDeviceMemory allocation is aliased if it is bound to multiple resources simultaneously, as described below, via 
            <code>vkBindImageMemory</code>
            , 
            <code>vkBindBufferMemory</code>
            , 
            <code>vkBindAccelerationStructureMemoryNV</code>
            , 
            <code>vkBindTensorMemoryARM</code>
            , via sparse memory bindings, or by binding the memory to resources in multiple Vulkan instances or external APIs using external memory handle export and import mechanisms.
		</p>
	</li>
	<li>
		<p>
            Consider two resources, resourceA and resourceB, bound respectively to memory rangeA and rangeB. Let paddedRangeA and paddedRangeB be, respectively, rangeA and rangeB aligned to bufferImageGranularity. If the resources are both linear or both non-linear (as defined in the Glossary), then the resources alias the memory in the intersection of rangeA and rangeB. If one resource is linear and the other is non-linear, then the resources alias the memory in the intersection of paddedRangeA and paddedRangeB.
		</p>
	</li>
	<li>
		<p>
            The implementation-dependent limit bufferImageGranularity also applies to tensor resources.
		</p>
	</li>
	<li>
		<p>
            Memory aliasing can be useful to reduce the total device memory footprint of an application, if some large resources are used for disjoint periods of time.
		</p>
	</li>
	<li>
		<p>
            <code>vkBindBufferMemory()</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    If memory allocation was successful, then we can now associate this memory with the buffer using this function.
				</p>
			</li>
			<li>
				<p>
                    <code>offset</code>
				</p>
				<ul>
					<li>
						<p>
                            Offset within the region of memory.
						</p>
					</li>
					<li>
						<p>
                            Since this memory is allocated specifically for this the vertex buffer, the offset is simply 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If the offset is non-zero, then it is required to be divisible by 
                            <code>memRequirements.alignment</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-memory-aliasing" 
				class="external-link" 
				target="_blank" >
                Memory Aliasing
			</a>
            .
		</p>
	</li>
</ul>
<h4
	id="lazily-allocated-memory" >
    Lazily Allocated Memory
</h4>
<ul>
	<li>
		<p>
            If the memory object is allocated from a heap with the 
            <code>MEMORY_PROPERTY_LAZILY_ALLOCATED</code>
            &nbsp;bit set, that object‚Äôs backing memory may be provided by the implementation lazily. The actual committed size of the memory may initially be as small as zero (or as large as the requested size), and monotonically increases as additional memory is needed.
		</p>
	</li>
	<li>
		<p>
            A memory type with this flag set is only allowed to be bound to a VkImage whose usage flags include 
            <code>IMAGE_USAGE_TRANSIENT_ATTACHMENT</code>
            .
		</p>
	</li>
</ul>
<h4
	id="protected-memory" >
    Protected Memory
</h4>
<ul>
	<li>
		<p>
            Protected memory divides device memory into protected device memory and unprotected device memory.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Unprotected Device Memory
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Unprotected device memory, which can be visible to the device and can be visible to the host
				</p>
			</li>
			<li>
				<p>
                    Unprotected images, unprotected tensors, and unprotected buffers, to which unprotected memory can be bound
				</p>
			</li>
			<li>
				<p>
                    Unprotected command buffers, which can be submitted to a device queue to execute unprotected queue operations
				</p>
			</li>
			<li>
				<p>
                    Unprotected device queues, to which unprotected command buffers can be submitted
				</p>
			</li>
			<li>
				<p>
                    Unprotected queue submissions, through which unprotected command buffers can be submitted
				</p>
			</li>
			<li>
				<p>
                    Unprotected queue operations
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Protected Device Memory
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Protected device memory, which can be visible to the device but must not be visible to the host
				</p>
			</li>
			<li>
				<p>
                    Protected images, protected tensors, and protected buffers, to which protected memory can be bound
				</p>
			</li>
			<li>
				<p>
                    Protected command buffers, which can be submitted to a protected-capable device queue to execute protected queue operations
				</p>
			</li>
			<li>
				<p>
                    Protected-capable device queues, to which unprotected command buffers or protected command buffers can be submitted
				</p>
			</li>
			<li>
				<p>
                    Protected queue submissions, through which protected command buffers can be submitted
				</p>
			</li>
			<li>
				<p>
                    Protected queue operations
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/protected.html" 
				class="external-link" 
				target="_blank" >
                Protected Memory
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="tracking-gpu-memory" >
    Tracking GPU Memory
</h3>
<ul>
	<li>
		<p>
            Vulkan does not expose fixed per-object byte counts for most objects ‚Äî exact memory use is implementation and driver-dependent. Some objects (
            <code>VkImage</code>
            , 
            <code>VkBuffer</code>
            ) must be bound to 
            <code>VkDeviceMemory</code>
            &nbsp;you allocate (so you can know their size). Many other objects (pipelines, command buffers, descriptor sets, semaphores, imageviews, pipeline layouts, etc.) often cause hidden driver allocations that may live in host memory, device memory, or both ‚Äî and those allocations‚Äô size and placement vary by driver and GPU.
		</p>
	</li>
</ul>
<h5
	id="by-object" >
    By object
</h5>
<ul>
	<li>
		<p>
            <code>VkInstance</code>
            &nbsp;/ 
            <code>VkPhysicalDevice</code>
            &nbsp;/ 
            <code>VkDevice</code>
            &nbsp;(handles):
		</p>
		<ul>
			<li>
				<p>
                    Small host-side allocations (process RAM). Measure via your VkAllocationCallbacks or by tracking driver host allocations. These are host-visible (they are just process memory)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkImageView</code>
            &nbsp;/ 
            <code>VkBufferView</code>
            &nbsp;/ 
            <code>VkSampler</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Lightweight, usually host memory (small driver structures). They rarely allocate large device memory; they may cause small host allocations. Implementation dependent but small (tens to a few hundred bytes each in many drivers).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkDescriptorSetLayout</code>
            &nbsp;/ 
            <code>VkPipelineLayout</code>
            &nbsp;/ 
            <code>VkDescriptorSet</code>
            &nbsp;(layout vs sets):
		</p>
		<ul>
			<li>
				<p>
                    Layout and pipeline layout are small host structures (host memory). Descriptor sets and descriptor pools may be implemented in host memory or device memory; larger descriptor usage (large arrays, inline uniform blocks, inline immutable samplers, or driver internal structures) can cause real device allocations. Behavior is driver dependent.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkPipeline</code>
            &nbsp;(graphics/compute):
		</p>
		<ul>
			<li>
				<p>
                    Creation can cause hidden device and/or host allocations (compiled device binaries, GPU resident state). The spec explicitly allows implementations to allocate device memory during pipeline creation; the pipeline cache and pipeline executable properties APIs can help quantify some of this. Pipeline objects range from a few KB to multiple MB depending on driver, the number/complexity of shaders, and whether the driver stores compiled GPU blobs. Use 
                    <code>VK_KHR_pipeline_executable_properties</code>
                    &nbsp;and pipeline cache queries to inspect pipeline internals.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkPipelineCache</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Contains data you can query with 
                    <code>vkGetPipelineCacheData</code>
                    &nbsp;‚Äî that returns host-visible data you can size and persist.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkCommandPool</code>
            &nbsp;/ 
            <code>VkCommandBuffer</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Command buffers are allocated from a pool; actual memory holding recorded commands is driver-managed and may be placed in device local memory (GPU command stream) or host memory, depending on driver and OS. Sizes vary widely and are not exposed directly; instrument via driver callbacks or 
                    <code>VK_EXT_device_memory_report</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkSemaphore</code>
            &nbsp;/ 
            <code>VkFence</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Binary semaphores and fences may use kernel/OS constructs or small host/device allocations; timeline semaphores hold a 64-bit value and may be backed by device memory on some implementations. Typically small (a few bytes to some KB) but driver dependent.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkSwapchainKHR</code>
            &nbsp;and presentable images:
		</p>
		<ul>
			<li>
				<p>
                    Swapchain images are VkImage objects with memory managed by the WSI/driver; they are typically DEVICE_LOCAL and can live in special presentable heaps. Their size equals image size √ó format bits √ó layers/levels plus padding (obtainable from 
                    <code>vkGetImageMemoryRequirements</code>
                    &nbsp;for images you allocate yourself; for WSI images use provided queries and 
                    <code>VK_EXT_memory_budget</code>
                    &nbsp;to monitor heap consumption).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Typical magnitude examples (illustrative only)
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Instance / layouts / view objects: tens to hundreds of bytes each (host).
				</p>
			</li>
			<li>
				<p>
                    Small buffers (uniform buffers) / small images: KBs to MBs, depending on dimensions and format ‚Äî these are the allocations you make explicitly.
				</p>
			</li>
			<li>
				<p>
                    Pipelines: KBs ‚Üí multiple MBs (depends on shader complexity and driver caching). Use pipeline executable queries to get an estimate.
				</p>
			</li>
			<li>
				<p>
                    Command buffer pools / driver command memory: KBs ‚Üí MBs per many command buffers; driver dependent.
				</p>
			</li>
			<li>
				<p>
                    These numbers must be measured on your target hardware ‚Äî they are not constant across drivers.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tracking" >
    Tracking
</h5>
<ol>
	<li>
		<p
			class="line-emphasis" >
            Centralize and wrap all 
            <code>vkAllocateMemory</code>
            &nbsp;/ 
            <code>vkFreeMemory</code>
            &nbsp;calls.
		</p>
		<ul>
			<li>
				<p>
                    Record: 
                    <code>VkDeviceMemory</code>
                    &nbsp;handle, 
                    <code>VkMemoryAllocateInfo</code>
                    &nbsp;size/flags, chosen memory type index, and optionally the 
                    <code>VkDeviceSize</code>
                    &nbsp;and offset for any suballocator logic. Suballocation (one 
                    <code>VkDeviceMemory</code>
                    &nbsp;used for many buffers/images) means you must additionally record your suballocations. Use this table as the authoritative committed GPU bytes. (Spec: 
                    <code>vkAllocateMemory</code>
                    &nbsp;produces the device memory payload.)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Track suballocation bookkeeping in your allocator.
		</p>
		<ul>
			<li>
				<p>
                    If you allocate large 
                    <code>VkDeviceMemory</code>
                    &nbsp;blocks and suballocate slices for many buffers/images, account the slices into your counters (otherwise counting only 
                    <code>VkDeviceMemory</code>
                    &nbsp;handles will under- or over-count usage).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            Hook creation / bind points to attribute usage.
		</p>
		<ul>
			<li>
				<p>
                    When you 
                    <code>vkBindBufferMemory</code>
                    &nbsp;/ 
                    <code>vkBindImageMemory</code>
                    , attach which application object is consuming which suballocation ‚Äî this lets you produce per-buffer/per-image committed usage.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            Use 
            <code>VK_EXT_memory_budget</code>
            &nbsp;for driver-reported heap usage/budgets.
		</p>
		<ul>
			<li>
				<p>
                    Query 
                    <code>VkPhysicalDeviceMemoryBudgetPropertiesEXT</code>
                    &nbsp;via 
                    <code>vkGetPhysicalDeviceMemoryProperties2</code>
                    &nbsp;to get 
                    <code>heapBudget</code>
                    &nbsp;and 
                    <code>heapUsage</code>
                    &nbsp;values per heap.
				</p>
			</li>
			<li>
				<p>
                    These are implementation-provided and reflect other processes and driver internal usage; use them as cross-checks and to warn when you approach limits.
				</p>
			</li>
			<li>
				<p>
                    Use it to see heap usage and budget per heap (useful to spot overall device local vs host mapped heap pressure). This is not per-object, but shows total heap usage and remaining budget. Combine with device_memory_report events to attribute heap changes to objects.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            Enable 
            <code>VK_EXT_device_memory_report</code>
            &nbsp;for visibility into 
			<strong>
                driver-internal
			</strong>
            &nbsp;allocations.
		</p>
		<ul>
			<li>
				<p>
                    This extension gives callbacks for driver-side device memory events (allocate/free/import) including allocations not exposed as VkDeviceMemory (for example, allocations made internally during pipeline creation). Use it for debugging and to catch allocations that your vkAllocateMemory wrapper would miss.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Account for dedicated allocations and imports.
		</p>
		<ul>
			<li>
				<p>
                    You can use 
                    <code>VK_KHR_dedicated_allocation</code>
                    &nbsp;to force one allocation per resource. If you allocate one 
                    <code>VkDeviceMemory</code>
                    &nbsp;per resource you know exactly how many bytes each resource consumes.
				</p>
			</li>
			<li>
				<p>
                    If an allocation is made with 
                    <code>VkMemoryDedicatedAllocateInfo</code>
                    &nbsp;or via external memory import, count that device memory appropriately ‚Äî it typically represents a whole allocation tied to a single image/buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Use 
            <code>VK_KHR_pipeline_executable_properties</code>
            &nbsp;for pipeline internals.
		</p>
		<ul>
			<li>
				<p>
                    Create the pipeline with the capture flag (
                    <code>VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR</code>
                    ) and call 
                    <code>vkGetPipelineExecutablePropertiesKHR</code>
                    &nbsp;/ 
                    <code>vkGetPipelineExecutableStatisticsKHR</code>
                    &nbsp;to obtain compile-time statistics and sizes for pipeline executables that the driver produced. This helps measure how much space pipeline compilation produced (but it may not show every byte the driver reserved at runtime).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Vendor tools + RenderDoc / NSight / Radeon GPU Profiler.
		</p>
		<ul>
			<li>
				<p>
                    These tools often show GPU memory usage, allocations, and sometimes attribute memory to API objects. Use them to validate your in-process accounting.
				</p>
			</li>
		</ul>
	</li>
</ol>
<h5
	id="device-memory-report-codevk_ext_device_memory_report-code" >
    Device Memory Report (
    <code>VK_EXT_device_memory_report</code>
    )
</h5>
<ul>
	<li>
		<p>
            Last updated (2021-01-06).
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/refpages/latest/refpages/source/VK_EXT_device_memory_report.html" 
				class="external-link" 
				target="_blank" >
                Info
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Allows registration of device memory event callbacks upon device creation, so that applications or middleware can obtain detailed information about memory usage and how memory is associated with Vulkan objects. This extension exposes the actual underlying device memory usage, including allocations that are not normally visible to the application, such as memory consumed by 
            <code>vkCreateGraphicsPipelines</code>
            . It is intended primarily for use by debug tooling rather than for production applications.
		</p>
	</li>
</ul>
<h5
	id="memory-budget-codeext_memory_budget-code" >
    Memory Budget (
    <code>EXT_memory_budget</code>
    )
</h5>
<ul>
	<li>
		<p>
            Last updated (2018-10-08).
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_EXT_memory_budget" 
				class="external-link" 
				target="_blank" >
                Coverage
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Not good on android, but the rest is 80%+.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/memory_budget/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
		</p>
	</li>
	<li>
		<p>
            Query video memory budget for the process from the OS memory manager.
		</p>
	</li>
	<li>
		<p>
            It‚Äôs important to keep usage below the budget to avoid stutters caused by demotion of video memory allocations.
		</p>
	</li>
	<li>
		<p>
            While running a Vulkan application, other processes on the machine might also be attempting to use the same device memory, which can pose problems.
		</p>
	</li>
	<li>
		<p>
            This extension adds support for querying the amount of memory used and the total memory budget for a memory heap. The values returned by this query are implementation-dependent and can depend on a variety of factors including operating system and system load.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VkPhysicalDeviceMemoryBudgetPropertiesEXT.heapBudget</code>
            &nbsp;values can be used as a guideline for how much total memory from each heap the current process can use at any given time, before allocations may start failing or causing performance degradation. The values may change based on other activity in the system that is outside the scope and control of the Vulkan implementation.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VkPhysicalDeviceMemoryBudgetPropertiesEXT.heapUsage</code>
            &nbsp;will display the current process estimated heap usage.
		</p>
	</li>
	<li>
		<p>
            With this information, the idea is for an application at some interval (once per frame, per few seconds, etc) to query heapBudget and heapUsage. From here the application can notice if it is over budget and decide how it wants to handle the memory situation (free it, move to host memory, changing mipmap levels, etc).
		</p>
	</li>
	<li>
		<p>
            This extension is designed to be used in concert with 
            <code>VK_EXT_memory_priority</code>
            &nbsp;to help with this part of memory management.
		</p>
	</li>
</ul>
<h3
	id="vulkan-memory-allocator-vma" >
    <s>Vulkan Memory Allocator (VMA)</s>
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Capati/odin-vma?utm_source=chatgpt.com" 
				class="external-link" 
				target="_blank" >
                VMA in Odin
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator" 
				class="external-link" 
				target="_blank" >
                VMA (vulkan memory allocator)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Implements memory allocators for Vulkan, header only. In Vulkan, the user has to deal with the memory allocation of buffers, images, and other resources on their own. This can be very difficult to get right in a performant and safe way. Vulkan Memory Allocator does it for us and allows us to simplify the creation of images and other resources. Widely used in personal Vulkan engines or smaller scale projects like emulators. Very high end projects like Unreal Engine or AAA engines write their own memory allocators.
		</p>
	</li>
	<li>
		<p>
            There are cases like the PCSX3 emulator project, where they replaced their attempt at allocation to VMA, and won 20% extra framerate.
		</p>
	</li>
	<li>
		<p>
			<em>
                Critiques
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250907092003.png" width="625" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="hdr-support" >
    HDR Support
</h2>
<ul>
	<li>
		<p>
            Shader code converts high-dynamic-range (HDR) linear color values (often stored in floating formats like 
            <code>R16G16B16A16_SFLOAT</code>
            ) into display-referred low-dynamic-range (LDR) values (sRGB or the swapchain format).
		</p>
	</li>
	<li>
		<p>
            Operations include exposure, clamping, tone curve (Reinhard, ACES, filmic), and gamma or sRGB conversion.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/shorts/0M7INvSHSRk" 
				class="external-link" 
				target="_blank" >
                Each monitor manufacturer does this differently; it's not standardized
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Inputs:
		</p>
		<ul>
			<li>
				<p>
                    HDR color (linear), optionally exposure/exposure texture, bloom, eye adaptation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Steps (example minimal):
		</p>
		<ol>
			<li>
				<p>
                    Multiply by exposure.
				</p>
			</li>
			<li>
				<p>
                    Apply curve (e.g. Reinhard: 
                    <code>c/(1+c)</code>
                    , or ACES approximation).
				</p>
			</li>
			<li>
				<p>
                    Convert to sRGB/gamma (
                    <code>pow(color, 1.0/2.2)</code>
                    ) or use proper sRGB conversion.
				</p>
			</li>
			<li>
				<p>
                    Output 
                    <code>vec4</code>
                    &nbsp;clamped to 
                    <code>[0,1]</code>
                    &nbsp;into swapchain format (e.g. 
                    <code>FORMAT_B8G8R8A8_UNORM</code>
                    ).
				</p>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="drawing-to-a-high-precision-image-coder16g16b16a16_sfloat-code" >
    Drawing to a High Precision Image (
    <code>R16G16B16A16_SFLOAT</code>
    )
</h5>
<ul>
	<li>
		<p>
            Rendering into an 
            <code>R16G16B16A16_SFLOAT</code>
            &nbsp;(FP16) image provides:
		</p>
		<ul>
			<li>
				<p>
                    Higher dynamic range and precision (light accumulation &gt; 1.0, less banding, better tone mapping).
				</p>
			</li>
			<li>
				<p>
                    Freedom to tone-map and convert later.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This is the 
			<em>
                engine-side HDR pipeline
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vkguide.dev/docs/new_chapter_2/vulkan_new_rendering/#new-draw-loop" 
				class="external-link" 
				target="_blank" >
                Described technique
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    From &quot;New draw loop&quot; until the end.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Rendering into a separate high-precision offscreen target and then copying/blitting/tonemapping into the swapchain is the standard approach when you need arbitrary internal resolution, higher precision, HDR processing, or when the swapchain does not expose desired formats/usages. The trade-off is the extra memory and an explicit copy/blit or import step; the benefit is control over precision and size. The Vulkan command 
            <code>vkCmdBlitImage</code>
            &nbsp;/ transfer usage or a shader-based blit/resolve are the usual mechanisms to move from the internal target to the presentable image.
		</p>
	</li>
	<li>
		<p>
            The image we will be using is going to be in the RGBA 16-bit float format.
		</p>
		<ul>
			<li>
				<p>
                    <code>R16G16B16A16_SFLOAT</code>
                    &nbsp;is a common intermediate HDR format (16-bit float per channel). It increases memory and bandwidth (roughly 2√ó vs 8-bit RGBA) and may affect GPU/VRAM usage and upload/download costs; it also reduces quantization/banding and supports HDR/light-accumulation workflows without clamping at 1.0. The choice is an explicit trade-off: more precision (and headroom for lighting) vs more memory/bandwidth. The format is widely supported for offscreen images but may not be available as a swapchain format on all platforms, which reinforces the decision to render offscreen then convert/tonemap for presentation.
				</p>
			</li>
			<li>
				<p>
                    This is slightly overkill, but will provide us with a lot of extra pixel precision that will come in handy when doing lighting calculations and better rendering.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It's possible to apply low-latency techniques where we could be rendering into a different image from the swapchain image, and then directly push that image to the swapchain with very low latency.
		</p>
		<ul>
			<li>
				<p>
                    Techniques like NVIDIA's &quot;Latency Markers&quot; / Reflex or AMD's Anti-Lag rely on starting rendering work as early as possible, often 
					<em>
                        before
					</em>
                    &nbsp;the presentation engine signals readiness for the next frame via 
                    <code>vkAcquireNextImageKHR</code>
                    &nbsp;(Vulkan) or 
                    <code>AcquireNextFrame</code>
                    &nbsp;(DXGI). This necessitates rendering into a separate, persistently available image. The swapchain image index is only provided at acquisition time, making pre-rendering impossible with direct swapchain targets. Documentation for these low-latency SDKs implicitly requires separate render targets.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Choosing the image tiling:
		</p>
		<ul>
			<li>
				<p>
                    We can then copy that image into the swapchain image and present it to the screen.
				</p>
			</li>
			<li>
				<p>
                    <code>VkCmdCopyImage</code>
				</p>
				<ul>
					<li>
						<p>
                            Is faster, but its much more restricted, for example the resolution on both images must match.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VkCmdBlitImage</code>
				</p>
				<ul>
					<li>
						<p>
                            Lets you copy images of different formats and different sizes into one another.
						</p>
					</li>
					<li>
						<p>
                            You have a source rectangle and a target rectangle, and the system copies it into its position.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                New code for transitioning
			</em>
            :
		</p>
<pre><code class="language-cpp" data-lang="cpp">_drawExtent.width = _drawImage.imageExtent.width;
_drawExtent.height = _drawImage.imageExtent.height;

CHECK(vkBeginCommandBuffer(cmd, &cmdBeginInfo)); 

// transition our main draw image into general layout so we can write into it
// we will overwrite it all so we dont care about what was the older layout
vkutil::transition_image(cmd, _drawImage.image, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_GENERAL);

draw_background(cmd);

//transition the draw image and the swapchain image into their correct transfer layouts
vkutil::transition_image(cmd, _drawImage.image, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);
vkutil::transition_image(cmd, _swapchainImages[swapchainImageIndex], IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);

// execute a copy from the draw image into the swapchain
vkutil::copy_image_to_image(cmd, _drawImage.image, _swapchainImages[swapchainImageIndex], _drawExtent, _swapchainExtent);

// set swapchain image layout to Present so we can show it on the screen
vkutil::transition_image(cmd, _swapchainImages[swapchainImageIndex], IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, IMAGE_LAYOUT_PRESENT_SRC_KHR);

//finalize the command buffer (we can no longer add commands, but it can now be executed)
CHECK(vkEndCommandBuffer(cmd));
</code></pre>
		<ul>
			<li>
				<p>
                    The main difference we have in the render loop is that we no longer do the clear on the swapchain image. Instead, we do it on the 
                    <code>_drawImage.image</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Once we have cleared the image, we transition both the swapchain and the draw image into their layouts for transfer, and we execute the copy command. Once we are done with the copy command, we transition the swapchain image into present layout for display. As we are always drawing on the same image, our draw_image does not need to access swapchain index, it just clears the draw image. We are also writing the 
                    <code>_drawExtent</code>
                    &nbsp;that we will use for our draw region.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="etc" >
    Etc
</h5>
<ul>
	<li>
		<p>
			<strong>
                But
			</strong>
            &nbsp;this image still has to be copied/tonemapped into the 
			<strong>
                swapchain format
			</strong>
            , which is typically limited to 8-bit UNORM unless the OS/driver supports HDR swapchain formats.
		</p>
	</li>
	<li>
		<p>
            To actually output HDR to the screen, all of the following conditions must be met:
		</p>
	</li>
</ul>
<ol>
	<li>
		<p>
			<strong>
                Swapchain format must support HDR bit depth
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    Example formats: 
                    <code>FORMAT_A2B10G10R10_UNORM_PACK32</code>
                    , 
                    <code>FORMAT_R16G16B16A16_SFLOAT</code>
                    , or platform-specific HDR surface formats.
				</p>
			</li>
			<li>
				<p>
                    You query available swapchain formats via 
                    <code>vkGetPhysicalDeviceSurfaceFormatsKHR</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If only 8-bit formats are exposed, you cannot present HDR directly.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Swapchain color space must be HDR-capable
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Vulkan allows specifying a 
                    <code>VkColorSpaceKHR</code>
                    &nbsp;(e.g., 
                    <code>COLOR_SPACE_HDR10_ST2084_EXT</code>
                    , 
                    <code>COLOR_SPACE_HDR10_HLG_EXT</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    These correspond to HDR transfer functions (PQ/HLG).
				</p>
			</li>
			<li>
				<p>
                    If the driver/surface does not expose them, the system compositor won‚Äôt accept HDR content.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                OS and display pipeline must be HDR-enabled
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Windows: HDR toggle must be enabled in system settings, compositor configured for HDR10.
				</p>
			</li>
			<li>
				<p>
                    Linux/Wayland: requires HDR support in compositor + driver (still emerging).
				</p>
			</li>
			<li>
				<p>
                    Android: requires 
                    <code>AHardwareBuffer</code>
                    &nbsp;/ 
                    <code>SurfaceView</code>
                    &nbsp;with HDR formats.
				</p>
			</li>
			<li>
				<p>
                    macOS: Metal swapchains expose extended sRGB/PQ output modes.
				</p>
			</li>
			<li>
				<p>
                    (Platform docs confirm HDR availability is compositor-driven).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Application side tone mapping &amp; gamut mapping
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Even if swapchain supports HDR, you generally still render into FP16, then apply:
				</p>
				<ul>
					<li>
						<p>
                            Tone mapping (map wide dynamic range ‚Üí HDR10/HLG range).
						</p>
					</li>
					<li>
						<p>
                            Color gamut conversion (usually Rec.709 ‚Üí Rec.2020 for HDR10).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Only then write into the HDR swapchain image.
				</p>
			</li>
		</ul>
	</li>
</ol>
<h2
	id="profiling" >
    Profiling
</h2>
<ul>
	<li>
		<p>
            Provides your application with a mechanism to time the execution of commands on the GPU.
		</p>
	</li>
	<li>
		<p>
            You can specify any pipeline stage at which the timestamp should be written, a lot of stage combinations and orderings won‚Äôt give meaningful result.
		</p>
		<ul>
			<li>
				<p>
                    So while it may may sound reasonable to write timestamps for the vertex and fragment shader stage directly one after another, that will usually not return meaningful results due to how the GPU works.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            You can‚Äôt compare timestamps taken on different queues.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/api/timestamp_queries/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    We‚Äôll be using 6 time points, one for the start and one for the end of three render passes.
				</p>
			</li>
			<li>
				<p>
                    The code 
                    <code>samples/api/timestamp_queries</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Uses 
                            <code>QUERY_RESULT_64 | QUERY_RESULT_WAIT</code>
                            , so it's not optimal.
						</p>
					</li>
					<li>
						<p>
                            The query is made after 
                            <code>vkQueueSubmit()</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pavelsmejkal.net/Posts/GPUTimingBasics" 
				class="external-link" 
				target="_blank" >
                GPU Timing Basics
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Vulkan and DX12.
				</p>
			</li>
			<li>
				<p>
                    Uses 
                    <code>QUERY_RESULT_64</code>
                    &nbsp;and enables the 
                    <code>hostQueryReset</code>
                    &nbsp;for 
                    <code>vk.PhysicalDeviceVulkan12Features</code>
                    , using 
                    <code>vk.ResetQueryPool()</code>
                    &nbsp;right after creating the 
                    <code>QueryPool</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#queries" 
				class="external-link" 
				target="_blank" >
                Queries
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdWriteTimestamp2</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is pretty much the same as the 
                    <code>vkCmdWriteTimestamp</code>
                    &nbsp;function used in this sample, but adds support for some additional pipeline stages using 
                    <code>VkPipelineStageFlags2</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="support" >
    Support
</h3>
<ul>
	<li>
		<p>
            Device limits:
		</p>
		<ul>
			<li>
				<p>
                    <code>timestampPeriod</code>
				</p>
				<ul>
					<li>
						<p>
                            If the limit of the physical device is greater than zero, timestamp queries are supported.
						</p>
					</li>
					<li>
						<p>
                            If your device has a 
                            <code>timestampPeriod</code>
                            &nbsp;of 1, so that one increment in the result maps to exactly one nanosecond.
						</p>
					</li>
					<li>
						<p>
                            It contains the number of nanoseconds it takes for a timestamp query value to be increased by 1 (&quot;tick&quot;).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>timestampComputeAndGraphics</code>
				</p>
				<ul>
					<li>
						<p>
                            If is 
                            <code>TRUE</code>
                            , timestamps are supported by every queue family that supports either graphics or compute operations
						</p>
					</li>
					<li>
						<p>
                            If not, we need to check if the queue we want to use supports timestamps.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="query-pool" >
    Query Pool
</h3>
<ul>
	<li>
		<p>
            A query pool is then used to either directly fetch or copy over the results to the host.
		</p>
	</li>
	<li>
		<p>
            Used to store and read back the results.
		</p>
	</li>
	<li>
		<p>
            <code>queryType</code>
		</p>
		<ul>
			<li>
				<p>
                    We set to 
                    <code>QUERY_TYPE_TIMESTAMP</code>
                    &nbsp;for using timestamp queries
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>queryCount</code>
		</p>
		<ul>
			<li>
				<p>
                    The maximum number of the the timestamp query result this pool can store.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="reset" >
    Reset
</h5>
<ul>
	<li>
		<p>
            Before we can start writing data to the query pool, we need to reset it.
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdResetQueryPool</code>
		</p>
		<ul>
			<li>
				<p>
                    At the start of the command buffer.
				</p>
			</li>
			<li>
				<p>
                    Sets the status of query indices [
                    <code>firstQuery</code>
                    , 
                    <code>firstQuery</code>
                    &nbsp;+ 
                    <code>queryCount</code>
                    &nbsp;- 1] to unavailable.
				</p>
			</li>
			<li>
				<p>
                    Defines an execution dependency between other query commands that reference the same query.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/queries.html#vkResetQueryPool" 
				class="external-link" 
				target="_blank" >
                <code>vkResetQueryPool()</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>QUERY_POOL_CREATE_RESET_KHR</code>
		</p>
		<ul>
			<li>
				<p>
                    During Query Pool creation.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="writing" >
    Writing
</h3>
<ul>
	<li>
		<p>
            <code>vkCmdWriteTimestamp</code>
		</p>
		<ul>
			<li>
				<p>
                    Will request a timestamp to be written from the GPU for a certain pipeline stage and write that value to memory.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="reading" >
    Reading
</h3>
<ul>
	<li>
		<p>
            Reading back the results can be done in two ways:
		</p>
		<ul>
			<li>
				<p>
                    Copy the results into a 
                    <code>VkBuffer</code>
                    &nbsp;inside the command buffer using 
                    <code>vkCmdCopyQueryPoolResults</code>
				</p>
			</li>
			<li>
				<p>
                    Get the results after the command buffer has finished executing using 
                    <code>vkGetQueryPoolResults</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkGetQueryPoolResults()</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>QUERY_RESULT_64</code>
				</p>
				<ul>
					<li>
						<p>
                            Will tell the api that we want to get the results as 64 bit values. Without this flag, we would only get 32 bit values. And since timestamp queries can operate in nanoseconds, only using 32 bits could result into an overflow.
						</p>
					</li>
					<li>
						<p>
                            if your device has a 
                            <code>timestampPeriod</code>
                            &nbsp;of 1, so that one increment in the result maps to exactly one nanosecond, with 32 bit precision you‚Äôd run into such an overflow after only about 0.43 seconds.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>QUERY_RESULT_WAIT</code>
				</p>
				<ul>
					<li>
						<p>
                            Tells the api to wait for all results to be available. So when using this flag the values written to our 
                            <code>time_stamps</code>
                            &nbsp;vector is guaranteed to be available after calling 
                            <code>vkGetQueryPoolResults</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            This is fine for our use-case where we want to immediately access the results, but may introduce unnecessary stalls in other scenarios.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>QUERY_RESULT_WITH_AVAILABILITY</code>
				</p>
				<ul>
					<li>
						<p>
                            Will let you poll the availability of the results and defer writing new timestamps until the results are available.
						</p>
					</li>
					<li>
						<p>
                            This should be the preferred way of fetching the results in a real-world application. Using this flag an additional availability value is inserted after each query value. If that value becomes non-zero, the result is available. You then check availability before writing the timestamp again.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="occlusion-queries" >
    Occlusion Queries
</h3>
<ul>
	<li>
		<p>
            Occlusion queries track the number of samples that pass the per-fragment tests for a set of drawing commands. As such, occlusion queries are only available on queue families supporting graphics operations. The application 
			<strong>
                can
			</strong>
            &nbsp;then use these results to inform future rendering decisions.
		</p>
	</li>
	<li>
		<p>
            An occlusion query is begun and ended by calling 
            <code>vkCmdBeginQuery</code>
            &nbsp;and 
            <code>vkCmdEndQuery</code>
            , respectively.
		</p>
	</li>
	<li>
		<p>
            When an occlusion query begins, the count of passing samples always starts at zero.
		</p>
	</li>
	<li>
		<p>
            For each drawing command, the count is incremented as described in 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/fragops.html#fragops-samplecount" 
				class="external-link" 
				target="_blank" >
                Sample Counting
			</a>
            . If 
            <code>flags</code>
            &nbsp;does not contain 
            <code>QUERY_CONTROL_PRECISE</code>
            &nbsp;an implementation 
			<strong>
                may
			</strong>
            &nbsp;generate any non-zero result value for the query if the count of passing samples is non-zero.
		</p>
	</li>
</ul>
<h3
	id="pipeline-statistics-queries" >
    Pipeline Statistics Queries
</h3>
<ul>
	<li>
		<p>
            Pipeline statistics queries allow the application to sample a specified set of 
            <code>VkPipeline</code>
            &nbsp;counters. These counters are accumulated by Vulkan for a set of either drawing or dispatching commands while a pipeline statistics query is active. As such, pipeline statistics queries are available on queue families supporting compute operations.
		</p>
	</li>
	<li>
		<p>
            The availability of pipeline statistics queries is indicated by the 
            <code>pipelineStatisticsQuery</code>
            &nbsp;member of the 
            <code>VkPhysicalDeviceFeatures</code>
            &nbsp;object (see 
            <code>vkGetPhysicalDeviceFeatures</code>
            &nbsp;and 
            <code>vkCreateDevice</code>
            &nbsp;for detecting and requesting this query type on a 
            <code>VkDevice</code>
            ).
		</p>
	</li>
	<li>
		<p>
            A pipeline statistics query is begun and ended by calling 
            <code>vkCmdBeginQuery</code>
            &nbsp;and 
            <code>vkCmdEndQuery</code>
            , respectively.
		</p>
	</li>
	<li>
		<p>
            When a pipeline statistics query begins, all statistics counters are set to zero. While the query is active, the pipeline type determines which set of statistics are available, but these 
			<strong>
                must
			</strong>
            &nbsp;be configured on the query pool when it is created. If a statistic counter is issued on a command buffer that does not support the corresponding operation, or the counter corresponds to a shading stage which is missing from any of the pipelines used while the query is active, the value of that counter is 
			<strong>
                undefined
			</strong>
            &nbsp;after the query has been made available. At least one statistic counter relevant to the operations supported on the recording command buffer 
			<strong>
                must
			</strong>
            &nbsp;be enabled.
		</p>
	</li>
</ul>
<h3
	id="performance-queries" >
    Performance Queries
</h3>
<ul>
	<li>
		<p>
            Provide applications with a mechanism for getting performance counter information about the execution of command buffers, render passes, and commands. [asdasd]
		</p>
	</li>
	<li>
		<p>
            Each queue family advertises the performance counters that 
			<strong>
                can
			</strong>
            &nbsp;be queried on a queue of that family via a call to 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/devsandqueues.html#vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR" 
				class="external-link" 
				target="_blank" >
                vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
			</a>
            . Implementations 
			<strong>
                may
			</strong>
            &nbsp;limit access to performance counters based on platform requirements or only to specialized drivers for development purposes.
		</p>
	</li>
	<li>
		<p>
            Performance queries use the existing 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/queries.html#vkCmdBeginQuery" 
				class="external-link" 
				target="_blank" >
                vkCmdBeginQuery
			</a>
            &nbsp;and 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/queries.html#vkCmdEndQuery" 
				class="external-link" 
				target="_blank" >
                vkCmdEndQuery
			</a>
            &nbsp;to control what command buffers, render passes, or commands to get performance information for.
		</p>
	</li>
</ul>
<h3
	id="mesh-shaders-queries" >
    Mesh Shaders Queries
</h3>
<ul>
	<li>
		<p>
            When a generated mesh primitives query is active, the mesh-primitives-generated count is incremented every time a primitive emitted from the mesh shader stage reaches the fragment shader stage. When a generated mesh primitives query begins, the mesh-primitives-generated count starts from zero.
		</p>
	</li>
	<li>
		<p>
            Mesh and task shader pipeline statistics queries function the same way that invocation queries work for other shader stages, counting the number of times the respective shader stage has been run. When the statistics query begins, the invocation counters start from zero.
		</p>
	</li>
</ul>
<h3
	id="result-status-queries" >
    Result Status Queries
</h3>
<ul>
	<li>
		<p>
            Result status queries serve a single purpose: allowing the application to determine whether a set of operations have completed successfully or not, as indicated by the 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/queries.html#VkQueryResultStatusKHR" 
				class="external-link" 
				target="_blank" >
                VkQueryResultStatusKHR
			</a>
            &nbsp;value written when retrieving the result of a query using the 
            <code>QUERY_RESULT_WITH_STATUS_KHR</code>
            &nbsp;flag.
		</p>
	</li>
	<li>
		<p>
            Unlike other query types, result status queries do not track or maintain any other data beyond the completion status, thus no other data is written when retrieving their results.
		</p>
	</li>
	<li>
		<p>
            Support for result status queries is indicated by 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/devsandqueues.html#VkQueueFamilyQueryResultStatusPropertiesKHR" 
				class="external-link" 
				target="_blank" >
                VkQueueFamilyQueryResultStatusPropertiesKHR
			</a>
            ::
            <code>queryResultStatusSupport</code>
            &nbsp;, as returned by 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/devsandqueues.html#vkGetPhysicalDeviceQueueFamilyProperties2" 
				class="external-link" 
				target="_blank" >
                vkGetPhysicalDeviceQueueFamilyProperties2
			</a>
            &nbsp;for the queue family in question.
		</p>
	</li>
</ul>
<h3
	id="other-queries" >
    Other Queries
</h3>
<ul>
	<li>
		<p>
            Transform Feedback Queries.
		</p>
	</li>
	<li>
		<p>
            Primitives Generated Queries.
		</p>
	</li>
	<li>
		<p>
            Intel Performance Queries.
		</p>
	</li>
	<li>
		<p>
            Video Encode Feedback Queries.
		</p>
	</li>
</ul>
<h2
	id="mobile" >
    Mobile
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://developer.samsung.com/sdp/blog/en/2019/07/26/vulkan-mobile-best-practice-how-to-configure-your-vulkan-swapchain?utm_source=chatgpt.com" 
				class="external-link" 
				target="_blank" >
                Samsung - Mobile best practices
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>presentMode</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    FIFO &gt; MAILBOX.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minImageCount</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Triple-buffer &gt; double-buffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>preTransform</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Not covered.
								</p>
							</li>
							<li>
								<p>
                                    &quot;Covered in a future post&quot;, but the link is broken.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=yIz4Jzk7bcs" 
				class="external-link" 
				target="_blank" >
                Arm - Mobile Best Practices
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's a more technical video.
				</p>
			</li>
			<li>
				<p>
                    Tiled-based GPUs, etc.
				</p>
			</li>
			<li>
				<p>
                    I haven't watched it yet.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            See pages 244 to 311 of 
			<a
				href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
				class="external-link" 
				target="_blank" >
                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche), Markus Billeter - 2014
			</a>
            &nbsp;for more details.
		</p>
		<ul>
			<li>
				<p>
                    &quot;Many Light Rendering on Mobile Hardware&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=ch6161wvME8" 
				class="external-link" 
				target="_blank" >
                Live Long and Optimise - Samsung 2019
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250929150320.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250929151149.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Android ideas for fixing Present blocking
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250929151334.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            &quot;This is not going to change when the image is presented, we are just delaying the calling of the function that would display the image, to a point where the image is more likely to be available by the GPU&quot;.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250929151618.png" width="450" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2025-09-29) I watched it to study Pipeline Barriers, but the talk covers many mobile-specific topics.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="glfw" >
    GLFW
</h5>
<ul>
	<li>
		<p>
            An unfortunate disadvantage is GLFW doesn‚Äôt work in Android or iOS; it is a desktop-only solution.
		</p>
	</li>
	<li>
		<p>
            SDL does offer mobile support; however, mobile windowing support is best done by interfacing with the Operating system such as using the 
			<strong>
                JNI
			</strong>
            &nbsp;in Android.
		</p>
	</li>
	<li>
		<p>
            While mobile is beyond the scope of this initial tutorial, plans exist to eventually cover it in detail, and 
			<a
				href="https://developer.android.com/ndk/guides/graphics/getting-started" 
				class="external-link" 
				target="_blank" >
                Google has excellent documentation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="pre-rotation" >
    Pre-Rotation
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250818173112.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818173229.png" width="475" >
            .
		</p>
		<ul>
			<li>
				<p>
                    You can only query 
                    <code>surfaceCapabilities.currentTransform</code>
                    , you cannot set it.
				</p>
			</li>
			<li>
				<p>
                    If they don't match, the presentation engine will have to do the pre-rotation for you, which has a performance cost.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Implementing a full pre-rotate system is reportedly difficult, so many engines avoid it.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818173635.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818173712.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    This is a simpler option to implement.
				</p>
			</li>
			<li>
				<p>
                    &quot;Many engines already do a blit to the final image to the swapchain image, so this is the perfect place to do the pre-rotation&quot;.
				</p>
				<ul>
					<li>
						<p>
                            &quot;Basically free and you get performance benefits&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="vr" >
    VR
</h2>
<ul>
	<li>
		<p>
            <a href="/studies/Graphics Programming/Render Engineering/Render Engineering.html#variable-rate-shading-vrs">
            Render Engineering#Variable Rate Shading (VRS)
            </a>
            .
		</p>
	</li>
</ul>
<h2
	id="video-decoding" >
    Video Decoding
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2023/05/vulkan-video-decoding/" 
				class="external-link" 
				target="_blank" >
                Video Decoding - Wicked Engine
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="spir-v" >
    SPIR-V
</h2>
<ul>
	<li>
		<p>
			<em>
                Standard Portable Intermediate Representation V
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/what_is_spirv.html" 
				class="external-link" 
				target="_blank" >
                SPIR-V
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Vulkan‚Äôs official shader format (portable, efficient).
		</p>
	</li>
	<li>
		<p>
            SPIR-V is a binary format.
		</p>
	</li>
	<li>
		<p>
            Works with Metal via MoltenVK.
		</p>
	</li>
</ul>
<h5
	id="compiling" >
    Compiling
</h5>
<ul>
	<li>
		<p>
            You can write GLSL or HLSL and compile to SPIR-V.
		</p>
		<ul>
			<li>
				<p>
                    GLSL to SPIR-V:
				</p>
				<ul>
					<li>
						<p>
                            glslangValidator (from Khronos)
						</p>
					</li>
				</ul>
<pre><code class="language-sh" data-lang="sh"># Compile GLSL ‚Üí SPIR-V (Vulkan)
glslangValidator -V vertex_shader.vert -o vert.spv
glslangValidator -V fragment_shader.frag -o frag.spv
</code></pre>
			</li>
			<li>
				<p>
                    HLSL to SPIR-V:
				</p>
				<ul>
					<li>
						<p>
                            DXC (DirectX Shader Compiler)
						</p>
					</li>
				</ul>
<pre><code class="language-sh" data-lang="sh">dxc -T vs_6_0 -E VSMain -spirv shader.hlsl -Fo vert.spv
</code></pre>
				<ul>
					<li>
						<p>
                            Requires HLSL shaders with Vulkan-compatible semantics.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Convert SPIR-V to other formats:
				</p>
				<ul>
					<li>
						<p>
                            SPIRV-Cross (converts HLSL to GLSL/SPIR-V)
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Compiling shaders on the commandline is one of the most straightforward options and it's the one that we'll use in this tutorial, but it's also possible to compile shaders directly from your own code.
		</p>
		<ul>
			<li>
				<p>
                    The Vulkan SDK includes 
					<a
						href="https://github.com/google/shaderc" 
						class="external-link" 
						target="_blank" >
                        libshaderc
					</a>
                    , which is a library to compile GLSL code to SPIR-V from within your program.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="advantages" >
    Advantages
</h5>
<ul>
	<li>
		<p>
            The advantage of using a bytecode format is that the compilers written by GPU vendors to turn shader code into native code are significantly less complex. The past has shown that with human-readable syntax like GLSL, some GPU vendors were rather flexible with their interpretation of the standard. If you happen to write non-trivial shaders with a GPU from one of these vendors, then you‚Äôd risk another vendor‚Äôs drivers rejecting your code due to syntax errors, or worse, your shader running differently because of compiler bugs. With a straightforward bytecode format like SPIR-V that will hopefully be avoided.
		</p>
	</li>
</ul>
<h3
	id="tooling" >
    Tooling
</h3>
<h5
	id="spirv-cross" >
    spirv-cross
</h5>
<ul>
	<li>
		<p>
			<strong>
                Cross-compilation
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Converts SPIR-V shader binaries into high-level shading languages:
				</p>
				<ul>
					<li>
						<p>
                            GLSL (various versions)
						</p>
					</li>
					<li>
						<p>
                            HLSL
						</p>
					</li>
					<li>
						<p>
                            MSL (Metal Shading Language for Apple platforms)
						</p>
					</li>
					<li>
						<p>
                            WGSL (WebGPU shading language)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This lets you write shaders once (e.g. in GLSL or HLSL), compile to SPIR-V, then regenerate source for other backends.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Reflection
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Inspects SPIR-V binaries and reports metadata about:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor sets and bindings
						</p>
					</li>
					<li>
						<p>
                            Push constants
						</p>
					</li>
					<li>
						<p>
                            Vertex input/output attributes
						</p>
					</li>
					<li>
						<p>
                            Specialization constants
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    With the 
                    <code>--reflect</code>
                    &nbsp;flag, it outputs this data as 
					<strong>
                        JSON
					</strong>
                    , making it easy to drive engine code-generation or runtime Vulkan setup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>spirv-cross scene_vert.spv --reflect &gt; scene_vert.json</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="web" >
    Web
</h2>
<ul>
	<li>
		<p>
            No Vulkan support in browsers; you must port to WebGPU or use translation layers.
		</p>
	</li>
	<li>
		<p>
            <a href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html">
            WebAssembly - WASM
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="webgpu-wgpu" >
    WebGPU (wgpu)
</h3>
<ul>
	<li>
		<p>
            WebGPU is a cross-platform graphics API, aiming to unify GPU access across:
		</p>
		<ul>
			<li>
				<p>
                    Browsers (via native support)
				</p>
			</li>
			<li>
				<p>
                    Native apps (via libraries like wgpu, Dawn, etc.)
				</p>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Other Engines/Other Engines.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-10-21 .&nbsp;&nbsp;2025-12-13 üöÄ
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#starting" >
                            Starting
						</a>
						<ul>
							<li>
								<a
									href="#compatibility" >
                                    Compatibility
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#tutorials" >
                            Tutorials
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#samples" >
                            Samples
						</a>
						<ul>
							<li>
								<a
									href="#api" >
                                    API
								</a>
							</li>
							<li>
								<a
									href="#extensions" >
                                    Extensions
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#core" >
                            Core
						</a>
						<ul>
							<li>
								<a
									href="#instance-extensions" >
                                    Instance / Extensions
								</a>
							</li>
							<li>
								<a
									href="#debugging" >
                                    Debugging
								</a>
							</li>
							<li>
								<a
									href="#window-surface-glfw" >
                                    Window / Surface / GLFW
								</a>
							</li>
							<li>
								<a
									href="#physical-device-logical-device" >
                                    Physical Device / Logical Device
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#render-loop" >
                            Render Loop
						</a>
						<ul>
							<li>
								<a
									href="#swapchain" >
                                    Swapchain
								</a>
							</li>
							<li>
								<a
									href="#swapchain-recreation" >
                                    Swapchain Recreation
								</a>
							</li>
							<li>
								<a
									href="#frames-in-flight" >
                                    Frames In-Flight
								</a>
							</li>
							<li>
								<a
									href="#acquire-next-image" >
                                    Acquire Next Image
								</a>
							</li>
							<li>
								<a
									href="#render-targets" >
                                    Render Targets
								</a>
							</li>
							<li>
								<a
									href="#dynamic-rendering" >
                                    Dynamic Rendering
								</a>
							</li>
							<li>
								<a
									href="#drawing-commands" >
                                    Drawing Commands
								</a>
							</li>
							<li>
								<a
									href="#multithreading-rendering" >
                                    <s>Multithreading Rendering</s>
								</a>
							</li>
							<li>
								<a
									href="#render-passes-and-framebuffers" >
                                    <s>Render Passes and Framebuffers</s>
								</a>
							</li>
							<li>
								<a
									href="#submit" >
                                    Submit
								</a>
							</li>
							<li>
								<a
									href="#presentation" >
                                    Presentation
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#synchronization-and-cache-control" >
                            Synchronization and Cache Control
						</a>
						<ul>
							<li>
								<a
									href="#queues" >
                                    Queues
								</a>
							</li>
							<li>
								<a
									href="#blocking-operations" >
                                    Blocking Operations
								</a>
							</li>
							<li>
								<a
									href="#examples" >
                                    Examples
								</a>
							</li>
							<li>
								<a
									href="#execution-dependencies-memory-dependencies-memory-model" >
                                    Execution Dependencies, Memory Dependencies, Memory Model
								</a>
							</li>
							<li>
								<a
									href="#execution-stages" >
                                    Execution Stages
								</a>
							</li>
							<li>
								<a
									href="#memory-access" >
                                    Memory Access
								</a>
							</li>
							<li>
								<a
									href="#pipeline-barriers" >
                                    Pipeline Barriers
								</a>
							</li>
							<li>
								<a
									href="#events-quotsplit-barriersquot" >
                                    Events / &quot;Split Barriers&quot;
								</a>
							</li>
							<li>
								<a
									href="#semaphores-and-fences" >
                                    Semaphores and Fences
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#command-buffers" >
                            Command Buffers
						</a>
						<ul>
							<li>
								<a
									href="#command-pools" >
                                    Command Pools
								</a>
							</li>
							<li>
								<a
									href="#command-buffer" >
                                    Command Buffer
								</a>
							</li>
							<li>
								<a
									href="#command-buffer-recording" >
                                    Command Buffer Recording
								</a>
							</li>
							<li>
								<a
									href="#pre-recording" >
                                    Pre-recording
								</a>
							</li>
							<li>
								<a
									href="#multi-threading-recording" >
                                    Multi-threading Recording
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#pipelines" >
                            Pipelines
						</a>
						<ul>
							<li>
								<a
									href="#mesh-shaders" >
                                    Mesh Shaders
								</a>
							</li>
							<li>
								<a
									href="#cluster-culling-shader" >
                                    Cluster Culling Shader
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#graphics-pipeline" >
                            Graphics Pipeline
						</a>
						<ul>
							<li>
								<a
									href="#shader-compilation" >
                                    Shader Compilation
								</a>
							</li>
							<li>
								<a
									href="#input-assembly" >
                                    Input Assembly
								</a>
							</li>
							<li>
								<a
									href="#vertex-shader" >
                                    Vertex Shader
								</a>
							</li>
							<li>
								<a
									href="#tessellation-shader" >
                                    Tessellation Shader
								</a>
							</li>
							<li>
								<a
									href="#geometry-shader" >
                                    Geometry Shader
								</a>
							</li>
							<li>
								<a
									href="#rasterization" >
                                    Rasterization
								</a>
							</li>
							<li>
								<a
									href="#fragment-operations" >
                                    Fragment Operations
								</a>
							</li>
							<li>
								<a
									href="#fragment-shader" >
                                    Fragment Shader
								</a>
							</li>
							<li>
								<a
									href="#color-blending" >
                                    Color Blending
								</a>
							</li>
							<li>
								<a
									href="#creation" >
                                    Creation
								</a>
							</li>
							<li>
								<a
									href="#managing-pipelines-and-reducing-overhead" >
                                    Managing Pipelines and Reducing overhead
								</a>
							</li>
							<li>
								<a
									href="#optimizations" >
                                    Optimizations
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#strongsupport-strong" >
                            <strong>Support</strong>:
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#compute-pipeline" >
                            Compute Pipeline
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#resources" >
                            Resources
						</a>
						<ul>
							<li>
								<a
									href="#buffers" >
                                    Buffers
								</a>
							</li>
							<li>
								<a
									href="#images" >
                                    Images
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#depth" >
                            Depth
						</a>
						<ul>
							<li>
								<a
									href="#depth-tests" >
                                    Depth Tests
								</a>
							</li>
							<li>
								<a
									href="#depth-attachment" >
                                    Depth Attachment
								</a>
							</li>
							<li>
								<a
									href="#depth-image" >
                                    Depth Image
								</a>
							</li>
							<li>
								<a
									href="#normal-reconstruction-from-depth" >
                                    Normal Reconstruction from Depth
								</a>
							</li>
							<li>
								<a
									href="#stencil" >
                                    Stencil
								</a>
							</li>
							<li>
								<a
									href="#stencil-attachment" >
                                    Stencil Attachment
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#mapping-data-to-shaders" >
                            Mapping Data to Shaders
						</a>
						<ul>
							<li>
								<a
									href="#shader-alignment" >
                                    Shader Alignment
								</a>
							</li>
							<li>
								<a
									href="#comparisons" >
                                    Comparisons
								</a>
							</li>
							<li>
								<a
									href="#input-attributes" >
                                    Input Attributes
								</a>
							</li>
							<li>
								<a
									href="#push-constants" >
                                    Push Constants
								</a>
							</li>
							<li>
								<a
									href="#descriptors-sets" >
                                    Descriptors Sets
								</a>
							</li>
							<li>
								<a
									href="#specialization-constants" >
                                    Specialization Constants
								</a>
							</li>
							<li>
								<a
									href="#physical-storage-buffer-codekhr_buffer_device_address-code" >
                                    Physical Storage Buffer (<code>KHR_buffer_device_address</code>)
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory-allocation" >
                            Memory Allocation
						</a>
						<ul>
							<li>
								<a
									href="#info" >
                                    Info
								</a>
							</li>
							<li>
								<a
									href="#arenas" >
                                    Arenas
								</a>
							</li>
							<li>
								<a
									href="#host-memory" >
                                    Host Memory
								</a>
							</li>
							<li>
								<a
									href="#device-memory" >
                                    Device Memory
								</a>
							</li>
							<li>
								<a
									href="#tracking-gpu-memory" >
                                    Tracking GPU Memory
								</a>
							</li>
							<li>
								<a
									href="#vulkan-memory-allocator-vma" >
                                    <s>Vulkan Memory Allocator (VMA)</s>
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#hdr-support" >
                            HDR Support
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#profiling" >
                            Profiling
						</a>
						<ul>
							<li>
								<a
									href="#support" >
                                    Support
								</a>
							</li>
							<li>
								<a
									href="#query-pool" >
                                    Query Pool
								</a>
							</li>
							<li>
								<a
									href="#writing" >
                                    Writing
								</a>
							</li>
							<li>
								<a
									href="#reading" >
                                    Reading
								</a>
							</li>
							<li>
								<a
									href="#occlusion-queries" >
                                    Occlusion Queries
								</a>
							</li>
							<li>
								<a
									href="#pipeline-statistics-queries" >
                                    Pipeline Statistics Queries
								</a>
							</li>
							<li>
								<a
									href="#performance-queries" >
                                    Performance Queries
								</a>
							</li>
							<li>
								<a
									href="#mesh-shaders-queries" >
                                    Mesh Shaders Queries
								</a>
							</li>
							<li>
								<a
									href="#result-status-queries" >
                                    Result Status Queries
								</a>
							</li>
							<li>
								<a
									href="#other-queries" >
                                    Other Queries
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#mobile" >
                            Mobile
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#vr" >
                            VR
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#video-decoding" >
                            Video Decoding
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#spir-v" >
                            SPIR-V
						</a>
						<ul>
							<li>
								<a
									href="#tooling" >
                                    Tooling
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#web" >
                            Web
						</a>
						<ul>
							<li>
								<a
									href="#webgpu-wgpu" >
                                    WebGPU (wgpu)
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.24731.js" >
		</script>
	</body>
</html>
