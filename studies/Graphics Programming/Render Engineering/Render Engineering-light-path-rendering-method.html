<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.26909.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
>
					<summary>
                        Vulkan
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                Samples
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                Core
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                Render Loop
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                Synchronization and Cache Control
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                Command Buffers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                Pipelines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                Compute Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                Resources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                Depth
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                Mapping Data to Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                Memory Allocation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                HDR Support
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                Profiling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                Mobile
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                VR
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                Video Decoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                SPIR-V
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                Web
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Render Engineering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                Graphics APIs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                Shader Languages
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                Choosing the Space to compute Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                BSDF (Bidirectional Scattering Distribution Function)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                Material
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                Direct Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                Shadows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                Skybox / Skydome
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                Transparency
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                Global Illumination / Indirect Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                Global Illumination - Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                Global Illumination - Discarded Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                Lightmaps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                Post-Processing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                Anti-Aliasing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                Light Path / Rendering Method
							</a>
							<ul>
								<li>
									<a
										href="#forward-rendering" >
                                        Forward Rendering
									</a>
									<ul>
										<li>
											<a
												href="#forward" >
                                                Forward
											</a>
										</li>
										<li>
											<a
												href="#tiled-forward-shading" >
                                                Tiled Forward Shading
											</a>
										</li>
										<li>
											<a
												href="#clustered-forward-shading" >
                                                Clustered Forward Shading
											</a>
										</li>
									</ul>
								</li>
								<li>
									<a
										href="#deferred-shading" >
                                        Deferred Shading
									</a>
									<ul>
										<li>
											<a
												href="#deferred" >
                                                Deferred
											</a>
										</li>
										<li>
											<a
												href="#tiled-deferred" >
                                                Tiled Deferred
											</a>
										</li>
										<li>
											<a
												href="#clustered-deferred" >
                                                Clustered Deferred
											</a>
										</li>
										<li>
											<a
												href="#adaptive-deferred-shading" >
                                                Adaptive Deferred Shading
											</a>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                Optimization Techniques
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Graphics and Shaders
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                Sources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                Math, Linear Algebra
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                Spaces, Transformations and Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                Common Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                Shaders
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GLSL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                Storage Qualifiers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                Layout Qualifiers
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GPU
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                Execution Building Blocks
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                Specialized units &amp; instructions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                Cache
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                GPU VA (Virtual Address)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                Tiled-GPUs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Slang
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang-slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Font Rendering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                Text Processing Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                Formats
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                Libs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                Fonts
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        OpenGL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Light Path / Rendering Method
						</h1>
						<p>
							<time
								datetime="2025-07-03" >
                                üïí Created: 2025-07-03
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<ul>
	<li>
		<p>
            <img src="assets/image_20250924121245.png" width="600" >
            .
		</p>
		<ul>
			<li>
				<p>
                    From the Real-Time Rendering 4th Edition.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922203446.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    By Ola Olsson.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="forward-rendering" >
    Forward Rendering
</h3>
<h4
	id="forward" >
    Forward
</h4>
<ul>
	<li>
		<p>
            Geometry is shaded as it is drawn. For each triangle/pixel, the fragment shader loops over the lights that affect that object (or uses some per-object light set).
		</p>
	</li>
	<li>
		<p>
            Lighting for a fragment is computed when that fragment is shaded, using the set of lights you feed to that draw call/shader.
		</p>
	</li>
	<li>
		<p>
            Shading and output to the final render target happen in one pass.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909115709.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Overdraw happens, as the back triangle is 
					<em>
                        shaded
					</em>
                    , but the front triangle overwrites the color on the screen.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909082543.png" width="350" >
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Multipass forward rendering&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909083021.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909082949.png" width="350" >
            .
		</p>
	</li>
</ul>
<h4
	id="tiled-forward-shading" >
    Tiled Forward Shading
</h4>
<ul>
	<li>
		<p>
            Tiled shading can be applied to both forward and deferred rendering methods.
		</p>
	</li>
	<li>
		<p>
            The idea is to split the screen into a grid of tiles and, for each tile, find the list of lights that affect the pixels within that tile.
		</p>
	</li>
	<li>
		<p>
            This has the advantage of reducing overdraw (in deferred rendering) and shading computations of large objects (in forward rendering).
		</p>
	</li>
	<li>
		<p>
            However, this technique suffers from depth discontinuity issues that can lead to large amounts of extraneous work.
		</p>
	</li>
</ul>
<h5
	id="gathering-the-lights" >
    Gathering the lights
</h5>
<ul>
	<li>
		<p>
            We now need to access all relevant lights for each pixel sequentially.
		</p>
	</li>
	<li>
		<p>
            Just using a global list of lights is, of course, terribly inefficient.
		</p>
	</li>
	<li>
		<p>
            On the other hand, creating lists of lights for each pixel individually is both slow and requires lots of storage.
		</p>
	</li>
	<li>
		<p>
            Tiled shading strikes a balance, where we create lists for tiles of pixels.
		</p>
	</li>
	<li>
		<p>
            The list must be conservative, storing all lights that may affect any sample within the tile.
		</p>
	</li>
	<li>
		<p>
            So we trade some compute performance for bandwidth, which, as we have seen, is a good tradeoff on modern GPUs.
		</p>
	</li>
	<li>
		<p>
            Each tile contains a single list of all the lights that might influence any of the pixels inside.
		</p>
	</li>
	<li>
		<p>
            This list is shared between the pixels, so overhead for list maintenance and fetching is low.
		</p>
	</li>
</ul>
<h5
	id="constructing-the-list" >
    Constructing the list
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250922175337.png" width="350" >
            <img src="assets/image_20250922175354.png" width="350" >
            <img src="assets/image_20250922175450.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            For each light, establish the screen space bounding box, illustrated for the green light.
		</p>
	</li>
	<li>
		<p>
            Then add the index of the light to all overlapped tiles.
		</p>
	</li>
	<li>
		<p>
            Then repeat this process for all remaining lights.
		</p>
	</li>
	<li>
		<p>
            The illustration only shows the counts, so you need to imagine the lists being built as well.
		</p>
	</li>
	<li>
		<p>
            In practice, we‚Äôd also do a conservative per-tile min/max depth test to cull away lights occupying empty space.
		</p>
	</li>
</ul>
<h5
	id="vertex-shader" >
    Vertex Shader
</h5>
<ul>
	<li>
		<p>
            Vertex Output:
		</p>
<pre><code class="language-glsl" data-lang="glsl">struct VertexShaderOutput
{
&nbsp;&nbsp;&nbsp;&nbsp;float3 positionVS&nbsp;&nbsp; : TEXCOORD0;&nbsp;&nbsp;&nbsp;&nbsp;// View space position.
&nbsp;&nbsp;&nbsp;&nbsp;float2 texCoord&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD1;&nbsp;&nbsp;&nbsp;&nbsp;// Texture coordinate
&nbsp;&nbsp;&nbsp;&nbsp;float3 tangentVS&nbsp;&nbsp;&nbsp;&nbsp;: TANGENT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// View space tangent.
&nbsp;&nbsp;&nbsp;&nbsp;float3 binormalVS&nbsp;&nbsp; : BINORMAL;&nbsp;&nbsp;&nbsp;&nbsp; // View space binormal.
&nbsp;&nbsp;&nbsp;&nbsp;float3 normalVS&nbsp;&nbsp;&nbsp;&nbsp; : NORMAL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // View space normal.
&nbsp;&nbsp;&nbsp;&nbsp;float4 position&nbsp;&nbsp;&nbsp;&nbsp; : SV_POSITION;&nbsp;&nbsp;// Clip space position.
};
</code></pre>
		<ul>
			<li>
				<p>
                    I chose to do all of the lighting in view space, as opposed to world space, because it is easier to work in view space coordinates when implementing deferred shading and forward+ rendering techniques.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>SV_POSITION</code>
                    &nbsp;semantic is applied to the output value from the vertex shader to specify that the value is used as the clip space position, but this semantic can also be applied to an input variable of a pixel shader. When 
                    <code>SV_POSITION</code>
                    &nbsp;is used as an input semantic to a pixel shader, the value is the position of the pixel in screen space. In both the deferred shading and the forward+ shaders, I will use this semantic to get the screen space position of the current pixel.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">VertexShaderOutput VS_main( AppData IN )
{
&nbsp;&nbsp;&nbsp;&nbsp;VertexShaderOutput OUT;

&nbsp;&nbsp;&nbsp;&nbsp;OUT.position = mul( ModelViewProjection, float4( IN.position, 1.0f ) );

&nbsp;&nbsp;&nbsp;&nbsp;OUT.positionVS = mul( ModelView, float4( IN.position, 1.0f ) ).xyz;
&nbsp;&nbsp;&nbsp;&nbsp;OUT.tangentVS = mul( ( float3x3 )ModelView, IN.tangent );
&nbsp;&nbsp;&nbsp;&nbsp;OUT.binormalVS = mul( ( float3x3 )ModelView, IN.binormal );
&nbsp;&nbsp;&nbsp;&nbsp;OUT.normalVS = mul( ( float3x3 )ModelView, IN.normal );

&nbsp;&nbsp;&nbsp;&nbsp;OUT.texCoord = IN.texCoord;

&nbsp;&nbsp;&nbsp;&nbsp;return OUT;
}
</code></pre>
		<ul>
			<li>
				<p>
                    You will notice that I am pre-multiplying the input vectors by the matrices. This indicates that the matrices are stored in column-major order by default.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fragment-shader-inputs" >
    Fragment Shader Inputs
</h5>
<ul>
	<li>
		<p>
			<strong>
                Material
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Since some material properties can also have an associated texture (for example, diffuse textures, specular textures, or normal textures), we will also use the material to indicate if those textures are present on the object.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">struct Material
{
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp;GlobalAmbient;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp;AmbientColor;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp;EmissiveColor;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp;DiffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp;SpecularColor;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;// Reflective value.
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp;Reflectance;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp; Opacity;
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp; SpecularPower;
&nbsp;&nbsp;&nbsp;&nbsp;// For transparent materials, IOR &gt; 0.
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp; IndexOfRefraction;
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasAmbientTexture;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasEmissiveTexture;
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasDiffuseTexture;
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasSpecularTexture;
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasSpecularPowerTexture;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasNormalTexture;
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasBumpTexture;
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;HasOpacityTexture;
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp; BumpIntensity;
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp; SpecularScale;
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp; AlphaThreshold;
&nbsp;&nbsp;&nbsp;&nbsp;float2&nbsp;&nbsp;Padding;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------- ( 16 bytes )
};&nbsp;&nbsp;//--------------------------- ( 16 * 10 = 160 bytes )
</code></pre>
		<ul>
			<li>
				<p>
                    <code>GlobalAmbient</code>
				</p>
				<ul>
					<li>
						<p>
                            Describes the ambient contribution applied to all objects in the scene globally. Technically, this variable should be a global variable (not specific to a single object), but since there is only a single material at a time in the pixel shader, it‚Äôs fine to put it here.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Opacity</code>
				</p>
				<ul>
					<li>
						<p>
                            Determines the total opacity of an object. This value can make objects appear transparent. This property is used to render semi-transparent objects in the transparent pass. If the opacity value is less than one (1 being fully opaque and 0 being fully transparent), the object is considered transparent and rendered in the transparent pass instead of the opaque pass.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SpecularPower</code>
				</p>
				<ul>
					<li>
						<p>
                            Determines how shiny the object appears.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>IndexOfRefraction</code>
				</p>
				<ul>
					<li>
						<p>
                            Can be applied to objects that should refract light through them. Since refraction requires environment mapping techniques not implemented in this experiment, this variable will not be used here.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>BumpIntensity</code>
				</p>
				<ul>
					<li>
						<p>
                            If a model has a bump map, the material‚Äôs 
                            <code>HasBumpTexture</code>
                            &nbsp;property is set to 
                            <code>true</code>
                            &nbsp;and the model is bump-mapped instead of normal-mapped.
						</p>
					</li>
					<li>
						<p>
                            Normal and bump maps are mutually exclusive, so they can reuse the same texture slot assignment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SpecularScale</code>
				</p>
				<ul>
					<li>
						<p>
                            Scales the specular power value read from a specular power texture. Since textures usually store values as unsigned normalized values, when sampling from the texture the value is read as a floating-point value in the range of 
                            <code>[0..1]</code>
                            . A specular power of 1.0 doesn‚Äôt make much sense, so the specular power value read from the texture will be scaled by 
                            <code>SpecularScale</code>
                            &nbsp;before being used for the final lighting computation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>AlphaThreshold</code>
				</p>
				<ul>
					<li>
						<p>
                            Can be used to discard pixels whose opacity is below a certain value using the ‚Äúdiscard‚Äù command in the pixel shader. This is useful for ‚Äúcut-out‚Äù materials where the object does not need alpha blending but should have holes (for example, a chain-link fence).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The material properties are passed to the pixel shader using a constant buffer.
		</p>
<pre><code class="language-glsl" data-lang="glsl">cbuffer Material : register( b2 )
{
&nbsp;&nbsp;&nbsp;&nbsp;Material Mat;
};

Texture2D AmbientTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: register( t0 );
Texture2D EmissiveTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t1 );
Texture2D DiffuseTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: register( t2 );
Texture2D SpecularTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t3 );
Texture2D SpecularPowerTexture&nbsp;&nbsp;: register( t4 );
Texture2D NormalTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t5 );
Texture2D BumpTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t6 );
Texture2D OpacityTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: register( t7 );&nbsp;&nbsp; 
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Lights
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">StructuredBuffer&lt;uint&gt; LightIndexList: register(&nbsp;&nbsp;t9 );
Texture2D&lt;uint2&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LightGrid:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register( t10 );

struct Light
{
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* Position for point and spot lights (World space).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp; PositionWS;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* Direction for spot and directional lights (World space).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp; DirectionWS;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* Position for point and spot lights (View space).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp; PositionVS;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* Direction for spot and directional lights (View space).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp; DirectionVS;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* Color of the light. Diffuse and specular colors are not separated.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;float4&nbsp;&nbsp; Color;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* The half angle of the spotlight cone.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;&nbsp;&nbsp;SpotlightAngle;
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* The range of the light.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;&nbsp;&nbsp;Range;

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp; * The intensity of the light.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;&nbsp;&nbsp;Intensity;

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* Disable or enable the light.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;Enabled;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 bytes )

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp; * Is the light selected in the editor?
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;Selected;

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;* The type of the light.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;&nbsp;&nbsp;&nbsp;Type;
&nbsp;&nbsp;&nbsp;&nbsp;float2&nbsp;&nbsp;Padding;
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp;//--------------------------------------------------------------( 16 * 7 = 112 bytes )
};
</code></pre>
		<ul>
			<li>
				<p>
                    <code>SpotlightAngle</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the half-angle of the spotlight cone expressed in degrees. Working in degrees is more intuitive than in radians. The spotlight angle is converted to radians in the shader when computing the cosine of the angle between the spotlight direction and the light vector.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Range</code>
				</p>
				<ul>
					<li>
						<p>
                            For point lights, the range is the radius of the sphere that represents the light; for spotlights, it‚Äôs the length of the cone that represents the light. Directional lights don‚Äôt use range because they are considered infinitely far away, pointing in the same direction everywhere.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Intensity</code>
				</p>
				<ul>
					<li>
						<p>
                            Modulates the computed light contribution. By default, this value is 1 but can make some lights brighter or dimmer than others.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Enabled</code>
				</p>
				<ul>
					<li>
						<p>
                            Lights with 
                            <code>Enabled</code>
                            &nbsp;set to 
                            <code>false</code>
                            &nbsp;are skipped in the shader.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Selected</code>
				</p>
				<ul>
					<li>
						<p>
                            When a light is selected in the scene, its visual representation appears darker (less transparent) to indicate selection.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Type</code>
				</p>
				<ul>
					<li>
						<p>
                            Can have one of the following values:
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">#define POINT_LIGHT 0
#define SPOT_LIGHT 1
#define DIRECTIONAL_LIGHT 2
</code></pre>
			</li>
			<li>
				<p>
                    Spot lights, point lights and directional lights are not separated into different structs and all of the properties necessary to define any of those light types are stored in a single struct.
				</p>
			</li>
			<li>
				<p>
                    The Position variable only applies to point and spot lights while the Direction variable only applies to spot and directional lights.
				</p>
			</li>
			<li>
				<p>
                    I store both world space and view space position and direction vectors because I find it easier to work in world space in the application then convert the world space vectors to view space before uploading the lights array to the GPU.
				</p>
			</li>
			<li>
				<p>
                    This way I do not need to maintain multiple light lists at the cost of additional space that is required on the GPU. But even 10,000 lights only require 1.12 MB on the GPU so I figured this was a reasonable sacrifice. But minimizing the size of the light structs could have a positive impact on caching on the GPU and improve rendering performance.
				</p>
			</li>
			<li>
				<p>
                    I chose not to separate the diffuse and specular color contributions because it is rare that these values differ.
				</p>
			</li>
			<li>
				<p>
                    The lights array is accessed through a 
					<strong>
                        StructuredBuffer
					</strong>
                    . Most lighting shader implementations will use a constant buffer to store the lights array but constant buffers are limited to 64 KB in size which means that it would be limited to about 570 lights before running out of constant memory on the GPU. Structured buffers are stored in texture memory which is limited to the amount of texture memory available on the GPU (usually in the GB range on desktop GPUs). Texture memory is also very fast on most GPUs so storing the lights in a structured buffer did not impose a performance impact. In fact, on my particular GPU (NVIDIA GeForce GTX 680) I noticed a considerable performance improvement when I moved the lights array to a structure buffer.
				</p>
<pre><code class="language-glsl" data-lang="glsl">StructuredBuffer&lt;Light&gt; Lights : register( t8 );
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fragment-shader" >
    Fragment Shader
</h5>
<pre><code class="language-glsl" data-lang="glsl">
float3 ExpandNormal( float3 n )
{
&nbsp;&nbsp;&nbsp;&nbsp;return n * 2.0f - 1.0f;
}

float4 DoNormalMapping( float3x3 TBN, Texture2D tex, sampler s, float2 uv )
{
&nbsp;&nbsp;&nbsp;&nbsp;float3 normal = tex.Sample( s, uv ).xyz;
&nbsp;&nbsp;&nbsp;&nbsp;normal = ExpandNormal( normal );

&nbsp;&nbsp;&nbsp;&nbsp;// Transform normal from tangent space to view space.
&nbsp;&nbsp;&nbsp;&nbsp;normal = mul( normal, TBN );
&nbsp;&nbsp;&nbsp;&nbsp;return normalize( float4( normal, 0 ) );
}

float4 DoBumpMapping( float3x3 TBN, Texture2D tex, sampler s, float2 uv, float bumpScale )
{
&nbsp;&nbsp;&nbsp;&nbsp;// Sample the heightmap at the current texture coordinate.
&nbsp;&nbsp;&nbsp;&nbsp;float height = tex.Sample( s, uv ).r * bumpScale;
&nbsp;&nbsp;&nbsp;&nbsp;// Sample the heightmap in the U texture coordinate direction.
&nbsp;&nbsp;&nbsp;&nbsp;float heightU = tex.Sample( s, uv, int2( 1, 0 ) ).r * bumpScale;
&nbsp;&nbsp;&nbsp;&nbsp;// Sample the heightmap in the V texture coordinate direction.
&nbsp;&nbsp;&nbsp;&nbsp;float heightV = tex.Sample( s, uv, int2( 0, 1 ) ).r * bumpScale;

&nbsp;&nbsp;&nbsp;&nbsp;float3 p = { 0, 0, height };
&nbsp;&nbsp;&nbsp;&nbsp;float3 pU = { 1, 0, heightU };
&nbsp;&nbsp;&nbsp;&nbsp;float3 pV = { 0, 1, heightV };

&nbsp;&nbsp;&nbsp;&nbsp;// normal = tangent x bitangent
&nbsp;&nbsp;&nbsp;&nbsp;float3 normal = cross( normalize(pU - p), normalize(pV - p) );

&nbsp;&nbsp;&nbsp;&nbsp;// Transform normal from tangent space to view space.
&nbsp;&nbsp;&nbsp;&nbsp;normal = mul( normal, TBN );

&nbsp;&nbsp;&nbsp;&nbsp;return float4( normal, 0 );
}

float4 DoDiffuse( Light light, float4 L, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;float NdotL = max( dot( N, L ), 0 );
&nbsp;&nbsp;&nbsp;&nbsp;return light.Color * NdotL;
}

float4 DoSpecular( Light light, Material material, float4 V, float4 L, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;float4 R = normalize( reflect( -L, N ) );
&nbsp;&nbsp;&nbsp;&nbsp;float RdotV = max( dot( R, V ), 0 );

&nbsp;&nbsp;&nbsp;&nbsp;return light.Color * pow( RdotV, material.SpecularPower );
}

// Compute the attenuation based on the range of the light.
float DoAttenuation( Light light, float d )
{
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0f - smoothstep( light.Range * 0.75f, light.Range, d );
}

LightingResult DoPointLight( Light light, Material mat, float4 V, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result;

&nbsp;&nbsp;&nbsp;&nbsp;float4 L = light.PositionVS - P;
&nbsp;&nbsp;&nbsp;&nbsp;float distance = length( L );
&nbsp;&nbsp;&nbsp;&nbsp;L = L / distance;

&nbsp;&nbsp;&nbsp;&nbsp;float attenuation = DoAttenuation( light, distance );

&nbsp;&nbsp;&nbsp;&nbsp;result.Diffuse = DoDiffuse( light, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attenuation * light.Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;result.Specular = DoSpecular( light, mat, V, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation * light.Intensity;

&nbsp;&nbsp;&nbsp;&nbsp;return result;
}


float DoSpotCone( Light light, float4 L )
{
&nbsp;&nbsp;&nbsp;&nbsp;// If the cosine angle of the light's direction 
&nbsp;&nbsp;&nbsp;&nbsp;// vector and the vector from the light source to the point being 
&nbsp;&nbsp;&nbsp;&nbsp;// shaded is less than minCos, then the spotlight contribution will be 0.
&nbsp;&nbsp;&nbsp;&nbsp;float minCos = cos( radians( light.SpotlightAngle ) );
&nbsp;&nbsp;&nbsp;&nbsp;// If the cosine angle of the light's direction vector
&nbsp;&nbsp;&nbsp;&nbsp;// and the vector from the light source to the point being shaded
&nbsp;&nbsp;&nbsp;&nbsp;// is greater than maxCos, then the spotlight contribution will be 1.
&nbsp;&nbsp;&nbsp;&nbsp;float maxCos = lerp( minCos, 1, 0.5f );
&nbsp;&nbsp;&nbsp;&nbsp;float cosAngle = dot( light.DirectionVS, -L );
&nbsp;&nbsp;&nbsp;&nbsp;// Blend between the minimum and maximum cosine angles.
&nbsp;&nbsp;&nbsp;&nbsp;return smoothstep( minCos, maxCos, cosAngle );
}

LightingResult DoSpotLight( Light light, Material mat, float4 V, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result;

&nbsp;&nbsp;&nbsp;&nbsp;float4 L = light.PositionVS - P;
&nbsp;&nbsp;&nbsp;&nbsp;float distance = length( L );
&nbsp;&nbsp;&nbsp;&nbsp;L = L / distance;

&nbsp;&nbsp;&nbsp;&nbsp;float attenuation = DoAttenuation( light, distance );
&nbsp;&nbsp;&nbsp;&nbsp;float spotIntensity = DoSpotCone( light, L );

&nbsp;&nbsp;&nbsp;&nbsp;result.Diffuse = DoDiffuse( light, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation * spotIntensity * light.Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;result.Specular = DoSpecular( light, mat, V, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation * spotIntensity * light.Intensity;

&nbsp;&nbsp;&nbsp;&nbsp;return result;
}

LightingResult DoDirectionalLight( Light light, Material mat, float4 V, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result;

&nbsp;&nbsp;&nbsp;&nbsp;float4 L = normalize( -light.DirectionVS );

&nbsp;&nbsp;&nbsp;&nbsp;result.Diffuse = DoDiffuse( light, L, N ) * light.Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;result.Specular = DoSpecular( light, mat, V, L, N ) * light.Intensity;

&nbsp;&nbsp;&nbsp;&nbsp;return result;
}


// This lighting result is returned by the 
// lighting functions for each light type.
struct LightingResult
{
&nbsp;&nbsp;&nbsp;&nbsp;float4 Diffuse;
&nbsp;&nbsp;&nbsp;&nbsp;float4 Specular;
};

LightingResult DoLighting( StructuredBuffer&lt;Light&gt; lights, Material mat, float4 eyePos, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;float4 V = normalize( eyePos - P );

&nbsp;&nbsp;&nbsp;&nbsp;LightingResult totalResult = (LightingResult)0;

&nbsp;&nbsp;&nbsp;&nbsp;for ( int i = 0; i &lt; NUM_LIGHTS; ++i )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result = (LightingResult)0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Skip lights that are not enabled.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !lights[i].Enabled ) continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Skip point and spot lights that are out of range of the point being shaded.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( lights[i].Type != DIRECTIONAL_LIGHT &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length( lights[i].PositionVS - P ) &gt; lights[i].Range ) continue;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( lights[i].Type )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case DIRECTIONAL_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoDirectionalLight( lights[i], mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case POINT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoPointLight( lights[i], mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case SPOT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoSpotLight( lights[i], mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalResult.Diffuse += result.Diffuse;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalResult.Specular += result.Specular;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return totalResult;
}


[earlydepthstencil]
float4 PS_main( VertexShaderOutput IN ) : SV_TARGET
{
&nbsp;&nbsp;&nbsp;&nbsp;// Everything is in view space.
&nbsp;&nbsp;&nbsp;&nbsp;float4 eyePos = { 0, 0, 0, 1 };
&nbsp;&nbsp;&nbsp;&nbsp;Material mat = Mat;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Diffuse
&nbsp;&nbsp;&nbsp;&nbsp;float4 diffuse = mat.DiffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasDiffuseTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 diffuseTex = DiffuseTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( diffuse.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= diffuseTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffuse = diffuseTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Opacity
&nbsp;&nbsp;&nbsp;&nbsp;float alpha = diffuse.a;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasOpacityTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the material has an opacity texture, use that to override the diffuse alpha.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alpha = OpacityTexture.Sample( LinearRepeatSampler, IN.texCoord ).r;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Ambient
&nbsp;&nbsp;&nbsp;&nbsp;float4 ambient = mat.AmbientColor;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasAmbientTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 ambientTex = AmbientTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( ambient.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ambient *= ambientTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ambient = ambientTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Combine the global ambient term.
&nbsp;&nbsp;&nbsp;&nbsp;ambient *= mat.GlobalAmbient;

&nbsp;&nbsp;&nbsp;&nbsp;// Emissive
&nbsp;&nbsp;&nbsp;&nbsp;float4 emissive = mat.EmissiveColor;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasEmissiveTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 emissiveTex = EmissiveTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( emissive.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emissive *= emissiveTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emissive = emissiveTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Specular
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasSpecularPowerTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mat.SpecularPower = SpecularPowerTexture.Sample( LinearRepeatSampler, IN.texCoord ).r \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* mat.SpecularScale;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Normal mapping
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasNormalTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For scenes with normal mapping, I don't have to invert the binormal.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float3x3 TBN = float3x3( normalize( IN.tangentVS ),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( IN.binormalVS ),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( IN.normalVS ) );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = DoNormalMapping( TBN, NormalTexture, LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Bump mapping
&nbsp;&nbsp;&nbsp;&nbsp;else if ( mat.HasBumpTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For most scenes using bump mapping, I have to invert the binormal.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float3x3 TBN = float3x3( normalize( IN.tangentVS ),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( -IN.binormalVS ), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( IN.normalVS ) );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = DoBumpMapping( TBN, BumpTexture, LinearRepeatSampler, IN.texCoord, mat.BumpIntensity );
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Just use the normal from the model.
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = normalize( float4( IN.normalVS, 0 ) );
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;float4 P = float4( IN.positionVS, 1 );



&nbsp;&nbsp;&nbsp;&nbsp;LightingResult lit = DoLighting( Lights, mat, eyePos, P, N );

&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= float4( lit.Diffuse.rgb, 1.0f ); // Discard the alpha value from the lighting calculations.

&nbsp;&nbsp;&nbsp;&nbsp;float4 specular = 0;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.SpecularPower &gt; 1.0f ) // If specular power is too low, don't use it.
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular = mat.SpecularColor;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasSpecularTexture )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 specularTex = SpecularTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( specular.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular *= specularTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular = specularTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular *= lit.Specular;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Get the index of the current pixel in the light grid.
&nbsp;&nbsp;&nbsp;&nbsp;uint2 tileIndex = uint2( floor(IN.position.xy / BLOCK_SIZE) );

&nbsp;&nbsp;&nbsp;&nbsp;// Get the start position and offset of the light in the light index list.
&nbsp;&nbsp;&nbsp;&nbsp;uint startOffset = LightGrid[tileIndex].x;
&nbsp;&nbsp;&nbsp;&nbsp;uint lightCount = LightGrid[tileIndex].y;

&nbsp;&nbsp;&nbsp;&nbsp;LightingResult lit = (LightingResult)0; // DoLighting( Lights, mat, eyePos, P, N );

&nbsp;&nbsp;&nbsp;&nbsp;for ( uint i = 0; i &lt; lightCount; i++ )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint lightIndex = LightIndexList[startOffset + i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Light light = Lights[lightIndex];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result = (LightingResult)0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( light.Type )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case DIRECTIONAL_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoDirectionalLight( light, mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case POINT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoPointLight( light, mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case SPOT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoSpotLight( light, mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lit.Diffuse += result.Diffuse;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lit.Specular += result.Specular;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= float4( lit.Diffuse.rgb, 1.0f ); // Discard the alpha value from the lighting calculations.
&nbsp;&nbsp;&nbsp;&nbsp;specular *= lit.Specular;

&nbsp;&nbsp;&nbsp;&nbsp;return float4( ( ambient + emissive + diffuse + specular ).rgb, alpha * mat.Opacity );
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                EarlyDepthStencil
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>[earlydepthstencil]</code>
                    &nbsp;attribute before the function indicates that the GPU should take advantage of early depth and stencil culling. This causes the depth/stencil tests to be performed before the pixel shader is executed. This attribute cannot be used on shaders that modify the pixel‚Äôs depth value by outputting a value using the 
                    <code>SV_Depth</code>
                    &nbsp;semantic. Since this pixel shader only outputs a color value using the 
                    <code>SV_TARGET</code>
                    &nbsp;semantic, it can take advantage of early depth/stencil testing to provide a performance improvement when a pixel is rejected. Most GPUs will perform early depth/stencil tests anyway even without this attribute, and adding this attribute to the pixel shader did not have a noticeable impact on performance, but I decided to keep the attribute anyway.
				</p>
			</li>
			<li>
				<p>
                    Since all lighting computations are performed in view space, the eye position (the camera position) is always (0, 0, 0).
				</p>
			</li>
			<li>
				<p>
                    This is a nice side effect of working in view space: the camera‚Äôs eye position 
					<strong>
                        does not
					</strong>
                    &nbsp;need to be passed as an additional parameter to the shader.
				</p>
				<ul>
					<li>
						<p>
                            Cool.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            First, we need to gather the material properties. If the material has textures associated with its various components, the textures will be sampled before the lighting is computed. After the material properties have been initialized, all the lights in the scene will be iterated, and the lighting contributions will be accumulated and modulated with the material properties to produce the final pixel color.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Comments
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Diffuse
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>any</code>
                            &nbsp;HLSL intrinsic function can be used to determine if any of the color components are non-zero.
						</p>
					</li>
					<li>
						<p>
                            If the material also has a diffuse texture associated with it, then the color from the diffuse texture will be blended with the material‚Äôs diffuse color. If the material‚Äôs diffuse color is black (0, 0, 0, 0), then the material‚Äôs diffuse color will simply be replaced by the color in the diffuse texture.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Opacity
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            By default, the fragment‚Äôs transparency value is determined by the alpha component of the diffuse color. If the material has an opacity texture associated with it, the red component of the opacity texture is used as the alpha value, overriding the alpha value in the diffuse texture. In most cases, opacity textures store only a single channel in the first component of the color returned from the 
							<strong>
                                Sample
							</strong>
                            &nbsp;method. To read from a single-channel texture, we must read from the red channel, not the alpha channel. The alpha channel of a single-channel texture will always be 1, so reading the alpha channel from the opacity map (which is most likely a single-channel texture) would not provide the required value.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lighting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The lighting calculations for the forward rendering technique are performed in the 
                    <code>DoLighting</code>
                    &nbsp;function. This function accepts the following arguments:
				</p>
				<ul>
					<li>
						<p>
                            <code>lights</code>
                            : The lights array (as a structured buffer)
						</p>
					</li>
					<li>
						<p>
                            <code>mat</code>
                            : The material properties that were just computed
						</p>
					</li>
					<li>
						<p>
                            <code>eyePos</code>
                            : The position of the camera in view space (which is always (0, 0, 0))
						</p>
					</li>
					<li>
						<p>
                            <code>P</code>
                            : The position of the point being shaded in view space
						</p>
					</li>
					<li>
						<p>
                            <code>N</code>
                            : The normal of the point being shaded in view space
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The view vector (
                    <code>V</code>
                    ) is computed from the eye position and the position of the shaded pixel in view space.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923140023.png" width="250" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="etc" >
    etc
</h5>
<ul>
	<li>
		<p>
			<strong>
                Wicked Engine
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    All the lights inside the camera are binned to small 8√ó8 pixel tiles on the screen. Each tile will thus have a minimal list of lights that should be iterated by every pixel inside when lighting up the surface.
				</p>
			</li>
			<li>
				<p>
                    The main optimizations I‚Äôve used for some years now is the ‚Äú2.5D culling‚Äù and the ‚Äúflat bit arrays‚Äù methods, which I really liked.
				</p>
			</li>
			<li>
				<p>
                    I rearranged the light loops so they always operate strictly on one light type (directional/point/spot), which gave some minor performance improvement. So instead of one big loop that checks the type of light and calls the appropriate function, now there are 3 loops for each type. This also allowed to avoid all the tile checking for directional lights, because they are always affecting the full screen, that specific loop is just going over all of them which simplifies the shader further.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Visibility Buffer
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The main twist to the forward rendering is the inclusion of a secondary ‚Äúvisibility buffer‚Äù, to aid with effects that would better fit into a deferred renderer.
						</p>
					</li>
					<li>
						<p>
                            I always wanted to support all the post processing that deferred rendering supports, but normally forward rendering doesn‚Äôt write any G-Buffer textures to allow this. Some years ago I used a thin G-buffer for this written by the depth prepass.
						</p>
					</li>
					<li>
						<p>
                            Now the depth-prepass for the main camera writes a UINT texture that contains primitive IDs, this is called the visibility buffer.
						</p>
					</li>
					<li>
						<p>
                            This is some overhead compared to depth-only pass, but less than writing a G-buffer with multiple textures.
						</p>
					</li>
					<li>
						<p>
                            From this primitiveID texture any shader can get per-pixel information about any surface properties: depth, normal, roughness, velocity, etc.
						</p>
					</li>
					<li>
						<p>
                            The nice thing about it that we can get this on the async compute queue too, and that‚Äôs exactly what happens.
						</p>
					</li>
					<li>
						<p>
                            After the visibility buffer is completed in the prepass, the graphics queue continues rendering shadow maps, planar reflections and updating environment probes, while the compute queue starts working independently on rendering a G-buffer from the visibility buffer, but only if some effects are turned on that would require this:
						</p>
						<ul>
							<li>
								<p>
                                    depth buffer: it is always created from the visibility buffer. The normal depth buffer is always kept in depth write state, it‚Äôs never used as a sampled texture. This way the depth test efficiency remains the highest for the color and transparent passes later.
								</p>
							</li>
							<li>
								<p>
                                    velocity: if any of the following effects are turned on: Temporal AA, Motion Blur, FSR upscaling, ray traced shadows/reflections/diffuse, SSR‚Ä¶
								</p>
							</li>
							<li>
								<p>
                                    normal, roughness: if any of the following effects are turned on: SSR, ray traced reflections
								</p>
							</li>
							<li>
								<p>
                                    some other params are simply retrieved from visibility buffer just on demand if effects need it, but not saved as a texture: for example face normal
								</p>
							</li>
							<li>
								<p>
                                    light buffers: these are not separated, so things like blurred diffuse subsurface scattering is not supported. I support a simple wrapped and tinted NdotL term for subsurface scattering instead.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            What does this texture actually store? It‚Äôs a single channel 32-bit UINT texture, and normally that wouldn‚Äôt be enough to store both primitive and instance ID. But there is a workaround, in which I store 25 bits of meshlet ID and 7 bits of primitive ID. A regular mesh wouldn‚Äôt fit into it, since it limits to 128 triangles, but with a lookup table it‚Äôs possible to manage.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="disadvantages" >
    Disadvantages
</h5>
<ul>
	<li>
		<p>
            Tiled shading groups samples in rectangular screen-space tiles, using the min and max depth within each tile to define sub frustums. Thus, tiles which contain depth values that are close together, e.g. from a single surface, will be represented with small bounding volumes. However, for tiles where one or more depth discontinuities occur, the depth bounds of the tile must encompass all the empty space between the sample groups (illustrated in Figure 1). This reduces light culling efficiency, in the worst case degenerating to a pure 2D test. This results in a strong dependency between view and performance, which highly is undesirable in real-time applications, as it becomes difficult to guarantee consistent rendering performance at all times.
		</p>
		<ul>
			<li>
				<p>
                    Visually, this means:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922180103.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Toggling on the light geometry, we see that there is a lot of overlap, even in the empty space behind the tree.
				</p>
			</li>
			<li>
				<p>
                    We now should be able to start seeing the shape of the problem with 2D tiles in a 3D world.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922180303.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In 3D:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922180341.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    While actually some of the samples, from the tree, are affected zero of these lights. While the tiger in the wall would only need two of the lights.
				</p>
			</li>
			<li>
				<p>
                    There is a fairly fundamental problem with tiled shading. The basic problem stems from that we are making the intersection between lights and geometry samples, both of which are 3D entities, in a 2D screen space.
				</p>
			</li>
			<li>
				<p>
                    The main practical issue with this is that the resulting light assignment is highly view dependent. This means that we cannot author scenes with any strong guarantee on performance, as a given view of the scene may have a significantly higher screen space light density than average.
				</p>
			</li>
			<li>
				<p>
                    For example, we‚Äôd like to be able to construct a scene with, say, maximum 4 lights affecting any part of the scene. In this case, we would like shading cost to be proportional to this, and stable, given different view points.
				</p>
			</li>
			<li>
				<p>
                    Unfortunately, no such correlation exists for tiled shading. In other words shading times are unpredictable, which is a major problem for a real time application.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Avalanche Studios
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The two tiled solutions need quite a bit of massaging to work reasonable well in all situations, especially with large amounts of depth discontinuities. There are proposed solutions that mitigate the problem, such as 2.5D culling, but they further complicate the code.
						</p>
					</li>
					<li>
						<p>
                            I didn‚Äôt have to go look for a problematic area, in fact, it was right there in front of my face. This shows how common these scenes actually are in real games, and certainly so in the games that we make.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922204443.png" width="250" >
                            <img src="assets/image_20250922204452.png" width="250" >
                            .
						</p>
					</li>
					<li>
						<p>
                            We are still using a deferred engine, but we could change to forward at any time should we decide that to be better. The important part is, however, that the transparency passes can now use the same lighting structure as the deferred passes, making it a unified lighting solution.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="quoteextensions-to-the-tiled-forwardquote" >
    &quot;Extensions to the Tiled Forward&quot;
</h5>
<ul>
	<li>
		<p>
			<strong>
                2.5D Culling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://pt.slideshare.net/slideshow/a-25d-culling-for-forward-siggraph-asia-2012/34909590" 
						class="external-link" 
						target="_blank" >
                        2.5D Culling for Forward+ - AMD Siggraph 2012
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://wickedengine.net/2018/01/optimizing-tile-based-light-culling/" 
						class="external-link" 
						target="_blank" >
                        2.5D Culling for Forward+ - Wicked Engine 2018
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=NGWZm2VhxDs" 
						class="external-link" 
						target="_blank" >
                        2.5D Light Culling for Tiled Forward - Wicked Engine 2017
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Depth discontinuity is the enemy of Forward+.
						</p>
					</li>
					<li>
						<p>
                            With a more aggressive culling we can eliminate false positives and have a much faster render.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922113909.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Avalanche Studios
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Criticizes the use of 2.5D Culling, considering that Cluster Shading yields a better result with less effort.
						</p>
					</li>
					<li>
						<p>
                            This is explained and demonstrated on pages 112 to 121 of this presentation: 
							<a
								href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
								class="external-link" 
								target="_blank" >
                                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            2.5D Culling.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bimodal Clusters / HalfZ
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922113926.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Ola Olsson:
		</p>
		<ul>
			<li>
				<p>
                    This extensions have the problems of:
				</p>
				<ul>
					<li>
						<p>
                            Lack of generality: slopes / multiple layers.
						</p>
					</li>
					<li>
						<p>
                            No solution for transparency.
						</p>
					</li>
					<li>
						<p>
                            Require depth pre-pass, as you have to work with the depth range to apply the extensions.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The use of Clustered Forward Shading removes the need for these extensions.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="samples" >
    Samples
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/3dgep/ForwardPlus" 
				class="external-link" 
				target="_blank" >
                Forward, Deferred, Tile Forward Shading - DirectX11, HLSL - Sample - Jeremiah van Oosten 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    There are 30,000,000,000 files, etc, C++, Visual Studio, CMake, etc. Jeebs.
				</p>
			</li>
			<li>
				<p>
                    The 
					<em>
                        only
					</em>
                    &nbsp;relevant things are the shaders:
				</p>
				<ul>
					<li>
						<p>
                            <code>GraphicsTest\Assets\shaders\CommonInclude.hlsl</code>
						</p>
					</li>
					<li>
						<p>
                            <code>GraphicsTest\Assets\shaders\ForwardPlusRendering.hlsl</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/WindyDarian/Vulkan-Forward-Plus-Renderer" 
				class="external-link" 
				target="_blank" >
                Tile Forward Shading - Sample - Windy Darian
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=ZLNDfPxhqdE" 
						class="external-link" 
						target="_blank" >
                        Sample Demo
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="papers-and-presentations" >
    Papers and Presentations
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://takahiroharada.wordpress.com/wp-content/uploads/2015/04/forward_plus.pdf" 
				class="external-link" 
				target="_blank" >
                Forward+: Bringing Deferred Lighting to the Next Level - AMD 2012
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.3dgep.com/forward-plus/" 
				class="external-link" 
				target="_blank" >
                Forward, Deferred, Tiled Forward - Jeremiah Van Oosten - 2015
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    C++, shaders em HLSL.
				</p>
			</li>
			<li>
				<p>
                    Possui uma Sample acima.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=mkAbE9Z4gxI" 
				class="external-link" 
				target="_blank" >
                Demo - Wicked Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=HIrq4sF5QO8" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=w0gTf6PKHwI" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.gdcvault.com/play/1017627/Advanced-Visual-Effects-with-DirectX" 
				class="external-link" 
				target="_blank" >
                Tiled Forward Shading vs Tiled Deferred Rendering - AMD 2013 (Jason Stewart and Gareth Thomas)
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    The presentation is somewhat poor and the graphics are questionable.
				</p>
			</li>
			<li>
				<p>
                    No real-world lighting cases are presented.
				</p>
			</li>
			<li>
				<p>
                    &quot;Have you looked into Forward Clustered?&quot; Yea, but have not implemented, they are hours worth of work. I don't know if the extra complexity is worth, but I'll probably test it at some point.
				</p>
			</li>
			<li>
				<p>
                    They use Virtual Point Lights for GI, which sounds suspicious..
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="clustered-forward-shading" >
    Clustered Forward Shading
</h4>
<ul>
	<li>
		<p>
            Clustered shading expands on the idea of tiled rendering but adds a segmentation on the 3rd axis. The ‚Äúclustering‚Äù is done in view space, by splitting the frustum into a 3D grid.
		</p>
	</li>
	<li>
		<p>
            Clustered Shading enables using normal information to perform per-cluster back-face culling of lights, again reducing the number of lighting computations.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Clustered Shading vs Tiled Shading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We also show that Clustered Shading not only outperforms tiled shading in many scenes, but also exhibits better worst case behaviour under tricky conditions (e.g. when looking at high-frequency geometry with large discontinuities in depth).
				</p>
			</li>
			<li>
				<p>
                    Additionally, Clustered Shading enables real-time scenes with two to three orders of magnitudes more lights than previously feasible (up to around one million light sources).
				</p>
			</li>
			<li>
				<p>
                    Our implementation shows much less view-dependent performance, and is much faster for some cases that are challenging for tiled shading.
				</p>
			</li>
			<li>
				<p>
                    Compared to tiled shading, clusters generally are smaller, and therefore will be affected by fewer light sources.
				</p>
			</li>
			<li>
				<p>
                    Our implementation shows that both clustered deferred and forward shading offer real-time performance and can scale up to 1M lights. In addition, overhead for the clustering is low, making it competitive even for few lights.
				</p>
			</li>
			<li>
				<p>
                    The shading cost is proportional to the light density.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Clustered Forward vs Clustered Deferred
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Clustered Shading is really decoupled from the choice between deferred or forward rendering. It works with both, so you‚Äôre not locked into one or the other. This way you can make an informed choice between the two approaches based on other factors, such as whether you need custom materials and lighting models, or need deferred effects such as screen-space decals, or simply based on performance.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h6
	id="godot" >
    Godot
</h6>
<ul>
	<li>
		<p>
            Clustered lighting uses a compute shader to group lights into a 3D frustum aligned grid.
		</p>
	</li>
	<li>
		<p>
            At render time, pixels can lookup what lights affect the grid cell they are in and only run light calculations for lights that might affect that pixel.
		</p>
	</li>
	<li>
		<p>
            This approach can greatly speed up rendering performance on desktop hardware, but is substantially less efficient on mobile.
		</p>
	</li>
	<li>
		<p>
            There's a default limit of 512 clustered elements that can be present in the current camera view.
		</p>
		<ul>
			<li>
				<p>
                    A clustered element is an omni light, a spot light, a decal or a reflection probe.
				</p>
			</li>
			<li>
				<p>
                    This limit can be increased by adjusting Max Clustered Elements in Project Settings &gt; Rendering &gt; Limits &gt; Cluster Builder.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="high-level-overview" >
    High-level overview
</h5>
<ol>
	<li>
		<p>
            Build the clustering data structure.
		</p>
	</li>
	<li>
		<p>
            Render scene to Z Pre-pass.
		</p>
	</li>
	<li>
		<p>
            Find visible clusters.
		</p>
	</li>
	<li>
		<p>
            Reduce repeated values in the list of visible clusters.
		</p>
	</li>
	<li>
		<p>
            Perform light culling and assign lights to clusters.
		</p>
	</li>
	<li>
		<p>
            Shade samples using light list.
		</p>
	</li>
</ol>
<ul>
	<li>
		<p>
            Steps two and six won‚Äôt be covered since they are mostly dependent on the shading model you‚Äôre using.
		</p>
	</li>
	<li>
		<p>
            Steps three and four are combined into one and covered in the section on Determining Active Clusters, much like in 
			<a
				href="https://www.3dgep.com/volume-tiled-forward-shading/" 
				class="external-link" 
				target="_blank" >
                Van Oosten‚Äôs implementation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="building-the-cluster-grid" >
    Building the Cluster Grid
</h5>
<ul>
	<li>
		<p>
			<strong>
                Depth Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We‚Äôll be focusing on building cluster grids that group samples based on their view space position. We‚Äôll begin by tiling the view frustum exactly the same way you would in tiled shading and then subdividing it along the depth axis multiple times.
				</p>
			</li>
			<li>
				<p>
                    We choose to perform the subdivision in view space, by spacing the divisions exponentially to achieve self-similar subdivisions, such that the clusters become as cubical as possible (Figures 2(c) and 3).
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922162804.png" width="350" >
                    <img src="assets/image_20250922162907.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In Figure 3, we illustrate the subdivisions of a frustum. The number of subdivisions in the Y direction (Sy) is given in screen space (e.g. to form tiles of 32√ó32 pixels).
				</p>
			</li>
			<li>
				<p>
                    The near plane for a division k, near k, can be calculated from:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922163111.png" width="276" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922163221.png" width="275" >
                    .
				</p>
			</li>
			<li>
				<p>
                    &quot;I settled on a 16x9x24 subdivision because it matches my monitors aspect ratio, but it honestly could have been something else.&quot; - Angel Ortiz.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Doom (2016)
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Uses the one below, which doesn't represent any of the three above.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923200901.png" width="" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Solving: 
                            <img src="assets/image_20250923201004.png" width="500" >
                            .
						</p>
					</li>
					<li>
						<p>
                            The major advantage of the equation above is that the only variable is Z and everything else is a constant.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923201056.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Avalanche Studios
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Another option we have considered, but not yet explored, is to not base it on pixel count, but simply divide the screen into a specific number of tiles regardless of resolution. This may reduce coherency on the GPU side somewhat in some cases, but would also decouple the CPU workload from the GPU workload and allow for some useful CPU side optimizations if the tile counts are known at compile time.
						</p>
					</li>
					<li>
						<p>
                            We are using exponential depth slicing, much like in the paper. There is nothing dictating that this is what we have to use, or for that matter that it is the best or most optimal depth slicing strategy; however, the advantage is that the shape of the clusters remain the same as we go deeper into the depth. On the other hand, clusters get larger in world space, which could potentially result in some distant clusters containing a much larger amount of lights. Depending on the game, it may be worth exploring other options.
						</p>
					</li>
					<li>
						<p>
                            Our biggest problem was that our depth ratio is massive, with near plane as close as 0.1m and far plane way out on the other side of the map, at 50,000m. This resulted in poor utilization of our limited depth slices, currently 16 of them. The step from one slice to the next is very large. Fortunately, in our game we don‚Äôt have any actual light sources beyond a distance of 500m. So we simply decided to keep our current distant light system for distances beyond 500m and limit the far range for clustering to that.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922205338.png" width="350" >
                            .
						</p>
					</li>
					<li>
						<p>
                            This improved the situation notably, but was still not ideal. We still burnt half of our slices on the first 7 meters from the camera. Given how our typical scenes look like, that‚Äôs likely going to be mostly empty space in most situations. So to improve the situation, we made the first slice special and made that go from near plane to an arbitrary visually tweaked distance, currently 5m. This gave us much better utilization.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Filament Engine
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The depth slicing is not linear, but exponential. In a typical scene, there will be more pixels close to the near plane than to the far plane. An exponential grid of froxels will therefore improve the assignment of lights where it matters the most.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922080354.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            A simple exponential voxelization is unfortunately not enough. The graphic above clearly illustrates how world space is distributed across slices but it fails to show what happens close to the near plane.
						</p>
					</li>
					<li>
						<p>
                            A simple exponential distribution uses up half of the slices very close to the camera. In this particular case, we use 8 slices out of 16 in the first 5 meters. Since dynamic world lights are either point lights (spheres) or spot lights (cones), such a fine resolution is completely unnecessary so close to the near plane.
						</p>
					</li>
					<li>
						<p>
                            Our solution is to manually tweak the size of the first froxel depending on the scene and the near and far planes. By doing so, we can better distribute the remaining froxels across the frustum.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922080541.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            This new distribution is much more efficient and allows a better assignment of the lights throughout the entire frustum.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922080237.png" width="350" >
                            <img src="assets/image_20250922080246.png" width="350" >
                            <img src="assets/image_20250922080156.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            We call a 
							<strong>
                                froxel
							</strong>
                            &nbsp;a voxel in frustum space.
						</p>
					</li>
					<li>
						<p>
                            The frustum voxelization can be executed only once by a first compute shader (as long as the projection matrix does not change).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Screen Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Filament Engine
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            1280x720px, 80x80px tiles.
						</p>
					</li>
					<li>
                        <img src="assets/image_20250922080036.png" width="350" >

					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922202558.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            Cluster assignments is a simple mapping from sample coordinate, to an integer tuple 
            <code>i</code>
            , 
            <code>j</code>
            , 
            <code>k</code>
            .
		</p>
	</li>
	<li>
		<p>
            <code>i</code>
            &nbsp;and 
            <code>j</code>
            &nbsp;are the tile coordinates, which can be derived by dividing 
            <code>gl_FragCoord.xy</code>
            &nbsp;by the tile size.
		</p>
		<ul>
			<li>
				<p>
                    <code>i = bx_screen_space/txc</code>
                    &nbsp;
                    <code>j = by_screen_space/tyc</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>k</code>
            &nbsp;is a logarithmic function of the view space Z of the sample, not simply the logarithm.
		</p>
		<ul>
			<li>
				<p>
                    The logarithmic subdivisions also means that as clusters become larger further away, we get a kind of LOD behaviour and do not end up with insane numbers of clusters, for a wide range of view parameters.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We use this subdivision as it creates self similar clusters that are as cube like as possible. This makes them better suited for culling.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922202238.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            An easy solution is to use Axis Aligned Bounding Boxes (AABB) that enclose each cluster. AABBs built from the max and min points of the clusters will be ever so slightly larger than the actual clusters. We‚Äôre okay with this since it ensures that there are no gaps in between volumes due to precision issues. Also, AABB‚Äôs can be stored using only only two vec3‚Äôs, a max and min point.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Angelo1211/HybridRenderingEngine/blob/master/assets/shaders/ComputeShaders/clusterShader.comp" 
				class="external-link" 
				target="_blank" >
                Building the Cluster Grid - Compute Shader Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            This compute shader is ran once per cluster and aims to obtain the min and max points of the AABB encompassing said cluster.
		</p>
	</li>
	<li>
		<p>
            First, imagine we‚Äôre looking at the view frustum from a front camera perspective, like we did in the Tiled Shading animations of part one. Each tile will have a min and max point, which in our coordinate system will be the upper right and bottom left vertices of a tile respectively. After obtaining these two points in screen space we set their Z position equal to the near plane, which in NDC and in my specific setup is equal to -1.
		</p>
		<ul>
			<li>
				<p>
                    I know, I know. I should be using reverse Z, not the default OpenGL layout, I‚Äôll fix that eventually.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Then, we transform these min and max points to view space. Next, we obtain the Z value of the ‚Äúnear‚Äù and ‚Äúfar‚Äù plane of our target mini-frustum / cluster. And, armed with the knowledge that all rays meet at the origin in view space, a pair of min and max values in screen space and both bounding planes of the cluster, we can obtain the four points intersecting those planes that will represent the four corners of the AABB encompassing said cluster. Lastly, we find the min and max of those points and save their values to the cluster array. And voil√†, the grid is complete!
		</p>
	</li>
	<li>
		<p>
            Screen To View:
		</p>
		<ul>
			<li>
				<p>
                    Converts a given point in screen space to view space by taking the reverse transformation steps taken by the graphics pipeline.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Line Intersection to Z Plane:
		</p>
		<ul>
			<li>
				<p>
                    Used to obtain the points on the corners of the AABB that encompasses a cluster. The normal vector of the planes is fixed at 1.0 in the z direction because we are evaluating the points in view space and positive z points towards the camera from this frame of reference.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            When to recalculate:
		</p>
		<ul>
			<li>
				<p>
                    Our list of cluster AABBs will be valid as long as the view frustum stays the same shape. So, it can be calculated once at load time and only recalculated with any changes in FOV or other view field altering camera properties.
				</p>
			</li>
			<li>
				<p>
                    My initial profiling in RenderDoc seems to indicate that the GPU can run this shader really quickly, so I think it wouldn‚Äôt be a huge deal either if this was done every frame.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="idk" >
    Idk
</h5>
<ul>
	<li>
		<p>
			<strong>
                From depth to froxel
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Given a near plane $n$, a far plane $m$, a maximum number of depth slices $z$ and a linear depth value in the range 
                    <code>[0..1]</code>
                    , this equation can be used to compute the index of the cluster for a given position.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922081032.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This formula suffers however from the resolution issue mentioned previously. We can fix it by introducing $sn$, a special near value that defines the extent of the first froxel (the first froxel occupies the range 
                    <code>[n..sn]</code>
                    , the remaining froxels 
                    <code>[sn..f]</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    The following equation can be used to compute a linear depth value from 
                    <code>gl_FragCoord.z</code>
                    &nbsp;(assuming a standard OpenGL projection matrix).
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922081150.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This equation can be simplified by pre-computing two terms $c0$ and $c1$:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922081222.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This simplification is important because we will pass the linear $z$ value to a 
                    <code>log2</code>
                    . Since the division becomes a negation under a logarithmic, we can avoid a division by using 
                    <code>-log2(z * c0 + c1)</code>
                    &nbsp;instead.
				</p>
			</li>
			<li>
				<p>
                    Implementation to compute a froxel index from a fragment's screen coordinates:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#define MAX_LIGHT_COUNT 16 // max number of lights per froxel

uniform uvec4 froxels; // res x, res y, count y, count y
uniform vec4 zParams;&nbsp;&nbsp;// c0, c1, index scale, index bias

uint getDepthSlice() {
&nbsp;&nbsp;&nbsp;&nbsp;return uint(max(0.0, log2(zParams.x * gl_FragCoord.z + zParams.y) *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zParams.z + zParams.w));
}

uint getFroxelOffset(uint depthSlice) {
&nbsp;&nbsp;&nbsp;&nbsp;uvec2 froxelCoord = uvec2(gl_FragCoord.xy) / froxels.xy;
&nbsp;&nbsp;&nbsp;&nbsp;froxelCoord.y = (froxels.w - 1u) - froxelCoord.y;

&nbsp;&nbsp;&nbsp;&nbsp;uint index = froxelCoord.x + froxelCoord.y * froxels.z +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depthSlice * froxels.z * froxels.w;
&nbsp;&nbsp;&nbsp;&nbsp;return index * MAX_FROXEL_LIGHT_COUNT;
}

uint slice = getDepthSlice();
uint offset = getFroxelOffset(slice);

// Compute lighting...
</code></pre>
		<ul>
			<li>
				<p>
                    Several uniforms must be pre-computed to perform the index evaluation efficiently.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">froxels[0] = TILE_RESOLUTION_IN_PX;
froxels[1] = TILE_RESOLUTION_IN_PX;
froxels[2] = numberOfTilesInX;
froxels[3] = numberOfTilesInY;

zParams[0] = 1.0f - Z_FAR / Z_NEAR;
zParams[1] = Z_FAR / Z_NEAR;
zParams[2] = (MAX_DEPTH_SLICES - 1) / log2(Z_SPECIAL_NEAR / Z_FAR);
zParams[3] = MAX_DEPTH_SLICES;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                From froxel to depth
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922081542.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    For $i = 0$, the z value is 0. The result of this equation is in the 
                    <code>[0..1]</code>
                    &nbsp;range and should be multiplied by $f$ to get a distance in world units.
				</p>
			</li>
			<li>
				<p>
                    The compute shader implementation should use 
                    <code>exp2</code>
                    &nbsp;instead of a 
                    <code>pow</code>
                    . The division can be precomputed and passed as a uniform.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="data-structure" >
    Data Structure
</h5>
<ul>
	<li>
		<p>
            They‚Äôre implemented solely on the GPU using shader storage buffer objects, so keep in mind that reads and writes have incoherent memory access and 
			<strong>
                will
			</strong>
            &nbsp;require the appropriate barriers to avoid any disasters.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175552.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;At the end, you get an accelerated structure like this, which is just a grid where you can look up your light lists.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Global Light List
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is an array containing all of the lights in a given scene with a size equivalent to the maximum amount of lights possible in the scene.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Global Light Index List
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Every light will have its own unique index based on its location in the Global Light List and that index is stored in the Global Light Index List.
				</p>
			</li>
			<li>
				<p>
                    This array contains the indices of all of the active lights in the scene grouped by cluster.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Light Grid
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Contain information as to how these indices relate to their parent clusters.
				</p>
			</li>
			<li>
				<p>
                    This array has as many elements as there are clusters and each element contains two unsigned ints, one that stores the offset to the Global Light Index List and another that contains the number of lights intersecting the cluster.
				</p>
			</li>
			<li>
				<p>
                    Each cell stores an offset and count that represent a range in ?.
				</p>
			</li>
			<li>
				<p>
                    This range contains a list of 
					<em>
                        light indices
					</em>
                    &nbsp;indicating all the lights that the may affect the samples in the tile.
				</p>
			</li>
			<li>
				<p>
                    The Light Grid provides access to light list for each pixel.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Unlike what‚Äôs shown in the diagram, the global light index list does not necessarily store the indices for each cluster sequentially, in fact, it might store them in a completely random order.
		</p>
	</li>
	<li>
		<p>
            If you‚Äôre wondering why we need such a convoluted data structure, the quick answer is that it plays nicely with the GPU and works well in parallel. Also, it allows both compute shaders and pixel shaders to read the same data structure and execute the same code. Lastly, it is pretty memory efficient since clusters tend to share the same lights and by storing indices to the global light list instead of the lights themselves we save up memory.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Angelo1211/HybridRenderingEngine/blob/master/assets/shaders/ComputeShaders/clusterCullLightShader.comp" 
				class="external-link" 
				target="_blank" >
                clusterCullLightShader.comp
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Check lights against every cluster of the view frustum. Performs light culling for every cluster in the cluster grid.
				</p>
			</li>
			<li>
				<p>
                    Thread groups sizes are actually relevant in this compute shader since I‚Äôm using shared GPU memory to reduce the number of reads and writes by only loading each light once per thread group, instead of once per cluster.
				</p>
			</li>
			<li>
				<p>
                    First, each thread gets its bearings and begins by calculating some initialization values.
				</p>
				<ul>
					<li>
						<p>
                            For example, how many threads there are in a thread group, what it‚Äôs linear cluster index is and in how many passes it shall traverse the global light list.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Next, each thread initializes a count variable of how many lights intersect its cluster and a local index light array to zero.
				</p>
			</li>
			<li>
				<p>
                    Once setup is complete, each thread group begins a traversal of a batch of lights. Each individual thread will be responsible for loading a light and writing it to shared memory so other threads can read it.
				</p>
			</li>
			<li>
				<p>
                    A barrier after this step ensures all threads are done loading before continuing.
				</p>
			</li>
			<li>
				<p>
                    Then, each thread performs collision detection for its cluster, using the AABB we determined in step one, against every light in the shared memory array, writing all positive intersections to the local thread index array.
				</p>
			</li>
			<li>
				<p>
                    We repeat these steps until every light in the global light array has been evaluated.
				</p>
			</li>
			<li>
				<p>
                    Next, we atomically add the local number of active lights in a cluster to the globalIndexCount and store the global count value before we add to it.
				</p>
			</li>
			<li>
				<p>
                    This number is our offset to the global light index list and due to the nature of atomic operations we know that it will be 
					<em>
                        unique per cluster
					</em>
                    , since only one thread has access to it at any given time.
				</p>
			</li>
			<li>
				<p>
                    Then, we populate the global light index list by transferring the values from the 
					<strong>
                        local
					</strong>
                    &nbsp;light index list (named visibleLightIndices in the code) into the 
					<strong>
                        global
					</strong>
                    &nbsp;light index list starting at the offset index we just obtained.
				</p>
			</li>
			<li>
				<p>
                    Finally, we write the offset value and the count of how many lights intersected the cluster to the lightGrid array at the given cluster index.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Once this shader is done running the data structures will contain all of the values necessary for a pixel shader to read the list of lights that are affecting a given fragment, since we can use the getClusterIndex function from the previous section to find which cluster a fragment belongs to.
		</p>
	</li>
	<li>
		<p>
            With this, we‚Äôve completed step five and therefore have all the building blocks in place for a working clustered shading implementation.
		</p>
	</li>
	<li>
		<p>
            Even this simple culling method will still manage lights in the order of tens of thousands.
		</p>
	</li>
	<li>
		<p>
			<em>
                Extra Optimizations
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.3dgep.com/volume-tiled-forward-shading/" 
						class="external-link" 
						target="_blank" >
                        Jeremiah Van Oosten‚Äôs thesis
					</a>
                    &nbsp;writes about optimizing Clustered Renderers and has links to his testing framework where you can compare different efficient rendering algorithms.
				</p>
			</li>
			<li>
				<p>
                    He goes into detail as to how spatial optimization structures like Boundary Volume Hierarchies (BVH) and efficient light sorting can significantly increase performance and allow for scenes with millions of dynamic light sources in real-time.
				</p>
				<ul>
					<li>
						<p>
                            Right now, it seems that implementing the BVH will be my first task ‚Äî and specially after how important being familiar with BVH‚Äôs will become after Turing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="http://www.cse.chalmers.se/~uffe/ClusteredWithShadows.pdf" 
						class="external-link" 
						target="_blank" >
                        virtual shadow mapping
					</a>
                    &nbsp;enables hundreds of real-time shadow casting dynamic lights.
				</p>
			</li>
			<li>
				<p>
                    It should be considered an alternate clustering method best suited for mobile hardware.
				</p>
			</li>
			<li>
				<p>
                    Doom 2016 goes into optimized shaders to make use of GCN scalar units and saved some Vector General-Purpose Registers(VGPR). Also, by voxelizing environment probes, decals and lights the benefits of the cluster data structure were brought over to nearly all items that influence lighting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Given a screen position and a depth value (whether from a depth buffer or the rasterized depth in a forward pass) we start by looking up the cluster from a 3D texture. Each texel represents a cluster and its light list.
				</p>
			</li>
			<li>
				<p>
                    The red channel gives us an offset to where the light list starts, whereas the green channel contains the light counts. The light lists are then stored in a tightly packed lists of indexes to the lights. The actual light source data is stored as arrays in a constant buffer.
				</p>
			</li>
			<li>
				<p>
                    All in all the data structure is very compact. In a typical artists lit scene it may be around 50- 100kb of data to upload to the GPU every frame.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922205540.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Data coherency
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            So the difference between tiled and clustered is that we pick a light list on a per-pixel basis instead of per-tile, depending on which cluster we fall within. Obviously though, in a lot of cases nearby pixels will choose the same light list, in particular neighbors within the same tile on a similar depth. If we visualize what light lists were chosen, we can see that there are a bunch of different paths taken beyond just the tile boundaries. A number of depth discontinuities from the foliage in front of the player gets clearly visible. This may seem like a big problem, but here we are only talking about fetching different data. This is not a problem for a GPU, it‚Äôs something they do all the time for regular texture fetches, and this is even much lower frequency than that.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Filament Engine
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The list of lights per froxel can be passed to the fragment shader either as an SSBO or a texture.
				</p>
			</li>
			<li>
				<p>
                    During the rendering pass, we can compute the ID of the froxel a fragment belongs to and therefore the list of lights that can affect that fragment.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="finding-active-clusters-unique-clusters" >
    Finding Active Clusters / Unique Clusters
</h5>
<ul>
	<li>
		<p>
			<em>
                Motivation
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    This section is optional since active cluster determination is not a crucial part of light culling.
				</p>
			</li>
			<li>
				<p>
                    Even though it isn‚Äôt terribly optimal, you can simply perform culling checks for all clusters in the cluster grid every frame.
				</p>
			</li>
			<li>
				<p>
                    Thankfully, determining active clusters doesn‚Äôt take much work to implement and can speed up the light culling pass considerably.
				</p>
			</li>
			<li>
				<p>
                    The only drawback is that it 
					<strong>
                        will
					</strong>
                    &nbsp;require a 
					<strong>
                        Depth Pre-pass
					</strong>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Depth Pre-pass
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The depth map generated is used to determine the minimum and maximum depth values within a tile, that is the minimum and maximum depths across the entire tile.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The key idea is that not all clusters will be visible all of the time, and there is no point in performing light culling against clusters you cannot see.
		</p>
	</li>
	<li>
		<p>
            So, we can check every pixel in parallel for their cluster ID and mark it as active on a list of clusters.
		</p>
	</li>
	<li>
		<p>
            This list will most likely be sparsely populated, so we will compact it into another list using atomic operations.
		</p>
	</li>
	<li>
		<p>
            Then, during light culling we will check light ‚Äúcollisions‚Äù against the compacted list instead, saving us from having to check every light for every cluster.
		</p>
	</li>
	<li>
		<p>
            To increase efficiency, both Van Oosten and Olsson compact this list into a set of 
			<strong>
                unique clusters
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    We compact the grid into the list of non-zero elements.
				</p>
			</li>
			<li>
				<p>
                    This leaves us with a list of clusters which needs lights assigned to them.
				</p>
			</li>
			<li>
				<p>
                    The most obvious method to find the unique clusters in parallel is to simply sort the cluster keys, and then perform a compaction step that 
					<em>
                        removes any with an identical neighbour
					</em>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250922163401.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Identifying unique clusters
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Local Sorting
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    We sort samples in each screen space tile locally. This allows us to perform the sorting operation in on-chip shared memory, and use local (and therefore smaller) indices to link back to the source pixel.
								</p>
							</li>
							<li>
								<p>
                                    We extract unique clusters from each tile using a parallel compaction. From this, we get the globally unique list of clusters. During the compaction, we also compute and store a link from each sample to its associated cluster.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>
							<em>
                                Page Tables
							</em>
                            </s>
						</p>
						<ul>
							<li>
								<p>
                                    The second technique is similar to the page table approach used by virtual textures (Section 2). However, as the range of possible cluster keys is very large, we cannot use a direct mapping between cluster key and physical storage location for the cluster data; it simply would typically not fit into GPU memory. Instead we use a virtual mapping, and allocate physical pages where any actual keys needs storage. Lefohn et.al. [LSK‚àó06] provide details on software GPU implementation of virtual address translation. We exploit the fact that all physical pages are allocated in a compact range, and we can therefore compact that range to find the unique clusters.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>
							<em>
                                Other methods
							</em>
                            </s>:
						</p>
						<ul>
							<li>
								<p>
                                    Both sorting and compaction are relatively efficient and readily available GPU building blocks. However, despite steady progress, sorting remains an expensive operation.
								</p>
							</li>
							<li>
								<p>
                                    Methods that rely on adjacent screen-space coherency are not robust, especially with respect to stochastic frame buffers.
								</p>
							</li>
							<li>
								<p>
                                    We therefore focus on techniques that do not suffer from this weaknesses.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Explicit Bounds
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            As the actual view-sample positions and normals typically have tighter bounds, we also evaluate explicit 3D bounds and normal cones.
						</p>
					</li>
					<li>
						<p>
                            We compute the explicit bounds by performing a reduction over the samples in each cluster (e.g., we perform a min-max reduction to find the AABB enclosing each cluster).
						</p>
					</li>
					<li>
						<p>
                            The results of the reduction are stored separately in memory.
						</p>
					</li>
					<li>
						<p>
                            When using page tables, the reduction is difficult to implement efficiently, because of the many-to-one mapping from view samples to cluster data, we would need to make use of atomic operations, and get a high rate of collisions. We deemed this to be impractically expensive.
						</p>
					</li>
					<li>
						<p>
                            We therefore only implement explicit bounds for local sort.
						</p>
					</li>
					<li>
						<p>
                            After the local sort, information about which samples belong to a given cluster is readily available.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">//Input
vec2 pixelID; // The thread x and y id corresponding to the pixel it is representing
vec2 screenDimensions; // The total pixel size of the screen in x and y

//Output
bool clusterActive[];

//We will evaluate the whole screen in one compute shader
//so each thread is equivalent to a pixel
void markActiveClusters(){
&nbsp;&nbsp;&nbsp;&nbsp;//Getting the depth value
&nbsp;&nbsp;&nbsp;&nbsp;vec2 screenCord = pixelID.xy / screenDimensions.xy;
&nbsp;&nbsp;&nbsp;&nbsp;float z = texture(screenCord) //reading the depth buffer

&nbsp;&nbsp;&nbsp;&nbsp;//Getting the linear cluster index value
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterID = getClusterIndex(vec3(pixelID.xy, z));
&nbsp;&nbsp;&nbsp;&nbsp;clusterActive[clusterID] = true;
}
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">//Input
vec3 pixelCoord;&nbsp;&nbsp;// Screen space pixel coordinate with depth
uint tileSizeInPx; // How many pixels a rectangular cluster takes in x and y
uint3 numClusters; // The fixed number of clusters in x y and z axes

//Output
uint clusterIndex; // The linear index of the cluster the pixel belongs to

uint getClusterIndex(vec3 pixelCoord){
&nbsp;&nbsp;&nbsp;&nbsp;// Uses equation (3) from Building a Cluster Grid section
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterZVal&nbsp;&nbsp;= getDepthSlice(pixelCoord.z);

&nbsp;&nbsp;&nbsp;&nbsp;uvec3 clusters&nbsp;&nbsp;&nbsp;&nbsp;= uvec3( uvec2( pixelCoord.xy / tileSizeInPx), clusterZVal);
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterIndex = clusters.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numClusters.x * clusters.y +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numClusters.x * numClusters.y) * clusters.z;
&nbsp;&nbsp;&nbsp;&nbsp;return clusterIndex;
}
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">//Input
bool clusterActive[]; //non-compacted list
uint globalActiveClusterCount; //Number of active clusters

//Output
uint uniqueActiveClusters[]; //compacted list of active clusters

//One compute shader for all clusters, one cluster per thread
void buildCompactClusterList(){
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterIndex&nbsp;&nbsp;= gl_GlobalInvocationID;
&nbsp;&nbsp;&nbsp;&nbsp;if(clusterActive[clusterIndex]){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint offset = atomicAdd(globalActiveClusterCount, 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniqueActiveClusters[offset] = clusterIndex;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h5
	id="light-culling-light-assignment" >
    Light Culling / Light Assignment
</h5>
<ul>
	<li>
		<p>
            This step aims to assign lights to each cluster based on their view space position.
		</p>
	</li>
	<li>
		<p>
            The main idea is that we perform something very similar to a ‚Äúlight volume collision detection‚Äù against the active clusters in the scene and append any lights within a cluster to a local list of lights.
		</p>
	</li>
	<li>
		<p>
            Performing this ‚Äúlight volume collision detection‚Äù requires that I define clearly what I mean by 
			<em>
                light volume
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            In a nutshell, lights become dimmer with distance. After a certain point they are so dim we can assume they aren‚Äôt contributing to shading anymore so, we mark those points as our boundary. The volume contained within the boundary is our light volume and if that volume intersects with the AABB of a cluster, we assume that light is contained within the cluster.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">//Input:
uint light; // A given light index in the shared lights array
uint tile;&nbsp;&nbsp;// The cluster index we are testing

//Checking for intersection given a cluster AABB and a light volume
bool testSphereAABB(uint light, uint tile){
&nbsp;&nbsp;&nbsp;&nbsp;float radius = sharedLights[light].range;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 center&nbsp;&nbsp;= vec3(viewMatrix * sharedLights[light].position);
&nbsp;&nbsp;&nbsp;&nbsp;float squaredDistance = sqDistPointAABB(center, tile);

&nbsp;&nbsp;&nbsp;&nbsp;return squaredDistance &lt;= (radius * radius);
}
</code></pre>
<ul>
	<li>
		<p>
            The main idea is that we check the distance between the point light sphere center and the AABB. If the distance is less than the radius they are intersecting.
		</p>
	</li>
	<li>
		<p>
            For spotlights, the light volume and consequently the collision tests will be very different.
		</p>
		<ul>
			<li>
				<p>
                    Check out 
					<a
						href="https://newq.net/dl/pub/SA2014Practical.pdf" 
						class="external-link" 
						target="_blank" >
                        this
					</a>
                    &nbsp;presentation by Emil Persson that explains how they implemented spotlight culling in Just Cause 3 if you do want to know more.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="light-assignment" >
    Light Assignment
</h5>
<ul>
	<li>
		<p>
            The lights have a limited range, with some falloff which goes to 0 at the boundary.
		</p>
	</li>
	<li>
		<p>
            There is no pre-computation so all geometry and lights are allowed to change freely from frame to frame.
		</p>
	</li>
	<li>
		<p>
            The goal of the light assignment stage is to calculate the list of lights influencing each cluster. Previous designs for tiled deferred shading implementations have by and large utilized a brute force approach to finding the intersection between lights and tiles. That is, light-cluster overlaps were found by, for each tile, iterating over all lights in the scene and testing bounding volumes. This is tolerable for reasonably low numbers of lights and clusters.
		</p>
	</li>
	<li>
		<p>
            To support large numbers of lights and a dynamically varying number of clusters, we use a fully hierarchical approach based on a spatial tree over the lights.
		</p>
	</li>
	<li>
		<p>
            Each frame, we construct a 
			<em>
                bounding volume hierarchy (BVH)
			</em>
            &nbsp;by first sorting the lights according to the Z-order (Morton Code) based on the discretized centre position of each light. We derive the discretization from a dynamically computed bounding volume around all lights.
		</p>
		<ul>
			<li>
				<p>
                    We use a BVH with a branching factor of 32, which is rebuilt each frame.
				</p>
			</li>
			<li>
				<p>
                    When not so many lights are used, there are many other approaches which may be better.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The leaves of the search tree we get directly from the sorted data.
		</p>
	</li>
	<li>
		<p>
            Next, 32 consecutive leaves are grouped into a bounding volume (AABB) to form the first level above the leaves.
		</p>
	</li>
	<li>
		<p>
            The next level is constructed by again combining 32 consecutive elements. We continue until a single root element remains.
		</p>
	</li>
	<li>
		<p>
            For each cluster, we traverse this BVH using depth-first traversal. At each level, the bounding box of the cluster (either explicitly computed from the cluster‚Äôs contents or implicitly derived from the cluster‚Äôs key) is tested against the bounding volumes of the child nodes. For the leaf nodes, the sphere bounding the light source is used; other nodes store an AABB enclosing the node. The branching factor of 32 allows efficient SIMD-traversal on the GPU and keeps the search tree relatively shallow (up to 5 levels), which is used to avoid expensive recursion (the branching factor should be adjusted depending on the GPU used, the factor of 32 is convenient on current NVIDIA GPUs).
		</p>
	</li>
	<li>
		<p>
			<strong>
                If
			</strong>
            &nbsp;a normal cone is available for a cluster, we use this cone to further reject lights that will not affect any samples in the cluster; etc (to summarize).
		</p>
	</li>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Deriving the explicit cluster bounds was something that could be interesting, but we found that sticking to implicit bounds simplified the technique, while also allowing the light assignment to run on the CPU.
				</p>
			</li>
			<li>
				<p>
                    In addition, this gives us scene independence. This means that we don‚Äôt need to know what the scene looks like to fill in the clusters, and this also allows us to evaluate light at any given point in space, even if it‚Äôs floating in thin air. This could be relevant for instance for ray-marching effects.
				</p>
			</li>
			<li>
				<p>
                    Given that we are doing the light assignment on the CPU, one may suspect that this will become a significant burden for the CPU. However, our implementation is fast enough to actually save us a bunch of CPU time over our previous solution. In a normal artist lit scene we recorded 0.1ms on one core for clustered shading. The old code supporting our previous forward pass for transparency that was still running in our system was still consuming 0.67ms for the same scene, a cost that we can now eliminate.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Filament Engine
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Before rendering a frame, each light in the scene is assigned to any froxel it intersects with. The result of the lights assignment pass is a list of lights for each froxel.
				</p>
			</li>
			<li>
				<p>
                    Lights assignment can be done in two different ways, on the GPU or on the CPU.
				</p>
			</li>
			<li>
				<p>
                    On GPU:
				</p>
				<ul>
					<li>
						<p>
                            The lights are stored in Shader Storage Buffer Objects (SSBO) and passed to a compute shader that assigns each light to the corresponding froxels.
						</p>
					</li>
					<li>
						<p>
                            The lights assignment can be performed each frame by another compute shader.
						</p>
					</li>
					<li>
						<p>
                            The threading model of compute shaders is particularly well suited for this task. We simply invoke as many workgroups as we have froxels (we can directly map the X, Y and Z workgroup counts to our froxel grid resolution). Each workgroup will in turn be threaded and traverse all the lights to assign.
						</p>
					</li>
					<li>
						<p>
                            Intersection tests imply simple sphere/frustum or cone/frustum tests.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Assigning Lights with Froxels
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Assigning lights to froxels can be implemented on the GPU using two compute shaders.
								</p>
							</li>
							<li>
								<p>
                                    The first one, creates the froxels data (4 planes + a min Z and max Z per froxel) in an SSBO and needs to be run only once.
								</p>
								<ul>
									<li>
										<p>
                                            Projection matrix
										</p>
										<ul>
											<li>
												<p>
                                                    The projection matrix used to render the scene (view space to clip space transformation).
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Inverse projection matrix
										</p>
										<ul>
											<li>
												<p>
                                                    The inverse of the projection matrix used to render the scene (clip space to view space transformation).
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Depth parameters
										</p>
										<ul>
											<li>
												<p>
                                                    <img src="assets/image_20250922083216.png" width="" >
                                                    , maximum number of depth slices, Z near and Z far.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Clip space size
										</p>
										<ul>
											<li>
												<p>
                                                    <img src="assets/image_20250922083239.png" width="" >
                                                    , with $F_x$ the number of tiles on the X axis, $F_r$ the resolution in pixels of a tile and w the width in pixels of the render target.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
<pre><code class="language-glsl" data-lang="glsl">#version 310 es

precision highp float;
precision highp int;


#define FROXEL_RESOLUTION 80u

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(location = 0) uniform mat4 projectionMatrix;
layout(location = 1) uniform mat4 projectionInverseMatrix;
layout(location = 2) uniform vec4 depthParams; // index scale, index bias, near, far
layout(location = 3) uniform float clipSpaceSize;

struct Froxel {
&nbsp;&nbsp;&nbsp;&nbsp;// NOTE: the planes should be stored in vec4[4] but the
&nbsp;&nbsp;&nbsp;&nbsp;// Adreno shader compiler has a bug that causes the data
&nbsp;&nbsp;&nbsp;&nbsp;// to not be read properly inside the loop
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane0;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane1;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane2;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane3;
&nbsp;&nbsp;&nbsp;&nbsp;vec2 minMaxZ;
};

layout(binding = 0, std140) writeonly restrict buffer FroxelBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;Froxel data[];
} froxels;

shared vec4 corners[4];
shared vec2 minMaxZ;

vec4 projectionToView(vec4 p) {
&nbsp;&nbsp;&nbsp;&nbsp;p = projectionInverseMatrix * p;
&nbsp;&nbsp;&nbsp;&nbsp;return p / p.w;
}

vec4 createPlane(vec4 b, vec4 c) {
&nbsp;&nbsp;&nbsp;&nbsp;// standard plane equation, with a at (0, 0, 0)
&nbsp;&nbsp;&nbsp;&nbsp;return vec4(normalize(cross(c.xyz, b.xyz)), 1.0);
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;uint index = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;

&nbsp;&nbsp;&nbsp;&nbsp;if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// first tile the screen and build the frustum for the current tile
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 renderTargetSize = vec2(FROXEL_RESOLUTION * gl_NumWorkGroups.xy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 frustumMin = vec2(FROXEL_RESOLUTION * gl_WorkGroupID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 frustumMax = vec2(FROXEL_RESOLUTION * (gl_WorkGroupID.xy + 1u));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corners[0] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustumMin.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(renderTargetSize.y - frustumMin.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corners[1] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustumMax.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(renderTargetSize.y - frustumMin.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corners[2] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustumMax.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(renderTargetSize.y - frustumMax.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corners[3] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustumMin.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(renderTargetSize.y - frustumMax.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint froxelSlice = gl_WorkGroupID.z;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minMaxZ = vec2(0.0, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (froxelSlice &gt; 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minMaxZ.x = exp2((float(froxelSlice) - depthParams.y) * depthParams.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* depthParams.w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minMaxZ.y = exp2((float(froxelSlice + 1u) - depthParams.y) * depthParams.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* depthParams.w;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 frustum[4];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustum[0] = projectionToView(corners[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustum[1] = projectionToView(corners[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustum[2] = projectionToView(corners[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frustum[3] = projectionToView(corners[3]);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;froxels.data[index].plane0 = createPlane(frustum[0], frustum[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;froxels.data[index].plane1 = createPlane(frustum[1], frustum[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;froxels.data[index].plane2 = createPlane(frustum[2], frustum[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;froxels.data[index].plane3 = createPlane(frustum[3], frustum[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;froxels.data[index].minMaxZ = minMaxZ;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
						<ul>
							<li>
								<p>
                                    The second compute shader, runs every frame (if the camera and/or lights have changed) and assigns all the lights to their respective froxels.
								</p>
								<ul>
									<li>
										<p>
                                            Light index buffer
										</p>
										<ul>
											<li>
												<p>
                                                    For each froxel, the index of each light that affects said froxel. The indices for point lights are written first and if there is enough space left, the indices for spot lights are written as well. A sentinel of value 0√ó7fffffffu separates point and spot lights and/or marks the end of the froxel's list of lights. Each froxel has a maximum number of lights (point + spot).
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Point lights buffer
										</p>
										<ul>
											<li>
												<p>
                                                    Array of structures describing the scene's point lights.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Spot lights buffer
										</p>
										<ul>
											<li>
												<p>
                                                    Array of structures describing the scene's spot lights.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Froxels buffer
										</p>
										<ul>
											<li>
												<p>
                                                    The list of froxels represented by planes, created by the previous compute shader.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
<pre><code class="language-glsl" data-lang="glsl">#version 310 es
precision highp float;
precision highp int;

#define LIGHT_BUFFER_SENTINEL 0x7fffffffu
#define MAX_FROXEL_LIGHT_COUNT 32u

#define THREADS_PER_FROXEL_X 8u
#define THREADS_PER_FROXEL_Y 8u
#define THREADS_PER_FROXEL_Z 1u
#define THREADS_PER_FROXEL (THREADS_PER_FROXEL_X * \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THREADS_PER_FROXEL_Y * THREADS_PER_FROXEL_Z)

layout(local_size_x = THREADS_PER_FROXEL_X,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_size_y = THREADS_PER_FROXEL_Y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_size_z = THREADS_PER_FROXEL_Z) in;

// x = point lights, y = spot lights
layout(location = 0) uniform uvec2 totalLightCount;
layout(location = 1) uniform mat4 viewMatrix;

layout(binding = 0, packed) writeonly restrict buffer LightIndexBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;uint index[];
} lightIndexBuffer;

struct PointLight {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 positionFalloff; // x, y, z, falloff
&nbsp;&nbsp;&nbsp;&nbsp;vec4 colorIntensity;&nbsp;&nbsp;// r, g, b, intensity
&nbsp;&nbsp;&nbsp;&nbsp;vec4 directionIES;&nbsp;&nbsp;&nbsp;&nbsp;// dir x, dir y, dir z, IES profile index
};

layout(binding = 1, std140) readonly restrict buffer PointLightBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;PointLight lights[];
} pointLights;

struct SpotLight {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 positionFalloff; // x, y, z, falloff
&nbsp;&nbsp;&nbsp;&nbsp;vec4 colorIntensity;&nbsp;&nbsp;// r, g, b, intensity
&nbsp;&nbsp;&nbsp;&nbsp;vec4 directionIES;&nbsp;&nbsp;&nbsp;&nbsp;// dir x, dir y, dir z, IES profile index
&nbsp;&nbsp;&nbsp;&nbsp;vec4 angle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // angle scale, angle offset, unused, unused
};

layout(binding = 2, std140) readonly restrict buffer SpotLightBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;SpotLight lights[];
} spotLights;

struct Froxel {
&nbsp;&nbsp;&nbsp;&nbsp;// NOTE: the planes should be stored in vec4[4] but the
&nbsp;&nbsp;&nbsp;&nbsp;// Adreno shader compiler has a bug that causes the data
&nbsp;&nbsp;&nbsp;&nbsp;// to not be read properly inside the loop
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane0;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane1;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane2;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 plane3;
&nbsp;&nbsp;&nbsp;&nbsp;vec2 minMaxZ;
};

layout(binding = 3, std140) readonly restrict buffer FroxelBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;Froxel data[];
} froxels;

shared uint groupLightCounter;
shared uint groupLightIndexBuffer[MAX_FROXEL_LIGHT_COUNT];

float signedDistanceFromPlane(vec4 p, vec4 plane) {
&nbsp;&nbsp;&nbsp;&nbsp;// plane.w == 0.0, simplify computation
&nbsp;&nbsp;&nbsp;&nbsp;return dot(plane.xyz, p.xyz);
}

void synchronize() {
&nbsp;&nbsp;&nbsp;&nbsp;memoryBarrierShared();
&nbsp;&nbsp;&nbsp;&nbsp;barrier();
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groupLightCounter = 0u;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memoryBarrierShared();

&nbsp;&nbsp;&nbsp;&nbsp;uint froxelIndex = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
&nbsp;&nbsp;&nbsp;&nbsp;Froxel current = froxels.data[froxelIndex];

&nbsp;&nbsp;&nbsp;&nbsp;uint offset = gl_LocalInvocationID.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl_LocalInvocationID.y * THREADS_PER_FROXEL_X;
&nbsp;&nbsp;&nbsp;&nbsp;for (uint i = 0u; i &lt; totalLightCount.x &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groupLightCounter &lt; MAX_FROXEL_LIGHT_COUNT &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset + i &lt; totalLightCount.x; i += THREADS_PER_FROXEL) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint currentLight = offset + i;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 center = pointLights.lights[currentLight].positionFalloff;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;center.xyz = (viewMatrix * vec4(center.xyz, 1.0)).xyz;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float r = inversesqrt(center.w);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (-center.z + r &gt; current.minMaxZ.x &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-center.z - r &lt;= current.minMaxZ.y) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signedDistanceFromPlane(center, current.plane0) &lt; r &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signedDistanceFromPlane(center, current.plane1) &lt; r &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signedDistanceFromPlane(center, current.plane2) &lt; r &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signedDistanceFromPlane(center, current.plane3) &lt; r) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint index = atomicAdd(groupLightCounter, 1u);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groupLightIndexBuffer[index] = currentLight;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;synchronize();

&nbsp;&nbsp;&nbsp;&nbsp;uint pointLightCount = groupLightCounter;
&nbsp;&nbsp;&nbsp;&nbsp;offset = froxelIndex * MAX_FROXEL_LIGHT_COUNT;

&nbsp;&nbsp;&nbsp;&nbsp;for (uint i = gl_LocalInvocationIndex; i &lt; pointLightCount;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += THREADS_PER_FROXEL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lightIndexBuffer.index[offset + i] = groupLightIndexBuffer[i];
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pointLightCount &lt; MAX_FROXEL_LIGHT_COUNT) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lightIndexBuffer.index[offset + pointLightCount] = LIGHT_BUFFER_SENTINEL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    On CPU:
				</p>
				<ul>
					<li>
						<p>
                            The algorithm is different from the GPU implementation. Instead of iterating over every light for each froxel, the engine will ‚Äúrasterize‚Äù each light as froxels. For instance, given a point light‚Äôs center and radius, it is trivial to compute the list of froxels it intersects with.
						</p>
					</li>
					<li>
						<p>
                            This technique has the added benefit of providing tighter culling than in the GPU variant. The CPU implementation can also more easily generate a packed list of lights.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="culling" >
    Culling
</h5>
<ul>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Point light
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250922210816.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Our light sources are typically artist placed, scaled for human environments in an outdoor world, so generally speaking from meters to tens of meters. So a light source generally intersects many clusters. The typical sphere-frustum tests that you can find online are not suitable for this sort of culling. They are made for view-frustum culling and based on the assumption that the frustum typically is much larger than the sphere, which is the opposite of what we have here. Typically they simply test sphere vs plane for each six planes of the frustum. This is conservative, but lets through spheres that aren‚Äôt completely behind any of the planes, such as in the frustum corners. The result you get is that green rectangle, or essentially a ‚Äùcube‚Äù of clusters around the light. But that‚Äôs also the first thing we compute. We simply compute the screen-space and depth extents of the light analytically first, so this test doesn‚Äôt actually help anything at all after that.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922210849.png" width="350" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Most frustum culling code is written with the scenario on the left in mind. We need to handle the scenario on the right.
						</p>
					</li>
					<li>
						<p>
                            One way to go about frustum culling is testing all planes, all edges and all vertices. This would work, but be too costly to outweigh the gains from fewer false positives. A fast, conservative but relatively tight solution is what we are looking for. There are many approaches that seem fitting, but there are also many complications, which has ultimately thrown many of our attempts into the garbage bin. One relatively straightforward approach is to cull against the cluster‚Äôs AABB. This is fast and gives fairly decent results, but it‚Äôs possible to do better.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922211034.png" width="300" >
                            &nbsp;
                            <img src="assets/image_20250922211119.png" width="124" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Starting with the ‚Äùcube‚Äù of clusters around the light, in our outer loop we iterate over the slices in z direction. We intersect the sphere with the slice where it is the widest. This results in a circle of a smaller radius than the original sphere, we thus continue in the y direction using a sphere of this smaller radius and the circle‚Äôs midpoint. In the center slice we simply proceed with the original sphere. We repeat this procedure in y and have an even smaller sphere. Then in the inner loop we do plane vs. sphere tests in x direction to get a strip of clusters to add the light to.
						</p>
					</li>
					<li>
						<p>
                            To optimize all the math we take advantage of the fact that in view-space, all planes will have components that are zero. A plane in the x direction will have zero y and offset, y direction has zero x and offset, and z-direction is basically only a z offset.
						</p>
					</li>
					<li>
						<p>
                            The resulting culling is somewhat tighter than a plain AABB test, and costs about the same. Where AABB culls around 15-25%, this technique culls around 20-30% from the ‚Äúcube‚Äù of clusters.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922211134.png" width="400" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Spotlight
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            For spotlights we begin by finding the ‚Äùcube‚Äù of clusters around the light‚Äôs sphere, just like for pointlights, except this cube typically is much larger than necessary for a spotlight. However, this analytical test is cheap and goes a long way to limit the search space for following passes. Next we find a tighter ‚Äùcube‚Äù simply by scanning in all six directions, narrowing it down by doing plane-cone tests. There is likely a neat analytical solution here, but this seemed non- trivial. Given that the plane scanning works fine and is cheap we haven‚Äôt really explored that path.
						</p>
					</li>
					<li>
						<p>
                            Note that our cones are sphere-capped rather than flat-capped. That‚Äôs because the light attenuation is based on distance (as it should), rather than depth. Sphere-capped cones also generally behave much better for wide angles and doesn‚Äôt become extremely large as flat-capped cones can get.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922211251.png" width="350" >
                            <img src="assets/image_20250922211332.png" width="125" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Finally, for the remaining ‚Äùcube‚Äù of clusters we cull each cluster with a sphere-capped cone vs. bounding sphere test. For this to work well we have to have relatively cubical shaped clusters, otherwise the bounding sphere becomes way oversized. Overall this technique results in a moderately tight culling that is good enough for us so far, although there is room for some minor improvement.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="shading" >
    Shading
</h5>
<ul>
	<li>
		<p>
            Shading differs from Tiled Shading only in how we look up the cluster for the view sample in question.
		</p>
	</li>
	<li>
		<p>
            For Tiled Shading, a simple 2D lookup, based on the screen-space coordinates, is sufficient to retrieve light-list offset and count. However, for clustered approaches, there no longer exists a direct mapping between the cluster key and the index into the list of unique clusters.
		</p>
	</li>
	<li>
		<p>
            In the sorting approach, we explicitly store this index for each pixel. This is achieved by tracking references back to the originating pixel, and, when the unique cluster list is established, storing the index to the correct pixel in a full screen buffer.
		</p>
	</li>
	<li>
		<p>
            When using page tables, after the unique clusters are found, we store the cluster index back to the physical memory location used to store the cluster key earlier (using the same page table as before). This means that a virtual lookup for the cluster key will yield the cluster index. Thus, each sample can look up the cluster index using the cluster key computed earlier (or re-computed).
		</p>
	</li>
</ul>
<h5
	id="cluster-key-packing" >
    Cluster Key Packing
</h5>
<ul>
	<li>
		<p>
            For maximum performance when using sorting or page tables, we wish to pack the cluster key into as few bits as possible. We allocate 8 bits to each i and j components, which identify the screen-space tile the cluster belongs to. This allows up to 8192 √ó 8192 size render targets (assuming screen-space tile size of 32 √ó 32 pixels). The depth index k is determined from settings for the near and far planes and Equation 2. In our scenes, we found 10 bits to be sufficient. This leaves up to 6 bits for the optional normal clustering. Using 6 bits, we can for instance support a resolution up to 3 √ó 3 subdivisions on each cube face (3 √ó 3 √ó 6 = 54 and dlog2 54e = 6). For more restricted environments, the data could be packed more aggressively, saving both time and space.
		</p>
	</li>
</ul>
<h5
	id="tile-sorting" >
    Tile sorting
</h5>
<ul>
	<li>
		<p>
            To the cluster key (between 10 and 16 bits wide) we attach an additional 10 bits of meta-data, which identifies the sample‚Äôs original position relative to its tile. We then perform a tile-local sort of the cluster keys and the associated meta-data. The sort only considers the up-to 16 bits of the cluster key; the meta-data is used as a link back to the original sample after sorting. In each tile, we count the number of unique cluster keys. Using a prefix operation over the counts from each tile, we find the total number of unique cluster keys and assign each cluster a unique ID in the range 
            <code>[0...numClusters)</code>
            . We write the unique ID back to each pixel that is a member of the cluster. The unique ID also serves as an offset in memory to where the cluster‚Äôs data is stored.
		</p>
	</li>
	<li>
		<p>
            Bounding volumes (AABB and normal cone) can be re-constructed from the cluster keys, in which case each cluster only needs to store its cluster key. For explicit bounding volumes, we additionally store the AABB and/or normal cone. The explicit bounding volumes are computed using a reduction operation: for instance, AABBs can be found using a min- and a max-reduction operation on the sample positions. The meta-data from the locally sorted cluster keys gives us information on which samples belong to a given cluster.
		</p>
	</li>
</ul>
<h5
	id="shadows" >
    Shadows
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.cse.chalmers.se/~uffe/ClusteredWithShadows.pdf" 
				class="external-link" 
				target="_blank" >
                Efficient Virtual Shadow Maps for Many Lights - Ola Olsson - 2014
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This paper builds on clustered shading.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922212154.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Etc
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I saw this in some paper and left it loose; maybe I‚Äôll revisit it later.
				</p>
			</li>
			<li>
				<p>
                    Resolution Matched Shadow Maps (RMSM), must determine which shadow pages are used by the view samples. The method achieves this by first exploiting screen space coherency to reduce duplicate requests from adjacent pixels in screen space. Globally unique requests are then determined by sorting and compacting the remaining requests.
				</p>
			</li>
			<li>
				<p>
                    Garanzha present a similar technique that they call Compress-Sort-Decompress (CSD). Their goal is to find 3D (or 5D) clusters in a frame buffer, which are used to form ray packets. The main differences are that Garanzha et al. treat the frame buffer as a 1D sequence and use run length encoding (RLE) to reduce duplicates before sorting. They expand the result after the sorting.
				</p>
			</li>
			<li>
				<p>
                    The approaches in both RMSMs and CSD rely on the presence of coherency between adjacent input elements, in 2D and 1D respectively. In many cases, this is a reasonable assumption. However, techniques such as multi sampling anti aliasing (MSAA) with alpha-to-coverage, or stochastic transparency, invalidate this assumption. Coherency is still present in the frame buffer, but not between adjacent samples. For scenes with low coherence between adjacent samples, both of these methods degenerate to sorting the entire frame buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It has even been stated that shadow maps are unsuited for many lights. However, when limiting the problem as I have just done, there really is no fundamental reason against shadow maps. And given that they are the de facto standard in the real-time industry, they must clearly be the first stop, if nothing else to provide a benchmark for more clever ideas.
		</p>
	</li>
	<li>
		<p>
            To create shadow maps, we need to perform the following steps each frame, using the current camera view:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250923080409.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    The first step is the same as determining what lights are needed for shading, and we have already seen how this can be achieved using clustered shading and other methods.
				</p>
			</li>
			<li>
				<p>
                    The last step is also fairly trivial, using 
					<em>
                        bindless textures
					</em>
                    , 
					<em>
                        array textures
					</em>
                    &nbsp;or 
					<em>
                        shadow map atlases
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081229.png" width="250" >
                    <img src="assets/image_20250923081212.png" width="250" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081156.png" width="250" >
                    <img src="assets/image_20250923081136.png" width="250" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081256.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    As we saw before, the shadow map samples can be very tightly grouped, requiring a high shadow map resolution And note how this happens when most of the shadow map would be unused! This is pretty much how it has to be, as the high density comes from looking at something very near the camera, and then we‚Äôre guaranteed to not see so very much of the scene. This is highly wasteful and a fantastic opportunity, for...
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081059.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Keyword: Virtual Shadow Maps (Virtual SMs).
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            See pages 181 to 195 of 
							<a
								href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
								class="external-link" 
								target="_blank" >
                                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
							</a>
                            &nbsp;for more information.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081545.png" width="377" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In other terms, this means the difference between impossible on a current console and something we might consider.
				</p>
			</li>
			<li>
				<p>
                    Our method achieves quite uniform shadow quality, this means we can control quality and thus memory usage with a global parameter. This allows more flexibility in memory use while maintaining uniform quality. An interesting idea is to do this dynamically, to ensure a certain memory budget. Should be possible as it is very quick to work out memory usage from the used pages and resolutions.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081724.png" width="400" >
                    <img src="assets/image_20250923081802.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Recall that the peak is 322MB without reducing quality.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Cull Shadow Cast Geometry
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            This process is just like normal view frustum culling, in that we are trying to get rid of geometry that is not visible, and that we do this by testing bounding volumes of chunks or batches of triangles.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923081907.png" width="300" >
                            <img src="assets/image_20250923082134.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            What is not like view frustum culling is that we need to perform hundreds of these tests. The view volumes are quite small, or short, given the limited range of the lights. There are 6 adjacent frustra sharing planes. This adjacency means we can share calculations.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082259.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Here is the somewhat condensed code we use to calculate the culling mask, with a bit for each cube face. This is a very efficient test, checking only 6 planes for six frustums. Especially as the plane equations are all ones and zeroes, which means that if the loop is unrolled, most of this code just goes away. I think this is a rather big advantage with cube maps, over using separate frustums (As done in [6]). This efficiency is especially important given that we will be culling a lot more objects than normal culling!
						</p>
					</li>
					<li>
						<p>
                            You see, to enable efficient culling, batches must be small. Intuitively, for any culling, the optimal size of batches correlates to the size of the frustums. If batches are too large, the triangles get replicated into most cube faces.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082424.png" width="350" >
                            .
						</p>
					</li>
					<li>
						<p>
                            So we are trading increased culling work for fewer triangles drawn. Triangle drawing is the biggest performance bottleneck so this is important to be able to tune.
						</p>
					</li>
					<li>
						<p>
                            We used batches of up to 128 triangles, in practice they average around 68 triangles. A batch is represented by an AABB and a list of triangles. The batches are constructed in a pre-process, that builds a tree using agglomerative clustering (see the paper section 6.2.1). Note that the quality of the batches is fairly important for good performance. The batches are stored in a flat array that is loaded into the runtime.
						</p>
						<ul>
							<li>
								<p>
									<input
										type="checkbox" 
										disabled=""
>
                                    These values remind me of &quot;clusters in the rabbit&quot;. See Optimization Techniques -&gt; Cluster.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082534.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082807.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            For efficient culling, we obviously need a hierarchy.
						</p>
					</li>
					<li>
						<p>
                            The important thing is to balance the time spent building and traversing an acceleration structure. This trade-off has been studied by Karras and Aila in context of ray tracing, and is a very interesting read. In short, it suggests to me that the acceleration structure for just a few thousand box queries must be pretty bad to be worth building.
						</p>
					</li>
					<li>
						<p>
                            We used a very simple, full, 32-way BVH which is completely rebuilt each frame. This is in no way the best possible structure, or even the fastest to build, but it has served us well.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082902.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Here we parallelize the lights, and each light traverses the hierarchy to find the batches that overlap the sphere. These batches are those that may produce a shadow if drawn into the shadow map.
						</p>
					</li>
					<li>
						<p>
                            This produces a list for each light of pairs of cube face masks and batch indexes. The Cube Face Mask is a bit mask where each bit indicates if it overlaps a certain cube face. This tells us what batches to draw to which cube faces of each light.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083025.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083139.png" width="300" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Green: source light BB.
								</p>
							</li>
							<li>
								<p>
                                    Black: Shadow casters.
								</p>
							</li>
							<li>
								<p>
                                    Blue: Clusters containing samples.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Note that the shadow casters are outside of the view volume, and so have no clusters associated, but cast their shadow through the view volume. So we‚Äôre interested in finding out what shadows affect the visible samples, and thus determine if the shadow caster needs to be drawn.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083317.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Instead of doing some crazy thing, like shadow volumes, we can figure this out by projecting the shadow caster onto the light source. This gives us these two intervals on the cube face.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083405.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Doing the same thing for the clusters, gives us another interval. If the projection of a shadow caster overlaps that of some clusters, i.e. shadow receiver, ‚Ä¶it needs to be rendered into this shadow map, else, it doesn‚Äôt. Note that the clusters don‚Äôt need to form a range for this to work, any overlap will do.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            The subject continues from pages 225 to 243 of 
							<a
								href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
								class="external-link" 
								target="_blank" >
                                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    I found it quite specific and complicated to implement, for something I'm not focusing on right now.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Classic deferred has the advantage that you can iterate light by light, and thus reuse resources such as shadow buffers in between. This saves some memory, which may be needed on current generation consoles. On PC and next-generation consoles this is not nearly as big a problem.
				</p>
			</li>
			<li>
				<p>
                    With the switch to clustered shading the cost of adding a new light to the scene is small. Artists can now be moderate ‚Äùwasteful‚Äù without causing much problems performance-wise. This is not true for rasterizing shadow buffers. They remain expensive, and relatively speaking going to be more expensive going forward since it‚Äôs often a ROP-bound process, and ROPs aren‚Äôt getting scaled up nearly as much as ALU. So we still need to be a bit conservative about how many shadow casting lights we add to the scene.
				</p>
			</li>
			<li>
				<p>
                    An observation that was made is that artists often place very similar looking lights close to each other. In some cases it is to get a desired profile of a light, in which case the two lights may in fact be centered at the exact same point. But often it is motivated by the real world, such as two headlights on car. Some vehicles actually have ten or more lights, all pointing in the same general direction. Rendering ten shadow buffers for that may prove to be far too expensive.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922211554.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Often it works just fine to share a single shadow buffer for these lights. While the shadow may be slightly off, this is usually not something that you will notice unless you are specifically looking for it. To make this work the shadow buffer is decoupled from lights and the light is assigned a shadow buffer and frustum from which to extract shadows. The shadow frustum has to be large enough to include all the different lights that uses it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="transparency" >
    Transparency
</h5>
<ul>
	<li>
		<p>
            When the transparent geometry is considered, the depth range optimization cannot be fully used. Instead, only a more conventional hierarchical depth test can be used. The grid structure can be built once, and quickly pruned to prepare a more efficient instance for opaque geometry. However, as each transparent layer must consider all the lights in the tile, performance does not scale linearly with the depth complexity, but far worse.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922170304.png" width="209" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            To improve on this we extend clustered forward shading by constructing the grid using a 
			<em>
                pre-pass over all geometry
			</em>
            &nbsp;(not just opaque), and flagging clusters as a side effect. This allows us to quickly find the unique clusters used.
		</p>
	</li>
	<li>
		<p>
            As clusters contain only space around actual samples that need shading, efficiency is much better.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922170026.png" width="212" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For deferred shading a single 1080p, 16x MSAA, 16-bit float RGBA buffer requires over 250Mb of memory. In addition, each sample may need to be shaded individually, effectively running shading at a per-sample frequency.
		</p>
	</li>
	<li>
		<p>
            For forward shading, no G-Buffers are required and MSAA is trivially enabled.
		</p>
	</li>
</ul>
<h5
	id="optimized-forward-renderer" >
    Optimized Forward Renderer
</h5>
<ul>
	<li>
		<p>
			<strong>
                High-level overview
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909094633.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909094044.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909094439.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Performance caveats
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909094750.png" width="650" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Triangle Overshading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909095017.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909095147.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="papers-and-presentations" >
    Papers and Presentations
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://google.github.io/filament/Filament.html.html#imagingpipeline/lightpath" 
				class="internal-link" 
				target="_self" >
                Clustered Forward Shading - PBR Filament
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://google.github.io/filament/Filament.html.html#annex/lightassignmentwithfroxels" 
				class="internal-link" 
				target="_self" >
                Froxel Generation - PBR Filament
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf" 
				class="external-link" 
				target="_blank" >
                Clustered Deferred and Forward Shading - Ola Olsson - 2012
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.researchgate.net/profile/Ulf-Assarsson/publication/254463291_Tiled_and_Clustered_Forward_Shading_Supporting_Transparency_and_MSAA/links/55f6cdb608aeba1d9eed7fc6/Tiled-and-Clustered-Forward-Shading-Supporting-Transparency-and-MSAA.pdf?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uIn19" 
				class="external-link" 
				target="_blank" >
                Tiled and Clustered Forward Shading Supporting Transparency and MSAA - Ola Olsson - 2012
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
				class="external-link" 
				target="_blank" >
                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Avalanche Studios did:
				</p>
				<ul>
					<li>
						<p>
                            Just Cause 1 (Forward), Just Cause 2 (Forward), Mad Max (Deferred).
						</p>
					</li>
					<li>
						<p>
                            Just Cause 3, Just Cause 4, Generation Zero, Rage 2.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.aortiz.me/2018/12/21/CG.html" 
				class="external-link" 
				target="_blank" >
                A Primer On Efficient Rendering Algorithms &amp; Clustered Shading - Angel Ortiz - Rockstar North - 2018
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Part 2 explains the implementation of the technique.
				</p>
			</li>
			<li>
				<p>
                    Great read, pretty good, with some implementation explanations and source code in OpenGL.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://github.com/DaveH355/clustered-shading" 
				class="external-link" 
				target="_blank" >
                Cluster Shading OpenGL - David Hu - 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is not a sample, just a C++ and OpenGL tutorial with some GLSL shaders for reference.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.gdcvault.com/play/1025420/Cluster-Forward-Rendering-and-Anti" 
				class="external-link" 
				target="_blank" >
                Clustered Forward Rendering and Anti-Aliasing in Detroit: Become Human - GDC 2018
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/" 
				class="external-link" 
				target="_blank" >
                Doom (2016) - Graphics Study - Adrian Courreges - 2016
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://pt.slideshare.net/slideshow/siggraph2016-the-devil-is-in-the-details-idtech-666/64714659" 
				class="external-link" 
				target="_blank" >
                Doom (2016) - The Devil is in the Details - Siggraph 2016
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbExyYm9nWElMSzhBTDFtMVVVMHRiNFpxUGRhd3xBQ3Jtc0trRkVqekVNa2NzUy0xZHRFM2lLdERTOUR1amVPcUtEVERiZ1JTeGowdEtZNUx0Y2ZKUUxoT2dwOGJDcEVCNGlMQm1SQmxWT21wQkpaWk5LZWVOeldQWXJzbWFKNzMtRmFVcVE3d1JLVTdVamk1VUdZVQ&q=https%3A%2F%2Fadvances.realtimerendering.com%2Fs2020%2FRenderingDoomEternal.pdf&v=QVbOp1h-Jb4" 
				class="external-link" 
				target="_blank" >
                Rendering the Hellscape of Doom Eternal - idTech - 2020
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="http://advances.realtimerendering.com/s2017/2017_Sig_Improved_Culling_final.pdf" 
				class="external-link" 
				target="_blank" >
                Improved Culling for Tiled and Clustered Rendering - Michal Drobot / Call of Duty / Activision - Siggraph 2017
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://wickedengine.net/2019/02/thoughts-on-light-culling-stream-compaction-vs-flat-bit-arrays/" 
						class="external-link" 
						target="_blank" >
                        Thoughts on Light Culling: Stream Compaction vs Flat Bits Array - Wicked Engine 2019
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.adriancourreges.com/blog/" 
				class="external-link" 
				target="_blank" >
                Graphics Studies compilation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            ~
			<a
				href="https://www.3dgep.com/volume-tiled-forward-shading/" 
				class="external-link" 
				target="_blank" >
                Volume Tiled Forward Shading - Jeremiah Van Oosten - 2017
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Supposedly: Volume &gt; Clustered &gt; Tiled.
				</p>
			</li>
			<li>
				<p>
                    Volume Tiled Forward Shading is based on Tiled and Clustered Forward Shading from Ola Olsson.
				</p>
			</li>
			<li>
				<p>
                    By first constructing a Bounding Volume Hierarchy (BVH) over the lights, we can achieve millions of light sources while maintaining real-time frame rates.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=nyItqF3sM84" 
						class="external-link" 
						target="_blank" >
                        Demo - Jeremiah Van Oosten - 2017
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            So... it seems the only thing he did was add BVH to the technique, however that seems to already be done by default in the culling part of Clustered Shading....
						</p>
					</li>
					<li>
						<p>
                            I don't understand. Did someone copy someone here? I'm confused...
						</p>
					</li>
					<li>
						<p>
                            His master's thesis is huge, but much of it is kind of &quot;padding&quot;, as it's just a presentation of previous works.
						</p>
					</li>
					<li>
						<p>
                            Hmmm idk. He's not wrong, it just sounds odd.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.humus.name/Articles/PracticalClusteredShading.pdf" 
				class="external-link" 
				target="_blank" >
                Practical Clustered Shading - Avalanche Studios 2015
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Exactly the same presentation as 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014'; see that presentation, since it has presenter comments.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbEl2WGFDbXJ1S2hUYmZZdzFraFpIY3g5TnNLd3xBQ3Jtc0ttVHBlNTRRaEcwVXdXRXlCUkdrQzViWWNZRmhwbHNscFNzMTJwN19pX0lySjRuSG1lMkFubVZMZlVIUHNzWnJEcEJQUTNmNDBiRnlPb1ZUTkVjUkV0dlYtN3NTU0xvbi1PZWgzblpJbEF0UkV1T05JTQ&q=http%3A%2F%2Fnewq.net%2Fdl%2Fpub%2FSA2014Practical.pdf&v=QVbOp1h-Jb4" 
				class="external-link" 
				target="_blank" >
                Practical Clustered Shading 2/4 - Avalanche Studios - 2014
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    The presentation comes after 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014', since Just Cause 3 had already been announced, using Clustered Shading.
				</p>
			</li>
			<li>
				<p>
                    The presentation is very similar to 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014'.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/watch?v=uEtI7JRBVXk" 
				class="external-link" 
				target="_blank" >
                Managing many lights in real time with clustered shading - Ola Olsson 2016
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Based on the 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014' presentation, with basically no changes.
				</p>
			</li>
			<li>
				<p>
                    I preferred to read the former, for better slide visibility and because the presentation is much more in-depth. Also, the earlier presentation seemed to have more enthusiasm and depth; perhaps the audience for this presentation did not show much enthusiasm.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="samples" >
    Samples
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Angelo1211/HybridRenderingEngine/tree/master" 
				class="external-link" 
				target="_blank" >
                HybridRenderingEngine OpenGL (Clustered Forward/Deferred) - Sample - Angel Ortiz - 2018
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Clustered Forward/Deferred Renderer
				</p>
			</li>
			<li>
				<p>
                    Physically Based shading
				</p>
			</li>
			<li>
				<p>
                    Image Based Lighting
				</p>
			</li>
			<li>
				<p>
                    Metallic workflow
				</p>
			</li>
			<li>
				<p>
                    Cook-Torrance specular BRDF (w/ lambert diffuse)
				</p>
			</li>
			<li>
				<p>
                    Ambient Occlusion &amp; Emissive mapping
				</p>
			</li>
			<li>
				<p>
                    Tangent space normal mapping
				</p>
			</li>
			<li>
				<p>
                    HDR/linear lighting
				</p>
			</li>
			<li>
				<p>
                    HDR/LDR skyboxes
				</p>
			</li>
			<li>
				<p>
                    Exposure based tone mapping
				</p>
			</li>
			<li>
				<p>
                    Bloom
				</p>
			</li>
			<li>
				<p>
                    Multisample Anti-aliasing (MSAA)
				</p>
			</li>
			<li>
				<p>
                    Directional &amp; point light sources
				</p>
			</li>
			<li>
				<p>
                    Compute shader based light culling
				</p>
			</li>
			<li>
				<p>
                    Alpha tested foliage (sponza atrium)
				</p>
			</li>
			<li>
				<p>
                    Directional light dynamic shadow mapping
				</p>
			</li>
			<li>
				<p>
                    Static Omnidirectional Shadow Mapping for Point Lights
				</p>
			</li>
			<li>
				<p>
                    Forward, Tiled Forward and Deferred rendering implementations
				</p>
				<ul>
					<li>
						<p>
                            Located in other branches of the repo. Only clustered rendering is actively being developed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Engine:
				</p>
				<ul>
					<li>
						<p>
                            OpenGL 4.5+
						</p>
					</li>
					<li>
						<p>
                            SDL2 backend
						</p>
					</li>
					<li>
						<p>
                            JSON Parsing via Nlohmann: JSON for C++
						</p>
					</li>
					<li>
						<p>
                            Model Loading via ASSIMP (OBJ, FBX, gLTF2.0 etc)
						</p>
					</li>
					<li>
						<p>
                            Scene contents clearly outlined in JSON file
						</p>
					</li>
					<li>
						<p>
                            Multiple image loading paths via stb-image and GLI
						</p>
					</li>
					<li>
						<p>
                            Immediate mode GUI for debugging via ImGUI
						</p>
					</li>
					<li>
						<p>
                            Fully commented for future referencing
						</p>
					</li>
					<li>
						<p>
                            Environment map generation on load for IBL and skyboxes
						</p>
					</li>
					<li>
						<p>
                            Free flight camera
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="deferred-shading" >
    Deferred Shading
</h3>
<h4
	id="deferred" >
    Deferred
</h4>
<ul>
	<li>
		<p>
            Deferred shading is a screen-space shading technique that is performed on a second rendering pass, after the vertex and pixel shaders are rendered.
		</p>
	</li>
	<li>
		<p>
            &quot;I like to call it a &quot;fake rendering&quot;, as at the end of the day you'll be just doing your shading on a quad, not on the geometry&quot;.
		</p>
	</li>
	<li>
		<p>
            A shader that collects all geometry information into buffers, matches the first stage of a deferred renderer.
		</p>
	</li>
	<li>
		<p>
			<strong>
                GBuffer (&quot;Geometry Buffer&quot;)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    G-buffer is a set of textures or render targets used in deferred shading/rendering.
				</p>
			</li>
			<li>
				<p>
                    Instead of directly shading fragments during rasterization (as in forward rendering), the GPU first stores per-fragment data into the G-buffer.
				</p>
			</li>
			<li>
				<p>
                    A later pass (the lighting pass) reads from these buffers to compute lighting, shadows, reflections, etc.
				</p>
			</li>
			<li>
				<p>
                    A typical G-buffer contains attributes such as:
				</p>
				<ul>
					<li>
						<p>
                            World/eye space position of the fragment
						</p>
					</li>
					<li>
						<p>
                            Normals
						</p>
					</li>
					<li>
						<p>
                            Albedo (base color)
						</p>
					</li>
					<li>
						<p>
                            Specular properties
						</p>
					</li>
					<li>
						<p>
                            Possibly depth, roughness, metalness, etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The key point is: the first pass writes geometry information into multiple render targets (the G-buffer), and the second pass consumes it for lighting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909115633.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909120445.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909083205.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922174712.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The problem is from the fact that the innermost loop is over the pixels.
				</p>
			</li>
			<li>
				<p>
                    This requires repeated reading and writing of the G-Buffers and frame buffer.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="disadvantages" >
    Disadvantages
</h5>
<ul>
	<li>
		<p>
			<strong>
                Bandwidth
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909093834.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Consider marking non-persistent attachments as transient (
                    <code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code>
                    &nbsp;/ lazily allocated) so tile-based GPUs can keep them on-tile and reduce bandwidth.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transparency
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Inability to handle transparency within the algorithm, although this problem is a generic one in 
					<a
						href="https://en.wikipedia.org/wiki/Z-buffering" 
						class="external-link" 
						target="_blank" >
                        Z-buffered
					</a>
                    &nbsp;scenes and it tends to be handled by delaying and sorting the rendering of transparent portions of the scene.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://en.wikipedia.org/wiki/Depth_peeling" 
						class="external-link" 
						target="_blank" >
                        Depth peeling
					</a>
                    &nbsp;can be used to achieve 
					<a
						href="https://en.wikipedia.org/wiki/Order-independent_transparency" 
						class="external-link" 
						target="_blank" >
                        order-independent transparency
					</a>
                    &nbsp;in deferred rendering, but at the cost of additional batches and g-buffer size.
				</p>
			</li>
			<li>
				<p>
                    Modern hardware, supporting DirectX 10 and later, is often capable of performing batches fast enough to maintain interactive frame rates.
				</p>
			</li>
			<li>
				<p>
                    When order-independent transparency is desired (commonly for consumer applications) deferred shading is 
					<em>
                        no less
					</em>
                    &nbsp;effective than forward shading using the same technique.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909083851.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Example from GTA V.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Opaque is drawn with deferred renderer.
				</p>
			</li>
			<li>
				<p>
                    Transparent is drawn with forward renderer and then blended with the result of the deferred renderer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Difficulty with using multiple materials
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's possible to use many different materials, but it requires more data to be stored in the G-buffer, which is already quite large and takes up a large amount of the memory bandwidth.
				</p>
			</li>
			<li>
				<p>
                    Memory and bandwidth heavy (multiple render targets).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Another disadvantage of deferred shading is that only a single lighting model can be simulated in the lighting pass. This is due to the fact that it is only possible to bind a single pixel shader when rendering the light geometry. This is usually not an issue for pipelines that make use of √ºbershaders as rendering with a single pixel shader is the norm, however if your rendering pipeline takes advantage of several different lighting models implemented in various pixel shaders then it will be problematic to switch your rendering pipeline to use deferred shading.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Bad MSAA
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Due to separating the lighting stage from the geometric stage, hardware anti-aliasing (MSAA) does not produce correct results anymore since interpolated subsamples would result in nonsensical position, normal, and tangent attributes.
				</p>
			</li>
			<li>
				<p>
                    One of the usual techniques to overcome this limitation is using edge detection (MLAA, FXAA, DLAA, or post MSAA) on the final image and then applying blur over the edges. TAA can also be used.
				</p>
			</li>
			<li>
				<p>
                    DirectX 10 introduced features allowing shaders to access individual samples in multi-sampled render targets (and depth buffers in version 10.1), giving users of this API access to hardware anti-aliasing in deferred shading. These features also allow them to correctly apply HDR luminance mapping to anti-aliased edges, where in earlier versions of the API any benefit of anti-aliasing may have been lost.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Extra complexity
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    G-buffer packing, formats, reconstructing positions, light culling systems, extra render passes and descriptor management.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="variants" >
    Variants
</h5>
<ul>
	<li>
		<p>
            As said by Ola Olsson:
		</p>
	</li>
	<li>
		<p>
            Deferred Lighting
		</p>
		<ul>
			<li>
				<p>
                    Factor out specular and diffuse color.
				</p>
			</li>
			<li>
				<p>
                    G-Buffer only stores normal and shininess.
				</p>
			</li>
			<li>
				<p>
                    Output diffuse and specular shading.
				</p>
			</li>
			<li>
				<p>
                    Second geometry pass which multiple colors.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Light Prepass.
		</p>
		<ul>
			<li>
				<p>
                    Much like the above.
				</p>
			</li>
			<li>
				<p>
                    But with monochromatic specular highlight.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            They offer similar performance as deferred.
		</p>
	</li>
	<li>
		<p>
            Only improves constant factors.
		</p>
	</li>
	<li>
		<p>
            Limits shading model even further.
		</p>
	</li>
</ul>
<h4
	id="tiled-deferred" >
    Tiled Deferred
</h4>
<ul>
	<li>
		<p>
            Tiled deferred shading removes the bandwidth bottleneck from deferred shading, instead making the technique compute bound. This enables efficient usage of devices with a high compute-to-bandwidth ratio, such as modern consoles and GPUs. Modern high-end games are using tiled deferred shading to allow for thousands of lights, which are required to push the limits of visual fidelity.
		</p>
	</li>
	<li>
		<p>
            With large numbers of lights, GI effects can be produced that affect dynamic as well as static geometry.
		</p>
	</li>
	<li>
		<p>
            Steps:
		</p>
		<ol>
			<li>
				<p>
                    Render scene to G-Buffers.
				</p>
			</li>
			<li>
				<p>
                    Cluster assignment.
				</p>
			</li>
			<li>
				<p>
                    Find unique clusters.
				</p>
			</li>
			<li>
				<p>
                    Assign lights to clusters.
				</p>
			</li>
			<li>
				<p>
                    Shade samples.
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
            The first step, rendering the model to populate the G-Buffers, does not differ from traditional deferred shading or from tiled deferred shading. The second step computes for each pixel which cluster it belongs to according to its position (possibly normal). In the third step, we reduce this into a list of unique clusters. The fourth step, assigning lights to clusters, consists of efficiently finding which lights influence which of the unique clusters and produce a list of lights for each cluster. Finally, for each sample, these light lists are accessed to compute the sample‚Äôs shading.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175750.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175810.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175909.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Tiles in 1D, from side
				</p>
			</li>
			<li>
				<p>
                    View Frustum
				</p>
			</li>
			<li>
				<p>
                    4 subdivisions
				</p>
			</li>
			<li>
				<p>
                    Redline is geometry
				</p>
			</li>
			<li>
				<p>
                    Min and max depth per tile
				</p>
			</li>
			<li>
				<p>
                    Light range, rejected, completely hidden
				</p>
			</li>
			<li>
				<p>
                    Another rejected, completely in front
				</p>
			</li>
			<li>
				<p>
                    Rejected in one tile, not others
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
            Uncharted: Drake‚Äôs fortune.
		</p>
	</li>
	<li>
		<p>
            Battlefield 3.
		</p>
	</li>
	<li>
		<p>
            PlayStation 3.
		</p>
	</li>
	<li>
		<p>
            Xbox 360.
		</p>
	</li>
</ul>
<h5
	id="optimized-deferred-renderer" >
    Optimized Deferred Renderer
</h5>
<ul>
	<li>
		<p>
			<strong>
                High-level overview
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909093433.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            For SSR you need to take a lot of samples from G-Buffer B, and one sample from the shading color from the TAA pass.
						</p>
						<ul>
							<li>
								<p>
                                    We do the Raymarching using roughness and depth, once that is done we sample the TAA to get the final color.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            DOF: Depth of Field.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Compressing the GBuffer
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Optimized deferred shading renderer:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909091124.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Random person in the comments: There's a small typo - Normal should be G32 and Emissive should be B32.
						</p>
						<ul>
							<li>
								<p>
                                    Does it make sense? maybe?
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lights
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909091634.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909092350.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Decals
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909092522.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Clustered Decals &gt; D-Buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909092622.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909092646.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Post-processing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909093149.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=8rNl4A0qGao" 
				class="external-link" 
				target="_blank" >
                Demo and Source Code - Sascha Willems
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Based on my deferred shading example this new example adds shadows from multiple spotlights using shadow mapping. To avoid having multiple render passes for rendering the scene's depth from each of the light's point-of-view the example uses a layered depth attachment and multiple geometry shader invocations, so that an arbitrary number of depth maps can be generated in one pass. Each layer in the attachment corresponds to a light source and the geometry shader does multiple invocations on each vertex to output the scene into the different layers of the attachment. Each invocation uses a different light's mvp matrix. The final scene compositing pass then samples from the depth map array texture to determine if a fragment is shadowed or not.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/SaschaWillems/Vulkan?tab=readme-ov-file#Deferred" 
						class="external-link" 
						target="_blank" >
                        Source code
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=V7PxEpzkY1c" 
				class="external-link" 
				target="_blank" >
                Demo and Source Code
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/manuelpagliuca/deferred-render-vulkan" 
						class="external-link" 
						target="_blank" >
                        Source Code
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=RGM2eKVL30I" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Deferred lighting is physically based, using Cook-Torrance as the BRDF. In this demo the forward pass is only responsible for drawing the skybox, but could draw other rasterization pipelines not suitable for the deferred passes.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=g85DzhvRHXM" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=M9tOLSFXa5s" 
				class="external-link" 
				target="_blank" >
                Jonathan Blow's criticisms of Deferred Rendering
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    He bullshits and claims it's bad, unjustifiable.
				</p>
			</li>
			<li>
				<p>
                    &quot;Doesn't make sense in the modern day&quot;.
				</p>
			</li>
			<li>
				<p>
                    Counter-argument:
				</p>
				<ul>
					<li>
						<p>
                            Deferred is defined very very simply - do you have a G-buffer? If the answer is yes - you're deferred.
						</p>
					</li>
					<li>
						<p>
                            Pretty much all of high-performance forward renderers do a &quot;depth pre-pass&quot;, which is sort-of like &quot;deferred lite&quot;.
						</p>
					</li>
					<li>
						<p>
                            Forward has a huge benefit of being very bandwidth efficient, but it's very compute inefficient.
						</p>
					</li>
					<li>
						<p>
                            About transparencies - transparency is hard. Most forward renderers suck at transparency, most deferred suck as well. Forward makes it a bit easier, because your architecture is about the same.
						</p>
					</li>
					<li>
						<p>
                            About lighting, Jonathan Blow clearly is not a graphics engineer, there's tiled and clustered rendering that has existed since late 2000s which is typically called Forward+, same techniques are used in deferred, but hey man... the whole lighting argument is over a decade out of date.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Counter-argument:
				</p>
				<ul>
					<li>
						<p>
                            Deferred solves the problem of doing the pricey per-pixel calculations only on the pixels that will be visible in the end result. Which is why, contrary to what he said, basically every engine went deferred. I like the guy but this is maybe the worst take that I've ever heard him say? He doesn't really get why it's used AND he is wildly off the mark about its popularity in general. If anything, forward had a pretty big comeback with phones and VR.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Pro argument:
				</p>
				<ul>
					<li>
						<p>
                            Deferred rendering is an optimization technique to make lighting cheaper, but has massive complexity, VRAM, and image quality downsides. There's not really an upside besides being cheap to process many lights. There's a few ultra high end games that are slowly ditching deferred for forward+ systems. I think in a few years there's a good chance deferred won't be common. Even if raytracing doesn't happen.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Counter-argument:
				</p>
				<ul>
					<li>
						<p>
                            Forward+ still doesn't solve the problem of shadow casting lights. Deferred at least has lower overhead, so the bits of computing power go to shadow mapping purposes.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="clustered-deferred" >
    Clustered Deferred
</h4>
<ul>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922211739.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="adaptive-deferred-shading" >
    Adaptive Deferred Shading
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://youtu.be/9_v8cvd-BSQ?si=ZlpJkttRJFyc821O&t=3081" 
				class="external-link" 
				target="_blank" >
                Explanation by Cem Yuksel {51:21 -&gt; end}
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It's a selective way to choose what to perform shading on.
		</p>
	</li>
	<li>
		<p>
            He compared it with VRS while using deferred shading.
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-10-21 .&nbsp;&nbsp;2026-01-26 üöÄ
			</footer>
		</div>
		<script
			src="/static/studies.26909.js" >
		</script>
	</body>
</html>
