<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.42575.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
								<ul>
									<li>
										<a
											href="#terms" >
                                            Terms
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#techniques" >
                                            Techniques
										</a>
										<ul>
											<li>
												<a
													href="#parameterizations-sampling-layouts-for-the-sphere" >
                                                    Parameterizations / sampling layouts for the sphere
												</a>
											</li>
											<li>
												<a
													href="#directional-data-represent-or-approximate-functions-on-the-sphere-bases-or-parametric-lobes" >
                                                    Directional Data (Represent or approximate functions on the sphere (bases or parametric lobes))
												</a>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sizes.html" >
                                    Sizes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-fixing-artifacts.html" >
                                    Fixing Artifacts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Global Illumination / Indirect Lighting
					</h1>
					<p>
						<time
							datetime="2025-07-03" >
                            üïí Created: 2025-07-03
						</time>
						<time
							datetime="2026-02-15" >
                            | Updated: 2026-02-15
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<ul>
	<li>
		<p>
            A broad term that refers to any algorithm or technique that simulates how light bounces around a scene, not just directly from light sources but also after interactions with surfaces.
		</p>
	</li>
	<li>
		<p>
            It encompasses both 
			<strong>
                direct lighting
			</strong>
            &nbsp;(light coming straight from a source) and 
			<strong>
                indirect lighting
			</strong>
            &nbsp;(light that has bounced one or more times).
		</p>
	</li>
</ul>
<h3
	id="terms" >
    Terms
</h3>
<h5
	id="irradiance" >
    Irradiance
</h5>
<ul>
	<li>
		<p>
			<strong>
                Irradiance (scalar)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    At a surface point, the integral of incoming radiance over the hemisphere (units: W/m¬≤).
				</p>
			</li>
			<li>
				<p>
                    Often the quantity of interest for diffuse shading.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Irradiance field
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    An Irradiance Field is the continuous phenomenon.
				</p>
			</li>
			<li>
				<p>
                    A function that maps spatial position (and sometimes orientation) to irradiance.
				</p>
			</li>
			<li>
				<p>
                    In papers this term can mean the true continuous field, or a specific continuous representation (e.g., a voxel grid, analytic basis, or neural field).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Irradiance probes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    An Irradiance Probe is a discrete measurement of that phenomenon.
				</p>
			</li>
			<li>
				<p>
                    A set of sampled measurements placed at discrete spatial locations.
				</p>
			</li>
			<li>
				<p>
                    Each probe stores an irradiance representation (examples: spherical-harmonic coefficients, a small cubemap, or directional coefficients).
				</p>
			</li>
			<li>
				<p>
                    During rendering the scene samples/interpolates between probes to approximate the irradiance at arbitrary points.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="techniques" >
    Techniques
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html" 
				class="external-link" 
				target="_blank" >
                Hammersley Points on the Hemisphere
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
            <img src="assets/image_2025-09-19_20-52-54.png" width="400" >
		</p>
		<ul>
			<li>
				<p>
                    Appeared in Surfels.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="parameterizations-sampling-layouts-for-the-sphere" >
    Parameterizations / sampling layouts for the sphere
</h4>
<h5
	id="octahedral-maps" >
    Octahedral Maps
</h5>
<ul>
	<li>
		<p>
            A bijective mapping (with a fold) that encodes a unit 3D direction 
            <code>n = (x,y,z)</code>
            &nbsp;into 2D texture coordinates 
            <code>u,v ‚àà [0,1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            Designed to pack the sphere into a single square texture with less angular distortion than latitude‚Äìlongitude and usually fewer wasted texels than cube maps.
		</p>
	</li>
	<li>
		<p>
            Commonly used to store normals, unit vectors (reflection vectors, tangent-space directions), or per-direction scalar/vector fields (e.g., an environment map sampled per texel).
		</p>
	</li>
</ul>
<h5
	id="cube-maps" >
    Cube Maps
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html#annex/importancesamplingfortheibl" 
				class="internal-link" 
				target="_self" >
                Filament Importance Sampling for the IBL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Precomputing $L_{DFG}$
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The term $L_{DFG}$ is only dependent on $n.v$. Below, the normal is arbitrarily set to $n = [0, 0, 1]$ and $v$ is chosen to satisfy $n.v$. The vector $h_i$ is the $D_{GGX}(\alpha)$ important direction sample $i$.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">float GDFG(float NoV, float NoL, float a) {
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = a * a;
&nbsp;&nbsp;&nbsp;&nbsp;float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
&nbsp;&nbsp;&nbsp;&nbsp;float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
&nbsp;&nbsp;&nbsp;&nbsp;return (2 * NoL) / (GGXV + GGXL);
}

float2 DFG(float NoV, float a) {
&nbsp;&nbsp;&nbsp;&nbsp;float3 V;
&nbsp;&nbsp;&nbsp;&nbsp;V.x = sqrt(1.0f - NoV*NoV);
&nbsp;&nbsp;&nbsp;&nbsp;V.y = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;V.z = NoV;

&nbsp;&nbsp;&nbsp;&nbsp;float2 r = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;for (uint i = 0; i &lt; sampleCount; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float2 Xi = hammersley(i, sampleCount);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float3 H = importanceSampleGGX(Xi, a, N);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float3 L = 2.0f * dot(V, H) * H - V;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float VoH = saturate(dot(V, H));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float NoL = saturate(L.z);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float NoH = saturate(H.z);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (NoL &gt; 0.0f) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float G = GDFG(NoV, NoL, a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float Gv = G * VoH / NoH;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float Fc = pow(1 - VoH, 5.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.x += Gv * (1 - Fc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.y += Gv * Fc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return r * (1.0f / sampleCount);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Filament Engine coordinates system
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922082120.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    To simplify the rendering of reflections, IBL cubemaps are stored mirrored on the X axis. This is the default behaviour of the 
                    <code>cmgen</code>
                    &nbsp;tool. This means that an IBL cubemap used as environment background needs to be mirrored again at runtime. An easy way to achieve this for skyboxes is to use textured back faces. Filament does this by default.
				</p>
			</li>
			<li>
				<p>
                    To convert equirectangular environment maps to horizontal/vertical cross cubemaps we position the +Z face in the center of the source rectilinear environment map.
				</p>
			</li>
			<li>
				<p>
                    When specifying a skybox or an IBL in Filament, the specified cubemap is oriented such that its -Z face points towards the +Z axis of the world (this is because filament assumes mirrored cubemaps). However, because environments and skyboxes are expected to be pre-mirrored, their -Z (back) face points towards the world's -Z axis as expected (and the camera looks toward that direction by default).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="directional-data-represent-or-approximate-functions-on-the-sphere-bases-or-parametric-lobes" >
    Directional Data (Represent or approximate functions on the sphere (bases or parametric lobes))
</h4>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-1-a-brief-and-incomplete-history-of-baked-lighting-representations/" 
				class="external-link" 
				target="_blank" >
                SG Series Part 1: A Brief (and Incomplete) History of Baked Lighting Representations
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Sounds very interesting and relevant.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h6
	id="when-an-sh-sg-wavelet-can-replace-a-cubemap-oct-map-and-when-it-cannot" >
    When an SH/SG/wavelet can ‚Äúreplace‚Äù a cubemap/oct map ‚Äî and when it cannot
</h6>
<ul>
	<li>
		<p>
			<strong>
                Replace (acceptable / typical):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Low-frequency lighting (diffuse irradiance): SH (low-order) is commonly used instead of sampling a full cubemap at runtime because SH compactly encodes low-frequency content and allows analytic convolution with Lambertian cosine. That avoids per-pixel cubemap lookups for diffuse IBL.
				</p>
			</li>
			<li>
				<p>
                    Compact specular approximation: Representing an environment by a small number of SG lobes can replace a cubemap for fast approximate glossy shading or importance sampling when the environment is lobe-like.
				</p>
			</li>
			<li>
				<p>
                    Compression / streaming: Wavelets (or hierarchical transforms) can replace a naive cubemap storage by providing a compressed, multiresolution representation that is progressively refinable.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cannot fully replace (or will be lossy / expensive to use):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Detailed, high-frequency reflections (sharp mirror-like): Full-resolution cubemap/oct textures or prefiltered mipmap chains (PMREM) are the usual approach. SH needs very high band count (many coefficients) to represent sharp features, and SG requires many lobes to approximate complex high-frequency structure ‚Äî both become expensive or inaccurate.
				</p>
			</li>
			<li>
				<p>
                    Arbitrary sampling and filtering: A texture parameterization (cubemap/oct) is a direct sampling representation and is straightforward to sample, filter (with caveats) and prefilter with hardware. Basis expansions require projection and reconstruction steps before sampling in the standard pipeline.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="haar-wavelets" >
    Haar Wavelets
</h5>
<ul>
	<li>
		<p>
            A family of localized, multiresolution basis functions (Haar is the simplest wavelet) that represent signals with coarse-to-fine detail. Haar wavelets are piecewise-constant, have compact support, and provide spatial locality and hierarchical decomposition.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Typical form (1D/2D idea):
			</strong>
            &nbsp;scaling functions and wavelet functions that split signal into averages + differences at successive scales. On the sphere one can build analogous spherical wavelet bases (e.g., via hierarchical partitioning of the sphere).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Properties:
			</strong>
            &nbsp;spatially localized, multi-resolution (supports progressive refinement), good at representing localized/high-frequency features and discontinuities, many coefficients are zero or small for sparse signals, not globally smooth (Haar is discontinuous). Wavelet transforms can be fast (O(n)). Rotation is awkward for bases tied to a fixed partitioning.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Common graphics uses:
			</strong>
            &nbsp;compression and multi-resolution representation of environment maps or textures, adaptive shading, fast hierarchical importance sampling / level-of-detail, GPU-friendly encodings, and sparse approximations of signals with local sharp features.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Trade-offs:
			</strong>
            &nbsp;better for localized/high-frequency structure and compression; Haar specifically is low-order (blocky) unless higher-order wavelets are used; rotation and analytic convolution are not generally simple in the wavelet domain without additional structure.
		</p>
	</li>
</ul>
<h5
	id="spherical-gaussians-sg" >
    Spherical Gaussians (SG)
</h5>
<ul>
	<li>
		<p>
			<strong>
                What it is (short):
			</strong>
            &nbsp;parametric, localized ‚Äúlobe‚Äù functions on the sphere that approximate a single-peaked angular distribution (an axis-aligned Gaussian-like lobe).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Typical form (common form):
			</strong>
            &nbsp;$G(\omega;\mu,\kappa)=\exp\big(\kappa(\mu\cdot\omega-1)\big)$, where $\mu$ is the lobe axis and $\kappa$ (or similar) controls concentration (larger $\kappa$ = narrower lobe). (Different papers use slightly different normalization/scales.)
		</p>
	</li>
	<li>
		<p>
			<strong>
                Properties:
			</strong>
            &nbsp;strongly localized, easily rotated by changing $\mu$, analytic approximations exist for products and convolutions with some BRDF lobes (useful approximations), compact parametric representation (axis + sharpness), cheap evaluation of a single lobe. Not an orthogonal basis. Multiple SGs can be summed to approximate complex lobes.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Common graphics uses:
			</strong>
            &nbsp;representing specular lobes and glossy reflections, analytic or semi-analytic shading and convolution approximations, importance sampling, fitting environment lighting with a sum of lobes for real-time shading. SGs are also used in prefiltered environment maps where single-lobe behavior is important.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Trade-offs:
			</strong>
            &nbsp;simple and efficient for localized lobes; approximating arbitrary functions requires many SGs; not linear-orthonormal (so projection/coefficients don‚Äôt have the same algebraic niceties as SH).
		</p>
	</li>
</ul>
<h5
	id="spherical-harmonics-sh" >
    Spherical Harmonics (SH)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf" 
				class="external-link" 
				target="_blank" >
                An Efficient Representation for Irradiance Environment Maps - Ramamoorthi &amp; Hanrahan - Siggraph 2001
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://cseweb.ucsd.edu/~ravir/papers/freqenv/freqenv.pdf" 
				class="external-link" 
				target="_blank" >
                Frequency Space Environment Map Rendering - Ramamoorthi &amp; Hanrahan- Siggraph 2002
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Spherical harmonic reflection map (SHRM)&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pdfs.semanticscholar.org/566f/c019459435ac3ad25d9a4941d5da02d7ba59.pdf" 
				class="external-link" 
				target="_blank" >
                Lighting and Material of Halo 3 - Siggraph 2008
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://media.gdcvault.com/gdc08/slides/S6220i1.pdf" 
				class="external-link" 
				target="_blank" >
                Lighting and Material of Halo 3 - Siggraph 2008
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Bungie pioneered baked SH lighting in a shipped game with Halo 3 (Xbox 360, 2007). Halo 3‚Äôs engine precomputed ‚Äúlight probe‚Äù textures: each texel stored multiple SH coefficients (the slides cite 9‚Äì16 floats per texel) representing the incoming diffuse light at that point. These SH lightmaps were then sampled in shaders, so that static geometry received baked global illumination, and dynamic models could be lit by dot-producting their SH transfer vectors against the light-probe SH. (Siggraph 2008 ‚ÄúLighting and Materials of Halo 3‚Äù notes SH lightmaps as a natural extension of lightmaps.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html#annex/sphericalharmonics" 
				class="internal-link" 
				target="_self" >
                Filament - Spherical Harmonics
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    C++ implementation to compute a non-normalized SH basis:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">static inline size_t SHindex(ssize_t m, size_t l) {
&nbsp;&nbsp;&nbsp;&nbsp;return l * (l + 1) + m;
}

void computeShBasis(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double* const SHb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t numBands,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const vec3& s)
{
&nbsp;&nbsp;&nbsp;&nbsp;// handle m=0 separately, since it produces only one coefficient
&nbsp;&nbsp;&nbsp;&nbsp;double Pml_2 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;double Pml_1 = 1;
&nbsp;&nbsp;&nbsp;&nbsp;SHb[0] =&nbsp;&nbsp;Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;for (ssize_t l = 1; l &lt; numBands; l++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double Pml = ((2 * l - 1) * Pml_1 * s.z - (l - 1) * Pml_2) / l;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pml_2 = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pml_1 = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex(0, l)] = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;double Pmm = 1;
&nbsp;&nbsp;&nbsp;&nbsp;for (ssize_t m = 1; m &lt; numBands ; m++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pmm = (1 - 2 * m) * Pmm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double Pml_2 = Pmm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double Pml_1 = (2 * m + 1)*Pmm*s.z;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// l == m
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex(-m, m)] = Pml_2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex( m, m)] = Pml_2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m + 1 &lt; numBands) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// l == m+1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex(-m, m + 1)] = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex( m, m + 1)] = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (ssize_t l = m + 2; l &lt; numBands; l++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double Pml = ((2 * l - 1) * Pml_1 * s.z - (l + m - 1) * Pml_2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ (l - m);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pml_2 = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pml_1 = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex(-m, l)] = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex( m, l)] = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;double Cm = s.x;
&nbsp;&nbsp;&nbsp;&nbsp;double Sm = s.y;
&nbsp;&nbsp;&nbsp;&nbsp;for (ssize_t m = 1; m &lt;= numBands ; m++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (ssize_t l = m; l &lt; numBands; l++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex(-m, l)] *= Sm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHb[SHindex( m, l)] *= Cm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double Cm1 = Cm * s.x - Sm * s.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double Sm1 = Sm * s.x + Cm * s.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cm = Cm1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sm = Sm1;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
		<ul>
			<li>
				<p>
                    C++ code to compute $\hat{C}_l$:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">static double factorial(size_t n, size_t d = 1);

// &lt; cos(theta) &gt; SH coefficients pre-multiplied by 1 / K(0,l)
double computeTruncatedCosSh(size_t l) {
&nbsp;&nbsp;&nbsp;&nbsp;if (l == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return M_PI;
&nbsp;&nbsp;&nbsp;&nbsp;} else if (l == 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 2 * M_PI / 3;
&nbsp;&nbsp;&nbsp;&nbsp;} else if (l & 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;const size_t l_2 = l / 2;
&nbsp;&nbsp;&nbsp;&nbsp;double A0 = ((l_2 & 1) ? 1.0 : -1.0) / ((l + 2) * (l - 1));
&nbsp;&nbsp;&nbsp;&nbsp;double A1 = factorial(l, l_2) / (factorial(l_2) * (1 &lt;&lt; l));
&nbsp;&nbsp;&nbsp;&nbsp;return 2 * M_PI * A0 * A1;
}

// returns n! / d!
double factorial(size_t n, size_t d ) {
&nbsp;&nbsp; d = std::max(size_t(1), d);
&nbsp;&nbsp; n = std::max(size_t(1), n);
&nbsp;&nbsp; double r = 1.0;
&nbsp;&nbsp; if (n == d) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // intentionally left blank
&nbsp;&nbsp; } else if (n &gt; d) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( ; n&gt;d ; n--) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r *= n;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( ; d&gt;n ; d--) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r *= d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = 1.0 / r;
&nbsp;&nbsp; }
&nbsp;&nbsp; return r;
}
</code></pre>
	</li>
	<li>
		<p>
            Basis functions $Y_{\ell}^m(\theta,\phi)$ indexed by degree $\ell\ge 0$ and order $-\ell\le m\le\ell$. A function $f(\omega)$ on the sphere is expanded as $f(\omega)=\sum_{\ell=0}^{L}\sum_{m=-\ell}^{\ell} c_{\ell m} Y_{\ell}^m(\omega)$.
		</p>
	</li>
	<li>
		<p>
            Are an orthonormal basis for functions on the sphere. In real-time lighting they are used to compactly represent low-frequency angular functions (environment illumination, visibility, convolution kernels).
		</p>
	</li>
	<li>
		<p>
            Irradiance probes commonly store SH coefficients so the renderer can approximate diffuse lighting quickly.
		</p>
	</li>
	<li>
		<p>
			<em>
                Why is it useful for Irradiance / Probes
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Compression
					</strong>
                    : low-frequency lighting (diffuse environment lighting, soft shadows) is well-approximated by a small number of SH bands (e.g. 9 coefficients).
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Linear projection
					</strong>
                    : you can project an environment (cubemap, sampling) onto SH. Once you have certain coefficients‚Äã, you store those in a probe instead of storing a full cubemap.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Fast evaluation
					</strong>
                    : to evaluate the approximated radiance or irradiance at some direction $\omega$, evaluate the SH basis at $\omega$ and form the dot product with coefficients: $f(\omega)=\sum a_{l}^{m}Y_{l}^{m}(\omega)$. That dot product is inexpensive for small L.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Convolution property (why diffuse works well)
					</strong>
                    : for Lambertian reflection you need the cosine-weighted integral of incoming radiance. The cosine kernel is low-frequency and its SH representation has non-zero weight only on low bands. Convolving $L_i$‚Äã with the cosine kernel reduces to scaling SH bands by precomputed factors. Practically, this means you can compute irradiance from the projected SH coefficients cheaply without re-sampling the entire environment at render time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=dDQTHFeJf5M" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    A demonstration of spherical harmonics used to construct the surface of the earth at increasing angular resolution.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/shorts/t06UTZAxCgw" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Demo - Earth Magnetic Field
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=Ziz7t1HHwBw" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Visualization
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    We describe the possible fundamental vibrations on a sphere in three dimensions by counting, mirroring and rotating nodal lines.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/shorts/IlvTHPClwHI" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Idk, wtf.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=M--6_0F62pQ" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics in Quantum Mechanics
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The video is cool.
				</p>
			</li>
			<li>
				<p>
                    The idea is to take this 1D visualization for the energy states of the electron:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919134538.png" width="350" >
                    &nbsp;
                    <img src="assets/image_20250919134703.png" width="200" >
				</p>
			</li>
			<li>
				<p>
                    And arrive at this 3D visualization:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919134409.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    All the visual characteristics of the visualization come from the ways in which the nodes can be represented.
				</p>
			</li>
			<li>
				<p>
                    Apparently nodes can be radial or angular. The angular representations appear when considering that the node can be a plane.
				</p>
			</li>
			<li>
				<p>
                    It is these nodes represented as a plane that make the shapes more interesting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The &quot;overlap&quot; I mentioned is not about spatial overlap. It's about mathematical independence.
		</p>
	</li>
	<li>
		<p>
            Spherical harmonics are precisely the spherical analogue of the Fourier transform.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Fourier Series (for a function on a circle):
			</strong>
            &nbsp;Any function on a 1D circle (like a sound wave over time) can be broken down into a sum of simple, orthogonal basis functions: sines and cosines of different frequencies (
            <code>sin(nŒ∏)</code>
            , 
            <code>cos(nŒ∏)</code>
            ).
		</p>
		<ul>
			<li>
				<p>
                    The low-frequency sines/cosines capture the broad, smooth shape.
				</p>
			</li>
			<li>
				<p>
                    The high-frequency ones capture the sharp details and edges.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Spherical Harmonics (for a function on a sphere):
			</strong>
            &nbsp;Any function on a 2D sphere (like an environment map) can be broken down into a sum of simple, orthogonal basis functions: the spherical harmonics (
            <code>Y_lm(Œ∏, œÜ)</code>
            ).
		</p>
		<ul>
			<li>
				<p>
                    The low-
                    <code>l</code>
                    &nbsp;(low-frequency) SHs capture the broad, smooth lighting (the average color, the dominant light direction).
				</p>
			</li>
			<li>
				<p>
                    The high-
                    <code>l</code>
                    &nbsp;(high-frequency) SHs capture the sharp details and edges (sharp reflections, tiny light sources).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We are not projecting a 3D scene onto a sphere.
		</p>
		<ul>
			<li>
				<p>
                    This is called environment map capture (e.g., taking a 360¬∞ photo). That gives us a function 
                    <code>f(Œ∏, œÜ)</code>
                    &nbsp;that is defined on the surface of a sphere.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The Spherical Harmonic transform is the next step. We are taking that already-spherical function 
            <code>f(Œ∏, œÜ)</code>
            &nbsp;and projecting it onto the spherical harmonic basis functions.
		</p>
	</li>
	<li>
		<p>
            The word &quot;projection&quot; here is used in the linear algebra sense, just like projecting a vector onto a set of basis axes.
		</p>
	</li>
	<li>
		<p>
            Imagine your environment map 
            <code>f(œâ)</code>
            &nbsp;is a vector in a giant, infinite-dimensional space.
		</p>
	</li>
	<li>
		<p>
            The spherical harmonics 
            <code>Ylm(œâ)</code>
            &nbsp;form a complete set of orthonormal basis vectors for that space.
		</p>
	</li>
	<li>
		<p>
            Projecting 
            <code>f</code>
            &nbsp;onto a specific basis vector 
            <code>Ylm</code>
            &nbsp;is how we find the coefficient 
            <code>clm</code>
            &nbsp;for that function. The formula for this projection is the inner product:&nbsp;&nbsp;
            <code>c_lm = ‚à´ f(œâ) * Y_lm(œâ) dœâ</code>
            .
		</p>
	</li>
	<li>
		<p>
            This is identical to how in 3D space, you find the 
            <code>x</code>
            -component of a vector 
            <code>V</code>
            &nbsp;by projecting it onto the unitX basis vector: 
            <code>V_x = V ‚Ä¢ unitX</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                &quot;Orthonormalization&quot;
			</strong>
            &nbsp;means we have ensured two things for our basis functions 
            <code>Y_lm</code>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Orthogonal:
					</strong>
                    &nbsp;
                    <code>‚à´ Y_lm(œâ) * Y_l'm'(œâ) dœâ = 0</code>
                    &nbsp;if 
                    <code>(l, m) ‚â† (l', m')</code>
                    &nbsp;(they are independent).
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Normalized:
					</strong>
                    &nbsp;
                    <code>‚à´ Y_lm(œâ) * Y_lm(œâ) dœâ = 1</code>
                    &nbsp;(each one has a &quot;unit length&quot;).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This orthonormality is what makes the math so clean and the coefficients independent.
		</p>
	</li>
	<li>
		<p>
            In Quantum Mechanics, the spherical harmonics 
            <code>Y_lm</code>
            &nbsp;are famous because they are the 
			<strong>
                angular solutions to the Laplace equation in spherical coordinates.
			</strong>
		</p>
	</li>
	<li>
		<p>
            This describes the probability distribution of an electron around a hydrogen atom (its orbital). The shapes of the s, p, d, f orbitals are visualizations of the 
            <code>Y_lm</code>
            &nbsp;functions!
		</p>
		<ul>
			<li>
				<p>
                    <code>Y00</code>
                    &nbsp;is the s-orbital (spherical).
				</p>
			</li>
			<li>
				<p>
                    <code>Y1m</code>
                    &nbsp;are the three p-orbitals (dumbbell shaped along x, y, z).
				</p>
			</li>
			<li>
				<p>
                    <code>Y2m</code>
                    &nbsp;are the five d-orbitals (cloverleaf shapes).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                In Computer Graphics:
			</strong>
            &nbsp;We are using the exact same mathematical functions to describe the distribution of light energy around a point. The &quot;orbital&quot; is now the &quot;irradiance environment.&quot;
		</p>
	</li>
	<li>
		<p>
            The key difference is one of interpretation:
		</p>
	</li>
	<li>
		<p>
            In Quantum Mechanics, you're solving for a wavefunction.
		</p>
	</li>
	<li>
		<p>
            In Computer Graphics, you're using the SH basis to compactly represent a function (light) defined on a sphere.
		</p>
	</li>
	<li>
		<p>
			<strong>
                The process for computer graphics
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    For a render engineer, the process is this:
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<strong>
                        Capture/Define:
					</strong>
                    &nbsp;Start with an environment map 
                    <code>f(œâ)</code>
                    . This is your function on the sphere.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Project (Precompute/Integrate):
					</strong>
                    &nbsp;For each SH basis function 
                    <code>Y_lm</code>
                    &nbsp;you care about (e.g., the first 9), compute the coefficient 
                    <code>c_lm</code>
                    &nbsp;by integrating the product 
                    <code>f(œâ) * Y_lm(œâ)</code>
                    &nbsp;over the entire sphere. This is the &quot;transformation&quot; into the SH frequency space.&nbsp;&nbsp;
                    <code>c_lm = ‚à´ f(œâ) * Y_lm(œâ) dœâ</code>
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Reconstruct (Runtime):
					</strong>
                    &nbsp;To get the approximate value of the environment at any direction 
                    <code>œâ</code>
                    , you evaluate the sum:&nbsp;&nbsp;
                    <code>f(œâ) ‚âà Œ£ c_lm * Y_lm(œâ)</code>
                    &nbsp;for 
                    <code>l=0...N-1</code>
                    .
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
            The reason this is a &quot;convolution&quot; is that the rendering equation often includes a cosine term (
            <code>n ‚Ä¢ œâ</code>
            ). The magic is that projecting this cosine lobe into SH space results in analytic attenuation factors (
            <code>A_l</code>
            ) that you can just multiply by your 
            <code>c_lm</code>
            &nbsp;coefficients 
			<em>
                before
			</em>
            &nbsp;the reconstruction step. This turns a complex integral into a simple dot product of two SH vectors (lighting coefficients and attenuated coefficients).
		</p>
	</li>
	<li>
		<p>
            So, you were right on all counts. It is a Fourier-style transform. It is a projection onto an orthonormal basis. And it uses the same elegant math as quantum physics to solve a seemingly unrelated problem in computer graphics with breathtaking efficiency.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Application
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=jN7FX5COASM" 
						class="external-link" 
						target="_blank" >
                        Spherical Harmonics Exponentials for Efficient Glossy Reflections
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            I watched a bit of the video, very technical and specific, about an optimization for computing glossiness.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250920105624.png" width="500" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Ringing happens when you try using high order spherical harmonics.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.42575.js" >
		</script>
	</body>
</html>
