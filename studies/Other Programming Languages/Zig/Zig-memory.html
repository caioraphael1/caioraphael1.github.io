<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.30472.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Rust
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-installation.html" >
                                    Installation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-cargo.html" >
                                    Cargo
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-debug.html" >
                                    Debug
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-imports.html" >
                                    Imports
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-symbols.html" >
                                    Symbols
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-keywords.html" >
                                    Keywords
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-control-flow.html" >
                                    Control Flow
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-types.html" >
                                    Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-strings.html" >
                                    Strings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-tuples.html" >
                                    Tuples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-arrays.html" >
                                    Arrays
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-vectors.html" >
                                    Vectors
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-hash-maps.html" >
                                    Hash Maps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-functions.html" >
                                    Functions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-structs.html" >
                                    Structs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-traits.html" >
                                    Traits
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-enums.html" >
                                    Enums
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-options.html" >
                                    Options
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-result.html" >
                                    Result
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-match.html" >
                                    Match
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-iterator.html" >
                                    Iterator
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Rust/Rust-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Zig
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-impressions.html" >
                                    Impressions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-installation.html" >
                                    Installation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-build.html" >
                                    Build
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-basics.html" >
                                    Basics
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-types.html" >
                                    Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-error-handling.html" >
                                    Error Handling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Other Programming Languages/Zig/Zig-memory.html" >
                                    Memory
								</a>
								<ul>
									<li>
										<a
											href="#defer" >
                                            Defer
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#comptime" >
                                            Comptime
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#pointers" >
                                            Pointers
										</a>
										<ul>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-memory-allocators.html" >
                                    Memory: Allocators
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-threads.html" >
                                    Threads
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-file-system.html" >
                                    File System
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-others.html" >
                                    Others
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Zig/Zig-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Go
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Go-overview.html" >
                                    Overview
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Go-goroutines.html" >
                                    Goroutines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Go-godot.html" >
                                    Godot
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            C++
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/C++/C++-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/C++/C++-building.html" >
                                    Building
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/C++/C++-explanations.html" >
                                    Explanations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/C++/C++-gamedev.html" >
                                    GameDev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            CSharp
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/CSharp/CSharp-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/CSharp/CSharp-explanations.html" >
                                    Explanations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/CSharp/CSharp-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Lua
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Lua-basics.html" >
                                    Basics
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Lua-functions.html" >
                                    Functions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Lua-table.html" >
                                    Table
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Lua-metatables.html" >
                                    Metatables
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Lua-control-flows.html" >
                                    Control Flows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Lua-modules.html" >
                                    Modules
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Lua-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Nim
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Nim/Nim-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Nim/Nim-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Swift
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-swift.html" >
                                    Swift
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-setup.html" >
                                    Setup
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-basics.html" >
                                    Basics
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-nullability.html" >
                                    Nullability
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-error-handling.html" >
                                    Error Handling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-control-flow.html" >
                                    Control Flow
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-types.html" >
                                    Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-functions.html" >
                                    Functions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-enums.html" >
                                    Enums
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Swift/Swift-structs-and-classes.html" >
                                    Structs and Classes
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Python
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Python-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Python-basics.html" >
                                    Basics
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Python-network.html" >
                                    Network
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Python-matplotlib-graphs.html" >
                                    Matplotlib (Graphs)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Python-pyinstaller-create-exe.html" >
                                    PyInstaller (Create .exe)
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Haxe
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Haxe-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Haxe-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Kotlin
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Kotlin-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Kotlin-syntax.html" >
                                    Syntax
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Kotlin-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Java
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Other Programming Languages/Java-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Memory
					</h1>
					<p>
						<time
							datetime="2025-01-09" >
                            üïí Created: 2025-01-09
						</time>
						<time
							datetime="2026-01-23" >
                            | Updated: 2026-01-23
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<ul>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/Memory/Memory.html">
            Memory
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="lifetime-and-ownership" >
    Lifetime and Ownership
</h5>
<ul>
	<li>
		<p>
            Ownership determines whose responsibility it is to free the memory referenced by the pointer, and lifetime determines the point at which the memory becomes inaccessible.
		</p>
	</li>
	<li>
		<p>
            It is the Zig programmer's responsibility to ensure that a pointer is not accessed when the memory pointed to is no longer available.
		</p>
	</li>
	<li>
		<p>
            Note that a slice is a form of pointer, in that it references other memory.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Conventions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In general, when a function returns a pointer, the documentation for the function should explain who &quot;owns&quot; the pointer. This concept helps the programmer decide when it is appropriate, if ever, to free the pointer.
				</p>
				<ul>
					<li>
						<p>
                            For example, the function's documentation may say &quot;caller owns the returned memory&quot;, in which case the code that calls the function must have a plan for when to free that memory.
						</p>
					</li>
					<li>
						<p>
                            Probably in this situation, the function will accept an 
                            <code>Allocator</code>
                            &nbsp;parameter.
						</p>
					</li>
					<li>
						<p>
                            The API documentation for functions and data structures should take great care to explain the ownership and lifetime semantics of pointers.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="defer" >
    Defer
</h3>
<h5
	id="defer" >
    Defer
</h5>
<ul>
	<li>
		<p>
            Defer is used to execute a statement upon exiting the current block.
		</p>
	</li>
	<li>
		<p>
            When there are multiple defers in a single block, they are executed in reverse order.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "defer" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: i16 = 5;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer x += 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 5); // first the test runs, then the defer happens.
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 7);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "multi defer" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: f32 = 5;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer x += 2;&nbsp;&nbsp; // runs after this one.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer x /= 2;&nbsp;&nbsp; // runs first.
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 4.5);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;
const print = std.debug.print;

test "defer unwinding" {
&nbsp;&nbsp;&nbsp;&nbsp;print("\n", .{});

&nbsp;&nbsp;&nbsp;&nbsp;defer {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("1 ", .{});
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;defer {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("2 ", .{});
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (false) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// defers are not run if they are never executed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("3 ", .{});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example of handling Optionals (
                <code>?T</code>
                )
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const jsonParsed: ?std.json.Parsed(std.json.Value) = parseJson(allocator, mapa) catch |err| blk:
&nbsp;&nbsp;&nbsp;&nbsp;print("\nERROR | LDtkParser: {}, {s}\n", .{err, mapa});
&nbsp;&nbsp;&nbsp;&nbsp;break :blk null;
};
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Correct
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">defer {
&nbsp;&nbsp;&nbsp;&nbsp;if (jsonParsed != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonParsed.?.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// or
&nbsp;&nbsp;&nbsp;&nbsp;if (jsonParsed) |jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// or, (not sure which is correct)
&nbsp;&nbsp;&nbsp;&nbsp;if (jsonParsed) |*jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.*.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
				<ul>
					<li>
						<p>
                            The 
                            <code>defer</code>
                            &nbsp;will happen at the expected moment, performing actions depending on whether the variable is null.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Incorrect
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">if (jsonParsed != null) {
&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed.?.deinit();
}
// or
if (jsonParsed) |jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.deinit();
}
// or, (not sure which is correct)
if (jsonParsed) |*jsonParsed_| {
&nbsp;&nbsp;&nbsp;&nbsp;defer jsonParsed_.*.deinit();
}
</code></pre>
				<ul>
					<li>
						<p>
                            All syntaxes are valid, but the 
                            <code>defer</code>
                            &nbsp;will run as soon as the 
                            <code>if</code>
                            &nbsp;scope exits, i.e., immediately. The 
                            <code>defer</code>
                            &nbsp;is executed inside the 
                            <code>if</code>
                            , not outside it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Comparing with Go
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Zig's 
                    <code>defer</code>
                    &nbsp;is similar to Go's, with one major difference.
				</p>
			</li>
			<li>
				<p>
                    In Zig, the defer runs at the end of its containing scope.
				</p>
			</li>
			<li>
				<p>
                    In Go, defer runs at the end of the containing function.
				</p>
			</li>
			<li>
				<p>
                    Zig's approach is probably less surprising, unless you are a Go developer.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="errdefer" >
    errdefer
</h5>
<ul>
	<li>
		<p>
            <code>errdefer</code>
            &nbsp;works like 
            <code>defer</code>
            , but only executes when the function returns with an error inside the 
            <code>errdefer</code>
            's block.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">var problems: u32 = 98;

fn failingFunction() error{Oops}!void {
&nbsp;&nbsp;&nbsp;&nbsp;return error.Oops;
}

fn failFnCounter() error{Oops}!void {
&nbsp;&nbsp;&nbsp;&nbsp;errdefer problems += 1;
&nbsp;&nbsp;&nbsp;&nbsp;try failingFunction();
}

fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;failFnCounter() catch |err| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const Allocator = std.mem.Allocator;

pub const Game = struct {
&nbsp;&nbsp;&nbsp;&nbsp;players: []Player,
&nbsp;&nbsp;&nbsp;&nbsp;history: []Move,
&nbsp;&nbsp;&nbsp;&nbsp;allocator: Allocator,

&nbsp;&nbsp;&nbsp;&nbsp;fn init(allocator: Allocator, player_count: usize) !Game {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var players = try allocator.alloc(Player, player_count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errdefer allocator.free(players);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// store 10 most recent moves per player
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var history = try allocator.alloc(Move, player_count * 10);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return .{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.players = players,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.history = history,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.allocator = allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;fn deinit(game: Game) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const allocator = game.allocator;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(game.players);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator.free(game.history);
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
		<ul>
			<li>
				<p>
                    Under normal conditions, 
                    <code>players</code>
                    &nbsp;is allocated in 
                    <code>init</code>
                    &nbsp;and released in 
                    <code>deinit</code>
                    . But there's an edge case when the initialization of 
                    <code>history</code>
                    &nbsp;fails. In this case and only this case we need to undo the allocation of 
                    <code>players</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Another notable aspect is that the lifecycle of our two dynamically allocated slices, 
                    <code>players</code>
                    &nbsp;and 
                    <code>history</code>
                    , is based on application logic. There's no rule that dictates when 
                    <code>deinit</code>
                    &nbsp;must be called or who must call it. This is good because it gives arbitrary lifetimes, but bad because we can forget to call 
                    <code>deinit</code>
                    &nbsp;or call it more than once.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="comptime" >
    Comptime
</h3>
<ul>
	<li>
		<p>
            &quot;Compile time&quot; is a program's environment while it is being compiled.
		</p>
	</li>
	<li>
		<p>
            &quot;Run time&quot; is the environment while the compiled program executes.
		</p>
	</li>
	<li>
		<p>
            All compiled languages perform some logic at compile time to analyze code and build symbol tables.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Optimizations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Compilers can precompute or inline things at compile time to make the resulting program more efficient.
				</p>
			</li>
			<li>
				<p>
                    Smart compilers can even unroll loops.
				</p>
			</li>
			<li>
				<p>
                    Zig makes compile-time execution an integral part of the language.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Zig has a powerful 
            <code>comptime</code>
            &nbsp;feature to do things at compile time. Compile-time execution can only operate on compile-time known data. Zig provides 
            <code>comptime_int</code>
            &nbsp;and 
            <code>comptime_float</code>
            &nbsp;types. Example:
		</p>
<pre><code class="language-zig" data-lang="zig">var x = 0;
while (true) {
&nbsp;&nbsp;if (someCondition()) break;
&nbsp;&nbsp;x += 2;
}
</code></pre>
		<ul>
			<li>
				<p>
                    This won't compile. 
                    <code>x</code>
                    's type is inferred as a 
                    <code>comptime_int</code>
                    &nbsp;since the value 
                    <code>0</code>
                    &nbsp;is known at compile time. A 
                    <code>comptime_int</code>
                    &nbsp;must be a 
                    <code>const</code>
                    . If we change to 
                    <code>const x = 0;</code>
                    &nbsp;we'll get a different error because we try to add 2 to a 
                    <code>const</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The solution is to explicitly define 
                    <code>x</code>
                    &nbsp;as a runtime integer type:
				</p>
<pre><code class="language-zig" data-lang="zig">var x: usize = 0;
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="numeric-literals" >
    Numeric Literals
</h5>
<ul>
	<li>
		<p>
            ALL numeric literals in Zig are of type 
            <code>comptime_int</code>
            &nbsp;or 
            <code>comptime_float</code>
            . They are arbitrary precision.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const const_int = 12345;
const const_float = 987.654;
</code></pre>
<ul>
	<li>
		<p>
            When assigned to 
            <code>const</code>
            &nbsp;identifiers, we don't need to specify sizes like 
            <code>u8</code>
            &nbsp;or 
            <code>f64</code>
            .
		</p>
	</li>
	<li>
		<p>
            The values are inserted at compile time. The identifiers 
            <code>const_int</code>
            &nbsp;and 
            <code>const_float</code>
            &nbsp;don't exist in the compiled binary.
		</p>
	</li>
</ul>
<h3
	id="pointers" >
    Pointers
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Pointers" 
				class="external-link" 
				target="_blank" >
                Pointers
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="single-item-pointer-codet-code" >
    Single-item Pointer (
    <code>*T</code>
    )
</h5>
<ul>
	<li>
		<p>
            Normal pointers in Zig cannot have 0 or null as a value.
		</p>
		<ul>
			<li>
				<p>
                    Setting a 
                    <code>*T</code>
                    &nbsp;to 0 is detectable illegal behaviour.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Referencing is 
            <code>&variable</code>
            , dereferencing is 
            <code>variable.*</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

// The function receives a pointer to `u8`.
fn increment(num: *u8) void {
&nbsp;&nbsp;&nbsp;&nbsp;num.* += 1;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `num.*` accesses the value pointed to by the pointer (dereference).
}

test "pointers" {
&nbsp;&nbsp;&nbsp;&nbsp;var x: u8 = 1;
&nbsp;&nbsp;&nbsp;&nbsp;increment(&x); // Pass a pointer to `x` to `increment`.
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x == 2);
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Sizes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>usize</code>
                    &nbsp;and 
                    <code>isize</code>
                    &nbsp;have the same size as pointers.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">test "usize" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@sizeOf(usize) == @sizeOf(*u8));
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@sizeOf(isize) == @sizeOf(*u8));
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Coercion / Casting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Pointers are not integers; explicit conversion is needed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Recommendations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Prefer slices and array types to raw pointers. Compiler-enforced types are less error-prone than pointer manipulation.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="many-item-pointer-codet-code" >
    Many-item Pointer (
    <code>[*]T</code>
    )
</h5>
<ul>
	<li>
		<p>
            Many pointer types exist to represent what is pointed to: single value or array, known length or not.
		</p>
	</li>
	<li>
		<p>
            Most programs need buffers with runtime-known lengths. Many-item pointers represent those.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Questions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Example usage confusion:
				</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

fn doubleAllManypointer(buffer: [*]u8, byte_count: usize) void {
&nbsp;&nbsp;&nbsp;&nbsp;var i: usize = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while (i &lt; byte_count) : (i += 1) buffer[i] *= 2;
}

test "many-item pointers" {
&nbsp;&nbsp;&nbsp;&nbsp;var buffer: [100]u8 = [_]u8{1} ** 100;
&nbsp;&nbsp;&nbsp;&nbsp;const buffer_ptr: *[100]u8 = &buffer;

&nbsp;&nbsp;&nbsp;&nbsp;const buffer_many_ptr: [*]u8 = buffer_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;doubleAllManypointer(buffer_many_ptr, buffer.len);
&nbsp;&nbsp;&nbsp;&nbsp;for (buffer) |byte| try expect(byte == 2);

&nbsp;&nbsp;&nbsp;&nbsp;const first_elem_ptr: *u8 = &buffer_many_ptr[0];
&nbsp;&nbsp;&nbsp;&nbsp;const first_elem_ptr_2: *u8 = @ptrCast(buffer_many_ptr);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(first_elem_ptr == first_elem_ptr_2);
}
</code></pre>
			</li>
			<li>
				<p>
                    &quot;Slices can be thought of as many-item pointers (
                    <code>[*]T</code>
                    ) plus a length (
                    <code>usize</code>
                    ).&quot;
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="slices-codet-code" >
    Slices (
    <code>[]T</code>
    )
</h5>
<ul>
	<li>
		<p>
			<strong>
                Slices vs Arrays
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Slices do not store data, only a 
					<em>
                        reference
					</em>
                    &nbsp;to the original array.
				</p>
				<ul>
					<li>
						<p>
                            They store the valid length of the buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Slices can have runtime variable length; arrays have fixed length known at compile time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Slices vs Many-item Pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Slices are safer and more convenient. 
                    <code>for</code>
                    &nbsp;loops work on slices.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Slices are &quot;fat pointers&quot; and are typically twice the size of a normal pointer.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Create from an array with 
                    <code>x[n..m]</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Slicing includes 
                    <code>n</code>
                    &nbsp;and excludes 
                    <code>m</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

fn total(values: []const u8) usize {
&nbsp;&nbsp;&nbsp;&nbsp;var soma: usize = 0;
&nbsp;&nbsp;&nbsp;&nbsp;for (values) |v| soma += v;
&nbsp;&nbsp;&nbsp;&nbsp;return soma;
}

test "slices" {
&nbsp;&nbsp;&nbsp;&nbsp;const array = [_]u8{ 1, 2, 3, 4, 5 };
&nbsp;&nbsp;&nbsp;&nbsp;const slice = array[0..3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// elements 0, 1 and 2.
&nbsp;&nbsp;&nbsp;&nbsp;try expect(total(slice) == 6);&nbsp;&nbsp;// returns 6 = 1 + 2 + 3.
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf(slice) == *const [3]u8);
}
</code></pre>
		<ul>
			<li>
				<p>
                    Use 
                    <code>x[n..]</code>
                    &nbsp;to slice to the end.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">test "slices 3" {
&nbsp;&nbsp;&nbsp;&nbsp;var array = [_]u8{ 1, 2, 3, 4, 5 };
&nbsp;&nbsp;&nbsp;&nbsp;var slice = array[0..];
&nbsp;&nbsp;&nbsp;&nbsp;_ = slice;
}
</code></pre>
	</li>
</ul>
<h5
	id="pointer-types" >
    Pointer Types
</h5>
<ul>
	<li>
		<p>
			<strong>
                Single-item Pointer vs Multi-item Pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250307235940.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250308001358.png" width="575" >
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>[]T</code>
                    &nbsp;is a Slice.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="dangling-pointers" >
    Dangling Pointers
</h5>
<ul>
	<li>
		<p>
			<strong>
                About
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Returning the address of a local.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;const warning1 = try powerLevel(9000);
&nbsp;&nbsp;const warning2 = try powerLevel(10);

&nbsp;&nbsp;std.debug.print("{s}\n", .{warning1});
&nbsp;&nbsp;std.debug.print("{s}\n", .{warning2});
}

fn powerLevel(over: i32) ![]u8 {
&nbsp;&nbsp;var buf: [20]u8 = undefined;
&nbsp;&nbsp;return std.fmt.bufPrint(&buf, "over {d}!!!", .{over});
}
</code></pre>
		<ul>
			<li>
				<p>
                    Here we return the address of 
                    <code>buf</code>
                    , but 
                    <code>buf</code>
                    &nbsp;ceases to exist when the function returns.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex2
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.openmymind.net/Zig-Dangling-Pointers/" 
						class="external-link" 
						target="_blank" >
                        Source examples
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Other examples:
				</p>
				<ul>
					<li>
						<p>
                            Arena allocator created inside a struct, etc.
						</p>
						<ul>
							<li>
								<p>
                                    Not fully understood.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Printing a pointer that pointed to a StringHashMap entry that was removed.
						</p>
						<ul>
							<li>
								<p>
                                    A simple, somewhat silly example.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex3
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() void {
&nbsp;&nbsp;&nbsp;&nbsp;const user1 = User.init(1, 10);
&nbsp;&nbsp;&nbsp;&nbsp;const user2 = User.init(2, 20);

&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("User {d} has power of {d}\n", .{user1.id, user1.power});
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("User {d} has power of {d}\n", .{user2.id, user2.power});
}

pub const User = struct {
&nbsp;&nbsp;&nbsp;&nbsp;id: u64,
&nbsp;&nbsp;&nbsp;&nbsp;power: i32,

&nbsp;&nbsp;&nbsp;&nbsp;fn init(id: u64, power: i32) *User{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var user = User{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.id = id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.power = power,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &user;
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
		<ul>
			<li>
				<p>
                    The problem is 
                    <code>User.init</code>
                    &nbsp;returns the address of the local 
                    <code>user</code>
                    . That's a dangling pointer. Returning 
                    <code>&user</code>
                    &nbsp;returns an invalid address.
				</p>
			</li>
			<li>
				<p>
                    A simple fix is to change 
                    <code>init</code>
                    &nbsp;to return 
                    <code>User</code>
                    &nbsp;(not 
                    <code>*User</code>
                    ) and 
                    <code>return user;</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            But that's not always possible.
						</p>
					</li>
					<li>
						<p>
                            Data often must outlive function scope. For that we use the heap.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex4
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">fn read() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const input = try readUserInput();
&nbsp;&nbsp;&nbsp;&nbsp;return Parser.parse(input);
}
</code></pre>
		<ul>
			<li>
				<p>
                    If 
                    <code>Parser.parse</code>
                    &nbsp;returns a value that references 
                    <code>input</code>
                    , that will be a dangling pointer. Ideally 
                    <code>Parser</code>
                    &nbsp;would copy 
                    <code>input</code>
                    &nbsp;if it needs it to live longer. There's nothing here to enforce that. Check documentation or source to know semantics.
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.30472.js" >
		</script>
	</body>
</html>
