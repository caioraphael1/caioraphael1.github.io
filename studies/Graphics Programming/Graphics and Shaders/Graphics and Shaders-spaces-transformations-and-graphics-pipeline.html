<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.64934.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
								<ul>
									<li>
										<a
											href="#concepts" >
                                            Concepts
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#model-object-local-space" >
                                            Model / Object / Local Space
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#model-object-local-matrix" >
                                            Model / Object / Local Matrix
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#world-space" >
                                            World Space
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#camera-view-eye-matrix" >
                                            Camera / View / Eye Matrix
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#camera-view-eye-space" >
                                            Camera / View / Eye Space
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#projection-matrix-classical-z-reversed-z" >
                                            Projection Matrix / Classical-Z / Reversed-Z
										</a>
										<ul>
											<li>
												<a
													href="#classical-z-reversed-z" >
                                                    Classical-Z / Reversed-Z
												</a>
											</li>
											<li>
												<a
													href="#view-frustum" >
                                                    View Frustum
												</a>
											</li>
											<li>
												<a
													href="#orthographic-projection-matrix" >
                                                    Orthographic Projection Matrix
												</a>
											</li>
											<li>
												<a
													href="#perspective-projection-matrix" >
                                                    Perspective Projection Matrix
												</a>
											</li>
										</ul>
									</li>
									<li>
										<a
											href="#mvp-matrix-model-view-projection-matrix" >
                                            MVP Matrix / Model-View-Projection Matrix
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#clip-space" >
                                            Clip Space
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#perspective-divide" >
                                            Perspective Divide
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#ndc-space-normalized-device-coordinates-space" >
                                            NDC Space / Normalized Device Coordinates Space
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#viewport-transform-matrix" >
                                            Viewport Transform Matrix
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#screen-space-screen-coordinates-window-coordinates" >
                                            Screen Space / Screen Coordinates / Window Coordinates
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#what-vulkan-does-implicitly" >
                                            What Vulkan does implicitly
										</a>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sizes.html" >
                                    Sizes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-fixing-artifacts.html" >
                                    Fixing Artifacts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Spaces, Transformations and Graphics Pipeline
					</h1>
					<p>
						<time
							datetime="2023-07-10" >
                            üïí Created: 2023-07-10
						</time>
						<time
							datetime="2026-02-16" >
                            | Updated: 2026-02-16
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=C8YtdC8mxTU" 
				class="external-link" 
				target="_blank" >
                Graphics Rendering Introduction
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Nice, with plenty of animations.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="concepts" >
    Concepts
</h3>
<ul>
	<li>
		<p>
			<strong>
                Homogeneous coordinates (4D)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Representation that lets projection be expressed as a linear 4√ó4 matrix and supports perspective divide.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=o-xwmTODTUI" 
						class="external-link" 
						target="_blank" >
                        Homogeneous Coordinates for Compute Graphics
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Affine Transformations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Preserves:
				</p>
			</li>
			<li>
				<p>
                    Straight lines (no curves introduced)
				</p>
			</li>
			<li>
				<p>
                    Parallelism (parallel lines remain parallel, though distances can change)
				</p>
			</li>
			<li>
				<p>
                    Ratios along a line (midpoints stay midpoints)
				</p>
			</li>
			<li>
				<p>
                    An affine transformation has the last row fixed to 
                    <code>[0,0,0,1]</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Affine examples
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Translation
						</p>
					</li>
					<li>
						<p>
                            Rotation
						</p>
					</li>
					<li>
						<p>
                            Uniform/non-uniform scaling
						</p>
					</li>
					<li>
						<p>
                            Shearing
						</p>
					</li>
					<li>
						<p>
                            Any combination of the above
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Non-affine examples
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Perspective projection (parallel lines may converge)
						</p>
					</li>
					<li>
						<p>
                            Non-linear warps
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Note
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    'Matrix' and 'Transform Matrix' are the same thing in this context.
				</p>
			</li>
			<li>
				<p>
                    Everything is separated between Spaces, Matrices, or operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250811161919.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250811161944.png" width="300" >
            .
		</p>
	</li>
</ul>
<h3
	id="model-object-local-space" >
    Model / Object / Local Space
</h3>
<ul>
	<li>
		<p>
            A coordinate space where a single mesh or object‚Äôs vertices are defined relative to the object‚Äôs own origin.
		</p>
	</li>
	<li>
		<p>
            Vertices are usually created and manipulated in object space before any scene-level transforms are applied.
		</p>
	</li>
</ul>
<h3
	id="model-object-local-matrix" >
    Model / Object / Local Matrix
</h3>
<ul>
	<li>
		<p>
            Transforms 
			<em>
                Model / Object / Local Space
			</em>
            &nbsp;into 
			<em>
                World Space
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            It's an affine transformation.
		</p>
	</li>
	<li>
		<p>
            Applies the object‚Äôs translation, rotation, scale (and optionally shear).
		</p>
	</li>
</ul>
<h3
	id="world-space" >
    World Space
</h3>
<ul>
	<li>
		<p>
            A scene-level coordinate system in which multiple objects are placed and arranged.
		</p>
	</li>
	<li>
		<p>
            World space is the reference for lighting, physics, and global placement.
		</p>
	</li>
</ul>
<h3
	id="camera-view-eye-matrix" >
    Camera / View / Eye Matrix
</h3>
<ul>
	<li>
		<p>
            Transforms 
			<em>
                World Space
			</em>
            &nbsp;into 
			<em>
                Camera / View / Eye Space
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            It's an affine transformation.
		</p>
	</li>
	<li>
		<p>
            The inverse of a camera‚Äôs world transform.
		</p>
	</li>
</ul>
<h3
	id="camera-view-eye-space" >
    Camera / View / Eye Space
</h3>
<ul>
	<li>
		<p>
            A coordinate system where the camera is at the origin and looks down a canonical axis (commonly ‚àíZ or +Z depending on convention).
		</p>
	</li>
	<li>
		<p>
            Vertices are expressed relative to the camera: positions are what the camera ‚Äúsees.‚Äù
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909141655.png" width="350" >
            .
		</p>
	</li>
</ul>
<h3
	id="projection-matrix-classical-z-reversed-z" >
    Projection Matrix / Classical-Z / Reversed-Z
</h3>
<ul>
	<li>
		<p>
            Transforms all vertices from the 
			<em>
                Camera / View / Eye Space
			</em>
            &nbsp;into 
			<em>
                Clip Space
			</em>
            .
		</p>
		<ul>
			<li>
				<p>
                    The GPU later 
					<em>
                        Clips
					</em>
                    &nbsp;to the frustum.
				</p>
			</li>
			<li>
				<p>
                    The projection matrix doesn‚Äôt ‚Äúignore‚Äù vertices outside the frustum; it still transforms them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Is defined by the 
			<em>
                View Frustum
			</em>
            &nbsp;parameters.
		</p>
	</li>
	<li>
		<p>
            It's not an affine transformation, as they rely on a divide by 
            <code>w</code>
            &nbsp;(the 
			<em>
                Perspective Divide
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pr0g.github.io/mathematics/graphics/2023/08/06/reverse-z.html" 
				class="external-link" 
				target="_blank" >
                Reverse Z (and why it's so awesome) - Tom Hulton-Harrop
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The best article on the topic.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.vincentparizet.com/blog/posts/vulkan_perspective_matrix/" 
				class="external-link" 
				target="_blank" >
                Vulkan Projection Matrix - Vincent Parizet
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The explanation seems correct, but I'm quite sure his formulas use row_major, instead of column major.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://yancouto.github.io/functional/src/ultraviolet/projection/rh_yup.rs.html#350-365" 
				class="external-link" 
				target="_blank" >
                Ultraviolet Engine - Rust
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    I'm not sure I should trust this source.
				</p>
			</li>
			<li>
				<p>
                    <code>perspective_infinite_z_vk</code>
                    &nbsp;was incorrect.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Definitions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vertical_fov</code>
				</p>
				<ul>
					<li>
						<p>
                            Should be provided in radians.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>aspect_ratio</code>
				</p>
				<ul>
					<li>
						<p>
                            Should be the quotient 
                            <code>width / height</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="what-matters" >
    What matters
</h5>
<ul>
	<li>
		<p>
			<strong>
                Handedness
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It matters.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Which axis is vertical in NDC
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It matters.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Depth range
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It matters.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Y Up vs Z Up
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It doesn't matter.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="classical-z-reversed-z" >
    Classical-Z / Reversed-Z
</h4>
<ul>
	<li>
		<p>
            Also check 
			<a
				href="#Precision" 
				class="external-link" 
				target="_blank" >
                #Precision
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="vulkan" >
    Vulkan
</h5>
<ul>
	<li>
		<p>
            Flipping the Y axis is required because Vulkan's Y axis in clip space points down.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Other options
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Flipping y in the shader.
						</p>
					</li>
					<li>
						<p>
                            Setting a negative height for the viewport.
						</p>
					</li>
					<li>
						<p>
                            With reverse z it‚Äôs possible to just flip the order of the near and far arguments when using the regular projection matrix.
						</p>
					</li>
					<li>
						<p>
                            For whatever reason I prefer the above approach but please do what‚Äôs best for you and be aware of these other approaches out in the wild.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Classical-Z
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Finite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Direct result:
								</p>
							</li>
						</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
camera_perspective_vulkan_classical_z :: proc "contextless" (vertical_fov, aspect, near, far: f32) -&gt; (m: Mat4) #no_bounds_check {
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;Right-handed (Camera forward -Z).
&nbsp;&nbsp;&nbsp;&nbsp;Clip Space: left-handed, y-down, with Z (depth) extending from 0.0 (close) to 1.0 (far).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;focal_length := 1.0 / math.tan(0.5 * vertical_fov)
&nbsp;&nbsp;&nbsp;&nbsp;nmf := near - far
&nbsp;&nbsp;&nbsp;&nbsp;m[0, 0] = focal_length / aspect
&nbsp;&nbsp;&nbsp;&nbsp;m[1, 1] = -focal_length
&nbsp;&nbsp;&nbsp;&nbsp;m[2, 2] = far / nmf
&nbsp;&nbsp;&nbsp;&nbsp;m[3, 2] = -1
&nbsp;&nbsp;&nbsp;&nbsp;m[2, 3] = near * far / nmf
&nbsp;&nbsp;&nbsp;&nbsp;return
}
</code></pre>
						<ul>
							<li>
								<p>
                                    Manually: Take the OpenGL projection matrix, remap the depth from 0 to 1, and then additionally flip the Y axis.
								</p>
							</li>
						</ul>
<pre><code class="language-c" data-lang="c">mat4 perspective_vulkan_rh(const float fovy, const float aspect, const float n, const float f) {
&nbsp;&nbsp;constexpr mat4 vulkan_clip {1.0f,&nbsp;&nbsp;0.0f, 0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f, -1.0f, 0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;0.0f, 0.5f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;0.0f, 0.5f, 1.0f};
&nbsp;&nbsp;return mat_mul(perspective_opengl_rh(fovy, aspect, n, f), vulkan_clip);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The correct multiplication is vulkan_clip * perspective_opengl_rh (column-vector math)
}
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Infinite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
<pre><code class="language-odin" data-lang="odin">@(require_results)
camera_perspective_vulkan_infinite :: proc "contextless" (vertical_fov, aspect, near: f32) -&gt; (m: Mat4) #no_bounds_check {
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;Right-handed (Camera forward -Z).
&nbsp;&nbsp;&nbsp;&nbsp;Clip Space: left-handed, y-down, with Z (depth) extending from 1.0 (close) to 0.0 (far).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;focal_length := 1.0 / math.tan(0.5 * vertical_fov)
&nbsp;&nbsp;&nbsp;&nbsp;A :: -1.0
&nbsp;&nbsp;&nbsp;&nbsp;B := near
&nbsp;&nbsp;&nbsp;&nbsp;m[0, 0] = focal_length / aspect
&nbsp;&nbsp;&nbsp;&nbsp;m[1, 1] = -focal_length
&nbsp;&nbsp;&nbsp;&nbsp;m[2, 2] = A
&nbsp;&nbsp;&nbsp;&nbsp;m[3, 2] = -1
&nbsp;&nbsp;&nbsp;&nbsp;m[2, 3] = B
&nbsp;&nbsp;&nbsp;&nbsp;return
}
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Reversed-Z
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Clear depth to 0 (not 1 as usual).
				</p>
			</li>
			<li>
				<p>
                    Set depth test to 
					<em>
                        greater
					</em>
                    &nbsp;(not 
					<em>
                        less
					</em>
                    &nbsp;as usual).
				</p>
			</li>
			<li>
				<p>
                    Ensure you‚Äôre using a floating point depth buffer (e.g. 
                    <code>GL_DEPTH_COMPONENT32F</code>
                    , 
                    <code>DXGI_FORMAT_D32_FLOAT_S8X24_UINT</code>
                    , 
                    <code>MTLPixelFormat.depth32Float</code>
                    &nbsp;etc.)
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Finite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
<pre><code class="language-odin" data-lang="odin">@(require_results)
camera_perspective_vulkan_reversed_z :: proc "contextless" (vertical_fov, aspect, near, far: f32) -&gt; (m: Mat4) #no_bounds_check {
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;Right-handed (Camera forward -Z).
&nbsp;&nbsp;&nbsp;&nbsp;Clip Space: left-handed, y-down, with Z (depth) extending from 1.0 (close) to 0.0 (far).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;This procedure assumes near &lt; far.
&nbsp;&nbsp;&nbsp;&nbsp;If near &gt; far, the depth will be inverted, and far away geometry will be drawn first; which is incorrect.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;return camera_perspective_vulkan_classical_z(vertical_fov, aspect, far, near)
}
</code></pre>
						<ul>
							<li>
								<p>
									<a
										href="https://www.vincentparizet.com/blog/posts/vulkan_perspective_matrix/" 
										class="external-link" 
										target="_blank" >
                                        Vulkan Reversed-Z Finite - Vincent Parizet
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            I tested his version and it doesn't work for me.
										</p>
									</li>
									<li>
										<p>
                                            If I transpose his version, it works fine.
										</p>
									</li>
									<li>
										<p>
                                            His matrices are probably row-major, not column-major.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Infinite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
<pre><code class="language-odin" data-lang="odin">@(require_results)
camera_perspective_vulkan_reversed_z_infinite :: proc "contextless" (vertical_fov, aspect, near: f32) -&gt; (m: Mat4) #no_bounds_check {
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;Right-handed (Camera forward -Z).
&nbsp;&nbsp;&nbsp;&nbsp;Clip Space: left-handed, y-down, with Z (depth) extending from 1.0 (close) to 0.0 (far).
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;focal_length := 1.0 / math.tan(0.5 * vertical_fov)
&nbsp;&nbsp;&nbsp;&nbsp;A :: 0
&nbsp;&nbsp;&nbsp;&nbsp;B := near
&nbsp;&nbsp;&nbsp;&nbsp;m[0, 0] = focal_length / aspect
&nbsp;&nbsp;&nbsp;&nbsp;m[1, 1] = -focal_length
&nbsp;&nbsp;&nbsp;&nbsp;m[2, 2] = A
&nbsp;&nbsp;&nbsp;&nbsp;m[3, 2] = -1
&nbsp;&nbsp;&nbsp;&nbsp;m[2, 3] = B
&nbsp;&nbsp;&nbsp;&nbsp;return
}
</code></pre>
						<ul>
							<li>
								<p>
									<a
										href="https://www.vincentparizet.com/blog/posts/vulkan_perspective_matrix/" 
										class="external-link" 
										target="_blank" >
                                        Vulkan Reversed-Z Infinite - Vincent Parizet
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            I tested his version and it doesn't work for me.
										</p>
									</li>
									<li>
										<p>
                                            If I transpose his version, it becomes exactly equal to the implementation above, and it works fine.
										</p>
									</li>
									<li>
										<p>
                                            His matrices are probably row-major, not column-major.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Orthographic
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Right Handed
					</strong>
                    :
				</p>
<pre><code class="language-rust" data-lang="rust">/// Clip-space: left-handed and y-down with Z (depth) clip extending from 0.0 (close) to 1.0 (far).
#[inline]
pub fn orthographic_vk(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let rml = right - left;
&nbsp;&nbsp;&nbsp;&nbsp;let rpl = right + left;
&nbsp;&nbsp;&nbsp;&nbsp;let tmb = top - bottom;
&nbsp;&nbsp;&nbsp;&nbsp;let tpb = top + bottom;
&nbsp;&nbsp;&nbsp;&nbsp;let fmn = far - near;
&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(2.0 / rml, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, -2.0 / tmb, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -1.0 / fmn, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(-(rpl / rml), -(tpb / tmb), -(near / fmn), 1.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="directx-metal" >
    DirectX / Metal
</h5>
<ul>
	<li>
		<p>
            Uses 0 for the near plane and 1 for the far plane.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Classical-Z
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Finite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
<pre><code class="language-c" data-lang="c">// The resulting depth values mapped from 0 to 1.
mat4 perspective_direct3d_rh(const float fovy, const float aspect, const float n, const float f) {
&nbsp;&nbsp;const float e = 1.0f / std::tan(fovy * 0.5f);
&nbsp;&nbsp;return {e / aspect, 0.0f,&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e,&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp;&nbsp;f / (n - f),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, (f * n) / (n - f), 0.0f};
}
</code></pre>
<pre><code class="language-rust" data-lang="rust">/// Meant to be used with WebGPU or DirectX.
/// Clip-space: left-handed and y-up with Z (depth) clip extending from 0.0 (close) to 1.0 (far).
#[inline]
pub fn perspective_wgpu_dx(vertical_fov: f32, aspect_ratio: f32, z_near: f32, z_far: f32) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let t = (vertical_fov / 2.0).tan();
&nbsp;&nbsp;&nbsp;&nbsp;let sy = 1.0 / t;
&nbsp;&nbsp;&nbsp;&nbsp;let sx = sy / aspect_ratio;
&nbsp;&nbsp;&nbsp;&nbsp;let nmf = z_near - z_far;

&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(sx, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, sy, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, z_far / nmf, -1.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, z_near * z_far / nmf, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
					</li>
					<li>
						<p>
							<strong>
                                Left Handed
							</strong>
                            :
						</p>
<pre><code class="language-c" data-lang="c">// The resulting depth values mapped from 0 to 1.
mat4 perspective_direct3d_lh(const float fovy, const float aspect, const float n, const float f) {
&nbsp;&nbsp;const float e = 1.0f / std::tan(fovy * 0.5f);
&nbsp;&nbsp;return {e / aspect, 0.0f,&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e,&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp;&nbsp;f / (f - n),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, (f * n) / (n - f), 0.0f};
}
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Infinite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
<pre><code class="language-rust" data-lang="rust">/// Meant to be used with WebGPU, or DirectX.
/// Clip-space: left-handed and y-up with Z (depth) clip extending from 0.0 (close) to 1.0 (far).
#[inline]
pub fn perspective_infinite_z_wgpu_dx(vertical_fov: f32, aspect_ratio: f32, z_near: f32) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let t = (vertical_fov / 2.0).tan();
&nbsp;&nbsp;&nbsp;&nbsp;let sy = 1.0 / t;
&nbsp;&nbsp;&nbsp;&nbsp;let sx = sy / aspect_ratio;

&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(sx, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, sy, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -1.0, -1.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -z_near, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Reverse-Z
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Clear depth to 0 (not 1 as usual).
				</p>
			</li>
			<li>
				<p>
                    Set depth test to 
					<em>
                        greater
					</em>
                    &nbsp;(not 
					<em>
                        less
					</em>
                    &nbsp;as usual).
				</p>
			</li>
			<li>
				<p>
                    Ensure you‚Äôre using a floating point depth buffer (e.g. 
                    <code>GL_DEPTH_COMPONENT32F</code>
                    , 
                    <code>DXGI_FORMAT_D32_FLOAT_S8X24_UINT</code>
                    , 
                    <code>MTLPixelFormat.depth32Float</code>
                    &nbsp;etc.)
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Finite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
<pre><code class="language-rust" data-lang="rust">/// Meant to be used with WebGPU, OpenGL, or DirectX.
/// Clip-space: left-handed and y-up with Z (depth) clip extending from 0.0 (close) to 1.0 (far).
/// Note: In order for this to work properly with OpenGL, you'll need to use the `gl_arb_clip_control` extension 
/// and set the z clip from 0.0 to 1.0 rather than the default -1.0 to 1.0.
#[inline]
pub fn perspective_reversed_z_wgpu_dx_gl(
&nbsp;&nbsp;&nbsp;&nbsp;vertical_fov: f32,
&nbsp;&nbsp;&nbsp;&nbsp;aspect_ratio: f32,
&nbsp;&nbsp;&nbsp;&nbsp;z_near: f32,
&nbsp;&nbsp;&nbsp;&nbsp;z_far: f32,
) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let t = (vertical_fov / 2.0).tan();
&nbsp;&nbsp;&nbsp;&nbsp;let sy = 1.0 / t;
&nbsp;&nbsp;&nbsp;&nbsp;let sx = sy / aspect_ratio;
&nbsp;&nbsp;&nbsp;&nbsp;let nmf = z_near - z_far;

&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(sx, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, sy, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -z_far / nmf - 1.0, -1.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -z_near * z_far / nmf, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Infinite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right Handed
							</strong>
                            :
						</p>
<pre><code class="language-rust" data-lang="rust">/// Meant to be used with WebGPU, OpenGL, or DirectX.
/// Clip-space: left-handed and y-up with Z (depth) clip extending from 0.0 (close) to 1.0 (far).
/// Note: In order for this to work properly with OpenGL, you'll need to use the `gl_arb_clip_control` extension 
/// and set the z clip from 0.0 to 1.0 rather than the default -1.0 to 1.0.
#[inline]
pub fn perspective_reversed_infinite_z_wgpu_dx_gl(
&nbsp;&nbsp;&nbsp;&nbsp;vertical_fov: f32,
&nbsp;&nbsp;&nbsp;&nbsp;aspect_ratio: f32,
&nbsp;&nbsp;&nbsp;&nbsp;z_near: f32,
) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let t = (vertical_fov / 2.0).tan();
&nbsp;&nbsp;&nbsp;&nbsp;let sy = 1.0 / t;
&nbsp;&nbsp;&nbsp;&nbsp;let sx = sy / aspect_ratio;

&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(sx, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, sy, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, 0.0, -1.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, z_near, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Orthographic
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Right Handed
					</strong>
                    :
				</p>
<pre><code class="language-rust" data-lang="rust">/// Clip-space: left-handed and y-up with Z (depth) clip extending from 0.0 (close) to 1.0 (far).
#[inline]
pub fn orthographic_wgpu_dx(
&nbsp;&nbsp;&nbsp;&nbsp;left: f32,
&nbsp;&nbsp;&nbsp;&nbsp;right: f32,
&nbsp;&nbsp;&nbsp;&nbsp;bottom: f32,
&nbsp;&nbsp;&nbsp;&nbsp;top: f32,
&nbsp;&nbsp;&nbsp;&nbsp;near: f32,
&nbsp;&nbsp;&nbsp;&nbsp;far: f32,
) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let rml = right - left;
&nbsp;&nbsp;&nbsp;&nbsp;let rpl = right + left;
&nbsp;&nbsp;&nbsp;&nbsp;let tmb = top - bottom;
&nbsp;&nbsp;&nbsp;&nbsp;let tpb = top + bottom;
&nbsp;&nbsp;&nbsp;&nbsp;let fmn = far - near;
&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(2.0 / rml, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 2.0 / tmb, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -1.0 / fmn, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(-(rpl / rml), -(tpb / tmb), -(near / fmn), 1.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="legacy-opengl" >
    Legacy OpenGL
</h5>
<ul>
	<li>
		<p>
            Uses ‚àí1 for the near and 1 for the far. This is the worst for floating point precision.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Classical-Z
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Finite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right-handed
							</strong>
                            :
						</p>
<pre><code class="language-c" data-lang="c">// The resulting depth values mapped from -1 to +1.
mat4 perspective_opengl_rh(const float fovy, const float aspect, const float n, const float f) {
&nbsp;&nbsp;const float e = 1.0f / std::tan(fovy * 0.5f);
&nbsp;&nbsp;return {e / aspect, 0.0f,&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e,&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, (f + n) / (n - f),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, (2.0f * f * n) / (n - f), 0.0f};
}
</code></pre>
					</li>
					<li>
						<p>
							<strong>
                                Left-handed
							</strong>
                            :
						</p>
<pre><code class="language-c" data-lang="c">// The resulting depth values mapped from -1 to +1.
mat4 perspective_opengl_lh(const float fovy, const float aspect, const float n, const float f) {
&nbsp;&nbsp;const float e = 1.0f / std::tan(fovy * 0.5f);
&nbsp;&nbsp;return {e / aspect, 0.0f,&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e,&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, (f + n) / (f - n),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, (2.0f * f * n) / (n - f), 0.0f};
}
</code></pre>
					</li>
					<li>
						<p>
							<strong>
                                Normalizing Matrix
							</strong>
                            :
						</p>
<pre><code class="language-c" data-lang="c">// map from -1 to 1 to 0 to 1
mat4 normalize_unit_range(const mat4& perspective_projection)
{
&nbsp;&nbsp;constexpr mat4 normalize_range {1.0f, 0.0f, 0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f, 1.0f, 0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f, 0.0f, 0.5f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f, 0.0f, 0.5f, 1.0f};
&nbsp;&nbsp;return mat_mul(perspective_projection, normalize_range);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The correct multiplication is normalize_range * perspective_projection (column-vector math)
}
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Infinite
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Right-handed
							</strong>
                            :
						</p>
<pre><code class="language-rust" data-lang="rust">/// Clip-space: left-handed and y-up with Z (depth) clip extending from -1.0 (close) to 1.0 (far).
#[inline]
pub fn perspective_infinite_z_gl(vertical_fov: f32, aspect_ratio: f32, z_near: f32) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let t = (vertical_fov / 2.0).tan();
&nbsp;&nbsp;&nbsp;&nbsp;let sy = 1.0 / t;
&nbsp;&nbsp;&nbsp;&nbsp;let sx = sy / aspect_ratio;

&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(sx, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, sy, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -1.0, -1.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -2.0 * z_near, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Reverse-Z
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use the Normalizing Matrix above, and the Reverse-Z Matrix below, to get the final Proj Matrix.
				</p>
			</li>
			<li>
				<p>
                    We create a standard perspective matrix and update the depth mapping to be from -1 to 1 to 0 to 1 (all the matrix is doing is multiplying by 0.5 then adding 0.5 to achieve this).
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">const mat4 perspective_projection = perspective_opengl_rh(radians(60.0f), float(width) / float(height), near, far);
const mat4 reverse_z_perspective_projection = reverse_z(normalize_unit_range(perspective_projection));
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Steps
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Clear depth to 0 (not 1 as usual).
						</p>
					</li>
					<li>
						<p>
                            Set depth test to 
							<em>
                                greater
							</em>
                            &nbsp;(not 
							<em>
                                less
							</em>
                            &nbsp;as usual).
						</p>
					</li>
					<li>
						<p>
                            Ensure you‚Äôre using a floating point depth buffer (e.g. 
                            <code>GL_DEPTH_COMPONENT32F</code>
                            , 
                            <code>DXGI_FORMAT_D32_FLOAT_S8X24_UINT</code>
                            , 
                            <code>MTLPixelFormat.depth32Float</code>
                            &nbsp;etc.)
						</p>
					</li>
					<li>
						<p>
                            (in OpenGL) Make sure 
                            <code>glClipControl(GL_LOWER_LEFT, GL_ZERO_TO_ONE);</code>
                            &nbsp;is set so OpenGL knows the depth range will be 0 to 1 and not -1 to 1.
						</p>
					</li>
					<li>
						<p>
                            Extra that I saw somewhere: you'll need to use the 
                            <code>gl_arb_clip_control</code>
                            &nbsp;extension and set the z clip from 0.0 to 1.0 rather than the default -1.0 to 1.0
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Orthographic
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Right-handed
					</strong>
                    :
				</p>
<pre><code class="language-rust" data-lang="rust">/// Clip-space: left-handed and y-up with Z (depth) clip extending from -1.0 (close) to 1.0 (far).
#[inline]
pub fn orthographic_gl(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -&gt; Mat4 {
&nbsp;&nbsp;&nbsp;&nbsp;let rml = right - left;
&nbsp;&nbsp;&nbsp;&nbsp;let rpl = right + left;
&nbsp;&nbsp;&nbsp;&nbsp;let tmb = top - bottom;
&nbsp;&nbsp;&nbsp;&nbsp;let tpb = top + bottom;
&nbsp;&nbsp;&nbsp;&nbsp;let fmn = far - near;
&nbsp;&nbsp;&nbsp;&nbsp;let fpn = far + near;
&nbsp;&nbsp;&nbsp;&nbsp;Mat4::new(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(2.0 / rml, 0.0, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 2.0 / tmb, 0.0, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(0.0, 0.0, -2.0 / fmn, 0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vec4::new(-(rpl / rml), -(tpb / tmb), -(fpn / fmn), 1.0),
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="reverse-z" >
    Reverse-Z
</h5>
<ul>
	<li>
		<p>
            1 for the near plane and 0 for the far plane.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251007090952.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251007090517.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251007130200.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Reverse Z Matrix
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We can just swap the 
                    <code>near</code>
                    &nbsp;and 
                    <code>far</code>
                    &nbsp;parameters when calling the function.
				</p>
			</li>
			<li>
				<p>
                    Or we can create a new matrix that will produce a reverse Z friendly matrix for us.
				</p>
			</li>
			<li>
				<p>
                    This matrix flips the z/depth value to go from 1 to 0 instead of 0 to 1.
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">mat4 reverse_z(const mat4& perspective_projection)
{
&nbsp;&nbsp;constexpr mat4 reverse_z {1.0f, 0.0f,&nbsp;&nbsp;0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f, 1.0f,&nbsp;&nbsp;0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f, 0.0f, -1.0f, 0.0f,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0f, 0.0f,&nbsp;&nbsp;1.0f, 1.0f};
&nbsp;&nbsp;return mat_mul(perspective_projection, reverse_z);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The correct multiplication is reverse_z * perspective_projection (column-vector math)
}
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Note
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I tested doing this, but it simply didn't work.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Precision
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Results in a better distribution of the floating point values than using ‚àí1 and 1 or 0 and 1.
				</p>
			</li>
			<li>
				<p>
                    There is a truly 
					<em>
                        insane
					</em>
                    &nbsp;amount of precision near 0 with floating point numbers.
				</p>
			</li>
			<li>
				<p>
                    Out of the total range between 0.0 and 1.0, only approximately 
					<strong>
                        0.79%
					</strong>
                    &nbsp;of all representable values are between 0.5 and 1.0, with a staggering 
					<strong>
                        99.21%
					</strong>
                    &nbsp;between 0.0 and 0.5.
				</p>
			</li>
			<li>
				<p>
                    I always knew there was more precision near 0, but I don‚Äôt think I‚Äôd fully appreciated by quite how much.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Example
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Non-Reversed-Z:
						</p>
						<ul>
							<li>
								<p>
                                    If we choose a generous near clip plane of 1.0 and far clip plane of 100.0, and give an input value of say 5.0 to this equation we get an interesting result. The depth value is 0.808! That means even when we‚Äôre using regular z, and we have a value near the clip plane, we already have completely discarded an insane amount of precision because all those values near 0 already can‚Äôt be used. If we put in more representative numbers things get even worse. With a near clip plane of 0.01 and a far clip plane of 1000.0, using a view space depth value of 5.0 gives 0.998. That means we only have 33554 unique values left to represent normalized depth between 5.0 and 1000 which isn‚Äôt great.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Reversed-Z:
						</p>
						<ul>
							<li>
								<p>
                                    Now for the near clip plane at 1.0 and far clip plane at 100.0 case, with an input value of 5.0, we get approximately 0.192 for the depth value. If we set the near clip plane to 0.01 and the far clip plane to 1000, a view space depth value of 5.0 becomes approximately 0.00199. The amazing thing though is in this case we have 990014121 possible unique depth values, an improvement of 29500x over regular z.
								</p>
							</li>
							<li>
								<p>
                                    Reversing z has the effect of smoothing the precision throughout the range (we leverage the fact so much precision sits between 0.0 and 0.5 by ensuring more values end up there). Without reverse z, the precision is front-loaded to the near clip plane where we don‚Äôt need as much precision.
								</p>
							</li>
							<li>
								<p>
                                    The incredible thing about this is we gain all this extra precision and improved fidelity at no cost in performance or memory, which usually never happens in computer science or software engineering
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Usage in Orthographic Projection
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The depth precision gain is negligible. Orthographic mapping is linear in z, so the standard forward mapping already distributes precision uniformly.
				</p>
			</li>
			<li>
				<p>
                    You should only do it if your renderer globally uses reverse-Z for consistency (e.g. shared depth buffer with perspective passes), otherwise, keep Classical-Z.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="infinite-perspective" >
    Infinite Perspective
</h5>
<ul>
	<li>
		<p>
            Having to set scene-specific values for both the near and far plane can be a pain in the ass. If you want to display large open-world scenes, you will almost always use an absurdly high value for the far plane anyway.
		</p>
	</li>
	<li>
		<p>
            With the increased precision of using a Reverse-Z, it is possible to set an infinitely distant far plane.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251007123856.png" width="576" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage in Orthographic Projection
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Orthographic projections define a finite slab of space.&nbsp;&nbsp;Sending 
                    <code>far ‚Üí ‚àû</code>
                    &nbsp;removes the far clipping plane, but all geometry at any z beyond 
                    <code>near</code>
                    &nbsp;will still map to the same NDC z value (0 or 1 depending on convention).
				</p>
			</li>
			<li>
				<p>
                    Depth test stops discriminating depth beyond the near plane, so almost everything ‚Äúat infinity‚Äù z-fights.
				</p>
			</li>
			<li>
				<p>
                    It is mathematically valid but useless for depth testing. It can be used only if you never rely on depth ordering‚Äîe.g. for skybox or background plane rendering.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="nvidia-recommendations" >
    Nvidia Recommendations
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://developer.nvidia.com/content/depth-precision-visualized" 
				class="external-link" 
				target="_blank" >
                Article
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The 
            <code>1/z</code>
            &nbsp;(Reversed-Z) mapping and the choice of float versus integer depth buffer are a big part of the precision story, but not all of it. Even if you have enough depth precision to represent the scene you're trying to render, it's easy to end up with your precision controlled by error in the arithmetic of the vertex transformation process.
		</p>
	</li>
	<li>
		<p>
            As mentioned earlier, 
			<a
				href="http://www.geometry.caltech.edu/pubs/UD12.pdf" 
				class="external-link" 
				target="_blank" >
                Upchurch and Desbrun
			</a>
            &nbsp;studied this and came up with two main recommendations to minimize roundoff error:
		</p>
		<ol>
			<li>
				<p>
                    Use an infinite far plane.
				</p>
			</li>
			<li>
				<p>
                    Keep the projection matrix separate from other matrices, and apply it in a separate operation in the vertex shader, rather than composing it into the view matrix.
				</p>
				<ul>
					<li>
						<p>
                            In many cases, separating the view and projection matrices (following Upchurch and Desbrun‚Äôs recommendation) does make some improvement. While it doesn't lower the overall error rate, it does seem to turn swaps into indistinguishables, which is a step in the right direction.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
            Upchurch and Desbrun came up with these recommendations through an analytical technique, based on treating roundoff errors as small random perturbations introduced at each arithmetic operation, and keeping track of them to first order through the transformation process.
		</p>
	</li>
	<li>
		<p>
			<em>
                float32 or int24
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    There is no difference between float and integer depth buffers in most setups. The arithmetic error swamps the quantization error. In part this is because float32 and int24 have almost the same-sized ulp in [0.5, 1] (because float32 has a 23-bit mantissa), so there actually is almost no additional quantization error over the vast majority of the depth range.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Infinite Perspective
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    An infinite far plane makes only a miniscule difference in error rates. Upchurch and Desbrun predicted a 25% reduction in absolute 
					<em>
                        numerical
					</em>
                    &nbsp;error, but it doesn't seem to translate into a reduced rate of 
					<em>
                        comparison
					</em>
                    &nbsp;errors.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Reverse-Z
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The reversed-Z mapping is basically magic.
				</p>
			</li>
			<li>
				<p>
                    Reversed-Z with a float depth buffer gives a 
					<em>
                        zero error rate
					</em>
                    &nbsp;in this test. Now, of course you can make it generate some errors if you keep tightening the spacing of the input depth values. Still, reversed-Z with float is ridiculously more accurate than any of the other options.
				</p>
			</li>
			<li>
				<p>
                    Reversed-Z with an integer depth buffer is as good as any of the other integer options.
				</p>
			</li>
			<li>
				<p>
                    Reversed-Z erases the distinctions between precomposed versus separate view/projection matrices, and finite versus infinite far planes. In other words, with reversed-Z you can compose your projection matrix with other matrices, and you can use whichever far plane you like, without affecting precision at all.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Conclusion
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    In any perspective projection situation, just use a floating-point depth buffer with reversed-Z! And if you can't use a floating-point depth buffer, you should still use reversed-Z. It isn't a panacea for all precision woes, especially if you're building an open-world environment that contains extreme depth ranges. But it's a great start.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="view-frustum" >
    View Frustum
</h4>
<ul>
	<li>
		<p>
            It's a 
			<em>
                region
			</em>
            &nbsp;in 
			<em>
                Camera / View / Eye Space
			</em>
            ; it's not a matrix or a separated space.
		</p>
	</li>
	<li>
		<p>
            A view frustum is the truncated-pyramid volume (for perspective cameras) or box (for orthographic cameras) that defines the region of space potentially visible to the camera.
		</p>
	</li>
	<li>
		<p>
            Objects outside it are clipped or culled.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Perspective View Volume
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 3D region produced by a perspective camera: geometrically a truncated pyramid (frustum).
				</p>
			</li>
			<li>
				<p>
                    Points in view (camera/eye) space that lie inside this frustum are potentially visible and then mapped by the perspective projection matrix into the canonical volume (NDC).
				</p>
			</li>
			<li>
				<p>
                    This term is essentially the same concept as 
					<em>
                        View Frustum
					</em>
                    &nbsp;for perspective cameras.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Parameters
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Field of view (or focal length), aspect ratio, near plane, far plane.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Orthographic View Volume
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A rectangular box (prism) defining the visible region for an orthographic (parallel) projection.
				</p>
			</li>
			<li>
				<p>
                    Unlike the perspective frustum, there is no perspective foreshortening; parallel lines remain parallel.
				</p>
			</li>
			<li>
				<p>
                    The orthographic view volume is mapped to the canonical view volume by the orthographic projection matrix.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Parameters
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Left, right, top, bottom, near, far.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Plane representation
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The frustum can be represented by six plane equations. Those are convenient for fast culling and intersection tests.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Frustum culling
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a performance test done usually on the CPU/GPU before or during rendering.
				</p>
			</li>
			<li>
				<p>
                    It tests bounding volumes (AABBs/spheres) against the six frustum planes (left/right/top/bottom/near/far) to skip drawing objects outside the frustum.
				</p>
			</li>
			<li>
				<p>
                    Those plane tests can be done in 
					<em>
                        Camera / View / Eye Space
					</em>
                    &nbsp;(transform object bounds by the view matrix) or in 
					<em>
                        World Space
					</em>
                    &nbsp;(transform the frustum planes into world space by the inverse view).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="orthographic-projection-matrix" >
    Orthographic Projection Matrix
</h4>
<ul>
	<li>
		<p>
            A 4√ó4 matrix that implements an orthographic projection.
		</p>
	</li>
	<li>
		<p>
            It uses linear (non-perspective) mapping in z and x/y and does not produce perspective foreshortening.
		</p>
	</li>
</ul>
<h4
	id="perspective-projection-matrix" >
    Perspective Projection Matrix
</h4>
<ul>
	<li>
		<p>
            A 4√ó4 matrix that implements a perspective projection.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250811160302.png" width="250" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250811160220.png" width="250" >
            .
		</p>
	</li>
</ul>
<h3
	id="mvp-matrix-model-view-projection-matrix" >
    MVP Matrix / Model-View-Projection Matrix
</h3>
<ul>
	<li>
		<p>
            The combined matrix (Projection √ó View √ó Model).
		</p>
	</li>
	<li>
		<p>
            Multiply the model-space vertex by the MVP to get 
			<em>
                Clip Space
			</em>
            &nbsp;homogeneous coordinates; it's not in 
			<em>
                NDC Space
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            <code>glm::mat4 MVPmatrix = projection * view * model; // Remember: inverted!</code>
		</p>
	</li>
	<li>
		<p>
            Using a single combined matrix is common for efficiency.
		</p>
	</li>
</ul>
<h3
	id="clip-space" >
    Clip Space
</h3>
<ul>
	<li>
		<p>
            4D Homogeneous space.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Clip Space Position
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's the 
                    <code>gl_Position</code>
                    &nbsp;in GLSL.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Projected Frustum / Canonical Clip Volume
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Exists in 
					<em>
                        Clip Space
					</em>
                    &nbsp;after applying the 
					<em>
                        Projection Matrix
					</em>
                    &nbsp;to the 
					<em>
                        View Frustum
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    The 
					<em>
                        View Frustum
					</em>
                    &nbsp;is remapped so that:
				</p>
				<ul>
					<li>
						<p>
                            Left, right, top, bottom planes align with 
                            <code>x=¬±w</code>
                            , 
                            <code>y=¬±w</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Near, far planes align with 
                            <code>z=¬±w</code>
                            &nbsp;(OpenGL) or 
                            <code>z=[0,w]</code>
                            &nbsp;(D3D/Vulkan).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It's the 
					<em>
                        region
					</em>
                    &nbsp;the GPU will 
					<em>
                        Clip
					</em>
                    &nbsp;against.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Clipping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is performed in clip space (or against clip planes).
				</p>
			</li>
			<li>
				<p>
                    Removes geometry outside the canonical clip volume (the projected Frustum).
				</p>
			</li>
			<li>
				<p>
                    This avoids producing fragments that should not be visible and prevents division-by-zero problems.
				</p>
			</li>
			<li>
				<p>
					<em>
                        When to clip
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Reason it happens in clip space: the clip planes are linear in homogeneous coords; doing clipping after perspective divide would be non-linear and problematic.
						</p>
					</li>
					<li>
						<p>
                            Clipping in homogeneous clip space uses linear plane equations (easy and reliable).
						</p>
					</li>
					<li>
						<p>
                            If you divided first, you would get nonlinear boundaries and more complicated intersection math; also you could divide by 0 for points on the camera plane.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="perspective-divide" >
    Perspective Divide
</h3>
<ul>
	<li>
		<p>
            It's an operation to convert homogeneous clip coordinates to 3D (from 
			<em>
                Clip Space
			</em>
            &nbsp;to 
			<em>
                Canonical View Volume / NDC / Normalized Device Coordinates
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
            It's just an operation.
		</p>
	</li>
	<li>
		<p>
            Divide 
            <code>x</code>
            , 
            <code>y</code>
            , 
            <code>z</code>
            &nbsp;by 
            <code>w</code>
            &nbsp;from the 
			<em>
                Clip Space
			</em>
            &nbsp;to get the 
			<em>
                Canonical View Volume / NDC / Normalized Device Coordinates
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Once you perform the 
			<em>
                Perspective Divide
			</em>
            , that 
			<em>
                Projected Frustum
			</em>
            &nbsp;becomes the 
			<em>
                NDC Cube / Canonical View Volume
			</em>
            .
		</p>
	</li>
</ul>
<h3
	id="ndc-space-normalized-device-coordinates-space" >
    NDC Space / Normalized Device Coordinates Space
</h3>
<ul>
	<li>
		<p>
            3D non-homogeneous space.
		</p>
	</li>
	<li>
		<p>
            Is the result derived from 
			<em>
                Clip Space
			</em>
            &nbsp;by the 
			<em>
                Perspective Divide
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Geometry that lies inside the 
			<em>
                NDC Space
			</em>
            &nbsp;will map into the 
			<em>
                Viewport
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                NDC Cube / Canonical View Volume
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Obtained after performing the 
					<em>
                        Perspective Divide
					</em>
                    &nbsp;in the 
					<em>
                        Projected Frustum
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    Is convenient because the next mapping to pixels is a simple affine transform.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Coordinates
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    After a vertex is multiplied with this matrix X and Y, the resulting coordinates are position on the screen (between 
                    <code>[-1, 1]</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    The Z is used for the depth-buffer and identifies how far the vertex (or fragment) is from your camera's near plane.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Typical ranges
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    OpenGL convention:
				</p>
				<ul>
					<li>
						<p>
                            <code>x ‚àà [-1,1]</code>
                            , 
                            <code>y ‚àà [-1,1]</code>
                            , 
                            <code>z ‚àà [-1,1]</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Direct3D / Vulkan convention:
				</p>
				<ul>
					<li>
						<p>
                            <code>x ‚àà [-1,1]</code>
                            , 
                            <code>y ‚àà [-1,1]</code>
                            , 
                            <code>z ‚àà [0,1]</code>
                            &nbsp;(Z-range differs).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="viewport-transform-matrix" >
    Viewport Transform Matrix
</h3>
<ul>
	<li>
		<p>
            Transforms 
			<em>
                NDC Space / Normalized Device Coordinates Space / Canonical View Volume
			</em>
            &nbsp;to 
			<em>
                Window Coordinates / Screen Coordinates
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            This transform is linear in X and Y but affine in Z, mapping NDC z-range to depth buffer range (
            <code>[0,1]</code>
            &nbsp;or 
            <code>[-1,1]</code>
            ).
		</p>
	</li>
	<li>
		<p>
            This is the final transform before rasterization writes to the framebuffer.
		</p>
	</li>
	<li>
		<p>
            The projection stage produces normalized coordinates that are independent of the actual render target size or position.
		</p>
	</li>
	<li>
		<p>
            This transform gives those normalized coordinates a real position and scale on a particular render target (pixel grid + depth range).
		</p>
	</li>
	<li>
		<p>
            Without viewport mapping, you would only have coordinates in 
            <code>[-1,1]</code>
            &nbsp;(
			<em>
                NDC Space
			</em>
            ); the rasterizer needs actual pixel locations (and a depth value in the depth-buffer range) to generate fragments and write pixels.
		</p>
	</li>
	<li>
		<p>
            The GPU/driver usually applies this mapping automatically (parameters set by API calls such as 
            <code>glViewport</code>
            &nbsp;/ 
            <code>vkCmdSetViewport</code>
            ), but conceptually it is an affine transform applied after the 
			<em>
                Perspective Divide
			</em>
            .
		</p>
	</li>
</ul>
<h3
	id="screen-space-screen-coordinates-window-coordinates" >
    Screen Space / Screen Coordinates / Window Coordinates
</h3>
<ul>
	<li>
		<p>
            2D coordinates in pixels (and a depth value).
		</p>
	</li>
	<li>
		<p>
            It's the final stage before rasterization.
		</p>
	</li>
</ul>
<h3
	id="what-vulkan-does-implicitly" >
    What Vulkan does implicitly
</h3>
<ul>
	<li>
		<p>
            These are built-in, automatic steps the GPU will perform 
			<strong>
                after
			</strong>
            &nbsp;your 
			<em>
                Vertex Shader
			</em>
            &nbsp;runs, as part of the fixed-function pipeline:
		</p>
	</li>
	<li>
		<p>
			<strong>
                Clipping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vulkan 
					<em>
                        clips
					</em>
                    &nbsp;primitives against the 
					<em>
                        Projected Frustum / Canonical Clip Volume
					</em>
                    &nbsp;automatically, based on the convention:
				</p>
				<ul>
					<li>
						<p>
                            <code>x,y ‚àà [‚àíw,w]</code>
                            , 
                            <code>z ‚àà [0,w]</code>
                            &nbsp;in 
							<em>
                                Clip Space
							</em>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This happens whether you use 
					<em>
                        Perspective Projection
					</em>
                    &nbsp;or 
					<em>
                        Orthographic Projection
					</em>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Perspective Divide
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vulkan automatically divides 
                    <code>x</code>
                    , 
                    <code>y</code>
                    , 
                    <code>z</code>
                    &nbsp;by 
                    <code>w</code>
                    &nbsp;from the 
					<em>
                        Clip Space
					</em>
                    &nbsp;to get the 
					<em>
                        NDC Space
					</em>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Viewport Transform Matrix
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vulkan uses the 
                    <code>VkViewport</code>
                    &nbsp;parameters you provide to map 
					<em>
                        NDC Space
					</em>
                    &nbsp;to 
					<em>
                        Screen Space / Screen Coordinates / Window Coordinates
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    It also maps 
					<em>
                        NDC Cube
					</em>
                    &nbsp;Z from 
                    <code>[0, 1]</code>
                    &nbsp;to your depth-buffer range (possibly reversed if you configure it that way).
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.64934.js" >
		</script>
	</body>
</html>
