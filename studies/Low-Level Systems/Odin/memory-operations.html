<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.85839.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
					open="">
					<summary>
                        Odin
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/overview.html" >
                                Overview
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/my-impressions.html" >
                                My Impressions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/installation.html" >
                                Installation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/building.html" >
                                Building
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/compile-time-stuff.html" >
                                Compile-time Stuff
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/package-system.html" >
                                Package System
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/lsp-ols-odin-language-server.html" >
                                LSP (OLS - Odin Language Server)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/operations.html" >
                                Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/control-flow-if-when-switch-for-defer.html" >
                                Control Flow (if, when, switch, for, defer)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/procedures.html" >
                                Procedures
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/typing.html" >
                                Typing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/any.html" >
                                any
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/primitive-types.html" >
                                Primitive Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/matrix.html" >
                                Matrix
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/quaternion.html" >
                                Quaternion
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/complex.html" >
                                Complex
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/strings.html" >
                                Strings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/rune.html" >
                                Rune
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/maps-hash-maps.html" >
                                Maps (Hash Maps)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/struct.html" >
                                Struct
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/union.html" >
                                Union
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/bit-sets.html" >
                                Bit Sets
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/arrays.html" >
                                Arrays
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/interfaces-methods-vtables.html" >
                                Interfaces / Methods / VTables
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/error-handling.html" >
                                Error Handling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/context.html" >
                                Context
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/memory-address.html" >
                                Memory: Address
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/memory-allocators.html" >
                                Memory: Allocators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Low-Level Systems/Odin/memory-operations.html" >
                                Memory: Operations
							</a>
							<ul>
								<li>
									<a
										href="#mem-alloc" >
                                        Mem Alloc
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#new" >
                                        New
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mem-free" >
                                        Mem Free
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mem-free-all" >
                                        Mem Free All
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#make" >
                                        Make
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#deletes" >
                                        Deletes
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mem-resize" >
                                        Mem Resize
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mem-set" >
                                        Mem Set
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mem-copy" >
                                        Mem Copy
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#mem-zero" >
                                        Mem Zero
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#resize" >
                                        Resize
									</a>
									<ul>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/entry-point.html" >
                                Entry Point
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/multi-threading.html" >
                                Multi-Threading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/simd.html" >
                                SIMD
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/directives.html" >
                                Directives
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/ffi-foreign-function-interface-bindings.html" >
                                FFI (Foreign Function Interface) / Bindings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/web-build.html" >
                                Web Build
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/file-system-process-cli-shell.html" >
                                File System / Process / CLI / Shell
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/useful-packages.html" >
                                Useful Packages
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Memory
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/virtual-memory.html" >
                                Virtual Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/os-memory-on-windows.html" >
                                OS: Memory on Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/memory-alignment.html" >
                                Memory Alignment
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/address.html" >
                                Address
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/allocators.html" >
                                Allocators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/tools-memory-analysis.html" >
                                Tools: Memory Analysis
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/handles-instead-of-pointers.html" >
                                Handles instead of Pointers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/ownership-strategies-destruction-strategies.html" >
                                Ownership Strategies / Destruction Strategies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/strategies-for-handling-short-lived-memory.html" >
                                Strategies for handling short lived memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/garbage-collection.html" >
                                Garbage Collection
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/initialization.html" >
                                Initialization
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        CPU
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/physical-structure.html" >
                                Physical Structure
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/cache.html" >
                                Cache
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/soa-struct-of-arrays-ecs-entity-component-system.html" >
                                SOA (Struct Of Arrays) / ECS (Entity Component System)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/simd.html" >
                                SIMD
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Multithreading
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/core-concepts.html" >
                                Core Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/thread.html" >
                                Thread
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/strategies.html" >
                                Strategies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/implementation-detail.html" >
                                Implementation Detail
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/synchronization-primitives.html" >
                                Synchronization Primitives
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/double-buffering.html" >
                                Double-Buffering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/networking-strategies.html" >
                                Networking Strategies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Handmade Hero
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Profilers
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/tracy.html" >
                                Tracy
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/spall.html" >
                                Spall
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/nvidia-nsight-graphics-gpu-trace.html" >
                                Nvidia Nsight Graphics - GPU Trace
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/amd-gpu-profiler-amd-rgp.html" >
                                AMD GPU Profiler (AMD RGP)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/intel-gpa.html" >
                                Intel GPA
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/nsight-systems.html" >
                                <s>Nsight Systems</s>
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        C
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/critiques.html" >
                                Critiques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/c-standard.html" >
                                C Standard
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/c-standard-library-libc.html" >
                                C Standard Library (libc)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/building.html" >
                                Building
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/loops.html" >
                                Loops
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/strings.html" >
                                Strings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/structs.html" >
                                Structs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/pointers.html" >
                                Pointers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/arrays.html" >
                                Arrays
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/preprocessors.html" >
                                Preprocessors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/undefined-behavior.html" >
                                Undefined Behavior
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/gamedev.html" >
                                GameDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/windows-c-api.html" >
                                WIndows C API
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Build Systems - Compilation - Linking
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/compilation-process.html" >
                                Compilation Process
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/compilers.html" >
                                Compilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/build-tools.html" >
                                Build Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/meta-build-tools.html" >
                                Meta Build Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/extra-annoying-things-on-windows.html" >
                                Extra: Annoying things on Windows
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Debuggers
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/file-types.html" >
                                File Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/rad-debbuger.html" >
                                RAD Debbuger
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/gdb-gnu-debugger.html" >
                                GDB (GNU Debugger)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/lldb.html" >
                                LLDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/vscode.html" >
                                VSCode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/visual-studio-debugger.html" >
                                Visual Studio Debugger
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/others.html" >
                                Others
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/web.html" >
                                Web
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Assembly - ASM
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/assembly.html" >
                                Assembly
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/notes.html" >
                                Notes
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/reverse-engineering.html" >
                                Reverse Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/operations.html" >
                                Operations
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Parsing
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/parsing.html" >
                                Parsing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/lexer.html" >
                                Lexer
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/tools.html" >
                                Tools
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        JAI
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/impressions.html" >
                                Impressions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/build.html" >
                                Build
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/types.html" >
                                Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/meta-programming.html" >
                                Meta programming
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/control-flow.html" >
                                Control flow
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Memory: Operations
						</h1>
						<p>
							<time
								datetime="2025-03-28" >
                                ðŸ•’ Created: 2025-03-28
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h3
	id="mem-alloc" >
    Mem Alloc
</h3>
<ul>
	<li>
		<p>
            This function allocates 
            <code>size</code>
            &nbsp;bytes of memory, aligned to a boundary specified by 
            <code>alignment</code>
            &nbsp;using the allocator specified by 
            <code>allocator</code>
            .
		</p>
	</li>
	<li>
		<p>
            If the 
            <code>size</code>
            &nbsp;parameter is 
            <code>0</code>
            , the operation is a no-op.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Inputs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>size</code>
                    : The desired size of the allocated memory region.
				</p>
			</li>
			<li>
				<p>
                    <code>alignment</code>
                    : The desired alignment of the allocated memory region.
				</p>
			</li>
			<li>
				<p>
                    <code>allocator</code>
                    : The allocator to allocate from.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>core:mem</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
alloc :: proc(
Â  Â  size: int,
Â  Â  alignment: int = DEFAULT_ALIGNMENT,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; (rawptr, Allocator_Error) {
Â  Â  data, err := runtime.mem_alloc(size, alignment, allocator, loc)
Â  Â  return raw_data(data), err
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">@(require_results)
alloc_bytes :: proc(
Â  Â  size: int,
Â  Â  alignment: int = DEFAULT_ALIGNMENT,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) {
Â  Â  return runtime.mem_alloc(size, alignment, allocator, loc)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">@(require_results)
alloc_bytes_non_zeroed :: proc(
Â  Â  size: int,
Â  Â  alignment: int = DEFAULT_ALIGNMENT,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) {
Â  Â  return runtime.mem_alloc_non_zeroed(size, alignment, allocator, loc)
}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_alloc :: #force_no_inline proc(size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; ([]byte, Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if size == 0 || allocator.procedure == nil {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  return allocator.procedure(allocator.data, .Alloc, size, alignment, nil, 0, loc)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">mem_alloc_bytes :: #force_no_inline proc(size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; ([]byte, Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if size == 0 || allocator.procedure == nil{
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  return allocator.procedure(allocator.data, .Alloc, size, alignment, nil, 0, loc)
}
</code></pre>
<h3
	id="new" >
    New
</h3>
<ul>
	<li>
		<p>
            Allocates a single object.
		</p>
	</li>
	<li>
		<p>
            Returns a pointer to a newly allocated value of that type using the specified allocator.
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<h5
	id="new" >
    new
</h5>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
new :: proc($T: typeid, allocator := context.allocator, loc := #caller_location) -&gt; (t: ^T, err: Allocator_Error) #optional_allocator_error {
Â  Â  t = (^T)(raw_data(mem_alloc_bytes(size_of(T), align_of(T), allocator, loc) or_return))
Â  Â  return
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">ptr := new(int)
ptr^ = 123
x: int = ptr^
</code></pre>
	</li>
</ul>
<h5
	id="new_aligned" >
    new_aligned
</h5>
<pre><code class="language-odin" data-lang="odin">@(require_results)
new_aligned :: proc($T: typeid, alignment: int, allocator := context.allocator, loc := #caller_location) -&gt; (t: ^T, err: Allocator_Error) {
Â  Â  t = (^T)(raw_data(mem_alloc_bytes(size_of(T), alignment, allocator, loc) or_return))
Â  Â  return
}
</code></pre>
<h5
	id="new_clone" >
    new_clone
</h5>
<ul>
	<li>
		<p>
            Allocates a clone of the 
			<em>
                value
			</em>
            &nbsp;passed to it.
		</p>
	</li>
	<li>
		<p>
            The resulting value of the type will be a 
			<em>
                pointer
			</em>
            &nbsp;to the type of the value passed.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
new_clone :: proc(data: $T, allocator := context.allocator, loc := #caller_location) -&gt; (t: ^T, err: Allocator_Error) #optional_allocator_error {
Â  Â  t = (^T)(raw_data(mem_alloc_bytes(size_of(T), align_of(T), allocator, loc) or_return))
Â  Â  if t != nil {
Â  Â  Â  Â  t^ = data
Â  Â  }
Â  Â  return
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">ptr: ^int = new_clone(123)
assert(ptr^ == 123)
</code></pre>
	</li>
</ul>
<h3
	id="mem-free" >
    Mem Free
</h3>
<ul>
	<li>
		<p>
            Free a single object (opposite of 
            <code>new</code>
            )
		</p>
	</li>
	<li>
		<p>
            Will try to free the passed pointer, with the given 
            <code>allocator</code>
            &nbsp;if the allocator supports this operation.
		</p>
	</li>
	<li>
		<p>
            Only free memory with the allocator it was allocated with.
		</p>
	</li>
</ul>
<h5
	id="cautions" >
    Cautions
</h5>
<ul>
	<li>
		<p>
            Trying to free an object that is &quot;zero-initialized&quot; will not cause a &quot;bad-free&quot;.
		</p>
	</li>
	<li>
		<p>
            <code>free(&...)</code>
            &nbsp;will almost always be wrong, or at best unnecessary.
		</p>
		<ul>
			<li>
				<p>
                    If you need to use 
                    <code>&</code>
                    &nbsp;to get a pointer to something, then that something probably isn't allocated at all.
				</p>
			</li>
			<li>
				<p>
                    If it were allocated, you'd already have a pointer. e.g., in that example, 
                    <code>free(&d)</code>
                    &nbsp;would be trying to free a pointer to the stack--that'll never end well.
				</p>
			</li>
			<li>
				<p>
                    For built-in types like slices, dynamic arrays, maps, and strings, use 
                    <code>delete</code>
                    &nbsp;for those instead. They're not pointers themselves, but they have a pointer internally.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="procs" >
    Procs
</h5>
<ul>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@builtin
free :: proc{mem_free}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_free :: #force_no_inline proc(ptr: rawptr, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  if ptr == nil || allocator.procedure == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  _, err := allocator.procedure(allocator.data, .Free, 0, 0, ptr, 0, loc)
Â  Â  return err
}

mem_free_with_size :: #force_no_inline proc(ptr: rawptr, byte_count: int, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  if ptr == nil || allocator.procedure == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  _, err := allocator.procedure(allocator.data, .Free, 0, 0, ptr, byte_count, loc)
Â  Â  return err
}

mem_free_bytes :: #force_no_inline proc(bytes: []byte, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  if bytes == nil || allocator.procedure == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  _, err := allocator.procedure(allocator.data, .Free, 0, 0, raw_data(bytes), len(bytes), loc)
Â  Â  return err
}
</code></pre>
<ul>
	<li>
		<p>
            <code>core:mem</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">free :: proc(
Â  Â  ptr: rawptr,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; Allocator_Error {
Â  Â  return runtime.mem_free(ptr, allocator, loc)
}
</code></pre>
<h3
	id="mem-free-all" >
    Mem Free All
</h3>
<ul>
	<li>
		<p>
            Will try to free/reset all of the memory of the given 
            <code>allocator</code>
            &nbsp;if the allocator supports this operation.
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">// `free_all` will try to free/reset all of the memory of the given `allocator` if the allocator supports this operation.
@builtin
free_all :: proc{mem_free_all}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_free_all :: #force_no_inline proc(allocator := context.allocator, loc := #caller_location) -&gt; (err: Allocator_Error) {
Â  Â  if allocator.procedure != nil {
Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free_All, 0, 0, nil, 0, loc)
Â  Â  }
Â  Â  return
}
</code></pre>
<h3
	id="make" >
    Make
</h3>
<ul>
	<li>
		<p>
            Allocates and initializes a value of type slice, dynamic array, map, or multi-pointer (only).
		</p>
	</li>
	<li>
		<p>
            Unlike 
            <code>new</code>
            , 
            <code>make</code>
            's return value is the same as the type of its argument, not a pointer to it.
		</p>
	</li>
	<li>
		<p>
            Like 
            <code>new</code>
            , the first argument is a type, not a value.
		</p>
	</li>
	<li>
		<p>
            Uses the specified allocator; the default is 
            <code>context.allocator</code>
            .
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@builtin
make :: proc{
Â  Â  make_slice,
Â  Â  make_dynamic_array,
Â  Â  make_dynamic_array_len,
Â  Â  make_dynamic_array_len_cap,
Â  Â  make_map,
Â  Â  make_map_cap,
Â  Â  make_multi_pointer,
Â  Â  make_soa_slice,
Â  Â  make_soa_dynamic_array,
Â  Â  make_soa_dynamic_array_len,
Â  Â  make_soa_dynamic_array_len_cap,
}
</code></pre>
<ul>
	<li>
		<p>
            <code>make_aligned</code>
		</p>
		<ul>
			<li>
				<p>
                    Not included in 
                    <code>make</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>make_soa_aligned</code>
		</p>
		<ul>
			<li>
				<p>
                    Not included in 
                    <code>make</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<pre><code class="language-odin" data-lang="odin">slice := make([]int, 65)

dynamic_array_zero_length := make([dynamic]int)
dynamic_array_with_length := make([dynamic]int, 32)
dynamic_array_with_length_and_capacity := make([dynamic]int, 16, 64)

made_map := make(map[string]int)
made_map_with_reservation := make(map[string]int, 64)
</code></pre>
<h5
	id="allocation-in-structs" >
    Allocation in structs
</h5>
<ul>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    How can I ensure that the 
                    <code>[dynamic]</code>
                    &nbsp;arrays in the struct 
                    <code>physics_packet</code>
                    &nbsp;below use a custom allocator?
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">Physics_Packet :: struct {
Â  Â  tick_number: u64,
Â  Â  data: Physics_Data,
}

Physics_Data :: struct {
Â  Â  characters: [dynamic]Character_Data,
Â  Â  creatures: [dynamic]Creature_Data,
}

physics_packet: Physics_Packet
</code></pre>
		<ul>
			<li>
				<p>
                    When doing something like
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">append(&physics_packet.data.characters, {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;id = personagem.socket,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;pos = personagem.pos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
})

</code></pre>
		<ul>
			<li>
				<p>
                    How do I not use the 
                    <code>context.allocator</code>
                    &nbsp;but a custom allocator? I created the struct just by doing 
                    <code>physics_packet: Physics_Packet</code>
                    , so which allocator is used to define the arrays 
                    <code>characters</code>
                    &nbsp;and 
                    <code>creatures</code>
                    ?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    Use 
                    <code>physics_packet.data.characters = make([dynamic]Character_Data, allocator=custom_alloc)</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Chamberlain:
		</p>
		<ul>
			<li>
				<p>
                    The first append actually does the allocation unless you do it explicitly with make.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    What about ZII? Shouldn't I delete the &quot;previous array&quot; before assigning it with a 
                    <code>make</code>
                    ? Or even, is there a way that I define the whole struct using a custom allocator, without having to redefine the arrays, just to use a different allocator? There's also the question of which allocator is used when creating the struct.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Chamberlain:
		</p>
		<ul>
			<li>
				<p>
                    No allocator is used when creating the struct.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    If you declared 
                    <code>physics_packet</code>
                    &nbsp;as a local variable, then it'll be zero-initialized on the stack. No allocation will happen (depending on how technical you are about &quot;allocation&quot;; technically it was allocated on the stack--but that's completely unrelated to 
                    <code>Allocator</code>
                    s). That includes the dynamic arrays in it, where &quot;zero&quot; means &quot;no pointer, 0 length, no allocator&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="slice" >
    slice
</h5>
<ul>
	<li>
		<p>
            Allocates and initializes a slice
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
make_aligned :: proc($T: typeid/[]$E, #any_int len: int, alignment: int, allocator := context.allocator, loc := #caller_location) -&gt; (res: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_aligned_type_erased(&res, size_of(E), len, alignment, allocator, loc)
Â  Â  return
}

@(require_results)
_make_aligned_type_erased :: proc(slice: rawptr, elem_size: int, len: int, alignment: int, allocator: Allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  make_slice_error_loc(loc, len)
Â  Â  data, err := mem_alloc_bytes(elem_size*len, alignment, allocator, loc)
Â  Â  if data == nil && elem_size != 0 {
Â  Â  Â  Â  return err
Â  Â  }
Â  Â  (^Raw_Slice)(slice).data = raw_data(data)
Â  Â  (^Raw_Slice)(slice).len Â = len
Â  Â  return err
}

@(builtin, require_results)
make_slice :: proc($T: typeid/[]$E, #any_int len: int, allocator := context.allocator, loc := #caller_location) -&gt; (res: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_aligned_type_erased(&res, size_of(E), len, align_of(E), allocator, loc)
Â  Â  return
}
</code></pre>
<h5
	id="dynamic-array" >
    dynamic array
</h5>
<ul>
	<li>
		<p>
            Allocates and initializes a dynamic array.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
make_dynamic_array :: proc($T: typeid/[dynamic]$E, allocator := context.allocator, loc := #caller_location) -&gt; (array: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_dynamic_array_len_cap((^Raw_Dynamic_Array)(&array), size_of(E), align_of(E), 0, 0, allocator, loc)
Â  Â  return
}

@(builtin, require_results)
make_dynamic_array_len :: proc($T: typeid/[dynamic]$E, #any_int len: int, allocator := context.allocator, loc := #caller_location) -&gt; (array: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_dynamic_array_len_cap((^Raw_Dynamic_Array)(&array), size_of(E), align_of(E), len, len, allocator, loc)
Â  Â  return
}

@(builtin, require_results)
make_dynamic_array_len_cap :: proc($T: typeid/[dynamic]$E, #any_int len: int, #any_int cap: int, allocator := context.allocator, loc := #caller_location) -&gt; (array: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  err = _make_dynamic_array_len_cap((^Raw_Dynamic_Array)(&array), size_of(E), align_of(E), len, cap, allocator, loc)
Â  Â  return
}

@(require_results)
_make_dynamic_array_len_cap :: proc(array: ^Raw_Dynamic_Array, size_of_elem, align_of_elem: int, #any_int len: int, #any_int cap: int, allocator := context.allocator, loc := #caller_location) -&gt; (err: Allocator_Error) {
Â  Â  make_dynamic_array_error_loc(loc, len, cap)
Â  Â  array.allocator = allocator // initialize allocator before just in case it fails to allocate any memory
Â  Â  data := mem_alloc_bytes(size_of_elem*cap, align_of_elem, allocator, loc) or_return
Â  Â  use_zero := data == nil && size_of_elem != 0
Â  Â  array.data = raw_data(data)
Â  Â  array.len = 0 if use_zero else len
Â  Â  array.cap = 0 if use_zero else cap
Â  Â  array.allocator = allocator
Â  Â  return
}
</code></pre>
<h5
	id="map" >
    map
</h5>
<ul>
	<li>
		<p>
            Initializes a map with an allocator.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
make_map :: proc($T: typeid/map[$K]$E, allocator := context.allocator, loc := #caller_location) -&gt; (m: T) {
Â  Â  m.allocator = allocator
Â  Â  return m
}

@(builtin, require_results)
make_map_cap :: proc($T: typeid/map[$K]$E, #any_int capacity: int, allocator := context.allocator, loc := #caller_location) -&gt; (m: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  make_map_expr_error_loc(loc, capacity)
Â  Â  context.allocator = allocator
Â  Â  err = reserve_map(&m, capacity, loc)
Â  Â  return
}
</code></pre>
<h5
	id="multi-pointer" >
    Multi-pointer
</h5>
<ul>
	<li>
		<p>
            Allocates and initializes a multi-pointer.
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(builtin, require_results)
make_multi_pointer :: proc($T: typeid/[^]$E, #any_int len: int, allocator := context.allocator, loc := #caller_location) -&gt; (mp: T, err: Allocator_Error) #optional_allocator_error {
Â  Â  make_slice_error_loc(loc, len)
Â  Â  data := mem_alloc_bytes(size_of(E)*len, align_of(E), allocator, loc) or_return
Â  Â  if data == nil && size_of(E) != 0 {
Â  Â  Â  Â  return
Â  Â  }
Â  Â  mp = cast(T)raw_data(data)
Â  Â  return
}
</code></pre>
<h3
	id="deletes" >
    Deletes
</h3>
<ul>
	<li>
		<p>
            Free a group of objects (opposite of 
            <code>make</code>
            )
		</p>
	</li>
	<li>
		<p>
            Deletes the backing memory of a value allocated with make or a string that was allocated through an allocator.
		</p>
	</li>
	<li>
		<p>
            Will try to free the underlying data of the passed built-in data structure (string, cstring, dynamic array, slice, or map), with the given 
            <code>allocator</code>
            &nbsp;if the allocator supports this operation.
		</p>
	</li>
	<li>
		<p>
            <code>base:builtin</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@builtin
delete :: proc{
Â  Â  delete_string,
Â  Â  delete_cstring,
Â  Â  delete_dynamic_array,
Â  Â  delete_slice,
Â  Â  delete_map,
Â  Â  delete_soa_slice,
Â  Â  delete_soa_dynamic_array,
Â  Â  delete_string16,
Â  Â  delete_cstring16,
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Recursiveness
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>delete</code>
                    &nbsp;isn't recursive. It has no way of knowing whether you actually 
					<em>
                        want
					</em>
                    &nbsp;to delete the contents or not--you may not always.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">Â  Â  array_args_as_bytes: [dynamic][]u8

&nbsp;&nbsp;&nbsp;&nbsp;// Option 1: Don't delete everything.
&nbsp;&nbsp;&nbsp;&nbsp;defer delete(array_args_as_bytes)

Â  Â  // Option 2: Delete everything.
Â  Â  defer {
Â  Â  Â  Â  for arg in array_args_as_bytes {
Â  Â  Â  Â  Â  Â  delete(arg)
Â  Â  Â  Â  }
Â  Â  Â  Â  delete(array_args_as_bytes)
Â  Â  }
</code></pre>
		<ul>
			<li>
				<p>
                    If it's a struct, it's not uncommon to make a 
                    <code>destroy_struct</code>
                    &nbsp;proc that does this for you.
				</p>
				<ul>
					<li>
						<p>
                            Example: 
							<a
								href="https://github.com/odin-lang/Odin/blob/master/core/encoding/json/types.odin#L92" 
								class="external-link" 
								target="_blank" >
                                <code>json.destroy_value</code>
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The way I understand it is that the 
                    <code>data</code>
                    &nbsp;of the object is deleted. The 
                    <code>data</code>
                    &nbsp;itself is a pointer to where the data is stored, so deleting the 
                    <code>data</code>
                    &nbsp;is deleting the pointer.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="string" >
    string
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_string :: proc(str: string, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(str), len(str), allocator, loc)
}
</code></pre>
<h5
	id="cstring" >
    cstring
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_cstring :: proc(str: cstring, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free((^byte)(str), allocator, loc)
}
</code></pre>
<h5
	id="string16" >
    string16
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_string16 :: proc(str: string16, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(str), len(str)*size_of(u16), allocator, loc)
}
</code></pre>
<h5
	id="cstring16" >
    cstring16
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_cstring16 :: proc(str: cstring16, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free((^u16)(str), allocator, loc)
}
</code></pre>
<h5
	id="dynamic-array" >
    dynamic array
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_dynamic_array :: proc(array: $T/[dynamic]$E, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(array), cap(array)*size_of(E), array.allocator, loc)
}
</code></pre>
<h5
	id="slice" >
    slice
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_slice :: proc(array: $T/[]$E, allocator := context.allocator, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return mem_free_with_size(raw_data(array), len(array)*size_of(E), allocator, loc)
}
</code></pre>
<h5
	id="map" >
    Map
</h5>
<pre><code class="language-odin" data-lang="odin">@builtin
delete_map :: proc(m: $T/map[$K]$V, loc := #caller_location) -&gt; Allocator_Error {
Â  Â  return map_free_dynamic(transmute(Raw_Map)m, map_info(T), loc)
}
</code></pre>
<h3
	id="mem-resize" >
    Mem Resize
</h3>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">_mem_resize :: #force_no_inline proc(
&nbsp;&nbsp;&nbsp;&nbsp;ptr: rawptr, 
&nbsp;&nbsp;&nbsp;&nbsp;old_size, 
&nbsp;&nbsp;&nbsp;&nbsp;new_size: int, 
&nbsp;&nbsp;&nbsp;&nbsp;alignment: int = DEFAULT_ALIGNMENT, 
&nbsp;&nbsp;&nbsp;&nbsp;allocator := context.allocator, 
&nbsp;&nbsp;&nbsp;&nbsp;should_zero: bool, 
&nbsp;&nbsp;&nbsp;&nbsp;loc := #caller_location
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (data: []byte, err: Allocator_Error) {
&nbsp;&nbsp;&nbsp;&nbsp;
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if allocator.procedure == nil {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  if new_size == 0 {
Â  Â  Â  Â  if ptr != nil {
Â  Â  Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  } else if ptr == nil {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  } else if old_size == new_size && uintptr(ptr) % uintptr(alignment) == 0 {
Â  Â  Â  Â  data = ([^]byte)(ptr)[:old_size]
Â  Â  Â  Â  return
Â  Â  }
Â  Â  if should_zero {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize, new_size, alignment, ptr, old_size, loc)
Â  Â  } else {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize_Non_Zeroed, new_size, alignment, ptr, old_size, loc)
Â  Â  }
Â  Â  if err == .Mode_Not_Implemented {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  Â  Â  if err != nil {
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  copy(data, ([^]byte)(ptr)[:old_size])
Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  }
Â  Â  return
}

mem_resize :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;ptr: rawptr, 
&nbsp;&nbsp;&nbsp;&nbsp;old_size, 
&nbsp;&nbsp;&nbsp;&nbsp;new_size: int, 
&nbsp;&nbsp;&nbsp;&nbsp;alignment: int = DEFAULT_ALIGNMENT, 
&nbsp;&nbsp;&nbsp;&nbsp;allocator := context.allocator, 
&nbsp;&nbsp;&nbsp;&nbsp;loc := #caller_location
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, true, loc)
}

non_zero_mem_resize :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;ptr: rawptr, 
&nbsp;&nbsp;&nbsp;&nbsp;old_size, 
&nbsp;&nbsp;&nbsp;&nbsp;new_size: int, 
&nbsp;&nbsp;&nbsp;&nbsp;alignment: int = DEFAULT_ALIGNMENT, 
&nbsp;&nbsp;&nbsp;&nbsp;allocator := context.allocator, 
&nbsp;&nbsp;&nbsp;&nbsp;loc := #caller_location
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, false, loc)
}
</code></pre>
<h3
	id="mem-set" >
    Mem Set
</h3>
<ul>
	<li>
		<p>
            Set a number of bytes (
            <code>len</code>
            ) to a value (
            <code>val</code>
            ), from the address specified (
            <code>ptr</code>
            ).
		</p>
	</li>
</ul>
<h5
	id="using-the-c-runtime-library-crt" >
    Using the 'C Runtime Library' (CRT)
</h5>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">when ODIN_NO_CRT == true && ODIN_OS == .Windows {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memset", linkage="strong", require)
Â  Â  memset :: proc "c" (ptr: rawptr, val: i32, len: int) -&gt; rawptr {
Â  Â  Â  Â  RtlFillMemory(ptr, len, val)
Â  Â  Â  Â  return ptr
Â  Â  }
} else when ODIN_NO_CRT || (ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32)) {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memset", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memset :: proc "c" (ptr: rawptr, val: i32, #any_int len: int_t) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ptr != nil && len != 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b := byte(val)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p := ([^]byte)(ptr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := int_t(0); i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[i] = b
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr
&nbsp;&nbsp;&nbsp;&nbsp;}
} else {
&nbsp;&nbsp;&nbsp;&nbsp;memset :: proc "c" (ptr: rawptr, val: i32, len: int) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ptr != nil && len != 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b := byte(val)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p := ([^]byte)(ptr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[i] = b
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h5
	id="in-c" >
    In C
</h5>
<ul>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/C.html#mem-set">
            C#Mem Set
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="mem-copy" >
    Mem Copy
</h3>
<h5
	id="which-one-to-use" >
    Which one to use
</h5>
<ul>
	<li>
		<p>
			<strong>
                TLDR
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Barinzaya / Tetralux / Yawning:
				</p>
				<ul>
					<li>
						<p>
                            Use 
                            <code>copy</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The difference in performance is going to be pretty small between any of them. Anything 
                            <code>non_overlapping</code>
                            &nbsp;is a slight optimization at most if you know 
							<strong>
                                for sure
							</strong>
                            &nbsp;it won't overlap. If it does, it may completely wreck your data.
						</p>
					</li>
					<li>
						<p>
                            Use 
                            <code>intrinsics.mem_copy_non_overlapping</code>
                            &nbsp;or other option if you profile and see 
                            <code>copy</code>
                            &nbsp;to be an issue.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>copy</code>
		</p>
		<ul>
			<li>
				<p>
                    For convenience and safety, but slower.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>intrinsics.mem_copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    For speed and no safety.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>runtime.copy</code>
            &nbsp;/ 
            <code>runtime.copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    A middle ground between the two above, I guess,
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>mem.copy</code>
            &nbsp;/ 
            <code>mem.copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    Just a indirection from 
                    <code>intrinsics.mem_copy</code>
                    &nbsp;/ 
                    <code>intrinsics.mem_copy_non_overlapping</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>mem.copy</code>
                    &nbsp;is a tiny wrapper that will almost certainly end up inlined with any optimization on.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>core:c/libc</code>
		</p>
		<ul>
			<li>
				<p>
                    Ignore this one, is just there for completeness.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="equivalence-to-cs" >
    Equivalence to C's
</h5>
<ul>
	<li>
		<p>
            <code>mem_copy</code>
		</p>
		<ul>
			<li>
				<p>
                    Similar to C's 
                    <code>memmove</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Requires a little bit of additional logic to correctly handle the ranges overlapping.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>mem_copy_non_overlapping</code>
		</p>
		<ul>
			<li>
				<p>
                    Similar to C's 
                    <code>memcopy</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="using-codeintrinsics-code" >
    Using 
    <code>intrinsics</code>
</h5>
<ul>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>intrinsic</code>
                    &nbsp;is handled by the compiler. It does a bit of additional &quot;smart&quot; stuff--if the length is constant, it emits the instructions to do the copy inline (without a call), and it just tells LLVM to do the 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    . LLVM may in fact just call the 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    &nbsp;proc (provided by the CRT or 
                    <code>procs.odin</code>
                    ), if it sees fit.
				</p>
			</li>
			<li>
				<p>
                    But it still allows LLVM to be a little &quot;smarter&quot; about it, AFAIK. Since it 
					<em>
                        knows
					</em>
                    &nbsp;what the proc does, it can potentially elide the copy (though probably less so in the case where the length is variable).
				</p>
			</li>
			<li>
				<p>
                    Every available copy procedure uses 
                    <code>intrinsics.mem_copy</code>
                    &nbsp;or 
                    <code>intrinsics.mem_copy_non_overlapping</code>
                    &nbsp;under the hood, so therefore, all those implementations benefit from possible compiler optimizations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
		<ul>
			<li>
				<p>
                    Builtin.
				</p>
			</li>
			<li>
				<p>
                    Slice / Strings.
				</p>
			</li>
			<li>
				<p>
                    Copies elements from a source slice/string 
                    <code>src</code>
                    &nbsp;to a destination slice 
                    <code>dst</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of 
                    <code>len(src)</code>
                    &nbsp;and 
                    <code>len(dst)</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
copy_slice_raw :: proc "contextless" (dst, src: rawptr, dst_len, src_len, elem_size: int) -&gt; int {
Â  Â  n := min(dst_len, src_len)
Â  Â  if n &gt; 0 {
Â  Â  Â  Â  intrinsics.mem_copy(dst, src, n*elem_size)
Â  Â  }
Â  Â  return n
}

@builtin
copy_slice :: #force_inline proc "contextless" (dst, src: $T/[]$E) -&gt; int {
Â  Â  return copy_slice_raw(raw_data(dst), raw_data(src), len(dst), len(src), size_of(E))
}

@builtin
copy_from_string :: #force_inline proc "contextless" (dst: $T/[]$E/u8, src: $S/string) -&gt; int {
Â  Â  return copy_slice_raw(raw_data(dst), raw_data(src), len(dst), len(src), 1)
}

@builtin
copy :: proc{copy_slice, copy_from_string, copy_from_string16}
</code></pre>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
		<ul>
			<li>
				<p>
                    General.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">mem_copy :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
Â  Â  if src != nil && dst != src && len &gt; 0 {
Â  Â  Â  Â  // NOTE(bill): This _must_ be implemented like C's memmove
Â  Â  Â  Â  intrinsics.mem_copy(dst, src, len)
Â  Â  }
Â  Â  return dst
}

mem_copy_non_overlapping :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
Â  Â  if src != nil && dst != src && len &gt; 0 {
Â  Â  Â  Â  // NOTE(bill): This _must_ be implemented like C's memcpy
Â  Â  Â  Â  intrinsics.mem_copy_non_overlapping(dst, src, len)
Â  Â  }
Â  Â  return dst
}
</code></pre>
	</li>
	<li>
		<p>
            <code>core:mem</code>
		</p>
<pre><code class="language-odin" data-lang="odin">copy :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;intrinsics.mem_copy(dst, src, len)
&nbsp;&nbsp;&nbsp;&nbsp;return dst
}

copy_non_overlapping :: proc "contextless" (dst, src: rawptr, len: int) -&gt; rawptr {
Â  Â  intrinsics.mem_copy_non_overlapping(dst, src, len)
Â  Â  return dst
}
</code></pre>
	</li>
	<li>
		<p>
            <code>base:intrinsics</code>
		</p>
<pre><code class="language-odin" data-lang="odin">mem_copy Â  Â  Â  Â  Â  Â  Â  Â  :: proc(dst, src: rawptr, len: int) ---
mem_copy_non_overlapping :: proc(dst, src: rawptr, len: int) ---
</code></pre>
	</li>
</ul>
<h5
	id="using-codecorec-libc-code" >
    Using 
    <code>core:c/libc</code>
</h5>
<ul>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    It's just procs from libc--part of which is the CRT. So the 
                    <code>libc</code>
                    &nbsp;one is explicitly the CRT implementation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>core:c/libc</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">memcpy Â  :: proc(s1, s2: rawptr, n: size_t) -&gt; rawptr ---

memmove Â :: proc(s1, s2: rawptr, n: size_t) -&gt; rawptr ---

strcpy Â  :: proc(s1: [^]char, s2: cstring) -&gt; [^]char ---
strncpy Â :: proc(s1: [^]char, s2: cstring, n: size_t) -&gt; [^]char ---
</code></pre>
<h5
	id="implementation-from-c-runtime-library-crt" >
    Implementation from 'C Runtime Library' (CRT)
</h5>
<ul>
	<li>
		<p>
            <code>ODIN_NO_CRT</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>true</code>
                    &nbsp;if the 
                    <code>-no-crt</code>
                    &nbsp;command line switch is passed, which inhibits linking with the C Runtime Library, a.k.a. LibC.
				</p>
			</li>
			<li>
				<p>
                    The default is 
                    <code>false</code>
                    , so CRT 
					<strong>
                        is
					</strong>
                    &nbsp;used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
			<input
				type="checkbox" 
				disabled=""
>
            Should I enabled CRT or not? I forgot to ask that, oops
		</p>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    <code>memcpy</code>
                    &nbsp;and 
                    <code>memmove</code>
                    &nbsp;are part of the C run-time, and LLVM 
					<em>
                        needs to have them
					</em>
                    . If you disable the CRT, then they need to be provided--hence, why they're in 
                    <code>procs.odin</code>
                    . Note that they're in 
                    <code>when ODIN_NO_CRT</code>
                    &nbsp;blocks (plus other conditions). So the 
                    <code>procs.odin</code>
                    &nbsp;implementation is used when the CRT isn't linked, because they need to exist
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    Can I say that 
                    <code>procs.odin</code>
                    &nbsp;provides an implementation 
					<strong>
                        for
					</strong>
                    &nbsp;
                    <code>intrinsics</code>
                    &nbsp;copy procedures, considering the conditions defined in the 
                    <code>procs.odin</code>
                    ? As a fallback I mean, I assume 
                    <code>intrinsics</code>
                    &nbsp;already have an implementation somewhere.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Barinzaya:
		</p>
		<ul>
			<li>
				<p>
                    Not entirely, 
                    <code>procs.odin</code>
                    &nbsp;is more &quot;stuff needed for LLVM to work at all when the CRT isn't included&quot;
				</p>
			</li>
			<li>
				<p>
                    <code>intrinsics</code>
                    &nbsp;are all implemented in the compiler itself. In the case of the 
                    <code>copy</code>
                    s, they defer to LLVM intrinsics, which 
					<em>
                        may
					</em>
                    &nbsp;call 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    &nbsp;from the CRT or 
                    <code>procs.odin</code>
                    --but they also may not
				</p>
			</li>
			<li>
				<p>
                    Also, LLVM can call 
                    <code>memcpy</code>
                    /
                    <code>memmove</code>
                    &nbsp;
					<em>
                        without
					</em>
                    &nbsp;those intrinsics too, for sufficiently large copies.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tetralux:
		</p>
		<ul>
			<li>
				<p>
                    Intrinsics are more &quot;compiler hooks&quot; for &quot;I want to do this thing please&quot;
				</p>
			</li>
			<li>
				<p>
                    They are somewhat opaque things if you see what I mean
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">when ODIN_NO_CRT == true && ODIN_OS == .Windows {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memcpy", linkage="strong", require)
Â  Â  memcpy :: proc "c" (dst, src: rawptr, len: int) -&gt; rawptr {
Â  Â  Â  Â  RtlMoveMemory(dst, src, len)
Â  Â  Â  Â  return dst
Â  Â  }
Â  Â  
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memmove", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memmove :: proc "c" (dst, src: rawptr, len: int) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RtlMoveMemory(dst, src, len)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;}
} else when ODIN_NO_CRT || (ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32)) {
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memcpy", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memcpy :: proc "c" (dst, src: rawptr, #any_int len: int_t) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d, s := ([^]byte)(dst), ([^]byte)(src)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d != s {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := int_t(0); i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i] = s[i]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return d
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@(link_name="memmove", linkage="strong", require)
&nbsp;&nbsp;&nbsp;&nbsp;memmove :: proc "c" (dst, src: rawptr, #any_int len: int_t) -&gt; rawptr {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d, s := ([^]byte)(dst), ([^]byte)(src)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d == s || len == 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d &gt; s && uintptr(d)-uintptr(s) &lt; uintptr(len) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := len-1; i &gt;= 0; i -= 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i] = s[i]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if s &gt; d && uintptr(s)-uintptr(d) &lt; uintptr(len) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := int_t(0); i &lt; len; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i] = s[i]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dst
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return memcpy(dst, src, len)
&nbsp;&nbsp;&nbsp;&nbsp;}
} else {
&nbsp;&nbsp;&nbsp;&nbsp;// None.
}
</code></pre>
<h5
	id="in-c" >
    In C
</h5>
<ul>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/C.html#mem-copy">
            C#Mem Copy
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="mem-zero" >
    Mem Zero
</h3>
<h5
	id="using-codeintrinsics-code" >
    Using 
    <code>intrinsics</code>
</h5>
<ul>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_zero :: proc "contextless" (data: rawptr, len: int) -&gt; rawptr {
Â  Â  if data == nil {
Â  Â  Â  Â  return nil
Â  Â  }
Â  Â  if len &lt;= 0 {
Â  Â  Â  Â  return data
Â  Â  }
Â  Â  intrinsics.mem_zero(data, len)
Â  Â  return data
}
</code></pre>
<ul>
	<li>
		<p>
            <code>base:intrinsics</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">mem_zero Â  Â  Â  Â  Â  Â  Â  Â  :: proc(ptr: rawptr, len: int) ---
mem_zero_volatile Â  Â  Â  Â :: proc(ptr: rawptr, len: int) ---
</code></pre>
<h5
	id="conditionally-mem-zero" >
    Conditionally Mem Zero
</h5>
<ul>
	<li>
		<p>
            When acquiring memory from the OS for the first time it's likely that the OS already gives the zero page mapped multiple times for the request. The actual allocation does not have physical pages allocated to it until those pages are written to which causes a page-fault. This is often called 
			<strong>
                COW (Copy on Write)
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            You do not want to actually zero out memory in this case because it would cause a bunch of page faults decreasing the speed of allocations and increase the amount of actual resident physical memory used.
		</p>
	</li>
	<li>
		<p>
            Instead a better technique is to check if memory is zerored before zeroing it. This turns out to be an important optimization in practice, saving nearly half (or more) the amount of physical memory used by an application.
		</p>
	</li>
	<li>
		<p>
            This is why every implementation of 
            <code>calloc</code>
            &nbsp;in 
            <code>libc</code>
            &nbsp;does this optimization.
		</p>
	</li>
	<li>
		<p>
            It may seem counter-intuitive but most allocations in an application are wasted and never used. When you consider something like a 
            <code>[dynamic]T</code>
            &nbsp;which always doubles in capacity on resize but you rarely ever actually use the full capacity of a dynamic array it means you have a lot of resident waste if you actually zeroed the remainder of the memory.
		</p>
	</li>
	<li>
		<p>
            Keep in mind the OS is already guaranteed to give you zeroed memory by mapping in this zero page multiple times so in the best case there is no need to actually zero anything. As for testing all this memory for a zero value, it costs nothing because the the same zero page is used for the whole allocation and will exist in L1 cache for the entire zero checking process.
		</p>
	</li>
	<li>
		<p>
            <code>base:runtime</code>
		</p>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">conditional_mem_zero :: proc "contextless" (data: rawptr, n_: int) #no_bounds_check {
Â  Â  if n_ &lt;= 0 {
Â  Â  Â  Â  return
Â  Â  }
Â  Â  n := uint(n_)
Â  Â  n_words := n / size_of(uintptr)
Â  Â  p_words := ([^]uintptr)(data)[:n_words]
Â  Â  p_bytes := ([^]byte)(data)[size_of(uintptr) * n_words:n]
Â  Â  for &p_word in p_words {
Â  Â  Â  Â  if p_word != 0 {
Â  Â  Â  Â  Â  Â  p_word = 0
Â  Â  Â  Â  }
Â  Â  }
Â  Â  for &p_byte in p_bytes {
Â  Â  Â  Â  if p_byte != 0 {
Â  Â  Â  Â  Â  Â  p_byte = 0
Â  Â  Â  Â  }
Â  Â  }
}
</code></pre>
<h5
	id="using-the-c-runtime-library-crt" >
    Using the 'C Runtime Library' (CRT)
</h5>
<pre><code class="language-odin" data-lang="odin">when ODIN_NO_CRT && ODIN_OS == .Windows {
&nbsp;&nbsp;&nbsp;&nbsp;// None
} else when ODIN_NO_CRT || (ODIN_OS != .Orca && (ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32)) {
Â  Â  @(link_name="bzero", linkage="strong", require)
Â  Â  bzero :: proc "c" (ptr: rawptr, #any_int len: int_t) -&gt; rawptr {
Â  Â  Â  Â  if ptr != nil && len != 0 {
Â  Â  Â  Â  Â  Â  p := ([^]byte)(ptr)
Â  Â  Â  Â  Â  Â  for i := int_t(0); i &lt; len; i += 1 {
Â  Â  Â  Â  Â  Â  Â  Â  p[i] = 0
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return ptr
Â  Â  }
Â } else {
&nbsp;&nbsp;&nbsp;&nbsp;Â // None
Â }
</code></pre>
<h5
	id="in-c" >
    In C
</h5>
<ul>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/C.html#mem-zero">
            C#Mem Zero
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="resize" >
    Resize
</h3>
<pre><code class="language-odin" data-lang="odin">_mem_resize :: #force_no_inline proc(ptr: rawptr, old_size, new_size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, should_zero: bool, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  if allocator.procedure == nil {
Â  Â  Â  Â  return nil, nil
Â  Â  }
Â  Â  if new_size == 0 {
Â  Â  Â  Â  if ptr != nil {
Â  Â  Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  return
Â  Â  } else if ptr == nil {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  return allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  } else if old_size == new_size && uintptr(ptr) % uintptr(alignment) == 0 {
Â  Â  Â  Â  data = ([^]byte)(ptr)[:old_size]
Â  Â  Â  Â  return
Â  Â  }
Â  Â  if should_zero {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize, new_size, alignment, ptr, old_size, loc)
Â  Â  } else {
Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Resize_Non_Zeroed, new_size, alignment, ptr, old_size, loc)
Â  Â  }
Â  Â  if err == .Mode_Not_Implemented {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  data, err = allocator.procedure(allocator.data, .Alloc_Non_Zeroed, new_size, alignment, nil, 0, loc)
Â  Â  Â  Â  }
Â  Â  Â  Â  if err != nil {
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  }
Â  Â  Â  Â  copy(data, ([^]byte)(ptr)[:old_size])
Â  Â  Â  Â  _, err = allocator.procedure(allocator.data, .Free, 0, 0, ptr, old_size, loc)
Â  Â  }
Â  Â  return
}

mem_resize :: proc(ptr: rawptr, old_size, new_size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, true, loc)
}

non_zero_mem_resize :: proc(ptr: rawptr, old_size, new_size: int, alignment: int = DEFAULT_ALIGNMENT, allocator := context.allocator, loc := #caller_location) -&gt; (data: []byte, err: Allocator_Error) {
Â  Â  assert(is_power_of_two_int(alignment), "Alignment must be a power of two", loc)
Â  Â  return _mem_resize(ptr, old_size, new_size, alignment, allocator, false, loc)
}
</code></pre>
<h5
	id="default-resize-procedure" >
    Default resize procedure
</h5>
<ul>
	<li>
		<p>
            When allocator does not support resize operation, but supports 
            <code>.Alloc</code>
            &nbsp;/ 
            <code>.Alloc_Non_Zeroed</code>
            &nbsp;and 
            <code>.Free</code>
            , this procedure is used to implement allocator's default behavior on resize.
		</p>
	</li>
	<li>
		<p>
            The behavior of the function is as follows:
		</p>
		<ul>
			<li>
				<p>
                    If 
                    <code>new_size</code>
                    &nbsp;is 
                    <code>0</code>
                    , the function acts like 
                    <code>free()</code>
                    , freeing the memory region specified by 
                    <code>old_data</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>old_data</code>
                    &nbsp;is 
                    <code>nil</code>
                    , the function acts like 
                    <code>alloc()</code>
                    , allocating 
                    <code>new_size</code>
                    &nbsp;bytes of memory aligned on a boundary specified by 
                    <code>alignment</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Otherwise, a new memory region of size 
                    <code>new_size</code>
                    &nbsp;is allocated, then the data from the old memory region is copied and the old memory region is freed.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">@(require_results)
_default_resize_bytes_align :: #force_inline proc(
Â  Â  old_data: []byte,
Â  Â  new_size: int,
Â  Â  alignment: int,
Â  Â  should_zero: bool,
Â  Â  allocator := context.allocator,
Â  Â  loc := #caller_location,
) -&gt; ([]byte, Allocator_Error) {
Â  Â  old_memory := raw_data(old_data)
Â  Â  old_size := len(old_data)
Â  Â  if old_memory == nil {
Â  Â  Â  Â  if should_zero {
Â  Â  Â  Â  Â  Â  return alloc_bytes(new_size, alignment, allocator, loc)
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  return alloc_bytes_non_zeroed(new_size, alignment, allocator, loc)
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if new_size == 0 {
Â  Â  Â  Â  err := free_bytes(old_data, allocator, loc)
Â  Â  Â  Â  return nil, err
Â  Â  }
Â  Â  if new_size == old_size && is_aligned(old_memory, alignment) {
Â  Â  Â  Â  return old_data, .None
Â  Â  }
Â  Â  new_memory : []byte
Â  Â  err : Allocator_Error
Â  Â  if should_zero {
Â  Â  Â  Â  new_memory, err = alloc_bytes(new_size, alignment, allocator, loc)
Â  Â  } else {
Â  Â  Â  Â  new_memory, err = alloc_bytes_non_zeroed(new_size, alignment, allocator, loc)
Â  Â  }
Â  Â  if new_memory == nil || err != nil {
Â  Â  Â  Â  return nil, err
Â  Â  }
Â  Â  runtime.copy(new_memory, old_data)
Â  Â  free_bytes(old_data, allocator, loc)
Â  Â  return new_memory, err
}
</code></pre>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-01-22 ðŸš€
			</footer>
		</div>
		<script
			src="/static/studies.85839.js" >
		</script>
	</body>
</html>
