<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.68499.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Odin
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-overview.html" >
                                    Overview
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-my-impressions.html" >
                                    My Impressions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-installation.html" >
                                    Installation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-building.html" >
                                    Building
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-compile-time-stuff.html" >
                                    Compile-time Stuff
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-package-system.html" >
                                    Package System
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-lsp-ols-odin-language-server.html" >
                                    LSP (OLS - Odin Language Server)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-control-flow-if-when-switch-for-defer.html" >
                                    Control Flow (if, when, switch, for, defer)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-procedures.html" >
                                    Procedures
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-typing.html" >
                                    Typing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-any.html" >
                                    any
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-primitive-types.html" >
                                    Primitive Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-matrix.html" >
                                    Matrix
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-quaternion.html" >
                                    Quaternion
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-complex.html" >
                                    Complex
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-strings.html" >
                                    Strings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-rune.html" >
                                    Rune
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-maps-hash-maps.html" >
                                    Maps (Hash Maps)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-struct.html" >
                                    Struct
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-union.html" >
                                    Union
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-bit-sets.html" >
                                    Bit Sets
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-arrays.html" >
                                    Arrays
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-interfaces-methods-vtables.html" >
                                    Interfaces / Methods / VTables
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-error-handling.html" >
                                    Error Handling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-context.html" >
                                    Context
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-address.html" >
                                    Memory: Address
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-allocators.html" >
                                    Memory: Allocators
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-operations.html" >
                                    Memory: Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-entry-point.html" >
                                    Entry Point
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-multi-threading.html" >
                                    Multi-Threading
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-simd.html" >
                                    SIMD
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-directives.html" >
                                    Directives
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-ffi-foreign-function-interface-bindings.html" >
                                    FFI (Foreign Function Interface) / Bindings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-web-build.html" >
                                    Web Build
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-file-system-process-cli-shell.html" >
                                    File System / Process / CLI / Shell
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-useful-packages.html" >
                                    Useful Packages
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Memory
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-virtual-memory.html" >
                                    Virtual Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-os-memory-on-windows.html" >
                                    OS: Memory on Windows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-memory-alignment.html" >
                                    Memory Alignment
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-address.html" >
                                    Address
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-allocators.html" >
                                    Allocators
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-tools-memory-analysis.html" >
                                    Tools: Memory Analysis
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-handles-instead-of-pointers.html" >
                                    Handles instead of Pointers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-ownership-strategies-destruction-strategies.html" >
                                    Ownership Strategies / Destruction Strategies
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-strategies-for-handling-short-lived-memory.html" >
                                    Strategies for handling short lived memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-garbage-collection.html" >
                                    Garbage Collection
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-initialization.html" >
                                    Initialization
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            CPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-physical-structure.html" >
                                    Physical Structure
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-soa-struct-of-arrays-ecs-entity-component-system.html" >
                                    SOA (Struct Of Arrays) / ECS (Entity Component System)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-simd.html" >
                                    SIMD
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Multithreading
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-core-concepts.html" >
                                    Core Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-thread.html" >
                                    Thread
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-strategies.html" >
                                    Strategies
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-implementation-detail.html" >
                                    Implementation Detail
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-synchronization-primitives.html" >
                                    Synchronization Primitives
								</a>
								<ul>
									<li>
										<a
											href="#atomic-operations-lock-free" >
                                            Atomic Operations / Lock-free
										</a>
										<ul>
											<li>
												<a
													href="#atomic-operations" >
                                                    Atomic Operations
												</a>
											</li>
											<li>
												<a
													href="#atomic-memory-order" >
                                                    Atomic Memory Order
												</a>
											</li>
										</ul>
									</li>
									<li>
										<a
											href="#barrier" >
                                            Barrier
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#semaphore" >
                                            Semaphore
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#benaphore" >
                                            Benaphore
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#recursive-benaphore" >
                                            Recursive Benaphore
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#auto-reset-event" >
                                            Auto Reset Event
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#mutex-mutual-exclusion-lock" >
                                            Mutex (Mutual exclusion lock)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#futex-fast-userspace-mutex" >
                                            Futex (Fast Userspace Mutex)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#one-shot-event" >
                                            One Shot Event
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#parker" >
                                            Parker
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#spinlock-spin-until-mutex-is-unlocked" >
                                            Spinlock (Spin until Mutex is unlocked)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#read-write-mutex-read-write-lock" >
                                            Read-Write Mutex / Read-Write Lock
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#once" >
                                            Once
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#ticket-mutex" >
                                            Ticket Mutex
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#condition-variable" >
                                            Condition Variable
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#wait-group" >
                                            Wait Group
										</a>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-double-buffering.html" >
                                    Double-Buffering
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-networking-strategies.html" >
                                    Networking Strategies
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Handmade Hero
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero-handmade-hero.html" >
                                    Handmade Hero
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Profilers
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-tracy.html" >
                                    Tracy
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-spall.html" >
                                    Spall
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-nvidia-nsight-graphics-gpu-trace.html" >
                                    Nvidia Nsight Graphics - GPU Trace
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-amd-gpu-profiler-amd-rgp.html" >
                                    AMD GPU Profiler (AMD RGP)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-intel-gpa.html" >
                                    Intel GPA
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-nsight-systems.html" >
                                    <s>Nsight Systems</s>
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            C
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-critiques.html" >
                                    Critiques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-c-standard.html" >
                                    C Standard
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-c-standard-library-libc.html" >
                                    C Standard Library (libc)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-building.html" >
                                    Building
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-loops.html" >
                                    Loops
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-strings.html" >
                                    Strings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-structs.html" >
                                    Structs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-pointers.html" >
                                    Pointers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-arrays.html" >
                                    Arrays
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-preprocessors.html" >
                                    Preprocessors
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-undefined-behavior.html" >
                                    Undefined Behavior
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-gamedev.html" >
                                    GameDev
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-windows-c-api.html" >
                                    WIndows C API
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Build Systems - Compilation - Linking
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilation-process.html" >
                                    Compilation Process
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-linker.html" >
                                    Linker
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilers.html" >
                                    Compilers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-build-tools.html" >
                                    Build Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-meta-build-tools.html" >
                                    Meta Build Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-extra-annoying-things-on-windows.html" >
                                    Extra: Annoying things on Windows
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Debuggers
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-file-types.html" >
                                    File Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-rad-debbuger.html" >
                                    RAD Debbuger
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-gdb-gnu-debugger.html" >
                                    GDB (GNU Debugger)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-lldb.html" >
                                    LLDB
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-vscode.html" >
                                    VSCode
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-visual-studio-debugger.html" >
                                    Visual Studio Debugger
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-others.html" >
                                    Others
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Assembly - ASM
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-notes.html" >
                                    Notes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-reverse-engineering.html" >
                                    Reverse Engineering
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Parsing
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-parsing.html" >
                                    Parsing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-lexer.html" >
                                    Lexer
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            JAI
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-build.html" >
                                    Build
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-types.html" >
                                    Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-meta-programming.html" >
                                    Meta programming
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-control-flow.html" >
                                    Control flow
								</a>
							</li>
						</ul>
					</details>
				</nav>
				<footer
					id="left-sidebar-footer" >
				</footer>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="central" >
				<main
					id="note-wrapper" >
					<header
						id="note-header" >
						<h1>
                            Synchronization Primitives
						</h1>
						<p>
							<time
								datetime="2025-03-11" >
                                üïí Created: 2025-03-11
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<article
						id="note-content" >
<ul>
	<li>
		<p>
            Synchronization primitives can come from multiple layers of abstraction; some are provided directly by the operating system, while others are part of programming language libraries or runtime environments.
		</p>
	</li>
</ul>
<h5
	id="operating-system-os-level" >
    Operating System (OS) Level
</h5>
<ul>
	<li>
		<p>
            Most low-level synchronization primitives originate from the OS.
		</p>
	</li>
	<li>
		<p>
            Provided through 
			<strong>
                system calls
			</strong>
            &nbsp;or 
			<strong>
                kernel APIs
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            Examples:
		</p>
		<ul>
			<li>
				<p>
                    <code>pthread_mutex</code>
                    , 
                    <code>pthread_cond</code>
                    &nbsp;(POSIX Threads on Unix/Linux)
				</p>
			</li>
			<li>
				<p>
                    <code>WaitForSingleObject</code>
                    , 
                    <code>CreateSemaphore</code>
                    &nbsp;(Windows API)
				</p>
			</li>
			<li>
				<p>
                    <code>futex</code>
                    &nbsp;(Linux-specific syscall)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Typically used in C/C++, or by language runtimes internally.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Responsibilities of the OS
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Manage thread scheduling.
				</p>
			</li>
			<li>
				<p>
                    Handle context switching and resource blocking.
				</p>
			</li>
			<li>
				<p>
                    Provide kernel support for locks, semaphores, etc.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="programming-language-runtime" >
    Programming Language Runtime
</h5>
<ul>
	<li>
		<p>
            Languages abstract OS primitives or implement their own strategies.
		</p>
	</li>
	<li>
		<p>
            May use OS-level primitives under the hood or optimize further in user-space.
		</p>
	</li>
</ul>
<h5
	id="user-space-libraries" >
    User-Space Libraries
</h5>
<ul>
	<li>
		<p>
            Some libraries provide synchronization mechanisms independent of the OS.
		</p>
	</li>
	<li>
		<p>
            Often optimized for performance (e.g., lock-free, wait-free algorithms).
		</p>
	</li>
	<li>
		<p>
            Examples:
		</p>
		<ul>
			<li>
				<p>
                    Intel TBB (Threading Building Blocks)
				</p>
			</li>
			<li>
				<p>
                    Boost.Thread (C++)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="atomic-operations-lock-free" >
    Atomic Operations / Lock-free
</h3>
<ul>
	<li>
		<p>
            Low-level CPU-supported operations that are completely indivisible.
		</p>
	</li>
	<li>
		<p>
            No locking required.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://blog.molecular-matters.com/2012/03/05/volatile-thread-synchronization/" 
				class="external-link" 
				target="_blank" >
                Avoid using Volatile in C++
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I think this exemplifies a bit the necessity of using atomic operations.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="atomic-operations" >
    Atomic Operations
</h4>
<ul>
	<li>
		<p>
            See 
            <a href="/studies/Low-Level Systems/Odin/Odin.html#atomics">
            Odin#Atomics
            </a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I'm assuming the operations stated here are universal.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="atomic-memory-order" >
    Atomic Memory Order
</h4>
<ul>
	<li>
		<p>
            Modern CPU's contain multiple cores and caches specific to those cores. When a core performs a write to memory, the value is written to cache first. The issue is that a core doesn't typically see what's inside the caches of other cores. In order to make operations consistent CPU's implement mechanisms that synchronize memory operations across cores by asking other cores or by pushing data about writes to other cores.
		</p>
	</li>
	<li>
		<p>
            Due to how these algorithms are implemented, the stores and loads performed by one core may seem to happen in a different order to another core. It also may happen that a core reorders stores and loads (independent of how compiler put them into the machine code). This can cause issues when trying to synchronize multiple memory locations between two cores. Which is why CPU's allow for stronger memory ordering guarantees if certain instructions or instruction variants are used.
		</p>
	</li>
	<li>
		<p>
            <code>Relaxed</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    The memory access (load or store) is unordered with respect to other memory accesses. This can be used to implement an atomic counter. Multiple threads access a single variable, but it doesn't matter when exactly it gets incremented, because it will become eventually consistent.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>Consume</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    No loads or stores dependent on a memory location can be reordered before a load with consume memory order. If other threads released the same memory, it becomes visible.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>Acquire</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    No loads or stores on a memory location can be reordered before a load of that memory location with acquire memory ordering. If other threads release the same memory, it becomes visible.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>Release</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    No loads or stores on a memory location can be reordered after a store of that memory location with release memory ordering. All threads that acquire the same memory location will see all writes done by the current thread.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>Acq_Rel</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Acquire-release memory ordering: combines acquire and release memory orderings in the same operation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>Seq_Cst</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Sequential consistency. The strongest memory ordering. A load will always be an acquire operation, a store will always be a release operation, and in addition to that all threads observe the same order of writes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Note(i386, x64)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    x86 has a very strong memory model by default. It guarantees that all writes are ordered, stores and loads aren't reordered. In a sense, all operations are at least acquire and release operations. If 
                    <code>lock</code>
                    &nbsp;prefix is used, all operations are sequentially consistent. If you use explicit atomics, make sure you have the correct atomic memory order, because bugs likely will not show up in x86, but may show up on e.g. arm. More on x86 memory ordering can be found 
					<a
						href="https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf" 
						class="external-link" 
						target="_blank" >
                        here
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="barrier" >
    Barrier
</h3>
<ul>
	<li>
		<p>
            Blocks a group of threads until all have reached the same point of execution.
		</p>
	</li>
	<li>
		<p>
            Once 
			<em>
                all
			</em>
            &nbsp;threads arrive, they are released simultaneously.
		</p>
	</li>
	<li>
		<p>
            Enables multiple threads to synchronize the beginning of some computation.
		</p>
	</li>
	<li>
		<p>
            When 
            <code>barrier_wait</code>
            &nbsp;procedure is called by any thread, that thread will block the execution, until all threads associated with the barrier reach the same point of execution and also call 
            <code>barrier_wait</code>
            .
		</p>
	</li>
	<li>
		<p>
            When a barrier is initialized, a 
            <code>thread_count</code>
            &nbsp;parameter is passed, signifying the amount of participant threads of the barrier. The barrier also keeps track of an internal atomic counter. When a thread calls 
            <code>barrier_wait</code>
            , the internal counter is incremented. When the internal counter reaches 
            <code>thread_count</code>
            , it is reset and all threads waiting on the barrier are unblocked.
		</p>
	</li>
	<li>
		<p>
            This type of synchronization primitive can be used to synchronize &quot;staged&quot; workloads, where the workload is split into stages, and until all threads have completed the previous threads, no thread is allowed to start work on the next stage. In this case, after each stage, a 
            <code>barrier_wait</code>
            &nbsp;shall be inserted in the thread procedure.
		</p>
	</li>
</ul>
<h3
	id="semaphore" >
    Semaphore
</h3>
<ul>
	<li>
		<p>
            A counter-based synchronization primitive.
		</p>
	</li>
	<li>
		<p>
            Can allow multiple threads to access a resource (unlike a mutex, which is binary).
		</p>
	</li>
	<li>
		<p>
            Types:
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Counting Semaphore
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allows 
                            <code>n</code>
                            &nbsp;concurrent accesses.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Binary Semaphore
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Functions like a mutex.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            When waited upon, semaphore blocks until the internal count is greater than zero, then decrements the internal counter by one. Posting to the semaphore increases the count by one, or the provided amount.
		</p>
	</li>
	<li>
		<p>
            This type of synchronization primitives can be useful for implementing queues. The internal counter of the semaphore can be thought of as the amount of items in the queue. After a data has been pushed to the queue, the thread shall call¬†
            <code>sema_post()</code>
            ¬†procedure, increasing the counter. When a thread takes an item from the queue to do the job, it shall call¬†
            <code>sema_wait()</code>
            , waiting on the semaphore counter to become non-zero and decreasing it, if necessary.
		</p>
	</li>
</ul>
<h3
	id="benaphore" >
    Benaphore
</h3>
<ul>
	<li>
		<p>
            A benaphore is a combination of an atomic variable and a semaphore that can improve locking efficiency in a no-contention system. Acquiring a benaphore lock doesn't call into an internal semaphore, if no other thread is in the middle of a critical section.
		</p>
	</li>
	<li>
		<p>
            Once a lock on a benaphore is acquired by a thread, no other thread is allowed into any critical sections, associted with the same benaphore, until the lock is released.
		</p>
	</li>
</ul>
<h3
	id="recursive-benaphore" >
    Recursive Benaphore
</h3>
<ul>
	<li>
		<p>
            A recursive benaphore is just like a plain benaphore, except it allows reentrancy into the critical section.
		</p>
	</li>
	<li>
		<p>
            When a lock is acquired on a benaphore, all other threads attempting to acquire a lock on the same benaphore will be blocked from any critical sections, associated with the same benaphore.
		</p>
	</li>
	<li>
		<p>
            When a lock is acquired on a benaphore by a thread, that thread is allowed to acquire another lock on the same benaphore. When a thread has acquired the lock on a benaphore, the benaphore will stay locked until the thread releases the lock as many times as it has been locked by the thread.
		</p>
	</li>
</ul>
<h3
	id="auto-reset-event" >
    Auto Reset Event
</h3>
<ul>
	<li>
		<p>
            Represents a thread synchronization primitive that, when signalled, releases one single waiting thread and then resets automatically to a state where it can be signalled again.
		</p>
	</li>
	<li>
		<p>
            When a thread calls 
            <code>auto_reset_event_wait</code>
            , its execution will be blocked, until the event is signalled by another thread. The call to 
            <code>auto_reset_event_signal</code>
            &nbsp;wakes up exactly one thread waiting for the event.
		</p>
	</li>
</ul>
<h3
	id="mutex-mutual-exclusion-lock" >
    Mutex (Mutual exclusion lock)
</h3>
<ul>
	<li>
		<p>
            A Mutex is a 
			<a
				href="https://en.wikipedia.org/wiki/Mutual_exclusion" 
				class="external-link" 
				target="_blank" >
                mutual exclusion lock
			</a>
            &nbsp;It can be used to prevent more than one thread from entering the critical section, and thus prevent access to same piece of memory by multiple threads, at the same time.
		</p>
	</li>
	<li>
		<p>
            Mutex's zero-initializzed value represents an initial, 
			<em>
                unlocked
			</em>
            &nbsp;state.
		</p>
	</li>
	<li>
		<p>
            If another thread tries to acquire the lock, while it's already held (typically by another thread), the thread's execution will be blocked, until the lock is released. Code or memory that is &quot;surrounded&quot; by a mutex lock and unlock operations is said to be &quot;guarded by a mutex&quot;.
		</p>
	</li>
	<li>
		<p>
            Ensures only one thread accesses a critical section at a time.
		</p>
	</li>
	<li>
		<p>
            If another thread tries to lock an already locked mutex, it blocks until the mutex is released.
		</p>
	</li>
	<li>
		<p>
            Protect shared variables from concurrent modification.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://yashdhadve.hashnode.dev/multi-threading-in-odin-lang#heading-handling-deadlock-using-mutex" 
				class="external-link" 
				target="_blank" >
                Odin - Preventing deadlock with Mutex
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="problems-prevented-by-mutex" >
    Problems Prevented by Mutex
</h5>
<ul>
	<li>
		<p>
			<strong>
                Race conditions:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    When multiple threads access and modify a resource simultaneously in an unpredictable way.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Data inconsistency:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Ensures that operations in a critical section are atomic.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="challenges-of-using-mutex" >
    Challenges of Using Mutex
</h5>
<ul>
	<li>
		<p>
			<strong>
                Deadlock:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Occurs when two or more threads are stuck waiting for each other to release mutexes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Starvation:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    A thread may wait indefinitely if mutexes are constantly acquired by others.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="what-a-mutex-actually-blocks" >
    What a Mutex Actually Blocks
</h5>
<ul>
	<li>
		<p>
            It blocks other threads from locking the same mutex.
		</p>
		<ul>
			<li>
				<p>
                    If Thread A locks 
                    <code>mutex</code>
                    , Thread B will wait if it tries to lock 
                    <code>mutex</code>
                    &nbsp;until Thread A unlocks it.
				</p>
			</li>
			<li>
				<p>
                    It does not block threads that don‚Äôt try to lock 
                    <code>mutex</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It does not block the entire function or thread.
		</p>
		<ul>
			<li>
				<p>
                    The rest of your code (outside the mutex) runs normally.
				</p>
			</li>
			<li>
				<p>
                    Only the critical section (between 
                    <code>lock</code>
                    /
                    <code>unlock</code>
                    ) is protected.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Mutexes Protect Data, Not Functions or Threads.
		</p>
<pre><code class="language-odin" data-lang="odin">textures: map[u32]Texture2D
textures_mutex: sync.Mutex

// Thread A (locks mutex, modifies textures)
sync.mutex_lock(&textures_mutex)&nbsp;&nbsp;// üîí
textures[123] = load_texture("test.png")&nbsp;&nbsp;// Protected
sync.mutex_unlock(&textures_mutex)&nbsp;&nbsp;// üîì

// Thread B (also needs the mutex to touch textures)
sync.mutex_lock(&textures_mutex)&nbsp;&nbsp;// ‚è≥ Waits if Thread A holds the lock
unload_texture(textures[123])
sync.mutex_unlock(&textures_mutex)
</code></pre>
		<ul>
			<li>
				<p>
                    The mutex only blocks Thread B if it tries to lock 
                    <code>textures_mutex</code>
                    &nbsp;while Thread A holds it.
				</p>
			</li>
			<li>
				<p>
                    If Thread B runs code that doesn‚Äôt lock 
                    <code>textures_mutex</code>
                    , it runs freely.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Mutexes Are Not &quot;Global Barriers&quot;. If two threads use different mutexes, they don‚Äôt block each other:
		</p>
<pre><code class="language-odin" data-lang="odin">// Thread A (uses mutex_x)
sync.mutex_lock(&mutex_x)&nbsp;&nbsp;// üîí
// ... do work ...
sync.mutex_unlock(&mutex_x)&nbsp;&nbsp;// üîì

// Thread B (uses mutex_y)
sync.mutex_lock(&mutex_y)&nbsp;&nbsp;// ‚úÖ Runs in parallel (no conflict)
// ... do work ...
sync.mutex_unlock(&mutex_y)
</code></pre>
	</li>
</ul>
<h5
	id="example-task-queue" >
    Example: Task Queue
</h5>
<pre><code class="language-odin" data-lang="odin">// --- Shared Task System (Thread-safe) ---
Task_Type :: enum {
&nbsp;&nbsp;&nbsp;&nbsp;UNLOAD_TEXTURE,
&nbsp;&nbsp;&nbsp;&nbsp;LOAD_TEXTURE,
&nbsp;&nbsp;&nbsp;&nbsp;SWAP_SCENE_TEXTURES,
&nbsp;&nbsp;&nbsp;&nbsp;// Add more as needed...
}

Task :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;type: Task_Type,
&nbsp;&nbsp;&nbsp;&nbsp;// Add payload if needed (e.g., texture IDs)
}

task_queue: [dynamic]Task
task_mutex: sync.Mutex

// Thread A (Game Thread): Processes tasks
process_tasks :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;// üîí LOCK the mutex to safely read the queue
&nbsp;&nbsp;&nbsp;&nbsp;sync.mutex_lock(&task_mutex)
&nbsp;&nbsp;&nbsp;&nbsp;defer sync.mutex_unlock(&task_mutex)&nbsp;&nbsp;// üîì Unlock when done

&nbsp;&nbsp;&nbsp;&nbsp;// Make a local copy of tasks (optional but cleaner)
&nbsp;&nbsp;&nbsp;&nbsp;tasks_to_process := task_queue[:]
&nbsp;&nbsp;&nbsp;&nbsp;clear(&task_queue)&nbsp;&nbsp;// Empty the shared queue
&nbsp;&nbsp;&nbsp;&nbsp;// üîì Mutex unlocked here (defer runs)

&nbsp;&nbsp;&nbsp;&nbsp;// Process tasks WITHOUT holding the mutex
&nbsp;&nbsp;&nbsp;&nbsp;for task in tasks_to_process {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle_task(task)&nbsp;&nbsp;// e.g., UnloadTexture(...)
&nbsp;&nbsp;&nbsp;&nbsp;}
}

// Thread B (Network Thread): Adds a task
add_task :: proc(new_task: Task) {
&nbsp;&nbsp;&nbsp;&nbsp;// üîí LOCK the mutex to safely append
&nbsp;&nbsp;&nbsp;&nbsp;sync.mutex_lock(&task_mutex)
&nbsp;&nbsp;&nbsp;&nbsp;defer sync.mutex_unlock(&task_mutex)&nbsp;&nbsp;// üîì Unlock when done

&nbsp;&nbsp;&nbsp;&nbsp;append(&task_queue, new_task)
}
</code></pre>
<h5
	id="example-read-and-write" >
    Example: Read and Write
</h5>
<ul>
	<li>
		<p>
            READ: MAKES A COPY (wrapped in a mutex), WRITE: MUTEX GUARD
		</p>
		<ul>
			<li>
				<p>
                    For read operations, make a copy of the data to read; for write operations, use a mutex.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Shared data with mutex and atomic pointer for efficient reads
std::mutex data_mutex;
Data* atomic_data_ptr; // Atomic pointer for thread-safe access

// Read Job
void ReadJob() {
&nbsp;&nbsp;Data local_copy;
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;std::lock_guard&lt;std::mutex&gt; lock(data_mutex); // Optional: Only if data isn't atomically swappable
&nbsp;&nbsp;&nbsp;&nbsp;local_copy = *atomic_data_ptr; // Copy under mutex (or use atomic load)
&nbsp;&nbsp;}
&nbsp;&nbsp;// Use local_copy safely...
}

// Write Job
void WriteJob() {
&nbsp;&nbsp;std::lock_guard&lt;std::mutex&gt; lock(data_mutex);
&nbsp;&nbsp;// Modify data...
}
</code></pre>
<h3
	id="futex-fast-userspace-mutex" >
    Futex (Fast Userspace Mutex)
</h3>
<ul>
	<li>
		<p>
            Allows most lock/unlock operations to be done in userspace.
		</p>
	</li>
	<li>
		<p>
            System call is only used for contention resolution.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Use case
			</strong>
            : Efficient locking on Linux systems.
		</p>
	</li>
</ul>
<h5
	id="user-space-atomic-spin-with-codecpu_relax-code-vs-futex" >
    User-space atomic spin (with 
    <code>cpu_relax</code>
    ) vs Futex
</h5>
<ul>
	<li>
		<p>
            For very short waits (tens‚Äìthousands of CPU cycles) a user-space atomic spin (with 
            <code>cpurelax</code>
            ) is lower latency than a futex because it avoids syscalls and context switches.
		</p>
	</li>
	<li>
		<p>
            For longer waits (microseconds and above, or whenever contention is non-trivial) a futex is far better overall because it blocks the thread in the kernel and does not burn CPU.
		</p>
	</li>
</ul>
<h3
	id="one-shot-event" >
    One Shot Event
</h3>
<ul>
	<li>
		<p>
            One-shot event.
		</p>
	</li>
	<li>
		<p>
            A one-shot event is an associated token which is initially not present:
		</p>
	</li>
	<li>
		<p>
            The 
            <code>one_shot_event_wait</code>
            &nbsp;blocks the current thread until the event is made available The 
            <code>one_shot_event_signal</code>
            &nbsp;procedure automatically makes the token available if its was not already.
		</p>
	</li>
</ul>
<h3
	id="parker" >
    Parker
</h3>
<p>
    ¬†- A Parker is an associated token which is initially not present:
</p>
<ul>
	<li>
		<p>
            The 
            <code>park</code>
            &nbsp;procedure blocks the current thread unless or until the token is available, at which point the token is consumed. The 
            <code>park_with_timeout</code>
            &nbsp;procedures works the same as 
            <code>park</code>
            &nbsp;but only blocks for the specified duration. The 
            <code>unpark</code>
            &nbsp;procedure automatically makes the token available if it was not already.
		</p>
	</li>
</ul>
<h3
	id="spinlock-spin-until-mutex-is-unlocked" >
    Spinlock (Spin until Mutex is unlocked)
</h3>
<ul>
	<li>
		<p>
            Like a mutex, but instead of blocking, it repeatedly checks (spins) until the lock becomes available.
		</p>
	</li>
	<li>
		<p>
            Low overhead but inefficient if held for long.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Use case
			</strong>
            : Short critical sections on multiprocessor systems.
		</p>
	</li>
</ul>
<h3
	id="read-write-mutex-read-write-lock" >
    Read-Write Mutex / Read-Write Lock
</h3>
<h5
	id="naming" >
    Naming
</h5>
<ul>
	<li>
		<p>
            A read‚Äìwrite lock (RW lock) lets many readers hold the lock concurrently but only one writer at a time. Calling it a 
			<em>
                read‚Äìwrite mutex
			</em>
            &nbsp;is common and acceptable; it‚Äôs a mutual-exclusion primitive with two modes (shared/read and exclusive/write).
		</p>
	</li>
</ul>
<h5
	id="read-write-mutex" >
    Read-Write Mutex
</h5>
<ul>
	<li>
		<p>
            Allows 
			<strong>
                multiple readers
			</strong>
            &nbsp;or 
			<strong>
                one writer
			</strong>
            , but not both.
            <br>
            ¬†- Read-write mutual exclusion lock.
		</p>
	</li>
	<li>
		<p>
            An 
            <code>RW_Mutex</code>
            &nbsp;is a reader/writer mutual exclusion lock. The lock can be held by any number of readers or a single writer.
		</p>
	</li>
	<li>
		<p>
            This type of synchronization primitive supports two kinds of lock operations:
		</p>
		<ul>
			<li>
				<p>
                    Exclusive lock (write lock)
				</p>
			</li>
			<li>
				<p>
                    Shared lock (read lock)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            When an exclusive lock is acquired by any thread, all other threads, attempting to acquire either an exclusive or shared lock, will be blocked from entering the critical sections associated with the read-write mutex, until the exclusive owner of the lock releases the lock.
		</p>
	</li>
	<li>
		<p>
            When a shared lock is acquired by any thread, any other thread attempting to acquire a shared lock will also be able to enter all the critical sections associated with the read-write mutex. However threads attempting to acquire an exclusive lock will be blocked from entering those critical sections, until all shared locks are released.
		</p>
	</li>
</ul>
<h5
	id="how-it-works-internally" >
    How it works internally
</h5>
<ul>
	<li>
		<p>
            Most efficient implementations are user-space fast paths plus a kernel-assisted wait path.
		</p>
	</li>
	<li>
		<p>
			<strong>
                State word (atomic integer).
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Encodes reader count and writer flag (and sometimes waiter counts or ticket/sequence numbers).
				</p>
			</li>
			<li>
				<p>
                    Example encoding:
				</p>
				<ul>
					<li>
						<p>
                            low bits or a counter = number of active readers
						</p>
					</li>
					<li>
						<p>
                            one bit = writer-active flag
						</p>
					</li>
					<li>
						<p>
                            optional fields = number of waiters or ticket counters
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Fast path (uncontended):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    <code>AcquireRead</code>
                    : atomically increment reader count if writer bit is 0.
				</p>
			</li>
			<li>
				<p>
                    <code>AcquireWrite</code>
                    : atomically set writer bit (CAS) if reader count is 0 and writer bit was 0; if successful, you‚Äôre owner.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Slow path (contended):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    If fast path fails (writer present or racing), the thread either spins briefly or goes to sleep on a wait queue associated with the lock (on Linux typically via 
                    <code>futex</code>
                    , on Windows via wait-on-address / kernel wait objects).
				</p>
			</li>
			<li>
				<p>
                    Waiting threads sleep until a waking operation (writer release or explicit wake) changes the state and wakes them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Release:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    <code>ReleaseRead</code>
                    : atomically decrement reader count. If reader count becomes 0 and a writer is waiting, wake one writer.
				</p>
			</li>
			<li>
				<p>
                    <code>ReleaseWrite</code>
                    : clear writer bit and wake either waiting writers (writer-preferring) or all readers (reader-preferring / fair), depending on policy.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="comparison-coderw_mutex-code-vs-double-buffering" >
    Comparison 
    <code>RW_Mutex</code>
    &nbsp;vs Double-Buffering
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250522145205.png" width="625" >
            .
		</p>
	</li>
</ul>
<h5
	id="srw-lock-slim-reader-writer-lock-windows-only" >
    SRW Lock&nbsp;&nbsp;(Slim Reader/Writer lock) (Windows only)
</h5>
<ul>
	<li>
		<p>
            It's a lightweight synchronization primitive in Windows that allows multiple concurrent readers or a single writer.
		</p>
	</li>
	<li>
		<p>
            Supports 
			<strong>
                shared
			</strong>
            &nbsp;mode (multiple readers) and 
			<strong>
                exclusive
			</strong>
            &nbsp;mode (one writer).
		</p>
	</li>
	<li>
		<p>
            Unfair by design; a writer may bypass waiting readers.
		</p>
	</li>
	<li>
		<p>
            Very small footprint (pointer-sized structure).
		</p>
	</li>
	<li>
		<p>
            Non-reentrant: a thread must not acquire the same SRW lock twice in the same mode.
		</p>
	</li>
</ul>
<h3
	id="once" >
    Once
</h3>
<ul>
	<li>
		<p>
            Once action.
		</p>
	</li>
	<li>
		<p>
            <code>Once</code>
            &nbsp;a synchronization primitive, that only allows a single entry into a critical section from a single thread.
		</p>
	</li>
</ul>
<h3
	id="ticket-mutex" >
    Ticket Mutex
</h3>
<ul>
	<li>
		<p>
            Ticket lock.
		</p>
	</li>
	<li>
		<p>
            A ticket lock is a mutual exclusion lock that uses &quot;tickets&quot; to control which thread is allowed into a critical section.
		</p>
	</li>
	<li>
		<p>
            This synchronization primitive works just like spinlock, except that it implements a &quot;fairness&quot; guarantee, making sure that each thread gets a roughly equal amount of entries into the critical section.
		</p>
	</li>
	<li>
		<p>
            This type of synchronization primitive is applicable for short critical sections in low-contention systems, as it uses a spinlock under the hood.
		</p>
	</li>
</ul>
<h3
	id="condition-variable" >
    Condition Variable
</h3>
<ul>
	<li>
		<p>
            Allows threads to sleep and be awakened when a specific condition is true.
		</p>
	</li>
	<li>
		<p>
            It's a rendezvous point for threads waiting for signalling the occurence of an event. Condition variables are used in conjuction with mutexes to provide a shared access to one or more shared variable.
		</p>
	</li>
	<li>
		<p>
            A typical usage of condition variable is as follows:
		</p>
		<ul>
			<li>
				<p>
                    A thread that intends to modify a shared variable shall:
				</p>
				<ol>
					<li>
						<p>
                            Acquire a lock on a mutex.
						</p>
					</li>
					<li>
						<p>
                            Modify the shared memory.
						</p>
					</li>
					<li>
						<p>
                            Release the lock.
						</p>
					</li>
					<li>
						<p>
                            Call 
                            <code>cond_signal</code>
                            &nbsp;or 
                            <code>cond_broadcast</code>
                            .
						</p>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    A thread that intends to wait on a shared variable shall:
				</p>
				<ol>
					<li>
						<p>
                            Acquire a lock on a mutex.
						</p>
					</li>
					<li>
						<p>
                            Call 
                            <code>cond_wait</code>
                            &nbsp;or 
                            <code>cond_wait_with_timeout</code>
                            &nbsp;(will release the mutex).
						</p>
					</li>
					<li>
						<p>
                            Check the condition and keep waiting in a 
							<strong>
                                loop
							</strong>
                            &nbsp;if not satisfied with result.
						</p>
					</li>
				</ol>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="wait-group" >
    Wait Group
</h3>
<ul>
	<li>
		<p>
            Wait group is a synchronization primitive used by the waiting thread to wait, until all working threads finish work.
		</p>
	</li>
	<li>
		<p>
            The waiting thread first sets the number of working threads it will expect to wait for using 
            <code>wait_group_add</code>
            &nbsp;call, and start waiting using 
            <code>wait_group_wait</code>
            &nbsp;call. When worker threads complete their work, each of them will call 
            <code>wait_group_done</code>
            , and after all working threads have called this procedure, the waiting thread will resume execution.
		</p>
	</li>
	<li>
		<p>
            For the purpose of keeping track whether all working threads have finished their work, the wait group keeps an internal atomic counter. Initially, the waiting thread might set it to a certain non-zero amount. When each working thread completes the work, the internal counter is atomically decremented until it reaches zero. When it reaches zero, the waiting thread is unblocked. The counter is not allowed to become negative.
		</p>
	</li>
</ul>

					</article>
					<footer
						id="note-footer" >
					</footer>
				</main>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.68499.js" >
		</script>
	</body>
</html>
