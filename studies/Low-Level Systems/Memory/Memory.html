<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.05320.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
>
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering.html" >
                                Font Rendering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Low-Level Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Low-Level Systems/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers.html" >
                                Profilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Parsing.html" >
                                Parsing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design Patterns
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design.html" >
                                Data Oriented Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS.html" >
                                Data Oriented Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - COP/Data Oriented Design - COP.html" >
                                Data Oriented Design - COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns.html" >
                                Other Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Concepts and Terminology.html" >
                                Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Rules of thumb - Laws - Guidelines and Principles/Rules of thumb - Laws - Guidelines and Principles.html" >
                                Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Paradigms.html" >
                                Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Production Methodologies/Production Methodologies.html" >
                                Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Security.html" >
                                Security
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Game Development
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game AI/Game AI.html" >
                                Game AI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Procedural Animation/Procedural Animation.html" >
                                Procedural Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game Design/Game Design.html" >
                                Game Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Level Design.html" >
                                Level Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Scanning Algorithms.html" >
                                Scanning Algorithms
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Art
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing, Color Theory, Pixel Art/Drawing, Color Theory, Pixel Art.html" >
                                Drawing, Color Theory, Pixel Art
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Low-Poly, PSX.html" >
                                Low-Poly, PSX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Animation.html" >
                                Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Texel Density.html" >
                                Texel Density
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender.html" >
                                Blender
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender - Rigging and Animation.html" >
                                Blender - Rigging and Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench.html" >
                                Blockbench
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench - Source Code.html" >
                                Blockbench - Source Code
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing Softwares.html" >
                                Drawing Softwares
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Aseprite/Aseprite.html" >
                                Aseprite
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Voxel Editors.html" >
                                Voxel Editors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/MagicaVoxel.html" >
                                MagicaVoxel
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 2D/Level Editors 2D.html" >
                                Level Editors 2D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 3D.html" >
                                Level Editors 3D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/LDtk/LDtk.html" >
                                LDtk
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/TrenchBroom.html" >
                                TrenchBroom
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Assets - Sources and References/Assets - Sources and References.html" >
                                Assets - Sources and References
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Frameworks - Libraries
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Frameworks - Libraries/Frameworks - Libraries.html" >
                                Frameworks - Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/RayLib/RayLib.html" >
                                RayLib
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Clay/Clay.html" >
                                Clay
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Physics Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines.html" >
                                Physics Engines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics.html" >
                                Physics Engines - JoltPhysics
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Godot Engine
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot/Godot.html" >
                                Godot
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDScript/Godot - GDScript.html" >
                                Godot - GDScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDExtensions.html" >
                                Godot - GDExtensions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - Source Code.html" >
                                Godot - Source Code
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Embedded Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/RaspiberryPi.html" >
                                RaspiberryPi
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Embedded Systems.html" >
                                Embedded Systems
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Platforms
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Windows/Windows.html" >
                                Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Steam/Steam.html" >
                                Steam
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Android/Android.html" >
                                Android
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/iOS/iOS.html" >
                                iOS
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Terminal
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Code Editors
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim/NeoVim.html" >
                                NeoVim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Etc
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Licenses.html" >
                                Licenses
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Unity/Unity.html" >
                                Unity
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Other Engines.html" >
                                Other Engines
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Memory
						</h1>
						<p>
							<time
								datetime="2025-03-12" >
                                üïí Created: 2025-03-12
							</time>
							<time
								datetime="2025-12-13" >
                                | Updated: 2025-12-13
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="virtual-memory" >
    Virtual Memory
</h2>
<ul>
	<li>
		<p>
            Modern operating systems virtualize memory on a per-process basis. This means that the addresses used within your program/process are specific to that program/process only.
		</p>
	</li>
	<li>
		<p>
            Memory is no longer this dualistic model of 
			<em>
                the stack
			</em>
            &nbsp;and 
			<em>
                the heap
			</em>
            &nbsp;but rather a monistic model where everything is virtual memory.
		</p>
	</li>
	<li>
		<p>
            Some of that virtual address space is reserved for procedure stack frames, some of it is reserved for things required by the operating system, and the rest we can use for whatever we want.
		</p>
	</li>
	<li>
		<p>
            Memory is virtually-mapped and linear, and you can split that linear memory space into sections.
		</p>
	</li>
	<li>
		<p>
            &quot;A process view of memory&quot;.
		</p>
	</li>
	<li>
		<p>
            Virtual memory is &quot;merely&quot; the way the OS exposes memory to user-space applications. It is not how most allocators work.
		</p>
	</li>
	<li>
		<p>
            For the most part, one can simplify the concept of virtual memory down to &quot;I ask the OS for a block of memory that is a number of pages in size&quot;, where a &quot;page&quot; is defined by the OS. Modern systems often have it as 4096 bytes. You'll say you want 8 pages, and the OS gives you a pointer to the first byte in a 
            <code>8*4096</code>
            &nbsp;byte block to use. You can also do things like set whether each page is readable, writable, executable, etc.
		</p>
	</li>
	<li>
		<p>
            And, as you alluded to initially, each page can be resident or not. So to say, actually backed by physical memory, or only theoretically set up for access however you've not touched it yet.
		</p>
	</li>
	<li>
		<p>
            My current understanding:
		</p>
		<ul>
			<li>
				<p>
                    (2025-11-14)
				</p>
			</li>
			<li>
				<p>
                    when calling 
                    <code>new()</code>
                    &nbsp;or 
                    <code>make()</code>
                    &nbsp;with the default heap allocator (
                    <code>context.allocator</code>
                    ), Odin internally calls 
                    <code>malloc</code>
                    /
                    <code>calloc</code>
                    &nbsp;(at least on Unix) which internally calls 
                    <code>mmap</code>
                    &nbsp;to reserve a chunk of virtual memory (4MiB (is it maybe 4KB?) in x86_64), which is only physically allocated when touching the memory on read/write (in Odin I assume this is done immediately as for ZII). A 
                    <code>new(int)</code>
                    &nbsp;is allocated inside a free slot list inside a run inside the chunk; apparently something like 16B for an 
                    <code>int</code>
                    &nbsp;(this sounds weird to me as it can lead to 8B of waste in a 64bit system).
				</p>
			</li>
			<li>
				<p>
                    For heap-allocated arenas in Odin, it seems like you need to create a buffer using a heap allocator before you can use the arena, which was confusing to me at first, but it makes sense now. I just see them now as a &quot;managed slice of bytes in memory&quot; inside the allocated region from the heap allocator.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/Pasted%20image%2020251112092912.png" width="378" alt="" >
            .
		</p>
	</li>
	<li>
		<p>
            The program still assumes the memory is continuous.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/Pasted%20image%2020251113085433.png" width="395" alt="" >
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=dFIqNZ8VbRY" 
				class="external-link" 
				target="_blank" >
                Excelent talk by JF Bastien
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The whole video is really cool.
				</p>
			</li>
			<li>
				<p>
                    {28:30} He starts talking about Virtual Memory.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/Pasted%20image%2020251112142739.png" width="613" alt="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/Pasted%20image%2020251112142808.png" width="620" alt="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/Pasted%20image%2020251112142831.png" width="584" alt="" >
                    ..
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/Pasted%20image%2020251112141125.png" width="571" alt="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/Pasted%20image%2020251112141416.png" width="570" alt="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Caches make all this thing described work.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/Pasted%20image%2020251112142053.png" width="561" alt="" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=QyYoj9pkwCs" 
				class="external-link" 
				target="_blank" >
                Motivations for Virtual Memory - Chris Kanich
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=sGHYRr31BPE" 
				class="external-link" 
				target="_blank" >
                The magic of the page fault: understanding demand paging of virtual memory in linux
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=hd8bYx7QCS0" 
				class="external-link" 
				target="_blank" >
                Page tables for your page tables: understanding how multi level page tables work
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=ccWRlNP1UsY" 
				class="external-link" 
				target="_blank" >
                Demystifying Page Tables
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=8hVLcyBkSXY" 
				class="external-link" 
				target="_blank" >
                Virtual Memory, mmap, Shared Memory, Copy On Write, creating a new process via Fork, Exec - Chris Kanich
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I haven't see the whole video. The content seemed distant to what I need right now.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="initial-content" >
    Initial content
</h5>
<ul>
	<li>
		<p>
            Caio:
		</p>
		<ul>
			<li>
				<p>
                    &quot;Even when allocator gets a mapped virtual range from the kernel, actual physical pages are usually allocated only when you touch them (page fault on first write/read). So 
                    <code>mmap</code>
                    /
                    <code>sbrk</code>
                    &nbsp;creates virtual address space; the kernel populates physical pages on demand. Physical memory for those pages is usually committed lazily; when the process first touches a page, the kernel allocates a physical frame and updates the page tables.&quot; Or from the spec of 
                    <code>malloc</code>
                    : Allocates 
                    <code>size</code>
                    &nbsp;bytes and returns a pointer to the allocated memory. 
					<strong>
                        The memory is not initialized
					</strong>
                    . If 
                    <code>size</code>
                    &nbsp;is 0, then 
                    <code>malloc()</code>
                    &nbsp;returns a unique pointer value that can later be successfully passed to 
                    <code>free()</code>
                    . So what I got from both is that a page just has garbage at first, and doesn't actually have anything physical to it, just a virtual reservation of memory, but when writing to memory the OS would actually physically allocate that memory. So when I said &quot;the act of Odin zeroing the memory would interact with the OS&quot; I was referring to making the OS physically allocate the memory right away, not &quot;lazily&quot;, if that makes sense.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;Not initialized&quot; is like Odin's 
            <code>---</code>
            . It will be garbage. &quot;Committing lazily&quot; is about what I said before about being assigned to physical memory vs merely being set up for use.
		</p>
	</li>
	<li>
		<p>
            To be committed is to be resident is to be assigned to physical memory
		</p>
	</li>
	<li>
		<p>
            but only use a few megs
		</p>
	</li>
	<li>
		<p>
            why provide all of it
		</p>
	</li>
	<li>
		<p>
            Some OSes (linux being a good example) allows overcommit
		</p>
	</li>
	<li>
		<p>
            requesting memory from the OS is &quot;the OS promises to give you the memory when you actually use it&quot;
		</p>
	</li>
	<li>
		<p>
            (nb: depends on the OS/configuration/etc)
		</p>
	</li>
	<li>
		<p>
            Despite the fact that &quot;being committed&quot; means &quot;assigned to physical memory&quot;, does that in fact mean that once you tell the OS to make some memory committed, that it will immediately appear in the task manager as taking up your RAM? You should create your own alloc and see what happens.
		</p>
	</li>
</ul>
<h3
	id="os-pages" >
    OS Pages
</h3>
<ul>
	<li>
		<p>
            The page is the fundamental unit of virtual memory managed by the operating system and the CPU‚Äôs MMU (Memory Management Unit).
		</p>
	</li>
	<li>
		<p>
            The kernel can only map, protect, or page-in/page-out whole pages. There‚Äôs no such thing as ‚Äúhalf a page‚Äù to the MMU.
		</p>
	</li>
	<li>
		<p>
            Pages are what the OS maps between virtual addresses (what your process sees) and physical memory (RAM).
		</p>
	</li>
	<li>
		<p>
            When a process calls 
            <code>mmap()</code>
            &nbsp;or 
            <code>sbrk()</code>
            , the OS reserves a region of virtual address space measured in pages. Physical memory for those pages is usually committed lazily ‚Äî when the process first touches a page, the kernel allocates a physical frame and updates the page tables.
		</p>
	</li>
</ul>
<h5
	id="typical-size" >
    Typical size
</h5>
<ul>
	<li>
		<p>
            CPU/kernel page size is usually 4 KiB on x86_64 ‚Äî that‚Äôs the granularity the MMU uses.
		</p>
	</li>
</ul>
<h3
	id="chunk" >
    Chunk
</h3>
<ul>
	<li>
		<p>
            Pool of memory for suballocations.
		</p>
	</li>
	<li>
		<p>
            A chunk is made up of many OS pages.
		</p>
	</li>
	<li>
		<p>
            It's an allocator-internal bookkeeping unit ‚Äî a larger contiguous region of virtual memory (often multiple pages) that the allocator manages.
		</p>
	</li>
	<li>
		<p>
            It helps reduce syscall overhead. The allocator calls 
            <code>mmap</code>
            /
            <code>sbrk</code>
            &nbsp;once to get a big chunk, then fulfills thousands of small allocations (1 B‚Äì1 KiB) from that memory by splitting it into bins or slabs.
		</p>
	</li>
	<li>
		<p>
            The allocator requests a contiguous virtual region (a chunk) and the OS provides that region in page-sized units.
		</p>
	</li>
	<li>
		<p>
            The allocator only maps or expands its arena in chunk-sized (or threshold-driven) increments.
		</p>
	</li>
</ul>
<h5
	id="typical-size" >
    Typical size
</h5>
<ul>
	<li>
		<p>
            <code>glibc malloc</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Variable, based on 
                    <code>brk</code>
                    &nbsp;or 
                    <code>mmap</code>
                    &nbsp;thresholds.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>jemalloc</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Often 4 MiB per chunk.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>tcmalloc</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    Often 2 MiB per span.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Btw: 4 MiB chunk = 1024 OS pages.
		</p>
	</li>
</ul>
<h5
	id="size-class" >
    Size class
</h5>
<ul>
	<li>
		<p>
            Allocator rounds requested sizes up to a small set of sizes (e.g. 8, 16, 24, ‚Ä¶, 1024, then larger classes).
		</p>
	</li>
	<li>
		<p>
            Allocators round requested sizes up to a 
			<em>
                size class
			</em>
            &nbsp;for alignment and bookkeeping simplicity.
		</p>
	</li>
	<li>
		<p>
            Typical rules on 64-bit systems:
		</p>
		<ul>
			<li>
				<p>
                    Minimum alignment/slot is often 
					<strong>
                        8 or 16 bytes
					</strong>
                    &nbsp;(16 is common on x86_64 for SIMD/alignment safety).
				</p>
			</li>
			<li>
				<p>
                    Sizes are rounded up into a small table of classes (e.g. 8,16,24,32,‚Ä¶ or 16,32,48,64,‚Ä¶ depending on allocator).
				</p>
			</li>
			<li>
				<p>
                    A run is created for a size class (e.g. 16 B slots); a page (4 KiB) then contains 
                    <code>4096 / 16 = 256</code>
                    &nbsp;slots.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Implication:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Each 
                    <code>int</code>
                    &nbsp;allocation carries 
					<em>
                        internal fragmentation
					</em>
                    &nbsp;(unused bytes inside the slot). An 
                    <code>int</code>
                    &nbsp;is 4B, but uses a 16 B slot, that‚Äôs 12 B wasted per allocation (in-slot waste).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="run-span" >
    Run / span
</h5>
<ul>
	<li>
		<p>
            A contiguous subrange of pages inside a chunk that the allocator uses for a particular size class.
		</p>
	</li>
	<li>
		<p>
            One or more whole pages inside a chunk that the allocator dedicates to a single 
			<em>
                size class
			</em>
            .
		</p>
	</li>
</ul>
<h5
	id="bins-free-lists" >
    Bins / free lists
</h5>
<ul>
	<li>
		<p>
            Per-size-class pools of free blocks ready to be returned for 
            <code>malloc</code>
            &nbsp;without splitting.
		</p>
	</li>
</ul>
<h5
	id="slot-block-object" >
    Slot / block / object
</h5>
<ul>
	<li>
		<p>
            An individual allocation returned to the program (one slot inside a run).
		</p>
	</li>
	<li>
		<p>
            They are the small pieces inside a run.
		</p>
	</li>
</ul>
<h5
	id="illustration-chatgpt" >
    Illustration (ChatGPT)
</h5>
<ul>
	<li>
		<p>
            Before any allocation:
		</p>
<pre><code class="language-txt" data-lang="txt">Chunk (4 MiB)
[ chunk header | page0 | page1 | page2 | ... | page1023 ]
</code></pre>
	</li>
	<li>
		<p>
            First allocation: 
            <code>new int</code>
            &nbsp;(4B ‚Üí rounded to 16B)
		</p>
		<ul>
			<li>
				<p>
                    Allocator path:
				</p>
				<ol>
					<li>
						<p>
                            Translate request size ‚Üí size-class 16 B.
						</p>
					</li>
					<li>
						<p>
                            Look for an existing run for 16 B with free slots.
						</p>
					</li>
					<li>
						<p>
                            None yet in any chunk/arena, so allocator 
							<strong>
                                converts one page
							</strong>
                            &nbsp;from the chunk into a run for the 16 B class. (This means the allocator marks page0 as a run and initializes its free-slot data: bitmap or free-list.)
						</p>
					</li>
					<li>
						<p>
                            Allocate the first slot (slot 0) from that run and return pointer 
                            <code>p = base_of_page0 + 0</code>
                            .
						</p>
					</li>
				</ol>
			</li>
		</ul>
<pre><code class="language-txt" data-lang="txt">Chunk
[ chunk header | page0: RUN(16B) [slot0=used, slot1..slot255=free] | page1 | ... ]
</code></pre>
		<ul>
			<li>
				<p>
                    Physical pages: if allocator zeroes the returned memory (language runtime 
                    <code>new</code>
                    &nbsp;semantics), writing to the slot causes a page-fault and kernel provides a physical frame for page0. If allocator does not touch payload, that page may still be unbacked until first write.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Next few allocations: more small 
            <code>new()</code>
            &nbsp;calls:
		</p>
		<ul>
			<li>
				<p>
                    Each further 
                    <code>new(‚Ä¶)</code>
                    &nbsp;of size ‚â§16 B:
				</p>
				<ul>
					<li>
						<p>
                            Pop next free slot from page0‚Äôs free-list (slot1, slot2, ...).
						</p>
					</li>
					<li>
						<p>
                            No syscalls; purely allocator metadata ops (possibly lock-free if per-thread).
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-txt" data-lang="txt">page0: RUN(16B) [slot0..slot9 = used, slot10..slot255 = free]
</code></pre>
		<ul>
			<li>
				<p>
                    Physical pages: once the program touches each used slot, page0's single physical frame services all those slots.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Run exhaustion: allocate the 257th small object
		</p>
		<ul>
			<li>
				<p>
                    When page0‚Äôs 256 slots are all consumed:
				</p>
				<ul>
					<li>
						<p>
                            Allocator sees the run is full.
						</p>
					</li>
					<li>
						<p>
                            It selects another free page inside the chunk (page1) and converts it into a new run for the 16 B size-class.
						</p>
					</li>
					<li>
						<p>
                            page1 gets initialized with its own free-list/bitmap; allocation returns page1 slot0.
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-txt" data-lang="txt">[ chunk header | page0: RUN(16B) [all used] | page1: RUN(16B) [slot0=used, slot1..=free] | page2 ... ]
</code></pre>
		<ul>
			<li>
				<p>
                    Still no new 
                    <code>mmap</code>
                    &nbsp;syscall ‚Äî allocator used pages already reserved inside the chunk. If the chunk had no free pages left for runs, allocator would 
                    <code>mmap</code>
                    &nbsp;a new chunk.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Mixed-size allocations appear later:
		</p>
		<ul>
			<li>
				<p>
                    Suppose you then 
                    <code>malloc(1 KiB)</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allocator maps that request to a larger size-class (say 1024 B).
						</p>
					</li>
					<li>
						<p>
                            It will allocate from a run/span dedicated to that class. If none exists:
						</p>
						<ul>
							<li>
								<p>
                                    It may grab one or more pages inside the same chunk and create a span for 1 KiB blocks. Example: one page can hold 
                                    <code>4096 / 1024 = 4</code>
                                    &nbsp;blocks.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If the large request exceeds the allocator‚Äôs ‚Äúlarge‚Äù threshold it may instead call 
                            <code>mmap</code>
                            &nbsp;and give the caller an independent mapping (outside chunk).
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-txt" data-lang="txt">[ chunk header |
&nbsp;&nbsp;page0: RUN(16B) full |
&nbsp;&nbsp;page1: RUN(16B) partly-used |
&nbsp;&nbsp;page2: RUN(1KB) [blk0..blk3 some used] |
&nbsp;&nbsp;page3: free page |
&nbsp;&nbsp;... ]
</code></pre>
	</li>
	<li>
		<p>
            Freeing behavior
		</p>
		<ul>
			<li>
				<p>
                    Freeing a 16 B slot: allocator marks the slot free (pushes to free-list or clears bitmap). The page remains a run page. Usually the allocator 
					<strong>
                        does not
					</strong>
                    &nbsp;
                    <code>munmap</code>
                    &nbsp;a single partially-used page.
				</p>
			</li>
			<li>
				<p>
                    When an entire run/span (one or more pages) becomes fully unused, allocator heuristics may decide to:
				</p>
				<ul>
					<li>
						<p>
                            keep it for reuse (common), or
						</p>
					</li>
					<li>
						<p>
                            coalesce and 
                            <code>munmap</code>
                            &nbsp;the pages to return virtual address space (or release them to a central pool). This is allocator-specific.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="virtual-memory-mapping" >
    Virtual Memory Mapping
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=XV5sRaSVtXQ" 
				class="external-link" 
				target="_blank" >
                mmap and brk example
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=m7E9piHcfr4" 
				class="external-link" 
				target="_blank" >
                using mmap to read and write a file
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=rPV6b8BUwxM" 
				class="external-link" 
				target="_blank" >
                using mmap to share memory between processes
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="mmap" >
    mmap
</h5>
<ul>
	<li>
		<p>
            <code>mmap(..)</code>
		</p>
	</li>
	<li>
		<p>
            Tells the OS to allow read/write to a file/device as if it were in memory with byte 0 at a given address.
		</p>
	</li>
	<li>
		<p>
            Even when allocator gets a mapped virtual range from the kernel, actual physical pages are usually allocated only when you touch them (page fault on first write/read). So 
            <code>mmap</code>
            /
            <code>sbrk</code>
            &nbsp;creates virtual address space; the kernel populates physical pages on demand.
		</p>
	</li>
	<li>
		<p>
            It does 
			<strong>
                not
			</strong>
            &nbsp;magically remember or manage allocator chunks ‚Äî the allocator (e.g. 
            <code>malloc</code>
            , jemalloc, tcmalloc) is what 
			<em>
                tracks
			</em>
            &nbsp;chunks and decides when to call 
            <code>mmap</code>
            &nbsp;or 
            <code>munmap</code>
            . 
            <code>mmap</code>
            &nbsp;simply asks the kernel to reserve/map a virtual-address region; the kernel records that region in its VM structures and returns the address. The allocator then sub-allocates from that region without further syscalls until it needs more space (or decides to return space).
		</p>
	</li>
</ul>
<h5
	id="brk" >
    brk
</h5>
<ul>
	<li>
		<p>
            <code>brk(..)</code>
		</p>
	</li>
	<li>
		<p>
            shrink with 
            <code>brk</code>
            &nbsp;can be used as &quot;unmap&quot;.
		</p>
	</li>
</ul>
<h5
	id="sbrk" >
    sbrk
</h5>
<ul>
	<li>
		<p>
            <code>sbrk(..)</code>
		</p>
	</li>
	<li>
		<p>
            Asks the OS to expand/contract the size of the valid memory.
		</p>
	</li>
	<li>
		<p>
            &quot;You get multiples of page size, one way or the other&quot;.
		</p>
	</li>
</ul>
<h5
	id="munmap" >
    munmap
</h5>
<ul>
	<li>
		<p>
            <code>munmap</code>
		</p>
	</li>
	<li>
		<p>
            Free pages, unmap.
		</p>
	</li>
</ul>
<h3
	id="process" >
    Process
</h3>
<ol>
	<li>
		<p>
            Your allocator (
            <code>malloc</code>
            ) decides it needs more virtual address space (its internal chunks/arenas are exhausted).
		</p>
	</li>
	<li>
		<p>
            The allocator issues a syscall (
            <code>mmap</code>
            &nbsp;or sometimes 
            <code>sbrk</code>
            /
            <code>brk</code>
            ) requesting a contiguous virtual region of some size (an allocator-chosen chunk, e.g. 4 MiB).
		</p>
	</li>
	<li>
		<p>
            The kernel creates a VMA (e.g. 
            <code>vm_area_struct</code>
            &nbsp;on Linux) covering that range and returns the base address to the allocator. No physical pages are necessarily assigned yet ‚Äî only virtual address space is reserved.
		</p>
	</li>
	<li>
		<p>
            The allocator records that new region in its own metadata (free lists, bitmaps, arena/chunk tables) and hands out pointers for subsequent 
            <code>malloc</code>
            /
            <code>new</code>
            &nbsp;requests from that region ‚Äî no further 
            <code>mmap</code>
            &nbsp;needed while that region has free space.
		</p>
	</li>
	<li>
		<p>
            When the program first accesses pages inside the region the CPU triggers page faults and the kernel assigns physical frames (demand paging).
		</p>
	</li>
	<li>
		<p>
            If the allocator later frees enough whole pages or decides it no longer needs the region, it may call 
            <code>munmap</code>
            &nbsp;(or shrink with 
            <code>brk</code>
            ) to return the virtual range to the kernel.
		</p>
	</li>
</ol>
<h2
	id="os-memory-on-windows" >
    OS: Memory on Windows
</h2>
<ul>
	<li>
		<p>
            Demand-page memory management.
		</p>
	</li>
	<li>
		<p>
            Process aren't &quot;born&quot; with everything it needs, it actually needs to ask the system for it.
		</p>
	</li>
	<li>
		<p>
            The virtual memory is just a concept until the process touches the memory, demanding that the memory be backed with something physical.
		</p>
	</li>
	<li>
		<p>
            There's almost 
			<strong>
                no
			</strong>
            &nbsp;connection between virtual memory and physical memory; except by the bridge between the two (mapping).
		</p>
	</li>
	<li>
		<p>
            There's no swap in Windows; it's a old technique for when a process goes idle, the OS would take it's memory and throw it out into the paging file.
		</p>
	</li>
	<li>
		<p>
            A page is 4KB.
		</p>
	</li>
	<li>
		<p>
            Page is defined by the hardware and the OS.
		</p>
	</li>
	<li>
		<p>
            Allocations must align on 64KB boundaries.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=AjTl53I_qzY" 
				class="external-link" 
				target="_blank" >
                Mysteries of Memory Management Revealed (Part 1/2)
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Virtual Memory.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=6KZdNsq1YV4" 
				class="external-link" 
				target="_blank" >
                Mysteries of Memory Management Revealed (Part 2/2)
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Physical Memory.
				</p>
			</li>
			<li>
				<p>
                    Talks about Working Set.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="process-address-space-management" >
    Process Address Space Management
</h3>
<ul>
	<li>
		<p>
            How an operating system represents, backs, and shares ranges of a process‚Äôs virtual addresses.
		</p>
	</li>
	<li>
		<p>
            The terminology used is Windows (Win32) specific.
		</p>
		<ul>
			<li>
				<p>
                    Ex: 
                    <code>MEM_COMMIT</code>
                    , 
                    <code>MEM_RESERVE</code>
                    , 
                    <code>MEM_IMAGE</code>
                    , 
                    <code>MEM_MAPPED</code>
                    , 
                    <code>VirtualAlloc</code>
                    , 
                    <code>VirtualQuery</code>
                    , Private Bytes, Working Set, Commit Charge, 
                    <code>pagefile</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The concepts themselves are general OS virtual-memory concepts present on Linux, BSD, macOS, etc. Other OSes use different APIs and names but implement the same ideas.
		</p>
		<ul>
			<li>
				<p>
                    Ex: reservation vs commit, file-backed vs anonymous, copy-on-write, resident set vs virtual size, sharable vs private.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A single memory region will have both a 
			<strong>
                State
			</strong>
            &nbsp;and a 
			<strong>
                Type
			</strong>
            .
		</p>
	</li>
</ul>
<h5
	id="memory-state-address-range-lifecycle" >
    Memory State (address-range lifecycle)
</h5>
<ul>
	<li>
		<p>
            `MEM_COMMIT
		</p>
		<ul>
			<li>
				<p>
                    Pages in that range have physical backing (pagefile and/or RAM) allocated (or will be charged to the process‚Äô commit limit).
				</p>
			</li>
			<li>
				<p>
                    Represents memory that actually contains or will contain data.`
				</p>
			</li>
			<li>
				<p>
                    In Use.
				</p>
			</li>
			<li>
				<p>
                    Actually serves some purpose. It represents some data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEM_RESERVE</code>
            &nbsp;(Windows) / 
            <code>mmap(..., PROT_NONE)</code>
            &nbsp;(Linux)
		</p>
		<ul>
			<li>
				<p>
                    Address range is reserved in the virtual address space.
				</p>
			</li>
			<li>
				<p>
                    No physical backing (RAM/pagefile) is allocated yet.
				</p>
			</li>
			<li>
				<p>
                    Reservation prevents other allocations from taking those addresses.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Does not
					</em>
                    &nbsp;consume commit.
				</p>
			</li>
			<li>
				<p>
                    Can later be turned into committed pages.
				</p>
			</li>
			<li>
				<p>
                    Allocates an address range without faulting pages.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEM_FREE</code>
		</p>
		<ul>
			<li>
				<p>
                    Address range is unallocated and available for a new reservation/commit. Nothing mapped there.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-type-what-backs-the-pages" >
    Memory Type (what backs the pages)
</h5>
<ul>
	<li>
		<p>
            <code>MEM_IMAGE</code>
		</p>
		<ul>
			<li>
				<p>
                    Executable images (EXE/DLL).
				</p>
			</li>
			<li>
				<p>
                    Mapped executable image (PE): your EXE and DLLs. File-backed by the image on disk (loaded by the loader).
				</p>
			</li>
			<li>
				<p>
                    Often reported as committed when pages are resident, but they are backed by the file on disk (not pagefile) unless they are written to and become private (COW).
				</p>
			</li>
			<li>
				<p>
					<em>
                        Examples
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Executable + DLLs (Vulkan loader, driver DLLs, runtimes).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEM_MAPPED</code>
		</p>
		<ul>
			<li>
				<p>
                    File-mapped data (non-image).
				</p>
			</li>
			<li>
				<p>
                    A file mapping created with 
                    <code>CreateFileMapping</code>
                    /
                    <code>MapViewOfFile</code>
                    &nbsp;(non-image file).
				</p>
			</li>
			<li>
				<p>
                    These are file-backed; they do not charge commit unless pages are privately modified (COW).
				</p>
			</li>
			<li>
				<p>
					<em>
                        Examples
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            mmapped asset packs, shader cache files, streamed textures, some driver mappings.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEM_PRIVATE</code>
		</p>
		<ul>
			<li>
				<p>
                    Private anonymous pages.
				</p>
			</li>
			<li>
				<p>
                    Anonymous/private memory (allocated with 
                    <code>VirtualAlloc(MEM_COMMIT)</code>
                    &nbsp;or via heap APIs).
				</p>
			</li>
			<li>
				<p>
                    Pagefile-backed; increases commit charge and is counted as Private Bytes.
				</p>
			</li>
			<li>
				<p>
                    Examples:
				</p>
				<ul>
					<li>
						<p>
                            Heaps, stacks, general 
                            <code>VirtualAlloc</code>
                            &nbsp;private buffers (your allocators if they commit pages), CRT heaps, driver user-mode allocations that use 
                            <code>VirtualAlloc(MEM_COMMIT)</code>
                            &nbsp;or heap APIs.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Working Set
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The set of physical pages (RAM) currently resident for the process. Includes resident pages from image, mapped files and private committed pages.
				</p>
			</li>
			<li>
				<p>
                    It is a resident-RAM metric.
				</p>
			</li>
			<li>
				<p>
                    Can be smaller than commit.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Commit / Commit Charge (pagefile)
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Amount of virtual memory that must be backed by the pagefile (or other backing store) across the system. Primarily driven by 
					<strong>
                        committed private
					</strong>
                    &nbsp;pages. File-backed pages normally do 
					<strong>
                        not
					</strong>
                    &nbsp;count against commit because they can be reloaded from the file on disk; they only count if they are made private (COW).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Virtual Size / Virtual Bytes
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Amount of virtual address space reserved/used by the process (includes reserved ranges + committed ranges). Large reservations increase virtual size but do not increase commit.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-property-sharable" >
    Memory Property: Sharable
</h5>
<ul>
	<li>
		<p>
            It is a property of some regions, not a type.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Shared pages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A page is shared when:
				</p>
				<ul>
					<li>
						<p>
                            It is backed by a file (image or file mapping).
						</p>
					</li>
					<li>
						<p>
                            It is 
							<em>
                                identical
							</em>
                            &nbsp;across processes
						</p>
					</li>
					<li>
						<p>
                            Access permissions allow sharing (typically read-only or copy-on-write)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Shared pages 
					<strong>
                        do not
					</strong>
                    &nbsp;count as private commit.
				</p>
			</li>
			<li>
				<p>
                    This corresponds to:
				</p>
				<ul>
					<li>
						<p>
                            <code>MEM_IMAGE</code>
						</p>
					</li>
					<li>
						<p>
                            <code>MEM_MAPPED</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Examples:
				</p>
				<ul>
					<li>
						<p>
                            EXE/DLL code sections
						</p>
					</li>
					<li>
						<p>
                            Read-only memory-mapped assets
						</p>
					</li>
					<li>
						<p>
                            Read-only data from DLLs
						</p>
					</li>
					<li>
						<p>
                            Shader cache files mapped read-only
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Private pages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A page is private when:
				</p>
				<ul>
					<li>
						<p>
                            It is backed by the 
                            <code>pagefile</code>
                            &nbsp;(anonymous memory).
						</p>
					</li>
					<li>
						<p>
                            It cannot be shared with another process.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    These pages contribute to 
					<strong>
                        Private Bytes
					</strong>
                    &nbsp;and 
					<strong>
                        commit
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    Corresponds to:
				</p>
				<ul>
					<li>
						<p>
                            <code>MEM_PRIVATE</code>
                            .
						</p>
					</li>
					<li>
						<p>
							<strong>
                                COW versions
							</strong>
                            &nbsp;of file-backed pages (after modification)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Examples:
				</p>
				<ul>
					<li>
						<p>
                            Normal 
                            <code>VirtualAlloc(MEM_COMMIT)</code>
                            &nbsp;memory
						</p>
					</li>
					<li>
						<p>
                            Heaps, stacks, arena allocators
						</p>
					</li>
					<li>
						<p>
                            Modified portions of an 
                            <code>mmapped</code>
                            &nbsp;file or the image (COW)
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEM_IMAGE</code>
		</p>
		<ul>
			<li>
				<p>
                    Always shareable until you write to a writable image section.
				</p>
			</li>
			<li>
				<p>
                    Backing is the image file on disk.
				</p>
			</li>
			<li>
				<p>
                    Multiple processes can map the same DLL and share the same physical pages.
				</p>
			</li>
			<li>
				<p>
                    The page stays shared if it comes from a DLL or EXE file with normal image layout.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEM_MAPPED</code>
		</p>
		<ul>
			<li>
				<p>
                    Always shareable until written.
				</p>
			</li>
			<li>
				<p>
                    By nature it is shareable, because it is file-backed.
				</p>
			</li>
			<li>
				<p>
                    Always 
					<strong>
                        sharable
					</strong>
                    , but whether it is 
					<em>
                        actually shared right now
					</em>
                    &nbsp;depends on whether another process maps the same file with compatible access.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        It can change
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If you modify a 
                            <code>MEM_MAPPED</code>
                            &nbsp;page, it becomes 
							<strong>
                                private
							</strong>
                            &nbsp;via COW.
						</p>
					</li>
					<li>
						<p>
                            The original (on-disk) data remains shareable.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEM_PRIVATE</code>
		</p>
		<ul>
			<li>
				<p>
                    Backed by pagefile.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Not shareable
					</strong>
                    &nbsp;between processes (unless you explicitly create shared memory using 
                    <code>CreateFileMapping(INVALID_HANDLE_VALUE, ...)</code>
                    , but in that case Windows still reports the pages as 
                    <code>MEM_MAPPED</code>
                    ).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="task-manager-windows" >
    Task Manager (Windows)
</h3>
<ul>
	<li>
		<p>
            Task Manager only let's you see &quot;private bytes&quot;, which is data that is private to the process.
		</p>
	</li>
	<li>
		<p>
            The 'Details' section allows to view a bit more information, if right clicked on the table.
		</p>
	</li>
	<li>
        <img src="assets/Pasted%20image%2020251118161230.png" width="500" alt="" >

	</li>
</ul>
<h3
	id="process-explorer-windows" >
    Process Explorer (Windows)
</h3>
<ul>
	<li>
		<p>
            Similar to VMMap.
		</p>
	</li>
	<li>
		<p>
            I don't know which is better, probably this one if I were to guess.
		</p>
	</li>
</ul>
<h3
	id="vmmap-windows" >
    ~VMMap (Windows)
</h3>
<ul>
	<li>
		<p>
			<em>
                Impressions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2025-11-18)
				</p>
			</li>
			<li>
				<p>
                    Really basic. It doesn't give much, as it's really old.
				</p>
			</li>
			<li>
				<p>
                    Basic but confusing, idk.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://learn.microsoft.com/en-us/sysinternals/downloads/vmmap" 
				class="external-link" 
				target="_blank" >
                VMMap
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Is a Windows GUI tool from Microsoft Sysinternals that visualizes a process‚Äôs virtual memory layout and usage. It breaks memory down by type (Private, Image, Mapped File, Heap, Stack, etc.), shows committed vs reserved, identifies owning modules, and lets you take/compare snapshots.
		</p>
	</li>
	<li>
		<p>
            Windows only. On Linux/macOS use tools like 
            <code>pmap</code>
            /
            <code>smaps</code>
            , 
            <code>proc</code>
            /
            <code>vm_stat</code>
            , 
            <code>perf</code>
            , or process-specific profilers.
		</p>
	</li>
	<li>
		<p>
            Run 
            <code>VMMap.exe</code>
            &nbsp;
			<strong>
                as Administrator
			</strong>
            &nbsp;for full information.
		</p>
	</li>
</ul>
<h3
	id="windbg-windows" >
    WinDbg (Windows)
</h3>
<ul>
	<li>
		<p>
            Advanced stack/heap debugging for Windows binaries.
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">!heap -s&nbsp;&nbsp;&nbsp;&nbsp; # Show heap summary
!address&nbsp;&nbsp;&nbsp;&nbsp; # Memory layout overview
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=QuFJpH3My7A" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="get-process-windows" >
    Get-Process (Windows)
</h3>
<ul>
	<li>
		<p>
            Use on Powershell.
		</p>
	</li>
	<li>
		<p>
            Thread count and stacks
		</p>
		<ul>
			<li>
				<p>
                    Just replace 
                    <code>&lt;pid&gt;</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-sh" data-lang="sh">Get-Process -Id &lt;pid&gt; | Format-List Id,ProcessName,WorkingSet64,PrivateMemorySize64,VirtualMemorySize64,@{Name='Threads';Expression={$_.Threads.Count}}
</code></pre>
	</li>
	<li>
		<p>
            List loaded modules (may hint at large static data).
		</p>
		<ul>
			<li>
				<p>
                    Just replace 
                    <code>&lt;pid&gt;</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-sh" data-lang="sh">(Get-Process -Id &lt;pid&gt;).Modules | Select ModuleName,FileName,@{n='FileSizeMB';e={[math]::Round(($_.ModuleMemorySize/1MB),2)}} | Sort-Object FileSizeMB -Descending | Format-Table -AutoSize
</code></pre>
	</li>
</ul>
<h2
	id="memory-alignment" >
    Memory Alignment
</h2>
<h3
	id="why-to-align" >
    Why to align
</h3>
<ul>
	<li>
		<p>
            The scenario below causes unnecessary wastage of CPU cycles.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090530.png" width="480" >
            .
		</p>
	</li>
	<li>
		<p>
            If we use padding (empty space) we can improve the CPU cycles, at the cost of the struct storing more memory.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090718.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090834.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            The order of the elements matters, as it can introduce more padding than necessary:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090936.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009091017.png" width="400" >
            .
		</p>
	</li>
</ul>
<h3
	id="memory-access" >
    Memory Access
</h3>
<ul>
	<li>
		<p>
            Processors don't read 1 byte at a time from memory.
		</p>
	</li>
	<li>
		<p>
            They read 1 
			<strong>
                word
			</strong>
            &nbsp;at a time.
		</p>
	</li>
	<li>
		<p>
			<strong>
                32-bit Processor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Word size is 4 bytes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                64-bit Processor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Word size is 8 bytes.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="size" >
    Size
</h3>
<ul>
	<li>
		<p>
            The total number of bytes that a single element actually occupies in memory, 
			<em>
                including
			</em>
            &nbsp;any internal padding required by alignment.
		</p>
	</li>
</ul>
<h3
	id="offset" >
    Offset
</h3>
<ul>
	<li>
		<p>
            Defines where a field resides relative to a structure‚Äôs base address.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In 
                    <code>struct { int a; char b; }</code>
                    , if 
                    <code>a</code>
                    &nbsp;starts at offset 
                    <code>0</code>
                    , 
                    <code>b</code>
                    &nbsp;might be at offset 
                    <code>4</code>
                    &nbsp;due to alignment padding.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="stride" >
    Stride
</h3>
<ul>
	<li>
		<p>
            Byte distance between consecutive elements in an array or buffer.
		</p>
	</li>
	<li>
		<p>
            It‚Äôs not ‚Äúafter the element finishes‚Äù, it‚Äôs the 
			<em>
                total distance between consecutive starts
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            That‚Äôs why stride includes all bytes (data + padding) in a single element.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In a vertex buffer with position (12 bytes) + color (4 bytes), stride = 16 bytes. The next vertex starts 16 bytes after the previous one.
				</p>
				<ul>
					<li>
						<p>
                            Vertex 0 starts at byte 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Vertex 0 occupies bytes 
                            <code>0‚Äì15</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Vertex 1 starts at byte 
                            <code>16</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="address" >
    Address
</h2>
<h3
	id="alignment" >
    Alignment
</h3>
<ul>
	<li>
		<p>
            Alignment and Size are different things.
		</p>
	</li>
	<li>
		<p>
            Alignment == &quot;Divisible by&quot;.
		</p>
	</li>
	<li>
		<p>
            Required byte boundary a value must start on, typically a power of two.
		</p>
	</li>
	<li>
		<p>
            Hardware or ABI rule ensuring each type begins at addresses divisible by its alignment requirement.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009083338.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            An address is said to be 
			<em>
                aligned to 
                <code>N</code>
                &nbsp;bytes
			</em>
            , if the addresses's numeric value is divisible by 
            <code>N</code>
            . The number 
            <code>N</code>
            &nbsp;in this case can be referred to as the 
			<em>
                alignment boundary
			</em>
            . Typically an alignment is a power of two integer value.
		</p>
	</li>
	<li>
		<p>
            A 
			<em>
                natural alignment
			</em>
            &nbsp;of an object is typically equal to its size. For example a 16 bit integer has a natural alignment of 2 bytes.
		</p>
	</li>
</ul>
<h5
	id="unalignment" >
    Unalignment
</h5>
<ul>
	<li>
		<p>
            When an object is not located on its natural alignment boundary, accesses to that object are considered 
			<em>
                unaligned
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Some machines issue a hardware 
			<strong>
                exception
			</strong>
            , or experience 
			<strong>
                slowdowns
			</strong>
            &nbsp;when a memory access operation occurs from an unaligned address. Examples of such operations are:
		</p>
		<ul>
			<li>
				<p>
                    SIMD instructions on x86. These instructions require all memory accesses to be on an address that is aligned to 16 bytes.
				</p>
			</li>
			<li>
				<p>
                    On ARM unaligned loads have an extra cycle penalty.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you have an unaligned memory access (on a processor that allows it), the processor will have to read multiple ‚Äúwords‚Äù. This means that an unaligned memory access 
			<em>
                may
			</em>
            &nbsp;be much slower than an aligned memory access.
		</p>
	</li>
	<li>
		<p>
            This can also lead to undefined behavior if the unaligned memory is within cache bounds.
		</p>
	</li>
</ul>
<h5
	id="implicit-alignment" >
    Implicit Alignment
</h5>
<ul>
	<li>
		<p>
            When placing a field, the compiler ensures the field's offset is a multiple of the field's alignment. If the current offset is 
			<em>
                not
			</em>
            &nbsp;a multiple of the field's alignment, the compiler inserts padding before the field so the resulting offset becomes a multiple of the alignment.
		</p>
		<ul>
			<li>
				<p>
                    When placing field F the compiler ensures 
                    <code>offset(F) % align(F) == 0</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If not, it inserts 
                    <code>padding = (align(F) - (offset % align(F))) % align(F)</code>
                    &nbsp;bytes before F.
				</p>
			</li>
			<li>
				<p>
                    The struct‚Äôs overall alignment is 
                    <code>max(align(member))</code>
                    . The compiler may add trailing padding so 
                    <code>sizeof(struct)</code>
                    &nbsp;is a multiple of that max alignment.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A struct adds implicit padding between members, based on the alignment of the member with the highest alignment.
		</p>
	</li>
	<li>
		<p>
            The gray dots indicate the implicit padding added by the compiler.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009083656.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            It may also add padding at the end of the struct, so the struct is divisible by its alignment. This ensures that when the struct is used as an array, each struct will be properly aligned along with its members.
		</p>
	</li>
</ul>
<h5
	id="odin" >
    Odin
</h5>
<ul>
	<li>
		<p>
            Alignment, Size and the Pointer are related, such as:
		</p>
		<ul>
			<li>
				<p>
                    <code>size_of(T) % align_of(T) == 0</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>uintptr(&t) % align_of(t) == 0</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Check 
                    <a href="/studies/Low-Level Systems/Odin/Odin.html#alignment">
                    Odin#Alignment
                    </a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Many operations that allocate memory in this package allow to explicitly specify the alignment of allocated pointers/slices.
		</p>
	</li>
	<li>
		<p>
            The default alignment for all operations is specified in a constant 
            <code>mem.DEFAULT_ALIGNMENT</code>
            .
		</p>
	</li>
</ul>
<h3
	id="std140-and-std430" >
    std140 and std430
</h3>
<ul>
	<li>
		<p>
            Both are GLSL memory alignments.
		</p>
	</li>
	<li>
		<p>
            Check 
            <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#shader-aligment-stride-offsets">
            Vulkan#Shader Alignment, Stride, Offsets
            </a>
            .
		</p>
	</li>
</ul>
<h2
	id="allocators" >
    Allocators
</h2>
<h5
	id="lifetimes-hierarchy" >
    Lifetimes Hierarchy
</h5>
<ul>
	<li>
		<p>
			<strong>
                Permanent Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Memory that is never freed until the end of the program. This memory is persistent during the program lifetime.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transient Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Memory that has a cycle-based lifetime. This memory only persists for the ‚Äúcycle‚Äù and is freed at the end of this cycle. An example of a cycle could be a frame within a graphical program (e.g. a game) or an update loop.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scratch/Temporary Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Short-lived, quick memory that you just want to allocate and forget about. A common case for this is when generating a string and outputting it to a log.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="types-of-allocators" >
    Types of Allocators
</h3>
<ul>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/Odin/Odin.html#memory-allocators">
            Odin#Memory: Allocators
            </a>
            .
		</p>
		<ul>
			<li>
				<p>
                    There's a lot of things there.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/C.html#malloc">
            C#malloc
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="making-your-own-allocator" >
    Making your own allocator
</h3>
<h4
	id="where-to-allocate" >
    Where to allocate
</h4>
<h5
	id="algorithms-for-searching-for-free-blocks" >
    Algorithms for searching for free blocks
</h5>
<ul>
	<li>
		<p>
            First Fit.
		</p>
	</li>
	<li>
		<p>
            Next Fit.
		</p>
		<ul>
			<li>
				<p>
                    Optimization from First Fit, but increases fragmentation, apparently.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Best Fit.
		</p>
	</li>
</ul>
<h4
	id="coalescing-quotgrowing-together-fusingquot" >
    Coalescing (&quot;Growing together, fusing&quot;)
</h4>
<ul>
	<li>
		<p>
            When we have two free blocks next to each other, merge them together into one large block.
		</p>
	</li>
</ul>
<h5
	id="strategies" >
    Strategies
</h5>
<ul>
	<li>
		<p>
            On free: coalesce.
		</p>
		<ul>
			<li>
				<p>
                    Coalesce only above and below, once on free.
				</p>
			</li>
			<li>
				<p>
                    This is preferred as it has a more predictable performance.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Coalesce once in a while.
		</p>
		<ul>
			<li>
				<p>
                    This can take a little while, but removes the need to do it every operation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=UTii4dyhR5c" 
				class="external-link" 
				target="_blank" >
                Free List, Where to allocate a block, Coalescing - Chris Kanich
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=EhmZvyNA-1A" 
				class="external-link" 
				target="_blank" >
                Exploring a heap allocated memory with 
                <code>gdb</code>
                , showing free lists, etc - Chris Kanich
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="tools-memory-analysis" >
    Tools: Memory Analysis
</h2>
<h3
	id="asan-address-sanitizer" >
    ASan (Address Sanitizer)
</h3>
<ul>
	<li>
		<p>
            Accessing memory outside its scope causes a Segfault, but accessing memory inside another valid region of code can cause memory corruption.
		</p>
	</li>
	<li>
		<p>
            Because of this, ASan is used to check if accesses are within the array bounds, etc.
		</p>
	</li>
</ul>
<h5
	id="flags" >
    Flags
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/asan/asan_flags.inc#L169" 
				class="external-link" 
				target="_blank" >
                ASan LLVM flags
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;If you run it with 
                    <code>set ASAN_OPTIONS=help=1</code>
                    , it'll dump out a list on startup too.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags" 
				class="external-link" 
				target="_blank" >
                ASan Google flags
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Used in Odin:
		</p>
		<ul>
			<li>
				<p>
                    <code>set ASAN_OPTIONS=detect_stack_use_after_return=true:windows_hook_rtl_allocators=true</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="crash-report-registers" >
    Crash Report: Registers
</h5>
<ul>
	<li>
		<p>
			<strong>
                PC (Program Counter)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Also known as the Instruction Pointer (IP) in x86.
				</p>
			</li>
			<li>
				<p>
                    Points to the next instruction to be executed.
				</p>
			</li>
			<li>
				<p>
                    In ASan reports, the PC indicates where the crash (e.g., use-after-free, buffer overflow) occurred.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                BP (Base Pointer / Frame Pointer)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used to track the base of the current stack frame in functions.
				</p>
			</li>
			<li>
				<p>
                    Helps in unwinding the call stack during debugging.
				</p>
			</li>
			<li>
				<p>
                    May not always be present (e.g., in optimized builds where frame pointers are omitted).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SP (Stack Pointer)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Points to the top of the stack.
				</p>
			</li>
			<li>
				<p>
                    Used for managing function calls, local variables, and return addresses.
				</p>
			</li>
			<li>
				<p>
                    ASan uses this to detect stack-based buffer overflows or stack-use-after-return.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="warnings" >
    Warnings
</h5>
<ul>
	<li>
		<p>
            <code>Failed to use and restart external symbolizer!</code>
		</p>
		<ul>
			<li>
				<p>
                    Means that ASan could not use an external tool to convert raw memory addresses into readable file names, line numbers, and function names in your stack trace.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Why
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Missing Symbolizer Tool
						</p>
						<ul>
							<li>
								<p>
                                    ASan relies on an external program (like 
                                    <code>llvm-symbolizer</code>
                                    &nbsp;or 
                                    <code>addr2line</code>
                                    ) to map addresses to source code locations.
								</p>
							</li>
							<li>
								<p>
                                    If this tool is not installed or not in your 
                                    <code>PATH</code>
                                    , ASan can't resolve symbols properly.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Incorrect Path or Permissions
						</p>
						<ul>
							<li>
								<p>
                                    Even if the symbolizer exists, ASan might fail to execute it due to:
								</p>
								<ul>
									<li>
										<p>
                                            Wrong permissions (e.g., no execute access).
										</p>
									</li>
									<li>
										<p>
                                            Anti-virus blocking the tool.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Windows-Specific Issues
						</p>
						<ul>
							<li>
								<p>
                                    On Windows, ASan expects 
                                    <code>llvm-symbolizer.exe</code>
                                    &nbsp;to be available.
								</p>
							</li>
							<li>
								<p>
                                    If you're using MSVC, it might not be bundled by default.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            ASan Could Not Restart the Symbolizer
						</p>
						<ul>
							<li>
								<p>
                                    If the symbolizer crashes or times out, ASan gives up and shows this warning.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Fix
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Install 
							<a
								href="https://github.com/llvm/llvm-project/releases" 
								class="external-link" 
								target="_blank" >
                                LLVM
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="valgrind-massif-visualizer" >
    Valgrind + massif-visualizer
</h3>
<ul>
	<li>
		<p>
            &quot;Massif Visualizer is a tool that visualizes massif data. You run your application in Valgrind with 
            <code>--tool=massif</code>
            &nbsp;and then open the generated 
            <code>massif.out.%pid</code>
            &nbsp;in the visualizer. 
			<em>
                Gzip
			</em>
            &nbsp;or 
			<em>
                Bzip2
			</em>
            &nbsp;compressed massif files can also be opened transparently.&quot;
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/KDE/massif-visualizer" 
				class="external-link" 
				target="_blank" >
                massif-visualizer
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Created 16 years ago.
				</p>
			</li>
			<li>
				<p>
                    Updated 2 weeks ago.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://apps.kde.org/pt-br/massif_visualizer/" 
				class="external-link" 
				target="_blank" >
                massif-visualizer
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sys/valgrind/" 
				class="external-link" 
				target="_blank" >
                core:sys/valgrind
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://valgrind.org/docs/manual/ms-manual.html" 
				class="external-link" 
				target="_blank" >
                Massif docs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://courses.cs.washington.edu/courses/cse326/05wi/valgrind-doc/ms_main.html" 
				class="external-link" 
				target="_blank" >
                Massif docs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=A5Rc4AwdaOA" 
				class="external-link" 
				target="_blank" >
                Valgrind demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=pvOYwxsDIJI" 
				class="external-link" 
				target="_blank" >
                Valgrind + GDB demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Tracks heap usage over time and generates memory snapshots.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platforms
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Linux
				</p>
				<ul>
					<li>
						<p>
                            Primary platform, best support
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    macOS
				</p>
				<ul>
					<li>
						<p>
                            Limited support, works on older versions without Apple Silicon
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Windows</s>
				</p>
				<ul>
					<li>
						<p>
                            Not natively supported.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Languages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    C
				</p>
				<ul>
					<li>
						<p>
                            Full support.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    C++
				</p>
				<ul>
					<li>
						<p>
                            Full support.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Odin
				</p>
				<ul>
					<li>
						<p>
                            Partial support, requires debug symbols and manual suppression files.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Rust
				</p>
				<ul>
					<li>
						<p>
                            Works, but may need 
                            <code>--tool=memcheck</code>
                            &nbsp;for leaks.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Other compiled languages
				</p>
				<ul>
					<li>
						<p>
                            Any language that compiles to native code can be analyzed but may need extra configuration.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How to use
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">valgrind --tool=massif ./your_program
massif-visualizer massif.out.*&nbsp;&nbsp;# GUI viewer
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Pros
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Shows peak memory usage and allocation trends.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="coderr-code-gdb-lldb-time-travel-debugging" >
    <code>rr</code>
    &nbsp;+ GDB/LLDB (Time-Travel Debugging)
</h3>
<ul>
	<li>
		<p>
            Records execution and lets you 
			<strong>
                rewind
			</strong>
            &nbsp;to see when memory was freed.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How to use
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">rr record ./your_program&nbsp;&nbsp; # Records execution
rr replay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Debug with GDB/LLDB
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Key commands
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">watch -l *ptr&nbsp;&nbsp;# Break on UAF access
backtrace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# See who freed memory
</code></pre>
<h3
	id="gdb-lldb-stack-frames" >
    GDB/LLDB Stack Frames
</h3>
<ul>
	<li>
		<p>
            Inspect the call stack and local variables.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Key commands
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">bt full&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show full backtrace with locals
info locals&nbsp;&nbsp;# List all local variables
</code></pre>
<h3
	id="dr-memory" >
    Dr. Memory
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://drmemory.org/" 
				class="external-link" 
				target="_blank" >
                Dr Memory
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://drmemory.org/page_download.html" 
				class="external-link" 
				target="_blank" >
                Download
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=YI_TqmQf6-8" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platforms
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Windows.
				</p>
			</li>
			<li>
				<p>
                    Linux.
				</p>
			</li>
			<li>
				<p>
                    macOS.
				</p>
				<ul>
					<li>
						<p>
                            Alpha.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="handles-instead-of-pointers" >
    Handles instead of Pointers
</h2>
<h3
	id="handlemap-or-hashmaps" >
    HandleMap or HashMaps?
</h3>
<ol>
	<li>
		<p>
            A handle_map_static.
		</p>
		<ul>
			<li>
				<p>
                    A handle is nothing more than an index while using a sparse array.
				</p>
			</li>
			<li>
				<p>
                    Super lightweight.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A 
            <code>map[int]Listener</code>
            , where each int is a &quot;handle.&quot;
		</p>
		<ul>
			<li>
				<p>
                    The int could be a random number, maybe obtained via Unix time.
				</p>
			</li>
		</ul>
	</li>
</ol>
<ul>
	<li>
		<p>
			<em>
                What‚Äôs the difference
			</em>
            ?
		</p>
		<ul>
			<li>
				<p>
                    HandleMap:
				</p>
				<ul>
					<li>
						<p>
                            Works really well when the object being stored is a pointer. It‚Äôs far safer.
						</p>
					</li>
					<li>
						<p
							class="line-emphasis" >
							<input
								type="checkbox" 
								disabled=""
>
                            Handle somehow requires it to also be stored inside the Listener.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    HashMap:
				</p>
				<ul>
					<li>
						<p>
                            Can be intrinsically lighter on memory.
						</p>
						<ul>
							<li>
								<p>
                                    Does not require the object stored in the HandleMap to contain a handle.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            No need to worry about static memory limitations.
						</p>
						<ul>
							<li>
								<p>
                                    The HashMap expands automatically.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Which to choose
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    HandleMap for storing pointers; always.
				</p>
			</li>
			<li>
				<p>
                    HashMap for non-pointers.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="articles" >
    Articles
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html" 
				class="external-link" 
				target="_blank" >
                Handles are the better pointers
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The article is very good.
				</p>
			</li>
			<li>
				<p>
                    It doesn‚Äôt show any code, but all concepts are explained and the advantages of the approach are clearly presented.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2020/06/21/the-ownership-semantics-flaw/" 
				class="external-link" 
				target="_blank" >
                The Ownership Semantic Flaw
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Important conclusion about OOP and Ownership Semantics (OS):
				</p>
				<ul>
					<li>
						<p>
                            In general, most hard problems 
							<em>
                                cannot
							</em>
                            &nbsp;be solved at compile time; because of this, adding more and more concepts to the type system of the language will not help without adding extra costs. This does not mean ownership semantics are bad but that they are not a solution for many problems in that domain.
						</p>
					</li>
					<li>
						<p>
                            A lot of the problems related to responsibility are better solved with forms of ‚Äúsubsystems‚Äù within programs which handle groups of ‚Äúthings‚Äù and give out 
							<strong>
                                handles
							</strong>
                            &nbsp;to the ‚Äúthing‚Äù instead of a direct reference.
						</p>
					</li>
					<li>
						<p>
                            This is related to the approach many people already use to bypass the borrow checker by using indices/handles.
						</p>
					</li>
					<li>
						<p>
                            Handles can contain a lot more information than a single number. A common approach is to store a generation number alongside the index in the handle. If a generation has expired, but the handle is used, the subsystem can return a dummy sentinel value and report an error.
						</p>
					</li>
					<li>
						<p>
                            Other approaches aim to reduce the need for ownership responsibility in the first place. By keeping data structures 
							<a
								href="https://en.wikipedia.org/wiki/Passive_data_structure" 
								class="external-link" 
								target="_blank" >
                                POD
							</a>
                            , trivially copyable, and with a useful zero value, you can rethink the problem and simplify code. This places more emphasis on the data and algorithms themselves rather than the relationships between objects and types.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Final conclusion of the article:
				</p>
				<ul>
					<li>
						<p>
                            The main argument is to demonstrate how OS and OOP both result in a &quot;(linear) value hierarchy of behavior, where the values act as agents.&quot;
						</p>
					</li>
					<li>
						<p>
                            Ownership semantics can be a useful tool for certain problems, but due to their underlying linear logic, they 
							<strong>
                                cannot
							</strong>
                            &nbsp;be used to express 
							<em>
                                non-linear
							</em>
                            &nbsp;problems, which leads people to try to bypass the concept entirely.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2025-07-03)
				</p>
				<ul>
					<li>
						<p>
                            I found the article very interesting.
						</p>
					</li>
					<li>
						<p>
                            I found it interesting how the use of handles was mentioned as something that could solve the problem and how it's used in Rust to work around linearity issues.
						</p>
					</li>
					<li>
						<p>
                            I don‚Äôt yet know the counterarguments to this Rust linearity problem, but if it‚Äôs really solved through some kind of handle trick, then it does seem like Rust hasn‚Äôt solved an important problem ‚Äî it just complicates things unnecessarily.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="libraries" >
    Libraries
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/karl-zylinski/odin-handle-map" 
				class="external-link" 
				target="_blank" >
                handle-map-odin
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Very interesting and quite simple as well.
				</p>
			</li>
			<li>
				<p>
                    From what I saw through ChatGPT, its code follows a very classical handle system structure.
				</p>
			</li>
			<li>
				<p>
                    Check the README to understand the best usage recommendations, considering virtual memory limitations for the web.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Questions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
								checked="">
                            Use of 
                            <code>$HT</code>
                            &nbsp;in the definition of a handle_map.
						</p>
						<ul>
							<li>
								<p>
                                    See the explanation in the example in 
                                    <a href="/studies/Low-Level Systems/Odin/Odin.html#parametric-polymorphism-parapoly">
                                    Odin#Parametric Polymorphism (Parapoly)
                                    </a>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="usage-examples" >
    Usage examples
</h3>
<ul>
	<li>
		<p>
            The sokol-gfx API is an example of a C API that uses handles instead of pointers for rendering resource objects (buffers, images, shaders, ‚Ä¶):
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/floooh/sokol#sokol_gfxh" 
						class="external-link" 
						target="_blank" >
                        sokol_gfx.h
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The Oryol Gfx module is a similar 3D API wrapper, but written in C++:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/floooh/oryol/tree/sokol-gfx/code/Modules/Gfx" 
						class="external-link" 
						target="_blank" >
                        Oryol Gfx Module
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The Oryol Animation extension module is a character animation system that keeps all its data in arrays:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/floooh/oryol-animation/tree/master/src/Anim" 
						class="external-link" 
						target="_blank" >
                        Oryol Anim Module
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="ownership-strategies-destruction-strategies" >
    Ownership Strategies / Destruction Strategies
</h2>
<ul>
	<li>
		<p>
            &quot;Ownership determines destruction strategy. The stronger the ownership, the simpler the destruction should be.&quot;
		</p>
	</li>
	<li>
		<p>
            The entity always owns the Object. Necessarily the Object should die when the entity dies.
		</p>
	</li>
</ul>
<h3
	id="motivation" >
    Motivation
</h3>
<h5
	id="disclaimer" >
    Disclaimer
</h5>
<ul>
	<li>
		<p>
            This analysis I'm making below is from a challenge I was facing in my Odin engine.
		</p>
	</li>
	<li>
		<p>
            It's more of a sketch of what was going on in my head at the time. Some things probably doesn't make much sense, unless in the proper context.
		</p>
	</li>
</ul>
<h5
	id="back-to-the-analysis" >
    Back to the analysis
</h5>
<ul>
	<li>
		<p>
            Annoying places that led me to think about the subject:
		</p>
		<ul>
			<li>
				<p>
                    bodies
				</p>
			</li>
			<li>
				<p>
                    layers.
				</p>
			</li>
			<li>
				<p>
                    tweens.
				</p>
			</li>
			<li>
				<p>
                    ~timers
				</p>
				<ul>
					<li>
						<p>
                            if I rework the system.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    world init / world deinit is very easy to forget.
				</p>
				<ul>
					<li>
						<p>
                            The 'struct-based lifetime aggregation' system helped a lot with this.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Post about the subject, focusing on the tween system:
		</p>
<pre><code class="language-odin" data-lang="odin">eng.tween(
&nbsp;&nbsp;&nbsp;&nbsp;value = &some_vector_inside_an_entity,
&nbsp;&nbsp;&nbsp;&nbsp;end = some_vector,
&nbsp;&nbsp;&nbsp;&nbsp;duration_s = 0.1,
&nbsp;&nbsp;&nbsp;&nbsp;on_end = proc(tween: ^eng.Tween) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// stuff
&nbsp;&nbsp;&nbsp;&nbsp;},
)
</code></pre>
		<ul>
			<li>
				<p>
                    This is how I call a tween. The only thing it needs to do for this tween to work is call 
                    <code>eng.tween_system_init()</code>
                    &nbsp;at the beginning of the game, 
                    <code>eng.tween_system_deinit()</code>
                    &nbsp;at the end of it, and poll 
                    <code>eng.tween_system_update(dt)</code>
                    &nbsp;every frame for the 
                    <code>tween_system</code>
                    &nbsp;to process every tween stored when calling 
                    <code>eng.tween(..)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    When a tween ends processing, it gets removed automatically by the 
                    <code>eng.tween_system_update(dt)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The problem is kind of obvious: if the entity dies, the tween has a reference to a pointer inside the entity and the system crashes; UAF.
				</p>
			</li>
			<li>
				<p>
                    I came up with 5 major ideas to solve this problem, but I'm not really happy with them, or I don't know if they are good practice:
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                1 -
							</strong>
                            &nbsp;The entity stores the tween or a handle to the tween, so when the entity dies, I can manually ask to remove the tween and everything is ok.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                2 -
							</strong>
                            &nbsp;The tween doesn't store a pointer to some information in the entity, but a handle to it.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                3 -
							</strong>
                            &nbsp;The 
                            <code>tween_system</code>
                            &nbsp;doesn't exist. The entity has a tween stored, and MANUALLY calls a new function called 
                            <code>tween_process(&the_entity_tween)</code>
                            &nbsp;every frame of the entity 
                            <code>update</code>
                            . The tween doesn't need to be destroyed, as it doesn't own the value pointer. The existence of the tween is tightly linked to the existence of the entity. Just stop calling 
                            <code>tween_update</code>
                            &nbsp;and you won't have a UAF.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4 -
							</strong>
                            &nbsp;The entity doesn't care about the existence of the tween and can die in peace. The tween knows when the entity died and removes &quot;bad tweens&quot; and never tries to access freed memory. This could be done through:
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4.1 -
							</strong>
                            &nbsp;The entity has a &quot;pointer to lifetime handle&quot; inside of it. When calling the tween, it passes this handle as an argument for the tween. Every time an object stores this handle, its internal counter goes up by 1. When the entity dies, it changes the handle state to 
                            <code>dead = true</code>
                            &nbsp;and subtracts 1 from the counter. The 
                            <code>eng.tween_system_update(dt)</code>
                            &nbsp;checks if the handle is 
                            <code>dead</code>
                            &nbsp;or not; if so, it frees the &quot;bad tween&quot; and subtracts 1 from the counter. You got the idea. The counter only serves as a way to analyze the memory on game deinit.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4.2 -
							</strong>
                            &nbsp;The entity has an &quot;event struct&quot;. When calling the tween, it passes a pointer to the event so the tween can register a function pointer to be called when the event is emitted; the content inside this function pointer would be the destructor for the tween. When the entity dies, it calls something like 
                            <code>event_emit(the_entity_destructor_event)</code>
                            , and every system that subscribed to it will be destroyed. This kinda reminds me a bit of RAII.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    My thoughts on each strategy:
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                1, 2 and 3:
							</strong>
                            &nbsp;3 is clearly the best in terms of safety, but the problem with all 3 is that it makes the entity aware of the existence of a tween. The tween needs to know how many tweens will be used at the same time beforehand, or use an array that will need to be destructed. This makes the API look less pleasing. So many systems could use a tween and it sucks that it would be just a simple plug-n-play. I wish I could call 
                            <code>tween(..)</code>
                            &nbsp;and be done with it; let the 
                            <code>tween_system</code>
                            &nbsp;handle the rest.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4.1 and 4.2:
							</strong>
                            &nbsp;They both sound a bit cheesy. The tween SHOULD die as the entity dies, as it has a pointer to it, but this strategy throws the responsibility to a 3rd party (a lifetime handle or event emitter) to manage the problem. This introduces a level of abstraction that I'm not too fond of.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Finally, if I were to choose, I'd go for the 
					<strong>
                        4.2
					</strong>
                    &nbsp;to clean the API, or go back to 
                    <code>3</code>
                    , if it ends up not being a good idea.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ideas" >
    Ideas
</h3>
<ol>
	<li>
		<p>
			<strong>
                The object is stored internally in the Entity
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
					<strong>
                        The Object doesn't have to worry about being destroyed, since no one outside the Entity references it
					</strong>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Access is intrinsically tied to the lifetime.
						</p>
					</li>
					<li>
						<p>
                            'Stateless' seems to be a word that defines this strategy.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Examples where I use this
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Timer system.
								</p>
								<ul>
									<li>
										<p>
                                            Need to advance time manually via 
                                            <code>timer_is_finished</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            In that case, I would do 
                                            <code>en.tween_update(^Tween, dt)</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    The dt is optional, like in the Timer case.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                For a Tween
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    The entity has a Tween_System
								</p>
								<ul>
									<li>
										<p>
                                            Basically to have an array instead of unitary values.
										</p>
									</li>
									<li>
										<p>
                                            Use a single update.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The entity has multiple Tweens
								</p>
								<ul>
									<li>
										<p>
                                            Requires that I know the maximum number of concurrent tweens I will have at any moment.
										</p>
									</li>
								</ul>
							</li>
						</ol>
						<ul>
							<li>
								<p>
                                    The Tween can still have on_enter and on_end functions, no problem.
								</p>
							</li>
							<li>
								<p>
                                    A Tween can be torn down and rebuilt however you want, so when a tween finishes I can create another tween immediately afterwards using the same Tween.
								</p>
							</li>
							<li>
								<p>
                                    The Tween never needs to be destroyed. It doesn't own anything.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        The Object must be destroyed manually during the Entity's destruction
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            When the Entity is destroyed, it calls the destruction of the Objects it owns.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Compared to &quot;The Object doesn't have to worry about being destroyed, since no one outside the Entity references it&quot;:
								</p>
								<ul>
									<li>
										<p>
                                            forgetting to update: no big deal.
										</p>
									</li>
									<li>
										<p>
                                            forgetting to destroy: memory leak and UAF.
										</p>
									</li>
									<li>
										<p>
                                            So this technique is less safe.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Examples where I use this
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Bodies / Body Wrappers system.
								</p>
								<ul>
									<li>
										<p>
                                            This system makes sense, since a Body 
											<strong>
                                                needs
											</strong>
                                            &nbsp;to be destroyed in Jolt anyway, so a destructor call is inevitable.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                For a Tween
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    The entity has a Tween_System
								</p>
								<ul>
									<li>
										<p>
                                            Basically to have an array instead of unitary values.
										</p>
									</li>
									<li>
										<p>
                                            Use a single update.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The entity has multiple Tweens
								</p>
								<ul>
									<li>
										<p>
                                            Requires that I know the maximum number of concurrent tweens I will have at any moment.
										</p>
									</li>
								</ul>
							</li>
						</ol>
						<ul>
							<li>
								<p>
                                    <code>eng.tween</code>
                                    &nbsp;returns a handle to the tween.
								</p>
							</li>
							<li>
								<p>
                                    This can be annoying for chaining tweens, having to always have a place to store the tween data.
								</p>
								<ul>
									<li>
										<p>
                                            In this case, I could implement a system where tween chaining happens without the need for on_end, via use of 
                                            <code>eng.tween_chain</code>
                                            , something like that.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The tween update is done automatically via 
                                    <code>eng.tween_update(dt)</code>
                                    , called directly by the Game Loop, each desired frame.
								</p>
							</li>
							<li>
								<p>
                                    Considering that a tween destroys itself automatically when finished, it can be weird to call the destruction of something that's already been destroyed.
								</p>
								<ul>
									<li>
										<p>
                                            <s>The tween might not destroy itself automatically, but that makes things a bit more annoying, increasing the verbosity of the tween callback to always destroy itself.</s>
										</p>
<pre><code class="language-odin" data-lang="odin">proc(tween: ^Tween) {
&nbsp;&nbsp;&nbsp;&nbsp;eng.tween_destroy(tween)
&nbsp;&nbsp;&nbsp;&nbsp;//or
&nbsp;&nbsp;&nbsp;&nbsp;eng.tween_destroy(tween.value)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if using a handle.
}
</code></pre>
										<ul>
											<li>
												<p>
                                                    This changes NOTHING. Explicitly destroying the tween in the callback still requires me to destroy it when destroying the entity. Nothing changes.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Use of handles
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The tween doesn't store a pointer to some information in the entity, but a handle to the information.
						</p>
					</li>
					<li>
						<p>
                            This means that the entity must have the handle stored, so when the entity dies, the handle is correctly removed.
						</p>
					</li>
					<li>
						<p>
                            The tween system then tries to tween the data, but when attempting to 
                            <code>get</code>
                            &nbsp;the information inside the handle, it realizes the handle is now dead and deletes the tween.
						</p>
					</li>
					<li>
						<p>
                            When calling the tween:
						</p>
						<ul>
							<li>
								<p>
                                    We need to pass the handle for the data, instead of the data; so no new argument is added.
								</p>
							</li>
							<li>
								<p>
                                    We 
									<em>
                                        maybe
									</em>
                                    &nbsp;need to pass the handle_map related to the handle.
								</p>
								<ul>
									<li>
										<p>
                                            An alternative is to use a global handle_map.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Disadvantages
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    I have to store a handle for every pointer I want to tween, which means duplicating the data.
								</p>
								<ul>
									<li>
										<p>
                                            I would have a value and a pointer to this value, wrapped around a handle.
										</p>
									</li>
									<li>
										<p>
                                            That's really weird.
										</p>
									</li>
									<li>
										<p>
                                            Another option would be to store the data somewhere else and just have the handle around for the entity, but this could be even weirder.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    A handle_map for 
                                    <code>rawptr</code>
                                    &nbsp;could be an annoyance for generic procedures, such as the tween_system.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                About the handle map
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    The handle_map has the same (or higher) lifetime as the tween system.
								</p>
								<ol>
									<li>
										<p>
                                            The handle_map is implicit, without having to pass it around:
										</p>
										<ul>
											<li>
												<p>
                                                    This means that a generic handle_map would have to be used, storing 
                                                    <code>rawptr</code>
                                                    .
												</p>
												<ul>
													<li>
														<p>
                                                            This could be an annoyance for the Tween system, as I wouldn't have many ways of checking if the data for the 
                                                            <code>value</code>
                                                            &nbsp;and 
                                                            <code>end</code>
                                                            &nbsp;is compatible with each other.
														</p>
													</li>
													<li>
														<p>
                                                            Overall, it's a bit annoying for generics.
														</p>
													</li>
												</ul>
											</li>
										</ul>
										<ol>
											<li>
												<p>
                                                    The handle_map is part of the game.
												</p>
												<ul>
													<li>
														<p>
                                                            ok.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>The handle_map is global</s>.
												</p>
												<ul>
													<li>
														<p>
                                                            I don't think anything outside the game would want to tween something.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>The handle_map is part of the scene</s>.
												</p>
												<ul>
													<li>
														<p>
                                                            When exiting the scene, the handle_map is cleared.
														</p>
													</li>
													<li>
														<p>
                                                            If the handle_map used by the tween_system is 
															<em>
                                                                exclusively
															</em>
                                                            &nbsp;the handle_map of the current scene, that means that we can't tween something during a scene change, as this means that the whole tween_system would be cleared on a scene deinit.
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            <s>The handle_map is explicit, having to pass it around</s>:
										</p>
										<ul>
											<li>
												<p>
                                                    This increases the argument for calling a tween by one, and also makes the tween store the handle_map, besides the handle.
												</p>
											</li>
											<li>
												<p>
                                                    The handle_map could be more specific, but this is not an advantage necessarily, as:
												</p>
												<ul>
													<li>
														<p>
                                                            Most of the data processed by the tween is different from each other; could be a f32, Vec2, int, etc.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    I don't see this strategy having any real advantage.
												</p>
											</li>
										</ul>
										<ol>
											<li>
												<p>
                                                    The handle_map is part of the scene.
												</p>
												<ul>
													<li>
														<p>
                                                            This would make the most sense, as the only reason for having an explicit handle_map is to have many options for handle_maps.
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
								<p>
                                    <s>The entity has a handle_map</s>.
								</p>
								<ul>
									<li>
										<p>
                                            If the entity dies, the handle_map dies as well, crashing the whole system and making the use of the handle pointless.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
					<li>
						<p>
							<em>
                                Advantages
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The entity doesn't need to store any tween. We can have any amount of tweens, without any problems.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Disadvantages
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Forgetting to 
                                    <code>remove</code>
                                    &nbsp;the handle will cause a UAF, as the tween system will be able to access the data that the handle represents.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<strong>
                        Game State
					</strong>
                    </s>:
				</p>
				<ul>
					<li>
						<p>
                            &quot;Carrying around a 
                            <code>Game_State</code>
                            &nbsp;object which stores all game data so deleting any resource goes through a single place.&quot;
						</p>
					</li>
					<li>
						<p>
                            The Game State stores the tweens and the entities.
						</p>
					</li>
					<li>
						<p>
                            The entity is destroyed through the Game State 
                            <code>game_state_del_entity(gs: ^Game_State, ent: Entity_Id)</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Which will also delete all data associated with that entity.
								</p>
							</li>
							<li>
								<p>
                                    It can remove its tween because it has access to 
                                    <code>gs</code>
                                    ; the entity needs to have an indicator of which tween belongs to the entity either way.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            My thinking:
						</p>
						<ul>
							<li>
								<p>
                                    &quot;The entity doesn't own anything&quot;
								</p>
								<ul>
									<li>
										<p>
                                            Idk if this is true. When the entity dies some other piece of data MUST die as well.
										</p>
									</li>
									<li>
										<p>
                                            It's a different way to think of ownership. The entity doesn't really own the tween, but the tween must die with the entity; so who owns the data? I mean, I can't say it doesn't have an owner, as that would imply that something like the GameState owns the tween, which isn't true as only destroying the data when deinitializing the Game State would cause a UAF.
										</p>
									</li>
									<li>
										<p>
                                            Seems like the entity and tween are tied together, but if you look the other way around, if a tween dies that doesn't imply that an entity should die.
										</p>
									</li>
									<li>
										<p>
                                            The entity clearly has a higher hierarchy than the tween when it comes to ownership, so I can safely say that the tween belongs to the entity.
										</p>
									</li>
									<li>
										<p>
                                            So, with that in mind, what justifies the tween being out of the entity? What good does it bring to the destruction of the tween?
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Sameness:
								</p>
								<ul>
									<li>
										<p>
                                            The entity needs to have a handle for the tween stored or the whole tween itself.
										</p>
										<ul>
											<li>
												<p>
                                                    Storing only a handle could be a little more problematic if the tween is not killed once the entity dies; but yet, that depends on how the fetch for the tweens is made in the 
                                                    <code>game_state_tweens :: proc(gs: Game_State) -&gt; []Tween</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Possible advantages:
								</p>
								<ul>
									<li>
										<p>
                                            Forgetting to clean up a tween will not cause a UAF, as the entity stored the tween and will take the tween with it when dying.
										</p>
										<ul>
											<li>
												<p>
                                                    This could cause a memory leak if the tween allocates memory in heap and we forget to clean it up, but it will not cause a crash.
												</p>
											</li>
											<li>
												<p>
                                                    THO, this is only possible due to the system being stateless.
												</p>
											</li>
											<li>
												<p>
                                                    This is also true for other strategies that store the tween inside the entity.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Possible disadvantages:
								</p>
								<ul>
									<li>
										<p>
                                            Same disadvantages of other strategies that have to store the tween or a handle to the tween in the entity:
										</p>
										<ul>
											<li>
												<p>
                                                    I need to know how many tweens I'll have upfront.
												</p>
											</li>
											<li>
												<p>
                                                    The call for a tween could be problematic. If I call a new tween using the same tween_handle or the same tween, while the tween is being used for some other tweening, then this could fail somehow; I would have to overwrite what I asked the tween to do, or just fail the call altogether and say it couldn't be made; this is terrible as it introduces error handling in a simple system.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Being stateless means that every frame is 
											<em>
                                                necessary
											</em>
                                            &nbsp;to fetch all tweens from everywhere in the system, to finally update each one of them.
										</p>
										<ul>
											<li>
												<p>
                                                    This is a problem when you consider that a tween could be anywhere, not only inside entities.
												</p>
											</li>
											<li>
												<p>
                                                    It could be a mess to look up these tweens.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Finally:
						</p>
						<ul>
							<li>
								<p>
                                    The entity still needs to store a reference to the tween, while also the entity needs to know upfront how many tweens it will use, etc.
								</p>
							</li>
							<li>
								<p>
                                    Even though your strategy could be used, it falls within the realm of the strategies 
									<strong>
                                        1
									</strong>
                                    &nbsp;and 
									<strong>
                                        3
									</strong>
                                    . I'm looking for a way that the entity doesn't care about the tweening. The tween could live in a general global space, being created freely, BUT still having its lifetime tied to the lifetime of a pointer the tween holds.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Some people tried to defend the strategy, but I still thought it was garbage and it doesn't deserve to be considered. It doesn't solve anything, keeps the problems of having to store the tweens internally and complicates the whole memory system a lot.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
            <s>
			<strong>
                The Object is stored in a global system
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            ANY pointer is a problematic pointer, since the lifetime of the pointer will always be shorter than the lifetime of the tween system. This requires extra ways to destroy the tween before the pointer stored inside the tween is used.
						</p>
					</li>
				</ul>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
					<strong>
                        Use of Events to destroy Objects
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The main characteristic of this system is that the destructor can be defined right when creating the Object, so you know 
							<em>
                                when
							</em>
                            &nbsp;it will be destroyed; that is, when the event is emitted.
						</p>
					</li>
					<li>
						<p>
							<em>
                                For tweens
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        Why I stopped using this for tweens
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            I had big lifetime problems across the whole game in the past, but after removing global variables this problem was greatly reduced, diminishing the arguments in favor of using events.
										</p>
									</li>
									<li>
										<p>
                                            An internal system greatly reduces the complexity of the problem, making it much easier to read and understand what's happening.
										</p>
									</li>
									<li>
										<p>
                                            The existence of a destructor for a tween is strange. The tween destroys itself on completion, causing the &quot;destructor&quot; 
											<strong>
                                                not to be called in 99% of cases
											</strong>
                                            . In the vast majority of cases, event listeners were registered in the destructor and unregistered without ever being used.
										</p>
										<ul>
											<li>
												<p>
                                                    The destructor was just an anti-crash system; its purpose was only to handle an exception where tweens still existed while the pointer of their custom_data no longer existed.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        After doing
									</em>
                                    :
								</p>
<pre><code class="language-odin" data-lang="odin">// tween()
eng.tween(
&nbsp;&nbsp;&nbsp;&nbsp;destructor = &personagem.destructor,
&nbsp;&nbsp;&nbsp;&nbsp;value = &personagem.arm3.pos_world,
&nbsp;&nbsp;&nbsp;&nbsp;end = arm_relative_target_trans_arm3.pos,
&nbsp;&nbsp;&nbsp;&nbsp;duration_s = 0.1,
&nbsp;&nbsp;&nbsp;&nbsp;custom_data = personagem,
&nbsp;&nbsp;&nbsp;&nbsp;on_end = proc(tween: ^eng.Tween) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;personagem := cast(^Personagem_User)tween.custom_data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;personagem.arm3.is_stepping = false
&nbsp;&nbsp;&nbsp;&nbsp;}
)

// Internal to tween()
ok: bool
tween.destructor_handle, ok = event_add_listener(destructor, wrap_procedure(tween_delete), rawptr(value))
if !ok {
&nbsp;&nbsp;&nbsp;&nbsp;log.errorf("%v(%v): Failed to add event listener.", loc.procedure, loc.line)
&nbsp;&nbsp;&nbsp;&nbsp;return nil
}
</code></pre>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Use of an external Lifetimes Manager system
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Use a Lifetime_Handle as an indicator if the entity was destroyed.
						</p>
					</li>
					<li>
						<p>
                            Each of the individual object systems checks that Lifetime_Handle and will destroy the Object if it notices that the handle was marked as 
                            <code>dead</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The check must be done in a loop; normally in the object's system loop.
						</p>
					</li>
					<li>
						<p>
                            This means it is intrinsically a 
							<em>
                                polling
							</em>
                            &nbsp;system.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    If the polling is not done, then the entity will never be destroyed.
								</p>
								<ul>
									<li>
										<p>
                                            This is a problem that happens every time the game closes: the Lifetime_Handle is marked as dead, but no final polling is done to destroy the objects.
										</p>
									</li>
									<li>
										<p>
                                            This can cause memory leaks.
										</p>
										<ul>
											<li>
												<p>
                                                    Although the Lifetime_Handles system can clean up the memory of each indicated thing, this system doesn't have enough information about how the destruction of each element should be performed. Besides, of course, that would be a pain to implement.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</li>
</ol>
<h3
	id="improvements-applied" >
    Improvements Applied
</h3>
<h5
	id="stage-1-clarity-in-the-definition-of-lifetimes" >
    Stage 1: Clarity in the definition of lifetimes
</h5>
<ul>
	<li>
		<p>
            &quot;Grouped element thinking and systems (n+1)&quot;.
		</p>
	</li>
	<li>
		<p>
            &quot;struct-based lifetime aggregation&quot;.
		</p>
		<ul>
			<li>
				<p>
                    It was the solution I used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Ideally I don't want to have any data stored in the global scope, except if .
		</p>
	</li>
	<li>
		<p>
            All data should belong to a struct that represents its lifetime.
		</p>
	</li>
	<li>
		<p>
			<em>
                What does this help with?
			</em>
		</p>
		<ul>
			<li>
				<p>
                    It gets closer to n+1
				</p>
			</li>
			<li>
				<p>
                    Helps not to forget about initializations and deinitalizations.
				</p>
			</li>
			<li>
				<p>
                    Makes some lifetimes explicit, making it harder to make UAF mistakes.
				</p>
			</li>
			<li>
				<p>
                    Makes it much easier to use arena allocators for those objects with the same lifetime.
				</p>
			</li>
			<li>
				<p>
                    I think it also makes explicit what has a 1-frame lifetime, for use in the temp allocator or another custom arena allocator.
				</p>
			</li>
			<li>
				<p>
                    This can be very useful when dealing with a low-level render API.
				</p>
			</li>
			<li>
				<p>
                    Overall: it seems to be an improvement in code clarity and quality.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Does this help the tween/external systems in any way?
			</em>
		</p>
		<ul>
			<li>
				<p>
                    I don't think so.
				</p>
			</li>
			<li>
				<p>
                    The storage of the data is done using another allocator, regardless.
				</p>
			</li>
			<li>
				<p>
                    The data stored in the system cannot use the same allocator as the entity, since the system should not die when the entity dies.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Post-change impressions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The system helps to visualize improper access problems, that's all.
				</p>
			</li>
			<li>
				<p>
                    In a nutshell, it's a way to stay aware of grouped lifetimes, it's &quot;grouped thinking&quot;.
				</p>
			</li>
			<li>
				<p>
                    Therefore it's ok, even if it might not be the 
					<em>
                        best
					</em>
                    &nbsp;way to visualize/handle the problem.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="stage-2-purity-of-functions-via-removal-of-global-variables-and-global-structs" >
    Stage 2: Purity of functions, via removal of global variables and global structs
</h5>
<ul>
	<li>
		<p>
            The answer about lifetimes lies in the absence of global variables or global structs.
		</p>
	</li>
	<li>
		<p>
			<em>
                Why I came up with this idea
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    When the lifetime of something ends, I wanted it to be impossible to access it.
				</p>
			</li>
			<li>
				<p>
                    This reminded me of Scopes, which do exactly that.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Notable improvements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Multithreading is safer.
				</p>
				<ul>
					<li>
						<p>
                            The net_connections thread doesn't have access to the game thread's content, since the game is on the worker_game stack.
						</p>
					</li>
					<li>
						<p>
                            This is the only big advantage in the separation between 
                            <code>global</code>
                            &nbsp;and 
                            <code>game</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    There's also a gain in function purity, of course.
								</p>
							</li>
							<li>
								<p>
                                    If the game didn't have one dedicated network thread, then 
                                    <code>game</code>
                                    &nbsp;would be 
									<em>
                                        basically
									</em>
                                    &nbsp;a 
                                    <code>global</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Even if 
                                    <code>game</code>
                                    &nbsp;is a global variable (like in the crypted core) I would still pass the variable as a function parameter (for sure), for purity, helping to clarify what the function uses.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    I liked the solution for RPCs and Jobs, surprisingly.
				</p>
				<ul>
					<li>
						<p>
                            The only thing done is passing the game as an extra arg in the context, via 
                            <code>context.user_ptr</code>
                            ; that's it.
						</p>
					</li>
					<li>
						<p>
                            Simple, easy to understand, without requiring changes to the RPC or Job code.
						</p>
						<ul>
							<li>
								<p>
                                    If it weren't for that, I would have to pass the game as a procedure arg, having to modify the RPC and Job code accordingly.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="strategies-for-handling-short-lived-memory" >
    Strategies for handling short lived memory
</h2>
<ol>
	<li>
		<p>
            The libraries do internal free.
		</p>
		<ol>
			<li>
				<p>
                    Using arenas with 
					<em>
                        scope guard
					</em>
                    :
				</p>
				<ol>
					<li>
						<p>
                            Shrinks itself:
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        When to shrink
									</em>
                                    :
								</p>
								<ol>
									<li>
										<p>
                                            Shrinks itself no matter what.
										</p>
										<ul>
											<li>
												<p>
                                                    More akin to something stack-based.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Shrinks itself if a condition is met, where it makes sense to free the memory; too much garbage was accumulated.
										</p>
										<ul>
											<li>
												<p>
													<strong>
                                                        Not
													</strong>
                                                    &nbsp;stack-based.
												</p>
											</li>
										</ul>
									</li>
								</ol>
							</li>
						</ul>
						<ol>
							<li>
								<p>
                                    Free last Memory Block from&nbsp;&nbsp;
                                    <code>vmem.Arena -&gt; .Growing</code>
                                    &nbsp;with 
                                    <code>vmem.Arena_Temp</code>
								</p>
								<ul>
									<li>
										<p>
                                            Seems to shrinks it self, just like the 
                                            <code>runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
													<em>
                                                        Tests
													</em>
                                                    :
												</p>
												<ul>
													<li>
														<p>
															<input
																type="checkbox" 
																disabled=""
																checked="">
                                                            
                                                            <code>arena_free_all()</code>
														</p>
														<ul>
															<li>
																<p>
                                                                    Correctly shrinks the arena.
																</p>
															</li>
														</ul>
													</li>
													<li>
														<p>
															<input
																type="checkbox" 
																disabled=""
																checked="">
                                                            
                                                            <code>ARENA_TEMP_GUARD()</code>
														</p>
														<ul>
															<li>
																<p>
                                                                    When wrapping the 
                                                                    <code>model_create</code>
                                                                    s with this guard, the memory seems to have the same behavior as 
                                                                    <code>arena_free_all</code>
                                                                    : spikes to 500mb, then reduce to 140~150mb after 3 secs.
																</p>
															</li>
														</ul>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Seems much cleaner than the 
                                            <code>runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD</code>
                                            .
										</p>
									</li>
									<li>
										<p>
											<input
												type="checkbox" 
												disabled=""
>
                                            I'm unsure about the call to 
                                            <code>release</code>
                                            ; seemed odd to me ON WINDOWS.
										</p>
										<ul>
											<li>
												<p>
                                                    Linux seems ok and intuitive.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Free last Memory Block from 
                                    <code>context.temp_allocator</code>
                                    &nbsp;with 
                                    <code>runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD</code>
								</p>
								<ul>
									<li>
										<p>
                                            IF used with 
                                            <code>runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD</code>
                                            , the 
                                            <code>context.temp_allocator</code>
                                            &nbsp;can shrink it self, apparently.
										</p>
										<ul>
											<li>
												<p>
													<em>
                                                        Tests
													</em>
                                                    :
												</p>
												<ul>
													<li>
														<p>
															<input
																type="checkbox" 
																disabled=""
																checked="">
                                                            
                                                            <code>runtime.DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD</code>
                                                            .
														</p>
														<ul>
															<li>
																<p>
																	<strong>
                                                                        Careful!!
																	</strong>
                                                                    :
																</p>
																<ul>
																	<li>
																		<p>
                                                                            If the 
                                                                            <code>context.temp_allocator</code>
                                                                            &nbsp;is wrapped with some other thing (tracking allocator or Tracy), then the guard is 
																			<strong>
                                                                                not
																			</strong>
                                                                            &nbsp;going to begin.
																		</p>
																		<ul>
																			<li>
																				<p>
                                                                                    The condition 
                                                                                    <code>context.temp_allocator.data == &global_default_temp_allocator_data</code>
                                                                                    &nbsp;fails.
																				</p>
																			</li>
																		</ul>
																	</li>
																</ul>
															</li>
														</ul>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            ~It seems kinda weird tho, as the 
                                            <code>Memory_Block</code>
                                            s are backed by the 
                                            <code>context.allocator</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    The memory blocks can be backed by a different allocator (currently I'm using the 
                                                    <code>_general_alloc</code>
                                                    , which is just a more explicit version of the 
                                                    <code>context.allocator</code>
                                                    )
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<em>
                                                Thoughts
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    Not a fan of this, as its behavior is really implicit with 
                                                    <code>context.temp_allocator</code>
                                                    , but..... every core lib uses this, so.... aaaaaa....
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>Rollback the offset from 
                                    <code>vmem.Arena -&gt; .Static</code>
                                    &nbsp;with 
                                    <code>vmem.arena_static_reset_to</code>
                                    &nbsp;+ shrink if a condition is met.</s>
								</p>
								<ul>
									<li>
										<p>
                                            I would have to implement a guard with this, so I can store the offset I have to rollback, 
											<em>
                                                just like
											</em>
                                            &nbsp;
                                            <code>mem.Arena_Temp_Memory</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            When calling 
                                            <code>vmem.arena_static_reset_to</code>
                                            , shrink if the condition is met.
										</p>
										<ul>
											<li>
												<p>
                                                    Greater than the minimum size, and 
                                                    <code>reserved - used</code>
                                                    &nbsp;is greater or equal to 
                                                    <code>sqrt(reserved)</code>
                                                    ; something like this.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            This seems to be reaaally similar to a 
                                            <code>vmem.Arena -&gt; Growing</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>
                                    <code>mem.Arena_Temp_Memory</code>
                                    &nbsp;(Rollback the original Arena offset) + shrink if a condition is met.</s>
								</p>
								<ul>
									<li>
										<p>
                                            When calling 
                                            <code>mem.end_arena_temp_memory</code>
                                            , shrink if the condition is met.
										</p>
										<ul>
											<li>
												<p>
                                                    Greater than the minimum size, and 
                                                    <code>reserved - used</code>
                                                    &nbsp;is greater or equal to 
                                                    <code>sqrt(reserved)</code>
                                                    ; something like this.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            I wouldn't use this one directly, as I'm using 
                                            <code>vmem.Arena</code>
                                            , not 
                                            <code>mem.Arena</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            This seems to be reaaally similar to a 
                                            <code>mem.Dynamic_Arena</code>
                                            , I think.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            Doesn't shrink itself:
						</p>
						<ol>
							<li>
								<p>
                                    Rollback the offset from 
                                    <code>vmem.Arena -&gt; .Static</code>
                                    &nbsp;with 
                                    <code>vmem.arena_static_reset_to</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            It doesn't shrink itself automatically on rollback.
										</p>
									</li>
									<li>
										<p>
                                            I would have to implement a guard with this, so I can store the offset I have to rollback, 
											<em>
                                                just like
											</em>
                                            &nbsp;
                                            <code>mem.Arena_Temp_Memory</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Starts to seem like a stack.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    ~
                                    <code>mem.Arena_Temp_Memory</code>
                                    &nbsp;(Rollback the original Arena offset)
								</p>
								<ul>
									<li>
										<p>
                                            It doesn't shrink itself automatically on rollback.
										</p>
									</li>
									<li>
										<p>
                                            The 
                                            <code>vmem.arena_static_reset_to</code>
                                            &nbsp;for 
                                            <code>vmem.Arena</code>
                                            &nbsp;seems more convenient.
										</p>
									</li>
									<li>
										<p>
                                            Starts to seem like a stack.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ol>
				<ul>
					<li>
						<p>
							<em>
                                Characteristics
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The user doesn't control the deallocations.
								</p>
							</li>
							<li>
								<p>
                                    More akin to something stack-based:
								</p>
								<ul>
									<li>
										<p>
                                            This strategy would place more 
											<em>
                                                guard
											</em>
                                            s internally, so this would enforce something more similar to a stack-based memory.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~General allocator, manually freeing after every alloc.
				</p>
				<ul>
					<li>
						<p>
                            This doesn't seem compatible with the concept of &quot;temp&quot; or &quot;garbage&quot;.
						</p>
					</li>
					<li>
						<p>
                            This is useful for something that lives for a undetermined amount of time, or not even in this case.
						</p>
						<ul>
							<li>
								<p>
                                    Even if spawning entities and deleting entities, an optimized arena could be used...
								</p>
							</li>
						</ul>
					</li>
				</ul>
				<ol>
					<li>
						<p>
                            <code>context.allocator</code>
                            .
						</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
		<p>
            The libraries don't do internal free.
		</p>
		<ol>
			<li>
				<p>
                    Using arenas with a 
					<em>
                        scope guard
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Same options as 'Scope thing internal'.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Characteristics
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The user controls the deallocation.
								</p>
								<ul>
									<li>
										<p>
											<em>
                                                guard
											</em>
                                            s are only placed by the user, not internally by libraries.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    When the user has access to the deallocation, it might be &quot;too late&quot;, as we had the memory spike either way, as there was just too much garbage to clean up.
								</p>
								<ul>
									<li>
										<p>
                                            The only way to optimize this is if the user deconstructs the library implementation and places the 
											<em>
                                                guard
											</em>
                                            &nbsp;in the places it sees a best fit.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<strong>
                                        Not
									</strong>
                                    &nbsp;stack-based.
								</p>
								<ul>
									<li>
										<p>
                                            Memory keeps existing until ending the 
											<em>
                                                guard
											</em>
                                            , not after the stack scope of something internal is ended.
										</p>
									</li>
									<li>
										<p>
                                            <s>&quot;Memory that doesn't make sense to exist, keeps existing until removed by the user&quot;.</s>
										</p>
										<ul>
											<li>
												<p>
                                                    This statement actually doesn't make sense as the scope is defined by the 
													<em>
                                                        guard
													</em>
                                                    , and not by the stack scope of the functions.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Using arenas without a 
					<em>
                        scope guard
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Characteristics
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Free arbitrary.
								</p>
							</li>
							<li>
								<p>
                                    The user chooses when to free the memory.
								</p>
							</li>
							<li>
								<p>
                                    When the user has access to the deallocation, it might be &quot;too late&quot;, as we had the memory spike either way, as there was just too much garbage to clean up.
								</p>
								<ul>
									<li>
										<p>
                                            The only way to optimize this is if the user deconstructs the library implementation and frees the arena in the places it sees a best fit.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
				<ol>
					<li>
						<p>
                            <code>_temp_alloc</code>
						</p>
						<ul>
							<li>
								<p>
                                    It's just 
									<em>
                                        my
									</em>
                                    &nbsp;version of the 
                                    <code>context.temp_allocator</code>
                                    , acting explicitly, instead of implicitly through the 
                                    <code>context</code>
                                    &nbsp;system.
								</p>
							</li>
							<li>
								<p>
                                    This fights against all libraries that uses the 
                                    <code>context.temp_allocator</code>
                                    &nbsp;implicitly, as both arenas would be doing the same thing; it's ugly.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>context.temp_allocator</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    It doesn't shrink it self.
								</p>
							</li>
							<li>
								<p>
                                    Huge spike because of this.
								</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
<h2
	id="garbage-collection" >
    Garbage Collection
</h2>
<h5
	id="automatic-reference-counting-arc" >
    Automatic Reference Counting (ARC)
</h5>
<ul>
	<li>
		<p>
            The object has a field that represents the object's count.
		</p>
	</li>
	<li>
		<p>
            Expensive.
		</p>
	</li>
	<li>
		<p>
            There are checks every time the object is modified.
		</p>
	</li>
	<li>
		<p>
            Cycles are problematic.
		</p>
	</li>
</ul>
<h5
	id="mark-and-sweep" >
    Mark and Sweep
</h5>
<ul>
	<li>
		<p>
            Has no problems with cycles.
		</p>
	</li>
	<li>
		<p>
            There's no need to check every time the object is modified, but the checks are done during the GC Pause, which is where the GC pauses the app to look for garbage.
		</p>
	</li>
</ul>
<h2
	id="initialization" >
    Initialization
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=xt1KNDmOYqA" 
				class="external-link" 
				target="_blank" >
                Casey - Against SmartPointers, RAII, Rust Borrow Checker; &quot;becoming the n+1 programmer&quot;
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/screenshot_2025-03-12_003018.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="strategies-n" >
    Strategies (n)
</h5>
<ul>
	<li>
		<p>
            RAII.
		</p>
	</li>
	<li>
		<p>
            Smart Pointers.
		</p>
	</li>
	<li>
		<p>
            new/delete malloc/free.
		</p>
	</li>
	<li>
		<p>
            try/catch.
		</p>
	</li>
	<li>
		<p>
            Rust borrow checker.
		</p>
	</li>
</ul>
<h5
	id="strategies-n1-grouped-element-thinking-and-systems" >
    Strategies (n+1) (Grouped element thinking and systems)
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
            The entity has a block allocator, where all memory used by the entity uses that block allocator.
		</p>
		<ul>
			<li>
				<p>
                    Sounds nice, but doesn't seem to solve the problem of memory being used in other systems.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            Every frame has an arena allocator. Everything that should exist for a single frame uses that allocator.
		</p>
		<ul>
			<li>
				<p>
                    Casey and Jon use this.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            Use PEAK memory to know what size the block should have.
		</p>
		<ul>
			<li>
				<p>
                    Very interesting.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="strategies-n2" >
    Strategies (n+2)
</h5>
<ul>
	<li>
		<p>
            ZII and Stubs as alternative ways of memory structure and error handling.
		</p>
	</li>
	<li>
		<p>
            Casey about Stubs:
		</p>
		<ul>
			<li>
				<p>
                    Stubs are just a block of zeroes.
				</p>
			</li>
			<li>
				<p>
                    &quot;If you failed to push something into the arena, you just get a Stub back, it's all zeroed&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;When something comes back, just produces a Stub instead of something real, and everything still works&quot;.
				</p>
			</li>
			<li>
				<p>
                    The code doesn't check if the struct is a Stub. The code just assumes the data is something you can use and uses it.
				</p>
			</li>
			<li>
				<p>
                    For example, when using a 0 Handle, I don't return null, I just return a zeroed entity.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Stubs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Stubs are minimal or fake implementations of functions, classes or modules, used mainly for testing, incremental development or simulating external dependencies.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;

// Real function not yet implemented, we use a temporary stub
int calcularImposto(float salario) {
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "[STUB] Function not yet implemented." &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;return 0; // Returns a fixed value to continue development
}

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;float salario = 5000;
&nbsp;&nbsp;&nbsp;&nbsp;int imposto = calcularImposto(salario);
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Calculated tax: " &lt;&lt; imposto &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</code></pre>
	</li>
</ul>
<h3
	id="zii-zero-initialization-is-initialization" >
    ZII (Zero Initialization Is Initialization)
</h3>
<h5
	id="comparing-to-raii" >
    Comparing to RAII
</h5>
<ul>
	<li>
		<p>
            Unlike RAII, ZII does not inherently imply resource ownership or cleanup in the destructor.
		</p>
	</li>
	<li>
		<p>
            It's about 
			<em>
                safe default values
			</em>
            , not lifecycle management.
		</p>
	</li>
	<li>
		<p>
            Both are part of the broader design goal of:
		</p>
		<ul>
			<li>
				<p>
                    Avoiding uninitialized or unsafe state.
				</p>
			</li>
			<li>
				<p>
                    Ensuring predictable object behavior starting at construction.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Because of this shared 
			<strong>
                initialization focus
			</strong>
            , they're often discussed together in contexts like:
		</p>
		<ul>
			<li>
				<p>
                    C++ safety idioms.
				</p>
			</li>
			<li>
				<p>
                    Codebases transitioning from C-style to C++.
				</p>
			</li>
			<li>
				<p>
                    Embedded/safety-critical environments.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Their conceptual scopes differ, but they 
			<strong>
                both leverage constructors
			</strong>
            &nbsp;to achieve safety and predictability, hence the mental association.
		</p>
	</li>
</ul>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            ZII is true by default for every system.
		</p>
	</li>
	<li>
		<p>
            The way you program is by letting zero always be an acceptable value.
		</p>
	</li>
	<li>
		<p>
            ZII is a principle that defends that variables be initialized to zero or default values as soon as they are created. This reduces the risk of accessing undefined values.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Main characteristics
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Prevents undefined behavior when accessing uninitialized variables.
				</p>
			</li>
			<li>
				<p>
                    Applicable mainly to primitive types and arrays.
				</p>
			</li>
			<li>
				<p>
                    Avoids hard-to-debug errors.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages of ZII
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reduces errors related to uninitialized values.
				</p>
			</li>
			<li>
				<p>
                    Ensures predictability in program behavior.
				</p>
			</li>
			<li>
				<p>
                    Useful for data structures and dynamically allocated memory.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<pre><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;

class Example {
public:
&nbsp;&nbsp;&nbsp;&nbsp;int x = 0;&nbsp;&nbsp;// Zero initialization
&nbsp;&nbsp;&nbsp;&nbsp;double y = 0.0;
};

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;Example e;
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "x: " &lt;&lt; e.x &lt;&lt; ", y: " &lt;&lt; e.y &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</code></pre>
<pre><code class="language-cpp" data-lang="cpp">int arr[10] = {};&nbsp;&nbsp;// All elements are initialized to 0
</code></pre>
<h3
	id="raii-resource-acquisition-is-initialization" >
    RAII (Resource Acquisition Is Initialization)
</h3>
<h5
	id="about-and-meaning" >
    About and Meaning
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=LlZWqkCMdfk" 
				class="external-link" 
				target="_blank" >
                Bjarne Stroustrup - &quot;RAII is the best thing the language has&quot;
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Constructors and Destructors pairs is the best feature implemented in the language&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;Sometimes this comes out in the name of RAII&quot;.
				</p>
				<ul>
					<li>
						<p>
                            &quot;Not the greatest name I've ever heard&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The phrase 
			<strong>
                ‚ÄúResource Acquisition Is Initialization‚Äù
			</strong>
            &nbsp;emphasizes that:
		</p>
		<ul>
			<li>
				<p>
                    Acquiring a resource happens at the same time the object is initialized (constructed).
				</p>
			</li>
			<li>
				<p>
                    This ties the resource's lifetime to the object‚Äôs lifetime.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Why Destruction Is Implied
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Although destruction is not named, it's 
					<em>
                        implied by C++'s object lifetime rules
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If the resource is acquired during initialization, and the object controls the resource.
						</p>
					</li>
					<li>
						<p>
                            Then releasing it must naturally occur when the object is destroyed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    C++ deterministic destruction ensures that destructors are called at the end of scope, enabling automatic cleanup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Therefore, RAII relies on both construction and destruction, even if the name only mentions the construction side.
		</p>
	</li>
</ul>
<h5
	id="principles" >
    Principles
</h5>
<ul>
	<li>
		<p>
            Associates resource acquisition (like memory, file handles, mutexes, etc.) with the 
			<em>
                construction
			</em>
            &nbsp;of an object, and resource release with its 
			<em>
                destruction
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Scope-Based Lifetime
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In C++, objects declared with automatic storage duration (i.e., local stack variables) are automatically destroyed when they go out of scope.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Destructor Role
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The destructor is the mechanism used to release resources. Since C++ guarantees that destructors of local objects are called when the scope exits (either normally or via exception), this ensures deterministic cleanup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Why it &quot;implies&quot; a destructor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    For RAII to work, a resource-managing object must reliably release its resource.
				</p>
			</li>
			<li>
				<p>
                    C++ destructors are guaranteed to be called when the object‚Äôs scope ends.
				</p>
			</li>
			<li>
				<p>
                    Therefore, RAII relies on this guarantee, and the destructor becomes the point where the resource is released.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=LU62nNsigjs" 
				class="external-link" 
				target="_blank" >
                Demonstration of RAII in 
                <code>unique_ptr</code>
                &nbsp;and 
                <code>mutex_guard</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's all about scope.
				</p>
			</li>
			<li>
				<p>
                    Exiting the scope calls a function automatically.
				</p>
			</li>
			<li>
				<p>
                    That's it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

class FileHandler {
private:
&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream file;
public:
&nbsp;&nbsp;&nbsp;&nbsp;FileHandler(const std::string& filename) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.open(filename);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!file.is_open()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("Failed to open the file.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;~FileHandler() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.close();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;void write(const std::string& text) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file &lt;&lt; text &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;}
};

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileHandler fh("test.txt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fh.write("RAII ensures the file is closed.");
&nbsp;&nbsp;&nbsp;&nbsp;} catch (const std::exception& e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// The FileHandler destructor closes the file automatically.
&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</code></pre>
<h5
	id="negative-points" >
    Negative points
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=bJUnCXEIie0" 
				class="external-link" 
				target="_blank" >
                RAII in C++ and comparison with Odin
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Odin is soooo much better, wow.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Makes you allocate and deallocate simple things individually.
		</p>
	</li>
	<li>
		<p>
            Sometimes you want to be explicit about things and just free a bunch of things at once.
		</p>
		<ul>
			<li>
				<p>
                    In C++ that would require you to not use the language as it was intended in some ways.
				</p>
			</li>
			<li>
				<p>
                    In C++ you have to accept the complexity of RAII.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=OP_w_oEU1Wk" 
				class="external-link" 
				target="_blank" >
                Casey Muratori - RAII
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Automatic destructors make you think about failure and error handling in a bad way.
				</p>
			</li>
			<li>
				<p>
                    Unwinding the object through a destructor is not going to make the error go away. The error needs to be handled depending on the circumstance.
				</p>
			</li>
			<li>
				<p>
                    You need to think about failures and program around it.
				</p>
			</li>
			<li>
				<p>
                    In RAII you spend a lot of time writing code to handle failures that will never happen, but the same errors blow up.
				</p>
			</li>
			<li>
				<p>
                    RAII doesn't solve the problem they needed to solve.
				</p>
			</li>
			<li>
				<p>
                    Some people criticized his quote, for not making a distinction between RAII and error handling.
				</p>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Low-Level Systems/Odin/Odin.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Low-Level Systems/CPU/CPU.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-10-21 .&nbsp;&nbsp;2026-01-21 üöÄ
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#virtual-memory" >
                            Virtual Memory
						</a>
						<ul>
							<li>
								<a
									href="#os-pages" >
                                    OS Pages
								</a>
							</li>
							<li>
								<a
									href="#chunk" >
                                    Chunk
								</a>
							</li>
							<li>
								<a
									href="#virtual-memory-mapping" >
                                    Virtual Memory Mapping
								</a>
							</li>
							<li>
								<a
									href="#process" >
                                    Process
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#os-memory-on-windows" >
                            OS: Memory on Windows
						</a>
						<ul>
							<li>
								<a
									href="#process-address-space-management" >
                                    Process Address Space Management
								</a>
							</li>
							<li>
								<a
									href="#task-manager-windows" >
                                    Task Manager (Windows)
								</a>
							</li>
							<li>
								<a
									href="#process-explorer-windows" >
                                    Process Explorer (Windows)
								</a>
							</li>
							<li>
								<a
									href="#vmmap-windows" >
                                    ~VMMap (Windows)
								</a>
							</li>
							<li>
								<a
									href="#windbg-windows" >
                                    WinDbg (Windows)
								</a>
							</li>
							<li>
								<a
									href="#get-process-windows" >
                                    Get-Process (Windows)
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory-alignment" >
                            Memory Alignment
						</a>
						<ul>
							<li>
								<a
									href="#why-to-align" >
                                    Why to align
								</a>
							</li>
							<li>
								<a
									href="#memory-access" >
                                    Memory Access
								</a>
							</li>
							<li>
								<a
									href="#size" >
                                    Size
								</a>
							</li>
							<li>
								<a
									href="#offset" >
                                    Offset
								</a>
							</li>
							<li>
								<a
									href="#stride" >
                                    Stride
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#address" >
                            Address
						</a>
						<ul>
							<li>
								<a
									href="#alignment" >
                                    Alignment
								</a>
							</li>
							<li>
								<a
									href="#std140-and-std430" >
                                    std140 and std430
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#allocators" >
                            Allocators
						</a>
						<ul>
							<li>
								<a
									href="#types-of-allocators" >
                                    Types of Allocators
								</a>
							</li>
							<li>
								<a
									href="#making-your-own-allocator" >
                                    Making your own allocator
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#tools-memory-analysis" >
                            Tools: Memory Analysis
						</a>
						<ul>
							<li>
								<a
									href="#asan-address-sanitizer" >
                                    ASan (Address Sanitizer)
								</a>
							</li>
							<li>
								<a
									href="#valgrind-massif-visualizer" >
                                    Valgrind + massif-visualizer
								</a>
							</li>
							<li>
								<a
									href="#coderr-code-gdb-lldb-time-travel-debugging" >
                                    <code>rr</code> + GDB/LLDB (Time-Travel Debugging)
								</a>
							</li>
							<li>
								<a
									href="#gdb-lldb-stack-frames" >
                                    GDB/LLDB Stack Frames
								</a>
							</li>
							<li>
								<a
									href="#dr-memory" >
                                    Dr. Memory
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#handles-instead-of-pointers" >
                            Handles instead of Pointers
						</a>
						<ul>
							<li>
								<a
									href="#handlemap-or-hashmaps" >
                                    HandleMap or HashMaps?
								</a>
							</li>
							<li>
								<a
									href="#articles" >
                                    Articles
								</a>
							</li>
							<li>
								<a
									href="#libraries" >
                                    Libraries
								</a>
							</li>
							<li>
								<a
									href="#usage-examples" >
                                    Usage examples
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#ownership-strategies-destruction-strategies" >
                            Ownership Strategies / Destruction Strategies
						</a>
						<ul>
							<li>
								<a
									href="#motivation" >
                                    Motivation
								</a>
							</li>
							<li>
								<a
									href="#ideas" >
                                    Ideas
								</a>
							</li>
							<li>
								<a
									href="#improvements-applied" >
                                    Improvements Applied
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#strategies-for-handling-short-lived-memory" >
                            Strategies for handling short lived memory
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#garbage-collection" >
                            Garbage Collection
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#initialization" >
                            Initialization
						</a>
						<ul>
							<li>
								<a
									href="#zii-zero-initialization-is-initialization" >
                                    ZII (Zero Initialization Is Initialization)
								</a>
							</li>
							<li>
								<a
									href="#raii-resource-acquisition-is-initialization" >
                                    RAII (Resource Acquisition Is Initialization)
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.05320.js" >
		</script>
	</body>
</html>
