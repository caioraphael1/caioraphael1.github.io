<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.88482.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
>
					<summary>
                        Vulkan
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                Samples
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                Core
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                Render Loop
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                Synchronization and Cache Control
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                Command Buffers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                Pipelines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                Compute Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                Resources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                Depth
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                Mapping Data to Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                Memory Allocation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                HDR Support
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                Profiling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                Mobile
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                VR
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                Video Decoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                SPIR-V
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                Web
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Render Engineering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                Graphics APIs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                Shader Languages
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                Choosing the Space to compute Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                BSDF (Bidirectional Scattering Distribution Function)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                Material
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                Direct Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                Shadows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                Skybox / Skydome
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                Transparency
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                Global Illumination / Indirect Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                Global Illumination - Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                Global Illumination - Discarded Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                Lightmaps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                Post-Processing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                Anti-Aliasing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                Light Path / Rendering Method
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                Optimization Techniques
							</a>
							<ul>
								<li>
									<a
										href="#shader-branching" >
                                        Shader Branching
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#azdo-approach-zero-driver-overhead" >
                                        AZDO (Approach Zero Driver Overhead)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#instancing" >
                                        Instancing
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#scene-management" >
                                        Scene Management
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#culling" >
                                        Culling
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#cluster" >
                                        Cluster
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#lod-mipmap" >
                                        LOD, MipMap
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#image-formats" >
                                        Image Formats
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#dynamic-resolution" >
                                        Dynamic Resolution
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#tiling-based-vrs-nanite" >
                                        Tiling-based / VRS / Nanite
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#software-based-rasterization" >
                                        Software Based Rasterization
									</a>
								</li>
							</ul>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Graphics and Shaders
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                Sources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                Math, Linear Algebra
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                Spaces, Transformations and Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                Common Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                Shaders
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GLSL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                Storage Qualifiers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                Layout Qualifiers
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GPU
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                Execution Building Blocks
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                Specialized units &amp; instructions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                Cache
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                GPU VA (Virtual Address)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                Tiled-GPUs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Slang
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang-slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Font Rendering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                Text Processing Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                Formats
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                Libs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                Fonts
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        OpenGL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Optimization Techniques
						</h1>
						<p>
							<time
								datetime="2025-07-03" >
                                ðŸ•’ Created: 2025-07-03
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h3
	id="shader-branching" >
    Shader Branching
</h3>
<ul>
	<li>
		<p>
            Math is faster than branching with control flow.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250728154219.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250728154233.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250728154245.png" width="300" >
            .
		</p>
	</li>
</ul>
<h3
	id="azdo-approach-zero-driver-overhead" >
    AZDO (Approach Zero Driver Overhead)
</h3>
<h5
	id="motivation" >
    Motivation
</h5>
<ul>
	<li>
		<p>
            GPUs have orders of magnitude higher performance than CPU on data-parallel algorithms. Rendering is almost all data parallel algorithms.
		</p>
	</li>
	<li>
		<p>
            With the GPU deciding its own work, latencies are minimized as there is no roundtrip from CPU to GPU and back.
		</p>
	</li>
	<li>
		<p>
            Frees up the CPU from a lot of work which can now be used on other things.
		</p>
	</li>
	<li>
		<p>
            Repeated small 
            <code>vkCmdBindVertexBuffers</code>
            /
            <code>vkCmdBindIndexBuffer</code>
            &nbsp;and 
            <code>vkCmdDrawIndexed</code>
            &nbsp;calls force the driver to record many small draw commands (and possibly do relocations or check memory), which is expensive.
		</p>
	</li>
	<li>
		<p>
            Many small state changes cause the driver to update internal tables, validate, or patch commands â€” thatâ€™s CPU work and cannot be avoided without batching.
		</p>
	</li>
	<li>
		<p>
            Different drivers / GPUs behave differently. Some drivers do more CPU work per bind/draw and will be worse in this pattern.
		</p>
	</li>
	<li>
		<p>
            Query commands from a GPU buffer. This has two significant advantages:
		</p>
		<ul>
			<li>
				<p>
                    Draw calls can be generated from the GPU (such as in a &quot;compute shader&quot;), and
				</p>
			</li>
			<li>
				<p>
                    An array of draw calls can be called at once, reducing command buffer overhead
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="optimizations" >
    Optimizations
</h5>
<ul>
	<li>
		<p>
            Batch 
            <code>vkCmdDrawIndexed</code>
            : Multi-draw Indirect.
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdDrawIndexedIndirect</code>
                    &nbsp;/ multi-draw indirect to let GPU consume a small indirect buffer with many draws in one driver call.
				</p>
			</li>
			<li>
				<p>
                    Avoid binding vertex/index buffer per draw â€” bind the quad vertex/index buffer once and supply per-instance data via instance attributes or an SSBO.
				</p>
			</li>
			<li>
				<p>
                    See 
                    <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#drawing-commands">
                    Vulkan.md#Drawing Commands
                    </a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Batch 
            <code>vkCmdPushConstants</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    (2025-12-01) From 5 push calls taking 7.65us, to now 1 push call taking 3.08us.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Batch 
            <code>vkCmdBindDescriptorSets</code>
            : using Bindless.
		</p>
		<ul>
			<li>
				<p>
                    Bindless Textures.
				</p>
			</li>
			<li>
				<p>
                    Bindless / descriptor indexing (
                    <code>VK_EXT_descriptor_indexing</code>
                    &nbsp;/ descriptor arrays with update-after-bind) so you can bind a single descriptor set containing all textures and index into it in the shader using the per-instance texture index. This removes the per-draw 
                    <code>vkCmdBindDescriptorSets</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Binding a descriptor set per draw is heavy if each set references different image samplers; the driver must ensure the GPU has correct descriptors ready (or patch them).
				</p>
			</li>
			<li>
				<p>
                    See 
                    <a href="/studies/Graphics Programming/Vulkan/Vulkan.html#descriptor-sets">
                    Vulkan.md#Descriptor Sets
                    </a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Batch textures: Texture Atlas.
		</p>
		<ul>
			<li>
				<p>
                    Pack multiple textures into atlases or a texture array and index into them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Pre-record commands.
		</p>
		<ul>
			<li>
				<p>
                    Useful if CPU-bound.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            GPU Culling:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909090901.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    All culling passes would be a single pass, for performance reasons.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h6
	id="etc" >
    Etc
</h6>
<ul>
	<li>
		<p
			class="line-emphasis" >
            Once we have a renderer where everything is stored in big GPU buffers, and we donâ€™t use PushConstants or descriptor sets per object, we are ready to go with a GPU-driven-renderer.
		</p>
	</li>
	<li>
		<p>
            Because it takes its parameters from a buffer, it is possible to use compute shaders to write into these buffers and do culling or LOD selection in compute shaders. Doing culling this way is one of the simplest and most performant ways of doing culling. Due to the power of the GPU you can easily expect to cull more than a million objects in less than half a millisecond. Normal scenes donâ€™t tend to go as far. In more advanced pipelines like the one in Dragon Age or Rainbow Six, they go one step further and also cull individual triangles from the meshes. They do that by writing an output Index Buffer with the surviving triangles and using indirect to draw that.
		</p>
	</li>
	<li>
		<p>
            Store the matrices for all loaded objects into a big SSBO. In GPU driven pipelines, we also want to store more data, such as material ID and cull bounds.
		</p>
	</li>
	<li>
		<p>
            GPU driven pipelines work best when the amount of binds is as limited as possible. Best case scenario is to do a extremely minimal amount of BindVertexBuffer, BindIndexBuffer, BindPipeline, and BindDescriptorSet calls.
		</p>
	</li>
	<li>
		<p>
            The less drawcalls you use to render your scene, the better, as modern GPUs are really big and have a big ramp up/ramp down time. Big modern GPUs love when you give them massive amounts of work on each drawcall, as that way they can ramp up to 100% usage.
		</p>
	</li>
	<li>
		<p>
            The new Unreal 5 engine relies heavily on compute shaders for software rasterization.
		</p>
	</li>
	<li>
		<p>
            The first thing is to go all in on object data in GPU buffers. Per-object PushConstants are removed, per-object dynamic uniform buffers are removed, and everything is replaced by ObjectBuffer where we store the object matrix and we index into it from the shader.
		</p>
	</li>
	<li>
		<p>
            A Batch is a set of objects that matches material and mesh. Each batch will be rendered with one DrawIndirect call that does instanced drawing. Each mesh pass (forward pass, shadow pass, others) contains an array of batches which it will use for rendering.
		</p>
	</li>
	<li>
		<p>
            When starting the frame, we sync the objects that are on each mesh pass into a buffer. This buffer will be an array of ObjectID + BatchID. The BatchID maps directly as an index into the batch array of the mesh-pass.
		</p>
	</li>
	<li>
		<p>
            Once we have that buffer uploaded and synced, we execute a compute shader that performs the culling.
		</p>
	</li>
	<li>
		<p>
            For every object in said array of ObjectID + BatchID pairs, we access the object data in the ObjectBuffer using the ObjectID, and check if it is visible. If itâ€™s visible, we use the BatchID index to insert the draw into the Batches array, which contains the draw indirect calls, increasing the instance count. We also write it into the indirection buffer that maps from the instance ID of each batch into the ObjectID.
		</p>
	</li>
	<li>
		<p>
            With that done, on the CPU side we iterate over the batches in a mesh pass, and execute each of them in order, making sure to bind each batch pipeline and material descriptor set. The gpu will then use the parameters it just wrote into from the culling pass to render the objects.
		</p>
	</li>
	<li>
		<p>
            Buffer Storage.
		</p>
	</li>
	<li>
		<p>
            Direct State Access.
		</p>
	</li>
	<li>
		<p>
            Shader Buffer Load.
		</p>
	</li>
	<li>
		<p>
            UBO &amp; SSBO.
		</p>
	</li>
	<li>
		<p>
            and more...
		</p>
	</li>
</ul>
<h5
	id="avoid-being-vertex-bound" >
    Avoid being Vertex Bound
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250909101124.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    TBDR: Tile Based Deferred Renderer GPU.
				</p>
			</li>
			<li>
				<p>
                    TBIR: Tile Based Immediate Renderer GPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/zeux/meshoptimizer" 
				class="external-link" 
				target="_blank" >
                MeshOptimizer
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    When a GPU renders triangle meshes, various stages of the GPU pipeline have to process vertex and index data. The efficiency of these stages depends on the data you feed to them; this library provides algorithms to help optimize meshes for these stages, as well as algorithms to reduce the mesh complexity and storage overhead.
				</p>
			</li>
			<li>
				<p>
                    The library provides a C and C++ interface for all algorithms; you can use it from C/C++ or from other languages via FFI (such as P/Invoke).
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/zeux/meshoptimizer/blob/master/gltf/README.html" 
						class="internal-link" 
						target="_self" >
                        gltfack
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            gltfpack is a tool that can automatically optimize glTF files to reduce the download size and improve loading and rendering speed.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="instancing" >
    Instancing
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=Y0Ko0kvwfgA" 
				class="external-link" 
				target="_blank" >
                Billboard Grass and GPU Instancing
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Rendering millions of grass&quot;.
				</p>
			</li>
			<li>
				<p>
                    The video is cool.
				</p>
			</li>
			<li>
				<p>
                    We'll use a compute shader.
				</p>
			</li>
			<li>
				<p>
                    We take the thread id of our compute shader thread. For a 300 square space, we can do 
                    <code>position = id.xy - 150</code>
                    &nbsp;so it's centered over the origin.
				</p>
			</li>
			<li>
				<p>
                    As our grass is made of 3 meshes (3 billboard quads), this will result in 3 separate instancing calls.
				</p>
			</li>
			<li>
				<p>
                    To increase the density of grasses in the square space, we can 
                    <code>position *= (1 / density)</code>
                    ; I'll use 
                    <code>density = 2</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    For this example, I'll render 2,160,000 triangles at 523 fps.
				</p>
				<ul>
					<li>
						<p>
                            Screen: 1289x621
						</p>
					</li>
					<li>
						<p>
                            Setup? GTX 1660, apparently.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To get randomness, I did 
                    <code>pos.xz += noise()</code>
                    &nbsp;for the position and 
                    <code>position.y += noise()</code>
                    &nbsp;to get a different height (higher grass will be grouped with higher grasses).
				</p>
				<ul>
					<li>
						<p>
                            This uses a simplex noise.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To animate, I'll just skew the top 2 vertices of the mesh in the vertex shader.
				</p>
				<ul>
					<li>
						<p>
                            {9:20} Explanation of what was done to randomize the intensity and frequency of grass sway movement.
						</p>
					</li>
					<li>
						<p>
                            Hash the instance id to get a hash id. With the hash_id, we check against a threshold to know if we perform a fast cosine or a slow cosine.
						</p>
					</li>
					<li>
						<p>
                            The grass height changed the cosine frequency.
						</p>
					</li>
					<li>
						<p>
                            Etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To get the grass displaced with the terrain displacement, we convert the space coordinates of our grass to uv coordinates, such as they can sample the same height map as the terrain mesh.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250907212336.png" width="500" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    I also introduced a color variance in the grass, by making the tip of the grass more yellow, to show aging of the grass. This affects higher grasses a bit more, as they are older.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=jw00MbIJcrk" 
						class="external-link" 
						target="_blank" >
                        Continuation: Grass Mesh instead of Billboarding and GPU Culling with the Scan and Compact technique
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The video is the continuation of the previous one, changing: noise texture for wind simulation and optimizations with frustum culling with Scan and Compact.
						</p>
						<ul>
							<li>
								<p>
                                    The video is cool, though it has less content than the previous one.
								</p>
							</li>
							<li>
								<p>
                                    It shows no implementation or formulas.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Noise is used for wind movement, more sophisticated using a noise texture with oscillations ~etc, different from the randomization used in the billboarding solution.
						</p>
					</li>
					<li>
						<p>
                            Then, optimization is discussed. This new technique is 
							<em>
                                much
							</em>
                            &nbsp;heavier than the previous, so he uses Frustum Culling to optimize what is actually instanced.
						</p>
						<ul>
							<li>
								<p>
                                    This frustum culling apparently is harder to do, because it requires the Compute Buffer array to be contiguous.
								</p>
							</li>
							<li>
								<p>
                                    He uses: Scan and Compact.
								</p>
							</li>
							<li>
								<p>
                                    The array is scanned, marked for modification and a new array is created with the desired elements.
								</p>
							</li>
							<li>
								<p>
                                    For this, a Prefix Sum Scan is used to define which entries form the new array.
								</p>
								<ul>
									<li>
										<p>
                                            This is not explained.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=PNvlqsXdQic" 
						class="external-link" 
						target="_blank" >
                        Continuation: LOD with Chunking
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The video is quite short, only talking about the optimization below. It shows no implementation or formulas.
						</p>
					</li>
					<li>
						<p>
                            It uses a mesh with lower poly count when the object's distance to the camera is greater than a threshold.
						</p>
					</li>
					<li>
						<p>
                            The justification for using chunking is to help with LOD.
						</p>
						<ul>
							<li>
								<p>
                                    Apparently LOD would be done in chunks (?) which would reduce the need for having a second position buffer, specific to the low-poly LOD mesh.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The final performance is 110fps, with 408MB of VRAM.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="scene-management" >
    Scene Management
</h3>
<ul>
	<li>
		<p>
            Google &quot;GPU Scene Management&quot; for some ideas - BVH, scene graph, ECS on the GPU, etc.
		</p>
	</li>
	<li>
		<p>
            It has a concept of an &quot;object&quot; that users can place in the world.
		</p>
	</li>
	<li>
		<p>
            These objects can contain multiple meshes and have a bounding box.
		</p>
	</li>
	<li>
		<p>
            There is hierarchy (refer to flecs queries on how to do it efficiently).
		</p>
	</li>
	<li>
		<p>
            Streaming is handled.
		</p>
	</li>
</ul>
<h3
	id="culling" >
    Culling
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250909090542.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909090657.png" width="500" >
            .
		</p>
	</li>
</ul>
<h5
	id="culling" >
    Culling
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/occlusion_culling.html" 
				class="external-link" 
				target="_blank" >
                Godot 4 - Occlusion Culling
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.nickdarnell.com/hierarchical-z-buffer-occlusion-culling/" 
				class="external-link" 
				target="_blank" >
                Hierarchical Z-Buffer Culling - 2010
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="http://www.selfshadow.com/talks/rwc_gdc2010_v1.pdf" 
						class="external-link" 
						target="_blank" >
                        Rendering with Conviction - GDC 2010
					</a>
                    &nbsp;presented this technique, which was first introduced on Siggraph 2008.
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://www.nickdarnell.com/hierarchical-z-buffer-occlusion-culling-shadows/" 
						class="external-link" 
						target="_blank" >
                        Hierarchical Z-Buffer Culling - Shadows - 2010
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://www.nickdarnell.com/hierarchical-z-buffer-occlusion-culling-generating-occlusion-volumes/" 
						class="external-link" 
						target="_blank" >
                        Hierarchical Z-Buffer Culling - Generating Occlusion Volumes - 2011
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="frustum-culling" >
    Frustum Culling
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=vJrfcI_bMTA" 
				class="external-link" 
				target="_blank" >
                Frustum Culling - Kohi Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_7s7hH_HtSQ" 
				class="external-link" 
				target="_blank" >
                Tessellation Shader with LOD, Frustum Culling in the Geometry Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The video is pretty cool, but shows absolutely no code or formulas. It's only a theoretical discussion of the techniques.
				</p>
			</li>
			<li>
				<p>
                    Creating geometry in the tessellation shader is better than passing the mesh on the GPU.
				</p>
				<ul>
					<li>
						<p>
                            Data communication between CPU and GPU will always be the bottleneck.
						</p>
					</li>
					<li>
						<p>
                            This is not that precise, as the performance can actually be worse.
						</p>
					</li>
					<li>
						<p>
                            The 
							<strong>
                                real
							</strong>
                            &nbsp;performance gain comes from tessellating based on the distance of the object, by using LOD; if it's far away, tessellate less.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The Frustum Culling is based on the bounding box of the mesh, but as the mesh is too big, we are always rendering every triangle of the mesh, even for triangles we don't see.
				</p>
			</li>
			<li>
				<p>
                    The Geometry Shader can finalize the geometry, as well as culling the triangles we don't need.
				</p>
			</li>
			<li>
				<p>
                    This technique is usually used for terrain, as it's displaced by a height map.
				</p>
			</li>
			<li>
				<p
					class="line-emphasis" >
                    For characters, you would use different models with different poly count, rendering the correct one based on the distance to the camera.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                CPU Frustum Culling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The way this works is that we transform each of the 8 corners of the mesh-space bounding box into screen space, using the object matrix and view-projection matrix. From those, we find the screen-space box bounds, and we check if that box is inside the clip-space view. This way of calculating bounds is on the slow side compared to other formulas, and can have false-positives where it thinks objects are visible when they aren't. All the functions have different tradeoffs, and this one was selected for code simplicity and parallels with the functions we are doing on the vertex shaders.
				</p>
			</li>
			<li>
				<p>
                    We check for visibility before drawing.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">bool is_visible(const RenderObject& obj, const glm::mat4& viewproj) {
&nbsp;&nbsp;&nbsp;&nbsp;std::array&lt;glm::vec3, 8&gt; corners {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { 1, 1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { 1, 1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { 1, -1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { 1, -1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { -1, 1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { -1, 1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { -1, -1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 { -1, -1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;glm::mat4 matrix = viewproj * obj.transform;

&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 min = { 1.5, 1.5, 1.5 };
&nbsp;&nbsp;&nbsp;&nbsp;glm::vec3 max = { -1.5, -1.5, -1.5 };

&nbsp;&nbsp;&nbsp;&nbsp;for (int c = 0; c &lt; 8; c++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// project each corner into clip space
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::vec4 v = matrix * glm::vec4(obj.bounds.origin + (corners[c] * obj.bounds.extents), 1.f);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// perspective correction
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.x = v.x / v.w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.y = v.y / v.w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.z = v.z / v.w;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = glm::min(glm::vec3 { v.x, v.y, v.z }, min);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max = glm::max(glm::vec3 { v.x, v.y, v.z }, max);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// check the clip space box is within the view
&nbsp;&nbsp;&nbsp;&nbsp;if (min.z &gt; 1.f || max.z &lt; 0.f || min.x &gt; 1.f || max.x &lt; -1.f || min.y &gt; 1.f || max.y &lt; -1.f) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
	<li>
		<p>
            VkGuide:
		</p>
		<ul>
			<li>
				<p>
                    The instanceBuffer is AllocatedBuffer
                    <GPUInstance>
                    &nbsp;instanceBuffer; from the last article. It stores ObjectID + BatchID (draw indirect ID)
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">bool IsVisible(uint objectIndex)
{
&nbsp;&nbsp;&nbsp;&nbsp;//grab sphere cull data from the object buffer
&nbsp;&nbsp;&nbsp;&nbsp;vec4 sphereBounds = objectBuffer.objects[objectIndex].spherebounds;

&nbsp;&nbsp;&nbsp;&nbsp;vec3 center = sphereBounds.xyz;
&nbsp;&nbsp;&nbsp;&nbsp;center = (cullData.view * vec4(center,1.f)).xyz;
&nbsp;&nbsp;&nbsp;&nbsp;float radius = sphereBounds.w;

&nbsp;&nbsp;&nbsp;&nbsp;bool visible = true;

&nbsp;&nbsp;&nbsp;&nbsp;//frustrum culling
&nbsp;&nbsp;&nbsp;&nbsp;visible = visible && center.z * cullData.frustum[1] - abs(center.x) * cullData.frustum[0] &gt; -radius;
&nbsp;&nbsp;&nbsp;&nbsp;visible = visible && center.z * cullData.frustum[3] - abs(center.y) * cullData.frustum[2] &gt; -radius;

&nbsp;&nbsp;&nbsp;&nbsp;if(cullData.distCull != 0)
&nbsp;&nbsp;&nbsp;&nbsp;{// the near/far plane culling uses camera space Z directly
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visible = visible && center.z + radius &gt; cullData.znear && center.z - radius &lt; cullData.zfar;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;visible = visible || cullData.cullingEnabled == 0;

&nbsp;&nbsp;&nbsp;&nbsp;return visible;
}

void main()
{
&nbsp;&nbsp;&nbsp;&nbsp;uint gID = gl_GlobalInvocationID.x;
&nbsp;&nbsp;&nbsp;&nbsp;if(gID &lt; cullData.drawCount)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//grab object ID from the buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint objectID = instanceBuffer.Instances[gID].objectID;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//check if object is visible
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool visible&nbsp;&nbsp;= IsVisible(objectID);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(visible)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the index of the draw to insert into
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint batchIndex = instanceBuffer.Instances[gID].batchID;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//atomic-add to +1 on the number of instances of that draw command
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint countIndex = atomicAdd(drawBuffer.Draws[batchIndex].instanceCount,1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//write the object ID into the instance buffer that maps from gl_instanceID into ObjectID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint instanceIndex = drawBuffer.Draws[batchIndex].firstInstance + countIndex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finalInstanceBuffer.IDs[instanceIndex] = objectID;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
</ul>
<h3
	id="cluster" >
    Cluster
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250909085504.png" width="550" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Each cluster is up to 64 vertices / 124 triangles.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909105901.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909105849.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922140902.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922140841.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922140820.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/VK_HUAWEI_cluster_culling_shader/clusterculling.html" 
				class="external-link" 
				target="_blank" >
                Cluster Culling Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_HUAWEI_cluster_culling_shader</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="meshoptimizer" >
    MeshOptimizer
</h5>
<ul>
	<li>
		<p>
            From what I saw in the code below, it seems to have several interesting optimizations.
		</p>
	</li>
	<li>
		<p>
            <code>ogldev\DemoLITION\Framework\Source\core_model.cpp:492</code>
		</p>
	</li>
	<li>
		<p>
            It's the last thing done when creating the mesh.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">template&lt;typename VertexType&gt;
void CoreModel::OptimizeMesh(int MeshIndex, std::vector&lt;uint&gt;&Indices, std::vector&lt;VertexType&gt;&Vertices, std::vector&lt;VertexType&gt;& AllVertices)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t NumIndices = Indices.size();
&nbsp;&nbsp;&nbsp;&nbsp;size_t NumVertices = Vertices.size();
&nbsp;&nbsp;&nbsp;&nbsp;// Create a remap table
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned int&gt; remap(NumIndices);
&nbsp;&nbsp;&nbsp;&nbsp;size_t OptVertexCount = meshopt_generateVertexRemap(remap.data(), Â  Â // dst addr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indices.data(), Â // src indices
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumIndices, Â  Â  Â // ...and size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vertices.data(), // src vertices
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumVertices, Â  Â  // ...and size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(VertexType)); // stride
&nbsp;&nbsp;&nbsp;&nbsp;// Allocate a local index/vertex arrays
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;uint&gt; OptIndices;
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;VertexType&gt; OptVertices;
&nbsp;&nbsp;&nbsp;&nbsp;OptIndices.resize(NumIndices);
&nbsp;&nbsp;&nbsp;&nbsp;OptVertices.resize(OptVertexCount);
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #1: remove duplicate vertices&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_remapIndexBuffer(OptIndices.data(), Indices.data(), NumIndices, remap.data());
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_remapVertexBuffer(OptVertices.data(), Vertices.data(), NumVertices, sizeof(VertexType), remap.data());
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #2: improve the locality of the vertices
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_optimizeVertexCache(OptIndices.data(), OptIndices.data(), NumIndices, OptVertexCount);
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #3: reduce pixel overdraw
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_optimizeOverdraw(OptIndices.data(), OptIndices.data(), NumIndices, &(OptVertices[0].Position.x), OptVertexCount, sizeof(VertexType), 1.05f);
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #4: optimize access to the vertex buffer
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_optimizeVertexFetch(OptVertices.data(), OptIndices.data(), NumIndices, OptVertices.data(), OptVertexCount, sizeof(VertexType));
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #5: create a simplified version of the model
&nbsp;&nbsp;&nbsp;&nbsp;float Threshold = 1.0f;
&nbsp;&nbsp;&nbsp;&nbsp;size_t TargetIndexCount = (size_t)(NumIndices * Threshold);
&nbsp;&nbsp;&nbsp;&nbsp;float TargetError = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned int&gt; SimplifiedIndices(OptIndices.size());
&nbsp;&nbsp;&nbsp;&nbsp;size_t OptIndexCount = meshopt_simplify(SimplifiedIndices.data(), OptIndices.data(), NumIndices,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&OptVertices[0].Position.x, OptVertexCount, sizeof(VertexType), TargetIndexCount, TargetError);
&nbsp;&nbsp;&nbsp;&nbsp;static int num_indices = 0;
&nbsp;&nbsp;&nbsp;&nbsp;num_indices += (int)NumIndices;
&nbsp;&nbsp;&nbsp;&nbsp;static int opt_indices = 0;
&nbsp;&nbsp;&nbsp;&nbsp;opt_indices += (int)OptIndexCount;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Num indices %d\n", num_indices);
&nbsp;&nbsp;&nbsp;&nbsp;//printf("Target num indices %d\n", TargetIndexCount);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Optimized number of indices %d\n", opt_indices);
&nbsp;&nbsp;&nbsp;&nbsp;SimplifiedIndices.resize(OptIndexCount);
&nbsp;&nbsp;&nbsp;&nbsp;// Concatenate the local arrays into the class attributes arrays
&nbsp;&nbsp;&nbsp;&nbsp;m_Indices.insert(m_Indices.end(), SimplifiedIndices.begin(), SimplifiedIndices.end());
&nbsp;&nbsp;&nbsp;&nbsp;AllVertices.insert(AllVertices.end(), OptVertices.begin(), OptVertices.end());
&nbsp;&nbsp;&nbsp;&nbsp;m_Meshes[MeshIndex].NumIndices = (uint)OptIndexCount;
}
</code></pre>
<h5
	id="draco" >
    Draco
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/google/draco" 
				class="external-link" 
				target="_blank" >
                Draco
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Draco is a library for compressing and decompressing 3D geometric meshes and point clouds. It is intended to improve the storage and transmission of 3D graphics.
		</p>
	</li>
	<li>
		<p>
            By Google.
		</p>
	</li>
</ul>
<h3
	id="lod-mipmap" >
    LOD, MipMap
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=PNvlqsXdQic" 
				class="external-link" 
				target="_blank" >
                Chunking, LODs and Fog
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=qMCOX3m-R28" 
				class="external-link" 
				target="_blank" >
                Mipmap, Minification Filters, Magnification Filters
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    MIP: Latin for 'Much In Little'.
				</p>
				<ul>
					<li>
						<p>
                            It downsizes the image in powers of two.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {5:31 -&gt; 10:10}
				</p>
				<ul>
					<li>
						<p>
                            Explanation of the Filters
						</p>
					</li>
					<li>
						<p>
                            Minification:
						</p>
						<ul>
							<li>
								<p>
                                    Nearest, Linear, Linear_mipmap_nearest and Linear_mipmap_linear.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Magnification:
						</p>
						<ul>
							<li>
								<p>
                                    Nearest, Linear.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {10:14 -&gt; end}
				</p>
				<ul>
					<li>
						<p>
                            GLSL implementation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {19:29 -&gt; 21:02}
				</p>
				<ul>
					<li>
						<p>
                            Differences in the Filters.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/8OtOFN17jxM?si=slwMb0_K0gcraqao&t=68" 
				class="external-link" 
				target="_blank" >
                Mipmap and Trilinear Filter
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Trilinear Filtering: Linear interpolate between levels of mipmapping.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="http://the-witness.net/news/2010/09/computing-alpha-mipmaps/" 
				class="external-link" 
				target="_blank" >
                Improving the mipmap for transparent objects at a distance (foliage) - The Witness
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The idea is very simple: modify the content of the mipmap during its creation.
				</p>
			</li>
			<li>
				<p>
                    It shows a formula to manipulate the final result to get a better look.
				</p>
			</li>
			<li>
				<p>
                    That's all.
				</p>
			</li>
			<li>
				<p>
                    I found it interesting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Using the full chain
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Advantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Hardware trilinear/anisotropic filtering benefits from having all levels available â†’ better quality when minifying.
						</p>
					</li>
					<li>
						<p>
                            Simplifies generation: many GPU/CPU mip-generation algorithms assume a full chain.
						</p>
					</li>
					<li>
						<p>
                            No runtime fallback behavior to a coarser final level.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Disadvantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Increased memory and upload cost (sum of sizes of all mip levels).
						</p>
					</li>
					<li>
						<p>
                            Extra work to generate or upload every level (unless you generate on GPU).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lower mip levels (1 &lt; mipLevels &lt; max)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Advantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Lower memory and upload cost.
						</p>
					</li>
					<li>
						<p>
                            Useful for streaming: allocate only top K levels now, stream lower-res later.
						</p>
					</li>
					<li>
						<p>
                            Useful for textures that will rarely be minified (UI element, near camera).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Disadvantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Potentially poorer filtering when the sampler requests a lower LOD; sampling will effectively use the last available level (coarser detail).
						</p>
					</li>
					<li>
						<p>
                            If you plan to GPU-blit/generate mips, you must still have declared the target number of levels ahead of generation.
						</p>
					</li>
					<li>
						<p>
                            Some runtime tools/algorithms may assume a full chain and need adaptation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="mesh-lod" >
    Mesh: LOD
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/mesh_lod.html" 
				class="external-link" 
				target="_blank" >
                Godot 4 - Mesh LOD
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Godot provides a way to automatically generate less detailed meshes for LOD usage on import, then use those LOD meshes when needed automatically. This is completely transparent to the user. The 
					<a
						href="https://meshoptimizer.org/" 
						class="external-link" 
						target="_blank" >
                        meshoptimizer
					</a>
                    &nbsp;library is used for LOD mesh generation behind the scenes.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="image-formats" >
    Image Formats
</h3>
<h5
	id="ktx2" >
    KTX2
</h5>
<ul>
	<li>
		<p>
            Is a container file format for storing texture data optimized for GPU usage. Itâ€™s designed to work efficiently with modern graphics APIs like Vulkan, OpenGL, and DirectX.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/tutorial/latest/15_GLTF_KTX2_Migration.html#_understanding_ktx2" 
				class="external-link" 
				target="_blank" >
                KTX2 vs PNG
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://ktxviewer.com/" 
				class="external-link" 
				target="_blank" >
                KTX Viewer Online
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="dynamic-resolution" >
    Dynamic Resolution
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250909101707.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909101740.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909101805.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909101851.png" width="500" >
            .
		</p>
	</li>
</ul>
<h3
	id="tiling-based-vrs-nanite" >
    Tiling-based / VRS / Nanite
</h3>
<h5
	id="variable-rate-shading-vrs" >
    Variable Rate Shading (VRS)
</h5>
<ul>
	<li>
		<p>
            With VRS you can specify different sampling rates for different parts of the screen. This can be used to optimize performance for either adapting the shading rate to the content, or for adapting the shading rate for things like foveated rendering in VR, where you only need full shading rate at the center of the viewport.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=ES9799W6eMI" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=FzMZq8B1SEM" 
				class="external-link" 
				target="_blank" >
                VRS - Wicked Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://wickedengine.net/2020/09/variable-rate-shading-first-impressions/" 
				class="external-link" 
				target="_blank" >
                VRS First Impressions - Wicked Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            VRS seems to work better with Forward than Deferred Rendering.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/variable_rate_shading.html" 
				class="external-link" 
				target="_blank" >
                Godot 4 - VRS
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="tiling-post-processing" >
    Tiling Post-Processing
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2020/01/tile-based-optimization-for-post-processing/" 
				class="external-link" 
				target="_blank" >
                Tiled Based Optimization for Post-Processing - Wicked Engine
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="nanite" >
    Nanite
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=M00DGjAP-mU" 
				class="external-link" 
				target="_blank" >
                Comparing Nanite to LODs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Baz - Nanite is still a deferred renderer, but I 
			<em>
                don't
			</em>
            &nbsp;think Forward or Deferred Renderer is the right choice.
		</p>
	</li>
	<li>
        <img src="assets/image_20250909095458.png" width="650" >

	</li>
	<li>
		<p>
            <img src="assets/image_20250909101431.png" width="500" >
            .
		</p>
	</li>
</ul>
<h3
	id="software-based-rasterization" >
    Software Based Rasterization
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://research.nvidia.com/publication/2011-08_high-performance-software-rasterization-gpus" 
				class="external-link" 
				target="_blank" >
                High-Performance Software Rasterization on GPUs
			</a>
            &nbsp;by Laine and Karras.
		</p>
		<ul>
			<li>
				<p>
                    That paper describes an all-compute rendering pipeline for the traditional 3D triangle workload. The architecture calls for sorting in the middle of the pipeline, so that in the early stage of the pipeline, triangles can be processed in arbitrary order to maximally exploit parallelism, but the output render still correctly applies the triangles in order.
				</p>
			</li>
			<li>
				<p>
                    In 3D rendering, you can almost get away with unsorted rendering, relying on Z-buffering to decide a winning fragment, but that would result in â€œZ-fightingâ€ artifacts and also cause problems for semitransparent fragments.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Goals
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Our endeavor has multiple goals. First, we want to establish a firm data point of the performance of a state-of-the-art GPU software rasterizer compared to the hardware pipeline. We maintain that only a careful experiment will reveal the performance difference, as without an actual implementation there are too many unknown costs. Second, constructing a purely software-based graphics pipeline opens the opportunity to augment it with various extensions that are impossible or infeasible to fit in the hardware pipeline (without hardware modifications, that is). For example, programmable ROP calculations, trivial non-linear rasterization (e.g., [Gascuel et al. 2008]), fragment merging [Fatahalianet al. 2010], stochastic rasterization [Akenine-MÂ¨oller et al. 2007] with decoupled sampling [Ragan-Kelley et al. 2011], etc., could be implemented as part of the programmable pipeline. Thirdly, by identifying the hot spots in our software pipeline, we hope to illuminate future hardware that would be better suited for fully programmable graphics. The complexity and versatility of the hardware graphics pipeline does not come without costs in design and testing. In an ideal situation, just a few hardware features targeted at accelerating software-based graphics would be enough to obtain decent performance, and the remaining gap would be closed by faster time-to-market and reduced design costs.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                2D
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://raphlinus.github.io/rust/graphics/gpu/2020/06/12/sort-middle.html" 
						class="external-link" 
						target="_blank" >
                        Sort-middle architecture - Raph Levien
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Not so easy to understand.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://raphlinus.github.io/rust/graphics/gpu/2020/06/13/fast-2d-rendering.html" 
						class="external-link" 
						target="_blank" >
                        Fast 2D rendering - Raph Levien
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Not so easy to understand.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-02-01 ðŸš€
			</footer>
		</div>
		<script
			src="/static/studies.88482.js" >
		</script>
	</body>
</html>
