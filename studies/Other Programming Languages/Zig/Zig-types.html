<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.61297.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
>
					<summary>
                        Rust
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-installation.html" >
                                Installation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-cargo.html" >
                                Cargo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-debug.html" >
                                Debug
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-imports.html" >
                                Imports
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-symbols.html" >
                                Symbols
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-keywords.html" >
                                Keywords
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-operations.html" >
                                Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-control-flow.html" >
                                Control Flow
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-types.html" >
                                Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-strings.html" >
                                Strings
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-tuples.html" >
                                Tuples
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-arrays.html" >
                                Arrays
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-vectors.html" >
                                Vectors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-hash-maps.html" >
                                Hash Maps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-functions.html" >
                                Functions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-structs.html" >
                                Structs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-traits.html" >
                                Traits
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-enums.html" >
                                Enums
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-options.html" >
                                Options
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-result.html" >
                                Result
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-match.html" >
                                Match
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-iterator.html" >
                                Iterator
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Zig
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-impressions.html" >
                                Impressions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-installation.html" >
                                Installation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-build.html" >
                                Build
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Other Programming Languages/Zig/Zig-types.html" >
                                Types
							</a>
							<ul>
								<li>
									<a
										href="#casting" >
                                        Casting
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#primitives" >
                                        Primitives
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#generics" >
                                        Generics
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#tuples" >
                                        Tuples
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#arrays" >
                                        Arrays
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#vectors" >
                                        Vectors
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#strings" >
                                        Strings
									</a>
									<ul>
										<li>
											<a
												href="#sentinel-termination" >
                                                Sentinel Termination
											</a>
										</li>
									</ul>
								</li>
								<li>
									<a
										href="#hashmaps" >
                                        HashMaps
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#enums-codeenum-code" >
                                        Enums (<code>enum {}</code>)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#unions" >
                                        Unions
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#structs-codet-code" >
                                        Structs (<code>T{}</code>)
									</a>
									<ul>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-error-handling.html" >
                                Error Handling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-memory-allocators.html" >
                                Memory: Allocators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-threads.html" >
                                Threads
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-file-system.html" >
                                File System
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-others.html" >
                                Others
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Go
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go-overview.html" >
                                Overview
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go-goroutines.html" >
                                Goroutines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go-godot.html" >
                                Godot
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        C++
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-building.html" >
                                Building
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-explanations.html" >
                                Explanations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++-gamedev.html" >
                                GameDev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        CSharp
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp-explanations.html" >
                                Explanations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Lua
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-functions.html" >
                                Functions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-table.html" >
                                Table
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-metatables.html" >
                                Metatables
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-control-flows.html" >
                                Control Flows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-modules.html" >
                                Modules
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Nim
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Swift
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-setup.html" >
                                Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-nullability.html" >
                                Nullability
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-error-handling.html" >
                                Error Handling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-operations.html" >
                                Operations
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-control-flow.html" >
                                Control Flow
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-types.html" >
                                Types
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-functions.html" >
                                Functions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-enums.html" >
                                Enums
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift-structs-and-classes.html" >
                                Structs and Classes
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Python
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-basics.html" >
                                Basics
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-network.html" >
                                Network
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-matplotlib-graphs.html" >
                                Matplotlib (Graphs)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python-pyinstaller-create-exe.html" >
                                PyInstaller (Create .exe)
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Haxe
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Kotlin
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin-syntax.html" >
                                Syntax
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin-game-dev.html" >
                                Game Dev
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Java
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java-about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Types
						</h1>
						<p>
							<time
								datetime="2025-01-09" >
                                ðŸ•’ Created: 2025-01-09
							</time>
							<time
								datetime="2026-01-23" >
                                | Updated: 2026-01-23
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h3
	id="casting" >
    Casting
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Explicit-Casts" 
				class="external-link" 
				target="_blank" >
                Casting
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.lagerdata.com/articles/an-intro-to-zigs-integer-casting-for-c-programmers" 
				class="external-link" 
				target="_blank" >
                Casting
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="prtcast" >
    @prtCast
</h5>
<ul>
	<li>
		<p>
            We can use 
            <code>@ptrCast</code>
            &nbsp;to create a new variable that points to the same location but as a different type.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

const User = struct {
&nbsp;&nbsp;id: u32,
&nbsp;&nbsp;name: []const u8,
};

const Node = struct {
&nbsp;&nbsp;next: ?*Node,
};

pub fn main() !void {
&nbsp;&nbsp;var user1 = User{.id = 1, .name = "Leto"};
&nbsp;&nbsp;const node1: *Node = @ptrCast(&user1);
&nbsp;&nbsp;node1.next = null;
&nbsp;&nbsp;std.debug.print("{}\n", .{node1});
}
</code></pre>
		<ul>
			<li>
				<p>
                    This code not only compiles, but it also runs. Compiling and running are two distinct aspects we must consider. The code compiles because we told the compiler it was ok to treat the memory as a 
                    <code>*Node</code>
                    . 
                    <code>@ptrCast</code>
                    &nbsp;isn't changing the memory at runtime, it's forcing the compiler to see the memory as a 
                    <code>*Node</code>
                    . In this case, the code runs because there are some truths we can rely on that make it so the memory used to represent a 
                    <code>User</code>
                    &nbsp;can safely be used to represent a 
                    <code>Node</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex2
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

const User = struct {
&nbsp;&nbsp;id: u32,
&nbsp;&nbsp;name: []const u8,
};

const Node = struct {
&nbsp;&nbsp;next: ?*Node,
};

pub fn main() !void {
&nbsp;&nbsp;var node1 = Node{.next = null};
&nbsp;&nbsp;const user: *User = @ptrCast(&node1);

&nbsp;&nbsp;std.debug.print("Id: {d}\n", .{user.id});
&nbsp;&nbsp;std.debug.print("Name: {d}\n", .{user.name});
}
</code></pre>
		<ul>
			<li>
				<p>
                    Now we're creating a 
                    <code>Node</code>
                    &nbsp;and telling the compiler to see the underlying memory as a 
                    <code>User</code>
                    . Again, this code compiles. But what happens when we try to run it? You'll probably get the same thing I did: 
                    <code>Id: 0</code>
                    &nbsp;followed by a segfault.
				</p>
			</li>
			<li>
				<p>
                    Why does it work one way but not the other? Consider the size of a 
                    <code>Node</code>
                    &nbsp;and the size of a 
                    <code>User</code>
                    :
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
pub fn main() !void {
&nbsp;&nbsp;std.debug.print("Node: {d}&nbsp;&nbsp; User: {d}\n", .{@sizeOf(Node), @sizeOf(User)});
}
</code></pre>
		<ul>
			<li>
				<p>
                    Assuming you're on a modern platform, you'll likely see: 
                    <code>Node: 8 User: 24</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This highlights the power and 
					<strong>
                        danger
					</strong>
                    &nbsp;of 
                    <code>@ptrCast</code>
                    : it's obvious that the memory underlying a 
                    <code>Node</code>
                    &nbsp;isn't big enough to represent a whole 
                    <code>User</code>
                    , but 
                    <code>@ptrCast</code>
                    &nbsp;forces the compiler to proceed as though it can.
				</p>
			</li>
			<li>
				<p>
                    But size constraints aren't the only issue. Let's go back to our original example and add 2 more lines at the end:
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

const User = struct {
&nbsp;&nbsp;id: u32,
&nbsp;&nbsp;name: []const u8,
};

const Node = struct {
&nbsp;&nbsp;next: ?*Node,
};

pub fn main() !void {
&nbsp;&nbsp;var user1 = User{.id = 1, .name = "Leto"};
&nbsp;&nbsp;const node1: *Node = @ptrCast(&user1);
&nbsp;&nbsp;node1.next = null;

&nbsp;&nbsp;std.debug.print("{}\n", .{node1});
&nbsp;&nbsp;std.debug.print("{d}\n", .{user1.id});&nbsp;&nbsp;&nbsp;&nbsp;// added
&nbsp;&nbsp;std.debug.print("{s}\n", .{user1.name});&nbsp;&nbsp;// added
}
</code></pre>
		<ul>
			<li>
				<p>
                    The underlying memory for 
                    <code>node1</code>
                    &nbsp;is more than big enough, but the code still crashes. When we write to 
                    <code>user.id</code>
                    &nbsp;or 
                    <code>user1.name</code>
                    , the compiler enforces correctness: 
                    <code>id</code>
                    &nbsp;must be an 
                    <code>u32</code>
                    &nbsp;and 
                    <code>name</code>
                    &nbsp;must be a 
                    <code>[]const u8</code>
                    . Similarly, when we write 
                    <code>null</code>
                    &nbsp;to 
                    <code>node1.next</code>
                    , the code compiles because 
                    <code>null</code>
                    &nbsp;is a valid 
                    <code>?*Node</code>
                    . But when, at runtime, we try to interpret that 
                    <code>null</code>
                    &nbsp;as a part of a 
                    <code>User</code>
                    , the behavior becomes undefined (i.e. we'll most likely crash).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cautions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    One last thing worth pointing out is that, unless a structure is declared as 
                    <code>packed</code>
                    , Zig makes no guarantee about its memory layout.
				</p>
			</li>
			<li>
				<p>
                    In almost all cases, you should not write to memory as one type and read it as another (which is exactly what we've done throughout the post).
				</p>
			</li>
			<li>
				<p>
                    Unless the struct is 
                    <code>packed</code>
                    &nbsp;or the struct is very simple, you cannot predict how those read/writes will be interpreted by different types sharing the same memory.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="primitives" >
    Primitives
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Primitive-Types" 
				class="external-link" 
				target="_blank" >
                List
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="integers" >
    Integers
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Integers" 
				class="external-link" 
				target="_blank" >
                Integers
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const decimal_int: i32 = 98222;
const hex_int: u8 = 0xff;
const another_hex_int: u8 = 0xFF;
const octal_int: u16 = 0o755;
const binary_int: u8 = 0b11110000;
</code></pre>
<pre><code class="language-zig" data-lang="zig">const one_billion: u64 = 1_000_000_000;
const binary_mask: u64 = 0b1_1111_1111;
const permissions: u64 = 0o7_5_5;
const big_address: u64 = 0xFF80_0000_0000_0000;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Coercion / Casting
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "integer widening" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: u8 = 250;
&nbsp;&nbsp;&nbsp;&nbsp;// This is ok, providing that the new type can fit all of the values that the old type can.
&nbsp;&nbsp;&nbsp;&nbsp;const b: u16 = a;
&nbsp;&nbsp;&nbsp;&nbsp;const c: u32 = b;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(c == a);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "@intCast" {
&nbsp;&nbsp;&nbsp;&nbsp;const x: u64 = 200;
&nbsp;&nbsp;&nbsp;&nbsp;const y = @as(u8, @intCast(x));
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf(y) == u8);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Overflow
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Overflows are detectable illegal behaviour.
				</p>
			</li>
			<li>
				<p>
                    Sometimes, being able to overflow integers in a well-defined manner is a wanted behaviour.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250308105105.png" width="296" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Saturation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Values will stick to their lower and upper bounds.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">var i: u8 = 200;&nbsp;&nbsp; // "i" is an unsigned 8-bit integer (values: from 0 to 255)
i&nbsp;&nbsp;+| 100 == 255&nbsp;&nbsp; // u8: won't go higher than 255
i&nbsp;&nbsp;-| 300 == 0&nbsp;&nbsp;&nbsp;&nbsp; // unsigned, won't go lower than 0
i&nbsp;&nbsp;*| 2&nbsp;&nbsp; == 255&nbsp;&nbsp; // u8: won't go higher than 255
i &lt;&lt;| 8&nbsp;&nbsp; == 255&nbsp;&nbsp; // u8: won't go higher than 255
</code></pre>
	</li>
</ul>
<h5
	id="floats" >
    Floats
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Floats" 
				class="external-link" 
				target="_blank" >
                Floats
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const floating_point: f64 = 123.0E+77;
const another_float: f64 = 123.0;
const yet_another: f64 = 123.0e+77;

const hex_floating_point: f64 = 0x103.70p-5;
const another_hex_float: f64 = 0x103.70;
const yet_another_hex_float: f64 = 0x103.70P-5;
</code></pre>
<pre><code class="language-zig" data-lang="zig">const lightspeed: f64 = 299_792_458.000_000;
const nanosecond: f64 = 0.000_000_001;
const more_hex: f64 = 0x1234_5678.9ABC_CDEFp-10;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Coercion / Casting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Floats coerce to larger float types.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "float widening" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: f16 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;const b: f32 = a;
&nbsp;&nbsp;&nbsp;&nbsp;const c: f128 = b;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(c == @as(f128, a));
}
</code></pre>
		<ul>
			<li>
				<p>
                    <code>@floatFromInt</code>
				</p>
				<ul>
					<li>
						<p>
                            Is always safe
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>@intFromFloat</code>
				</p>
				<ul>
					<li>
						<p>
                            Is detectable illegal behaviour if the float value cannot fit in the integer destination type.
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "int-float conversion" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: i32 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;const b = @as(f32, @floatFromInt(a));
&nbsp;&nbsp;&nbsp;&nbsp;const c = @as(i32, @intFromFloat(b));
&nbsp;&nbsp;&nbsp;&nbsp;try expect(c == a);
}
</code></pre>
	</li>
</ul>
<h3
	id="generics" >
    Generics
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.openmymind.net/learning_zig/generics/" 
				class="external-link" 
				target="_blank" >
                Using Generics
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="types" >
    types
</h5>
<ul>
	<li>
		<p>
            A function can return any type, not just primitives and arrays.
		</p>
	</li>
	<li>
		<p>
            <code>types</code>
            &nbsp;must always be compile-time known.
		</p>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
			<strong>
                Returns an Array (new array type)
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var arr: IntArray(3) = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;arr[0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;arr[1] = 10;
&nbsp;&nbsp;&nbsp;&nbsp;arr[2] = 100;
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{any}\n", .{arr});
}

fn IntArray(comptime length: usize) type {
&nbsp;&nbsp;&nbsp;&nbsp;return [length]i64;
}
</code></pre>
		<ul>
			<li>
				<p>
                    This code only worked because we declared 
                    <code>length</code>
                    &nbsp;as 
                    <code>comptime</code>
                    . That is, we require anyone who calls 
                    <code>IntArray</code>
                    &nbsp;to pass a compile-time known 
                    <code>length</code>
                    &nbsp;parameter.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Returns a Struct (type)
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;var arr: IntArray(3) = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;arr.items[0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;arr.items[1] = 10;
&nbsp;&nbsp;&nbsp;&nbsp;arr.items[2] = 100;
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{any}\n", .{arr.items});
}

fn IntArray(comptime length: usize) type {
&nbsp;&nbsp;&nbsp;&nbsp;return struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items: [length]i64,
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Receives a type and returns a Struct (type)
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">fn List(comptime T: type) type {
&nbsp;&nbsp;&nbsp;&nbsp;return struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos: usize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items: []T,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator: Allocator,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn init(allocator: Allocator) !List(T) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return .{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.pos = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.allocator = allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.items = try allocator.alloc(T, 4),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;};
}
</code></pre>
	</li>
</ul>
<h3
	id="tuples" >
    Tuples
</h3>
<h5
	id="tuples" >
    Tuples
</h5>
<pre><code class="language-zig" data-lang="zig">// A tuple is a list of elements, possibly of different types.

const foo = .{ "hello", true, 42 };
// foo.len == 3
</code></pre>
<h3
	id="arrays" >
    Arrays
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://ziglang.org/documentation/master/#Arrays" 
				class="external-link" 
				target="_blank" >
                Arrays
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="array-codent-code" >
    Array (
    <code>[N]T</code>
    )
</h5>
<pre><code class="language-zig" data-lang="zig">const a = [5]u8{ 'h', 'e', 'l', 'l', 'o' };
const b = [_]u8{ 'w', 'o', 'r', 'l', 'd' };
const c: [100]u8 = [_]u8{1} ** 100;
</code></pre>
<pre><code class="language-zig" data-lang="zig">const array = [_]u8{ 'h', 'e', 'l', 'l', 'o' };
const length = array.len; // 5
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Multidimensional
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const mat4x4 = [4][4]f32{
&nbsp;&nbsp;&nbsp;&nbsp;.{ 1, 0, 0, 0 },
&nbsp;&nbsp;&nbsp;&nbsp;.{ 0, 1, 0, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;.{ 0, 0, 1, 0 },
&nbsp;&nbsp;&nbsp;&nbsp;.{ 0, 0, 0, 1 },
};

// Access the 2D array then the inner array through indexes.
try expect(mat4x4[1][1] == 1.0);

// Here we iterate with for loops.
for (mat4x4) |row, row_index| {
&nbsp;&nbsp;&nbsp;&nbsp;for (row) |cell, column_index| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
</ul>
<h5
	id="arraylist-codestd-arraylistt-code" >
    ArrayList (
    <code>std.ArrayList(T)</code>
    )
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://zig.guide/standard-library/arraylist" 
				class="external-link" 
				target="_blank" >
                ArrayList
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Serves as a buffer that can change size.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Similarities
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>std.ArrayList(T)</code>
                    &nbsp;is similar to C++'s 
                    <code>std::vector&lt;T&gt;</code>
                    &nbsp;and Rust's 
                    <code>Vec&lt;T&gt;</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Memory
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>deinit()</code>
                    &nbsp;method frees all memory used by the ArrayList.
				</p>
			</li>
			<li>
				<p>
                    Memory can be read from and written to via its slice field - 
                    <code>.items</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");
const expect = std.testing.expect;

const eql = std.mem.eql;
const ArrayList = std.ArrayList;
const test_allocator = std.testing.allocator;

test "arraylist" {
&nbsp;&nbsp;&nbsp;&nbsp;var list = ArrayList(u8).init(test_allocator);
&nbsp;&nbsp;&nbsp;&nbsp;defer list.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('H');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('e');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('l');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('l');
&nbsp;&nbsp;&nbsp;&nbsp;try list.append('o');
&nbsp;&nbsp;&nbsp;&nbsp;try list.appendSlice(" World!");

&nbsp;&nbsp;&nbsp;&nbsp;try expect(eql(u8, list.items, "Hello World!"));
}
</code></pre>
<h3
	id="vectors" >
    Vectors
</h3>
<ul>
	<li>
		<p>
            Allow efficient parallel operations using 
			<strong>
                SIMD (Single Instruction, Multiple Data)
			</strong>
            &nbsp;instructions.
		</p>
	</li>
	<li>
		<p>
            A data type that stores multiple values of the same type.
		</p>
		<ul>
			<li>
				<p>
                    Vectors can only have child types of booleans, integers, floats and pointers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Note that using explicit vectors may result in slower code if you make wrong choices. The compiler's auto-vectorization is fairly smart.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Access
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vectors are indexable.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "vector indexing" {
&nbsp;&nbsp;&nbsp;&nbsp;const x: @Vector(4, u8) = .{ 255, 0, 255, 0 };
&nbsp;&nbsp;&nbsp;&nbsp;try expect(x[0] == 255);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Addition
					</strong>
                    :
				</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const meta = @import("std").meta;

test "vector add" {
&nbsp;&nbsp;&nbsp;&nbsp;const x: @Vector(4, f32) = .{ 1, -10, 20, -1 };
&nbsp;&nbsp;&nbsp;&nbsp;const y: @Vector(4, f32) = .{ 2, 10, 0, 1 };
&nbsp;&nbsp;&nbsp;&nbsp;const z = x + y;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(meta.eql(z, @Vector(4, f32){ 3, 0, 20, 0 }));
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const a: @Vector(4, i32) = @Vector(4, i32){ 1, 2, 3, 4 };
const b: @Vector(4, i32) = @Vector(4, i32){ 10, 20, 30, 40 };

const c = a + b; // Result: {11, 22, 33, 44}

</code></pre>
			</li>
			<li>
				<p>
					<strong>
                        Scalar Multiply
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The function 
                            <code>@splat(len, value)</code>
                            &nbsp;creates a vector filled with the same value.
						</p>
					</li>
				</ul>
<pre><code class="language-zig" data-lang="zig">const v: @Vector(4, i32) = @Vector(4, i32){ 2, 4, 6, 8 };
const scale = 2;

const result = v * @splat(4, scale); // {4, 8, 12, 16}

</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Coercion
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Vectors coerce to their respective arrays.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const arr: [4]f32 = @Vector(4, f32){ 1, 2, 3, 4 };
</code></pre>
	</li>
</ul>
<h3
	id="strings" >
    Strings
</h3>
<pre><code class="language-zig" data-lang="zig">// Simple string constant.
const greetings = "hello";
// ... which is equivalent to:
const greetings: *const [5:0]u8 = "hello";
// In words: "greetings" is a constant value, a pointer to a constant array of 5 elements (8-bit unsigned integers), with an extra '0' at the end.
// The extra "0" is called a "sentinel value".

print("string: {s}\n", .{greetings});
</code></pre>
<ul>
	<li>
		<p>
            &quot;There are no strings in Zig, everything is an array of u8. It's frustrating.&quot;
		</p>
		<ul>
			<li>
				<p>
                    <code>[]const u8</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://gencmurat.com/en/posts/zig-strings/" 
				class="external-link" 
				target="_blank" >
                Tutorial =)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://medium.com/codex/solving-the-crazy-zig-literal-strings-f2f692ae500b" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.huy.rocks/everyday/01-04-2022-zig-strings-in-5-minutes" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=nTfyhJnKG7o" 
				class="external-link" 
				target="_blank" >
                Tutorial
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            RAGE AGAINST THE DYING OF THE LIGHT..................................
		</p>
	</li>
</ul>
<h5
	id="string-literals" >
    String Literals
</h5>
<ul>
	<li>
		<p>
            The type of string literals is 
            <code>*const [N:0]u8</code>
            , where N is the length of the string.
		</p>
		<ul>
			<li>
				<p>
                    This allows string literals to coerce to sentinel-terminated slices, and sentinel-terminated many pointers.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "string literal" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@TypeOf("hello") == *const [5:0]u8);
}
</code></pre>
<h5
	id="concatenation" >
    Concatenation
</h5>
<ul>
	<li>
		<p>
			<strong>
                With Alloc
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const name = "Leto";
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;const say = std.fmt.allocPrint(allocator, "Hello {s}", .{name});
&nbsp;&nbsp;&nbsp;&nbsp;defer allocator.free(say);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{s}\n", .{greeting});
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                With buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This API moves the memory management burden to the caller. If we had a longer 
                    <code>name</code>
                    , or a smaller 
                    <code>buf</code>
                    , our 
                    <code>bufPrint</code>
                    &nbsp;could return a 
                    <code>NoSpaceLeft</code>
                    &nbsp;error.
				</p>
			</li>
			<li>
				<p>
                    But there are plenty of scenarios where an application has known limits, such as a maximum name length.
				</p>
			</li>
			<li>
				<p>
                    In those cases 
                    <code>bufPrint</code>
                    &nbsp;is safer and faster.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const name = "Leto";

&nbsp;&nbsp;&nbsp;&nbsp;var buf: [100]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const greeting = try std.fmt.bufPrint(&buf, "Hello {s}", .{name});

&nbsp;&nbsp;&nbsp;&nbsp;std.debug.print("{s}\n", .{greeting});
}
</code></pre>
	</li>
</ul>
<h5
	id="equal" >
    Equal
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://nofmal.github.io/zig-with-example/string-handling/#string-equal" 
				class="external-link" 
				target="_blank" >
                std.mem.eql
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const internalIcons = "Internal_Icons";
if (std.mem.eql(u8, internalIcons, "Internal_Icons")) continue;
</code></pre>
<h5
	id="contains" >
    Contains
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://nofmal.github.io/zig-with-example/string-handling/#string-contains" 
				class="external-link" 
				target="_blank" >
                Contains
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="copy" >
    Copy
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://nofmal.github.io/zig-with-example/string-handling/#string-copy" 
				class="external-link" 
				target="_blank" >
                Copy
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="c-strings" >
    C Strings
</h5>
<ul>
	<li>
		<p>
            <code>[*:0]u8</code>
            &nbsp;and 
            <code>[*:0]const u8</code>
            &nbsp;perfectly model C's strings.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "C string" {
&nbsp;&nbsp;&nbsp;&nbsp;const c_string: [*:0]const u8 = "hello";
&nbsp;&nbsp;&nbsp;&nbsp;var array: [5]u8 = undefined;

&nbsp;&nbsp;&nbsp;&nbsp;var i: usize = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while (c_string[i] != 0) : (i += 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[i] = c_string[i];
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h4
	id="sentinel-termination" >
    Sentinel Termination
</h4>
<ul>
	<li>
		<p>
            <code>[N:t]T</code>
            , 
            <code>[:t]T</code>
            , and 
            <code>[*:t]T</code>
            , where 
            <code>t</code>
            &nbsp;is a value of the child type 
            <code>T</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "sentinel termination" {
&nbsp;&nbsp;&nbsp;&nbsp;const terminated = [3:0]u8{ 3, 2, 1 };
&nbsp;&nbsp;&nbsp;&nbsp;try expect(terminated.len == 3);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@as(*const [4]u8, @ptrCast(&terminated))[3] == 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `@ptrCast` is used to perform an unsafe type conversion. This shows us that the last element of the array is followed by a 0 byte.
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Coercion
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Sentinel-terminated types coerce to their non-sentinel-terminated counterparts.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "coercion" {
&nbsp;&nbsp;&nbsp;&nbsp;const a: [*:0]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const b: [*]u8 = a;

&nbsp;&nbsp;&nbsp;&nbsp;const c: [5:0]u8 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const d: [5]u8 = c;

&nbsp;&nbsp;&nbsp;&nbsp;const e: [:0]f32 = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;const f: []f32 = e;

&nbsp;&nbsp;&nbsp;&nbsp;_ = .{ b, d, f }; // ignore unused
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Sentinel Terminated Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can be used to create a sentinel-terminated slice with the syntax 
                    <code>x[n..m:t]</code>
                    , where 
                    <code>t</code>
                    &nbsp;is the terminator value.
				</p>
			</li>
			<li>
				<p>
                    Doing this is an assertion from the programmer that the memory is terminated where it should be. Getting this wrong is detectable illegal behaviour.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "sentinel terminated slicing" {
&nbsp;&nbsp;&nbsp;&nbsp;var x = [_:0]u8{255} ** 3;
&nbsp;&nbsp;&nbsp;&nbsp;const y = x[0..3 :0];
&nbsp;&nbsp;&nbsp;&nbsp;_ = y;
}
</code></pre>
	</li>
</ul>
<h3
	id="hashmaps" >
    HashMaps
</h3>
<ul>
	<li>
		<p>
            <code>std.StringHashMap</code>
            &nbsp;and 
            <code>std.AutoHashMap</code>
            &nbsp;are just wrappers for 
            <code>std.HashMap</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    If these two do not fulfill your needs, using 
                    <code>std.HashMap</code>
                    &nbsp;directly gives you much more control.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="autohashmap" >
    AutoHashMap
</h5>
<ul>
	<li>
		<p>
            <code>std.AutoHashMap</code>
		</p>
	</li>
	<li>
		<p>
            Lets you easily create a hash map type from a key type and a value type.
		</p>
	</li>
	<li>
		<p>
            These must be initialized with an allocator.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">test "hashing" {
&nbsp;&nbsp;&nbsp;&nbsp;const Point = struct { x: i32, y: i32 };

&nbsp;&nbsp;&nbsp;&nbsp;var map = std.AutoHashMap(u32, Point).init(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_allocator,&nbsp;&nbsp;// refers to `std.testing.allocator`.
&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;defer map.deinit();

&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1525, .{ .x = 1, .y = -4 });
&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1550, .{ .x = 2, .y = -3 });
&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1575, .{ .x = 3, .y = -2 });
&nbsp;&nbsp;&nbsp;&nbsp;try map.put(1600, .{ .x = 4, .y = -1 });

&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.count() == 4);

&nbsp;&nbsp;&nbsp;&nbsp;var sum = Point{ .x = 0, .y = 0 };
&nbsp;&nbsp;&nbsp;&nbsp;var iterator = map.iterator();

&nbsp;&nbsp;&nbsp;&nbsp;while (iterator.next()) |entry| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum.x += entry.value_ptr.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum.y += entry.value_ptr.y;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;try expect(sum.x == 10);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(sum.y == -10);
}
</code></pre>
<ul>
	<li>
		<p>
            <code>.fetchPut</code>
		</p>
		<ul>
			<li>
				<p>
                    Puts a value in the hash map, 
					<strong>
                        returning
					</strong>
                    &nbsp;a value if there was previously a value for that key.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">test "fetchPut" {
&nbsp;&nbsp;&nbsp;&nbsp;var map = std.AutoHashMap(u8, f32).init(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_allocator,
&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;defer map.deinit();

&nbsp;&nbsp;&nbsp;&nbsp;try map.put(255, 10);
&nbsp;&nbsp;&nbsp;&nbsp;const old = try map.fetchPut(255, 100);

&nbsp;&nbsp;&nbsp;&nbsp;try expect(old.?.value == 10);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.get(255).? == 100);
}
</code></pre>
	</li>
</ul>
<h5
	id="stringhashmap" >
    StringHashMap
</h5>
<ul>
	<li>
		<p>
            <code>std.StringHashMap</code>
		</p>
	</li>
	<li>
		<p>
            For when you need strings as keys.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">test "string hashmap" {
&nbsp;&nbsp;&nbsp;&nbsp;var map = std.StringHashMap(enum { cool, uncool }).init(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_allocator,
&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;defer map.deinit();

&nbsp;&nbsp;&nbsp;&nbsp;try map.put("loris", .uncool);
&nbsp;&nbsp;&nbsp;&nbsp;try map.put("me", .cool);

&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.get("me").? == .cool);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(map.get("loris").? == .uncool);
}
</code></pre>
<h3
	id="enums-codeenum-code" >
    Enums (
    <code>enum {}</code>
    )
</h3>
<ul>
	<li>
		<p>
            Allow you to define types with a restricted set of named values.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const Direction = enum { north, south, east, west };
</code></pre>
<pre><code class="language-zig" data-lang="zig">const Value = enum(u2) { zero, one, two };
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Default values
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Enum ordinal values start at 0. They can be accessed with the built-in function 
                    <code>@intFromEnum</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Value = enum(u2) { zero, one, two };

test "enum ordinal value" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value.zero) == 0);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value.one) == 1);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value.two) == 2);
}
</code></pre>
		<ul>
			<li>
				<p>
                    Values can be overridden, with subsequent values continuing from there.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Value2 = enum(u32) {
&nbsp;&nbsp;&nbsp;&nbsp;hundred = 100,
&nbsp;&nbsp;&nbsp;&nbsp;thousand = 1000,
&nbsp;&nbsp;&nbsp;&nbsp;million = 1000000,
&nbsp;&nbsp;&nbsp;&nbsp;next,
};

test "set enum ordinal value" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.hundred) == 100);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.thousand) == 1000);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.million) == 1000000);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(@intFromEnum(Value2.next) == 1000001);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Variables
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Enums can also have 
                    <code>var</code>
                    &nbsp;and 
                    <code>const</code>
                    &nbsp;declarations.
				</p>
			</li>
			<li>
				<p>
                    These act as namespaced globals and their values are unrelated to instances of the enum type.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Mode = enum {
&nbsp;&nbsp;&nbsp;&nbsp;var count: u32 = 0;
&nbsp;&nbsp;&nbsp;&nbsp;on,
&nbsp;&nbsp;&nbsp;&nbsp;off,
};

test "hmm" {
&nbsp;&nbsp;&nbsp;&nbsp;Mode.count += 1;
&nbsp;&nbsp;&nbsp;&nbsp;try expect(Mode.count == 1);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Methods
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Suit = enum {
&nbsp;&nbsp;&nbsp;&nbsp;clubs,
&nbsp;&nbsp;&nbsp;&nbsp;spades,
&nbsp;&nbsp;&nbsp;&nbsp;diamonds,
&nbsp;&nbsp;&nbsp;&nbsp;hearts,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;pub fn isClubs(self: Suit) bool {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self == Suit.clubs;
&nbsp;&nbsp;&nbsp;&nbsp;}
};

test "enum method" {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(Suit.spades.isClubs() == Suit.isClubs(.spades));
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Casting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Enums aren't integers. Convert them with a built-in.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const Value = enum { zero, stuff, blah };
if (@enumToInt(Value.zero)&nbsp;&nbsp;== 0) { ... }
if (@enumToInt(Value.stuff) == 1) { ... }
if (@enumToInt(Value.blah)&nbsp;&nbsp;== 2) { ... }
</code></pre>
	</li>
</ul>
<h3
	id="unions" >
    Unions
</h3>
<ul>
	<li>
		<p>
            Define types that store one value of many possible typed fields.
		</p>
	</li>
	<li>
		<p>
            Only one field may be active at a time.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const Result = union {
&nbsp;&nbsp;&nbsp;&nbsp;int: i64,
&nbsp;&nbsp;&nbsp;&nbsp;float: f64,
&nbsp;&nbsp;&nbsp;&nbsp;bool: bool,
};

test "simple union" {
&nbsp;&nbsp;&nbsp;&nbsp;var result = Result{ .int = 1234 };
&nbsp;&nbsp;&nbsp;&nbsp;result.int = 11;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// valid.
&nbsp;&nbsp;&nbsp;&nbsp;result.float = 12.34; // invalid.
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Tagged Unions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Are unions that use an enum to indicate which field is active.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Tag = enum { a, b, c };

const Tagged = union(Tag) { a: u8, b: f32, c: bool };

test "switch on tagged union" {
&nbsp;&nbsp;&nbsp;&nbsp;var value = Tagged{ .b = 1.5 };
&nbsp;&nbsp;&nbsp;&nbsp;switch (value) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// With `|*value|` we can capture a pointer to the values instead of the values themselves, allowing us to use dereferencing to mutate the original value.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.a =&gt; |*byte| byte.* += 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.b =&gt; |*float| float.* *= 2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.c =&gt; |*b| b.* = !b.*,
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;try expect(value.b == 3);
}
</code></pre>
		<ul>
			<li>
				<p>
                    The tag type of a tagged union can also be inferred. This is equivalent to the 
                    <code>Tagged</code>
                    &nbsp;type above.
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const Tagged = union(enum) { a: u8, b: f32, c: bool };
</code></pre>
		<ul>
			<li>
				<p>
                    <code>void</code>
                    &nbsp;member types can have their type omitted from the syntax. Here, 
                    <code>none</code>
                    &nbsp;has type 
                    <code>void</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const Tagged2 = union(enum) { a: u8, b: f32, c: bool, none };
</code></pre>
	</li>
</ul>
<h3
	id="structs-codet-code" >
    Structs (
    <code>T{}</code>
    )
</h3>
<ul>
	<li>
		<p>
            Zig gives no guarantees about the in-memory order of fields in a struct or its size.
		</p>
	</li>
	<li>
		<p>
            Struct fields cannot be implicitly uninitialized. If some component of the Struct is missing initialization, it will cause an error.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">const Vec3 = struct { x: f32, y: f32, z: f32 };

test "struct usage" {
&nbsp;&nbsp;&nbsp;&nbsp;const my_vector = Vec3{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.x = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.y = 100,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.z = 50,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;_ = my_vector;
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Defaults
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const Vec4 = struct { x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 0 };

test "struct defaults" {
&nbsp;&nbsp;&nbsp;&nbsp;const my_vector = Vec4{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.x = 25,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.y = -50,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;_ = my_vector;
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Packed
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">// Packed structure, with guaranteed in-memory layout.
const Divided = packed struct {
&nbsp;&nbsp;&nbsp;&nbsp;half1: u8,
&nbsp;&nbsp;&nbsp;&nbsp;quarter3: u4,
&nbsp;&nbsp;&nbsp;&nbsp;quarter4: u4,
};
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Methods
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Structs have the unique property that when given a pointer to a struct, one level of dereferencing is done automatically when accessing fields.&quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;In this example, 
                    <code>self.x</code>
                    &nbsp;and 
                    <code>self.y</code>
                    &nbsp;are accessed in the swap function without needing to dereference the self pointer.&quot;
				</p>
			</li>
		</ul>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

const Stuff = struct {
&nbsp;&nbsp;&nbsp;&nbsp;x: i32,
&nbsp;&nbsp;&nbsp;&nbsp;y: i32,
&nbsp;&nbsp;&nbsp;&nbsp;fn swap(self: *Stuff) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const tmp = self.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.x = self.y;&nbsp;&nbsp;&nbsp;&nbsp;// "without needing to dereference the self pointer", I believe this is `self.x` in Zig, whereas in C++ it would be `self-&gt;x` / `(*self).x`.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.y = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;}
};

test "automatic dereference" {
&nbsp;&nbsp;&nbsp;&nbsp;var thing = Stuff{ .x = 10, .y = 20 };
&nbsp;&nbsp;&nbsp;&nbsp;thing.swap();
&nbsp;&nbsp;&nbsp;&nbsp;try expect(thing.x == 20);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(thing.y == 10);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const Point = struct {
&nbsp;&nbsp;&nbsp;&nbsp;const Self = @This(); // Refers to its own type (later called "Point").

&nbsp;&nbsp;&nbsp;&nbsp;x: u32,
&nbsp;&nbsp;&nbsp;&nbsp;y: u32,
&nbsp;&nbsp;&nbsp;&nbsp;// Take a look at the signature. First argument is of type *Self: "self" is
&nbsp;&nbsp;&nbsp;&nbsp;// a pointer on the instance of the structure.
&nbsp;&nbsp;&nbsp;&nbsp;// This allows the same "dot" notation as in OOP, like "instance.set(x,y)".
&nbsp;&nbsp;&nbsp;&nbsp;// See the following example.
&nbsp;&nbsp;&nbsp;&nbsp;pub fn set(self: *Self, x: u32, y: u32) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.x = x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.y = y;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Again, look at the signature. First argument is of type Self (not *Self),
&nbsp;&nbsp;&nbsp;&nbsp;// this isn't a pointer. In this case, "self" refers to the instance of the
&nbsp;&nbsp;&nbsp;&nbsp;// structure, but can't be modified.
&nbsp;&nbsp;&nbsp;&nbsp;pub fn getx(self: Self) u32 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self.x;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// PS: two previous functions may be somewhat useless.
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; Attributes can be changed directly, no need for accessor functions.
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; It was just an example.
};
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Anonymous Structs
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "anonymous struct literal" {
&nbsp;&nbsp;&nbsp;&nbsp;const Point = struct { x: i32, y: i32 };

&nbsp;&nbsp;&nbsp;&nbsp;const pt: Point = .{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.x = 13,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.y = 67,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;try expect(pt.x == 13);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(pt.y == 67);
}
</code></pre>
<pre><code class="language-zig" data-lang="zig">const expect = @import("std").testing.expect;

test "fully anonymous struct" {
&nbsp;&nbsp;&nbsp;&nbsp;try dump(.{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.int = @as(u32, 1234),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.float = @as(f64, 12.34),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.b = true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.s = "hi",
&nbsp;&nbsp;&nbsp;&nbsp;});
}

fn dump(args: anytype) !void {
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.int == 1234);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.float == 12.34);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.b);
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.s[0] == 'h');
&nbsp;&nbsp;&nbsp;&nbsp;try expect(args.s[1] == 'i');
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Files as Structs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://youtu.be/oAVUW6sMb4U?si=78gjoshqC7vPJDvW&t=690" 
						class="external-link" 
						target="_blank" >
                        Using files as structs {11:30}
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Important notes:
						</p>
						<ul>
							<li>
								<p>
                                    <code>const Point = @This;</code>
                                    &nbsp;as the access point.
								</p>
							</li>
							<li>
								<p>
                                    Define functions as 
                                    <code>pub</code>
                                    &nbsp;if you want them accessible outside the file.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="this" >
    @This()
</h5>
<pre><code class="language-zig" data-lang="zig">const Tea = struct {
&nbsp;&nbsp;const Self = @This();
};

pub fn main() !void {
&nbsp;&nbsp;// prints "true"
&nbsp;&nbsp;std.debug.print("{}\n", .{Tea == Tea.Self});
}
</code></pre>
<h5
	id="declaration" >
    Declaration
</h5>
<ul>
	<li>
		<p>
            &quot;The principal units of code in Zig are declarations, not expressions&quot;.
		</p>
	</li>
	<li>
		<p>
			<strong>
                In Godot
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const z := Vector2(0, 0)
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Method 'a'
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const a: rl.Vector2 = .{.x = 0, .y = 0}; 
</code></pre>
		<ul>
			<li>
				<p>
                    Initializes the struct by values.
				</p>
			</li>
			<li>
				<p>
                    The method is called 'Anonymous Struct'.
				</p>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            When it comes to defining default values in a struct, maybe method 
                            <code>a</code>
                            &nbsp;is okay, but it's still inconvenient.
						</p>
					</li>
				</ul>
<pre><code class="language-zig" data-lang="zig">const MinhaStruct = Struct{
&nbsp;&nbsp;&nbsp;&nbsp;// vel: rl.Vector2 = .{.x = 0, .y = 0},
&nbsp;&nbsp;&nbsp;&nbsp;// vel: rl.Vector2 = rl.Vector2.init(0, 0),
};
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Method 'b'
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const b = rl.Vector2.init(0, 0); 
</code></pre>
		<ul>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            I feel a bit worried about 'initializing the struct by values', as I don't know if I'm initializing all the necessary values of the struct, so I usually go for a 
                            <code>.init</code>
                            -based approach.
						</p>
					</li>
					<li>
						<p>
                            The problem is: I change the struct, but I don't get warnings from the LSP, so the only way I know I'm creating the struct wrong is when compiling. Though, if there is an 
                            <code>init</code>
                            &nbsp;function and I'm always using it, it feels easier on the LSP, and I don't need to compile to see the error.
						</p>
					</li>
					<li>
						<p>
                            I'm thinking more about how to avoid having to compile every time to check for type errors in places where I use the struct.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Method 'c'
			</strong>
            :
		</p>
<pre><code class="language-zig" data-lang="zig">const c = rl.Vector2{.x = 0, .y = 0}; 
</code></pre>
		<ul>
			<li>
				<p>
                    Initializes the struct by values.
				</p>
			</li>
			<li>
				<p>
                    Quotes:
				</p>
				<ul>
					<li>
						<p>
                            &quot;c is probably least recommended followed by b.&quot;
						</p>
					</li>
					<li>
						<p>
                            &quot;a and b are fine, c is weird&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Method 'd'
			</strong>
		</p>
<pre><code class="language-zig" data-lang="zig">const d: rl.Vector2 = .init(0, 0);
</code></pre>
		<ul>
			<li>
				<p>
                    Quotes:
				</p>
				<ul>
					<li>
						<p>
                            &quot;the problem with d is that it doesn't work with 
                            <code>catch</code>
                            &quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-01-25 ðŸš€
			</footer>
		</div>
		<script
			src="/static/studies.61297.js" >
		</script>
	</body>
</html>
