<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/favicon.ico" >
		<link
			rel="icon" 
			href="/assets/favicon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/favicon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script
			src="/static/docs_load.js" >
		</script>
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			src="https://unpkg.com/@highlightjs/cdn-assets@11.11.1/highlight.min.js" >
		</script>
		<script
			src="https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.min.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/docs.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
>
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - DOD e COP/Design - DOD e COP.html" >
                                Design - DOD e COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - ECS/Design - ECS.html" >
                                Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - Design Patterns/Design - Design Patterns.html" >
                                Design - Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - Architecture Patterns.html" >
                                Design - Architecture Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - Concepts and Terminology.html" >
                                Design - Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - Rules of thumb - Laws - Guidelines and Principles/Design - Rules of thumb - Laws - Guidelines and Principles.html" >
                                Design - Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - Paradigms.html" >
                                Design - Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Design/Design - Production Methodologies/Design - Production Methodologies.html" >
                                Design - Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Things
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Code Editors/NeoVim - Uso/NeoVim - Uso.html" >
                                NeoVim - Uso
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Dependencies.html" >
                                Dependencies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/docs/Things/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Things/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/WebDev/HTML - Tests/HTML - Tests.html" >
                                HTML - Tests
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Electronics
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Electronics/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Electronics/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/docs/Electronics/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<header
				id="central-header" >
				<nav
					id="dropdown-menu" >
					<select
						onchange="if (this.value) window.location.href=this.value" >
						<option
							value="/" 
>
                            🏡 Home
						</option>
						<option
							value="/docs/_index.html" 
							selected="">
                            📖 Docs
						</option>
					</select>
				</nav>
				<button
					class="btn" 
					id="button-color-theme" >
					<i>
                        ☀️ / 🌑
					</i>
				</button>
			</header>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Memory
						</h1>
						<p>
							<time
								datetime="2025-03-12" >
                                🕒 Created: 2025-03-12
							</time>
							<time
								datetime="2025-10-28" >
                                | Updated: 2025-10-28
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="virtual-memory" >
    Virtual Memory
</h2>
<ul>
	<li>
		<p>
            Modern operating systems virtualize memory on a per-process basis. This means that the addresses used within your program/process are specific to that program/process only.
		</p>
	</li>
	<li>
		<p>
            Memory is no longer this dualistic model of 
			<em>
                the stack
			</em>
            &nbsp;and 
			<em>
                the heap
			</em>
            &nbsp;but rather a monistic model where everything is virtual memory.
		</p>
	</li>
	<li>
		<p>
            Some of that virtual address space is reserved for procedure stack frames, some of it is reserved for things required by the operating system, and the rest we can use for whatever we want.
		</p>
	</li>
	<li>
		<p>
            Memory is virtually-mapped and linear, and you can split that linear memory space into sections.
		</p>
	</li>
</ul>
<h2
	id="memory-alignment" >
    Memory Alignment
</h2>
<h3
	id="motivation" >
    Motivation
</h3>
<ul>
	<li>
		<p>
            The scenario below causes unnecessary wastage of CPU cycles.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090530.png" width="480" >
            .
		</p>
	</li>
	<li>
		<p>
            If we use padding (empty space) we can improve the CPU cycles, at the cost of the struct storing more memory.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090718.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090834.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            The order of the elements matters, as it can introduce more padding than necessary:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009090936.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009091017.png" width="400" >
            .
		</p>
	</li>
</ul>
<h3
	id="memory-access" >
    Memory Access
</h3>
<ul>
	<li>
		<p>
            Processors don't read 1 byte at a time from memory.
		</p>
	</li>
	<li>
		<p>
            They read 1 
			<strong>
                word
			</strong>
            &nbsp;at a time.
		</p>
	</li>
	<li>
		<p>
			<strong>
                32-bit Processor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Word size is 4 bytes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                64-bit Processor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Word size is 8 bytes.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="size" >
    Size
</h3>
<ul>
	<li>
		<p>
            The total number of bytes that a single element actually occupies in memory, 
			<em>
                including
			</em>
            &nbsp;any internal padding required by alignment.
		</p>
	</li>
</ul>
<h3
	id="offset" >
    Offset
</h3>
<ul>
	<li>
		<p>
            Defines where a field resides relative to a structure’s base address.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In 
                    <code>struct { int a; char b; }</code>
                    , if 
                    <code>a</code>
                    &nbsp;starts at offset 
                    <code>0</code>
                    , 
                    <code>b</code>
                    &nbsp;might be at offset 
                    <code>4</code>
                    &nbsp;due to alignment padding.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="stride" >
    Stride
</h3>
<ul>
	<li>
		<p>
            Byte distance between consecutive elements in an array or buffer.
		</p>
	</li>
	<li>
		<p>
            It’s not “after the element finishes”, it’s the 
			<em>
                total distance between consecutive starts
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            That’s why stride includes all bytes (data + padding) in a single element.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In a vertex buffer with position (12 bytes) + color (4 bytes), stride = 16 bytes. The next vertex starts 16 bytes after the previous one.
				</p>
				<ul>
					<li>
						<p>
                            Vertex 0 starts at byte 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Vertex 0 occupies bytes 
                            <code>0–15</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Vertex 1 starts at byte 
                            <code>16</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="alignment" >
    Alignment
</h3>
<ul>
	<li>
		<p>
            Alignment and Size are different things.
		</p>
	</li>
	<li>
		<p>
            Alignment == &quot;Divisible by&quot;.
		</p>
	</li>
	<li>
		<p>
            Required byte boundary a value must start on, typically a power of two.
		</p>
	</li>
	<li>
		<p>
            Hardware or ABI rule ensuring each type begins at addresses divisible by its alignment requirement.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20251009083338.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Implicit Alignment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    When placing a field, the compiler ensures the field's offset is a multiple of the field's alignment. If the current offset is 
					<em>
                        not
					</em>
                    &nbsp;a multiple of the field's alignment, the compiler inserts padding before the field so the resulting offset becomes a multiple of the alignment.
				</p>
				<ul>
					<li>
						<p>
                            When placing field F the compiler ensures 
                            <code>offset(F) % align(F) == 0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If not, it inserts 
                            <code>padding = (align(F) - (offset % align(F))) % align(F)</code>
                            &nbsp;bytes before F.
						</p>
					</li>
					<li>
						<p>
                            The struct’s overall alignment is 
                            <code>max(align(member))</code>
                            . The compiler may add trailing padding so 
                            <code>sizeof(struct)</code>
                            &nbsp;is a multiple of that max alignment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    A struct adds implicit padding between members, based on the alignment of the member with the highest alignment.
				</p>
			</li>
			<li>
				<p>
                    The gray dots indicate the implicit padding added by the compiler.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20251009083656.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It may also add padding at the end of the struct, so the struct is divisible by its alignment. This ensures that when the struct is used as an array, each struct will be properly aligned along with its members.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Odin
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Alignment, Size and the Pointer are related, such as:
				</p>
				<ul>
					<li>
						<p>
                            <code>size_of(T) % align_of(T) == 0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>uintptr(&t) % align_of(t) == 0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Check 
                            <a href="Odin.html#Alignment">
                            Odin#Alignment
                            </a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="unaligned-memory" >
    Unaligned Memory
</h3>
<ul>
	<li>
		<p>
            If you have an unaligned memory access (on a processor that allows it), the processor will have to read multiple “words”. This means that an unaligned memory access 
			<em>
                may
			</em>
            &nbsp;be much slower than an aligned memory access.
		</p>
	</li>
	<li>
		<p>
            This can also lead to undefined behavior if the unaligned memory is within cache bounds.
		</p>
	</li>
</ul>
<h3
	id="std140-and-std430" >
    std140 and std430
</h3>
<ul>
	<li>
		<p>
            Both are GLSL memory alignments.
		</p>
	</li>
	<li>
		<p>
            Check 
            <a href="Vulkan.html#Shader Aligment, Stride, Offsets">
            Vulkan#Shader Alignment, Stride, Offsets
            </a>
            .
		</p>
	</li>
</ul>
<h2
	id="allocators" >
    Allocators
</h2>
<h5
	id="lifetimes-hierarchy" >
    Lifetimes Hierarchy
</h5>
<ul>
	<li>
		<p>
			<strong>
                Permanent Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Memory that is never freed until the end of the program. This memory is persistent during the program lifetime.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transient Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Memory that has a cycle-based lifetime. This memory only persists for the “cycle” and is freed at the end of this cycle. An example of a cycle could be a frame within a graphical program (e.g. a game) or an update loop.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scratch/Temporary Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Short-lived, quick memory that you just want to allocate and forget about. A common case for this is when generating a string and outputting it to a log.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="linear-arena-allocator" >
    Linear / Arena Allocator
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2019/02/08/memory-allocation-strategies-002/" 
				class="external-link" 
				target="_blank" >
                Linear/Arena Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The arena’s logic only requires an offset (or pointer) to indicate the end of the last allocation.
		</p>
	</li>
	<li>
		<p>
            To allocate some memory from the arena, it is as simple as moving the offset (or pointer) forward. In Big-O notation, the allocation has complexity of 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            &nbsp;(constant).
		</p>
	</li>
	<li>
		<p>
            Due to being the simplest allocator possible, the arena allocator does not allow the user to free certain blocks of memory. The memory is usually freed all at once.
		</p>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
            The simplest arena allocator 
			<em>
                could
			</em>
            &nbsp;look like this:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">static unsigned char *arena_buffer;
static size_t arena_buffer_length;
static size_t arena_offset;

void *arena_alloc(size_t size) {
&nbsp;&nbsp;&nbsp;&nbsp;// Check to see if the backing memory has space left
&nbsp;&nbsp;&nbsp;&nbsp;if (arena_offset+size &lt;= arena_buffer_length) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *ptr = &arena_buffer[arena_offset];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arena_offset += size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Zero new memory by default
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ptr, 0, size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Return NULL if the arena is out of memory
&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
}
</code></pre>
<ul>
	<li>
		<p>
            There are two issues with this basic approach:
		</p>
		<ul>
			<li>
				<p>
                    You cannot reuse this procedure for different arenas
				</p>
				<ul>
					<li>
						<p>
                            Can be easily solved by coupling that global data into a structure and passing that to the procedure 
                            <code>arena_alloc</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The pointer returned may not be aligned correctly for the data you need.
				</p>
				<ul>
					<li>
						<p>
                            This requires understanding the basic issues of 
							<em>
                                unaligned memory
							</em>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It's also missing some important features of a practical implementation:
		</p>
		<ul>
			<li>
				<p>
                    <code>init</code>
                    , 
                    <code>alloc</code>
                    , 
                    <code>free</code>
                    , 
                    <code>resize</code>
                    , 
                    <code>free_all</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.gingerbill.org/code/memory-allocation-strategies/part002.c" 
						class="external-link" 
						target="_blank" >
                        Practical implementation of an arena allocator
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="stack-allocator-lifo" >
    Stack Allocator (LIFO)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2019/02/15/memory-allocation-strategies-003/" 
				class="external-link" 
				target="_blank" >
                Stack Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A stack-like allocator means that the allocator acts like a data structure following the 
			<em>
                last-in, first-out
			</em>
            &nbsp;(LIFO) principle.
		</p>
	</li>
	<li>
		<p>
            This has nothing to do with 
			<em>
                the stack
			</em>
            &nbsp;or the 
			<em>
                stack frame
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Evolution of an Arena Allocator
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    As with the arena allocator, an offset into the memory block will be stored and will be moved forwards on every allocation.
				</p>
			</li>
			<li>
				<p>
                    The difference is that the offset can also be moved backwards when memory is 
					<em>
                        freed
					</em>
                    . With an arena, you could only free all the memory all at once.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="header" >
    Header
</h5>
<ul>
	<li>
		<p>
            The offset of the previous allocation needs to be tracked. This is required in order to free memory on a 
			<em>
                per-allocation
			</em>
            &nbsp;basis.
		</p>
	</li>
	<li>
		<p>
            One approach is to store a 
			<em>
                header
			</em>
            &nbsp;which stores information about that allocation. This 
			<em>
                header
			</em>
            &nbsp;allows the allocator to know how far back it should move the offset to free that memory.
		</p>
		<ul>
			<li>
				<p>
                    The stack allocator is the first of many allocators that will use the concept of a 
					<em>
                        header
					</em>
                    &nbsp;for allocations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            To allocate some memory from the stack allocator, as with the arena allocator, it is as simple as moving the offset forward while accounting for the header. In Big-O notation, the allocation has complexity of 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            &nbsp;(constant).
		</p>
	</li>
	<li>
		<p>
            To free a block, the header stored before the block of memory can be read in order to move the offset backwards. In Big-O notation, freeing this memory has complexity of 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            &nbsp;(constant).
		</p>
	</li>
	<li>
		<p>
			<strong>
                What's stored in the header
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There are three main approaches:
				</p>
				<ul>
					<li>
						<p>
                            Store the padding from the previous offset
						</p>
					</li>
					<li>
						<p>
                            Store the previous offset
						</p>
					</li>
					<li>
						<p>
                            Store the size of the allocation
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            See the article 
			<a
				href="https://www.gingerbill.org/article/2019/02/15/memory-allocation-strategies-003/" 
				class="external-link" 
				target="_blank" >
                Stack Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Improvements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You can extend the stack allocator even further by having two different offsets: one that starts at the beginning and increments forwards, and another that starts at the end and increments backwards. This is called a double-ended stack and allows for the maximization of memory usage whilst keeping fragmentation extremely low (as long as the offsets never overlap).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="pool-allocator" >
    Pool Allocator
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2019/02/16/memory-allocation-strategies-004/" 
				class="external-link" 
				target="_blank" >
                Pool Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A pool splits the supplied backing buffer into 
			<em>
                chunks
			</em>
            &nbsp;of equal size and keeps track of which of the chunks are free.
		</p>
		<ul>
			<li>
				<p>
                    When an allocation is requested, a free chunk is given.
				</p>
			</li>
			<li>
				<p>
                    When a chunk is freed, it adds that chunk back to the list of free chunks.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Pool allocators are extremely useful when you need to allocate chunks of memory of the same size that are created and destroyed dynamically, especially in a random order.
		</p>
	</li>
	<li>
		<p>
            Pools also have the benefit that arenas and stacks have in that they provide very little fragmentation and allocate/free in constant time 
			<em>
				<strong>
                    O(1)
				</strong>
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Pool allocators are usually used to allocate 
			<em>
                groups
			</em>
            &nbsp;of “things” at once which share the same lifetime.
		</p>
		<ul>
			<li>
				<p>
                    An example could be within a game that creates and destroys entities in batches where each entity within a batch shares the same lifetime.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="free-list" >
    Free List
</h5>
<ul>
	<li>
		<p>
            A 
			<a
				href="https://wikipedia.org/wiki/Free_list" 
				class="external-link" 
				target="_blank" >
                free list
			</a>
            &nbsp;is a data structure that internally stores a 
			<a
				href="https://wikipedia.org/wiki/Linked_list" 
				class="external-link" 
				target="_blank" >
                linked list
			</a>
            &nbsp;of the free slots/chunks within the memory buffer.
		</p>
	</li>
	<li>
		<p>
            The nodes of the list are stored in-place, meaning there is no need for an additional data structure (e.g., array, list, etc.) to keep track of the free slots.
		</p>
	</li>
	<li>
		<p>
            The data is 
			<em>
                only
			</em>
            &nbsp;stored 
			<em>
                within
			</em>
            &nbsp;the backing buffer of the pool allocator.
		</p>
	</li>
	<li>
		<p>
            The general approach is to store a header at the beginning of the chunk (not before the chunk like with the stack allocator) which 
			<em>
                points
			</em>
            &nbsp;to the next available free chunk.
		</p>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/code/memory-allocation-strategies/part004.c" 
				class="external-link" 
				target="_blank" >
                Full implementation - Ginger Bill
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="free-list-based-allocator" >
    Free List Based Allocator
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2021/11/30/memory-allocation-strategies-005/" 
				class="external-link" 
				target="_blank" >
                Free List Based Allocator - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A free list is a general-purpose allocator which, compared to the other allocators we previously looked at, does not impose any restrictions.
		</p>
	</li>
	<li>
		<p>
            It allows allocations and deallocations to be out of order and of any size.
		</p>
	</li>
	<li>
		<p>
            Due to its nature, the allocator’s 
			<strong>
                performance is not as good
			</strong>
            &nbsp;as the others previously discussed in this series.
		</p>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            There are two common approaches to implementing a free list allocator:
		</p>
		<ul>
			<li>
				<p>
                    Using a 
					<a
						href="https://wikipedia.org/wiki/Linked_list" 
						class="external-link" 
						target="_blank" >
                        linked list
					</a>
				</p>
			</li>
			<li>
				<p>
                    Using a 
					<a
						href="https://wikipedia.org/wiki/Red%E2%80%93black_tree" 
						class="external-link" 
						target="_blank" >
                        red-black tree
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            See the article for the implementations.
		</p>
	</li>
</ul>
<h3
	id="buddy-memory-allocation" >
    Buddy Memory Allocation
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2021/12/02/memory-allocation-strategies-006/" 
				class="external-link" 
				target="_blank" >
                Buddy Memory Allocation - Ginger Bill
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The buddy allocator is a powerful allocator and a conceptually simple algorithm, but implementing it efficiently is a 
			<strong>
                lot harder
			</strong>
            &nbsp;than all of the previous allocators above.
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                Buddy Algorithm
			</em>
            &nbsp;assumes that the backing memory block is a power-of-two in bytes.
		</p>
	</li>
	<li>
		<p>
            When an allocation is requested, the allocator looks for a block whose size is at least the size of the requested allocation (similar to a free list).
		</p>
	</li>
	<li>
		<p>
            If the requested allocation size is less than half of the block, it is split into two (left and right), and the two resulting blocks are called “buddies.”
		</p>
	</li>
	<li>
		<p>
            If this requested allocation size is still less than half the size of the left buddy, the buddy block is recursively split until the resulting buddy is as small as possible to fit the requested allocation size.
		</p>
	</li>
	<li>
		<p>
            When a block is released, we can try to perform coalescence on buddies (contiguous neighboring blocks).
		</p>
	</li>
	<li>
		<p>
            Similar to free lists, there are specific conditions that must be met. Coalescence cannot be performed if a block has no (free) buddy, the block is still in use, or the buddy block is partially used.
		</p>
	</li>
</ul>
<h2
	id="tools-for-memory-analysis" >
    Tools for Memory Analysis
</h2>
<h3
	id="memory-visualization-tools" >
    Memory Visualization Tools
</h3>
<h5
	id="valgrind-massif-visualizer" >
    Valgrind + massif-visualizer
</h5>
<ul>
	<li>
		<p>
            &quot;Massif Visualizer is a tool that visualizes massif data. You run your application in Valgrind with 
            <code>--tool=massif</code>
            &nbsp;and then open the generated 
            <code>massif.out.%pid</code>
            &nbsp;in the visualizer. 
			<em>
                Gzip
			</em>
            &nbsp;or 
			<em>
                Bzip2
			</em>
            &nbsp;compressed massif files can also be opened transparently.&quot;
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/KDE/massif-visualizer" 
				class="external-link" 
				target="_blank" >
                massif-visualizer
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Created 16 years ago.
				</p>
			</li>
			<li>
				<p>
                    Updated 2 weeks ago.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://apps.kde.org/pt-br/massif_visualizer/" 
				class="external-link" 
				target="_blank" >
                massif-visualizer
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/core/sys/valgrind/" 
				class="external-link" 
				target="_blank" >
                core:sys/valgrind
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://valgrind.org/docs/manual/ms-manual.html" 
				class="external-link" 
				target="_blank" >
                Massif docs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://courses.cs.washington.edu/courses/cse326/05wi/valgrind-doc/ms_main.html" 
				class="external-link" 
				target="_blank" >
                Massif docs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=A5Rc4AwdaOA" 
				class="external-link" 
				target="_blank" >
                Valgrind demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=pvOYwxsDIJI" 
				class="external-link" 
				target="_blank" >
                Valgrind + GDB demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Tracks heap usage over time and generates memory snapshots.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platforms
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Linux
				</p>
				<ul>
					<li>
						<p>
                            Primary platform, best support
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    macOS
				</p>
				<ul>
					<li>
						<p>
                            Limited support, works on older versions without Apple Silicon
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Windows</s>
				</p>
				<ul>
					<li>
						<p>
                            Not natively supported.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Languages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    C
				</p>
				<ul>
					<li>
						<p>
                            Full support.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    C++
				</p>
				<ul>
					<li>
						<p>
                            Full support.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Odin
				</p>
				<ul>
					<li>
						<p>
                            Partial support, requires debug symbols and manual suppression files.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Rust
				</p>
				<ul>
					<li>
						<p>
                            Works, but may need 
                            <code>--tool=memcheck</code>
                            &nbsp;for leaks.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Other compiled languages
				</p>
				<ul>
					<li>
						<p>
                            Any language that compiles to native code can be analyzed but may need extra configuration.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How to use
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">valgrind --tool=massif ./your_program
massif-visualizer massif.out.*&nbsp;&nbsp;# GUI viewer
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Pros
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Shows peak memory usage and allocation trends.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="dr-memory" >
    Dr. Memory
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://drmemory.org/" 
				class="external-link" 
				target="_blank" >
                Dr Memory
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://drmemory.org/page_download.html" 
				class="external-link" 
				target="_blank" >
                Download
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=YI_TqmQf6-8" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platforms
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Windows.
				</p>
			</li>
			<li>
				<p>
                    Linux.
				</p>
			</li>
			<li>
				<p>
                    macOS.
				</p>
				<ul>
					<li>
						<p>
                            Alpha.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="coderr-code-gdb-lldb-time-travel-debugging" >
    <code>rr</code>
    &nbsp;+ GDB/LLDB (Time-Travel Debugging)
</h5>
<ul>
	<li>
		<p>
            Records execution and lets you 
			<strong>
                rewind
			</strong>
            &nbsp;to see when memory was freed.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How to use
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">rr record ./your_program&nbsp;&nbsp; # Records execution
rr replay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Debug with GDB/LLDB
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Key commands
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">watch -l *ptr&nbsp;&nbsp;# Break on UAF access
backtrace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# See who freed memory
</code></pre>
<h3
	id="stack-visualization-tools" >
    Stack Visualization Tools
</h3>
<h5
	id="gdb-lldb-stack-frames" >
    GDB/LLDB Stack Frames
</h5>
<ul>
	<li>
		<p>
            Inspect the call stack and local variables.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Key commands
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">bt full&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show full backtrace with locals
info locals&nbsp;&nbsp;# List all local variables
</code></pre>
<h5
	id="windbg-windows" >
    WinDbg (Windows)
</h5>
<ul>
	<li>
		<p>
            Advanced stack/heap debugging for Windows binaries.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Key commands
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">!heap -s&nbsp;&nbsp;&nbsp;&nbsp; # Show heap summary
!address&nbsp;&nbsp;&nbsp;&nbsp; # Memory layout overview
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=QuFJpH3My7A" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="godbolt" >
    Godbolt
</h5>
<ul>
	<li>
		<p>
            Visualize stack layout for small snippets (e.g., see how Odin arranges locals).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Paste Odin code 
					<a
						href="https://godbolt.org/" 
						class="external-link" 
						target="_blank" >
                        here
					</a>
                    &nbsp;(use 
                    <code>-emit-llvm</code>
                    &nbsp;to see IR).
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250423204721.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="advanced-tools" >
    Advanced Tools
</h3>
<h5
	id="vmmap-windows" >
    VMMap (Windows)
</h5>
<ul>
	<li>
		<p>
            Visualize memory regions (heaps, stacks, DLLs) of a running process.
		</p>
	</li>
</ul>
<h5
	id="platform-specific-apis" >
    Platform-Specific APIs
</h5>
<ul>
	<li>
		<p>
            Use low-level APIs for memory statistics:
		</p>
		<ul>
			<li>
				<p>
                    Windows: 
                    <code>GlobalMemoryStatusEx</code>
                    , 
                    <code>GetProcessMemoryInfo</code>
				</p>
			</li>
			<li>
				<p>
                    Linux: 
                    <code>/proc/self/status</code>
                    , 
                    <code>mallinfo</code>
				</p>
			</li>
			<li>
				<p>
                    Mac: 
                    <code>machtaskbasicinfo</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            These help track resident set size (RSS), virtual memory, and heap fragmentation.
		</p>
	</li>
</ul>
<h3
	id="asan-address-sanitizer" >
    ASan (Address Sanitizer)
</h3>
<ul>
	<li>
		<p>
            Accessing memory outside its scope causes a Segfault, but accessing memory inside another valid region of code can cause memory corruption.
		</p>
	</li>
	<li>
		<p>
            Because of this, ASan is used to check if accesses are within the array bounds, etc.
		</p>
	</li>
</ul>
<h5
	id="flags" >
    Flags
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/asan/asan_flags.inc#L169" 
				class="external-link" 
				target="_blank" >
                ASan LLVM flags
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;If you run it with 
                    <code>set ASAN_OPTIONS=help=1</code>
                    , it'll dump out a list on startup too.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags" 
				class="external-link" 
				target="_blank" >
                ASan Google flags
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Used in Odin:
		</p>
		<ul>
			<li>
				<p>
                    <code>set ASAN_OPTIONS=detect_stack_use_after_return=true:windows_hook_rtl_allocators=true</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="crash-report-registers" >
    Crash Report: Registers
</h5>
<ul>
	<li>
		<p>
			<strong>
                PC (Program Counter)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Also known as the Instruction Pointer (IP) in x86.
				</p>
			</li>
			<li>
				<p>
                    Points to the next instruction to be executed.
				</p>
			</li>
			<li>
				<p>
                    In ASan reports, the PC indicates where the crash (e.g., use-after-free, buffer overflow) occurred.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                BP (Base Pointer / Frame Pointer)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used to track the base of the current stack frame in functions.
				</p>
			</li>
			<li>
				<p>
                    Helps in unwinding the call stack during debugging.
				</p>
			</li>
			<li>
				<p>
                    May not always be present (e.g., in optimized builds where frame pointers are omitted).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SP (Stack Pointer)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Points to the top of the stack.
				</p>
			</li>
			<li>
				<p>
                    Used for managing function calls, local variables, and return addresses.
				</p>
			</li>
			<li>
				<p>
                    ASan uses this to detect stack-based buffer overflows or stack-use-after-return.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="warnings" >
    Warnings
</h5>
<ul>
	<li>
		<p>
            <code>Failed to use and restart external symbolizer!</code>
		</p>
		<ul>
			<li>
				<p>
                    Means that ASan could not use an external tool to convert raw memory addresses into readable file names, line numbers, and function names in your stack trace.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Why
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Missing Symbolizer Tool
						</p>
						<ul>
							<li>
								<p>
                                    ASan relies on an external program (like 
                                    <code>llvm-symbolizer</code>
                                    &nbsp;or 
                                    <code>addr2line</code>
                                    ) to map addresses to source code locations.
								</p>
							</li>
							<li>
								<p>
                                    If this tool is not installed or not in your 
                                    <code>PATH</code>
                                    , ASan can't resolve symbols properly.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Incorrect Path or Permissions
						</p>
						<ul>
							<li>
								<p>
                                    Even if the symbolizer exists, ASan might fail to execute it due to:
								</p>
								<ul>
									<li>
										<p>
                                            Wrong permissions (e.g., no execute access).
										</p>
									</li>
									<li>
										<p>
                                            Anti-virus blocking the tool.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Windows-Specific Issues
						</p>
						<ul>
							<li>
								<p>
                                    On Windows, ASan expects 
                                    <code>llvm-symbolizer.exe</code>
                                    &nbsp;to be available.
								</p>
							</li>
							<li>
								<p>
                                    If you're using MSVC, it might not be bundled by default.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            ASan Could Not Restart the Symbolizer
						</p>
						<ul>
							<li>
								<p>
                                    If the symbolizer crashes or times out, ASan gives up and shows this warning.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Fix
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Install 
							<a
								href="https://github.com/llvm/llvm-project/releases" 
								class="external-link" 
								target="_blank" >
                                LLVM
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="memory-growth-non-leaking-memory-accumulation-transient-memory-growth" >
    Memory Growth / Non-Leaking Memory Accumulation / Transient Memory Growth
</h3>
<ul>
	<li>
		<p>
            General increase in memory over time.
		</p>
	</li>
	<li>
		<p>
            Describes memory that builds up but is eventually released.
		</p>
	</li>
</ul>
<h5
	id="memory-visualization-tools" >
    Memory Visualization Tools
</h5>
<ul>
	<li>
		<p>
            See the section above.
		</p>
	</li>
</ul>
<h5
	id="snapshot-comparison" >
    Snapshot Comparison
</h5>
<ul>
	<li>
		<p>
            Take memory snapshots at key points:
		</p>
		<ul>
			<li>
				<p>
                    Before entering a problematic scene
				</p>
			</li>
			<li>
				<p>
                    During the scene at regular intervals
				</p>
			</li>
			<li>
				<p>
                    Just before scene transition
				</p>
			</li>
			<li>
				<p>
                    After unloading the scene
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Compare:
		</p>
		<ul>
			<li>
				<p>
                    Allocation counts
				</p>
			</li>
			<li>
				<p>
                    Peak usage
				</p>
			</li>
			<li>
				<p>
                    Object types / classes
				</p>
			</li>
			<li>
				<p>
                    Reference graphs (for managed environments)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="allocation-logging" >
    Allocation Logging
</h5>
<ul>
	<li>
		<p>
            Instrument your memory allocator (or use tools like 
            <code>malloc_logger</code>
            , 
            <code>jemalloc</code>
            , or 
            <code>tcmalloc</code>
            ) to:
		</p>
		<ul>
			<li>
				<p>
                    Log each allocation and deallocation
				</p>
			</li>
			<li>
				<p>
                    Track size, call stack, and timestamp
				</p>
			</li>
			<li>
				<p>
                    Detect allocation spikes or repeated allocations without matching frees
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="custom-counters-runtime-metrics" >
    Custom Counters / Runtime Metrics
</h5>
<ul>
	<li>
		<p>
            Add runtime metrics in your code:
		</p>
		<ul>
			<li>
				<p>
                    Count objects of specific types (e.g., textures, meshes, sounds)
				</p>
			</li>
			<li>
				<p>
                    Track size of loaded assets (e.g., total texture memory)
				</p>
			</li>
			<li>
				<p>
                    Monitor pool sizes, cache usage, or temporary buffers
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This helps detect unintended asset loading or buffer growth.
		</p>
	</li>
</ul>
<h5
	id="memory-pools-reuse-tracking" >
    Memory Pools / Reuse Tracking
</h5>
<ul>
	<li>
		<p>
            If you use memory pools, monitor:
		</p>
		<ul>
			<li>
				<p>
                    Pool size during and after scene
				</p>
			</li>
			<li>
				<p>
                    Pool reuse frequency
				</p>
			</li>
			<li>
				<p>
                    Accumulated allocations due to fragmentation or over-reservation
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="automated-scene-regression-test" >
    Automated Scene Regression Test
</h5>
<ul>
	<li>
		<p>
            Automate scene transitions and memory sampling to detect patterns:
		</p>
		<ul>
			<li>
				<p>
                    Run the scene in a loop, collect memory usage per iteration
				</p>
			</li>
			<li>
				<p>
                    Plot trends and detect growth plateaus or peaks
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="handles-instead-of-pointers" >
    Handles instead of Pointers
</h2>
<h3
	id="handlemap-or-hashmaps" >
    HandleMap or HashMaps?
</h3>
<ol>
	<li>
		<p>
            A handle_map_static.
		</p>
		<ul>
			<li>
				<p>
                    A handle is nothing more than an index while using a sparse array.
				</p>
			</li>
			<li>
				<p>
                    Super lightweight.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A 
            <code>map[int]Listener</code>
            , where each int is a &quot;handle.&quot;
		</p>
		<ul>
			<li>
				<p>
                    The int could be a random number, maybe obtained via Unix time.
				</p>
			</li>
		</ul>
	</li>
</ol>
<ul>
	<li>
		<p>
			<em>
                What’s the difference
			</em>
            ?
		</p>
		<ul>
			<li>
				<p>
                    HandleMap:
				</p>
				<ul>
					<li>
						<p>
                            Works really well when the object being stored is a pointer. It’s far safer.
						</p>
					</li>
					<li>
						<p
							class="line-emphasis" >
							<input
								type="checkbox" 
								disabled=""
>
                            Handle somehow requires it to also be stored inside the Listener.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    HashMap:
				</p>
				<ul>
					<li>
						<p>
                            Can be intrinsically lighter on memory.
						</p>
						<ul>
							<li>
								<p>
                                    Does not require the object stored in the HandleMap to contain a handle.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            No need to worry about static memory limitations.
						</p>
						<ul>
							<li>
								<p>
                                    The HashMap expands automatically.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Which to choose
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    HandleMap for storing pointers; always.
				</p>
			</li>
			<li>
				<p>
                    HashMap for non-pointers.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="articles" >
    Articles
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html" 
				class="external-link" 
				target="_blank" >
                Handles are the better pointers
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The article is very good.
				</p>
			</li>
			<li>
				<p>
                    It doesn’t show any code, but all concepts are explained and the advantages of the approach are clearly presented.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.gingerbill.org/article/2020/06/21/the-ownership-semantics-flaw/" 
				class="external-link" 
				target="_blank" >
                The Ownership Semantic Flaw
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Important conclusion about OOP and Ownership Semantics (OS):
				</p>
				<ul>
					<li>
						<p>
                            In general, most hard problems 
							<em>
                                cannot
							</em>
                            &nbsp;be solved at compile time; because of this, adding more and more concepts to the type system of the language will not help without adding extra costs. This does not mean ownership semantics are bad but that they are not a solution for many problems in that domain.
						</p>
					</li>
					<li>
						<p>
                            A lot of the problems related to responsibility are better solved with forms of “subsystems” within programs which handle groups of “things” and give out 
							<strong>
                                handles
							</strong>
                            &nbsp;to the “thing” instead of a direct reference.
						</p>
					</li>
					<li>
						<p>
                            This is related to the approach many people already use to bypass the borrow checker by using indices/handles.
						</p>
					</li>
					<li>
						<p>
                            Handles can contain a lot more information than a single number. A common approach is to store a generation number alongside the index in the handle. If a generation has expired, but the handle is used, the subsystem can return a dummy sentinel value and report an error.
						</p>
					</li>
					<li>
						<p>
                            Other approaches aim to reduce the need for ownership responsibility in the first place. By keeping data structures 
							<a
								href="https://en.wikipedia.org/wiki/Passive_data_structure" 
								class="external-link" 
								target="_blank" >
                                POD
							</a>
                            , trivially copyable, and with a useful zero value, you can rethink the problem and simplify code. This places more emphasis on the data and algorithms themselves rather than the relationships between objects and types.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Final conclusion of the article:
				</p>
				<ul>
					<li>
						<p>
                            The main argument is to demonstrate how OS and OOP both result in a &quot;(linear) value hierarchy of behavior, where the values act as agents.&quot;
						</p>
					</li>
					<li>
						<p>
                            Ownership semantics can be a useful tool for certain problems, but due to their underlying linear logic, they 
							<strong>
                                cannot
							</strong>
                            &nbsp;be used to express 
							<em>
                                non-linear
							</em>
                            &nbsp;problems, which leads people to try to bypass the concept entirely.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    [2025/07/03]
				</p>
				<ul>
					<li>
						<p>
                            I found the article very interesting.
						</p>
					</li>
					<li>
						<p>
                            I found it interesting how the use of handles was mentioned as something that could solve the problem and how it's used in Rust to work around linearity issues.
						</p>
					</li>
					<li>
						<p>
                            I don’t yet know the counterarguments to this Rust linearity problem, but if it’s really solved through some kind of handle trick, then it does seem like Rust hasn’t solved an important problem — it just complicates things unnecessarily.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="libraries" >
    Libraries
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/karl-zylinski/odin-handle-map" 
				class="external-link" 
				target="_blank" >
                handle-map-odin
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Very interesting and quite simple as well.
				</p>
			</li>
			<li>
				<p>
                    From what I saw through ChatGPT, its code follows a very classical handle system structure.
				</p>
			</li>
			<li>
				<p>
                    Check the README to understand the best usage recommendations, considering virtual memory limitations for the web.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Questions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
								checked="">
                            Use of 
                            <code>$HT</code>
                            &nbsp;in the definition of a handle_map.
						</p>
						<ul>
							<li>
								<p>
                                    See the explanation in the example in 
                                    <a href="Odin.html#Parametric Polymorphism (Parapoly)">
                                    Odin#Parametric Polymorphism (Parapoly)
                                    </a>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="usage-examples" >
    Usage examples
</h3>
<ul>
	<li>
		<p>
            The sokol-gfx API is an example of a C API that uses handles instead of pointers for rendering resource objects (buffers, images, shaders, …):
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/floooh/sokol#sokol_gfxh" 
						class="external-link" 
						target="_blank" >
                        sokol_gfx.h
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The Oryol Gfx module is a similar 3D API wrapper, but written in C++:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/floooh/oryol/tree/sokol-gfx/code/Modules/Gfx" 
						class="external-link" 
						target="_blank" >
                        Oryol Gfx Module
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The Oryol Animation extension module is a character animation system that keeps all its data in arrays:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/floooh/oryol-animation/tree/master/src/Anim" 
						class="external-link" 
						target="_blank" >
                        Oryol Anim Module
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="ownership-strategies-destruction-strategies" >
    Ownership Strategies / Destruction Strategies
</h2>
<ul>
	<li>
		<p>
            &quot;Ownership determines destruction strategy. The stronger the ownership, the simpler the destruction should be.&quot;
		</p>
	</li>
	<li>
		<p>
            The entity always owns the Object. Necessarily the Object should die when the entity dies.
		</p>
	</li>
</ul>
<h3
	id="motivation" >
    Motivation
</h3>
<h5
	id="disclaimer" >
    Disclaimer
</h5>
<ul>
	<li>
		<p>
            This analysis I'm making below is from a challenge I was facing in my Odin engine.
		</p>
	</li>
	<li>
		<p>
            It's more of a sketch of what was going on in my head at the time. Some things probably doesn't make much sense, unless in the proper context.
		</p>
	</li>
</ul>
<h5
	id="back-to-the-analysis" >
    Back to the analysis
</h5>
<ul>
	<li>
		<p>
            Annoying places that led me to think about the subject:
		</p>
		<ul>
			<li>
				<p>
                    bodies
				</p>
			</li>
			<li>
				<p>
                    layers.
				</p>
			</li>
			<li>
				<p>
                    tweens.
				</p>
			</li>
			<li>
				<p>
                    ~timers
				</p>
				<ul>
					<li>
						<p>
                            if I rework the system.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    world init / world deinit is very easy to forget.
				</p>
				<ul>
					<li>
						<p>
                            The 'struct-based lifetime aggregation' system helped a lot with this.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Post about the subject, focusing on the tween system:
		</p>
<pre><code class="language-odin" data-lang="odin"> eng.tween(
&nbsp;&nbsp;&nbsp;&nbsp; value = &some_vector_inside_an_entity,
&nbsp;&nbsp;&nbsp;&nbsp; end = some_vector,
&nbsp;&nbsp;&nbsp;&nbsp; duration_s = 0.1,
&nbsp;&nbsp;&nbsp;&nbsp; on_end = proc(tween: ^eng.Tween) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stuff
&nbsp;&nbsp;&nbsp;&nbsp; },
 )
</code></pre>
		<ul>
			<li>
				<p>
                    This is how I call a tween. The only thing it needs to do for this tween to work is call 
                    <code>eng.tween_system_init()</code>
                    &nbsp;at the beginning of the game, 
                    <code>eng.tween_system_deinit()</code>
                    &nbsp;at the end of it, and poll 
                    <code>eng.tween_system_update(dt)</code>
                    &nbsp;every frame for the 
                    <code>tween_system</code>
                    &nbsp;to process every tween stored when calling 
                    <code>eng.tween(..)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    When a tween ends processing, it gets removed automatically by the 
                    <code>eng.tween_system_update(dt)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The problem is kind of obvious: if the entity dies, the tween has a reference to a pointer inside the entity and the system crashes; UAF.
				</p>
			</li>
			<li>
				<p>
                    I came up with 5 major ideas to solve this problem, but I'm not really happy with them, or I don't know if they are good practice:
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                1 -
							</strong>
                            &nbsp;The entity stores the tween or a handle to the tween, so when the entity dies, I can manually ask to remove the tween and everything is ok.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                2 -
							</strong>
                            &nbsp;The tween doesn't store a pointer to some information in the entity, but a handle to it.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                3 -
							</strong>
                            &nbsp;The 
                            <code>tween_system</code>
                            &nbsp;doesn't exist. The entity has a tween stored, and MANUALLY calls a new function called 
                            <code>tween_process(&the_entity_tween)</code>
                            &nbsp;every frame of the entity 
                            <code>update</code>
                            . The tween doesn't need to be destroyed, as it doesn't own the value pointer. The existence of the tween is tightly linked to the existence of the entity. Just stop calling 
                            <code>tween_update</code>
                            &nbsp;and you won't have a UAF.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4 -
							</strong>
                            &nbsp;The entity doesn't care about the existence of the tween and can die in peace. The tween knows when the entity died and removes &quot;bad tweens&quot; and never tries to access freed memory. This could be done through:
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4.1 -
							</strong>
                            &nbsp;The entity has a &quot;pointer to lifetime handle&quot; inside of it. When calling the tween, it passes this handle as an argument for the tween. Every time an object stores this handle, its internal counter goes up by 1. When the entity dies, it changes the handle state to 
                            <code>dead = true</code>
                            &nbsp;and subtracts 1 from the counter. The 
                            <code>eng.tween_system_update(dt)</code>
                            &nbsp;checks if the handle is 
                            <code>dead</code>
                            &nbsp;or not; if so, it frees the &quot;bad tween&quot; and subtracts 1 from the counter. You got the idea. The counter only serves as a way to analyze the memory on game deinit.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4.2 -
							</strong>
                            &nbsp;The entity has an &quot;event struct&quot;. When calling the tween, it passes a pointer to the event so the tween can register a function pointer to be called when the event is emitted; the content inside this function pointer would be the destructor for the tween. When the entity dies, it calls something like 
                            <code>event_emit(the_entity_destructor_event)</code>
                            , and every system that subscribed to it will be destroyed. This kinda reminds me a bit of RAII.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    My thoughts on each strategy:
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                1, 2 and 3:
							</strong>
                            &nbsp;3 is clearly the best in terms of safety, but the problem with all 3 is that it makes the entity aware of the existence of a tween. The tween needs to know how many tweens will be used at the same time beforehand, or use an array that will need to be destructed. This makes the API look less pleasing. So many systems could use a tween and it sucks that it would be just a simple plug-n-play. I wish I could call 
                            <code>tween(..)</code>
                            &nbsp;and be done with it; let the 
                            <code>tween_system</code>
                            &nbsp;handle the rest.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                4.1 and 4.2:
							</strong>
                            &nbsp;They both sound a bit cheesy. The tween SHOULD die as the entity dies, as it has a pointer to it, but this strategy throws the responsibility to a 3rd party (a lifetime handle or event emitter) to manage the problem. This introduces a level of abstraction that I'm not too fond of.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Finally, if I were to choose, I'd go for the 
					<strong>
                        4.2
					</strong>
                    &nbsp;to clean the API, or go back to 
                    <code>3</code>
                    , if it ends up not being a good idea.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ideas" >
    Ideas
</h3>
<ol>
	<li>
		<p>
			<strong>
                The object is stored internally in the Entity
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
					<strong>
                        The Object doesn't have to worry about being destroyed, since no one outside the Entity references it
					</strong>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Access is intrinsically tied to the lifetime.
						</p>
					</li>
					<li>
						<p>
                            'Stateless' seems to be a word that defines this strategy.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Examples where I use this
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Timer system.
								</p>
								<ul>
									<li>
										<p>
                                            Need to advance time manually via 
                                            <code>timer_is_finished</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            In that case, I would do 
                                            <code>en.tween_update(^Tween, dt)</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    The dt is optional, like in the Timer case.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                For a Tween
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    The entity has a Tween_System
								</p>
								<ul>
									<li>
										<p>
                                            Basically to have an array instead of unitary values.
										</p>
									</li>
									<li>
										<p>
                                            Use a single update.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The entity has multiple Tweens
								</p>
								<ul>
									<li>
										<p>
                                            Requires that I know the maximum number of concurrent tweens I will have at any moment.
										</p>
									</li>
								</ul>
							</li>
						</ol>
						<ul>
							<li>
								<p>
                                    The Tween can still have on_enter and on_end functions, no problem.
								</p>
							</li>
							<li>
								<p>
                                    A Tween can be torn down and rebuilt however you want, so when a tween finishes I can create another tween immediately afterwards using the same Tween.
								</p>
							</li>
							<li>
								<p>
                                    The Tween never needs to be destroyed. It doesn't own anything.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        The Object must be destroyed manually during the Entity's destruction
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            When the Entity is destroyed, it calls the destruction of the Objects it owns.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Compared to &quot;The Object doesn't have to worry about being destroyed, since no one outside the Entity references it&quot;:
								</p>
								<ul>
									<li>
										<p>
                                            forgetting to update: no big deal.
										</p>
									</li>
									<li>
										<p>
                                            forgetting to destroy: memory leak and UAF.
										</p>
									</li>
									<li>
										<p>
                                            So this technique is less safe.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Examples where I use this
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Bodies / Body Wrappers system.
								</p>
								<ul>
									<li>
										<p>
                                            This system makes sense, since a Body 
											<strong>
                                                needs
											</strong>
                                            &nbsp;to be destroyed in Jolt anyway, so a destructor call is inevitable.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                For a Tween
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    The entity has a Tween_System
								</p>
								<ul>
									<li>
										<p>
                                            Basically to have an array instead of unitary values.
										</p>
									</li>
									<li>
										<p>
                                            Use a single update.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The entity has multiple Tweens
								</p>
								<ul>
									<li>
										<p>
                                            Requires that I know the maximum number of concurrent tweens I will have at any moment.
										</p>
									</li>
								</ul>
							</li>
						</ol>
						<ul>
							<li>
								<p>
                                    <code>eng.tween</code>
                                    &nbsp;returns a handle to the tween.
								</p>
							</li>
							<li>
								<p>
                                    This can be annoying for chaining tweens, having to always have a place to store the tween data.
								</p>
								<ul>
									<li>
										<p>
                                            In this case, I could implement a system where tween chaining happens without the need for on_end, via use of 
                                            <code>eng.tween_chain</code>
                                            , something like that.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The tween update is done automatically via 
                                    <code>eng.tween_update(dt)</code>
                                    , called directly by the Game Loop, each desired frame.
								</p>
							</li>
							<li>
								<p>
                                    Considering that a tween destroys itself automatically when finished, it can be weird to call the destruction of something that's already been destroyed.
								</p>
								<ul>
									<li>
										<p>
                                            <s>The tween might not destroy itself automatically, but that makes things a bit more annoying, increasing the verbosity of the tween callback to always destroy itself.</s>
										</p>
<pre><code class="language-odin" data-lang="odin"> proc(tween: ^Tween) {
&nbsp;&nbsp;&nbsp;&nbsp; eng.tween_destroy(tween)
&nbsp;&nbsp;&nbsp;&nbsp; //or
&nbsp;&nbsp;&nbsp;&nbsp; eng.tween_destroy(tween.value)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if using a handle.
 }
</code></pre>
										<ul>
											<li>
												<p>
                                                    This changes NOTHING. Explicitly destroying the tween in the callback still requires me to destroy it when destroying the entity. Nothing changes.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Use of handles
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The tween doesn't store a pointer to some information in the entity, but a handle to the information.
						</p>
					</li>
					<li>
						<p>
                            This means that the entity must have the handle stored, so when the entity dies, the handle is correctly removed.
						</p>
					</li>
					<li>
						<p>
                            The tween system then tries to tween the data, but when attempting to 
                            <code>get</code>
                            &nbsp;the information inside the handle, it realizes the handle is now dead and deletes the tween.
						</p>
					</li>
					<li>
						<p>
                            When calling the tween:
						</p>
						<ul>
							<li>
								<p>
                                    We need to pass the handle for the data, instead of the data; so no new argument is added.
								</p>
							</li>
							<li>
								<p>
                                    We 
									<em>
                                        maybe
									</em>
                                    &nbsp;need to pass the handle_map related to the handle.
								</p>
								<ul>
									<li>
										<p>
                                            An alternative is to use a global handle_map.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Disadvantages
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    I have to store a handle for every pointer I want to tween, which means duplicating the data.
								</p>
								<ul>
									<li>
										<p>
                                            I would have a value and a pointer to this value, wrapped around a handle.
										</p>
									</li>
									<li>
										<p>
                                            That's really weird.
										</p>
									</li>
									<li>
										<p>
                                            Another option would be to store the data somewhere else and just have the handle around for the entity, but this could be even weirder.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    A handle_map for 
                                    <code>rawptr</code>
                                    &nbsp;could be an annoyance for generic procedures, such as the tween_system.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                About the handle map
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    The handle_map has the same (or higher) lifetime as the tween system.
								</p>
								<ol>
									<li>
										<p>
                                            The handle_map is implicit, without having to pass it around:
										</p>
										<ul>
											<li>
												<p>
                                                    This means that a generic handle_map would have to be used, storing 
                                                    <code>rawptr</code>
                                                    .
												</p>
												<ul>
													<li>
														<p>
                                                            This could be an annoyance for the Tween system, as I wouldn't have many ways of checking if the data for the 
                                                            <code>value</code>
                                                            &nbsp;and 
                                                            <code>end</code>
                                                            &nbsp;is compatible with each other.
														</p>
													</li>
													<li>
														<p>
                                                            Overall, it's a bit annoying for generics.
														</p>
													</li>
												</ul>
											</li>
										</ul>
										<ol>
											<li>
												<p>
                                                    The handle_map is part of the game.
												</p>
												<ul>
													<li>
														<p>
                                                            ok.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>The handle_map is global</s>.
												</p>
												<ul>
													<li>
														<p>
                                                            I don't think anything outside the game would want to tween something.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>The handle_map is part of the scene</s>.
												</p>
												<ul>
													<li>
														<p>
                                                            When exiting the scene, the handle_map is cleared.
														</p>
													</li>
													<li>
														<p>
                                                            If the handle_map used by the tween_system is 
															<em>
                                                                exclusively
															</em>
                                                            &nbsp;the handle_map of the current scene, that means that we can't tween something during a scene change, as this means that the whole tween_system would be cleared on a scene deinit.
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            <s>The handle_map is explicit, having to pass it around</s>:
										</p>
										<ul>
											<li>
												<p>
                                                    This increases the argument for calling a tween by one, and also makes the tween store the handle_map, besides the handle.
												</p>
											</li>
											<li>
												<p>
                                                    The handle_map could be more specific, but this is not an advantage necessarily, as:
												</p>
												<ul>
													<li>
														<p>
                                                            Most of the data processed by the tween is different from each other; could be a f32, Vec2, int, etc.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    I don't see this strategy having any real advantage.
												</p>
											</li>
										</ul>
										<ol>
											<li>
												<p>
                                                    The handle_map is part of the scene.
												</p>
												<ul>
													<li>
														<p>
                                                            This would make the most sense, as the only reason for having an explicit handle_map is to have many options for handle_maps.
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
								<p>
                                    <s>The entity has a handle_map</s>.
								</p>
								<ul>
									<li>
										<p>
                                            If the entity dies, the handle_map dies as well, crashing the whole system and making the use of the handle pointless.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
					<li>
						<p>
							<em>
                                Advantages
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The entity doesn't need to store any tween. We can have any amount of tweens, without any problems.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Disadvantages
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Forgetting to 
                                    <code>remove</code>
                                    &nbsp;the handle will cause a UAF, as the tween system will be able to access the data that the handle represents.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<strong>
                        Game State
					</strong>
                    </s>:
				</p>
				<ul>
					<li>
						<p>
                            &quot;Carrying around a 
                            <code>Game_State</code>
                            &nbsp;object which stores all game data so deleting any resource goes through a single place.&quot;
						</p>
					</li>
					<li>
						<p>
                            The Game State stores the tweens and the entities.
						</p>
					</li>
					<li>
						<p>
                            The entity is destroyed through the Game State 
                            <code>game_state_del_entity(gs: ^Game_State, ent: Entity_Id)</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Which will also delete all data associated with that entity.
								</p>
							</li>
							<li>
								<p>
                                    It can remove its tween because it has access to 
                                    <code>gs</code>
                                    ; the entity needs to have an indicator of which tween belongs to the entity either way.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            My thinking:
						</p>
						<ul>
							<li>
								<p>
                                    &quot;The entity doesn't own anything&quot;
								</p>
								<ul>
									<li>
										<p>
                                            Idk if this is true. When the entity dies some other piece of data MUST die as well.
										</p>
									</li>
									<li>
										<p>
                                            It's a different way to think of ownership. The entity doesn't really own the tween, but the tween must die with the entity; so who owns the data? I mean, I can't say it doesn't have an owner, as that would imply that something like the GameState owns the tween, which isn't true as only destroying the data when deinitializing the Game State would cause a UAF.
										</p>
									</li>
									<li>
										<p>
                                            Seems like the entity and tween are tied together, but if you look the other way around, if a tween dies that doesn't imply that an entity should die.
										</p>
									</li>
									<li>
										<p>
                                            The entity clearly has a higher hierarchy than the tween when it comes to ownership, so I can safely say that the tween belongs to the entity.
										</p>
									</li>
									<li>
										<p>
                                            So, with that in mind, what justifies the tween being out of the entity? What good does it bring to the destruction of the tween?
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Sameness:
								</p>
								<ul>
									<li>
										<p>
                                            The entity needs to have a handle for the tween stored or the whole tween itself.
										</p>
										<ul>
											<li>
												<p>
                                                    Storing only a handle could be a little more problematic if the tween is not killed once the entity dies; but yet, that depends on how the fetch for the tweens is made in the 
                                                    <code>game_state_tweens :: proc(gs: Game_State) -&gt; []Tween</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Possible advantages:
								</p>
								<ul>
									<li>
										<p>
                                            Forgetting to clean up a tween will not cause a UAF, as the entity stored the tween and will take the tween with it when dying.
										</p>
										<ul>
											<li>
												<p>
                                                    This could cause a memory leak if the tween allocates memory in heap and we forget to clean it up, but it will not cause a crash.
												</p>
											</li>
											<li>
												<p>
                                                    THO, this is only possible due to the system being stateless.
												</p>
											</li>
											<li>
												<p>
                                                    This is also true for other strategies that store the tween inside the entity.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Possible disadvantages:
								</p>
								<ul>
									<li>
										<p>
                                            Same disadvantages of other strategies that have to store the tween or a handle to the tween in the entity:
										</p>
										<ul>
											<li>
												<p>
                                                    I need to know how many tweens I'll have upfront.
												</p>
											</li>
											<li>
												<p>
                                                    The call for a tween could be problematic. If I call a new tween using the same tween_handle or the same tween, while the tween is being used for some other tweening, then this could fail somehow; I would have to overwrite what I asked the tween to do, or just fail the call altogether and say it couldn't be made; this is terrible as it introduces error handling in a simple system.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Being stateless means that every frame is 
											<em>
                                                necessary
											</em>
                                            &nbsp;to fetch all tweens from everywhere in the system, to finally update each one of them.
										</p>
										<ul>
											<li>
												<p>
                                                    This is a problem when you consider that a tween could be anywhere, not only inside entities.
												</p>
											</li>
											<li>
												<p>
                                                    It could be a mess to look up these tweens.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Finally:
						</p>
						<ul>
							<li>
								<p>
                                    The entity still needs to store a reference to the tween, while also the entity needs to know upfront how many tweens it will use, etc.
								</p>
							</li>
							<li>
								<p>
                                    Even though your strategy could be used, it falls within the realm of the strategies 
									<strong>
                                        1
									</strong>
                                    &nbsp;and 
									<strong>
                                        3
									</strong>
                                    . I'm looking for a way that the entity doesn't care about the tweening. The tween could live in a general global space, being created freely, BUT still having its lifetime tied to the lifetime of a pointer the tween holds.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Some people tried to defend the strategy, but I still thought it was garbage and it doesn't deserve to be considered. It doesn't solve anything, keeps the problems of having to store the tweens internally and complicates the whole memory system a lot.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
            <s>
			<strong>
                The Object is stored in a global system
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            ANY pointer is a problematic pointer, since the lifetime of the pointer will always be shorter than the lifetime of the tween system. This requires extra ways to destroy the tween before the pointer stored inside the tween is used.
						</p>
					</li>
				</ul>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
					<strong>
                        Use of Events to destroy Objects
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The main characteristic of this system is that the destructor can be defined right when creating the Object, so you know 
							<em>
                                when
							</em>
                            &nbsp;it will be destroyed; that is, when the event is emitted.
						</p>
					</li>
					<li>
						<p>
							<em>
                                For tweens
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        Why I stopped using this for tweens
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            I had big lifetime problems across the whole game in the past, but after removing global variables this problem was greatly reduced, diminishing the arguments in favor of using events.
										</p>
									</li>
									<li>
										<p>
                                            An internal system greatly reduces the complexity of the problem, making it much easier to read and understand what's happening.
										</p>
									</li>
									<li>
										<p>
                                            The existence of a destructor for a tween is strange. The tween destroys itself on completion, causing the &quot;destructor&quot; 
											<strong>
                                                not to be called in 99% of cases
											</strong>
                                            . In the vast majority of cases, event listeners were registered in the destructor and unregistered without ever being used.
										</p>
										<ul>
											<li>
												<p>
                                                    The destructor was just an anti-crash system; its purpose was only to handle an exception where tweens still existed while the pointer of their custom_data no longer existed.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        After doing
									</em>
                                    :
								</p>
<pre><code class="language-odin" data-lang="odin"> // tween()
 eng.tween(
&nbsp;&nbsp;&nbsp;&nbsp; destructor = &personagem.destructor,
&nbsp;&nbsp;&nbsp;&nbsp; value = &personagem.arm3.pos_world,
&nbsp;&nbsp;&nbsp;&nbsp; end = arm_relative_target_trans_arm3.pos,
&nbsp;&nbsp;&nbsp;&nbsp; duration_s = 0.1,
&nbsp;&nbsp;&nbsp;&nbsp; custom_data = personagem,
&nbsp;&nbsp;&nbsp;&nbsp; on_end = proc(tween: ^eng.Tween) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; personagem := cast(^Personagem_User)tween.custom_data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; personagem.arm3.is_stepping = false
&nbsp;&nbsp;&nbsp;&nbsp; }
 )

 // Internal to tween()
 ok: bool
 tween.destructor_handle, ok = event_add_listener(destructor, wrap_procedure(tween_delete), rawptr(value))
 if !ok {
&nbsp;&nbsp;&nbsp;&nbsp; log.errorf("%v(%v): Failed to add event listener.", loc.procedure, loc.line)
&nbsp;&nbsp;&nbsp;&nbsp; return nil
 }
</code></pre>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Use of an external Lifetimes Manager system
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Use a Lifetime_Handle as an indicator if the entity was destroyed.
						</p>
					</li>
					<li>
						<p>
                            Each of the individual object systems checks that Lifetime_Handle and will destroy the Object if it notices that the handle was marked as 
                            <code>dead</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The check must be done in a loop; normally in the object's system loop.
						</p>
					</li>
					<li>
						<p>
                            This means it is intrinsically a 
							<em>
                                polling
							</em>
                            &nbsp;system.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    If the polling is not done, then the entity will never be destroyed.
								</p>
								<ul>
									<li>
										<p>
                                            This is a problem that happens every time the game closes: the Lifetime_Handle is marked as dead, but no final polling is done to destroy the objects.
										</p>
									</li>
									<li>
										<p>
                                            This can cause memory leaks.
										</p>
										<ul>
											<li>
												<p>
                                                    Although the Lifetime_Handles system can clean up the memory of each indicated thing, this system doesn't have enough information about how the destruction of each element should be performed. Besides, of course, that would be a pain to implement.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</li>
</ol>
<h3
	id="improvements-applied" >
    Improvements Applied
</h3>
<h5
	id="stage-1-clarity-in-the-definition-of-lifetimes" >
    Stage 1: Clarity in the definition of lifetimes
</h5>
<ul>
	<li>
		<p>
            &quot;Grouped element thinking and systems (n+1)&quot;.
		</p>
	</li>
	<li>
		<p>
            &quot;struct-based lifetime aggregation&quot;.
		</p>
		<ul>
			<li>
				<p>
                    It was the solution I used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Ideally I don't want to have any data stored in the global scope, except if .
		</p>
	</li>
	<li>
		<p>
            All data should belong to a struct that represents its lifetime.
		</p>
	</li>
	<li>
		<p>
			<em>
                What does this help with?
			</em>
		</p>
		<ul>
			<li>
				<p>
                    It gets closer to n+1
				</p>
			</li>
			<li>
				<p>
                    Helps not to forget about initializations and deinitalizations.
				</p>
			</li>
			<li>
				<p>
                    Makes some lifetimes explicit, making it harder to make UAF mistakes.
				</p>
			</li>
			<li>
				<p>
                    Makes it much easier to use arena allocators for those objects with the same lifetime.
				</p>
			</li>
			<li>
				<p>
                    I think it also makes explicit what has a 1-frame lifetime, for use in the temp allocator or another custom arena allocator.
				</p>
			</li>
			<li>
				<p>
                    This can be very useful when dealing with a low-level render API.
				</p>
			</li>
			<li>
				<p>
                    Overall: it seems to be an improvement in code clarity and quality.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Does this help the tween/external systems in any way?
			</em>
		</p>
		<ul>
			<li>
				<p>
                    I don't think so.
				</p>
			</li>
			<li>
				<p>
                    The storage of the data is done using another allocator, regardless.
				</p>
			</li>
			<li>
				<p>
                    The data stored in the system cannot use the same allocator as the entity, since the system should not die when the entity dies.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Post-change impressions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The system helps to visualize improper access problems, that's all.
				</p>
			</li>
			<li>
				<p>
                    In a nutshell, it's a way to stay aware of grouped lifetimes, it's &quot;grouped thinking&quot;.
				</p>
			</li>
			<li>
				<p>
                    Therefore it's ok, even if it might not be the 
					<em>
                        best
					</em>
                    &nbsp;way to visualize/handle the problem.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="stage-2-purity-of-functions-via-removal-of-global-variables-and-global-structs" >
    Stage 2: Purity of functions, via removal of global variables and global structs
</h5>
<ul>
	<li>
		<p>
            The answer about lifetimes lies in the absence of global variables or global structs.
		</p>
	</li>
	<li>
		<p>
			<em>
                Why I came up with this idea
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    When the lifetime of something ends, I wanted it to be impossible to access it.
				</p>
			</li>
			<li>
				<p>
                    This reminded me of Scopes, which do exactly that.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Notable improvements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Multithreading is safer.
				</p>
				<ul>
					<li>
						<p>
                            The net_connections thread doesn't have access to the game thread's content, since the game is on the worker_game stack.
						</p>
					</li>
					<li>
						<p>
                            This is the only big advantage in the separation between 
                            <code>global</code>
                            &nbsp;and 
                            <code>game</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    There's also a gain in function purity, of course.
								</p>
							</li>
							<li>
								<p>
                                    If the game didn't have one dedicated network thread, then 
                                    <code>game</code>
                                    &nbsp;would be 
									<em>
                                        basically
									</em>
                                    &nbsp;a 
                                    <code>global</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Even if 
                                    <code>game</code>
                                    &nbsp;is a global variable (like in the crypted core) I would still pass the variable as a function parameter (for sure), for purity, helping to clarify what the function uses.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    I liked the solution for RPCs and Jobs, surprisingly.
				</p>
				<ul>
					<li>
						<p>
                            The only thing done is passing the game as an extra arg in the context, via 
                            <code>context.user_ptr</code>
                            ; that's it.
						</p>
					</li>
					<li>
						<p>
                            Simple, easy to understand, without requiring changes to the RPC or Job code.
						</p>
						<ul>
							<li>
								<p>
                                    If it weren't for that, I would have to pass the game as a procedure arg, having to modify the RPC and Job code accordingly.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="garbage-collection" >
    Garbage Collection
</h3>
<h5
	id="automatic-reference-counting-arc" >
    Automatic Reference Counting (ARC)
</h5>
<ul>
	<li>
		<p>
            The object has a field that represents the object's count.
		</p>
	</li>
	<li>
		<p>
            Expensive.
		</p>
	</li>
	<li>
		<p>
            There are checks every time the object is modified.
		</p>
	</li>
	<li>
		<p>
            Cycles are problematic.
		</p>
	</li>
</ul>
<h5
	id="mark-and-sweep" >
    Mark and Sweep
</h5>
<ul>
	<li>
		<p>
            Has no problems with cycles.
		</p>
	</li>
	<li>
		<p>
            There's no need to check every time the object is modified, but the checks are done during the GC Pause, which is where the GC pauses the app to look for garbage.
		</p>
	</li>
</ul>
<h2
	id="initialization" >
    Initialization
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=xt1KNDmOYqA" 
				class="external-link" 
				target="_blank" >
                Casey - Against SmartPointers, RAII, Rust Borrow Checker; &quot;becoming the n+1 programmer&quot;
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/screenshot_2025-03-12_003018.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="strategies-n" >
    Strategies (n)
</h5>
<ul>
	<li>
		<p>
            RAII.
		</p>
	</li>
	<li>
		<p>
            Smart Pointers.
		</p>
	</li>
	<li>
		<p>
            new/delete malloc/free.
		</p>
	</li>
	<li>
		<p>
            try/catch.
		</p>
	</li>
	<li>
		<p>
            Rust borrow checker.
		</p>
	</li>
</ul>
<h5
	id="strategies-n1-grouped-element-thinking-and-systems" >
    Strategies (n+1) (Grouped element thinking and systems)
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
            The entity has a block allocator, where all memory used by the entity uses that block allocator.
		</p>
		<ul>
			<li>
				<p>
                    Sounds nice, but doesn't seem to solve the problem of memory being used in other systems.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            Every frame has an arena allocator. Everything that should exist for a single frame uses that allocator.
		</p>
		<ul>
			<li>
				<p>
                    Casey and Jon use this.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            Use PEAK memory to know what size the block should have.
		</p>
		<ul>
			<li>
				<p>
                    Very interesting.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="strategies-n2" >
    Strategies (n+2)
</h5>
<ul>
	<li>
		<p>
            ZII and Stubs as alternative ways of memory structure and error handling.
		</p>
	</li>
	<li>
		<p>
            Casey about Stubs:
		</p>
		<ul>
			<li>
				<p>
                    Stubs are just a block of zeroes.
				</p>
			</li>
			<li>
				<p>
                    &quot;If you failed to push something into the arena, you just get a Stub back, it's all zeroed&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;When something comes back, just produces a Stub instead of something real, and everything still works&quot;.
				</p>
			</li>
			<li>
				<p>
                    The code doesn't check if the struct is a Stub. The code just assumes the data is something you can use and uses it.
				</p>
			</li>
			<li>
				<p>
                    For example, when using a 0 Handle, I don't return null, I just return a zeroed entity.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Stubs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Stubs are minimal or fake implementations of functions, classes or modules, used mainly for testing, incremental development or simulating external dependencies.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp"> #include &lt;iostream&gt;
 
 // Real function not yet implemented, we use a temporary stub
 int calcularImposto(float salario) {
&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "[STUB] Function not yet implemented." &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp; return 0; // Returns a fixed value to continue development
 }
 
 int main() {
&nbsp;&nbsp;&nbsp;&nbsp; float salario = 5000;
&nbsp;&nbsp;&nbsp;&nbsp; int imposto = calcularImposto(salario);
&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Calculated tax: " &lt;&lt; imposto &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 }
</code></pre>
	</li>
</ul>
<h3
	id="zii-zero-initialization-is-initialization" >
    ZII (Zero Initialization Is Initialization)
</h3>
<h5
	id="comparing-to-raii" >
    Comparing to RAII
</h5>
<ul>
	<li>
		<p>
            Unlike RAII, ZII does not inherently imply resource ownership or cleanup in the destructor.
		</p>
	</li>
	<li>
		<p>
            It's about 
			<em>
                safe default values
			</em>
            , not lifecycle management.
		</p>
	</li>
	<li>
		<p>
            Both are part of the broader design goal of:
		</p>
		<ul>
			<li>
				<p>
                    Avoiding uninitialized or unsafe state.
				</p>
			</li>
			<li>
				<p>
                    Ensuring predictable object behavior starting at construction.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Because of this shared 
			<strong>
                initialization focus
			</strong>
            , they're often discussed together in contexts like:
		</p>
		<ul>
			<li>
				<p>
                    C++ safety idioms.
				</p>
			</li>
			<li>
				<p>
                    Codebases transitioning from C-style to C++.
				</p>
			</li>
			<li>
				<p>
                    Embedded/safety-critical environments.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Their conceptual scopes differ, but they 
			<strong>
                both leverage constructors
			</strong>
            &nbsp;to achieve safety and predictability, hence the mental association.
		</p>
	</li>
</ul>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            ZII is true by default for every system.
		</p>
	</li>
	<li>
		<p>
            The way you program is by letting zero always be an acceptable value.
		</p>
	</li>
	<li>
		<p>
            ZII is a principle that defends that variables be initialized to zero or default values as soon as they are created. This reduces the risk of accessing undefined values.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Main characteristics
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Prevents undefined behavior when accessing uninitialized variables.
				</p>
			</li>
			<li>
				<p>
                    Applicable mainly to primitive types and arrays.
				</p>
			</li>
			<li>
				<p>
                    Avoids hard-to-debug errors.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages of ZII
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reduces errors related to uninitialized values.
				</p>
			</li>
			<li>
				<p>
                    Ensures predictability in program behavior.
				</p>
			</li>
			<li>
				<p>
                    Useful for data structures and dynamically allocated memory.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<pre><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;

class Example {
public:
&nbsp;&nbsp;&nbsp;&nbsp;int x = 0;&nbsp;&nbsp;// Zero initialization
&nbsp;&nbsp;&nbsp;&nbsp;double y = 0.0;
};

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;Example e;
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "x: " &lt;&lt; e.x &lt;&lt; ", y: " &lt;&lt; e.y &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</code></pre>
<pre><code class="language-cpp" data-lang="cpp">int arr[10] = {};&nbsp;&nbsp;// All elements are initialized to 0
</code></pre>
<h3
	id="raii-resource-acquisition-is-initialization" >
    RAII (Resource Acquisition Is Initialization)
</h3>
<h5
	id="about-and-meaning" >
    About and Meaning
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=LlZWqkCMdfk" 
				class="external-link" 
				target="_blank" >
                Bjarne Stroustrup - &quot;RAII is the best thing the language has&quot;
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Constructors and Destructors pairs is the best feature implemented in the language&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;Sometimes this comes out in the name of RAII&quot;.
				</p>
				<ul>
					<li>
						<p>
                            &quot;Not the greatest name I've ever heard&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The phrase 
			<strong>
                “Resource Acquisition Is Initialization”
			</strong>
            &nbsp;emphasizes that:
		</p>
		<ul>
			<li>
				<p>
                    Acquiring a resource happens at the same time the object is initialized (constructed).
				</p>
			</li>
			<li>
				<p>
                    This ties the resource's lifetime to the object’s lifetime.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Why Destruction Is Implied
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Although destruction is not named, it's 
					<em>
                        implied by C++'s object lifetime rules
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If the resource is acquired during initialization, and the object controls the resource.
						</p>
					</li>
					<li>
						<p>
                            Then releasing it must naturally occur when the object is destroyed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    C++ deterministic destruction ensures that destructors are called at the end of scope, enabling automatic cleanup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Therefore, RAII relies on both construction and destruction, even if the name only mentions the construction side.
		</p>
	</li>
</ul>
<h5
	id="principles" >
    Principles
</h5>
<ul>
	<li>
		<p>
            Associates resource acquisition (like memory, file handles, mutexes, etc.) with the 
			<em>
                construction
			</em>
            &nbsp;of an object, and resource release with its 
			<em>
                destruction
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Scope-Based Lifetime
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In C++, objects declared with automatic storage duration (i.e., local stack variables) are automatically destroyed when they go out of scope.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Destructor Role
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The destructor is the mechanism used to release resources. Since C++ guarantees that destructors of local objects are called when the scope exits (either normally or via exception), this ensures deterministic cleanup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Why it &quot;implies&quot; a destructor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    For RAII to work, a resource-managing object must reliably release its resource.
				</p>
			</li>
			<li>
				<p>
                    C++ destructors are guaranteed to be called when the object’s scope ends.
				</p>
			</li>
			<li>
				<p>
                    Therefore, RAII relies on this guarantee, and the destructor becomes the point where the resource is released.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=LU62nNsigjs" 
				class="external-link" 
				target="_blank" >
                Demonstration of RAII in 
                <code>unique_ptr</code>
                &nbsp;and 
                <code>mutex_guard</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's all about scope.
				</p>
			</li>
			<li>
				<p>
                    Exiting the scope calls a function automatically.
				</p>
			</li>
			<li>
				<p>
                    That's it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

class FileHandler {
private:
&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream file;
public:
&nbsp;&nbsp;&nbsp;&nbsp;FileHandler(const std::string& filename) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.open(filename);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!file.is_open()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("Failed to open the file.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;~FileHandler() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.close();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;void write(const std::string& text) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file &lt;&lt; text &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;}
};

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileHandler fh("test.txt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fh.write("RAII ensures the file is closed.");
&nbsp;&nbsp;&nbsp;&nbsp;} catch (const std::exception& e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// The FileHandler destructor closes the file automatically.
&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</code></pre>
<h5
	id="negative-points" >
    Negative points
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=bJUnCXEIie0" 
				class="external-link" 
				target="_blank" >
                RAII in C++ and comparison with Odin
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Odin is soooo much better, wow.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Makes you allocate and deallocate simple things individually.
		</p>
	</li>
	<li>
		<p>
            Sometimes you want to be explicit about things and just free a bunch of things at once.
		</p>
		<ul>
			<li>
				<p>
                    In C++ that would require you to not use the language as it was intended in some ways.
				</p>
			</li>
			<li>
				<p>
                    In C++ you have to accept the complexity of RAII.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=OP_w_oEU1Wk" 
				class="external-link" 
				target="_blank" >
                Casey Muratori - RAII
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Automatic destructors make you think about failure and error handling in a bad way.
				</p>
			</li>
			<li>
				<p>
                    Unwinding the object through a destructor is not going to make the error go away. The error needs to be handled depending on the circumstance.
				</p>
			</li>
			<li>
				<p>
                    You need to think about failures and program around it.
				</p>
			</li>
			<li>
				<p>
                    In RAII you spend a lot of time writing code to handle failures that will never happen, but the same errors blow up.
				</p>
			</li>
			<li>
				<p>
                    RAII doesn't solve the problem they needed to solve.
				</p>
			</li>
			<li>
				<p>
                    Some people criticized his quote, for not making a distinction between RAII and error handling.
				</p>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/docs/Things/Linux/Linux.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/docs/Things/Multithreading/Multithreading.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                🧑‍💻 built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                📅 2025-10-21 .&nbsp;&nbsp;2025-10-30 🚀
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#virtual-memory" >
                            Virtual Memory
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#memory-alignment" >
                            Memory Alignment
						</a>
						<ul>
							<li>
								<a
									href="#motivation" >
                                    Motivation
								</a>
							</li>
							<li>
								<a
									href="#memory-access" >
                                    Memory Access
								</a>
							</li>
							<li>
								<a
									href="#size" >
                                    Size
								</a>
							</li>
							<li>
								<a
									href="#offset" >
                                    Offset
								</a>
							</li>
							<li>
								<a
									href="#stride" >
                                    Stride
								</a>
							</li>
							<li>
								<a
									href="#alignment" >
                                    Alignment
								</a>
							</li>
							<li>
								<a
									href="#unaligned-memory" >
                                    Unaligned Memory
								</a>
							</li>
							<li>
								<a
									href="#std140-and-std430" >
                                    std140 and std430
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#allocators" >
                            Allocators
						</a>
						<ul>
							<li>
								<a
									href="#linear-arena-allocator" >
                                    Linear / Arena Allocator
								</a>
							</li>
							<li>
								<a
									href="#stack-allocator-lifo" >
                                    Stack Allocator (LIFO)
								</a>
							</li>
							<li>
								<a
									href="#pool-allocator" >
                                    Pool Allocator
								</a>
							</li>
							<li>
								<a
									href="#free-list-based-allocator" >
                                    Free List Based Allocator
								</a>
							</li>
							<li>
								<a
									href="#buddy-memory-allocation" >
                                    Buddy Memory Allocation
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#tools-for-memory-analysis" >
                            Tools for Memory Analysis
						</a>
						<ul>
							<li>
								<a
									href="#memory-visualization-tools" >
                                    Memory Visualization Tools
								</a>
							</li>
							<li>
								<a
									href="#stack-visualization-tools" >
                                    Stack Visualization Tools
								</a>
							</li>
							<li>
								<a
									href="#advanced-tools" >
                                    Advanced Tools
								</a>
							</li>
							<li>
								<a
									href="#asan-address-sanitizer" >
                                    ASan (Address Sanitizer)
								</a>
							</li>
							<li>
								<a
									href="#memory-growth-non-leaking-memory-accumulation-transient-memory-growth" >
                                    Memory Growth / Non-Leaking Memory Accumulation / Transient Memory Growth
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#handles-instead-of-pointers" >
                            Handles instead of Pointers
						</a>
						<ul>
							<li>
								<a
									href="#handlemap-or-hashmaps" >
                                    HandleMap or HashMaps?
								</a>
							</li>
							<li>
								<a
									href="#articles" >
                                    Articles
								</a>
							</li>
							<li>
								<a
									href="#libraries" >
                                    Libraries
								</a>
							</li>
							<li>
								<a
									href="#usage-examples" >
                                    Usage examples
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#ownership-strategies-destruction-strategies" >
                            Ownership Strategies / Destruction Strategies
						</a>
						<ul>
							<li>
								<a
									href="#motivation" >
                                    Motivation
								</a>
							</li>
							<li>
								<a
									href="#ideas" >
                                    Ideas
								</a>
							</li>
							<li>
								<a
									href="#improvements-applied" >
                                    Improvements Applied
								</a>
							</li>
							<li>
								<a
									href="#garbage-collection" >
                                    Garbage Collection
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#initialization" >
                            Initialization
						</a>
						<ul>
							<li>
								<a
									href="#zii-zero-initialization-is-initialization" >
                                    ZII (Zero Initialization Is Initialization)
								</a>
							</li>
							<li>
								<a
									href="#raii-resource-acquisition-is-initialization" >
                                    RAII (Resource Acquisition Is Initialization)
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/docs.js" >
		</script>
	</body>
</html>
