<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.55658.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sizes.html" >
                                    Sizes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-fixing-artifacts.html" >
                                    Fixing Artifacts
								</a>
								<ul>
									<li>
										<a
											href="#concepts" >
                                            Concepts
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#debugging" >
                                            Debugging
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#solutions-proposal" >
                                            Solutions proposal
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#texture-bleeding" >
                                            Texture Bleeding
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#pixel-art-shimmering" >
                                            Pixel Art Shimmering
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#pixel-art-camera-smoothness" >
                                            Pixel Art Camera Smoothness
										</a>
									</li>
								</ul>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Fixing Artifacts
					</h1>
					<p>
						<time
							datetime="2023-07-10" >
                            üïí Created: 2023-07-10
						</time>
						<time
							datetime="2026-02-16" >
                            | Updated: 2026-02-16
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<h3
	id="concepts" >
    Concepts
</h3>
<h5
	id="camera-zoom" >
    Camera Zoom
</h5>
<ul>
	<li>
		<p>
            &quot;How much do we magnify the world on top of the base pixel density?&quot;
		</p>
	</li>
	<li>
		<p>
            Zoom is a camera parameter, not part of the meter‚Üîpixel definition.
		</p>
	</li>
</ul>
<pre><code class="language-txt" data-lang="txt">screen_pixels =
&nbsp;&nbsp;&nbsp;&nbsp;world_meters
&nbsp;&nbsp;&nbsp;&nbsp;√ó PIXELS_PER_METER
&nbsp;&nbsp;&nbsp;&nbsp;√ó zoom
</code></pre>
<ul>
	<li>
		<p>
            Zoom belongs to the projection matrix, not the view matrix.
		</p>
	</li>
	<li>
		<p>
            Multiply by zoom only when applying camera magnification; also inside projection.
		</p>
	</li>
</ul>
<h5
	id="texel-uv-in-texel-space" >
    Texel (UV in Texel Space)
</h5>
<pre><code class="language-glsl" data-lang="glsl">vec2 texel = uv * tex_size;
</code></pre>
<ul>
	<li>
		<p>
            uv is assumed to be normalized texture coordinates in [0,1].
		</p>
	</li>
	<li>
		<p>
            Multiplying by texture size converts from normalized UV space to texel space.
		</p>
	</li>
	<li>
		<p>
            Example: if texture is 256√ó256 and uv = (0.5, 0.5), then texel = (128, 128).
		</p>
	</li>
	<li>
		<p>
            Integer part:
		</p>
		<ul>
			<li>
				<p>
                    Which texel.
				</p>
			</li>
			<li>
				<p>
                    <code>floor(texel)</code>
                    &nbsp;return the integer part.
				</p>
				<ul>
					<li>
						<p>
                            Ex:
						</p>
						<ul>
							<li>
								<p>
                                    (128.3, 64.9) -&gt; (128, 64)
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Fractional part:
		</p>
		<ul>
			<li>
				<p>
                    where inside the texel
				</p>
			</li>
			<li>
				<p>
                    <code>fract(texel)</code>
                    &nbsp;returns the fractional part 
                    <code>(x - floor(x))</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Ex:
						</p>
					</li>
					<li>
						<p>
                            (10.2,&nbsp;&nbsp; 5.7) -&gt; (0.2, 0.7).
						</p>
					</li>
					<li>
						<p>
                            (128.0, 64.0) -&gt; (0.0, 0.0).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Naming:
				</p>
				<ul>
					<li>
						<p>
                            <code>vec2 texel_phase = fract(texel);</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    In signal processing and wave math, the fractional position within a repeating unit is commonly called the phase.
								</p>
							</li>
							<li>
								<p>
                                    &quot;This is the phase inside the repeating texel grid.&quot;.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>vec2 texel_frac = fract(texel);</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>vec2 texel_offset = fract(texel);</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="debugging" >
    Debugging
</h3>
<h5
	id="fractional-screen_pixels_per_texel" >
    Fractional screen_pixels_per_texel
</h5>
<ul>
	<li>
		<p>
            The only truly stable configuration is 
            <code>screen_pixels_per_texel = integer</code>
            ; Any fractional scale ‚Üí shimmer when camera moves.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">pixels_per_texel_x = viewport_width / (camera_world_width * texture_width_in_texels)
</code></pre>
<ul>
	<li>
		<p>
            If this is not an integer, you will get shimmer.
		</p>
	</li>
</ul>
<h5
	id="sub-texel-phase" >
    Sub-texel Phase
</h5>
<pre><code class="language-glsl" data-lang="glsl">vec2 tex_size = textureSize(texs[idx], 0);
vec2 texel = uv * tex_size;
vec2 texel_phase = fract(texel);
frag_color = vec4(texel_phase, 0.0, 1.0);
</code></pre>
<ul>
	<li>
		<p>
            Good Results:
		</p>
		<ul>
			<li>
				<p>
                    If everything were perfectly stable, you would see:
				</p>
				<ul>
					<li>
						<p>
                            solid colors inside sprites
						</p>
					</li>
					<li>
						<p>
                            clean step changes at texel boundaries
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Bad Results:
		</p>
		<ul>
			<li>
				<p>
                    Seeing a ‚Äúcrazy pattern‚Äù means:
				</p>
				<ul>
					<li>
						<p>
                            UVs are landing at fractional texel positions
						</p>
					</li>
					<li>
						<p>
                            and they vary across pixels in a non-uniform way
						</p>
					</li>
					<li>
						<p>
                            This proves your screen pixels are not mapping 1:1 to texels.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Results
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2026-02-15)
				</p>
				<ul>
					<li>
						<p>
                            Normal camera zoom:
						</p>
						<ul>
							<li>
								<p>
                                    There's a bunch of big squares that move in the opposite direction of the movement.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Floored camera zoom:
						</p>
						<ul>
							<li>
								<p>
                                    There's no longer big squares, but now very tiny ones, like pixels.
								</p>
							</li>
							<li>
								<p>
                                    The pattern color changes when moving, but seems more stable than the version before, expect for the fact that often I get some lines across the whole screen when moving, like everything is collapsing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Set camera zoom to 1.0:
						</p>
						<ul>
							<li>
								<p>
                                    Huge squares that keep changing color when moving. Sometimes I get lines inside those big squares.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Floored camera zoom + floored camera pos + floored sprite pos:
						</p>
						<ul>
							<li>
								<p>
                                    With the screen on 1280x720:
								</p>
								<ul>
									<li>
										<p>
                                            Everything seems to be in monochromatic tones of green, that slightly change in brightness when moving.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With the screen maximized to QuadHD screen (with the window bar on top, and task bar in the bottom):
								</p>
								<ul>
									<li>
										<p>
                                            The screen is filled with big horizontal rectangles that flicker when moving.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fractional-scaling-uv-interpolation" >
    Fractional Scaling / UV Interpolation
</h5>
<pre><code class="language-glsl" data-lang="glsl">vec2 tex_size = textureSize(texs[idx], 0);
vec2 texel = uv * tex_size;
frag_color = vec4(floor(texel) / 32.0, 0.0, 1.0);
</code></pre>
<ul>
	<li>
		<p>
            Each pixel inside the same texel gets the same value ‚Üí creates blocky regions.
		</p>
	</li>
	<li>
		<p>
            Clean square blocks ‚Üí UVs are well-behaved
		</p>
	</li>
	<li>
		<p>
            Skewed/parallelogram blocks ‚Üí UV interpolation or projection issues
		</p>
	</li>
	<li>
		<p>
            Wobbling/shimmering blocks ‚Üí precision or derivative problems
		</p>
	</li>
	<li>
		<p>
			<em>
                Results
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2026-02-16)
				</p>
				<ul>
					<li>
						<p>
                            Normal camera zoom / floored camera zoom / camera zoom set to 1.0:
						</p>
						<ul>
							<li>
								<p>
                                    Stable pattern, where every sprite seems to have a UV gradient visual, with no change when moving the camera.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="rate-of-uv-change-per-pixel" >
    Rate of UV change per pixel
</h5>
<pre><code class="language-glsl" data-lang="glsl">vec2 tex_size = textureSize(texs[idx], 0);
vec2 texel = uv * tex_size;
vec2 fw = fwidth(texel);
frag_color = vec4(vec3(length(fw)), 1.0);
</code></pre>
<ul>
	<li>
		<p>
            Good Results:
		</p>
<pre><code class="language-glsl" data-lang="glsl">length(fw) ‚âà 1.0
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">fw ‚âà (1, 1)
length = sqrt(1¬≤ + 1¬≤)
length(fw) ‚âà ‚àö2 ‚âà 1.414
</code></pre>
		<ul>
			<li>
				<p>
                    Meaning:
				</p>
				<ul>
					<li>
						<p>
                            1 ‚Üí minification
						</p>
					</li>
					<li>
						<p>
                            &lt;1 ‚Üí magnification
						</p>
					</li>
					<li>
						<p>
                            non-uniform values ‚Üí fractional scaling
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    When you display 1.414 in an unclamped color channel:
				</p>
				<ul>
					<li>
						<p>
                            values &gt; 1 are clamped to 1 in the framebuffer
						</p>
					</li>
					<li>
						<p>
                            but if your actual fw is, say, (0.7, 0.7):
						</p>
						<ul>
							<li>
								<p>
                                    <code>length ‚âà 0.99 ‚Üí gray</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            So the color alone is not diagnostic.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Results
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    (2026-02-16)
				</p>
				<ul>
					<li>
						<p>
                            Stable gray color.
						</p>
					</li>
					<li>
						<p>
                            The gray tone changes depending on the camera zoom, such as with zoom 1.0, the screen is white, and zoom 5.0, the screen is a darkish gray.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="projection-misalignment" >
    Projection Misalignment
</h5>
<pre><code class="language-glsl" data-lang="glsl">frag_color = vec4(fract(gl_FragCoord.xy), 0, 1);
</code></pre>
<ul>
	<li>
		<p>
            Good Results:
		</p>
		<ul>
			<li>
				<p>
                    Perfectly stable pattern
				</p>
			</li>
			<li>
				<p>
                    No movement when camera moves
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Bad Results:
		</p>
		<ul>
			<li>
				<p>
                    If it shifts ‚Üí projection misalignment.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec2 f = abs(fract(gl_FragCoord.xy) - 0.5);
float dist = max(f.x, f.y);
frag_color = vec4(vec3(dist * 4.0), 1.0);
</code></pre>
<ul>
	<li>
		<p>
            Interpretation
		</p>
		<ul>
			<li>
				<p>
                    dark = pixel center aligned (good)
				</p>
			</li>
			<li>
				<p>
                    bright = between pixels (bad)
				</p>
			</li>
			<li>
				<p>
                    If brightness changes when the camera moves ‚Üí confirmed source.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Results
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2026-02-16) With or without camera zoom rounding:
				</p>
				<ul>
					<li>
						<p>
                            Stable green/yellow pattern.
						</p>
					</li>
					<li>
						<p>
                            No bright changes.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="orthographic-projection-half-pixel-bias" >
    Orthographic Projection Half-pixel Bias
</h5>
<ul>
	<li>
		<p>
            Pattern for testing:
		</p>
<pre><code class="language-glsl" data-lang="glsl">// Frag
vec2 tex_size = textureSize(texs[idx], 0); 
vec2 texel_uv = uv * tex_size;
vec2 phase = fract(texel_uv); 
frag_color = vec4(phase, 0.0, 1.0);
</code></pre>
	</li>
	<li>
		<p>
            Setup 1:
		</p>
<pre><code class="language-odin" data-lang="odin">// CPU
ppm_x := PIXELS_PER_METER * camera._effective_zoom.x 
ppm_y := PIXELS_PER_METER * camera._effective_zoom.y 
camera.proj_matrix = proj_matrix_orthographic_vulkan_classical_z_finite( 
&nbsp;&nbsp;&nbsp;&nbsp;left = (-f32(camera.origin.x) + 0.5) / ppm_x, 
&nbsp;&nbsp;&nbsp;&nbsp;right = ( f32(camera.extent.w - camera.origin.x) + 0.5) / ppm_x, 
&nbsp;&nbsp;&nbsp;&nbsp;top = (-f32(camera.origin.y) + 0.5) / ppm_y, 
&nbsp;&nbsp;&nbsp;&nbsp;bottom = ( f32(camera.extent.h - camera.origin.y) + 0.5) / ppm_y, 
&nbsp;&nbsp;&nbsp;&nbsp;near = 0.0, far = 1.0
) 
</code></pre>
	</li>
	<li>
		<p>
            Setup 2:
		</p>
<pre><code class="language-glsl" data-lang="glsl">vec2 pixel_size = 2.0 / globals.framebuffer_size;
gl_Position.xy += pixel_size * 0.5;
</code></pre>
	</li>
	<li>
		<p>
			<em>
                Result
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2026-02-16)
				</p>
				<ul>
					<li>
						<p>
                            Camera zoom floored + sprite pos
						</p>
					</li>
					<li>
						<p>
                            The pattern with both setups is really chaotic, with a bunch of vertical and horizontal lines.
						</p>
					</li>
					<li>
						<p>
                            In Vulkan, unlike old D3D9-era pipelines, you usually do NOT need a half-pixel bias if your orthographic matrix is mathematically correct.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="orthographic-projection-is-not-enforcing-integer-pixel-mapping" >
    Orthographic projection is not enforcing integer pixel mapping
</h5>
<ul>
	<li>
		<p>
            Even with:
		</p>
		<ul>
			<li>
				<p>
                    floored camera
				</p>
			</li>
			<li>
				<p>
                    floored zoom
				</p>
			</li>
			<li>
				<p>
                    nearest filtering
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            You will still shimmer if your projection allows fractional screen coverage.
		</p>
	</li>
</ul>
<h5
	id="hidpi-os-compositor-scaling" >
    HiDPI / OS compositor scaling
</h5>
<ul>
	<li>
		<p>
            They must match exactly:
		</p>
		<ul>
			<li>
				<p>
                    swapchain extent
				</p>
			</li>
			<li>
				<p>
                    framebuffer size
				</p>
			</li>
			<li>
				<p>
                    viewport size
				</p>
			</li>
			<li>
				<p>
                    window size
				</p>
			</li>
			<li>
				<p>
                    orthographic projection dimensions
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Results
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    With the screen on 1280x720:
				</p>
<pre><code class="language-txt" data-lang="txt">window.extent:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Extent{w = 1280, h = 720} 
window.swapchain.extent: Extent2D{width = 1280, height = 720} 
glfw.GetWindowSize:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1280 720) 
glfw.GetWindowFrameSize: (8, 31, 8, 8) 
glfw.GetFramebufferSize: (1280 720) 
monitor_size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extent{w = 2560, h = 1440}
</code></pre>
			</li>
			<li>
				<p>
                    With the screen maximized to QuadHD screen (with the window bar on top, and task bar in the bottom):
				</p>
<pre><code class="language-txt" data-lang="txt">window.extent:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Extent{w = 2560, h = 1377} 
window.swapchain.extent: Extent2D{width = 2560, height = 1377} 
glfw.GetWindowSize:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2560 1377) 
glfw.GetWindowFrameSize: (8, 31, 8, 8) 
glfw.GetFramebufferSize: (2560 1377) 
monitor_size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extent{w = 2560, h = 1440}
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="vertex-positions-after-transform" >
    Vertex Positions after transform
</h5>
<ul>
	<li>
		<p>
            Even if you snap sprites in world space, after projection they may land between pixels.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// Vertex
vec4 clip = proj * view * model * vec4(pos, 1.0);
vec2 ndc = clip.xy / clip.w;
debug_screen = (ndc * 0.5 + 0.5) * framebufferSize;
gl_Position = clip;

// Frag
frag_color = vec4(fract(debug_screen), 0.0, 1.0);
</code></pre>
<ul>
	<li>
		<p>
            Good Results:
		</p>
		<ul>
			<li>
				<p>
                    Nearly constant color per triangle.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Bad Results:
		</p>
		<ul>
			<li>
				<p>
                    Noisy or shifting pattern ‚Üí subpixel positioning confirmed.
				</p>
			</li>
			<li>
				<p>
                    If not near integer pixel centers ‚Üí that‚Äôs the shimmer source.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Results
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2026-02-16)
				</p>
				<ul>
					<li>
						<p>
                            With or without round camera zoom:
						</p>
						<ul>
							<li>
								<p>
                                    Billions of stable squares with gradient colors; some of these squares:
								</p>
								<ul>
									<li>
										<p>
                                            <img src="assets/2026-02-16_09-10-29.png" width="400" >
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Seeing a grid of stable squares means:
								</p>
								<ul>
									<li>
										<p>
                                            derivatives are constant per pixel quad (expected)
										</p>
									</li>
									<li>
										<p>
                                            but not equal to 1
										</p>
									</li>
									<li>
										<p>
                                            and vary spatially
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    This almost always indicates:
								</p>
								<ul>
									<li>
										<p>
                                            Screen pixels do not map 1:1 to texels
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    More specifically:
								</p>
								<ul>
									<li>
										<p>
                                            each screen pixel footprint spans a fractional number of texels
										</p>
									</li>
									<li>
										<p>
                                            so nearest filtering flips between neighbors as the camera moves
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fractional-viewport" >
    Fractional Viewport
</h5>
<pre><code class="language-c" data-lang="c">viewport.x = 0
viewport.y = 0
viewport.width = framebuffer_width
viewport.height = framebuffer_height
</code></pre>
<ul>
	<li>
		<p>
            Fractional viewport ‚Üí shimmer.
		</p>
	</li>
</ul>
<h5
	id="sampler" >
    Sampler
</h5>
<ul>
	<li>
		<p>
            Must be:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">minFilter = NEAREST
magFilter = NEAREST
mipmapMode = NEAREST
</code></pre>
<ul>
	<li>
		<p>
            CLAMP_TO_EDGE
		</p>
	</li>
	<li>
		<p>
            no mipmaps
		</p>
	</li>
	<li>
		<p>
            no anisotropy
		</p>
	</li>
</ul>
<h3
	id="solutions-proposal" >
    Solutions proposal
</h3>
<ul>
	<li>
		<p>
			<strong>
                General recommendations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use texelFetch whenever possible.
				</p>
				<ul>
					<li>
						<p>
                            texelFetch(sampler2D, ivec2(coord), 0) is the most predictable way to read a texel without sampler filtering or dependency on derivatives. Combine with integer coords: ivec2(floor(uv * tex_size)).
						</p>
					</li>
					<li>
						<p>
                            This avoids fwidth/derivative pitfalls and is cheap and deterministic.
						</p>
					</li>
					<li>
						<p>
                            <code>texelFetch</code>
                            &nbsp;is typically cheaper and avoids derivative hardware work. fwidth and smoothstep per-fragment add cost.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Rotations / scaling:
				</p>
				<ul>
					<li>
						<p>
                            Pixel-perfect nearest sampling + rotation is inherently problematic. If you need rotated pixel-art, either pre-rotate frames (artwork side) or accept interpolation/AA. The derivative-based AA solutions reduce shimmering but change the crisp look.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                GPU: Use 
                <code>.CLAMP_TO_EDGE</code>
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    General recommendation to avoid texture bleeding, or add padding to atlases.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                GPU: Anisotropy OFF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2026-02-15) I'm not sure if this helps or not, but it was said to leave it off, so I did.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                GPU: Filter NEAREST
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                GPU: No mipmaps
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                CPU: Snap the projection matrix, via snap the camera zoom
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">camera._effective_zoom.x = math.round(camera._effective_zoom.x)
camera._effective_zoom.y = math.round(camera._effective_zoom.y)
</code></pre>
		<ul>
			<li>
				<p>
                    (2026-02-15) This helps.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                CPU: Snap the camera
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use 
                    <code>camera_pos = round(camera_pos * render_upscale) / render_upscale</code>
                    , to make a coordinate snap for 
                    <code>camera.target</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>camera_pos = floor(camera_pos * pixels_per_unit) / pixels_per_unit;</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    I used to use this in RayLib. It helped a bit.
				</p>
			</li>
			<li>
				<p>
                    (2026-02-15)
				</p>
				<ul>
					<li>
						<p>
                            I have to snap the camera as well, otherwise the main character will flicker in the direction of the movement. This is expected, as I'm just snapping the matrix of the sprite when drawing, not its actual 
                            <code>.pos</code>
                            , so the camera uses the unsnapped position for 
                            <code>_game.camera.pos = dyn_body_trans.pos</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Floored sprites, floored camera, floored zoom:
						</p>
						<ul>
							<li>
								<p>
                                    Sub-texel phase pattern:
								</p>
								<ul>
									<li>
										<p>
                                            The pattern was improved.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                CPU: Snap geometry
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">mat := mat
mat[0, 2] = (math.floor(mat[0, 2] * PIXELS_PER_METER * 5.0) / 5.0) / PIXELS_PER_METER
mat[1, 2] = (math.floor(mat[1, 2] * PIXELS_PER_METER * 5.0) / 5.0) / PIXELS_PER_METER
</code></pre>
		<ul>
			<li>
				<p>
                    (2026-02-15)
				</p>
				<ul>
					<li>
						<p>
                            I have to snap the camera as well, otherwise the main character will flicker in the direction of the movement. This is expected, as I'm just snapping the matrix of the sprite when drawing, not its actual 
                            <code>.pos</code>
                            , so the camera uses the unsnapped position for 
                            <code>_game.camera.pos = dyn_body_trans.pos</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Using both &quot;Snap geometry&quot; and &quot;snap the camera&quot; creates some gaps between sprites, which is not good. Either way, the shimmering doesn't seem to improve.
						</p>
					</li>
					<li>
						<p>
                            Floored sprites, floored camera, floored zoom:
						</p>
						<ul>
							<li>
								<p>
                                    Sub-texel phase pattern:
								</p>
								<ul>
									<li>
										<p>
                                            The pattern was improved.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                Fragment Shader: uv_aa_linear
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        uv_aa_linear
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Source: https://www.shadertoy.com/view/ltBfRD
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">vec2 tex_size = textureSize(texs[idx], 0);
vec2 texel = uv * tex_size; 
vec2 texel_floor = floor(texel + 0.5);
float width = 1.0;&nbsp;&nbsp;// Options: 1 pixel filter, 1.5 pixel filter, 2.0 pixel filter
uv = (texel_floor + clamp((texel - texel_floor) / fwidth(texel) / width, -0.5, 0.5)) / tex_size;
albedo = texture(texs[idx], uv);
</code></pre>
				<ul>
					<li>
						<p>
                            (2026-02-15)
						</p>
						<ul>
							<li>
								<p>
                                    With nearest filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    No weird edges around the sprites.
												</p>
											</li>
											<li>
												<p>
                                                    Sub-texel phase pattern:
												</p>
												<ul>
													<li>
														<p>
                                                            The pattern was improved. The green flickers less when moving.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With linear filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    Gives a weird edge around sprites.
												</p>
											</li>
											<li>
												<p>
                                                    Sub-texel phase pattern:
												</p>
												<ul>
													<li>
														<p>
                                                            The pattern was improved. The green flickers less when moving.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        uv_aa_smoothstep
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Source: https://www.shadertoy.com/view/ltBfRD
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">vec2 tex_size = textureSize(texs[idx], 0);
vec2 texel = uv * tex_size; 
vec2 texel_floor = floor(texel + 0.5);
vec2 texel_fract = fract(texel + 0.5);
float width = 1.0;&nbsp;&nbsp;// Options: 1 pixel filter, 1.5 pixel filter, 2.0 pixel filter
vec2 texel_aa = fwidth(texel) * width * 0.5;
texel_fract = smoothstep(
&nbsp;&nbsp;&nbsp;&nbsp;vec2(0.5) - texel_aa,
&nbsp;&nbsp;&nbsp;&nbsp;vec2(0.5) + texel_aa,
&nbsp;&nbsp;&nbsp;&nbsp;texel_fract
);
uv = (texel_floor + texel_fract - 0.5) / tex_size;
albedo = texture(texs[idx], uv);
</code></pre>
				<ul>
					<li>
						<p>
                            (2026-02-15)
						</p>
						<ul>
							<li>
								<p>
                                    With nearest filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    Gives a weird edge around sprites.
												</p>
											</li>
											<li>
												<p>
                                                    Sub-texel phase pattern:
												</p>
												<ul>
													<li>
														<p>
                                                            The pattern was improved. The green flickers less when moving.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With linear filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    Gives a weird edge around sprites.
												</p>
											</li>
											<li>
												<p>
                                                    Sub-texel phase pattern:
												</p>
												<ul>
													<li>
														<p>
                                                            The pattern was improved. The green flickers less when moving.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        What they do
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Use 
                            <code>fwidth</code>
                            &nbsp;to create an anti-aliased transition zone across texel boundaries; one uses a clamped linear blend, the other uses smoothstep.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Pros
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Reduced shimmering and softer transitions when the texture mapping footprint covers multiple texels.
						</p>
					</li>
					<li>
						<p>
                            Smoothstep gives visually nicer blending with fewer harsh transitions.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Cons
					</em>
				</p>
				<ul>
					<li>
						<p>
                            More expensive per-fragment.
						</p>
					</li>
					<li>
						<p>
                            Requires careful tuning of 
                            <code>width</code>
                            &nbsp;and correct handling of 
                            <code>fwidth == 0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Blending breaks &quot;pure&quot; nearest look; you get soft edges that may not fit some pixel-art aesthetics.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        When to use
					</em>
				</p>
				<ul>
					<li>
						<p>
                            If you permit a small amount of filtering/anti-aliasing to reduce shimmering for rotated/scaled sprites where snapping is not viable.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<strong>
                Vertex Shader: Inset UVs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Purpose
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Prevents sampling outside the sprite region in the atlas.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        It fixes
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            atlas edge bleed
						</p>
					</li>
					<li>
						<p>
                            neighbor tile leakage
						</p>
					</li>
					<li>
						<p>
                            precision at UV borders
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        It does not fix
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            shimmering during camera motion
						</p>
					</li>
					<li>
						<p>
                            subpixel raster instability
						</p>
					</li>
					<li>
						<p>
                            pixel-perfect alignment issues
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Use it if
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            sprites come from a tight atlas
						</p>
					</li>
					<li>
						<p>
                            you use linear filtering (especially)
						</p>
						<ul>
							<li>
								<p>
                                    With nearest filtering, this is usually secondary but still good hygiene.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            you see seams even when camera is static
						</p>
					</li>
					<li>
						<p>
                            tiles touch in the atlas
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Vertex Shader:
				</p>
<pre><code class="language-glsl" data-lang="glsl">// Original UV
frag_tex_coord = (vertex_tex_coord * pc.uv_scale) + pc.uv_pos;

// Adding Inset to UV
uint idx = nonuniformEXT(pc.tex_idx);
if (idx != NO_TEXTURE) {
&nbsp;&nbsp;&nbsp;&nbsp;vec2 tex_size = textureSize(texs[idx], 0);
&nbsp;&nbsp;&nbsp;&nbsp;// Half-texel in UV space
&nbsp;&nbsp;&nbsp;&nbsp;vec2 half_texel = 0.5 / tex_size;
&nbsp;&nbsp;&nbsp;&nbsp;// Apply symmetric inset
&nbsp;&nbsp;&nbsp;&nbsp;frag_tex_coord += mix(half_texel, -half_texel, vertex_tex_coord);
}
</code></pre>
				<ul>
					<li>
						<p>
                            (2026-02-15)
						</p>
						<ul>
							<li>
								<p>
                                    For texture bleeding:
								</p>
								<ul>
									<li>
										<p>
                                            This fixed the issue, without other solutions required.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With nearest filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    Sub-texel phase pattern:
												</p>
												<ul>
													<li>
														<p>
                                                            The pattern showed a lot of big squares with different colors.
														</p>
													</li>
													<li>
														<p>
                                                            The pattern was therefore worsen.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With linear filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    Everything looks blurred.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<strong>
                Vertex Shader: Position snapping in clip space
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Purpose
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Ensures rasterization happens on exact pixel boundaries.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        It fixes
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            seams that appear only while moving
						</p>
					</li>
					<li>
						<p>
                            nearest-filter flicker
						</p>
					</li>
					<li>
						<p>
                            pixel-perfect instability
						</p>
					</li>
					<li>
						<p>
                            subpixel camera artifacts
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        It does not fix
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            atlas bleed from bad UVs
						</p>
					</li>
					<li>
						<p>
                            mip bleeding
						</p>
					</li>
					<li>
						<p>
                            repeat wrap leakage
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Snaps vertex positions in clip/NDC ‚Üí pixel space to pixel centers.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Pros
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Keeps the whole sprite aligned to the pixel grid (prevents sub-pixel motion of the quad as a whole).
						</p>
					</li>
					<li>
						<p>
                            Very cheap and deterministic.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Cons / caveats
					</em>
				</p>
				<ul>
					<li>
						<p>
                            If you snap per-vertex (without treating the quad as a single unit) you can distort the quad (vertices snap differently) ‚Äî do snapping per-instance / per-sprite origin so the whole quad shifts the same amount.
						</p>
					</li>
					<li>
						<p>
                            Rotations and non-uniform scaling: snapping in screen-space will quantize the transformed geometry and can produce visually wrong shapes for rotated/scaled sprites.
						</p>
					</li>
					<li>
						<p>
                            Must keep UV mapping consistent with the snapped transform (otherwise texture appears offset by fractional pixels).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        When to use
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Static, axis-aligned sprites or translations where you can snap the sprite origin once (best if computed per-instance on CPU or in vertex shader once per sprite).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Practical change
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Snap the sprite origin (or instance translation) rather than each quad vertex. That keeps the quad intact.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;Since you are doing 2D with nearest, you should snap positions, not UVs.&quot;
				</p>
				<ul>
					<li>
						<p>
                            In the vertex shader after projection (or before), snap to pixel grid.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">vec4 vertex_pos_cs = globals.proj_matrix * vertex_pos_vs;
vertex_pos_cs.xy = floor(vertex_pos_cs.xy * viewport_size) / viewport_size;
&nbsp;&nbsp;&nbsp;&nbsp;// Snapping positions.
&nbsp;&nbsp;&nbsp;&nbsp;// convert to pixel space, snap, convert back
gl_Position = vertex_pos_cs;
</code></pre>
				<ul>
					<li>
						<p>
                            The safer pixel snap (post-projection) is:
						</p>
						<ul>
							<li>
								<p>
                                    Without the proper transform, snapping can be slightly off.
								</p>
							</li>
							<li>
								<p>
                                    Version 1:
								</p>
<pre><code class="language-glsl" data-lang="glsl">vec4 vertex_pos_cs = globals.proj_matrix * vertex_pos_vs;

// convert NDC ‚Üí pixel space
vec2 pixel_pos = (vertex_pos_cs.xy * 0.5 + 0.5) * viewport_size;

// snap
pixel_pos = floor(pixel_pos) + 0.5;

// back to NDC
vertex_pos_cs.xy = ((pixel_pos / viewport_size) * 2.0 - 1.0);

gl_Position = vertex_pos_cs;
</code></pre>
								<ul>
									<li>
										<p>
                                            (2026-02-15) Gives a crazy wobble in the whole screen.
										</p>
										<ul>
											<li>
												<p>
                                                    Problem: 
                                                    <code>vertex_pos_cs</code>
                                                    &nbsp;is different for each vertex.
												</p>
											</li>
											<li>
												<p>
                                                    That deforms the quad slightly every frame as rounding flips.
												</p>
											</li>
											<li>
												<p>
                                                    You should snap once per sprite origin; do not snap per vertex.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Version 2:
								</p>
								<ul>
									<li>
										<p>
                                            For when the world coordinates are in pixels.
										</p>
									</li>
								</ul>
<pre><code class="language-glsl" data-lang="glsl">// Origin
vec3 origin_pos3_ws = pc.model_matrix * vec3(0.0, 0.0, 1.0);
vec4 origin_pos_ws&nbsp;&nbsp;= vec4(origin_pos3_ws.x, origin_pos3_ws.y, 0.0, origin_pos3_ws.z);
vec4 origin_pos_vs&nbsp;&nbsp;= globals.view_matrix * origin_pos_ws;
vec4 origin_pos_cs&nbsp;&nbsp;= globals.proj_matrix * origin_pos_vs;
vec2 origin_pos_ps&nbsp;&nbsp;= (origin_pos_cs.xy * 0.5 + 0.5) * globals.viewport_size;
&nbsp;&nbsp;&nbsp;&nbsp;// Pixel Space

// snap ONCE per sprite
origin_pos_ps = floor(origin_pos_ps) + 0.5;

vec2 vertex_pos_ps = (vertex_pos_cs.xy * 0.5 + 0.5) * globals.viewport_size;
&nbsp;&nbsp;&nbsp;&nbsp;// Pixel Space

// offset in pixels from origin
vec2 offset_ps = vertex_pos_ps - ((origin_pos_cs.xy * 0.5 + 0.5) * globals.viewport_size);
// rebuild final pixel position
vec2 final_ps = origin_pos_ps + offset_ps;
// back to NDC
vec2 final_ndc = (final_ps / globals.viewport_size) * 2.0 - 1.0;

gl_Position = vec4(final_ndc, vertex_pos_cs.z, vertex_pos_cs.w);
frag_pos_ws = vec2(vertex_pos_ws);
</code></pre>
								<ul>
									<li>
										<p>
                                            (2026-02-15) Wabbles differently, but still wabbles.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Version 3:
								</p>
								<ul>
									<li>
										<p>
                                            For when the world coordinates are in pixels.
										</p>
									</li>
								</ul>
<pre><code class="language-glsl" data-lang="glsl">vec2 vertex_pos_ps = vertex_pos_vs.xy * PIXELS_PER_METER;
vertex_pos_ps = floor(vertex_pos_ps + 0.5); // round to nearest pixel
vertex_pos_vs.xy = vertex_pos_ps / PIXELS_PER_METER;

vec4 vertex_pos_cs&nbsp;&nbsp;= globals.proj_matrix * vertex_pos_vs;
gl_Position = vertex_pos_cs;
</code></pre>
							</li>
							<li>
								<p>
                                    Version 4:
								</p>
								<ul>
									<li>
										<p>
                                            Snap in clip space.
										</p>
									</li>
								</ul>
<pre><code class="language-glsl" data-lang="glsl">vertex_pos_cs.xy = floor(vertex_pos_cs.xy * globals.viewport_size) / globals.viewport_size;
</code></pre>
								<ul>
									<li>
										<p>
                                            (2026-02-15) Wabbles.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Version 5:
								</p>
<pre><code class="language-glsl" data-lang="glsl">// convert to NDC
vec2 ndc = vertex_pos_cs.xy / vertex_pos_cs.w;

// snap in pixel space
vec2 pixel = (ndc * 0.5 + 0.5) * globals.viewport_size;
pixel = floor(pixel);
ndc = (pixel / globals.viewport_size) * 2.0 - 1.0;

// back to clip
vertex_pos_cs.xy = ndc * vertex_pos_cs.w;
</code></pre>
								<ul>
									<li>
										<p>
                                            (2026-02-15) Wabbles.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Version 6:
								</p>
<pre><code class="language-glsl" data-lang="glsl">vec2 fb = globals.framebuffer_size; // (width, height)
// clip -&gt; NDC
vec2 ndc = vertex_pos_cs.xy / vertex_pos_cs.w;
// NDC -&gt; pixel coords
vec2 pixel = (ndc * 0.5 + 0.5) * fb;
// snap
pixel = floor(pixel + 0.5);
// pixel -&gt; NDC
ndc = (pixel / fb - 0.5) * 2.0;
// write back to clip space
vertex_pos_cs.xy = ndc * vertex_pos_cs.w;
</code></pre>
								<ul>
									<li>
										<p>
                                            (2026-02-15) Wabbles.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Many engines do this (wrong):
						</p>
						<ul>
							<li>
								<p>
                                    snap each vertex independently
								</p>
							</li>
							<li>
								<p>
                                    This causes:
								</p>
								<ul>
									<li>
										<p>
                                            quad distortion
										</p>
									</li>
									<li>
										<p>
                                            UV drift
										</p>
									</li>
									<li>
										<p>
                                            shimmering
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Make sure snapping happens once per sprite, not per vertex.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Fragment Shader: AA Point Sampling, simple fract/min
			</strong>
            :</s>
		</p>
		<ul>
			<li>
				<p>
                    Source: https://www.shadertoy.com/view/MlB3D3
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">uint idx = nonuniformEXT(pc.tex_idx);
vec2 tex_size = textureSize(texs[idx], 0);
vec2 texel = uv * tex_size; 
vec2 pix = floor(texel) + min(fract(texel) / fwidth(texel), vec2(1.0)) - vec2(0.5);
uv =&nbsp;&nbsp;pix / tex_size;
albedo = texture(texs[idx], uv);
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        What it does
					</em>
				</p>
				<ul>
					<li>
						<p>
                            <code>pix = floor(tex_pos) + min(fract(tex_pos), 1.0) - 0.5</code>
                            &nbsp;‚Äî effectively ends up as 
                            <code>tex_pos - 0.5</code>
                            &nbsp;when fract &lt; 1, so it‚Äôs not a true nearest calculation.
						</p>
					</li>
					<li>
						<p>
                            It‚Äôs simpler but not adaptive.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Pros
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Simple.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Cons
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Doesn‚Äôt use derivatives, so it won‚Äôt prevent flicker when the subpixel position crosses texel boundaries.
						</p>
					</li>
					<li>
						<p>
                            It‚Äôs effectively sampling at 
                            <code>tex_pos - 0.5</code>
                            &nbsp;which can be surprising at the edges and for atlases.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        When to use
					</em>
				</p>
				<ul>
					<li>
						<p>
                            None recommended for clean pixel-art nearest sampling.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2026-02-15)
				</p>
				<ul>
					<li>
						<p>
                            With nearest filtering:
						</p>
						<ul>
							<li>
								<p>
                                    Floored sprites, floored camera, floored zoom:
								</p>
								<ul>
									<li>
										<p>
                                            Things look skinnier and weird.
										</p>
									</li>
									<li>
										<p>
                                            Sub-texel phase pattern:
										</p>
										<ul>
											<li>
												<p>
                                                    No improvement to the pattern.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            With linear filtering:
						</p>
						<ul>
							<li>
								<p>
                                    Floored sprites, floored camera, floored zoom:
								</p>
								<ul>
									<li>
										<p>
                                            Things look blurry, like the usual when using linear filtering.
										</p>
									</li>
									<li>
										<p>
                                            Sub-texel phase pattern:
										</p>
										<ul>
											<li>
												<p>
                                                    No improvement to the pattern.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Fragment Shader: Samples at texel centers ‚Äî canonical nearest sampling implemented in shader
			</strong>
            :</s>
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Pros
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Simple, explicit nearest sampling; deterministic.
						</p>
					</li>
					<li>
						<p>
                            Matches what texelFetch would return if you convert coords to integer indices.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Cons
					</em>
				</p>
				<ul>
					<li>
						<p>
                            When UVs are interpolated across a triangle, different fragments can floor to different texels as the sprite moves sub-pixel, producing the expected discrete jumps (this is the shimmering you see unless geometry is pixel-aligned).
						</p>
					</li>
					<li>
						<p>
                            Still uses texture() (filtered sampler), so hardware filtering/mip settings must be consistent (use nearest sampler or disabled mipmaps).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        When to use
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Good if you must use texture() for arrayed bindless samplers. Prefer texelFetch if available.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Source: https://www.shadertoy.com/view/ltBfRD
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">uint idx = nonuniformEXT(pc.tex_idx);
vec2 tex_size = textureSize(texs[idx], 0);
uv = uv * tex_size;
albedo = texture(texs[idx], (floor(uv) + 0.5) / tex_size);
</code></pre>
		<ul>
			<li>
				<p>
                    (2026-02-15) Didn't help at all.
				</p>
				<ul>
					<li>
						<p>
                            After snapping the projection matrix, the result is the same.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Samples at texel centers with 
                        <code>texelFetch</code>
                        &nbsp;‚Äî canonical nearest sampling implemented in shader
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It's a better alternative.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">uint idx = nonuniformEXT(pc.tex_idx);
vec2 tex_size = textureSize(texs[idx], 0);
ivec2 coord = ivec2(floor(uv * tex_size));
albedo = texelFetch(texs[idx], coord, 0);
</code></pre>
				<ul>
					<li>
						<p>
                            <code>texelFetch</code>
                            &nbsp;samples exact texel with integer coords and avoids interpolation/derivative issues.
						</p>
					</li>
					<li>
						<p>
                            (2026-02-15).
						</p>
						<ul>
							<li>
								<p>
                                    With nearest filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    Things look skinnier and weird.
												</p>
											</li>
											<li>
												<p>
                                                    Sub-texel phase pattern:
												</p>
												<ul>
													<li>
														<p>
                                                            No improvement to the pattern.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With linear filtering:
								</p>
								<ul>
									<li>
										<p>
                                            Floored sprites, floored camera, floored zoom:
										</p>
										<ul>
											<li>
												<p>
                                                    Things look blurry, like the usual when using linear filtering.
												</p>
											</li>
											<li>
												<p>
                                                    Sub-texel phase pattern:
												</p>
												<ul>
													<li>
														<p>
                                                            No improvement to the pattern.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Fragment Shader: 
                <code>fwidth</code>
                &nbsp;in texel space to blend a texel
			</strong>
            :</s>
		</p>
		<ul>
			<li>
				<p>
                    Source: ChatGPT
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">uint idx = nonuniformEXT(pc.tex_idx);
vec2 tex_size = textureSize(texs[idx], 0);
vec2 tex_pos = uv * tex_size; 
vec2 fw = max(fwidth(tex_pos), vec2(1e-6));
vec2 pix = floor(tex_pos) + min(fract(tex_pos) / fw, vec2(1.0)) - vec2(0.5);
albedo = texture(texs[idx], pix / tex_size);
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        What it does
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Uses the fragment footprint (
                            <code>fwidth</code>
                            ) in texel units to choose/blend a texel and avoid divide-by-zero.
						</p>
					</li>
					<li>
						<p>
                            Compute derivatives in texel space and avoid divide-by-zero
						</p>
					</li>
					<li>
						<p>
                            Choose the nearest texel but allow a small smoothing based on derivatives
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Pros
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Adapts to the footprint size; can reduce popping during scale changes and handle partial coverage better than a hard floor.
						</p>
					</li>
					<li>
						<p>
                            Safer when derivatives are non-zero and indicate minification/magnification.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Cons / gotchas
					</em>
				</p>
				<ul>
					<li>
						<p>
                            fwidth can be zero for some primitives (flat varyings) ‚Äî you handled that with max(eps), but that‚Äôs an approximation.
						</p>
					</li>
					<li>
						<p>
                            If transform is anisotropic (very different x/y scales), fwidth can be misleading unless handled per-axis.
						</p>
					</li>
					<li>
						<p>
                            More expensive than integer fetch; tuning needed (eps, clamp ranges).
						</p>
					</li>
					<li>
						<p>
                            If textures come from different samplers or textures change across the primitive, derivatives become unreliable.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        When to use
					</em>
				</p>
				<ul>
					<li>
						<p>
                            When you need smooth transitions across varying scales and cannot rely on snapping + 
                            <code>texelFetch</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Good for dynamic scale/rotation where you want some anti-aliasing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2026-02-15)
				</p>
				<ul>
					<li>
						<p>
                            With nearest filtering:
						</p>
						<ul>
							<li>
								<p>
                                    Floored sprites, floored camera, floored zoom:
								</p>
								<ul>
									<li>
										<p>
                                            Sub-texel phase pattern:
										</p>
										<ul>
											<li>
												<p>
                                                    The pattern gets worse, with a lot of lines in the screen.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            With linear filtering:
						</p>
						<ul>
							<li>
								<p>
                                    Floored sprites, floored camera, floored zoom:
								</p>
								<ul>
									<li>
										<p>
                                            Sub-texel phase pattern:
										</p>
										<ul>
											<li>
												<p>
                                                    The pattern gets worse, with a lot of lines in the screen.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                CPU: Share geometry edges
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    When building tile meshes, reuse the same vertex for adjacent tiles so FP rounding can‚Äôt create tiny gaps
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                CPU: Extend the Source/Compress the Dest
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    To compensate for that, you sometimes need to extend the geometry out by a small bit to kind of force the rounding to happen differently. In the cases I have seen with this issue, extending the tile by half to a quarter of a unit helps the GPU round it in a better way.
				</p>
			</li>
			<li>
				<p>
                    I used values of: 
                    <code>1px</code>
                    , 
                    <code>0.5px</code>
                    , 
                    <code>0.25px</code>
                    , 
                    <code>0.125px</code>
                    , 
                    <code>0.02px</code>
                    &nbsp;of compression/expansion on all sides.
				</p>
			</li>
			<li>
				<p>
                    I tested:
				</p>
				<ul>
					<li>
						<p>
                            Compressing the source.
						</p>
						<ul>
							<li>
								<p>
                                    It made the visuals look &quot;bubbly&quot; and very weird at low resolutions.
								</p>
								<ul>
									<li>
										<p>
                                            This happens even with values of 
                                            <code>0.02</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    At high resolutions the effect also existed, although smaller.
								</p>
							</li>
							<li>
								<p>
                                    The overall impression is that the pixel art effect was lost and it looked very bad.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Expanding the source.
						</p>
						<ul>
							<li>
								<p>
                                    Made no sense.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Compressing the destination.
						</p>
						<ul>
							<li>
								<p>
                                    The effect looks very similar to &quot;compressing the source&quot;, but worse:
								</p>
								<ul>
									<li>
										<p>
                                            Sometimes one sprite was drawn in front of another.
										</p>
									</li>
									<li>
										<p>
                                            Sometimes the sprites left the &quot;world grid&quot; and also gave the impression of breaking the pixel art.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Expanding the destination.
						</p>
						<ul>
							<li>
								<p>
                                    Made no sense.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The result was not good.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="texture-bleeding" >
    Texture Bleeding
</h3>
<h5
	id="problem-demo" >
    Problem demo
</h5>
<ul>
	<li>
		<p>
            (2026-02-15)
		</p>
		<ul>
			<li>
				<p>
                    In Vulkan, using tilesets.
				</p>
			</li>
			<li>
                <img src="assets/2026-02-15_13-54-29.png" width="400" >

			</li>
			<li>
				<p>
                    <img src="assets/2026-02-15_13-56-13.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            (2025-06-26)
		</p>
		<ul>
			<li>
				<p>
                    In RayLib, using tilesets.
				</p>
			</li>
			<li>
                <img src="assets/2026-02-15_14-39-05.png" width="400" >

			</li>
		</ul>
	</li>
</ul>
<h5
	id="explanation" >
    Explanation
</h5>
<ul>
	<li>
		<p>
            Old answer from the RayLib discord: &quot;The core issue is that RayLib uses OpenGL, so everything you are drawing is 3d geometry. That geometry is transformed by 3d matrices as part of the camera and view transforms. Due to the nature of floating points there can be small rounding issues during that transform, so you end up with a 1 pixel gap between things. It is also compounded by the fact that GPUs and GPU drivers handle all that math and sometimes work slightly differently. If this was all done with raw pixels, it would be much simpler, but sadly GPUs don't work that way anymore.&quot;
		</p>
	</li>
</ul>
<h3
	id="pixel-art-shimmering" >
    Pixel Art Shimmering
</h3>
<ul>
	<li>
		<p>
			<em>
                Future ideas
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    If texture bleeding happens:
				</p>
				<ul>
					<li>
						<p>
                            Even with sprite and camera snapping there was gaps. This is odd...
						</p>
						<ul>
							<li>
								<p>
									<input
										type="checkbox" 
										disabled=""
>
                                    Could this be caused by the quad size when it's created?
								</p>
								<ul>
									<li>
										<p>
											<input
												type="checkbox" 
												disabled=""
>
                                            Check the dimensions.
										</p>
									</li>
									<li>
										<p>
                                            Is it maybe simply due to random float imprecisions?
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            Consider rendering in pixels and not meters, while having the positions, etc, in meters.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            (2026-02-16) 
			<em>
                Applied solutions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    CPU: Snap the projection matrix, via snap the camera zoom
				</p>
			</li>
			<li>
				<p>
                    Fragment Shader: uv_aa_linear
				</p>
			</li>
			<li>
				<p>
					<em>
                        Current visual
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Ok.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>(2026-02-15) 
			<em>
                Applied solutions
			</em>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    CPU: Snap the projection matrix, via snap the camera zoom
				</p>
			</li>
			<li>
				<p>
                    CPU: Snap the camera
				</p>
			</li>
			<li>
				<p>
                    CPU: Snap geometry
				</p>
			</li>
			<li>
				<p>
                    CPU snapping:
				</p>
				<ul>
					<li>
						<p>
                            Result:
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Fragment Shader: uv_aa_linear
				</p>
			</li>
			<li>
				<p>
					<em>
                        Current visual
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            There's a &quot;vibration&quot; when moving a character, probably due to how the camera is being snapped into place.
						</p>
						<ul>
							<li>
								<p>
                                    Smoothing the camera movement probably brings back the shimmering.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Some sprites now have gaps, due to sprite snapping.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="solutions-proposed" >
    Solutions proposed
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://jorenjoestar.github.io/post/pixel_art_filtering/" 
				class="external-link" 
				target="_blank" >
                Shimmering Artifact in Pixel Art
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The idea behind the filtering is simple: apply 
					<strong>
                        nearest
					</strong>
                    &nbsp;filter to pixels that are fully inside a texel, and use 
					<strong>
                        bilinear
					</strong>
                    &nbsp;with custom weights at the edges.
				</p>
			</li>
			<li>
				<p>
                    That is the core idea.
				</p>
			</li>
			<li>
				<p>
                    The tricky part is creating custom weights for the bilinear filter to work, and that is why there are so many different filters.
				</p>
			</li>
			<li>
				<p>
                    The rest of the article is: We will now see the different filters included in the testbed. Nothing that I wrote, so I will include links to the original material and you can see the authors' work.
				</p>
			</li>
			<li>
				<p>
                    See the links at the end of the article to view the analyzed shaders.
				</p>
				<ul>
					<li>
						<p>
                            https://www.shadertoy.com/view/MllBWf
						</p>
					</li>
					<li>
						<p>
                            https://www.shadertoy.com/view/ltfXWS
						</p>
					</li>
					<li>
						<p>
                            https://www.shadertoy.com/view/4dlXzB
						</p>
					</li>
					<li>
						<p>
                            https://www.shadertoy.com/view/ltBGWc / https://www.shadertoy.com/view/MlB3D3
						</p>
					</li>
					<li>
						<p>
                            https://www.shadertoy.com/view/ltBfRD
						</p>
					</li>
					<li>
						<p>
                            https://www.shadertoy.com/view/ltcGDX
						</p>
						<ul>
							<li>
								<p>
                                    scale/rotate a pixel-art-piece while preserving the chunky pixels (zoomed in view to highlight the effect of the filtering)
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The article references 
                    <a href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html#chat-18-shimmering-artifact-in-pixel-art-and-nsight-shader-analysis">
                    Handmade Hero#Chat 18 - Shimmering artifact in Pixel Art and nSight Shader Analysis
                    </a>
                    &nbsp;and comments on the shader made.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <a href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html#chat-18-shimmering-artifact-in-pixel-art-and-nsight-shader-analysis">
            Handmade Hero#Chat 18 - Shimmering artifact in Pixel Art and nSight Shader Analysis
            </a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=d6tp43wZqps" 
				class="external-link" 
				target="_blank" >
                Removing the shimmering artifact from Pixel Art in 3D
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Well explained.
				</p>
			</li>
			<li>
				<p>
                    Unlike the videos above, this considers that Pixel Art can be rotated in 3D.
				</p>
			</li>
			<li>
				<p>
                    He uses mipmap and premultiplied alpha.
				</p>
			</li>
			<li>
				<p>
                    Final shader:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250704084655.png" width="600" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="pixel-art-camera-smoothness" >
    Pixel Art Camera Smoothness
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=jguyR4yJb1M" 
				class="external-link" 
				target="_blank" >
                aarthificial: Pixel Art look for everything while keeping camera smoothness
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The technique is to use a low-resolution viewport but correct the camera position to avoid a snapping feel.
				</p>
			</li>
			<li>
				<p>
                    No code or equations are shown.
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.55658.js" >
		</script>
	</body>
</html>
