<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.70007.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
								<ul>
									<li>
										<a
											href="#registers-on-chip-in-each-shader-core" >
                                            Registers (on-chip, in each shader core)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#shared-quotescratchquote-on-chip-in-each-sm-wave-cu" >
                                            Shared / &quot;scratch&quot; (on-chip, in each SM/Wave/CU)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#texture-memory-on-chip-specialized-hardware" >
                                            Texture memory (on-chip, specialized hardware)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#l1-cache-on-chip-per-sm-cu" >
                                            L1 Cache (on chip, per SM/CU)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#l2-cache-on-chip-shader-across-gpu" >
                                            L2 Cache (on-chip, shader across GPU)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#local-off-chip-in-global-memory-per-thread" >
                                            Local (off-chip, in global memory, per-thread)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#constant-cache-" >
                                            Constant Cache (?)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#global-memory-off-chip-dram-vram-on-discrete-gpus" >
                                            Global Memory (off-chip DRAM, VRAM on discrete GPUs)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#host-visible-physical-memory" >
                                            Host-Visible Physical Memory
										</a>
										<ul>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
				<footer
					id="left-sidebar-footer" >
				</footer>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="central" >
				<main
					id="note-wrapper" >
					<header
						id="note-header" >
						<h1>
                            Memory
						</h1>
						<p>
							<time
								datetime="2025-08-11" >
                                üïí Created: 2025-08-11
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<article
						id="note-content" >
<ul>
	<li>
		<p>
            <img src="assets/image_20250812175721.png" width="600" >
            .
		</p>
	</li>
	<li>
        <img src="assets/2025-12-10_07-50-28.png" width="600" >

	</li>
	<li>
		<p>
            Off-chip memory:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/2025-12-10_07-35-27.png" width="600" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Deep Seek:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250812192004.png" width="1175" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="registers-on-chip-in-each-shader-core" >
    Registers (on-chip, in each shader core)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Physical Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    On-chip in each shader core.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scope / Visibility
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Private to a single thread.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Registers are the fastest memory components on a GPU, comprising the register file that supplies data directly into the CUDA cores.
		</p>
	</li>
	<li>
		<p>
            A kernel function uses registers to store variables private to the thread and accessed frequently.
		</p>
	</li>
	<li>
		<p>
            Both registers and shared memory are 
			<em>
                on-chip memories
			</em>
            &nbsp;where variables residing in these memories can be accessed at very high speeds in a parallel manner.
		</p>
	</li>
	<li>
		<p>
            By leveraging registers effectively, data reuse can be maximized and performance can be optimized.
		</p>
	</li>
	<li>
		<p>
            Per-thread fast storage, not addressable from shaders as normal memory.
		</p>
	</li>
</ul>
<h3
	id="shared-quotescratchquote-on-chip-in-each-sm-wave-cu" >
    Shared / &quot;scratch&quot; (on-chip, in each SM/Wave/CU)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Physical Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    On-chip in each compute unit (SM/Wave/Compute Unit).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scope / Visibility
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Shared by threads in a workgroup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Low-latency buffer for thread-group cooperation. Useful for explicitly managed caches and reductions.
		</p>
	</li>
	<li>
		<p>
            Is accessible to all threads in the same block and lasts for the block‚Äôs lifetime.
		</p>
	</li>
</ul>
<h3
	id="texture-memory-on-chip-specialized-hardware" >
    Texture memory (on-chip, specialized hardware)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Physical Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    On-chip, specialized hardware
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scope / Visibility
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Optimized for spatial locality (texture) or broadcast (constant)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Is another read-only memory type ideal for physically adjacent data access. Its use can mitigate memory traffic and increase performance compared to global memory.
		</p>
	</li>
</ul>
<h3
	id="l1-cache-on-chip-per-sm-cu" >
    L1 Cache (on chip, per SM/CU)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Physical Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    On-chip per-SM/CU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scope / Visibility
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Caches global/shared accesses
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            L1 or level 1 cache is attached to the processor core directly.
		</p>
	</li>
	<li>
		<p>
            It functions as a backup storage area when the amount of active data exceeds the capacity of a SM‚Äôs register file.
		</p>
	</li>
	<li>
		<p>
            Small, very low-latency caches often configurable (texture vs load/store/shared) on many architectures; behavior and size vary by vendor/generation.
		</p>
	</li>
	<li>
		<p>
            L1 may be partitioned between shared memory and cache.
		</p>
	</li>
</ul>
<h3
	id="l2-cache-on-chip-shader-across-gpu" >
    L2 Cache (on-chip, shader across GPU)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Physical Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    On-chip, shared across GPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scope / Visibility
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    GPU-wide.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            L2 or level 2 cache is larger and often shared across SMs.
		</p>
	</li>
	<li>
		<p>
            Unlike the L1 cache(s), there is only 
			<strong>
                one
			</strong>
            &nbsp;L2 cache.
		</p>
	</li>
	<li>
		<p>
            Larger cache shared across multiple SMs/CUs; services DRAM, texture and load/store requests; a common coherence point for the chip.
		</p>
	</li>
</ul>
<h3
	id="local-off-chip-in-global-memory-per-thread" >
    Local (off-chip, in global memory, per-thread)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Physical Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Off-chip in global memory.
				</p>
			</li>
			<li>
				<p>
                    ‚ÄúLocal‚Äù in shader languages is a per-thread address space.
				</p>
			</li>
			<li>
				<p>
                    Physically it may be kept in registers, spilled to on-chip memory, or spilled to device memory (global DRAM) depending on register pressure and compiler decisions. Saying it is 
					<em>
                        always
					</em>
                    &nbsp;off-chip is misleading.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scope / Visibility
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Private to a thread, but lives in DRAM
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Is private to each thread, but it‚Äôs slower than register memory.
		</p>
	</li>
</ul>
<h3
	id="constant-cache-" >
    Constant Cache (?)
</h3>
<ul>
	<li>
		<p>
            Constant cache captures frequently used variables for each kernel leading to improved performance.
		</p>
	</li>
	<li>
		<p>
            When designing memory systems for massively parallel processors, there will be constant memory variables. Rewriting these variables would be redundant and pointless. Thus, a specialized memory system like the constant cache eliminates the need for computationally costly hardware logic.
		</p>
	</li>
</ul>
<h3
	id="global-memory-off-chip-dram-vram-on-discrete-gpus" >
    Global Memory (off-chip DRAM, VRAM on discrete GPUs)
</h3>
<ul>
	<li>
		<p>
			<strong>
                Physical Location
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Off-chip DRAM (VRAM on discrete GPUs, DRAM on integrated GPUs)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scope / Visibility
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    GPU-wide.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ‚ÄúGlobal memory‚Äù is a 
			<em>
                logical/architectural term
			</em>
            , ‚ÄúVRAM‚Äù is a 
			<em>
                physical/hardware term
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            On discrete GPUs, this 
			<em>
                usually
			</em>
            &nbsp;maps to VRAM.
		</p>
	</li>
	<li>
		<p>
            On integrated GPUs or APUs (where GPU and CPU share DRAM), ‚Äúglobal memory‚Äù is just 
			<em>
                system RAM
			</em>
            .
		</p>
		<ul>
			<li>
				<p>
                    In that case, there is no separate VRAM, but the hardware still calls it ‚Äúglobal‚Äù because it‚Äôs visible to all threads.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Holds data that lasts for the duration of the grid/host.
		</p>
	</li>
	<li>
		<p>
            All threads and the host have access to global memory.
		</p>
	</li>
	<li>
		<p>
            High-bandwidth, higher-latency global memory; large capacity.
		</p>
	</li>
	<li>
		<p>
            Some platforms provide unified system/GPU memory where the GPU uses system DRAM.
		</p>
	</li>
</ul>
<h3
	id="host-visible-physical-memory" >
    Host-Visible Physical Memory
</h3>
<ul>
	<li>
		<p>
            <code>HOST_VISIBLE</code>
		</p>
		<ul>
			<li>
				<p>
                    CPU can map the memory with 
                    <code>vkMapMemory</code>
                    &nbsp;and read/write it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Why not make all VRAM host-visible?
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Mapping all VRAM to the CPU would waste PCIe BAR address space and could reduce GPU performance by forcing VRAM into a less optimal configuration.
				</p>
			</li>
			<li>
				<p>
                    Host-visible VRAM is generally slower for the GPU than purely device-local VRAM because of cacheability and controller constraints.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="properties" >
    Properties
</h5>
<ul>
	<li>
		<p>
            <code>HOST_CACHED</code>
		</p>
		<ul>
			<li>
				<p>
                    CPU accesses are cached in the CPU‚Äôs cache hierarchy (good for reads, but may need explicit flush for writes).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>DEVICE_LOCAL</code>
		</p>
		<ul>
			<li>
				<p>
                    Memory is physically close to the GPU (VRAM on discrete GPUs, DRAM on integrated GPUs).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="where-is-it" >
    Where is it
</h5>
<ul>
	<li>
		<p>
            <code>MEMORY_PROPERTY_HOST_VISIBLE</code>
            &nbsp;only means the CPU can map that VkDeviceMemory (i.e. vkMapMemory works). It does not guarantee where the bytes physically live.
		</p>
	</li>
	<li>
		<p>
            To know whether that host-visible memory counts against VRAM or system RAM, check the memory heap associated with the memory type. If the memory type‚Äôs heapIndex points to a heap that has 
            <code>MEMORY_HEAP_DEVICE_LOCAL</code>
            , that heap is the device-local heap (what you should treat as ‚ÄúVRAM‚Äù for accounting). If the heap does not have 
            <code>DEVICE_LOCAL</code>
            , it‚Äôs system RAM (account against main memory).
		</p>
	</li>
	<li>
		<p>
            Discrete GPU (most desktop cards)
		</p>
		<ul>
			<li>
				<p>
                    It's on System RAM, not on GPU VRAM.
				</p>
			</li>
			<li>
				<p>
                    The task manager shows it as System RAM.
				</p>
			</li>
			<li>
				<p>
                    The CPU owns system RAM ‚Üí the GPU accesses it over PCIe using DMA.
				</p>
			</li>
			<li>
				<p>
                    Vulkan marks this memory type as 
                    <code>HOST_VISIBLE</code>
                    &nbsp;because the driver can map it into the CPU‚Äôs virtual address space (
                    <code>vkMapMemory</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    It is not device-local, so GPU access is slower and higher-latency than VRAM.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Discrete GPU + resizable BAR (modern systems)
		</p>
		<ul>
			<li>
				<p>
                    Resizable BAR lets the CPU map large VRAM ranges.
				</p>
			</li>
			<li>
				<p>
                    Physically inside GPU VRAM.
				</p>
			</li>
			<li>
				<p>
                    Host-visible due to large PCIe BAR aperture.
				</p>
			</li>
			<li>
				<p>
                    Still slower for CPU than normal RAM but faster than old small BAR windows.
				</p>
			</li>
			<li>
				<p>
                    This creates memory types that are both host-visible and device-local on a dGPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Discrete GPU with a PCIe BAR that exposes VRAM (old default BAR)
		</p>
		<ul>
			<li>
				<p>
                    Physically still VRAM on the GPU card.
				</p>
			</li>
			<li>
				<p>
                    The task manager reports it as GPU memory, not System RAM.
				</p>
			</li>
			<li>
				<p>
                    This situation appears in Vulkan as host-visible + device-local memory types.
				</p>
			</li>
			<li>
				<p>
                    The driver exposes this region to the CPU, so it becomes host-visible.
				</p>
			</li>
			<li>
				<p>
                    Often small (MBs‚ÄìGBs, depending on BAR size and driver config).
				</p>
			</li>
			<li>
				<p>
                    CPU writes are slow due to PCIe latency, even though the memory is VRAM.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Integrated GPU / APU
		</p>
		<ul>
			<li>
				<p>
                    There is no VRAM; all GPU memory (both host-visible and device-local) is system RAM.
				</p>
			</li>
			<li>
				<p>
                    The task manager shows it as System RAM.
				</p>
			</li>
			<li>
				<p>
                    CPU and GPU share DRAM via a unified memory controller.
				</p>
			</li>
			<li>
				<p>
                    Vulkan will expose memory types that are both DEVICE_LOCAL and HOST_VISIBLE.
				</p>
			</li>
			<li>
				<p>
                    GPU access time can vary due to shared bandwidth or caches, but it‚Äôs still significantly faster than PCIe-based access.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="bar-base-address-register" >
    BAR (Base Address Register)
</h5>
<ul>
	<li>
		<p>
			<strong>
                Discrete GPU with a PCIe BAR that exposes VRAM‚Äù (old/default BAR)
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Historically:
				</p>
				<ul>
					<li>
						<p>
                            GPUs expose only a small PCIe BAR window (typically 256 MB).
						</p>
					</li>
					<li>
						<p>
                            The CPU can map only that tiny window of VRAM at once.
						</p>
					</li>
					<li>
						<p>
                            The driver remaps that window on demand if you try to access different VRAM ranges.
						</p>
					</li>
					<li>
						<p>
                            Because the window is so small, it is rarely used for general-purpose CPU access.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    So you can map VRAM, but only a tiny slice, and it‚Äôs awkward and slow for real work.
				</p>
			</li>
			<li>
				<p>
                    This is the legacy BAR situation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ‚ÄúDiscrete GPU + Resizable BAR‚Äù (modern systems)
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Resizable BAR is a PCIe capability that lets the BAR window be expanded to cover the entire VRAM.
				</p>
				<ul>
					<li>
						<p>
                            Instead of 256 MB, the CPU can directly map all VRAM.
						</p>
					</li>
					<li>
						<p>
                            No remapping tricks.
						</p>
					</li>
					<li>
						<p>
                            Vulkan can expose device-local memory that is also host-visible for large allocations.
						</p>
					</li>
					<li>
						<p>
                            Games can stream assets more efficiently because CPU ‚Üí VRAM access no longer requires the small-window workaround.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This is the full VRAM mapping situation.
				</p>
			</li>
			<li>
				<p>
                    Resizable BAR only changes addressability, not the speed of PCIe.
				</p>
			</li>
			<li>
				<p>
                    GPU performance is unaffected by whether BAR is small or large.
				</p>
			</li>
			<li>
				<p>
                    By Intel: Resizable BAR (Base Address Register) is a PCIe capability. This is a mechanism that allows the PCIe device, such as a discrete graphics card, to negotiate the BAR size to optimize system resources. Enabling this functionality can result in a performance improvement.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Discussion:
		</p>
		<ul>
			<li>
				<p>
                    Jesse:
				</p>
				<ul>
					<li>
						<p>
                            <code>BAR_pcie_access_flags := vk.MemoryPropertyFlags{.DEVICE_LOCAL, .HOST_VISIBLE, .HOST_COHERENT}</code>
                            &nbsp;I use that for my UBO buffer
						</p>
					</li>
					<li>
						<p>
                            It's what the BAR is (and where &quot;resizable bar&quot; comes from if you've heard the term)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            Can it be 
                            <code>DEVICE_LOCAL</code>
                            &nbsp;and 
                            <code>HOST_VISIBLE</code>
                            &nbsp;at the same time? I assumed it was exclusive. How do you update the buffer?
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Jesse:
				</p>
				<ul>
					<li>
						<p>
                            Yes, within some limits
						</p>
					</li>
					<li>
						<p>
                            It's what the BAR is (and where &quot;resizable bar&quot; comes from if you've heard the term)
						</p>
					</li>
					<li>
						<p>
                            I just write through to the pointer 
                            <code>intrinsics.mem_copy_non_overlapping(rawptr(ubo_frame_01_ptr), &per_frame_ubo, size_of(per_frame_ubo))</code>
						</p>
					</li>
					<li>
						<p>
                            <code>ubo_frame_01_ptr</code>
                            &nbsp;ping pongs at an offset determined by the frame index
						</p>
					</li>
					<li>
						<p>
                            Because multiple frames can be in flight at once
						</p>
					</li>
					<li>
						<p>
                            They need different cameras
						</p>
					</li>
					<li>
						<p>
                            In practice this means I effectively have 2 UBOs I source from
						</p>
					</li>
					<li>
						<p>
                            I also have two sets of positions for each mesh
						</p>
					</li>
					<li>
						<p>
                            BAR is a small segment of CPU-addressable memory on the GPU that is also relatively high-performance read access from the GPU
						</p>
					</li>
					<li>
						<p>
                            You want that allocation to be very small
						</p>
					</li>
					<li>
						<p>
                            Because it's not virtualized
						</p>
					</li>
					<li>
						<p>
                            And if multiple applications want it, they cannot share
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Lee Michael:
				</p>
				<ul>
					<li>
						<p>
                            I had not heard of this! My last Vulkan app actually just assumed ReBAR, and I didn't imagine that would be a downside.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Jesse:
				</p>
				<ul>
					<li>
						<p>
                            Yeah, at least in Vulkan you can try to allocate upfront and if it fails, just use the ordinary fallback
						</p>
					</li>
					<li>
						<p>
                            So at least it won't crash in the middle of the application runtime
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Enabling, by Intel
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use your system‚Äôs latest motherboard firmware supporting Resizable BAR.
				</p>
			</li>
			<li>
				<p>
                    Enter the system‚Äôs BIOS/UEFI firmware configuration menu by pressing the DEL key during system start up. This key may vary between each system manufacturer, please check with your system manufacturer for specific instructions as necessary.
				</p>
			</li>
			<li>
				<p>
                    Compatibility Support Module (CSM) or Legacy Mode must be disabled and UEFI boot mode must be Enabled.
				</p>
			</li>
			<li>
				<p>
                    Ensure the following settings are set to Enabled (or Auto if the Enabled option is not present):
				</p>
				<ul>
					<li>
						<p>
                            Above 4G Decoding
						</p>
					</li>
					<li>
						<p>
                            Re-Size BAR Support
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Use the Intel¬Æ Driver and Support Assistant (Intel DSA) to confirm that Resizable BAR is enabled on your system.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="host-coherent" >
    Host-Coherent
</h5>
<ul>
	<li>
		<p>
			<strong>
                Host-coherent memory
			</strong>
            &nbsp;means CPU and GPU share the same 
			<em>
                coherent view
			</em>
            &nbsp;of the data ‚Äî no explicit flush/invalidate needed.
		</p>
		<ul>
			<li>
				<p>
                    Often backed by system RAM (on discrete GPUs, that‚Äôs typical for PCIe-mapped system memory).
				</p>
			</li>
			<li>
				<p>
                    On integrated GPUs, system DRAM is naturally coherent if the architecture supports it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Non-coherent host-visible memory
			</strong>
            &nbsp;means CPU and GPU caches aren‚Äôt kept in sync automatically.
		</p>
		<ul>
			<li>
				<p>
                    Requires manual flush/invalidate via Vulkan commands.
				</p>
			</li>
			<li>
				<p>
                    This often happens when host-visible memory is still on the GPU‚Äôs side of the PCIe mapping.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>HOST_COHERENT</code>
		</p>
		<ul>
			<li>
				<p>
                    CPU writes/reads are automatically visible to the GPU without 
                    <code>vkFlushMappedMemoryRanges</code>
                    &nbsp;/ 
                    <code>vkInvalidateMappedMemoryRanges</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>

					</article>
					<footer
						id="note-footer" >
					</footer>
				</main>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.70007.js" >
		</script>
	</body>
</html>
