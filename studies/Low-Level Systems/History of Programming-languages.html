<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Game Developer, Engine Developer, Multithreading, Low-Level Network, Low-Level Systems, Bachelor in Physics - USP" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.92425.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Odin
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-overview.html" >
                                    Overview
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-my-impressions.html" >
                                    My Impressions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-installation.html" >
                                    Installation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-building.html" >
                                    Building
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-compile-time-stuff.html" >
                                    Compile-time Stuff
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-package-system.html" >
                                    Package System
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-lsp-ols-odin-language-server.html" >
                                    LSP (OLS - Odin Language Server)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-control-flow-if-when-switch-for-defer.html" >
                                    Control Flow (if, when, switch, for, defer)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-procedures.html" >
                                    Procedures
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-typing.html" >
                                    Typing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-any.html" >
                                    any
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-primitive-types.html" >
                                    Primitive Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-matrix.html" >
                                    Matrix
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-quaternion.html" >
                                    Quaternion
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-complex.html" >
                                    Complex
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-strings.html" >
                                    Strings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-rune.html" >
                                    Rune
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-maps-hash-maps.html" >
                                    Maps (Hash Maps)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-struct.html" >
                                    Struct
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-enum.html" >
                                    Enum
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-union.html" >
                                    Union
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-bit-sets.html" >
                                    Bit Sets
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-arrays.html" >
                                    Arrays
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-interfaces-methods-vtables.html" >
                                    Interfaces / Methods / VTables
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-error-handling.html" >
                                    Error Handling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-context.html" >
                                    Context
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-address.html" >
                                    Memory: Address
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-allocators.html" >
                                    Memory: Allocators
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-memory-operations.html" >
                                    Memory: Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-entry-point.html" >
                                    Entry Point
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-multi-threading.html" >
                                    Multi-Threading
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-simd.html" >
                                    SIMD
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-directives.html" >
                                    Directives
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-ffi-foreign-function-interface-bindings.html" >
                                    FFI (Foreign Function Interface) / Bindings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-web-build.html" >
                                    Web Build
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-file-system-process-cli-shell.html" >
                                    File System / Process / CLI / Shell
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Odin/Odin-useful-packages.html" >
                                    Useful Packages
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Memory
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-virtual-memory.html" >
                                    Virtual Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-os-memory-on-windows.html" >
                                    OS: Memory on Windows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-memory-alignment.html" >
                                    Memory Alignment
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-address.html" >
                                    Address
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-allocators.html" >
                                    Allocators
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-tools-memory-analysis.html" >
                                    Tools: Memory Analysis
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-handles-instead-of-pointers.html" >
                                    Handles instead of Pointers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-ownership-strategies-destruction-strategies.html" >
                                    Ownership Strategies / Destruction Strategies
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-strategies-for-handling-short-lived-memory.html" >
                                    Strategies for handling short lived memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-garbage-collection.html" >
                                    Garbage Collection
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Memory/Memory-initialization.html" >
                                    Initialization
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            CPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-physical-structure.html" >
                                    Physical Structure
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-branchless.html" >
                                    Branchless
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-soa-struct-of-arrays-ecs-entity-component-system.html" >
                                    SOA (Struct Of Arrays) / ECS (Entity Component System)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/CPU/CPU-simd.html" >
                                    SIMD
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Multithreading
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-core-concepts.html" >
                                    Core Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-thread.html" >
                                    Thread
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-strategies.html" >
                                    Strategies
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-implementation-detail.html" >
                                    Implementation Detail
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-synchronization-primitives.html" >
                                    Synchronization Primitives
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-double-buffering.html" >
                                    Double-Buffering
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Multithreading/Multithreading-networking-strategies.html" >
                                    Networking Strategies
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Handmade Hero
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero-handmade-hero.html" >
                                    Handmade Hero
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Profilers
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-tracy.html" >
                                    Tracy
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-spall.html" >
                                    Spall
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-nvidia-nsight-graphics-gpu-trace.html" >
                                    Nvidia Nsight Graphics - GPU Trace
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-amd-gpu-profiler-amd-rgp.html" >
                                    AMD GPU Profiler (AMD RGP)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-intel-gpa.html" >
                                    Intel GPA
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Profilers/Profilers-nsight-systems.html" >
                                    <s>Nsight Systems</s>
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            C
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-c-standard.html" >
                                    C Standard
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-c-standard-library-libc.html" >
                                    C Standard Library (libc)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-critiques.html" >
                                    Critiques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-compiling.html" >
                                    Compiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-includes.html" >
                                    Includes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-libraries.html" >
                                    Libraries
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-integers.html" >
                                    Integers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-loops.html" >
                                    Loops
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-strings.html" >
                                    Strings
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-structs.html" >
                                    Structs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-pointers.html" >
                                    Pointers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-arrays.html" >
                                    Arrays
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-preprocessors.html" >
                                    Preprocessors
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-undefined-behavior.html" >
                                    Undefined Behavior
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/C-game-dev.html" >
                                    Game Dev
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Build Systems - Compilation - Linking
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilation-process.html" >
                                    Compilation Process
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-linker.html" >
                                    Linker
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-compilers.html" >
                                    Compilers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-build-tools.html" >
                                    Build Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-meta-build-tools.html" >
                                    Meta Build Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking-extra-annoying-things-on-windows.html" >
                                    Extra: Annoying things on Windows
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Debuggers
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-debugging-tips.html" >
                                    Debugging Tips
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-file-types.html" >
                                    File Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-rad-debugger.html" >
                                    RAD Debugger
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-gdb-gnu-debugger.html" >
                                    GDB (GNU Debugger)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-lldb.html" >
                                    LLDB
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-vscode.html" >
                                    VSCode
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-visual-studio-debugger.html" >
                                    Visual Studio Debugger
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-others.html" >
                                    Others
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Debuggers-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Assembly - ASM
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-my-notes.html" >
                                    My Notes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-operations.html" >
                                    Operations
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-calling-conventions.html" >
                                    Calling Conventions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-reverse-engineering.html" >
                                    Reverse Engineering
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Assembly/Assembly - ASM-assemblers.html" >
                                    Assemblers
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            History of Programming
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-architectural-specifications.html" >
                                    Architectural Specifications
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-microarchitecture.html" >
                                    Microarchitecture
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-abi-application-binary-interface.html" >
                                    ABI (Application Binary Interface)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Low-Level Systems/History of Programming-languages.html" >
                                    Languages
								</a>
								<ul>
									<li>
										<a
											href="#fortran-1957" >
                                            Fortran (1957)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#lisp-1958" >
                                            Lisp (1958)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#cobol-1959" >
                                            COBOL (1959)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#algol-1960" >
                                            ALGOL (1960)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#basic-1964" >
                                            Basic (1964)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#apl-1966" >
                                            APL (1966)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#pascal-1970" >
                                            Pascal (1970)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#smalltalk-1962" >
                                            SmallTalk (1962)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#c-1972" >
                                            C (1972)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#ml-meta-language-1973" >
                                            ML / Meta Language (1973)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#scheme-1975" >
                                            Scheme (1975)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#ada-1980" >
                                            Ada (1980)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#matlab-1984" >
                                            MatLab (1984)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#objective-c-1984" >
                                            Objective-C (1984)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#common-lisp-1984" >
                                            Common Lisp (1984)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#c-1985" >
                                            C++ (1985)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#perl-1987" >
                                            Perl (1987)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#haskell-1990" >
                                            Haskell (1990)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#visual-basic-1991" >
                                            Visual Basic (1991)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#python-1991" >
                                            Python (1991)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#r-1993" >
                                            R (1993)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#lua-1993" >
                                            Lua (1993)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#delphi-1995" >
                                            Delphi (1995)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#java-1995" >
                                            Java (1995)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#javascript-1995" >
                                            JavaScript (1995)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#php-1995" >
                                            PHP (1995)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#ruby-1995" >
                                            Ruby (1995)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#erlang-1996" >
                                            Erlang (1996)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#ocaml-1996" >
                                            OCaml (1996)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#gml-gamemaker-language-1999" >
                                            GML / GameMaker Language (1999)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#c-2000" >
                                            C# (2000)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#d-20012026-02-20" >
                                            D (2001)(2026-02-20
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#groovy-2003" >
                                            Groovy (2003)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#scala-2004" >
                                            Scala (2004)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#haxe-2005" >
                                            Haxe (2005)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#f-2005" >
                                            F# (2005)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#vala-2006" >
                                            Vala (2006)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#clojure-2007" >
                                            Clojure (2007)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#nim-2008" >
                                            Nim (2008)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#coffeescript-2009" >
                                            CoffeeScript (2009)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#go-2009" >
                                            Go (2009)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#rust-2010" >
                                            Rust (2010)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#kotlin-2011" >
                                            Kotlin (2011)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#dart-2011" >
                                            Dart (2011)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#elixir-2011" >
                                            Elixir (2011)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#c2-2011" >
                                            C2 (2011)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#typescript-2012" >
                                            TypeScript (2012)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#julia-2012" >
                                            Julia (2012)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#swift-2014" >
                                            Swift (2014)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#hack-2014" >
                                            Hack (2014)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#crystal-2014" >
                                            Crystal (2014)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#gdscript-2014" >
                                            GDScript (2014)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#raku-2015" >
                                            Raku (2015)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#jai-2015" >
                                            Jai (2015)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#zig-2016" >
                                            Zig (2016)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#odin-2016" >
                                            Odin (2016)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#c3-2019" >
                                            C3 (2019)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#gleam-2019" >
                                            Gleam (2019)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#v-2019" >
                                            V (2019)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#beef-2019" >
                                            Beef (2019)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#fil-c-2021" >
                                            Fil-C (2021)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#hare-2021" >
                                            Hare (2021)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#carbon-2022" >
                                            Carbon (2022)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#mojo-2023" >
                                            Mojo (2023)
										</a>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/History of Programming-assembly.html" >
                                    Assembly
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Parsing
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-lexer.html" >
                                    Lexer
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-parser.html" >
                                    Parser
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-abstract-syntax-tree-ast.html" >
                                    Abstract Syntax Tree (AST)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Parsing-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            JAI
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-about.html" >
                                    About
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-build.html" >
                                    Build
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-types.html" >
                                    Types
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-meta-programming.html" >
                                    Meta programming
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/JAI-control-flow.html" >
                                    Control flow
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Serialization - Encoding
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Serialization - Encoding/Serialization - Encoding-serialization.html" >
                                    Serialization
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Low-Level Systems/Serialization - Encoding/Serialization - Encoding-encoding.html" >
                                    Encoding
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Languages
					</h1>
					<p>
						<time
							datetime="2026-02-19" >
                            ðŸ•’ Created: 2026-02-19
						</time>
						<time
							datetime="2026-02-22" >
                            | Updated: 2026-02-22
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=KUeuJM__cHs" 
				class="external-link" 
				target="_blank" >
                Most popular programming languages 1955-2025
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="fortran-1957" >
    Fortran (1957)
</h3>
<pre><code class="language-fortran" data-lang="fortran">program main
&nbsp;&nbsp;print *, "Hello"
end program main
</code></pre>
<pre><code class="language-fortran" data-lang="fortran">program factorial_example
&nbsp;&nbsp;&nbsp;&nbsp;implicit none
&nbsp;&nbsp;&nbsp;&nbsp;integer :: n

&nbsp;&nbsp;&nbsp;&nbsp;n = 5
&nbsp;&nbsp;&nbsp;&nbsp;print *, "Factorial of", n, "is", factorial(n)

contains

&nbsp;&nbsp;&nbsp;&nbsp;recursive function factorial(k) result(res)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implicit none
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer, intent(in) :: k
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer :: res

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (k &lt;= 1) then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = k * factorial(k - 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end if
&nbsp;&nbsp;&nbsp;&nbsp;end function factorial

end program factorial_example
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Early FORTRAN (especially FORTRAN IV and FORTRAN 77) primarily used static allocation.
				</p>
			</li>
			<li>
				<p>
                    Modern Fortran (e.g., Fortran 90 and later) introduced proper Stack-Based Automatic Storage
				</p>
			</li>
			<li>
				<p>
                    Historically:
				</p>
				<ul>
					<li>
						<p>
                            Static and stack allocation
						</p>
					</li>
					<li>
						<p>
                            No garbage collector
						</p>
					</li>
					<li>
						<p>
                            Manual heap via ALLOCATE/DEALLOCATE (Fortran 90+)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Modern Fortran:
				</p>
				<ul>
					<li>
						<p>
                            Explicit allocation model
						</p>
					</li>
					<li>
						<p>
                            Deterministic deallocation
						</p>
					</li>
					<li>
						<p>
                            No GC
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="lisp-1958" >
    Lisp (1958)
</h3>
<ul>
	<li>
		<p>
            Homoiconicity enables powerful compile-time code generation
		</p>
	</li>
	<li>
		<p>
            Macros can build domain-specific languages
		</p>
	</li>
	<li>
		<p>
            Direct control over memory layouts is possible in many implementations
		</p>
	</li>
</ul>
<pre><code class="language-lisp" data-lang="lisp">(defmacro my-when (cond &body body)
&nbsp;&nbsp;`(if ,cond
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (progn ,@body)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nil))

(my-when (&gt; 3 2)
&nbsp;&nbsp;(print "executed"))
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    First language to widely use garbage collection
				</p>
			</li>
			<li>
				<p>
                    Automatic heap allocation
				</p>
			</li>
			<li>
				<p>
                    Tracing GC (varies by implementation)
				</p>
			</li>
			<li>
				<p>
                    No manual memory control in idiomatic code
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="cobol-1959" >
    COBOL (1959)
</h3>
<pre><code class="language-cobol" data-lang="cobol">IDENTIFICATION DIVISION.
PROGRAM-ID. HELLO.
PROCEDURE DIVISION.
DISPLAY "HELLO".
STOP RUN.
</code></pre>
<ul>
	<li>
		<p>
            Macros as a key innovation.
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Static and automatic storage
				</p>
			</li>
			<li>
				<p>
                    Programmer-managed data areas
				</p>
			</li>
			<li>
				<p>
                    Main sections:
				</p>
				<ul>
					<li>
						<p>
                            WORKING-STORAGE SECTION â†’ persistent for entire program run
						</p>
					</li>
					<li>
						<p>
                            LOCAL-STORAGE SECTION â†’ per-invocation automatic storage (later COBOL standards)
						</p>
					</li>
					<li>
						<p>
                            LINKAGE SECTION â†’ parameters passed between programs
						</p>
					</li>
					<li>
						<p>
                            FILE SECTION â†’ buffers for I/O records
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    No traditional garbage collector (historically)
				</p>
			</li>
			<li>
				<p>
                    Modern managed COBOL variants may use GC on JVM/.NET
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="algol-1960" >
    ALGOL (1960)
</h3>
<pre><code class="language-algol" data-lang="algol">begin
&nbsp;&nbsp; print("Hello")
end
</code></pre>
<pre><code class="language-algol" data-lang="algol">begin
&nbsp;&nbsp; integer n;

&nbsp;&nbsp; procedure factorial(k);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value k;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer k;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if k = 0 then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorial := 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorial := k * factorial(k - 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;

&nbsp;&nbsp; comment Main program;
&nbsp;&nbsp; n := 5;
&nbsp;&nbsp; outinteger(1, factorial(n));
end
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    It introduced structured stack-based allocation and lexical scoping, which later shaped languages like C, Pascal, and many modern languages.
				</p>
				<ul>
					<li>
						<p>
                            Each procedure call creates an activation record (stack frame).
						</p>
					</li>
					<li>
						<p>
                            Local variables are allocated when the procedure is entered.
						</p>
					</li>
					<li>
						<p>
                            Memory is automatically reclaimed when the procedure returns
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ALGOL 60 had very limited heap allocation.
				</p>
				<ul>
					<li>
						<p>
                            Mostly stack-based
						</p>
					</li>
					<li>
						<p>
                            Arrays could have runtime bounds
						</p>
					</li>
					<li>
						<p>
                            Some implementations supported 
                            <code>own</code>
                            &nbsp;variables (static storage)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Limitations of ALGOL 60:
				</p>
				<ul>
					<li>
						<p>
                            No general-purpose heap with malloc/free
						</p>
					</li>
					<li>
						<p>
                            No garbage collector in standard ALGOL 60
						</p>
					</li>
					<li>
						<p>
                            No pointers in the modern sense
						</p>
					</li>
					<li>
						<p>
                            No manual memory management
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Later descendants (ALGOL W, ALGOL 68) introduced heap allocation and garbage collection.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="basic-1964" >
    Basic (1964)
</h3>
<ul>
	<li>
		<p>
            Beginner-friendly general language (many dialects).
		</p>
	</li>
</ul>
<pre><code class="language-basic" data-lang="basic">LET X = 42
PRINT "Value: "; X
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Varies heavily by dialect.
				</p>
			</li>
			<li>
				<p>
                    Classic BASIC:
				</p>
				<ul>
					<li>
						<p>
                            Static and simple heap management
						</p>
					</li>
					<li>
						<p>
                            Often no GC
						</p>
					</li>
					<li>
						<p>
                            Interpreter-managed memory
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Modern BASIC (e.g., VB family):
				</p>
				<ul>
					<li>
						<p>
                            Garbage collected (.NET)
						</p>
					</li>
					<li>
						<p>
                            Or reference counting (VB6 era)
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="apl-1966" >
    APL (1966)
</h3>
<pre><code class="language-apl" data-lang="apl">+/ 1 2 3 4 5
âˆ˜.Ã—â³5
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Heavy heap allocation for arrays
				</p>
			</li>
			<li>
				<p>
                    Copy-on-write in many implementations
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
			<li>
				<p>
                    Large temporary array pressure common
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="pascal-1970" >
    Pascal (1970)
</h3>
<ul>
	<li>
		<p>
            Structured systems and teaching language.
		</p>
	</li>
</ul>
<pre><code class="language-pascal" data-lang="pascal">program Main;
var
&nbsp;&nbsp;x: Integer;
begin
&nbsp;&nbsp;x := 42;
&nbsp;&nbsp;writeln('Value: ', x);
end.
</code></pre>
<pre><code class="language-pascal" data-lang="pascal">program CalculateAverage;
var
&nbsp;&nbsp;numbers: array[1..10] of real;
&nbsp;&nbsp;sum, average: real;
&nbsp;&nbsp;i: integer;
begin
&nbsp;&nbsp;sum := 0;
&nbsp;&nbsp;for i := 1 to 10 do
&nbsp;&nbsp;begin
&nbsp;&nbsp;&nbsp;&nbsp;write('Enter number ', i, ': ');
&nbsp;&nbsp;&nbsp;&nbsp;readln(numbers[i]);
&nbsp;&nbsp;&nbsp;&nbsp;sum := sum + numbers[i];
&nbsp;&nbsp;end;
&nbsp;&nbsp;
&nbsp;&nbsp;average := sum / 10;
&nbsp;&nbsp;writeln('The average is: ', average:0:2);
end.
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://pascal-lang.org/about/" 
				class="external-link" 
				target="_blank" >
                Pascal
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Stack allocation for locals
				</p>
			</li>
			<li>
				<p>
                    Manual heap via new / dispose
				</p>
			</li>
			<li>
				<p>
                    No garbage collector in classic Pascal
				</p>
			</li>
			<li>
				<p>
                    Deterministic lifetimes
				</p>
			</li>
			<li>
				<p>
                    Static data segments supported
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="smalltalk-1962" >
    SmallTalk (1962)
</h3>
<ul>
	<li>
		<p>
            Pure object-oriented environment.
		</p>
	</li>
</ul>
<pre><code class="language-smalltalk" data-lang="smalltalk">| x |
x := 42.
Transcript show: 'Value: ', x printString; cr.
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Historically generational collectors
				</p>
			</li>
			<li>
				<p>
                    Image-based heap
				</p>
			</li>
			<li>
				<p>
                    Everything is heap-allocated objects
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="c-1972" >
    C (1972)
</h3>
<pre><code class="language-c" data-lang="c">#include &lt;stdio.h&gt;

int main(void) {
&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Value: %d\n", x);
&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Manual memory management (malloc, free)
				</p>
			</li>
			<li>
				<p>
                    Stack allocation for automatic variables
				</p>
			</li>
			<li>
				<p>
                    No garbage collector
				</p>
			</li>
			<li>
				<p>
                    No lifetime tracking by compiler
				</p>
			</li>
			<li>
				<p>
                    Undefined behavior possible on misuse
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ml-meta-language-1973" >
    ML / Meta Language (1973)
</h3>
<ul>
	<li>
		<p>
            Functional with type inference
		</p>
	</li>
</ul>
<pre><code class="language-ml" data-lang="ml">datatype tree =
&nbsp;&nbsp;&nbsp;&nbsp;Leaf
&nbsp;&nbsp;| Node of int * tree * tree

fun sum t =
&nbsp;&nbsp;case t of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leaf =&gt; 0
&nbsp;&nbsp;&nbsp;&nbsp;| Node (v, l, r) =&gt; v + sum l + sum r
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Typically generational collectors
				</p>
			</li>
			<li>
				<p>
                    Immutable data emphasis
				</p>
			</li>
			<li>
				<p>
                    No manual memory management
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="scheme-1975" >
    Scheme (1975)
</h3>
<ul>
	<li>
		<p>
            Minimalist functional Lisp dialect
		</p>
	</li>
</ul>
<pre><code class="language-scheme" data-lang="scheme">(define (sum n acc)
&nbsp;&nbsp;(if (= n 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sum (- n 1) (+ acc n))))

(sum 1000000 0)
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Usually generational copying GC
				</p>
			</li>
			<li>
				<p>
                    Proper tail calls reduce stack pressure
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ada-1980" >
    Ada (1980)
</h3>
<pre><code class="language-ada" data-lang="ada">with Ada.Text_IO; use Ada.Text_IO;

procedure Main is
&nbsp;&nbsp; X : Integer := 42;
begin
&nbsp;&nbsp; Put_Line("Value: " & Integer'Image(X));
end Main;
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Primarily manual (new + explicit deallocation)
				</p>
			</li>
			<li>
				<p>
                    Stack allocation common
				</p>
			</li>
			<li>
				<p>
                    Optional controlled types (RAII-like)
				</p>
			</li>
			<li>
				<p>
                    No mandatory GC
				</p>
			</li>
			<li>
				<p>
                    Deterministic finalization supported
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="matlab-1984" >
    MatLab (1984)
</h3>
<ul>
	<li>
		<p>
            Numerical computing environment.
		</p>
	</li>
</ul>
<pre><code class="language-matlab" data-lang="matlab">x = 42;
disp(['Value: ', num2str(x)]);
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection (implementation-specific)
				</p>
			</li>
			<li>
				<p>
                    Reference counting + copy-on-write for arrays
				</p>
			</li>
			<li>
				<p>
                    Large heap allocations for matrices
				</p>
			</li>
			<li>
				<p>
                    No manual free in user code
				</p>
			</li>
			<li>
				<p>
                    Temporary array pressure significant
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="objective-c-1984" >
    Objective-C (1984)
</h3>
<pre><code class="language-objc" data-lang="objc">#import &lt;Foundation/Foundation.h&gt;

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;@autoreleasepool {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@"Value: %d", x);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Historically:
				</p>
				<ul>
					<li>
						<p>
                            Manual retain/release
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Modern (Apple platforms):
				</p>
				<ul>
					<li>
						<p>
                            ARC (Automatic Reference Counting)
						</p>
					</li>
					<li>
						<p>
                            Deterministic destruction
						</p>
					</li>
					<li>
						<p>
                            Weak references for cycles
						</p>
					</li>
					<li>
						<p>
                            Manual malloc/free still available via C
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="common-lisp-1984" >
    Common Lisp (1984)
</h3>
<ul>
	<li>
		<p>
            powerful macro system
		</p>
	</li>
	<li>
		<p>
            Lisp family evolution
		</p>
	</li>
	<li>
		<p>
            practical large-scale Lisp
		</p>
	</li>
	<li>
		<p>
            Optional static typing
		</p>
	</li>
</ul>
<pre><code class="language-lisp" data-lang="lisp">(defun dot (a b)
&nbsp;&nbsp;(declare (type (simple-array double-float (*)) a b)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (optimize (speed 3) (safety 0)))
&nbsp;&nbsp;(let ((sum 0.0d0))
&nbsp;&nbsp;&nbsp;&nbsp;(dotimes (i (length a) sum)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(incf sum (* (aref a i) (aref b i))))))
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Typically generational, implementation-specific
				</p>
			</li>
			<li>
				<p>
                    Dynamic heap allocation
				</p>
			</li>
			<li>
				<p>
                    Manual memory rarely exposed
				</p>
			</li>
			<li>
				<p>
                    Some implementations allow tuning
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="c-1985" >
    C++ (1985)
</h3>
<pre><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Value: " &lt;&lt; x &lt;&lt; "\n";
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Manual allocation (new/delete, malloc/free)
				</p>
			</li>
			<li>
				<p>
                    RAII deterministic destruction
				</p>
			</li>
			<li>
				<p>
                    Smart pointers (unique_ptr, shared_ptr)
				</p>
			</li>
			<li>
				<p>
                    Stack vs heap control
				</p>
			</li>
			<li>
				<p>
                    No built-in GC
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="perl-1987" >
    Perl (1987)
</h3>
<pre><code class="language-perl" data-lang="perl">my $x = 42;
print "Value: $x\n";
</code></pre>
<pre><code class="language-perl" data-lang="perl">#!/usr/bin/perl
use strict;
use warnings;

# Variables
my $name = "Alice";
my $age&nbsp;&nbsp;= 30;

print "Name: $name\n";
print "Age: $age\n";

# Conditional
if ($age &gt;= 18) {
&nbsp;&nbsp;&nbsp;&nbsp;print "$name is an adult.\n";
} else {
&nbsp;&nbsp;&nbsp;&nbsp;print "$name is a minor.\n";
}

# Array
my @fruits = ("apple", "banana", "orange");
print "First fruit: $fruits[0]\n";

print "All fruits:\n";
foreach my $fruit (@fruits) {
&nbsp;&nbsp;&nbsp;&nbsp;print "- $fruit\n";
}

# Hash (associative array)
my %person = (
&nbsp;&nbsp;&nbsp;&nbsp;name =&gt; "Bob",
&nbsp;&nbsp;&nbsp;&nbsp;city =&gt; "SÃ£o Paulo",
&nbsp;&nbsp;&nbsp;&nbsp;job&nbsp;&nbsp;=&gt; "Developer"
);

print "Person info:\n";
while (my ($key, $value) = each %person) {
&nbsp;&nbsp;&nbsp;&nbsp;print "$key =&gt; $value\n";
}

# Loop
print "Counting:\n";
for (my $i = 1; $i &lt;= 5; $i++) {
&nbsp;&nbsp;&nbsp;&nbsp;print "$i\n";
}

# File write example
my $filename = "output.txt";
open(my $fh, '&gt;', $filename) or die "Cannot open file: $!";
print $fh "Hello from Perl!\n";
close($fh);

print "File '$filename' written successfully.\n";
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Reference counting primary
				</p>
			</li>
			<li>
				<p>
                    Cycle detection in modern Perl
				</p>
			</li>
			<li>
				<p>
                    Deterministic destruction in many cases
				</p>
			</li>
			<li>
				<p>
                    No manual free in user code
				</p>
			</li>
			<li>
				<p>
                    Internal arenas used by interpreter
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="haskell-1990" >
    Haskell (1990)
</h3>
<ul>
	<li>
		<p>
            Purely functional, lazy, strongly typed
		</p>
	</li>
</ul>
<pre><code class="language-haskell" data-lang="haskell">module Main (main) where&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- not needed in interpreter, is the default in a module file

main :: IO ()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- the compiler can infer this type definition
main = putStrLn "Hello, World!"
</code></pre>
<pre><code class="language-haskell" data-lang="haskell">factorial :: (Integral a) =&gt; a -&gt; a

-- Using recursion (with the "ifthenelse" expression)
factorial n = if n &lt; 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else n * factorial (n - 1)

-- Using recursion (with pattern matching)
factorial 0 = 1
factorial n = n * factorial (n - 1)

-- Using recursion (with guards)
factorial n
&nbsp;&nbsp; | n &lt; 2&nbsp;&nbsp;&nbsp;&nbsp; = 1
&nbsp;&nbsp; | otherwise = n * factorial (n - 1)

-- Using a list and the "product" function
factorial n = product [1..n]

-- Using fold (implements "product")
factorial n = foldl (*) 1 [1..n]

-- Point-free style
factorial = foldr (*) 1 . enumFromTo 1
</code></pre>
<h3
	id="visual-basic-1991" >
    Visual Basic (1991)
</h3>
<pre><code class="language-vb" data-lang="vb">Module Program
&nbsp;&nbsp;&nbsp;&nbsp;Sub Main()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dim x As Integer = 42
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"Value: {x}")
&nbsp;&nbsp;&nbsp;&nbsp;End Sub
End Module
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    .NET garbage collector (VB.NET)
				</p>
			</li>
			<li>
				<p>
                    Generational GC
				</p>
			</li>
			<li>
				<p>
                    Value types on stack
				</p>
			</li>
			<li>
				<p>
                    IDisposable for resources
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="python-1991" >
    Python (1991)
</h3>
<ul>
	<li>
		<p>
            General-purpose high-level language.
		</p>
	</li>
</ul>
<pre><code class="language-py" data-lang="py">x = 42
print(f"Value: {x}")
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Reference counting (primary)
				</p>
			</li>
			<li>
				<p>
                    Cycle-detecting garbage collector
				</p>
			</li>
			<li>
				<p>
                    Deterministic destruction for most objects
				</p>
			</li>
			<li>
				<p>
                    No manual free in normal code
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="r-1993" >
    R (1993)
</h3>
<ul>
	<li>
		<p>
            Statistical computing language.
		</p>
	</li>
</ul>
<pre><code class="language-r" data-lang="r">x &lt;- 42
cat("Value:", x, "\n")
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Copy-on-modify semantics
				</p>
			</li>
			<li>
				<p>
                    Reference counting internally
				</p>
			</li>
			<li>
				<p>
                    Heavy heap usage for vectors/data frames
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="lua-1993" >
    Lua (1993)
</h3>
<ul>
	<li>
		<p>
            Lightweight embeddable scripting language.
		</p>
	</li>
</ul>
<pre><code class="language-lua" data-lang="lua">local x = 42
print("Value:", x)
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Incremental garbage collector
				</p>
			</li>
			<li>
				<p>
                    Generational mode in modern Lua
				</p>
			</li>
			<li>
				<p>
                    Fully heap managed
				</p>
			</li>
			<li>
				<p>
                    C API allows manual allocations outside VM
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="delphi-1995" >
    Delphi (1995)
</h3>
<ul>
	<li>
		<p>
            RAD native development.
		</p>
	</li>
</ul>
<pre><code class="language-delphi" data-lang="delphi">program Main;

begin
&nbsp;&nbsp;var x: Integer := 42;
&nbsp;&nbsp;Writeln('Value: ', x);
end.
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Objects: manual (Free) historically
				</p>
			</li>
			<li>
				<p>
                    Modern Delphi:
				</p>
			</li>
			<li>
				<p>
                    ARC on some platforms (mobile era)
				</p>
			</li>
			<li>
				<p>
                    Manual ownership still common
				</p>
			</li>
			<li>
				<p>
                    Strings and dynamic arrays are reference-counted
				</p>
			</li>
			<li>
				<p>
                    No tracing GC
				</p>
			</li>
			<li>
				<p>
                    Deterministic destruction via Free
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="java-1995" >
    Java (1995)
</h3>
<ul>
	<li>
		<p>
            Enterprise and cross-platform systems.
		</p>
	</li>
</ul>
<pre><code class="language-java" data-lang="java">public class Main {
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Value: " + x);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Multiple collectors (G1, ZGC, Shenandoah, etc.)
				</p>
			</li>
			<li>
				<p>
                    Heap + stack model
				</p>
			</li>
			<li>
				<p>
                    No manual free
				</p>
			</li>
			<li>
				<p>
                    Escape analysis for stack allocation
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="javascript-1995" >
    JavaScript (1995)
</h3>
<ul>
	<li>
		<p>
            Dynamic language for web and servers.
		</p>
	</li>
</ul>
<pre><code class="language-js" data-lang="js">const x = 42;
console.log(`Value: ${x}`);
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Typically generational mark-and-sweep
				</p>
			</li>
			<li>
				<p>
                    No manual free
				</p>
			</li>
			<li>
				<p>
                    Objects allocated on heap
				</p>
			</li>
			<li>
				<p>
                    Engines (e.g., V8) optimize with escape analysis
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="php-1995" >
    PHP (1995)
</h3>
<pre><code class="language-php" data-lang="php">&lt;?php
$x = 42;
echo "Value: $x\n";
</code></pre>
<ul>
	<li>
		<p>
            Embedded in HTML
		</p>
	</li>
	<li>
		<p>
            Massive web ecosystem
		</p>
	</li>
	<li>
		<p>
            Dynamic typing
		</p>
	</li>
	<li>
		<p>
            Simple deployment model
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Reference counting
				</p>
			</li>
			<li>
				<p>
                    Cycle collector (modern PHP)
				</p>
			</li>
			<li>
				<p>
                    Request-scoped memory model
				</p>
			</li>
			<li>
				<p>
                    No manual free in userland
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ruby-1995" >
    Ruby (1995)
</h3>
<pre><code class="language-ruby" data-lang="ruby">x = 42
puts "Value: #{x}"
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Modern Ruby uses generational + incremental GC
				</p>
			</li>
			<li>
				<p>
                    Fully heap-allocated objects
				</p>
			</li>
			<li>
				<p>
                    No manual memory management
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="erlang-1996" >
    Erlang (1996)
</h3>
<ul>
	<li>
		<p>
            Highly concurrent, fault-tolerant distributed systems.
		</p>
	</li>
</ul>
<pre><code class="language-erlang" data-lang="erlang">-module(main).
-export([main/0]).

main() -&gt;
&nbsp;&nbsp;&nbsp;&nbsp;X = 42,
&nbsp;&nbsp;&nbsp;&nbsp;io:format("Value: ~p~n", [X]).
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Per-process garbage collection
				</p>
			</li>
			<li>
				<p>
                    Each process has its own heap
				</p>
			</li>
			<li>
				<p>
                    Mostly generational copying GC
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
			<li>
				<p>
                    Immutable data model
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="ocaml-1996" >
    OCaml (1996)
</h3>
<ul>
	<li>
		<p>
            Native code compiler
		</p>
	</li>
	<li>
		<p>
            Efficient functional runtime
		</p>
	</li>
</ul>
<pre><code class="language-ocaml" data-lang="ocaml">type 'a vec =
&nbsp;&nbsp;| V2 of 'a * 'a
&nbsp;&nbsp;| V3 of 'a * 'a * 'a

let dot a b =
&nbsp;&nbsp;match a, b with
&nbsp;&nbsp;| V2 (x1,y1), V2 (x2,y2) -&gt; x1*x2 + y1*y2
&nbsp;&nbsp;| V3 (x1,y1,z1), V3 (x2,y2,z2) -&gt; x1*x2 + y1*y2 + z1*z2
&nbsp;&nbsp;| _ -&gt; invalid_arg "dim"
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Generational GC with minor/major heaps
				</p>
			</li>
			<li>
				<p>
                    Moving collector for young generation
				</p>
			</li>
			<li>
				<p>
                    Immutable data heavily optimized
				</p>
			</li>
			<li>
				<p>
                    Manual memory via C FFI when needed
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="gml-gamemaker-language-1999" >
    GML / GameMaker Language (1999)
</h3>
<ul>
	<li>
		<p>
            Used in GameMaker
		</p>
	</li>
</ul>
<pre><code class="language-gml" data-lang="gml">var x = 42;
show_debug_message("Value: " + string(x));
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection (modern GMS2)
				</p>
			</li>
			<li>
				<p>
                    Engine-managed instances
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
			<li>
				<p>
                    Older versions relied heavily on engine ownership
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="c-2000" >
    C# (2000)
</h3>
<pre><code class="language-cs" data-lang="cs">using System;

class Program {
&nbsp;&nbsp;&nbsp;&nbsp;static void Main() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"Value: {x}");
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Generational GC in .NET
				</p>
			</li>
			<li>
				<p>
                    Stack allocation for value types
				</p>
			</li>
			<li>
				<p>
                    IDisposable for deterministic resource cleanup
				</p>
			</li>
			<li>
				<p>
                    unsafe allows manual memory when needed
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="d-20012026-02-20" >
    D (2001)(2026-02-20
</h3>
<pre><code class="language-d" data-lang="d">import std.stdio;

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;writeln("Value: ", x);
}
</code></pre>
<pre><code class="language-d" data-lang="d">import core.stdc.stdlib;

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;int* p = cast(int*)malloc(int.sizeof);
&nbsp;&nbsp;&nbsp;&nbsp;*p = 42;
&nbsp;&nbsp;&nbsp;&nbsp;free(p);
}
</code></pre>
<pre><code class="language-d" data-lang="d">import std.stdio;
import std.file;
import std.array;

void main()
{
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;string name = "Alice";
&nbsp;&nbsp;&nbsp;&nbsp;int age = 30;

&nbsp;&nbsp;&nbsp;&nbsp;writeln("Name: ", name);
&nbsp;&nbsp;&nbsp;&nbsp;writeln("Age: ", age);

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if (age &gt;= 18)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln(name, " is an adult.");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln(name, " is a minor.");
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Dynamic array
&nbsp;&nbsp;&nbsp;&nbsp;string[] fruits = ["apple", "banana", "orange"];
&nbsp;&nbsp;&nbsp;&nbsp;writeln("First fruit: ", fruits[0]);

&nbsp;&nbsp;&nbsp;&nbsp;writeln("All fruits:");
&nbsp;&nbsp;&nbsp;&nbsp;foreach (fruit; fruits)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln("- ", fruit);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Associative array (hash map)
&nbsp;&nbsp;&nbsp;&nbsp;string[string] person;
&nbsp;&nbsp;&nbsp;&nbsp;person["name"] = "Bob";
&nbsp;&nbsp;&nbsp;&nbsp;person["city"] = "SÃ£o Paulo";
&nbsp;&nbsp;&nbsp;&nbsp;person["job"]&nbsp;&nbsp;= "Developer";

&nbsp;&nbsp;&nbsp;&nbsp;writeln("Person info:");
&nbsp;&nbsp;&nbsp;&nbsp;foreach (key, value; person)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln(key, " =&gt; ", value);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;writeln("Counting:");
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= 5; i++)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln(i);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;string filename = "output.txt";
&nbsp;&nbsp;&nbsp;&nbsp;write(filename, "Hello from D!\n");

&nbsp;&nbsp;&nbsp;&nbsp;writeln("File '", filename, "' written successfully.");
}
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://dlang.org/" 
				class="external-link" 
				target="_blank" >
                D Lang
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Direct C interop (extern(C))
		</p>
	</li>
	<li>
		<p>
            Compile-time function execution (CTFE)
		</p>
	</li>
	<li>
		<p>
            Value semantics + slices
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Built-in garbage collector (default)
				</p>
				<ul>
					<li>
						<p>
                            @nogc mode for GC-free code
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Manual memory via malloc/free
				</p>
			</li>
			<li>
				<p>
                    Reference counting possible
				</p>
			</li>
			<li>
				<p>
                    Stack allocation supported
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="groovy-2003" >
    Groovy (2003)
</h3>
<ul>
	<li>
		<p>
            Dynamic language for the JVM with Java interoperability.
		</p>
	</li>
</ul>
<pre><code class="language-groovy" data-lang="groovy">def x = 42
println "Value: $x"
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    JVM garbage collection
				</p>
			</li>
			<li>
				<p>
                    Same collectors as Java
				</p>
			</li>
			<li>
				<p>
                    Objects heap allocated
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
			<li>
				<p>
                    Escape analysis handled by JVM
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="scala-2004" >
    Scala (2004)
</h3>
<ul>
	<li>
		<p>
            Functional + OOP on the JVM.
		</p>
	</li>
</ul>
<pre><code class="language-scala" data-lang="scala">object Main extends App {
&nbsp;&nbsp;val x = 42
&nbsp;&nbsp;println(s"Value: $x")
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    JVM garbage collection
				</p>
			</li>
			<li>
				<p>
                    Same collectors as Java
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="haxe-2005" >
    Haxe (2005)
</h3>
<ul>
	<li>
		<p>
            multi-target language (JS, C++, C#, etc.).
		</p>
	</li>
</ul>
<pre><code class="language-haxe" data-lang="haxe">class Main {
&nbsp;&nbsp;&nbsp;&nbsp;static function main() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trace("Value: " + x);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Depends on compilation target
				</p>
			</li>
			<li>
				<p>
                    JS target â†’ GC
				</p>
			</li>
			<li>
				<p>
                    C++ target (hxcpp) â†’ GC (Boehm or hxcpp GC)
				</p>
			</li>
			<li>
				<p>
                    C# / Java targets â†’ host GC
				</p>
			</li>
			<li>
				<p>
                    No manual memory control in typical usage
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="f-2005" >
    F# (2005)
</h3>
<ul>
	<li>
		<p>
            Functional-first language on .NET.
		</p>
	</li>
</ul>
<pre><code class="language-fs" data-lang="fs">[&lt;EntryPoint&gt;]
let main _ =
&nbsp;&nbsp;&nbsp;&nbsp;let x = 42
&nbsp;&nbsp;&nbsp;&nbsp;printfn "Value: %d" x
&nbsp;&nbsp;&nbsp;&nbsp;0
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    .NET generational garbage collector
				</p>
			</li>
			<li>
				<p>
                    Value types allocated on stack
				</p>
			</li>
			<li>
				<p>
                    Reference types on heap
				</p>
			</li>
			<li>
				<p>
                    IDisposable pattern for deterministic resource cleanup
				</p>
			</li>
			<li>
				<p>
                    No manual free in safe code
				</p>
			</li>
			<li>
				<p>
                    stackalloc and Span
                    <T>
                    &nbsp;available for low-level work
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="vala-2006" >
    Vala (2006)
</h3>
<ul>
	<li>
		<p>
            High-level language compiling to C, mainly for GNOME.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vala.dev/" 
				class="external-link" 
				target="_blank" >
                Vala
			</a>
		</p>
	</li>
</ul>
<pre><code class="language-vala" data-lang="vala">public class ExampleApp : Gtk.Application {
&nbsp;&nbsp;public ExampleApp () {
&nbsp;&nbsp;&nbsp;&nbsp;Object (application_id: "com.example.App");
&nbsp;&nbsp;}

&nbsp;&nbsp;public override void activate () {
&nbsp;&nbsp;&nbsp;&nbsp;var win = new Gtk.ApplicationWindow (this);

&nbsp;&nbsp;&nbsp;&nbsp;var btn = new Gtk.Button.with_label ("Hello World");
&nbsp;&nbsp;&nbsp;&nbsp;btn.clicked.connect (win.close);

&nbsp;&nbsp;&nbsp;&nbsp;win.child = btn;
&nbsp;&nbsp;&nbsp;&nbsp;win.present ();
&nbsp;&nbsp;}

&nbsp;&nbsp;public static int main (string[] args) {
&nbsp;&nbsp;&nbsp;&nbsp;var app = new ExampleApp ();
&nbsp;&nbsp;&nbsp;&nbsp;return app.run (args);
&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    GObject reference counting
				</p>
			</li>
			<li>
				<p>
                    Automatic ref management in most cases
				</p>
			</li>
			<li>
				<p>
                    Compiles to C
				</p>
			</li>
			<li>
				<p>
                    Manual memory possible via C interop
				</p>
			</li>
			<li>
				<p>
                    No tracing GC
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="clojure-2007" >
    Clojure (2007)
</h3>
<pre><code class="language-clojure" data-lang="clojure">(def x 42)
(println (str "Value: " x))
</code></pre>
<ul>
	<li>
		<p>
            JVM interop
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    JVM garbage collection
				</p>
			</li>
			<li>
				<p>
                    Immutable persistent structures
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="nim-2008" >
    Nim (2008)
</h3>
<pre><code class="language-nim" data-lang="nim">import std/strformat

type
&nbsp;&nbsp;Person = object
&nbsp;&nbsp;&nbsp;&nbsp;name: string
&nbsp;&nbsp;&nbsp;&nbsp;age: Natural # Ensures the age is positive

let people = [
&nbsp;&nbsp;Person(name: "John", age: 45),
&nbsp;&nbsp;Person(name: "Kate", age: 30)
]

for person in people:
&nbsp;&nbsp;# Type-safe string interpolation,
&nbsp;&nbsp;# evaluated at compile time.
&nbsp;&nbsp;echo(fmt"{person.name} is {person.age} years old")


# Thanks to Nim's 'iterator' and 'yield' constructs,
# iterators are as easy to write as ordinary
# functions. They are compiled to inline loops.
iterator oddNumbers[Idx, T](a: array[Idx, T]): T =
&nbsp;&nbsp;for x in a:
&nbsp;&nbsp;&nbsp;&nbsp;if x mod 2 == 1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield x

for odd in oddNumbers([3, 6, 9, 12, 15, 18]):
&nbsp;&nbsp;echo odd


# Use Nim's macro system to transform a dense
# data-centric description of x86 instructions
# into lookup tables that are used by
# assemblers and JITs.
import macros, strutils

macro toLookupTable(data: static[string]): untyped =
&nbsp;&nbsp;result = newTree(nnkBracket)
&nbsp;&nbsp;for w in data.split(';'):
&nbsp;&nbsp;&nbsp;&nbsp;result.add newLit(w)

const
&nbsp;&nbsp;data = "mov;btc;cli;xor"
&nbsp;&nbsp;opcodes = toLookupTable(data)

for o in opcodes:
&nbsp;&nbsp;echo o
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://nim-lang.org/" 
				class="external-link" 
				target="_blank" >
                Nim
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Historically GC (mark-and-sweep)
				</p>
			</li>
			<li>
				<p>
                    Modern Nim supports:
				</p>
				<ul>
					<li>
						<p>
                            ARC/ORC (deterministic ref counting)
						</p>
					</li>
					<li>
						<p>
                            Optional GC
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Manual memory via alloc/dealloc
				</p>
			</li>
			<li>
				<p>
                    Stack allocation for value types
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="coffeescript-2009" >
    CoffeeScript (2009)
</h3>
<ul>
	<li>
		<p>
            Syntactic sugar over JavaScript.
		</p>
	</li>
</ul>
<pre><code class="language-js" data-lang="js">x = 42
console.log "Value: #{x}"
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Inherits JavaScript GC
				</p>
			</li>
			<li>
				<p>
                    Fully automatic
				</p>
			</li>
			<li>
				<p>
                    Engine dependent
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="go-2009" >
    Go (2009)
</h3>
<ul>
	<li>
		<p>
            Simple concurrent systems language.
		</p>
	</li>
</ul>
<pre><code class="language-go" data-lang="go">package main

import "fmt"

func main() {
&nbsp;&nbsp;&nbsp;&nbsp;x := 42
&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("Value:", x)
}
</code></pre>
<pre><code class="language-go" data-lang="go">package main

import (
&nbsp;&nbsp;&nbsp;&nbsp;"fmt"
&nbsp;&nbsp;&nbsp;&nbsp;"os"
)

// Function
func greet(name string) string {
&nbsp;&nbsp;&nbsp;&nbsp;return "Hello, " + name + "!"
}

func main() {
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;name := "Alice"
&nbsp;&nbsp;&nbsp;&nbsp;age := 30

&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("Name:", name)
&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("Age:", age)

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if age &gt;= 18 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(name, "is an adult.")
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(name, "is a minor.")
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Slice (dynamic array)
&nbsp;&nbsp;&nbsp;&nbsp;fruits := []string{"apple", "banana", "orange"}
&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("First fruit:", fruits[0])

&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("All fruits:")
&nbsp;&nbsp;&nbsp;&nbsp;for _, fruit := range fruits {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("-", fruit)
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Map (hash table)
&nbsp;&nbsp;&nbsp;&nbsp;person := map[string]string{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name": "Bob",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"city": "SÃ£o Paulo",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"job":&nbsp;&nbsp;"Developer",
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("Person info:")
&nbsp;&nbsp;&nbsp;&nbsp;for k, v := range person {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf("%s =&gt; %s\n", k, v)
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("Counting:")
&nbsp;&nbsp;&nbsp;&nbsp;for i := 1; i &lt;= 5; i++ {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(i)
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call function
&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(greet("World"))

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;filename := "output.txt"
&nbsp;&nbsp;&nbsp;&nbsp;err := os.WriteFile(filename, []byte("Hello from Go!\n"), 0644)
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("Error writing file:", err)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("File", filename, "written successfully.")
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Concurrent tri-color mark-and-sweep
				</p>
			</li>
			<li>
				<p>
                    Stack growth managed by runtime
				</p>
			</li>
			<li>
				<p>
                    No manual free
				</p>
			</li>
			<li>
				<p>
                    Escape analysis for stack allocation
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="rust-2010" >
    Rust (2010)
</h3>
<ul>
	<li>
		<p>
            Systems programming with strong safety guarantees.
		</p>
	</li>
</ul>
<pre><code class="language-rust" data-lang="rust">use std::collections::HashMap;
use std::fs;

// Function
fn greet(name: &str) -&gt; String {
&nbsp;&nbsp;&nbsp;&nbsp;format!("Hello, {}!", name)
}

fn main() {
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;let name = "Alice";
&nbsp;&nbsp;&nbsp;&nbsp;let age = 30;

&nbsp;&nbsp;&nbsp;&nbsp;println!("Name: {}", name);
&nbsp;&nbsp;&nbsp;&nbsp;println!("Age: {}", age);

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if age &gt;= 18 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println!("{} is an adult.", name);
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println!("{} is a minor.", name);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Vector (dynamic array)
&nbsp;&nbsp;&nbsp;&nbsp;let fruits = vec!["apple", "banana", "orange"];
&nbsp;&nbsp;&nbsp;&nbsp;println!("First fruit: {}", fruits[0]);

&nbsp;&nbsp;&nbsp;&nbsp;println!("All fruits:");
&nbsp;&nbsp;&nbsp;&nbsp;for fruit in &fruits {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println!("- {}", fruit);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// HashMap
&nbsp;&nbsp;&nbsp;&nbsp;let mut person: HashMap&lt;&str, &str&gt; = HashMap::new();
&nbsp;&nbsp;&nbsp;&nbsp;person.insert("name", "Bob");
&nbsp;&nbsp;&nbsp;&nbsp;person.insert("city", "SÃ£o Paulo");
&nbsp;&nbsp;&nbsp;&nbsp;person.insert("job", "Developer");

&nbsp;&nbsp;&nbsp;&nbsp;println!("Person info:");
&nbsp;&nbsp;&nbsp;&nbsp;for (key, value) in &person {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println!("{} =&gt; {}", key, value);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;println!("Counting:");
&nbsp;&nbsp;&nbsp;&nbsp;for i in 1..=5 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println!("{}", i);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call function
&nbsp;&nbsp;&nbsp;&nbsp;println!("{}", greet("World"));

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;let filename = "output.txt";
&nbsp;&nbsp;&nbsp;&nbsp;match fs::write(filename, "Hello from Rust!\n") {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ok(_) =&gt; println!("File '{}' written successfully.", filename),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Err(e) =&gt; println!("Error writing file: {}", e),
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Ownership + borrow checker (compile-time)
				</p>
			</li>
			<li>
				<p>
                    No garbage collector
				</p>
			</li>
			<li>
				<p>
                    Deterministic destruction (RAII)
				</p>
			</li>
			<li>
				<p>
                    Optional reference counting (Rc, Arc)
				</p>
			</li>
			<li>
				<p>
                    Manual allocation via allocators when needed
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="kotlin-2011" >
    Kotlin (2011)
</h3>
<ul>
	<li>
		<p>
            Modern JVM and multiplatform language.
		</p>
	</li>
</ul>
<pre><code class="language-kotlin" data-lang="kotlin">import java.io.File

// Function
fun greet(name: String): String {
&nbsp;&nbsp;&nbsp;&nbsp;return "Hello, $name!"
}

fun main() {
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;val name = "Alice"
&nbsp;&nbsp;&nbsp;&nbsp;val age = 30

&nbsp;&nbsp;&nbsp;&nbsp;println("Name: $name")
&nbsp;&nbsp;&nbsp;&nbsp;println("Age: $age")

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if (age &gt;= 18) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println("$name is an adult.")
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println("$name is a minor.")
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// List (dynamic array)
&nbsp;&nbsp;&nbsp;&nbsp;val fruits = listOf("apple", "banana", "orange")
&nbsp;&nbsp;&nbsp;&nbsp;println("First fruit: ${fruits[0]}")

&nbsp;&nbsp;&nbsp;&nbsp;println("All fruits:")
&nbsp;&nbsp;&nbsp;&nbsp;for (fruit in fruits) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println("- $fruit")
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Map
&nbsp;&nbsp;&nbsp;&nbsp;val person = mapOf(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name" to "Bob",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"city" to "SÃ£o Paulo",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"job" to "Developer"
&nbsp;&nbsp;&nbsp;&nbsp;)

&nbsp;&nbsp;&nbsp;&nbsp;println("Person info:")
&nbsp;&nbsp;&nbsp;&nbsp;for ((key, value) in person) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println("$key =&gt; $value")
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;println("Counting:")
&nbsp;&nbsp;&nbsp;&nbsp;for (i in 1..5) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(i)
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call function
&nbsp;&nbsp;&nbsp;&nbsp;println(greet("World"))

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;val filename = "output.txt"
&nbsp;&nbsp;&nbsp;&nbsp;File(filename).writeText("Hello from Kotlin!\n")

&nbsp;&nbsp;&nbsp;&nbsp;println("File '$filename' written successfully.")
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    JVM â†’ garbage collected
				</p>
			</li>
			<li>
				<p>
                    Kotlin/Native â†’ ARC + cycle collector
				</p>
			</li>
			<li>
				<p>
                    Kotlin/JS â†’ GC via JS engine
				</p>
			</li>
			<li>
				<p>
                    No manual free
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="dart-2011" >
    Dart (2011)
</h3>
<ul>
	<li>
		<p>
            Client apps (Flutter) and web.
		</p>
	</li>
</ul>
<pre><code class="language-dart" data-lang="dart">import 'dart:io';

// Function
String greet(String name) {
&nbsp;&nbsp;&nbsp;&nbsp;return 'Hello, $name!';
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;String name = 'Alice';
&nbsp;&nbsp;&nbsp;&nbsp;int age = 30;

&nbsp;&nbsp;&nbsp;&nbsp;print('Name: $name');
&nbsp;&nbsp;&nbsp;&nbsp;print('Age: $age');

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if (age &gt;= 18) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('$name is an adult.');
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('$name is a minor.');
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// List (dynamic array)
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; fruits = ['apple', 'banana', 'orange'];
&nbsp;&nbsp;&nbsp;&nbsp;print('First fruit: ${fruits[0]}');

&nbsp;&nbsp;&nbsp;&nbsp;print('All fruits:');
&nbsp;&nbsp;&nbsp;&nbsp;for (var fruit in fruits) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('- $fruit');
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Map
&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, String&gt; person = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'name': 'Bob',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'city': 'SÃ£o Paulo',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'job': 'Developer',
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;print('Person info:');
&nbsp;&nbsp;&nbsp;&nbsp;person.forEach((key, value) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('$key =&gt; $value');
&nbsp;&nbsp;&nbsp;&nbsp;});

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;print('Counting:');
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= 5; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(i);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call function
&nbsp;&nbsp;&nbsp;&nbsp;print(greet('World'));

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;String filename = 'output.txt';
&nbsp;&nbsp;&nbsp;&nbsp;File(filename).writeAsStringSync('Hello from Dart!\n');

&nbsp;&nbsp;&nbsp;&nbsp;print("File '$filename' written successfully.");
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Generational GC in Dart VM
				</p>
			</li>
			<li>
				<p>
                    AOT builds still GC-managed
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="elixir-2011" >
    Elixir (2011)
</h3>
<ul>
	<li>
		<p>
            Functional concurrent systems.
		</p>
	</li>
	<li>
		<p>
            Runs on Erlang VM (BEAM).
		</p>
	</li>
</ul>
<pre><code class="language-elixir" data-lang="elixir"># Function
defmodule Example do
&nbsp;&nbsp;def greet(name) do
&nbsp;&nbsp;&nbsp;&nbsp;"Hello, #{name}!"
&nbsp;&nbsp;end
end

defmodule Main do
&nbsp;&nbsp;def run do
&nbsp;&nbsp;&nbsp;&nbsp;# Variables (immutable)
&nbsp;&nbsp;&nbsp;&nbsp;name = "Alice"
&nbsp;&nbsp;&nbsp;&nbsp;age = 30

&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("Name: #{name}")
&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("Age: #{age}")

&nbsp;&nbsp;&nbsp;&nbsp;# Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if age &gt;= 18 do
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("#{name} is an adult.")
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("#{name} is a minor.")
&nbsp;&nbsp;&nbsp;&nbsp;end

&nbsp;&nbsp;&nbsp;&nbsp;# List
&nbsp;&nbsp;&nbsp;&nbsp;fruits = ["apple", "banana", "orange"]
&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("First fruit: #{Enum.at(fruits, 0)}")

&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("All fruits:")
&nbsp;&nbsp;&nbsp;&nbsp;Enum.each(fruits, fn fruit -&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("- #{fruit}")
&nbsp;&nbsp;&nbsp;&nbsp;end)

&nbsp;&nbsp;&nbsp;&nbsp;# Map
&nbsp;&nbsp;&nbsp;&nbsp;person = %{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: "Bob",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city: "SÃ£o Paulo",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job: "Developer"
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("Person info:")
&nbsp;&nbsp;&nbsp;&nbsp;Enum.each(person, fn {key, value} -&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("#{key} =&gt; #{value}")
&nbsp;&nbsp;&nbsp;&nbsp;end)

&nbsp;&nbsp;&nbsp;&nbsp;# Loop via range
&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("Counting:")
&nbsp;&nbsp;&nbsp;&nbsp;Enum.each(1..5, fn i -&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO.puts(i)
&nbsp;&nbsp;&nbsp;&nbsp;end)

&nbsp;&nbsp;&nbsp;&nbsp;# Call function
&nbsp;&nbsp;&nbsp;&nbsp;IO.puts(Example.greet("World"))

&nbsp;&nbsp;&nbsp;&nbsp;# File write example
&nbsp;&nbsp;&nbsp;&nbsp;filename = "output.txt"
&nbsp;&nbsp;&nbsp;&nbsp;File.write!(filename, "Hello from Elixir!\n")

&nbsp;&nbsp;&nbsp;&nbsp;IO.puts("File '#{filename}' written successfully.")
&nbsp;&nbsp;end
end

Main.run()
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Per-process heap GC (very important)
				</p>
			</li>
			<li>
				<p>
                    Lightweight isolated processes
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="c2-2011" >
    C2 (2011)
</h3>
<pre><code class="language-c" data-lang="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Function
const char* greet(const char* name) {
&nbsp;&nbsp;&nbsp;&nbsp;return "Hello from C2!";
}

// Struct
struct Person {
&nbsp;&nbsp;&nbsp;&nbsp;const char* name;
&nbsp;&nbsp;&nbsp;&nbsp;const char* city;
&nbsp;&nbsp;&nbsp;&nbsp;const char* job;
};

int main() {
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;const char* name = "Alice";
&nbsp;&nbsp;&nbsp;&nbsp;int age = 30;

&nbsp;&nbsp;&nbsp;&nbsp;printf("Name: %s\n", name);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Age: %d\n", age);

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if (age &gt;= 18) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s is an adult.\n", name);
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s is a minor.\n", name);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Array
&nbsp;&nbsp;&nbsp;&nbsp;const char* fruits[] = {"apple", "banana", "orange"};
&nbsp;&nbsp;&nbsp;&nbsp;printf("First fruit: %s\n", fruits[0]);

&nbsp;&nbsp;&nbsp;&nbsp;printf("All fruits:\n");
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 3; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("- %s\n", fruits[i]);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Struct usage
&nbsp;&nbsp;&nbsp;&nbsp;struct Person person = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.name = "Bob",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.city = "SÃ£o Paulo",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.job&nbsp;&nbsp;= "Developer"
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;printf("Person info:\n");
&nbsp;&nbsp;&nbsp;&nbsp;printf("name =&gt; %s\n", person.name);
&nbsp;&nbsp;&nbsp;&nbsp;printf("city =&gt; %s\n", person.city);
&nbsp;&nbsp;&nbsp;&nbsp;printf("job&nbsp;&nbsp;=&gt; %s\n", person.job);

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;printf("Counting:\n");
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= 5; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n", i);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call function
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n", greet("World"));

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;const char* filename = "output.txt";
&nbsp;&nbsp;&nbsp;&nbsp;FILE* f = fopen(filename, "w");
&nbsp;&nbsp;&nbsp;&nbsp;if (!f) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("Error opening file");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;fprintf(f, "Hello from C2!\n");
&nbsp;&nbsp;&nbsp;&nbsp;fclose(f);

&nbsp;&nbsp;&nbsp;&nbsp;printf("File '%s' written successfully.\n", filename);
&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Manual memory (C-like)
				</p>
			</li>
			<li>
				<p>
                    No garbage collector
				</p>
			</li>
			<li>
				<p>
                    Stack allocation
				</p>
			</li>
			<li>
				<p>
                    Predictable layout
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="typescript-2012" >
    TypeScript (2012)
</h3>
<ul>
	<li>
		<p>
            Statically typed superset of JavaScript.
		</p>
	</li>
</ul>
<pre><code class="language-ts" data-lang="ts">const x: number = 42;
console.log(`Value: ${x}`);
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Same as JavaScript runtime
				</p>
			</li>
			<li>
				<p>
                    Automatic GC (engine-dependent)
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="julia-2012" >
    Julia (2012)
</h3>
<ul>
	<li>
		<p>
            High-performance scientific computing.
		</p>
	</li>
</ul>
<pre><code class="language-julia" data-lang="julia">x = 42
println("Value: $x")
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection
				</p>
			</li>
			<li>
				<p>
                    Generational mark-and-sweep
				</p>
			</li>
			<li>
				<p>
                    Stack allocation for some immutables
				</p>
			</li>
			<li>
				<p>
                    Manual memory possible via Ptr and ccall
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="swift-2014" >
    Swift (2014)
</h3>
<ul>
	<li>
		<p>
            Systems-capable language for Apple platforms.
		</p>
	</li>
</ul>
<pre><code class="language-swift" data-lang="swift">import Foundation

// Function
func greet(_ name: String) -&gt; String {
&nbsp;&nbsp;&nbsp;&nbsp;return "Hello, \(name)!"
}

func main() {
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;let name = "Alice"
&nbsp;&nbsp;&nbsp;&nbsp;let age = 30

&nbsp;&nbsp;&nbsp;&nbsp;print("Name: \(name)")
&nbsp;&nbsp;&nbsp;&nbsp;print("Age: \(age)")

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if age &gt;= 18 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("\(name) is an adult.")
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("\(name) is a minor.")
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Array
&nbsp;&nbsp;&nbsp;&nbsp;let fruits = ["apple", "banana", "orange"]
&nbsp;&nbsp;&nbsp;&nbsp;print("First fruit: \(fruits[0])")

&nbsp;&nbsp;&nbsp;&nbsp;print("All fruits:")
&nbsp;&nbsp;&nbsp;&nbsp;for fruit in fruits {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("- \(fruit)")
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Dictionary
&nbsp;&nbsp;&nbsp;&nbsp;let person: [String: String] = [
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name": "Bob",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"city": "SÃ£o Paulo",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"job": "Developer"
&nbsp;&nbsp;&nbsp;&nbsp;]

&nbsp;&nbsp;&nbsp;&nbsp;print("Person info:")
&nbsp;&nbsp;&nbsp;&nbsp;for (key, value) in person {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("\(key) =&gt; \(value)")
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;print("Counting:")
&nbsp;&nbsp;&nbsp;&nbsp;for i in 1...5 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(i)
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call function
&nbsp;&nbsp;&nbsp;&nbsp;print(greet("World"))

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;let filename = "output.txt"
&nbsp;&nbsp;&nbsp;&nbsp;let content = "Hello from Swift!\n"
&nbsp;&nbsp;&nbsp;&nbsp;do {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try content.write(toFile: filename, atomically: true, encoding: .utf8)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("File '\(filename)' written successfully.")
&nbsp;&nbsp;&nbsp;&nbsp;} catch {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Error writing file: \(error)")
&nbsp;&nbsp;&nbsp;&nbsp;}
}

main()
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic Reference Counting (ARC)
				</p>
			</li>
			<li>
				<p>
                    Deterministic destruction
				</p>
			</li>
			<li>
				<p>
                    Weak/unowned references for cycles
				</p>
			</li>
			<li>
				<p>
                    Manual memory possible via unsafe pointers
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="hack-2014" >
    Hack (2014)
</h3>
<ul>
	<li>
		<p>
            Statically typed evolution of PHP for large codebases.
		</p>
	</li>
</ul>
<pre><code class="language-php" data-lang="php">&lt;?hh

function main(): void {
&nbsp;&nbsp;$x = 42;
&nbsp;&nbsp;echo "Value: $x\n";
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Reference counting (HHVM)
				</p>
			</li>
			<li>
				<p>
                    Cycle detection
				</p>
			</li>
			<li>
				<p>
                    Managed heap
				</p>
			</li>
			<li>
				<p>
                    No manual control in typical code
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="crystal-2014" >
    Crystal (2014)
</h3>
<ul>
	<li>
		<p>
            Ruby-like syntax with native performance.
		</p>
	</li>
</ul>
<pre><code class="language-ruby" data-lang="ruby">x = 42
puts "Value: #{x}"
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic garbage collection (Boehm GC historically; modern incremental GC)
				</p>
			</li>
			<li>
				<p>
                    Compiles to native code
				</p>
			</li>
			<li>
				<p>
                    No manual free
				</p>
			</li>
			<li>
				<p>
                    Stack allocation possible via compiler analysis
				</p>
			</li>
			<li>
				<p>
                    Faster than Ruby, still GC pauses exist.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="gdscript-2014" >
    GDScript (2014)
</h3>
<ul>
	<li>
		<p>
            Python-like scripting for Godot.
		</p>
	</li>
</ul>
<pre><code class="language-gd" data-lang="gd">func _ready():
&nbsp;&nbsp;&nbsp;&nbsp;var x = 42
&nbsp;&nbsp;&nbsp;&nbsp;print("Value: ", x)
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Reference counting for Objects
				</p>
			</li>
			<li>
				<p>
                    Engine-managed memory
				</p>
			</li>
			<li>
				<p>
                    Automatic cleanup when nodes freed
				</p>
			</li>
			<li>
				<p>
                    No manual free for most gameplay code
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="raku-2015" >
    Raku (2015)
</h3>
<ul>
	<li>
		<p>
            Modern multi-paradigm language evolved from Perl.
		</p>
	</li>
</ul>
<pre><code class="language-raku" data-lang="raku">class Circle {
&nbsp;&nbsp;&nbsp;&nbsp;has $.radius;
&nbsp;&nbsp;&nbsp;&nbsp;method area { Ï€ * $.radiusÂ² }
}

my @radii = 1,2,4...256;

my @circles = map { Circle.new(:$^radius) }, @radii;

my $total-area = [+] @circlesÂ».area;


say "Total area: $total-area";
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://raku.org/" 
				class="external-link" 
				target="_blank" >
                Raku
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="jai-2015" >
    Jai (2015)
</h3>
<pre><code class="language-jai" data-lang="jai">#import "Basic";

// Procedure
greet :: (name: string) -&gt; string {
&nbsp;&nbsp;&nbsp;&nbsp;return tprint("Hello, %!", name);
}

// Struct
Person :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;name: string;
&nbsp;&nbsp;&nbsp;&nbsp;city: string;
&nbsp;&nbsp;&nbsp;&nbsp;job:&nbsp;&nbsp;string;
}

main :: () {
&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;name := "Alice";
&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;&nbsp;:= 30;

&nbsp;&nbsp;&nbsp;&nbsp;print("Name: %\n", name);
&nbsp;&nbsp;&nbsp;&nbsp;print("Age: %\n", age);

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if age &gt;= 18 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("% is an adult.\n", name);
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("% is a minor.\n", name);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Array
&nbsp;&nbsp;&nbsp;&nbsp;fruits := .["apple", "banana", "orange"];
&nbsp;&nbsp;&nbsp;&nbsp;print("First fruit: %\n", fruits[0]);

&nbsp;&nbsp;&nbsp;&nbsp;print("All fruits:\n");
&nbsp;&nbsp;&nbsp;&nbsp;for fruit: fruits {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("- %\n", fruit);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Struct usage
&nbsp;&nbsp;&nbsp;&nbsp;person := Person.{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = "Bob",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city = "SÃ£o Paulo",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job&nbsp;&nbsp;= "Developer",
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;print("Person info:\n");
&nbsp;&nbsp;&nbsp;&nbsp;print("name =&gt; %\n", person.name);
&nbsp;&nbsp;&nbsp;&nbsp;print("city =&gt; %\n", person.city);
&nbsp;&nbsp;&nbsp;&nbsp;print("job&nbsp;&nbsp;=&gt; %\n", person.job);

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;print("Counting:\n");
&nbsp;&nbsp;&nbsp;&nbsp;for i := 1; i &lt;= 5; i += 1 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("%\n", i);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call procedure
&nbsp;&nbsp;&nbsp;&nbsp;print("%\n", greet("World"));

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;filename := "output.txt";
&nbsp;&nbsp;&nbsp;&nbsp;file, ok := file_open(filename, .WRITE);
&nbsp;&nbsp;&nbsp;&nbsp;if ok {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_write_string(file, "Hello from Jai!\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_close(file);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("File '%' written successfully.\n", filename);
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Error opening file.\n");
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Manual memory management
				</p>
			</li>
			<li>
				<p>
                    Custom allocators emphasized
				</p>
			</li>
			<li>
				<p>
                    No mandatory GC
				</p>
			</li>
			<li>
				<p>
                    Designed for arena-style allocation
				</p>
			</li>
			<li>
				<p>
                    Deterministic by design
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="zig-2016" >
    Zig (2016)
</h3>
<pre><code class="language-zig" data-lang="zig">const std = @import("std");

// Function
fn greet(name: []const u8) []const u8 {
&nbsp;&nbsp;&nbsp;&nbsp;_ = name;
&nbsp;&nbsp;&nbsp;&nbsp;return "Hello from Zig!";
}

pub fn main() !void {
&nbsp;&nbsp;&nbsp;&nbsp;const stdout = std.io.getStdOut().writer();

&nbsp;&nbsp;&nbsp;&nbsp;// Variables
&nbsp;&nbsp;&nbsp;&nbsp;const name = "Alice";
&nbsp;&nbsp;&nbsp;&nbsp;const age: u32 = 30;

&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("Name: {s}\n", .{name});
&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("Age: {}\n", .{age});

&nbsp;&nbsp;&nbsp;&nbsp;// Conditional
&nbsp;&nbsp;&nbsp;&nbsp;if (age &gt;= 18) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("{s} is an adult.\n", .{name});
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("{s} is a minor.\n", .{name});
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Array
&nbsp;&nbsp;&nbsp;&nbsp;const fruits = [_][]const u8{"apple", "banana", "orange"};
&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("First fruit: {s}\n", .{fruits[0]});

&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("All fruits:\n", .{});
&nbsp;&nbsp;&nbsp;&nbsp;for (fruits) |fruit| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("- {s}\n", .{fruit});
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// HashMap
&nbsp;&nbsp;&nbsp;&nbsp;var gpa = std.heap.GeneralPurposeAllocator(.{}){};
&nbsp;&nbsp;&nbsp;&nbsp;defer _ = gpa.deinit();
&nbsp;&nbsp;&nbsp;&nbsp;const allocator = gpa.allocator();

&nbsp;&nbsp;&nbsp;&nbsp;var person = std.StringHashMap([]const u8).init(allocator);
&nbsp;&nbsp;&nbsp;&nbsp;defer person.deinit();

&nbsp;&nbsp;&nbsp;&nbsp;try person.put("name", "Bob");
&nbsp;&nbsp;&nbsp;&nbsp;try person.put("city", "SÃ£o Paulo");
&nbsp;&nbsp;&nbsp;&nbsp;try person.put("job", "Developer");

&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("Person info:\n", .{});
&nbsp;&nbsp;&nbsp;&nbsp;var it = person.iterator();
&nbsp;&nbsp;&nbsp;&nbsp;while (it.next()) |entry| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("{s} =&gt; {s}\n", .{ entry.key_ptr.*, entry.value_ptr.* });
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Loop
&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("Counting:\n", .{});
&nbsp;&nbsp;&nbsp;&nbsp;var i: u32 = 1;
&nbsp;&nbsp;&nbsp;&nbsp;while (i &lt;= 5) : (i += 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("{}\n", .{i});
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Call function
&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("{s}\n", .{greet("World")});

&nbsp;&nbsp;&nbsp;&nbsp;// File write example
&nbsp;&nbsp;&nbsp;&nbsp;const filename = "output.txt";
&nbsp;&nbsp;&nbsp;&nbsp;try std.fs.cwd().writeFile(.{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.sub_path = filename,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.data = "Hello from Zig!\n",
&nbsp;&nbsp;&nbsp;&nbsp;});

&nbsp;&nbsp;&nbsp;&nbsp;try stdout.print("File '{s}' written successfully.\n", .{filename});
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Explicit allocator passing
				</p>
			</li>
			<li>
				<p>
                    No hidden allocations
				</p>
			</li>
			<li>
				<p>
                    No garbage collector
				</p>
			</li>
			<li>
				<p>
                    Stack allocation encouraged
				</p>
			</li>
			<li>
				<p>
                    Manual free required
				</p>
			</li>
			<li>
				<p>
                    Optional arena patterns
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="odin-2016" >
    Odin (2016)
</h3>
<pre><code class="language-odin" data-lang="odin">package main

import "core:fmt"

main :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp;x: int = 42
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("Value:", x)
}
</code></pre>
<ul>
	<li>
		<p>
            Uses LLVM.
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Manual memory management
				</p>
			</li>
			<li>
				<p>
                    Explicit allocators, with default values.
				</p>
			</li>
			<li>
				<p>
                    No built-in GC (optional libraries exist)
				</p>
			</li>
			<li>
				<p>
                    Stack allocation supported
				</p>
			</li>
			<li>
				<p>
                    Designed for data-oriented control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="c3-2019" >
    C3 (2019)
</h3>
<pre><code class="language-c" data-lang="c">import std::io;

fn void main() {
&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;io::printn("Value: {}", x);
}
</code></pre>
<pre><code class="language-c" data-lang="c">import std::mem;
import std::io;

fn void main() {
&nbsp;&nbsp;&nbsp;&nbsp;int* p = mem::alloc&lt;int&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;*p = 42;
&nbsp;&nbsp;&nbsp;&nbsp;io::printn("Value: {}", *p);
&nbsp;&nbsp;&nbsp;&nbsp;mem::free(p);
}
</code></pre>
<ul>
	<li>
		<p>
            Has Methods:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">struct Foo
{
&nbsp;&nbsp;&nbsp;&nbsp;int i;
}

fn void Foo.next(Foo* this) // &lt;- Method
{
&nbsp;&nbsp;&nbsp;&nbsp;if (this) this.i++;
}

fn void test()
{
&nbsp;&nbsp;&nbsp;&nbsp;Foo foo = { 2 };
&nbsp;&nbsp;&nbsp;&nbsp;foo.next();
&nbsp;&nbsp;&nbsp;&nbsp;foo.next();
&nbsp;&nbsp;&nbsp;&nbsp;// Prints 4
&nbsp;&nbsp;&nbsp;&nbsp;io::printfn("%d", foo.i);
}
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://c3-lang.org/" 
				class="external-link" 
				target="_blank" >
                C3
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://c3-lang.org/language-overview/examples/" 
				class="external-link" 
				target="_blank" >
                Examples
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Uses LLVM.
		</p>
	</li>
	<li>
		<p>
            Compile-time execution.
		</p>
	</li>
	<li>
		<p>
            Clean module system.
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Manual allocation
				</p>
			</li>
			<li>
				<p>
                    No GC
				</p>
			</li>
			<li>
				<p>
                    Optional safety checks
				</p>
			</li>
			<li>
				<p>
                    Stack + heap control
				</p>
			</li>
			<li>
				<p>
                    Contracts and safety checks
				</p>
			</li>
			<li>
				<p>
                    Explicit ownership patterns encouraged
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Macros:
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://c3-lang.org/generic-programming/macros/" 
						class="external-link" 
						target="_blank" >
                        C3 Macros
					</a>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="gleam-2019" >
    Gleam (2019)
</h3>
<ul>
	<li>
		<p>
            Statically typed functional language for BEAM.
		</p>
	</li>
</ul>
<pre><code class="language-gleam" data-lang="gleam">import gleam/io

pub fn main() {
&nbsp;&nbsp;let x = 42
&nbsp;&nbsp;io.println("Value: " &lt;&gt; int.to_string(x))
}
</code></pre>
<pre><code class="language-gleam" data-lang="gleam">pub fn main() {
&nbsp;&nbsp;let subject = process.new_subject()

&nbsp;&nbsp;// Spawn a child green thread
&nbsp;&nbsp;process.spawn(fn() {
&nbsp;&nbsp;&nbsp;&nbsp;// Send a message back to the parent
&nbsp;&nbsp;&nbsp;&nbsp;process.send(subject, "Hello, Joe!")
&nbsp;&nbsp;})

&nbsp;&nbsp;// Wait for the message to arrive
&nbsp;&nbsp;echo process.receive(subject, 100)
}
</code></pre>
<pre><code class="language-gleam" data-lang="gleam">@external(erlang, "Elixir.HPAX", "new")
pub fn new(size: Int) -&gt; Table

pub fn register_event_handler() {
&nbsp;&nbsp;let el = document.query_selector("a")
&nbsp;&nbsp;element.add_event_listener(el, fn() {
&nbsp;&nbsp;&nbsp;&nbsp;io.println("Clicked!")
&nbsp;&nbsp;})
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Automatic GC via BEAM
				</p>
			</li>
			<li>
				<p>
                    Per-process heaps (inherited from Erlang)
				</p>
			</li>
			<li>
				<p>
                    Immutable data structures
				</p>
			</li>
			<li>
				<p>
                    No manual memory control
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="v-2019" >
    V (2019)
</h3>
<pre><code class="language-v" data-lang="v">fn main() {
&nbsp;&nbsp;&nbsp;&nbsp;x := 42
&nbsp;&nbsp;&nbsp;&nbsp;println('Value: $x')
}
</code></pre>
<pre><code class="language-v" data-lang="v">fn main() {
&nbsp;&nbsp;&nbsp;&nbsp;areas := ['game', 'web', 'tools', 'science', 'systems',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'embedded', 'drivers', 'GUI', 'mobile']
&nbsp;&nbsp;&nbsp;&nbsp;for area in areas {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println('Hello, ${area} developers!')
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://vlang.io/" 
				class="external-link" 
				target="_blank" >
                V Lang
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/vlang/v" 
				class="external-link" 
				target="_blank" >
                V Lang
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    There are 4 ways to manage memory in V:
				</p>
				<ul>
					<li>
						<p>
                            The default is a minimal and a well performing tracing GC.
						</p>
					</li>
					<li>
						<p>
                            The second way is autofree, it can be enabled with -autofree. It takes care of most objects (~90-100%): the compiler inserts necessary free calls automatically during compilation. Remaining small percentage of objects is freed via GC. The developer doesn't need to change anything in their code. &quot;It just works&quot;, like in Python, Go, or Java, except there's no heavy GC tracing everything or expensive RC for each object. Autofree is still experimental and not production ready yet. That's planned for V 1.0.
						</p>
					</li>
					<li>
						<p>
                            For developers willing to have more low level control, memory can be managed manually with -gc none.
						</p>
					</li>
					<li>
						<p>
                            Arena allocation is available via v -prealloc.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="beef-2019" >
    Beef (2019)
</h3>
<ul>
	<li>
		<p>
            Native language with C# ergonomics.
		</p>
	</li>
</ul>
<pre><code class="language-cs" data-lang="cs">using System;

class Program {
&nbsp;&nbsp;&nbsp;&nbsp;static void Main() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = 42;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"Value: {x}");
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Deterministic destruction (RAII-style)
				</p>
			</li>
			<li>
				<p>
                    No mandatory garbage collector
				</p>
			</li>
			<li>
				<p>
                    Optional GC available
				</p>
			</li>
			<li>
				<p>
                    Manual allocation supported
				</p>
			</li>
			<li>
				<p>
                    Value types on stack
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="fil-c-2021" >
    Fil-C (2021)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_AsXnyi2Mus" 
				class="external-link" 
				target="_blank" >
                Fil-C
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://fil-c.org/" 
				class="external-link" 
				target="_blank" >
                Fil-C
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="hare-2021" >
    Hare (2021)
</h3>
<pre><code class="language-hare" data-lang="hare">use fmt;

export fn main() void = {
&nbsp;&nbsp;&nbsp;&nbsp;const greetings = [
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Hello, world!",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Â¡Hola Mundo!",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Î“ÎµÎ¹Î¬ ÏƒÎ¿Ï… ÎšÏŒÏƒÎ¼Îµ!",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ÐŸÑ€Ð¸Ð²Ñ–Ñ‚, ÑÐ²Ñ–Ñ‚Ðµ!",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ã“ã‚“ã«ã¡ã¯ä¸–ç•Œï¼",
&nbsp;&nbsp;&nbsp;&nbsp;];
&nbsp;&nbsp;&nbsp;&nbsp;for (let greeting .. greetings) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt::println(greeting)!;
&nbsp;&nbsp;&nbsp;&nbsp;};
};
</code></pre>
<pre><code class="language-hare" data-lang="hare">let x = 10;
let y: *int = &x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Guaranteed to be non-null
let z: nullable *int = y; // May be null!

*y; // Valid
*z; // Error: main.ha:6:19: Cannot dereference nullable pointer type

match (z) {
case null =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;abort();
case let z: *int =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;yield *z; // Valid
};
</code></pre>
<pre><code class="language-hare" data-lang="hare">let x: int = if (foo) {
&nbsp;&nbsp;&nbsp;&nbsp;let results = do_work();
&nbsp;&nbsp;&nbsp;&nbsp;yield results.x;
} else 42;
</code></pre>
<pre><code class="language-hare" data-lang="hare">fn io::write(s: *stream, buf: const []u8) (size | io::error);

// ...

sum += match (io::write(s, buf)) {
case let err: io::error =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;match (err) {
&nbsp;&nbsp;&nbsp;&nbsp;case unsupported =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abort("Expected write to be supported");
&nbsp;&nbsp;&nbsp;&nbsp;case =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;
&nbsp;&nbsp;&nbsp;&nbsp;};
case let n: size =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;process(buf[..n]);
&nbsp;&nbsp;&nbsp;&nbsp;yield n;
};
</code></pre>
<ul>
	<li>
		<p>
            Hare is a systems programming language designed to be simple, stable, and robust. Hare uses a static type system, manual memory management, and a minimal runtime. It is well-suited to writing operating systems, system tools, compilers, networking software, and other low-level, high performance tasks.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://harelang.org/" 
				class="external-link" 
				target="_blank" >
                Hare lang
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://harelang.org/blog/2021-02-09-hare-advances-on-c/" 
				class="external-link" 
				target="_blank" >
                Hare advantages on C
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://sr.ht/~sircmpwn/hare/" 
				class="external-link" 
				target="_blank" >
                Hare Source Code
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://harebyexample.org/" 
				class="external-link" 
				target="_blank" >
                Hare by example
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://hareprogramming.com/" 
				class="external-link" 
				target="_blank" >
                Hare docs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://harelang.org/documentation/" 
				class="external-link" 
				target="_blank" >
                Hare docs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=oDEuf1gcapY&list=PLPi563THK-X_yMKQs9lzRRB2QBJrWnMA_&index=10" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            QBE Compiler.
		</p>
	</li>
	<li>
		<p>
            Expression oriented.
		</p>
	</li>
	<li>
		<p>
            Bound checking in arrays and slices.
		</p>
	</li>
	<li>
		<p>
            Optional unbound arrays for performance.
		</p>
	</li>
	<li>
		<p>
            No NULL value.
		</p>
	</li>
	<li>
		<p>
            Non-nullable pointers by default; cannot deref null pointer.
		</p>
	</li>
	<li>
		<p>
            Defer.
		</p>
	</li>
	<li>
		<p>
            Mandatory error handling.
		</p>
	</li>
	<li>
		<p>
            No macros, generics or multithreading.
		</p>
	</li>
	<li>
		<p>
            Transparency:
		</p>
		<ul>
			<li>
				<p>
                    No function overloading.
				</p>
			</li>
			<li>
				<p>
                    No operator overloading.
				</p>
			</li>
			<li>
				<p>
                    No implicit conversions.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            (2026-02-13) Hare 0.26.0 released.
		</p>
	</li>
</ul>
<h3
	id="carbon-2022" >
    Carbon (2022)
</h3>
<ul>
	<li>
		<p>
            Experimental successor language for C++.
		</p>
	</li>
</ul>
<pre><code class="language-carbon" data-lang="carbon">package Main;

fn Main() -&gt; i32 {
&nbsp;&nbsp;var x: i32 = 42;
&nbsp;&nbsp;Print("Value: {0}\n", x);
&nbsp;&nbsp;return 0;
}
</code></pre>
<pre><code class="language-carbon" data-lang="carbon">// Carbon:
package Geometry;
import Math;

class Circle {
&nbsp;&nbsp;var r: f32;
}

fn PrintTotalArea(circles: [Circle]) {
&nbsp;&nbsp;var area: f32 = 0;
&nbsp;&nbsp;for (c: Circle in circles) {
&nbsp;&nbsp;&nbsp;&nbsp;area += Math.Pi * c.r * c.r;
&nbsp;&nbsp;}
&nbsp;&nbsp;Print("Total area: {0}", area);
}

fn Run() -&gt; i32 {
&nbsp;&nbsp;// A dynamically sized array, like `std::vector`.
&nbsp;&nbsp;var circles: array [Circle] = ({.r = 1.0}, {.r = 2.0});
&nbsp;&nbsp;// Implicitly constructs a slice from the array.
&nbsp;&nbsp;PrintTotalArea(circles);
&nbsp;&nbsp;return 0;
}
</code></pre>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/carbon-language/carbon-lang" 
				class="external-link" 
				target="_blank" >
                Carbon
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Manual memory management (C++-like model)
				</p>
			</li>
			<li>
				<p>
                    No garbage collector by default
				</p>
			</li>
			<li>
				<p>
                    RAII-oriented design (planned)
				</p>
			</li>
			<li>
				<p>
                    Interop with C++
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="mojo-2023" >
    Mojo (2023)
</h3>
<ul>
	<li>
		<p>
            Python-like syntax for high-performance and AI.
		</p>
	</li>
</ul>
<pre><code class="language-mojo" data-lang="mojo">fn main():
&nbsp;&nbsp;&nbsp;&nbsp;let x: Int = 42
&nbsp;&nbsp;&nbsp;&nbsp;print("Value:", x)
</code></pre>
<ul>
	<li>
		<p>
            Memory management
		</p>
		<ul>
			<li>
				<p>
                    Ownership-based model (Rust-inspired direction)
				</p>
			</li>
			<li>
				<p>
                    Manual and automatic strategies planned
				</p>
			</li>
			<li>
				<p>
                    Value types with stack allocation
				</p>
			</li>
			<li>
				<p>
                    No traditional GC in performance mode
				</p>
			</li>
			<li>
				<p>
                    Still evolving
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-2026 ðŸš€
			</footer>
		</main>
		<script
			src="/static/studies.92425.js" >
		</script>
	</body>
</html>
