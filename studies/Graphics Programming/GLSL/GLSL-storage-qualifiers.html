<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.61297.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
>
					<summary>
                        Vulkan
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                Samples
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                Core
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                Render Loop
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                Synchronization and Cache Control
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                Command Buffers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                Pipelines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                Compute Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                Resources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                Depth
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                Mapping Data to Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                Memory Allocation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                HDR Support
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                Profiling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                Mobile
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                VR
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                Video Decoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                SPIR-V
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                Web
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Render Engineering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                Graphics APIs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                Shader Languages
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                Choosing the Space to compute Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                BSDF (Bidirectional Scattering Distribution Function)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                Material
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                Direct Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                Shadows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                Skybox / Skydome
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                Transparency
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                Global Illumination / Indirect Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                Global Illumination - Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                Global Illumination - Discarded Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                Lightmaps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                Post-Processing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                Anti-Aliasing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                Light Path / Rendering Method
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                Optimization Techniques
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Graphics and Shaders
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                Sources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                Math, Linear Algebra
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                Spaces, Transformations and Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                Common Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                Shaders
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        GLSL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                Storage Qualifiers
							</a>
							<ul>
								<li>
									<a
										href="#auxiliars" >
                                        Auxiliars
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#interface-blocks" >
                                        Interface Blocks
									</a>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                Layout Qualifiers
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GPU
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                Execution Building Blocks
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                Specialized units &amp; instructions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                Cache
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                GPU VA (Virtual Address)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                Tiled-GPUs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Slang
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang-slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Font Rendering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                Text Processing Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                Formats
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                Libs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                Fonts
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        OpenGL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Storage Qualifiers
						</h1>
						<p>
							<time
								datetime="2025-07-28" >
                                üïí Created: 2025-07-28
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<ul>
	<li>
		<p>
            Local variables can only use the 
			<strong>
                const
			</strong>
            &nbsp;storage qualifier (or use no storage qualifier).
		</p>
	</li>
	<li>
		<p>
            Note that function parameters can use 
			<strong>
                const
			</strong>
            , 
			<strong>
                in
			</strong>
            , and 
			<strong>
                out
			</strong>
            &nbsp;qualifiers, but as 
			<em>
                parameter qualifiers
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Function return types and structure members do not use storage qualifiers.
		</p>
	</li>
	<li>
		<p>
            Initializers in global declarations may only be used in declarations of global variables with no storage qualifier, with a 
			<strong>
                const
			</strong>
            &nbsp;qualifier, or with a 
			<strong>
                uniform
			</strong>
            &nbsp;qualifier. Global variables without storage qualifiers that are not initialized in their declaration or by the application will not be initialized, but rather will enter 
			<em>
                main()
			</em>
            &nbsp;with undefined values.
		</p>
	</li>
</ul>
<h5
	id="ltnone-defaultgreater" >
    &lt;none: default&gt;
</h5>
<ul>
	<li>
		<p>
            If no qualifier is present on a global variable, then the variable has no linkage to the application or shaders running on other pipeline stages.
		</p>
	</li>
	<li>
		<p>
            For either global or local unqualified variables, the declaration will appear to allocate memory associated with the processor it targets.
		</p>
	</li>
	<li>
		<p>
            This variable will provide read/write access to this allocated memory.
		</p>
	</li>
</ul>
<h5
	id="const" >
    const
</h5>
<ul>
	<li>
		<p>
            a variable whose value cannot be changed.
		</p>
	</li>
	<li>
		<p>
            Named compile-time constants or read-only variables can be declared using the 
			<strong>
                const
			</strong>
            &nbsp;qualifier. The 
			<strong>
                const
			</strong>
            &nbsp;qualifier can be used with any of the non-void transparent basic data types, as well as with structures and arrays of these. It is a compile-time error to write to a 
			<strong>
                const
			</strong>
            &nbsp;variable outside of its declaration, so they must be initialized when declared. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">const vec3 zAxis = vec3 (0.0, 0.0, 1.0);
const float ceiling = a + b; // a and b not necessarily constants
</code></pre>
<ul>
	<li>
		<p>
            Structure members may not be qualified with 
			<strong>
                const
			</strong>
            . Structure variables can be declared as 
			<strong>
                const
			</strong>
            , and initialized with a structure constructor or initializer.
		</p>
	</li>
	<li>
		<p>
            Initializers for 
			<strong>
                const
			</strong>
            &nbsp;declarations at global scope must be constant expressions
		</p>
	</li>
	<li>
		<p>
			<strong>
                Constant Expressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    SPIR-V specialization constants are expressed in GLSL as 
					<strong>
                        const
					</strong>
                    &nbsp;with the layout qualifier 
					<strong>
                        constant_id
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        constant expression
					</em>
                    &nbsp;is one of
				</p>
				<ul>
					<li>
						<p>
                            A literal value (e.g. 
							<strong>
                                5
							</strong>
                            &nbsp;or 
							<strong>
                                true
							</strong>
                            ).
						</p>
					</li>
					<li>
						<p>
                            A variable declared with the 
							<strong>
                                const
							</strong>
                            &nbsp;qualifier and an initializer, where the initializer is a constant expression. This includes both 
							<strong>
                                const
							</strong>
                            &nbsp;declared with a specialization-constant layout qualifier, e.g. 
							<strong>
                                layout
							</strong>
                            (
							<strong>
                                constant_id
							</strong>
                            &nbsp;= ‚Ä¶‚Äã), and those declared without a specialization-constant layout qualifier.
						</p>
					</li>
					<li>
						<p>
                            Built-in variables qualified as 
							<strong>
                                const
							</strong>
                            .
						</p>
					</li>
					<li>
						<p>
                            An expression formed by an operator on operands that are all constant expressions, including getting an element of a constant array, or a member of a constant structure, or components of a constant vector. However, the lowest precedence operators of the sequence operator (
							<strong>
                                ,
							</strong>
                            ) and the assignment operators (
							<strong>
                                =
							</strong>
                            , 
							<strong>
                                +=
							</strong>
                            , 
							<strong>
                                ‚Ä¶‚Äã
							</strong>
                            ) are not included in the operators that can create a constant expression. Also, an array access with a specialization constant as an index does not result in a constant expression.
						</p>
					</li>
					<li>
						<p>
                            Valid use of the 
							<strong>
                                length
							</strong>
                            () method on an explicitly sized object, whether or not the object itself is constant (implicitly sized or run-time sized arrays do not return a constant expression).
						</p>
					</li>
					<li>
						<p>
                            A constructor whose arguments are all constant expressions.
						</p>
					</li>
					<li>
						<p>
                            For non-specialization constants only: The value returned by certain built-in function calls whose arguments are all constant expressions, including at least the list below. Any other built-in function that does not access memory (not the texture lookup functions, image access, atomic counter, etc.), that has a non-
							<strong>
                                void
							</strong>
                            &nbsp;return type, that has no 
							<strong>
                                out
							</strong>
                            &nbsp;parameter, and is not a noise function might also be considered a constant. When a function is called with an argument that is a specialization constant, the result is not a constant expression.
						</p>
						<ul>
							<li>
								<p>
                                    Angle and Trigonometric Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                radians
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                degrees
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                sin
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                cos
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                asin
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                acos
											</strong>
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Exponential Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                pow
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                exp
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                log
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                exp2
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                log2
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                sqrt
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                inversesqrt
											</strong>
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Common Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                abs
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                sign
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                floor
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                trunc
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                round
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                ceil
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                mod
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                min
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                max
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                clamp
											</strong>
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Geometric Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                length
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                dot
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                normalize
											</strong>
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Function calls to user-defined functions (non-built-in functions) cannot be used to form constant expressions.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    A 
					<em>
                        constant integral expression
					</em>
                    &nbsp;is a constant expression that evaluates to a scalar signed or unsigned integer.
				</p>
			</li>
			<li>
				<p>
                    Constant expressions will be evaluated in an invariant way so as to create the same value in multiple shaders when the same constant expressions appear in those shaders.
				</p>
			</li>
			<li>
				<p>
                    Constant expressions respect the 
					<strong>
                        precise
					</strong>
                    &nbsp;and 
					<strong>
                        invariant
					</strong>
                    &nbsp;qualifiers but will be always be evaluated in an invariant way, independent of the use of such qualification, so as to create the same value in multiple shaders when the same constant expressions appear in those shaders.
				</p>
			</li>
			<li>
				<p>
                    Constant-expressions may be evaluated by a host platform, and are therefore not required to compute the same value that the same expression would evaluate to on the shader execution target. However, the host must use the same or greater precision than the target would use. When the precision qualification cannot be determined, the expression is evaluated at 
					<strong>
                        highp
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    Specialization-constant expressions are never evaluated by the compiler front end, but instead retain the expression‚Äôs operations needed to evaluate them later on the host.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="in" >
    in
</h5>
<ul>
	<li>
		<p>
            linkage into a shader from a previous stage, variable is copied in.
		</p>
	</li>
	<li>
		<p>
            Shader input variables are declared with the 
			<strong>
                in
			</strong>
            &nbsp;storage qualifier. They form the input interface between previous stages of the API pipeline and the declaring shader. Input variables must be declared at global scope. Values from the previous pipeline stage are copied into input variables at the beginning of shader execution. It is a compile-time error to write to a variable declared as an input.
		</p>
	</li>
	<li>
		<p>
            Only the input variables that are statically read need to be written by the previous stage; it is allowed to have superfluous declarations of input variables. This is shown in the following table.
		</p>
	</li>
</ul>
<p
	class="table" >
    |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    |-----------------------------------------|----------------------------|------------------------------------|--------------------------------------------|-----------------|
    <br>
    | Treatment of Mismatched Input Variables |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Consuming Shader (input variables) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | No Declaration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Declared but no Static Use | Declared and Static Use&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | Generating Shader (output variables)&nbsp;&nbsp;&nbsp;&nbsp;| No Declaration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Allowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Allowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Link-Time Error |
    <br>
    | Declared but no Static Use&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Allowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Allowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Allowed (values are undefined)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | Declared and Static Use&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Allowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Allowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Allowed (values are potentially undefined) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<ul>
	<li>
		<p>
            Consumption errors are based on static use only. Compilation may generate a warning, but not an error, for any dynamic use the compiler can deduce that might cause consumption of undefined values.
		</p>
	</li>
	<li>
		<p>
            See ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/builtins.html#built-in-variables" 
				class="external-link" 
				target="_blank" >
                Built-In Variables
			</a>
            ‚Äù for a list of the built-in input names.
		</p>
	</li>
	<li>
		<p>
            Vertex shader input variables (or attributes) receive per-vertex data. It is a compile-time error to use auxiliary storage or interpolation qualifiers on a vertex shader input. The values copied in are established by the API or through the use of the layout identifier 
			<strong>
                location
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a vertex shader input with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
			<li>
				<p>
                    A structure
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Example declarations in a vertex shader:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in vec4 position;
in vec3 normal;
in vec2 texCoord[4];
</code></pre>
<ul>
	<li>
		<p>
            It is expected that graphics hardware will have a small number of fixed vector locations for passing vertex inputs. Therefore, the OpenGL Shading Language defines each non-matrix input variable as taking up one such vector location. There is an implementation-dependent limit on the number of locations that can be used, and if this is exceeded it will cause a link-time error. (Declared input variables that are not statically used do not count against this limit.) A scalar input counts the same amount against this limit as a 
			<strong>
                vec4
			</strong>
            , so applications may want to consider packing groups of four unrelated float inputs together into a vector to better utilize the capabilities of the underlying hardware. A matrix input will use up multiple locations. The number of locations used will equal the number of columns in the matrix.
		</p>
	</li>
	<li>
		<p>
            Tessellation control, evaluation, and geometry shader input variables get the per-vertex values written out by output variables of the same names in the previous active shader stage. For these inputs, 
			<strong>
                centroid
			</strong>
            &nbsp;and interpolation qualifiers are allowed, but have no effect. Since tessellation control, tessellation evaluation, and geometry shaders operate on a set of vertices, each input variable (or input block, see 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            &nbsp;below) needs to be declared as an array. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in float foo[]; // geometry shader input for vertex "out float foo"
</code></pre>
<ul>
	<li>
		<p>
            Each element of such an array corresponds to one vertex of the primitive being processed. Each array can optionally have a size declared. For geometry shaders, the array size will be set by, (or if provided must be consistent with) the input 
			<strong>
                layout
			</strong>
            &nbsp;declaration(s) establishing the type of input primitive, as described later in ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#input-layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                Input Layout Qualifiers
			</a>
            ‚Äù.
		</p>
	</li>
	<li>
		<p>
            Some inputs and outputs are 
			<em>
                arrayed
			</em>
            , meaning that for an interface between two shader stages either the input or output declaration requires an extra level of array indexing for the declarations to match. For example, with the interface between a vertex shader and a geometry shader, vertex shader output variables and geometry shader input variables of the same name must have matching types, except that the geometry shader will have one more array dimension than the vertex shader, to allow for vertex indexing. If such an arrayed interface variable is not declared with the necessary additional input or output array dimension, a link-time error will result. Geometry shader inputs, tessellation control shader inputs and outputs, and tessellation evaluation inputs all have an additional level of arrayness relative to other shader inputs and outputs. These inputs and outputs are known as 
			<em>
                per-vertex-arrayed
			</em>
            &nbsp;inputs and outputs. Component limits for arrayed interfaces (e.g. 
			<em>
                gl_MaxTessControlInputComponents
			</em>
            ) are limits per vertex, not limits for the entire interface.
		</p>
	</li>
	<li>
		<p>
            For non-arrayed interfaces (meaning array dimensionally stays the same between stages), it is a link-time error if the input variable is not declared with the same type, including array dimensionality, as the matching output variable.
		</p>
	</li>
	<li>
		<p>
            The link-time type-matching rules apply to all declared input and output variables, whether or not they are used.
		</p>
	</li>
	<li>
		<p>
            Additionally, tessellation evaluation shaders support per-patch input variables declared with the 
			<strong>
                patch
			</strong>
            &nbsp;and 
			<strong>
                in
			</strong>
            &nbsp;qualifiers. Per-patch input variables are filled with the values of per-patch output variables written by the tessellation control shader. Per-patch inputs may be declared as one-dimensional arrays, but are not indexed by vertex number. Applying the 
			<strong>
                patch
			</strong>
            &nbsp;qualifier to inputs can only be done in tessellation evaluation shaders. As with other input variables, per-patch inputs must be declared using the same type and qualification as per-patch outputs from the previous (tessellation control) shader stage. It is a compile-time error to use 
			<strong>
                patch
			</strong>
            &nbsp;with inputs in any other stage.
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a tessellation control, tessellation evaluation or geometry shader input with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Fragment shader inputs get per-fragment values, typically interpolated from a previous stage‚Äôs outputs. The auxiliary storage qualifiers 
			<strong>
                centroid
			</strong>
            &nbsp;and 
			<strong>
                sample
			</strong>
            &nbsp;can also be applied, as well as the interpolation qualifiers 
			<strong>
                flat
			</strong>
            , 
			<strong>
                noperspective
			</strong>
            , and 
			<strong>
                smooth.
			</strong>
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a fragment shader input with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Fragment shader inputs that are, or contain, integral or double-precision floating-point types must be qualified with the interpolation qualifier 
			<strong>
                flat
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            Fragment inputs are declared as in the following examples:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in vec3 normal;
centroid in vec2 TexCoord;
noperspective in float temperature;
flat in vec3 myColor;
noperspective centroid in vec2 myTexCoord;
</code></pre>
<ul>
	<li>
		<p>
            The fragment shader inputs form an interface with the last active shader in the vertex processing pipeline. For this interface, the last active shader stage output variables and fragment shader input variables of the same name must match in type and qualification, with a few exceptions: The storage qualifiers must, of course, differ (one is 
			<strong>
                in
			</strong>
            &nbsp;and one is 
			<strong>
                out
			</strong>
            ). Also, interpolation qualification (e.g. 
			<strong>
                flat
			</strong>
            ) and auxiliary qualification (e.g. 
			<strong>
                centroid
			</strong>
            ) may differ. These mismatches are allowed between any pair of stages. When interpolation or auxiliary qualifiers do not match, those provided in the fragment shader supersede those provided in previous stages. If any such qualifiers are completely missing in the fragment shaders, then the default is used, rather than any qualifiers that may have been declared in previous stages. That is, what matters is what is declared in the fragment shaders, not what is declared in shaders in previous stages.
		</p>
	</li>
	<li>
		<p>
            When an interface between shader stages is formed using shaders from two separate program objects, it is not possible to detect mismatches between inputs and outputs when the programs are linked. When there are mismatches between inputs and outputs on such interfaces, the values passed across the interface will be partially or completely undefined.
		</p>
	</li>
	<li>
		<p>
            Shaders can ensure matches across such interfaces either by using input and output layout qualifiers (sections ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#input-layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                Input Layout Qualifiers
			</a>
            ‚Äù and ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#output-layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                Output Layout Qualifiers
			</a>
            ‚Äù) or by using identical input and output declarations of blocks or variables. Complete rules for interface matching are found in section 7.4.1 ‚ÄúShader Interface Matching‚Äù of the 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/references.html#references" 
				class="external-link" 
				target="_blank" >
                OpenGL Specification
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Compute shaders do not permit user-defined input variables and do not form a formal interface with any other shader stage. See ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/builtins.html#compute-shader-special-variables" 
				class="external-link" 
				target="_blank" >
                Compute Shader Special Variables
			</a>
            ‚Äù for a description of built-in compute shader input variables. All other input to a compute shader is retrieved explicitly through image loads, texture fetches, loads from uniforms or uniform buffers, or other user supplied code. Redeclaration of built-in input variables in compute shaders is not permitted.
		</p>
	</li>
</ul>
<h5
	id="out" >
    out
</h5>
<ul>
	<li>
		<p>
            linkage out of a shader to a subsequent stage, variable is copied out.
		</p>
	</li>
	<li>
		<p>
            Shader output variables are declared with the 
			<strong>
                out
			</strong>
            &nbsp;storage qualifier. They form the output interface between the declaring shader and the subsequent stages of the API pipeline. Output variables must be declared at global scope. During shader execution they will behave as normal unqualified global variables. Their values are copied out to the subsequent pipeline stage on shader exit. Only output variables that are read by the subsequent pipeline stage need to be written; it is allowed to have superfluous declarations of output variables.
		</p>
	</li>
	<li>
		<p>
            There is 
			<em>
                not
			</em>
            &nbsp;an 
			<strong>
                inout
			</strong>
            &nbsp;storage qualifier for declaring a single variable name as both input and output to a shader. Also, a variable cannot be declared with both the 
			<strong>
                in
			</strong>
            &nbsp;and the 
			<strong>
                out
			</strong>
            &nbsp;qualifiers, this will result in a compile-time or link-time error. Output variables must be declared with different names than input variables. However, nesting an input or output inside an interface block with an instance name allows the same names with one referenced through a block instance name.
		</p>
	</li>
	<li>
		<p>
            Vertex, tessellation evaluation, and geometry output variables output per-vertex data and are declared using the 
			<strong>
                out
			</strong>
            &nbsp;storage qualifier. Applying 
			<strong>
                patch
			</strong>
            &nbsp;to an output can only be done in a tessellation control shader. It is a compile-time error to use 
			<strong>
                patch
			</strong>
            &nbsp;on outputs in any other stage.
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a vertex, tessellation evaluation, tessellation control, or geometry shader output with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Individual outputs are declared as in the following examples:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out vec3 normal;
centroid out vec2 TexCoord;
invariant centroid out vec4 Color;
flat out vec3 myColor;
sample out vec4 perSampleColor;
</code></pre>
<ul>
	<li>
		<p>
            These can also appear in interface blocks, as described in ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            ‚Äù. Interface blocks allow simpler addition of arrays to the interface from vertex to geometry shader. They also allow a fragment shader to have the same input interface as a geometry shader for a given vertex shader.
		</p>
	</li>
	<li>
		<p>
            Tessellation control shader output variables are used to output per-vertex and per-patch data. Per-vertex output variables are arrayed (see 
			<em>
                arrayed
			</em>
            &nbsp;under ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#input-variables" 
				class="external-link" 
				target="_blank" >
                Input Variables
			</a>
            ‚Äù) and declared using the 
			<strong>
                out
			</strong>
            &nbsp;qualifier without the 
			<strong>
                patch
			</strong>
            &nbsp;qualifier. Per-patch output variables are declared using the 
			<strong>
                patch
			</strong>
            &nbsp;and 
			<strong>
                out
			</strong>
            &nbsp;qualifiers.
		</p>
	</li>
	<li>
		<p>
            Since tessellation control shaders produce an arrayed primitive comprising multiple vertices, each per-vertex output variable (or output block, see 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            &nbsp;below) needs to be declared as an array. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out float foo[]; // feeds next stage input "in float foo[]"
</code></pre>
<ul>
	<li>
		<p>
            Each element of such an array corresponds to one vertex of the primitive being produced. Each array can optionally have a size declared. The array size will be set by (or if provided must be consistent with) the output layout declaration(s) establishing the number of vertices in the output patch, as described later in ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#tessellation-control-outputs" 
				class="external-link" 
				target="_blank" >
                Tessellation Control Outputs
			</a>
            ‚Äù.
		</p>
	</li>
	<li>
		<p>
            Each tessellation control shader invocation has a corresponding output patch vertex, and may assign values to per-vertex outputs only if they belong to that corresponding vertex. If a per-vertex output variable is used as an l-value, it is a compile-time or link-time error if the expression indicating the vertex index is not the identifier 
			<em>
                gl_InvocationID
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            The order of execution of a tessellation control shader invocation relative to the other invocations for the same input patch is undefined unless the built-in function 
			<strong>
                barrier
			</strong>
            () is used. This provides some control over relative execution order. When a shader invocation calls 
			<strong>
                barrier
			</strong>
            (), its execution pauses until all other invocations have reached the same point of execution. Output variable assignments performed by any invocation executed prior to calling 
			<strong>
                barrier
			</strong>
            () will be visible to any other invocation after the call to 
			<strong>
                barrier
			</strong>
            () returns.
		</p>
	</li>
	<li>
		<p>
            Because tessellation control shader invocations execute in undefined order between barriers, the values of per-vertex or per-patch output variables will sometimes be undefined. Consider the beginning and end of shader execution and each call to 
			<strong>
                barrier
			</strong>
            () as synchronization points. The value of an output variable will be undefined in any of the three following cases:
		</p>
		<ol>
			<li>
				<p>
                    At the beginning of execution.
				</p>
			</li>
			<li>
				<p>
                    At each synchronization point, unless
				</p>
				<ul>
					<li>
						<p>
                            the value was well-defined after the previous synchronization point and was not written by any invocation since, or
						</p>
					</li>
					<li>
						<p>
                            the value was written by exactly one shader invocation since the previous synchronization point, or
						</p>
					</li>
					<li>
						<p>
                            the value was written by multiple shader invocations since the previous synchronization point, and the last write performed by all such invocations wrote the same value.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    When read by a shader invocation, if
				</p>
				<ul>
					<li>
						<p>
                            the value was undefined at the previous synchronization point and has not been written by the same shader invocation since, or
						</p>
					</li>
					<li>
						<p>
                            the output variable is written to by any other shader invocation between the previous and next synchronization points, even if that assignment occurs in code following the read.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
            Fragment outputs output per-fragment data and are declared using the 
			<strong>
                out
			</strong>
            &nbsp;storage qualifier. It is a compile-time error to use auxiliary storage qualifiers or interpolation qualifiers in a fragment shader output declaration. It is a compile-time error to declare a fragment shader output with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    A double-precision scalar or vector (
					<strong>
                        double
					</strong>
                    , 
					<strong>
                        dvec2
					</strong>
                    , 
					<strong>
                        dvec3
					</strong>
                    , 
					<strong>
                        dvec4
					</strong>
                    )
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
			<li>
				<p>
                    A matrix type
				</p>
			</li>
			<li>
				<p>
                    A structure
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Fragment outputs are declared as in the following examples:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out vec4 FragmentColor;
out uint Luminosity;
</code></pre>
<ul>
	<li>
		<p>
            Compute shaders have no built-in output variables, do not support user-defined output variables and do not form a formal interface with any other shader stage. All outputs from a compute shader take the form of the side effects such as image stores and operations on atomic counters.
		</p>
	</li>
</ul>
<h5
	id="attribute" >
    attribute
</h5>
<ul>
	<li>
		<p>
            compatibility profile only and vertex language only; same as in when in a vertex shader
		</p>
	</li>
</ul>
<h5
	id="uniform" >
    uniform
</h5>
<ul>
	<li>
		<p>
            value does not change across the primitive being processed, uniforms form the linkage between a shader, API, and the application.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                uniform
			</strong>
            &nbsp;qualifier is used to declare global variables whose values are the same across the entire primitive being processed. All 
			<strong>
                uniform
			</strong>
            &nbsp;variables are read-only and are initialized externally either at link time or through the API. The link-time initial value is either the value of the variable‚Äôs initializer, if present, or 0 if no initializer is present. Opaque types cannot have initializers, or a compile-time error results. When targeting Vulkan, it is a compile-time error to declare 
			<strong>
                uniform
			</strong>
            &nbsp;variables outside a block.
		</p>
	</li>
	<li>
		<p>
            Example declarations are:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">uniform vec4 lightPosition;
uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time
</code></pre>
<ul>
	<li>
		<p>
            The 
			<strong>
                uniform
			</strong>
            &nbsp;qualifier can be used with any of the basic data types, or when declaring a variable whose type is a structure, or an array of any of these.
		</p>
	</li>
	<li>
		<p>
            There is an implementation-dependent limit on the amount of storage for uniforms that can be used for each type of shader and if this is exceeded it will cause a compile-time or link-time error. Uniform variables that are declared but not used do not count against this limit. The number of user-defined uniform variables and the number of built-in uniform variables that are used within a shader are added together to determine whether available uniform storage has been exceeded.
		</p>
	</li>
	<li>
		<p>
            Uniforms in shaders all share a single global name space when linked into a program or separable program. Hence, the types, initializers, and any location specifiers of all statically used uniform variables with the same name must match across all shaders that are linked into a single program. However it is not required to repeat the initializer or location specifier in all the linked shaders. While this single uniform name space is cross stage, a uniform variable name‚Äôs scope is per stage: If a uniform variable name is declared in one stage (e.g. a vertex shader) but not in another (e.g. a fragment shader), then that name is still available in the other stage for a different use.
		</p>
	</li>
</ul>
<h5
	id="varying" >
    varying
</h5>
<ul>
	<li>
		<p>
            compatibility profile only and vertex and fragment languages only; same as out when in a vertex shader and same as in when in a fragment shader
		</p>
	</li>
</ul>
<h5
	id="buffer" >
    buffer
</h5>
<ul>
	<li>
		<p>
            value is stored in a buffer object, and can be read or written both by shader invocations and the API.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                buffer
			</strong>
            &nbsp;qualifier is used to declare global variables whose values are stored in the data store of a buffer object bound through the API. Buffer variables can be read and written, with the underlying storage shared among all active shader invocations. Buffer variable memory reads and writes within a single shader invocation are processed in order. However, the order of reads and writes performed in one invocation relative to those performed by another invocation is largely undefined. Buffer variables may be qualified with memory qualifiers affecting how the underlying memory is accessed, as described in ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#memory-qualifiers" 
				class="external-link" 
				target="_blank" >
                Memory Qualifiers
			</a>
            ‚Äù.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                buffer
			</strong>
            &nbsp;qualifier can be used to declare interface blocks (see ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            ‚Äù), which are then referred to as shader storage blocks. It is a compile-time error to declare buffer variables outside a block.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// use buffer to create a buffer block (shader storage block)
buffer BufferName { // externally visible name of buffer
&nbsp;&nbsp;&nbsp;&nbsp;int count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// typed, shared memory...
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp;&nbsp;&nbsp;vec4 v[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // last member may be an array that is not sized
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// until after link time (dynamically sized)
} Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // name of block within the shader
</code></pre>
<ul>
	<li>
		<p>
            There are implementation-dependent limits on the number of shader storage blocks used for each type of shader, the combined number of shader storage blocks used for a program, and the amount of storage required by each individual shader storage block. If any of these limits are exceeded, it will cause a compile-time or link-time error.
		</p>
	</li>
	<li>
		<p>
            If multiple shaders are linked together, then they will share a single global buffer variable name space. Hence, the types of all declared buffer variables with the same name must match across all shaders that are linked into a single program.
		</p>
	</li>
</ul>
<h5
	id="shared" >
    shared
</h5>
<ul>
	<li>
		<p>
            compute shader only; variable storage is shared across all work items in a workgroup.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                shared
			</strong>
            &nbsp;qualifier is used to declare global variables that have storage shared between all work items in a compute shader workgroup. Variables declared as 
			<strong>
                shared
			</strong>
            &nbsp;may only be used in compute shaders (see ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/overview.html#compute-processor" 
				class="external-link" 
				target="_blank" >
                Compute Processor
			</a>
            ‚Äù). Any other declaration of a 
			<strong>
                shared
			</strong>
            &nbsp;variable is a compile-time error. Shared variables are implicitly coherent (see ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#memory-qualifiers" 
				class="external-link" 
				target="_blank" >
                Memory Qualifiers
			</a>
            ‚Äù).
		</p>
	</li>
	<li>
		<p>
            Variables declared as 
			<strong>
                shared
			</strong>
            &nbsp;may not have initializers and their contents are undefined at the beginning of shader execution. Any data written to 
			<strong>
                shared
			</strong>
            &nbsp;variables will be visible to other work items (executing the same shader) within the same workgroup.
		</p>
	</li>
	<li>
		<p>
            In the absence of synchronization, the order of reads and writes to the same 
			<strong>
                shared
			</strong>
            &nbsp;variable by different invocations of a shader is not defined.
		</p>
	</li>
	<li>
		<p>
            In order to achieve ordering with respect to reads and writes to 
			<strong>
                shared
			</strong>
            &nbsp;variables, control flow barriers must be employed using the 
			<strong>
                barrier
			</strong>
            () function (see ‚Äú
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/builtinfunctions.html#shader-invocation-control-functions" 
				class="external-link" 
				target="_blank" >
                Shader Invocation Control Functions
			</a>
            ‚Äù).
		</p>
	</li>
	<li>
		<p>
            There is a limit to the total size of all variables declared as 
			<strong>
                shared
			</strong>
            &nbsp;in a single program. This limit, expressed in units of basic machine units may be determined by using the OpenGL API to query the value of MAX_COMPUTE_SHARED_MEMORY_SIZE.
		</p>
	</li>
</ul>
<h3
	id="auxiliars" >
    Auxiliars
</h3>
<ul>
	<li>
		<p>
            Some input and output qualified variables can be qualified with at most one additional auxiliary storage qualifier
		</p>
	</li>
	<li>
		<p>
            Auxiliary storage qualifiers can only be used with the 
			<strong>
                in
			</strong>
            &nbsp;or 
			<strong>
                out
			</strong>
            &nbsp;storage qualifiers.
		</p>
	</li>
</ul>
<h5
	id="centroid" >
    centroid
</h5>
<ul>
	<li>
		<p>
            centroid-based interpolation
		</p>
	</li>
</ul>
<h5
	id="sample" >
    sample
</h5>
<ul>
	<li>
		<p>
            per-sample interpolation
		</p>
	</li>
</ul>
<h5
	id="patch" >
    patch
</h5>
<ul>
	<li>
		<p>
            per-tessellation-patch attributes
		</p>
	</li>
</ul>
<h3
	id="interface-blocks" >
    Interface Blocks
</h3>
<ul>
	<li>
		<p>
            To implement our constant data we have to use an interface block. Interface blocks in shader code are used to group multiple global variables of the same 
            <code>&lt;storage&gt;</code>
            &nbsp;type.
		</p>
	</li>
	<li>
		<p>
            In theory they aren‚Äôt necessarily solely for constant data.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform PerMeshData {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 camera_position;
&nbsp;&nbsp;&nbsp;&nbsp;mat4 model_matrix;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 mesh_color;
} per_mesh_data;
</code></pre>
<ul>
	<li>
		<p>
            Interface blocks are still global variables, and technically still follow the global variable format. However, the difference is that they have to be given a user-defined type.
		</p>
	</li>
	<li>
		<p>
            They work exactly the same way as a 
            <code>struct</code>
            &nbsp;in GLSL/C++. For example, to access the model matrix in this interface block, you‚Äôd use 
            <code>per_mesh_data.model_matrix</code>
            .
		</p>
	</li>
	<li>
		<p>
            Input, output, uniform, and buffer variable declarations can be grouped into named interface blocks to provide coarser granularity backing than is achievable with individual declarations. They can have an optional instance name, used in the shader to reference their members. An output block of one programmable stage is backed by a corresponding input block in the subsequent programmable stage. A 
			<em>
                uniform block
			</em>
            &nbsp;is backed by the application with a buffer object. A 
			<em>
                buffer block
			</em>
            , also known as a 
			<em>
                shader storage block
			</em>
            , is also backed by the application with a buffer object. It is a compile-time error to have an input block in a vertex shader or an output block in a fragment shader. These uses are reserved for future use.
		</p>
	</li>
	<li>
		<p>
            An interface block declaration is defined in the grammar as follows:
		</p>
		<ul>
			<li>
				<p>
					<em>
                        interface-block
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        type_qualifier
					</em>
                    &nbsp;
					<em>
                        block-name
					</em>
                    &nbsp;
					<strong>
                        {
					</strong>
                    &nbsp;
					<em>
                        member-list
					</em>
                    &nbsp;
					<strong>
                        }
					</strong>
                    &nbsp;
					<em>
                        instance-nameopt
					</em>
                    &nbsp;
					<strong>
                        ;
					</strong>
				</p>
			</li>
			<li>
				<p>
					<em>
                        block-name
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        identifier
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-list
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-declaration
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-declaration
					</em>
                    &nbsp;
					<em>
                        member-list
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-declaration
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        layout-qualifieropt
					</em>
                    &nbsp;
					<em>
                        qualifiersopt
					</em>
                    &nbsp;
					<em>
                        type
					</em>
                    &nbsp;
					<em>
                        declarators
					</em>
                    &nbsp;
					<strong>
                        ;
					</strong>
				</p>
			</li>
			<li>
				<p>
					<em>
                        instance-name
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        identifier
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        identifier
					</em>
                    &nbsp;
					<em>
                        array-specifier
					</em>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Each of the above elements is discussed below.
		</p>
	</li>
	<li>
		<p>
            First, an example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">uniform Transform {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewProjectionMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;uniform mat3 NormalMatrix;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// allowed restatement of qualifier
&nbsp;&nbsp;&nbsp;&nbsp;float Deformation;
};
</code></pre>
<ul>
	<li>
		<p>
            The above establishes a uniform block named ‚ÄúTransform‚Äù with four uniforms grouped inside it.
		</p>
	</li>
	<li>
		<p>
			<em>
                type-qualifier
			</em>
            &nbsp;determines the interface of which the block will be a part and, optionally, additional qualifiers that are applied to the block. It is a compile-time error if it does not include one of the storage qualifiers 
			<strong>
                in
			</strong>
            , 
			<strong>
                out
			</strong>
            , 
			<strong>
                uniform
			</strong>
            &nbsp;or 
			<strong>
                buffer
			</strong>
            . It may optionally include 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                layout qualifiers
			</a>
            , the 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#storage-qualifiers" 
				class="external-link" 
				target="_blank" >
                auxiliary storage qualifier
			</a>
            &nbsp;
			<strong>
                patch
			</strong>
            , and the 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#the-precise-qualifier" 
				class="external-link" 
				target="_blank" >
                precise qualifier
			</a>
            . 
			<strong>
                buffer
			</strong>
            &nbsp;blocks may additionally include 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#memory-qualifiers" 
				class="external-link" 
				target="_blank" >
                Memory Qualifiers
			</a>
            . It is a compile-time error to include any other qualifiers.
		</p>
	</li>
	<li>
		<p>
			<em>
                member-list
			</em>
            &nbsp;declares the variables that are to be grouped into the block. Types and declarators are the same as for other input, output, uniform, and buffer variable declarations outside blocks, with these exceptions:
		</p>
	</li>
	<li>
		<p>
            Initializers are not allowed
		</p>
	</li>
	<li>
		<p>
            Opaque types are not allowed
		</p>
	</li>
	<li>
		<p>
            Structure definitions cannot be nested inside a block
		</p>
	</li>
	<li>
		<p>
            Any of these would result in a compile-time error.
		</p>
	</li>
	<li>
		<p>
            If no optional qualifier is used in a member-declaration, the qualification of the member includes all 
			<strong>
                in
			</strong>
            , 
			<strong>
                out
			</strong>
            , 
			<strong>
                patch
			</strong>
            , 
			<strong>
                uniform
			</strong>
            , or 
			<strong>
                buffer
			</strong>
            &nbsp;as determined by 
			<em>
                interface-qualifier
			</em>
            . If optional qualifiers are used, they can include interpolation qualifiers, auxiliary storage qualifiers, precision qualifiers, and storage qualifiers and they must declare an input, output, or uniform member consistent with the interface qualifier of the block: Input variables, output variables, uniform variables, and 
			<strong>
                buffer
			</strong>
            &nbsp;members can only be in 
			<strong>
                in
			</strong>
            &nbsp;blocks, 
			<strong>
                out
			</strong>
            &nbsp;blocks, 
			<strong>
                uniform
			</strong>
            &nbsp;blocks, and shader storage blocks, respectively.
		</p>
	</li>
	<li>
		<p>
            Repeating the 
			<strong>
                in
			</strong>
            , 
			<strong>
                out
			</strong>
            , 
			<strong>
                patch
			</strong>
            , 
			<strong>
                uniform
			</strong>
            , or 
			<strong>
                buffer
			</strong>
            &nbsp;interface qualifier for a member‚Äôs storage qualifier is optional. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in Material {
&nbsp;&nbsp;&nbsp;&nbsp;smooth in vec4 Color1; // legal, input inside in block
&nbsp;&nbsp;&nbsp;&nbsp;smooth vec4 Color2;&nbsp;&nbsp;&nbsp;&nbsp;// legal, 'in' inherited from 'in Material'
&nbsp;&nbsp;&nbsp;&nbsp;vec2 TexCoord;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // legal, TexCoord is an input
&nbsp;&nbsp;&nbsp;&nbsp;uniform float Atten;&nbsp;&nbsp; // illegal, mismatched storage qualifier
};
</code></pre>
<ul>
	<li>
		<p>
            Members of 
			<strong>
                uniform
			</strong>
            &nbsp;or 
			<strong>
                buffer
			</strong>
            &nbsp;storage blocks are always represented in memory as 
			<strong>
                highp
			</strong>
            , regardless of any precision qualifier associated with the declaration. When values are read from or written to such variables they are converted to or from the declared precision as described in 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#conversion-between-precisions" 
				class="external-link" 
				target="_blank" >
                Conversion Between Precisions
			</a>
            . Operations on the values within the shader will take place using the declared precision as normal.
		</p>
	</li>
	<li>
		<p>
            A 
			<em>
                shader interface
			</em>
            &nbsp;is defined to be one of these:
		</p>
	</li>
	<li>
		<p>
            All the uniform variables and uniform blocks declared in a program. This spans all compilation units linked together within one program.
		</p>
	</li>
	<li>
		<p>
            All the 
			<strong>
                buffer
			</strong>
            &nbsp;blocks declared in a program.
		</p>
	</li>
	<li>
		<p>
            The boundary between adjacent programmable pipeline stages: This spans all the outputs declared in all compilation units of the first stage and all the inputs declared in all compilation units of the second stage. Note that for the purposes of this definition, the fragment shader and the preceding shader are considered to have a shared boundary even though in practice, all values passed to the fragment shader first pass through the rasterizer and interpolator.
		</p>
	</li>
	<li>
		<p>
            The block name (
			<em>
                block-name
			</em>
            ) is used to match within shader interfaces: an output block of one pipeline stage will be matched to an input block with the same name in the subsequent pipeline stage. For uniform or shader storage blocks, the application uses the block name to identify the block. Block names have no other use within a shader beyond interface matching; it is a compile-time error to use a block name at global scope for anything other than as a block name (e.g. use of a block name for a global variable name or function name is currently reserved). It is a compile-time error to use the same block name for more than one block declaration in the same shader interface (as defined above) within one shader, even if the block contents are identical.
		</p>
	</li>
	<li>
		<p>
            Matched block names within a shader interface (as defined above) must match in terms of having the same number of declarations with the same sequence of types and the same sequence of member names, as well as having matching member-wise layout qualification (see next section). Matched uniform or shader storage block names (but not input or output block names) must also either all be lacking an instance name or all having an instance name, putting their members at the same scoping level. When instance names are present on matched block names, it is allowed for the instance names to differ; they need not match for the blocks to match. Furthermore, if a matching block is declared as an array, then the array sizes must also match (or follow array matching rules for the shader interface between consecutive shader stages). Any mismatch will generate a link-time error. A block name is allowed to have different definitions in different shader interfaces within the same shader, allowing, for example, an input block and output block to have the same name.
		</p>
	</li>
	<li>
		<p>
            If an instance name (
			<em>
                instance-name
			</em>
            ) is not used, the names declared inside the block are scoped at the global level and accessed as if they were declared outside the block. If an instance name (
			<em>
                instance-name
			</em>
            ) is used, then it puts all the members inside a scope within its own name space, accessed with the field selector (
			<strong>
                .
			</strong>
            ) operator (analogously to structures). For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in Light {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 LightPos;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 LightColor;
};
in ColoredTexture {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Color;
&nbsp;&nbsp;&nbsp;&nbsp;vec2 TexCoord;
} Material;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // instance name
vec3 Color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // different Color than Material.Color
vec4 LightPos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// illegal, already defined
...
... = LightPos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accessing LightPos
... = Material.Color; // accessing Color in ColoredTexture block
</code></pre>
<ul>
	<li>
		<p>
            Outside the shading language (i.e., in the API), members are similarly identified except the block name is always used in place of the instance name (API accesses are to shader interfaces, not to shaders). If there is no instance name, then the API does not use the block name to access a member, just the member name.
		</p>
	</li>
	<li>
		<p>
            Within a shader interface, all declarations of the same global name must be for the same object and must match in type and in whether they declare a variable or member of a block with no instance name. The API also needs this name to uniquely identify an object in the shader interface. It is a link-time error if any particular shader interface contains
		</p>
	</li>
	<li>
		<p>
            two different blocks, each having no instance name, and each having a member of the same name, or
		</p>
	</li>
	<li>
		<p>
            a variable outside a block, and a block with no instance name, where the variable has the same name as a member in the block.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out Vertex {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Position;&nbsp;&nbsp;// API transform/feedback will use "Vertex.Position"
&nbsp;&nbsp;&nbsp;&nbsp;vec2 Texture;
} Coords;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shader will use "Coords.Position"
out Vertex2 {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Color;&nbsp;&nbsp;&nbsp;&nbsp; // API will use "Color"
&nbsp;&nbsp;&nbsp;&nbsp;float Color2;
};
// in same program as Vertex2 above:
out Vertex3 {
&nbsp;&nbsp;&nbsp;&nbsp;float Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Color;&nbsp;&nbsp;&nbsp;&nbsp; // ERROR, name collision with Color in Vertex2
};
float Color2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ERROR, collides with Color2 in Vertex2
</code></pre>
<ul>
	<li>
		<p>
            For blocks declared as arrays, the array index must also be included when accessing members, as in this example
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">uniform Transform { // API uses "Transform[2]" to refer to instance 2
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewProjectionMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 a[]; // array will get implicitly sized
&nbsp;&nbsp;&nbsp;&nbsp;float Deformation;
} transforms[4];
...
... = transforms[2].ModelViewMatrix; // shader access of instance 2
// API uses "Transform.ModelViewMatrix" to query an offset or other query
transforms[x].a.length(); // same length for 'a' for all x
Transform[x];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // illegal, must use 'transforms'
Transform.a.length();&nbsp;&nbsp;&nbsp;&nbsp; // illegal, must use 'transforms'
...transforms[2].a[3]...&nbsp;&nbsp;// if these are the only two dereferences of 'a',
...transforms[3].a[7]...&nbsp;&nbsp;// then 'a' must be size 8, for all
transforms[x]
</code></pre>
<ul>
	<li>
		<p>
            For uniform or shader storage blocks declared as an array, each individual array element corresponds to a separate buffer object bind range, backing one instance of the block. As the array size indicates the number of buffer objects needed, uniform and shader storage block array declarations must specify an array size. A uniform or shader storage block array can only be indexed with a dynamically uniform integral expression, otherwise results are undefined.
		</p>
	</li>
	<li>
		<p>
            When using OpenGL API entry points to identify the name of an individual block in an array of blocks, the name string may include an array index (e.g. 
			<em>
                Transform[2]
			</em>
            ). When using OpenGL API entry points to refer to offsets or other characteristics of a block member, an array index must not be specified (e.g. 
			<em>
                Transform.ModelViewMatrix
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
            Tessellation control, tessellation evaluation and geometry shader input blocks must be declared as arrays and follow the array declaration and linking rules for all shader inputs for the respective stages. All other input and output block arrays must specify an array size.
		</p>
	</li>
	<li>
		<p>
            There are implementation-dependent limits on the number of uniform blocks and the number of shader storage blocks that can be used per stage. If either limit is exceeded, it will cause a link-time error.
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-10-21 .&nbsp;&nbsp;2026-01-25 üöÄ
			</footer>
		</div>
		<script
			src="/static/studies.61297.js" >
		</script>
	</body>
</html>
