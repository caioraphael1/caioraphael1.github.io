<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.62241.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
								<ul>
									<li>
										<a
											href="#sources" >
                                            Sources
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#samples" >
                                            Samples
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#bsdf-bidirectional-scattering-distribution-function" >
                                            BSDF (Bidirectional Scattering Distribution Function)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#brdf-bidirectional-reflectance-distribution-function" >
                                            BRDF (Bidirectional Reflectance Distribution Function)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#general-terms" >
                                            General Terms
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#tldr" >
                                            TLDR
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#specular-brdf" >
                                            Specular BRDF
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#diffuse-brdf" >
                                            Diffuse BRDF
										</a>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
				<footer
					id="left-sidebar-footer" >
				</footer>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="central" >
				<main
					id="note-wrapper" >
					<header
						id="note-header" >
						<h1>
                            BSDF (Bidirectional Scattering Distribution Function)
						</h1>
						<p>
							<time
								datetime="2025-07-03" >
                                ðŸ•’ Created: 2025-07-03
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<article
						id="note-content" >
<h3
	id="sources" >
    Sources
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html" 
				class="internal-link" 
				target="_self" >
                PBR in Filament
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Filament pbr paper is nice and readable and even has some pseudo code examples. the renderer is open source (which is also a good reference)&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;it just cuts right through the BS and just gives you the math you need&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=j-A0mwsJRmk" 
				class="external-link" 
				target="_blank" >
                Physics and Math of Shading - Siggraph
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://haqr.eu/tinyrenderer/" 
				class="external-link" 
				target="_blank" >
                Tiny Renderer Course
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf" 
				class="external-link" 
				target="_blank" >
                Moving Frostbite to Physically Based Rendering 3.0 - Siggraph 2014
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.pbr-book.org/4ed/contents" 
				class="external-link" 
				target="_blank" >
                PBR Book
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Award academy winning book.
				</p>
			</li>
			<li>
				<p>
                    Basically created the meaning of PBR.
				</p>
				<ul>
					<li>
						<p>
                            &quot;I'm finding myself pretty annoyed at how OOP-y it is so far (I think I'm at 4 levels of inheritancs now for the integrators?)&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2025-09-10)
				</p>
				<ul>
					<li>
						<p>
                            The reading sounds sloooow and seems to have the CMake mentality.
						</p>
					</li>
					<li>
						<p>
                            Nah fok off.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://learnopengl.com/PBR/Theory" 
				class="external-link" 
				target="_blank" >
                LearnOpenGL PBR
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    It's a super short and not enlightening explanation. The Filament PBR is better.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="samples" >
    Samples
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/SaschaWillems/Vulkan-glTF-PBR" 
				class="external-link" 
				target="_blank" >
                SaschaWillems/Vulkan-glTF-PBR
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/wdas/brdf/tree/main/src/brdfs" 
				class="external-link" 
				target="_blank" >
                BRDF Samples
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://godotshaders.com/shader/complete-cel-shader-for-godot-4/" 
				class="external-link" 
				target="_blank" >
                Cel Shading
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;wrap lighting&quot; â†’ 
                    <code>max((dot(N,L) + wrap) / (1+wrap), 0)</code>
                    &nbsp;creates softer shading.
				</p>
			</li>
			<li>
				<p>
                    Can quantize light intensity into bands for toon-like shading.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="bsdf-bidirectional-scattering-distribution-function" >
    BSDF (Bidirectional Scattering Distribution Function)
</h3>
<ul>
	<li>
		<p>
            A material model is described mathematically by a 
			<strong>
                BSDF
			</strong>
            &nbsp;(Bidirectional Scattering Distribution Function), which is itself composed of two other functions:
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        BRDF
					</strong>
                    &nbsp;(Bidirectional Reflectance Distribution Function)
				</p>
			</li>
			<li>
				<p>
					<strong>
                        BTDF
					</strong>
                    &nbsp;(Bidirectional Transmittance Function).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Since we aim to model commonly encountered surfaces, our standard material model will focus on the BRDF and ignore the BTDF, or approximate it greatly.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/Rendering_equation" 
				class="external-link" 
				target="_blank" >
                Rendering Equation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=RRE-F57fbXw" 
				class="external-link" 
				target="_blank" >
                Rendering Equation
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    {9:57}
				</p>
				<ul>
					<li>
						<p>
                            Implementation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=XK_p2MxGBQs" 
				class="external-link" 
				target="_blank" >
                Implementing the Rendering Equation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=KkOkx0FiHDA" 
				class="external-link" 
				target="_blank" >
                Rendering Equation and BRDFs
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Great video, super important to understand rendering and Physics Based Rendering (PBR).
				</p>
			</li>
			<li>
				<p>
                    Everything is based on the abstract equation, as being the basis for Based Physics Rendering:
				</p>
				<ul>
					<li>
						<p>
                            <code>outgoing_light = emitted_light + reflected_light</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {10:19}
				</p>
				<ul>
					<li>
						<p>
                            The 'reflected_light' equation is shown
						</p>
					</li>
					<li>
						<p>
                            $f_r(x, \omega_i, \omega_o)$ is the 'Bidirectional Reflectance Distribution Function (BRDF)'
						</p>
					</li>
					<li>
						<p>
                            $L_i$ is the 'color of light'.
						</p>
					</li>
					<li>
						<p>
                            $cos(\theta_i)$ is the representation of the 'Surface Normal'
						</p>
					</li>
					<li>
						<p>
                            ~Then an integral is used to calculate this at different angles, ~I don't know.
						</p>
						<ul>
							<li>
								<p>
                                    Engines don't use the integral.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {10:53}
				</p>
				<ul>
					<li>
						<p>
                            Rendering Equation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {22:58 -&gt; end}
				</p>
				<ul>
					<li>
						<p>
                            It's the most interesting part of the video, although everything is interesting.
						</p>
					</li>
					<li>
						<p>
                            Each parameter of the shader used by Disney is explained.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="brdf-bidirectional-reflectance-distribution-function" >
    BRDF (Bidirectional Reflectance Distribution Function)
</h3>
<ul>
	<li>
		<p>
            The BRDF describes the surface response of a standard material as a function made of two terms:
		</p>
		<ul>
			<li>
				<p>
                    A diffuse component ($f_d$).
				</p>
			</li>
			<li>
				<p>
                    A specular component ($f_r$).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911100411.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The complete surface response can be expressed as such:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911100324.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            This equation characterizes the surface response for incident light from a single direction. The full rendering equation would require to integrate $l$ over the entire hemisphere.
		</p>
	</li>
	<li>
		<p>
            Energy conservation is one of the key components of a good BRDF for physically based rendering. An energy conservative BRDF states that the total amount of specular and diffuse reflectance energy is less than the total amount of incident energy. Without an energy conservative BRDF, artists must manually ensure that the light reflected off a surface is never more intense than the incident light.
		</p>
	</li>
</ul>
<h3
	id="general-terms" >
    General Terms
</h3>
<ul>
	<li>
		<p>
            $v$
		</p>
		<ul>
			<li>
				<p>
                    View unit vector.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $h$
		</p>
		<ul>
			<li>
				<p>
                    Half unit vector between $l$ and $v$.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $l$
		</p>
		<ul>
			<li>
				<p>
                    Incident light unit vector.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $n$
		</p>
		<ul>
			<li>
				<p>
                    Normal surface unit vector.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $\alpha$
		</p>
		<ul>
			<li>
				<p>
                    Roughness, remapped from using input 
                    <code>perceptualRoughness</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="tldr" >
    TLDR
</h3>
<ul>
	<li>
		<p>
			<strong>
                Specular Term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
					<em>
                        Cook-Torrance
					</em>
                    &nbsp;specular microfacet model
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        GGX
					</em>
                    &nbsp;normal distribution function
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        Smith-GGX
					</em>
                    &nbsp;height-correlated visibility function.
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        Schlick Fresnel
					</em>
                    &nbsp;function.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Diffuse Term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
					<em>
                        Lambertian
					</em>
                    &nbsp;diffuse model.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float D_GGX(float NoH, float a) {
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = a * a;
&nbsp;&nbsp;&nbsp;&nbsp;float f = (NoH * a2 - NoH) * NoH + 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;return a2 / (PI * f * f);
}

vec3 F_Schlick(float u, vec3 f0) {
&nbsp;&nbsp;&nbsp;&nbsp;return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);
}

float V_SmithGGXCorrelated(float NoV, float NoL, float a) {
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = a * a;
&nbsp;&nbsp;&nbsp;&nbsp;float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
&nbsp;&nbsp;&nbsp;&nbsp;float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
&nbsp;&nbsp;&nbsp;&nbsp;return 0.5 / (GGXV + GGXL);
}

float Fd_Lambert() {
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0 / PI;
}

void BRDF(...) {
&nbsp;&nbsp;&nbsp;&nbsp;// &gt;&gt; Standard Model

&nbsp;&nbsp;&nbsp;&nbsp;vec3 h = normalize(v + l);

&nbsp;&nbsp;&nbsp;&nbsp;float NoV = abs(dot(n, v)) + 1e-5;
&nbsp;&nbsp;&nbsp;&nbsp;float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;float NoH = clamp(dot(n, h), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;float LoH = clamp(dot(l, h), 0.0, 1.0);

&nbsp;&nbsp;&nbsp;&nbsp;// perceptually linear roughness to roughness (see parameterization)
&nbsp;&nbsp;&nbsp;&nbsp;float roughness = perceptualRoughness * perceptualRoughness;

&nbsp;&nbsp;&nbsp;&nbsp;float D = D_GGX(NoH, roughness);
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;F = F_Schlick(LoH, f0);
&nbsp;&nbsp;&nbsp;&nbsp;float V = V_SmithGGXCorrelated(NoV, NoL, roughness);

&nbsp;&nbsp;&nbsp;&nbsp;// specular BRDF
&nbsp;&nbsp;&nbsp;&nbsp;float D = distributionCloth(roughness, NoH);&nbsp;&nbsp;// From the Cloth BRDF.
&nbsp;&nbsp;&nbsp;&nbsp;float V = visibilityCloth(NoV, NoL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// From the Cloth BRDF.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;F = sheenColor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // From the Cloth BRDF.
&nbsp;&nbsp;&nbsp;&nbsp;vec3 Fr = (D * V) * F; 

&nbsp;&nbsp;&nbsp;&nbsp;vec3 energyCompensation = 1.0 + f0 * (1.0 / dfg.y - 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;// Scale the specular lobe to account for multiscattering
&nbsp;&nbsp;&nbsp;&nbsp;Fr *= pixel.energyCompensation;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Without Cloth BRDF
&nbsp;&nbsp;&nbsp;&nbsp;// diffuse BRDF
&nbsp;&nbsp;&nbsp;&nbsp;// Conversion of base color to diffuse:
&nbsp;&nbsp;&nbsp;&nbsp;vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 Fd = diffuseColor * Fd_Lambert();&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// With Cloth BRDF
&nbsp;&nbsp;&nbsp;&nbsp;float diffuse = diffuse(roughness, NoV, NoL, LoH);
&nbsp;&nbsp;&nbsp;&nbsp;#if defined(MATERIAL_HAS_SUBSURFACE_COLOR)
&nbsp;&nbsp;&nbsp;&nbsp;// energy conservative wrap diffuse
&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= saturate((dot(n, light.l) + 0.5) / 2.25);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;vec3 Fd = diffuse * pixel.diffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &lt;&lt;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &gt;&gt; Cloth BRDF
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;#if defined(MATERIAL_HAS_SUBSURFACE_COLOR)
&nbsp;&nbsp;&nbsp;&nbsp;// cheap subsurface scatter
&nbsp;&nbsp;&nbsp;&nbsp;Fd *= saturate(subsurfaceColor + NoL);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 color = Fd + Fr * NoL;
&nbsp;&nbsp;&nbsp;&nbsp;color *= (lightIntensity * lightAttenuation) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp;#else
&nbsp;&nbsp;&nbsp;&nbsp;vec3 color = Fd + Fr;
&nbsp;&nbsp;&nbsp;&nbsp;color *= (lightIntensity * lightAttenuation * NoL) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &lt;&lt;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &gt;&gt; Clear Coat
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// remapping and linearization of clear coat roughness
&nbsp;&nbsp;&nbsp;&nbsp;clearCoatPerceptualRoughness = clamp(clearCoatPerceptualRoughness, 0.089, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;clearCoatRoughness = clearCoatPerceptualRoughness * clearCoatPerceptualRoughness;

&nbsp;&nbsp;&nbsp;&nbsp;// clear coat BRDF
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;Dc = D_GGX(clearCoatRoughness, NoH);
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;Vc = V_Kelemen(clearCoatRoughness, LoH);
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;Fc = F_Schlick(0.04, LoH) * clearCoat; // clear coat strength
&nbsp;&nbsp;&nbsp;&nbsp;float Frc = (Dc * Vc) * Fc;

&nbsp;&nbsp;&nbsp;&nbsp;// &lt;&lt;


&nbsp;&nbsp;&nbsp;&nbsp;// account for energy loss in the base layer
&nbsp;&nbsp;&nbsp;&nbsp;return color * ((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc);
}


void main() {
&nbsp;&nbsp;&nbsp;&nbsp;// I believe this is completely geared towards Directional Lights.

&nbsp;&nbsp;&nbsp;&nbsp;vec3 l = normalize(-lightDirection);
&nbsp;&nbsp;&nbsp;&nbsp;float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// lightIntensity is the illuminance
&nbsp;&nbsp;&nbsp;&nbsp;// at perpendicular incidence in lux
&nbsp;&nbsp;&nbsp;&nbsp;float illuminance = lightIntensity * NoL;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 luminance = BSDF(v, l) * illuminance;
}

</code></pre>
<h3
	id="specular-brdf" >
    Specular BRDF
</h3>
<ul>
	<li>
		<p>
            For the specular term, $f_r$ is a mirror BRDF that can be modeled with the 
			<em>
                Fresnel law
			</em>
            , noted in the 
			<em>
                Cook-Torrance
			</em>
            &nbsp;approximation of the microfacet model integration:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093903.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            This function can be simplified by introducing a Visibility Function.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911095038.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911094731.png" width="" >
            .
		</p>
	</li>
</ul>
<h5
	id="normal-distribution-function-specular-d" >
    Normal distribution function (Specular D)
</h5>
<ul>
	<li>
		<p>
			<em>
                Burley
			</em>
            &nbsp;observed that long-tailed normal distribution functions (NDF) are a good fit for real-world surfaces.
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                GGX
			</em>
            &nbsp;distribution is a distribution with long-tailed falloff and short peak in the highlights, with a simple formulation suitable for real-time implementations. It is also a popular model, equivalent to the 
			<em>
                Trowbridge-Reitz
			</em>
            &nbsp;distribution, in modern physically based renderers.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093757.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Specular D term
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">float D_GGX(float NoH, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp;float a = NoH * roughness;
&nbsp;&nbsp;&nbsp;&nbsp;float k = roughness / (1.0 - NoH * NoH + a * a);
&nbsp;&nbsp;&nbsp;&nbsp;return k * k * (1.0 / PI);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Specular D term, optimized for fp16
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">#define MEDIUMP_FLT_MAX&nbsp;&nbsp;&nbsp;&nbsp;65504.0
#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)

float D_GGX(float roughness, float NoH, const vec3 n, const vec3 h) {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 NxH = cross(n, h);
&nbsp;&nbsp;&nbsp;&nbsp;float a = NoH * roughness;
&nbsp;&nbsp;&nbsp;&nbsp;float k = roughness / (dot(NxH, NxH) + a * a);
&nbsp;&nbsp;&nbsp;&nbsp;float d = k * k * (1.0 / PI);
&nbsp;&nbsp;&nbsp;&nbsp;return saturateMediump(d);
}
</code></pre>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911121900.png" width="600" >
            .
		</p>
	</li>
</ul>
<h5
	id="geometric-shadowing-visibility-function-specular-g-specular-v" >
    Geometric Shadowing / Visibility Function (Specular G / Specular V)
</h5>
<ul>
	<li>
		<p>
			<em>
                Eric Heitz
			</em>
            &nbsp;showed in that the 
			<em>
                Smith
			</em>
            &nbsp;geometric shadowing function is the correct and exact term to use.
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                Smith
			</em>
            &nbsp;formulation is the following:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911094346.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            Consider:
		</p>
	</li>
	<li>
		<p>
			<strong>
                Specular V term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The GLSL implementation of the visibility term, is a bit more expensive than we would like since it requires two 
                    <code>sqrt</code>
                    &nbsp;operations.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">float V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = roughness * roughness;
&nbsp;&nbsp;&nbsp;&nbsp;float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
&nbsp;&nbsp;&nbsp;&nbsp;float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
&nbsp;&nbsp;&nbsp;&nbsp;return 0.5 / (GGXV + GGXL);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Approximated specular V term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This approximation is mathematically wrong but saves two square root operations and is good enough for real-time mobile applications
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">float V_SmithGGXCorrelatedFast(float NoV, float NoL, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp;float a = roughness;
&nbsp;&nbsp;&nbsp;&nbsp;float GGXV = NoL * (NoV * (1.0 - a) + a);
&nbsp;&nbsp;&nbsp;&nbsp;float GGXL = NoV * (NoL * (1.0 - a) + a);
&nbsp;&nbsp;&nbsp;&nbsp;return 0.5 / (GGXV + GGXL);
}
</code></pre>
		<ul>
			<li>
				<p>
                    (2025-09-13) Note:
				</p>
				<ul>
					<li>
						<p>
                            If roughness is 0, then the final result is 
                            <code>1 / (4 * NoL * NoV)</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            I tested this, it's correct.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911121941.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="fresnel-specular-f" >
    Fresnel (Specular F)
</h5>
<ul>
	<li>
		<p>
            This effect models the fact that the amount of light the viewer sees reflected from a surface depends on the viewing angle and on the index of refraction (IOR) of the material.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911095317.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    When looking at the water straight down (at normal incidence) you can see through the water. However, when looking further out in the distance (at grazing angle, where perceived light rays are getting parallel to the surface), you will see the specular reflections on the water become more intense.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Schlick
			</em>
            &nbsp;describes an inexpensive approximation of the 
			<em>
                Fresnel
			</em>
            &nbsp;term for the 
			<em>
                Cook-Torrance
			</em>
            &nbsp;specular BRDF:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911095503.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            This Fresnel function can be seen as interpolating between the incident specular reflectance and the reflectance at grazing angles.
		</p>
	</li>
	<li>
		<p>
			<strong>
                $f_0$ (Base Reflectance or Base Reflectivity)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a constant that represents the specular reflectance at normal incidence and is achromatic for dielectrics, and chromatic for metals.
				</p>
			</li>
			<li>
				<p>
                    The actual value depends on the index of refraction of the interface.
				</p>
			</li>
			<li>
				<p>
                    If dia-electric: use base reflectivity of 0.04; else: is a metal, use albedo as base reflectivity.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        n (Index of Refraction) (IOR)
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            base_reflectivity of 0.04 is the same as IOR = 1.5.
						</p>
					</li>
					<li>
						<p>
                            IOR 1.5 is the default for blender.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250917094252.png" width="175" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Calculating $f_0$ and Remapping
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The Fresnel term relies on $f_0$ , the specular reflectance at normal incidence angle, and is achromatic for dielectrics.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Remapping
							</em>
                            :
						</p>
<pre><code class="language-glsl" data-lang="glsl">vec3 f0 = 0.16 * reflectance * reflectance
</code></pre>
						<ul>
							<li>
								<p>
                                    See the Material -&gt; Reflectance part to understand the remapping.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Computing $f_0$ for dielectric and metallic materials in GLSL
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 f0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + baseColor * metallic;
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $f_{90}$.
		</p>
		<ul>
			<li>
				<p>
                    Reflectance at grazing angles.
				</p>
			</li>
			<li>
				<p>
                    Approaches 100% for smooth materials.
				</p>
			</li>
			<li>
				<p>
                    Observation of real world materials show that both dielectrics and conductors exhibit achromatic specular reflectance at grazing angles and that the Fresnel reflectance is 1.0 at 90Â°.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Specular F term
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">vec3 F_Schlick(float u, vec3 f0, float f90) {
&nbsp;&nbsp;&nbsp;&nbsp;return f0 + (vec3(f90) - f0) * pow(1.0 - u, 5.0);
}
</code></pre>
		<ul>
			<li>
				<p>
                    Using $f_{90}$ set to 1, the Schlick approximation for the Fresnel term can be optimized for scalar operations by refactoring the code slightly.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 F_Schlick(float u, vec3 f0) {
&nbsp;&nbsp;&nbsp;&nbsp;float f = pow(1.0 - u, 5.0);
&nbsp;&nbsp;&nbsp;&nbsp;return f + f0 * (1.0 - f);
}
</code></pre>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911121956.png" width="600" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Godot Code Snippet
					</em>
                    :
				</p>
<pre><code class="language-glsl" data-lang="glsl">float fresnel(float amount, vec3 normal, vec3 view)
{
&nbsp;&nbsp;&nbsp;&nbsp;return pow((1.0 - clamp(dot(normalize(normal), normalize(view)), 0.0, 1.0 )), amount);
}

void fragment()
{
&nbsp;&nbsp;&nbsp;&nbsp;vec3 base_color = vec3(0.0);
&nbsp;&nbsp;&nbsp;&nbsp;float basic_fresnel = fresnel(3.0, NORMAL, VIEW);
&nbsp;&nbsp;&nbsp;&nbsp;ALBEDO = base_color + basic_fresnel;
}
</code></pre>
				<ul>
					<li>
						<p>
							<em>
                                Colorful Fresnel:
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    This snippet lets you colorize the fresnel by multiplying it with an RGB-value and set the intensity to either tone down the effect or, if you crank it up, make it glow. You need to enable Glow in the Environment node. (The 
                                    <code>clamp()</code>
                                    &nbsp;has been removed allowing the fresnel to go beyond 1.0). You can also make the fresnel glow by assigning it to EMISSION.
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250917094949.png" width="400" >
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Not-colorful / colorful + glow.
										</p>
									</li>
								</ul>
							</li>
						</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 fresnel_glow(float amount, float intensity, vec3 color, vec3 normal, vec3 view)
{
&nbsp;&nbsp;&nbsp;&nbsp;return pow((1.0 - dot(normalize(normal), normalize(view))), amount) * color * intensity;
}

void fragment()
{
&nbsp;&nbsp;&nbsp;&nbsp;vec3 base_color = vec3(0.5, 0.2, 0.9);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 fresnel_color = vec3(0.0, 0.7, 0.9);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 fresnel = fresnel_glow(4.0, 4.5, fresnel_color, NORMAL, VIEW);
&nbsp;&nbsp;&nbsp;&nbsp;ALBEDO = base_color + fresnel;
}
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="energy-compensation" >
    Energy Compensation
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911093336.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Single Scaterring vs Multiscattering
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911102335.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911102417.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This solution is therefore not suitable for real-time rendering.
		</p>
	</li>
	<li>
		<p>
            The idea is to add an energy compensation term as an additional BRDF lobe.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 energyCompensation = 1.0 + f0 * (1.0 / dfg.y - 1.0);
// Scale the specular lobe to account for multiscattering
Fr *= pixel.energyCompensation;
</code></pre>
<h3
	id="diffuse-brdf" >
    Diffuse BRDF
</h3>
<ul>
	<li>
		<p>
            The diffuse term of the BRDF:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911101127.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            Our implementation will instead use a simple 
			<em>
                Lambertian BRDF
			</em>
            &nbsp;that assumes a uniform diffuse response over the microfacets hemisphere:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911101237.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Diffuse Lambertian BRDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In practice, the diffuse reflectance is multiplied later
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">float Fd_Lambert() {
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0 / PI;
}

vec3 Fd = diffuseColor * Fd_Lambert();
</code></pre>
	</li>
	<li>
		<p>
            However, the diffuse part would ideally be coherent with the specular term and take into account the surface roughness. Both the 
			<em>
                Disney diffuse BRDF
			</em>
            &nbsp;and 
			<em>
                Oren-Nayar
			</em>
            &nbsp;model take the roughness into account and create some retro-reflection at grazing angles. Given our constraints we decided that the extra runtime cost does not justify the slight increase in quality. This sophisticated diffuse model also renders image-based and spherical harmonics more difficult to express and implement.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Disney diffuse BRDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911101446.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911101459.png" width="" >
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">float F_Schlick(float u, float f0, float f90) {
&nbsp;&nbsp;&nbsp;&nbsp;return f0 + (f90 - f0) * pow(1.0 - u, 5.0);
}

float Fd_Burley(float NoV, float NoL, float LoH, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp;float f90 = 0.5 + 2.0 * roughness * LoH * LoH;
&nbsp;&nbsp;&nbsp;&nbsp;float lightScatter = F_Schlick(NoL, 1.0, f90);
&nbsp;&nbsp;&nbsp;&nbsp;float viewScatter = F_Schlick(NoV, 1.0, f90);
&nbsp;&nbsp;&nbsp;&nbsp;return lightScatter * viewScatter * (1.0 / PI);
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Lambertian diffuse BRDF vs Disney diffuse BRDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The material used is fully dialetric.
				</p>
			</li>
			<li>
				<p>
                    The surface response is very similar with both BRDFs but the Disney one exhibits some nice retro-reflections at grazing angles (look closely at the left edge of the spheres).
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911101749.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    We could allow artists/developers to choose the Disney diffuse BRDF depending on the quality they desire and the performance of the target device. It is important to note however that the Disney diffuse BRDF is not energy conserving as expressed here.
				</p>
			</li>
		</ul>
	</li>
</ul>

					</article>
					<footer
						id="note-footer" >
					</footer>
				</main>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-2026 ðŸš€
			</footer>
		</main>
		<script
			src="/static/studies.62241.js" >
		</script>
	</body>
</html>
