<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/favicon.ico" >
		<link
			rel="icon" 
			href="/assets/favicon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/favicon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script
			src="/static/docs_load.js" >
		</script>
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			src="https://unpkg.com/@highlightjs/cdn-assets@11.11.1/highlight.min.js" >
		</script>
		<script
			src="https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.min.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
					open="">
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - DOD e COP/Design - DOD e COP.html" >
                                Design - DOD e COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - ECS/Design - ECS.html" >
                                Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Design Patterns/Design - Design Patterns.html" >
                                Design - Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Architecture Patterns.html" >
                                Design - Architecture Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Concepts and Terminology.html" >
                                Design - Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Rules of thumb - Laws - Guidelines and Principles/Design - Rules of thumb - Laws - Guidelines and Principles.html" >
                                Design - Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Paradigms.html" >
                                Design - Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Production Methodologies/Design - Production Methodologies.html" >
                                Design - Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Things
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/NeoVim - Uso/NeoVim - Uso.html" >
                                NeoVim - Uso
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Dependencies.html" >
                                Dependencies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML - Tests/HTML - Tests.html" >
                                HTML - Tests
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Electronics
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<header
				id="central-header" >
				<nav
					id="dropdown-menu" >
					<select
						onchange="if (this.value) window.location.href=this.value" >
						<option
							value="/" 
>
                            🏡 Home
						</option>
						<option
							value="/studies/_index.html" 
							selected="">
                            📖 Studies
						</option>
					</select>
				</nav>
				<button
					class="btn" 
					id="button-color-theme" >
					<i>
                        ☀️ / 🌑
					</i>
				</button>
			</header>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Render Engineering
						</h1>
						<p>
							<time
								datetime="2025-07-03" >
                                🕒 Created: 2025-07-03
							</time>
							<time
								datetime="2025-10-30" >
                                | Updated: 2025-10-30
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="apis" >
    APIs
</h2>
<h3
	id="graphics-apis" >
    Graphics APIs
</h3>
<h5
	id="vulkan" >
    Vulkan
</h5>
<ul>
	<li>
		<p>
			<a
				href="Vulkan.html" 
				class="internal-link" 
				target="_self" >
                Vulkan
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Open Source Open Standard.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Type:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Low-level graphics API
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Platforms:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Windows, Linux, Android.
				</p>
			</li>
			<li>
				<p>
                    No native support for Web, needs WebAssembly.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Backend:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Vulkan
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Focus:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    High-performance games, advanced 3D graphics
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Cross-platform (Windows, Linux, Android)
				</p>
			</li>
			<li>
				<p>
                    Better performance than OpenGL due to control over the GPU
				</p>
			</li>
			<li>
				<p>
                    Better management of multiple threads and parallel rendering
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Complex and difficult to program (similar to DX12).
				</p>
			</li>
			<li>
				<p>
                    Requires more code and manual memory management
				</p>
			</li>
			<li>
				<p>
                    More recent support on some platforms (e.g., on macOS, only via layers like MoltenVK)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="webgpu" >
    WebGPU
</h5>
<ul>
	<li>
		<p>
            WebGPU is an open standard created by the W3C to offer GPU-accelerated graphics and computation within browsers.
		</p>
	</li>
	<li>
		<p>
            It is designed to replace WebGL, offering a more modern and efficient API based on Vulkan, Metal, and DirectX 12.
		</p>
	</li>
	<li>
		<p>
            Currently, it is being implemented natively in Chrome, Edge, and Firefox.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platforms
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Web.
				</p>
				<ul>
					<li>
						<p>
                            Only in browsers compatible with WebGPU.
						</p>
					</li>
					<li>
						<p>
                            It is not an independent library, but a standard that browsers implement.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Who maintains it
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The W3C, in collaboration with major companies like Google, Mozilla, Microsoft, and Apple.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                wgpu
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Open-source MIT.
				</p>
			</li>
			<li>
				<p>
                    It is a native implementation of the WebGPU standard, designed to work both in the browser and in desktop applications.
				</p>
			</li>
			<li>
				<p>
                    It serves as a cross-platform wrapper that can use different graphics APIs depending on the operating system.
				</p>
			</li>
			<li>
				<p>
                    Therefore, although WebGPU is a standard for the Web, wgpu is an implementation of that standard that can also run natively outside of browsers.
				</p>
			</li>
			<li>
				<p>
                    Written in Rust, C/C++, etc.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Type:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Mid-level graphics API
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Platforms:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Windows, Linux, macOS.
						</p>
					</li>
					<li>
						<p>
                            Web, via WebGPU.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Supported Backends:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Vulkan, DX12, Metal, OpenGL (selected automatically)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Focus:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Cross-platform, WebGPU, ease of use (Rust, C/C++)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Advantages:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Cross-platform and compatible with WebGPU
						</p>
					</li>
					<li>
						<p>
                            Easier to use than Vulkan/DX12
						</p>
					</li>
					<li>
						<p>
                            Memory safety and stability
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Disadvantages:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Less control over GPU optimizations
						</p>
					</li>
					<li>
						<p>
                            Still in development, fewer tools than Vulkan/DX12
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                wgpu vs WebGPU
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If you are developing for the Web, you will use WebGPU directly.
				</p>
			</li>
			<li>
				<p>
                    If you want to use WebGPU also in native apps, wgpu is the right choice, as it allows running the same code both in the browser and on desktops.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                wgpu vs Vulkan
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250309131745.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250309131804.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250309131817.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250309131835.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250309131847.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250309131913.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="opengl" >
    <s>OpenGL</s>
</h5>
<ul>
	<li>
		<p>
			<a
				href="OpenGL.html" 
				class="internal-link" 
				target="_self" >
                OpenGL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Open Source Open Standard.
		</p>
	</li>
	<li>
		<p>
            OpenGL itself has not been officially &quot;deprecated&quot; globally, but it is 
			<strong>
                obsolete
			</strong>
            &nbsp;in many contexts and being replaced by more modern APIs, such as Vulkan.
		</p>
		<ul>
			<li>
				<p>
                    ES 3.x versions are still used on mobile, but Vulkan is the future.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Type:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Mid-level graphics API
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Platforms:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Windows, Linux, macOS.
				</p>
			</li>
			<li>
				<p>
                    Support for Web via WebGL.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Backend:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    OpenGL
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Focus:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    3D graphics for games, graphics engines, scientific applications
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Cross-platform and widely supported
				</p>
			</li>
			<li>
				<p>
                    Easy to use compared to DX12/Vulkan
				</p>
			</li>
			<li>
				<p>
                    Good documentation and strong community
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Old API, not optimized for modern GPUs
				</p>
			</li>
			<li>
				<p>
                    Less control over memory and graphics pipeline
				</p>
			</li>
			<li>
				<p>
                    Limited support on macOS (Apple uses Metal)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="webgl" >
    <s>WebGL</s>
</h5>
<ul>
	<li>
		<p>
            Open Source Open Standard.
		</p>
	</li>
	<li>
		<p>
            It is based on OpenGL ES 2.0, which is a simplified version of OpenGL for mobile and embedded devices.
		</p>
	</li>
	<li>
		<p>
            WebGPU is the official successor to WebGL.
		</p>
	</li>
	<li>
		<p>
            WebGL is still functional, but it is not recommended for new projects.
		</p>
	</li>
	<li>
		<p>
            [2025/03/09] There is no official date for removal from browsers.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Type:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    High-level graphics API
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Platforms:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Web
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Backend:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Based on OpenGL ES 2.0
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Focus:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    3D rendering on the web
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Works directly in the browser, without the need for plugins
				</p>
			</li>
			<li>
				<p>
                    Easy to learn and integrate into web applications
				</p>
			</li>
			<li>
				<p>
                    Wide support, compatible with almost all browsers
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Based on OpenGL ES 2.0, older and less efficient technology
				</p>
			</li>
			<li>
				<p>
                    No native support for modern features like Ray Tracing and Compute Shaders
				</p>
			</li>
			<li>
				<p>
                    May have lower performance than WebGPU
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="directx-12" >
    <s>DirectX 12</s>
</h5>
<ul>
	<li>
		<p>
            Closed-source, from Microsoft.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Type:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Low-level graphics API.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Platforms:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Windows and Xbox
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Backend:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Direct3D 12
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Focus:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    AAA games, high-performance applications
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Direct control over the GPU
				</p>
			</li>
			<li>
				<p>
                    Support for Ray Tracing via DXR
				</p>
			</li>
			<li>
				<p>
                    Advanced Microsoft tools (PIX, RenderDoc)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Only for Windows and Xbox
				</p>
			</li>
			<li>
				<p>
                    High complexity, requires manual memory management and synchronization.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="metal" >
    <s>Metal</s>
</h5>
<ul>
	<li>
		<p>
            Closed-source, from Apple.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Low level and high performance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reduces CPU overhead, allowing better use of the GPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Support for parallel computation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Includes an API for general computation on the GPU (similar to CUDA or OpenCL).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Platforms
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Exclusive to the Apple ecosystem.
				</p>
				<ul>
					<li>
						<p>
                            Apple discontinued official support for OpenGL and encourages the use of Metal.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Support for Ray Tracing
			</strong>
            &nbsp;(since Metal 3).
		</p>
	</li>
</ul>
<h3
	id="shader-languages" >
    Shader Languages
</h3>
<h5
	id="spir-v" >
    SPIR-V
</h5>
<ul>
	<li>
		<p>
            <a href="Vulkan.html#SPIR-V">
            Vulkan#SPIR-V
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="glsl-opengl-shader-language" >
    GLSL (OpenGL Shader Language)
</h5>
<ul>
	<li>
		<p>
            <a href="GLSL.html">
            GLSL
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="slang" >
    Slang
</h5>
<ul>
	<li>
		<p>
            <a href="Slang.html">
            Slang
            </a>
            .
		</p>
	</li>
</ul>
<h5
	id="wgsl-webgpu" >
    WGSL (WebGPU)
</h5>
<ul>
	<li>
		<p>
            Modern, safe, and cross-platform (WebGPU standard).
		</p>
	</li>
	<li>
		<p>
            Works in browsers (WebGPU) and native (via 
            <code>wgpu</code>
            ).
		</p>
	</li>
	<li>
		<p>
            No corporate lock-in (developed by W3C &amp; Mozilla/Google/Apple).
		</p>
	</li>
	<li>
		<p>
            Newer, less mature than GLSL/SPIR-V.
		</p>
	</li>
	<li>
		<p>
            &quot;Explicitly designed to avoid C++/OOP cruft. Rust-inspired syntax but purely for GPU work.&quot;
		</p>
	</li>
</ul>
<h5
	id="hlsl-high-level-shader-language" >
    ~HLSL (High-level Shader Language)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/High-Level_Shader_Language" 
				class="external-link" 
				target="_blank" >
                HLSL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Proprietary to Microsoft.
		</p>
	</li>
	<li>
		<p>
            Made for DirectX 9.
		</p>
	</li>
	<li>
		<p>
            HLSL programs come in six forms: pixel shaders (fragment in GLSL), vertex shaders, geometry shaders, compute shaders, tessellation shaders (Hull and Domain shaders), and ray tracing shaders.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Where it can be used
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is mainly used in 
					<em>
                        DirectX-based environments
					</em>
                    &nbsp;(Windows/Xbox games, Unity, Unreal Engine). If you're targeting other platforms (macOS, Linux, mobile), you might need to use GLSL, MSL, or SPIR-V instead.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Direct3D (DirectX)
					</em>
				</p>
				<ul>
					<li>
						<p>
                            DirectX 9/10/11/12: HLSL is the standard shading language for Microsoft's Direct3D API.
						</p>
					</li>
					<li>
						<p>
                            Used in:
						</p>
						<ul>
							<li>
								<p>
                                    PC games (Windows)
								</p>
							</li>
							<li>
								<p>
                                    Xbox console development (Xbox One, Xbox Series XS)
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Unity (via Direct3D)
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Unity supports HLSL when using:
						</p>
						<ul>
							<li>
								<p>
                                    Built-in Render Pipeline (Legacy)
								</p>
							</li>
							<li>
								<p>
                                    Universal Render Pipeline (URP)
								</p>
							</li>
							<li>
								<p>
                                    High Definition Render Pipeline (HDRP)
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Shader Graph in Unity also uses HLSL-like syntax.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Unreal Engine (UE4/UE5)
					</em>
				</p>
				<ul>
					<li>
						<p>
                            Unreal Engine uses a custom shading language (Unreal Shader System, USS) but allows HLSL snippets in Custom HLSL Nodes.
						</p>
					</li>
					<li>
						<p>
                            HLSL is also used in Ray Tracing shaders in UE5.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        NVIDIA OptiX (Ray Tracing)
					</em>
				</p>
				<ul>
					<li>
						<p>
                            HLSL can sometimes be used alongside CUDA/PTX for ray tracing effects.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Vulkan (via SPIR-V Cross)
					</em>
				</p>
				<ul>
					<li>
						<p>
                            HLSL shaders can be converted to SPIR-V (Vulkan's intermediate format) using tools like:
						</p>
						<ul>
							<li>
								<p>
                                    glslangValidator (from Khronos)
								</p>
							</li>
							<li>
								<p>
                                    DXC (DirectX Shader Compiler)
								</p>
							</li>
							<li>
								<p>
                                    SPIRV-Cross (converts HLSL to GLSL/SPIR-V)
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Shader Model 6.0+ (Advanced Features)
					</em>
				</p>
				<ul>
					<li>
						<p>
                            HLSL supports modern GPU features like:
						</p>
						<ul>
							<li>
								<p>
                                    Ray Tracing (DXR)
								</p>
							</li>
							<li>
								<p>
                                    Mesh &amp; Amplification Shaders
								</p>
							</li>
							<li>
								<p>
                                    Wave Operations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Compute Shaders
					</em>
				</p>
				<ul>
					<li>
						<p>
                            (GPGPU programming in DirectX).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        AI/ML Acceleration
					</em>
				</p>
				<ul>
					<li>
						<p>
                            (Some frameworks allow HLSL-based compute shaders for GPU acceleration).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Where it's not used
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    OpenGL / WebGL → Uses GLSL instead.
				</p>
			</li>
			<li>
				<p>
                    Vulkan (Native) → Uses GLSL or SPIR-V.
				</p>
			</li>
			<li>
				<p>
                    Metal (Apple) → Uses MSL (Metal Shading Language).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex
			</strong>
            :
		</p>
<pre><code class="language-hlsl" data-lang="hlsl"> // Vertex Shader
 struct VSInput {
&nbsp;&nbsp;&nbsp;&nbsp; float3 position : POSITION;
&nbsp;&nbsp;&nbsp;&nbsp; float3 color : COLOR;
 };
 
 struct VSOutput {
&nbsp;&nbsp;&nbsp;&nbsp; float4 position : SV_POSITION;
&nbsp;&nbsp;&nbsp;&nbsp; float3 color : COLOR;
 };
 
 VSOutput VS_main(VSInput input) {
&nbsp;&nbsp;&nbsp;&nbsp; VSOutput output;
&nbsp;&nbsp;&nbsp;&nbsp; output.position = float4(input.position, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp; output.color = input.color;
&nbsp;&nbsp;&nbsp;&nbsp; return output;
 }
 
 // Fragment Shader
 struct PSInput {
&nbsp;&nbsp;&nbsp;&nbsp; float4 position : SV_POSITION;
&nbsp;&nbsp;&nbsp;&nbsp; float3 color : COLOR;
 };
 
 float4 PS_main(PSInput input) : SV_TARGET {
&nbsp;&nbsp;&nbsp;&nbsp; return float4(input.color, 1.0);
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Comparing the syntax of HLSL to GLSL
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Inputs
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            HLSL:
						</p>
						<ul>
							<li>
								<p>
                                    The parameter for the 
                                    <code>VS_main</code>
                                    &nbsp;and 
                                    <code>PS_main</code>
                                    &nbsp;describe the inputs for each step.
								</p>
							</li>
							<li>
								<p>
                                    Uses a struct with semantics (
                                    <code>: POSITION</code>
                                    , 
                                    <code>: COLOR</code>
                                    ).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            GLSL:
						</p>
						<ul>
							<li>
								<p>
                                    Uses 
                                    <code>in</code>
                                    /
                                    <code>out</code>
                                    &nbsp;variables.
								</p>
							</li>
							<li>
								<p>
                                    Uses 
                                    <code>layout(location)</code>
                                    &nbsp;to bind vertex attributes.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Outputs
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            HLSL:
                            <br>
                            Returns a struct, for passing values from the Vertex Shader to the Fragment Shader; 
                            <code>VSOutput</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            GLSL:
						</p>
						<ul>
							<li>
								<p>
                                    Uses a 
                                    <code>out</code>
                                    &nbsp;variable.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="msl-metal-shading-language" >
    <s>MSL (Metal Shading Language)</s>
</h5>
<ul>
	<li>
		<p>
            Apple’s official shader language (optimized for M1/M2).
		</p>
	</li>
	<li>
		<p>
            Required for iOS/macOS Metal apps.
		</p>
	</li>
	<li>
		<p>
            Apple-only (no Windows/Linux).
		</p>
	</li>
	<li>
		<p>
            Use with MoltenVK if you want Vulkan → Metal compatibility.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex
			</strong>
            :
		</p>
<pre><code class="language-hlsl" data-lang="hlsl"> // Vertex Shader
 #include &lt;metal_stdlib&gt;
 using namespace metal;
 
 struct VertexIn {
&nbsp;&nbsp;&nbsp;&nbsp; float3 position [[attribute(0)]];
&nbsp;&nbsp;&nbsp;&nbsp; float3 color [[attribute(1)]];
 };
 
 struct VertexOut {
&nbsp;&nbsp;&nbsp;&nbsp; float4 position [[position.md]];
&nbsp;&nbsp;&nbsp;&nbsp; float3 color;
 };
 
 vertex VertexOut vertex_main(VertexIn in [[stage_in]]) {
&nbsp;&nbsp;&nbsp;&nbsp; VertexOut out;
&nbsp;&nbsp;&nbsp;&nbsp; out.position = float4(in.position, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp; out.color = in.color;
&nbsp;&nbsp;&nbsp;&nbsp; return out;
 }
 
 // Fragment Shader
 fragment float4 fragment_main(VertexOut in [[stage_in]]) {
&nbsp;&nbsp;&nbsp;&nbsp; return float4(in.color, 1.0);
 }
</code></pre>
	</li>
</ul>
<h2
	id="tools" >
    Tools
</h2>
<h3
	id="capture" >
    Capture
</h3>
<h5
	id="gfxreconstruct" >
    GFXReconstruct
</h5>
<ul>
	<li>
		<p>
            Captures commands to a file and allows you to replay them.
		</p>
	</li>
	<li>
		<p>
            Linux, Android, Linux.
		</p>
	</li>
	<li>
		<p>
            Vulkan, but also other APIs.
		</p>
	</li>
	<li>
		<p>
            [2025/10/04]
		</p>
		<ul>
			<li>
				<p>
                    I tested it and it worked nicely, super simple.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=XwbiKwqrqHo" 
				class="external-link" 
				target="_blank" >
                GFXReconstruct
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/LunarG/gfxreconstruct" 
				class="external-link" 
				target="_blank" >
                GFXReconstruct
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vulkan.lunarg.com/doc/sdk/1.4.321.1/linux/capture_tools.html" 
				class="external-link" 
				target="_blank" >
                GFXReconstruct API Vulkan
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-sh" data-lang="sh">set VK_INSTANCE_LAYERS=VK_LAYER_LUNARG_gfxreconstruct
set GFXRECON_CAPTURE_FILE=C:\captures\capture.gfxr
set GFXRECON_CAPTURE_FRAMES=1000-2200
my_game.exe
</code></pre>
<ul>
	<li>
		<p>
            <code>gfxrecon-replay</code>
		</p>
		<ul>
			<li>
				<p>
                    Tool to replay GFXReconstruct capture files.
				</p>
			</li>
		</ul>
<pre><code class="language-sh" data-lang="sh"> gfxrecon-replay --pause-frame 1200 capture.gfxr
</code></pre>
		<ul>
			<li>
				<p>
                    Also supports 
                    <code>--screenshots</code>
                    &nbsp;and 
                    <code>--screenshot-all</code>
                    &nbsp;if you want a quick visual scan of frames.
				</p>
			</li>
			<li>
				<p>
                    While 
                    <code>gfxrecon-replay</code>
                    &nbsp;is paused, attach RenderDoc or Nsight Graphics to the replay process (or launch the replay from RenderDoc/Nsight) and use RenderDoc’s per-draw inspection / pixel history / depth buffer views. The GFXReconstruct docs explicitly say capture files “can be replayed inside other tools (RenderDoc, Nsight, AMD tools, etc.)”.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>gfxrecon-info</code>
		</p>
		<ul>
			<li>
				<p>
                    Tool to print information describing GFXReconstruct capture files.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>gfxrecon-compress</code>
		</p>
		<ul>
			<li>
				<p>
                    Tool to compress/decompress GFXReconstruct capture files.
				</p>
			</li>
			<li>
				<p>
                    The gfxrecon-compress tool requires LZ4, Zstandard, and/or zlib, which are currently optional build dependencies.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>gfxrecon-extract</code>
		</p>
		<ul>
			<li>
				<p>
                    Tool to extract SPIR-V binaries from GFXReconstruct capture files.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>gfxrecon-convert</code>
		</p>
		<ul>
			<li>
				<p>
                    Tool to convert GFXReconstruct capture files to a 
					<a
						href="https://jsonlines.org/" 
						class="external-link" 
						target="_blank" >
                        JSON Lines
					</a>
                    &nbsp;listing of API calls. (experimental for D3D12 captures)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>gfxrecon-optimize</code>
		</p>
		<ul>
			<li>
				<p>
                    Tool to produce new capture files with improved replay performance.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="debuggers" >
    Debuggers
</h3>
<h5
	id="renderdoc" >
    RenderDoc
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://renderdoc.org/" 
				class="external-link" 
				target="_blank" >
                Render Doc
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/2nafish117/odin-renderdoc" 
				class="external-link" 
				target="_blank" >
                odin-renderdoc
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    API loader.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/8ZCxFL6N7zU?si=ubZgzJR5oqLy-9ng&t=2169" 
				class="external-link" 
				target="_blank" >
                Demo {36:10 -&gt; end}
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Cross-platform.
		</p>
	</li>
	<li>
		<p>
            Open-source.
		</p>
	</li>
	<li>
		<p>
            Not a profiler, use Tracy, or other one.
		</p>
	</li>
	<li>
		<p>
            RenderDoc is not designed as a continuous multi-second timeline tracer; its strength is detailed single-frame analysis.
		</p>
	</li>
</ul>
<h5
	id="nvidia-nsight-graphics" >
    Nvidia Nsight Graphics
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://developer.nvidia.com/nsight-graphics" 
				class="external-link" 
				target="_blank" >
                Nsight Graphics
			</a>
		</p>
	</li>
	<li>
		<p>
			<strong>
                Capture
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    [2025/10/04]
				</p>
				<ul>
					<li>
						<p>
                            Exceptionally similar to RenderDoc.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                GPU Trace
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://docs.nvidia.com/nsight-graphics/2018.4/content/nsight_graphics/gpu_trace.htm?TocPath=_____8" 
						class="external-link" 
						target="_blank" >
                        GPU Trace
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Supports a limited number of frames, e.g. up to ~1–15 frames depending on options). Useful for small multi-frame captures where you already know the target time window.
				</p>
			</li>
			<li>
				<p>
                    [2025/10/04]
				</p>
				<ul>
					<li>
						<p>
                            I had to run as an admin to use it.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20251004112515.png" width="461" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="pix" >
    PIX
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h3
	id="profilers" >
    Profilers
</h3>
<h5
	id="tracy" >
    Tracy
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/oskarnp/odin-tracy" 
				class="external-link" 
				target="_blank" >
                odin-tracy
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Impressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    After testing it, I found it pretty meeeeeeeh.
				</p>
			</li>
			<li>
				<p>
                    It has 121123 compilation steps, having to use MSVC, Microsoft terminal, etc, etc.
				</p>
			</li>
			<li>
				<p>
                    The total thing weighs 1.33GB, after compiling everything.
				</p>
			</li>
			<li>
				<p>
                    Communication is done via network, which I don't like.
				</p>
			</li>
			<li>
				<p>
                    It has many options, but possibly many more than I need.
				</p>
			</li>
			<li>
				<p>
                    I don't like the &quot;timing ruler&quot; at the top, because it doesn't follow the event timeline; the thing shows any time, it's strange and completely arbitrary.
				</p>
			</li>
			<li>
				<p>
                    The only advantage I thought of in relation to this profiler is:
				</p>
				<ul>
					<li>
						<p>
                            Because it's real-time, it may have some advantage in detecting some ultra-specific bug.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Overall, I don't think it's worth the huge setup and connection to the network, but for sure if I had more use with the profiler I could change my mind, but nah.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="spall" >
    Spall
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://gravitymoth.com/spall/spall-web.html" 
				class="external-link" 
				target="_blank" >
                Spall-web
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/showcase/spall/" 
				class="external-link" 
				target="_blank" >
                About
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The 
			<a
				href="https://github.com/jakubtomsu/jobs" 
				class="external-link" 
				target="_blank" >
                Jobs
			</a>
            &nbsp;repo uses Spall in the examples:
		</p>
		<ul>
			<li>
				<p>
                    Boids.
				</p>
				<ul>
					<li>
						<p>
                            I prefer this one, because it's visual with Raylib.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Background.
				</p>
			</li>
			<li>
				<p>
                    Simple.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A 
            <code>.spall</code>
            &nbsp;file is generated and used on the site.
		</p>
	</li>
	<li>
		<p>
            For a non-web version, you have to 
			<a
				href="https://gravitymoth.itch.io/spall" 
				class="external-link" 
				target="_blank" >
                buy Spall
			</a>
            &nbsp;for $100 dollars.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Impressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I don't like it being web-based.
				</p>
			</li>
			<li>
				<p>
                    It's solid, cool, made in Odin, nice.
				</p>
			</li>
			<li>
				<p>
                    Generates local files, very simple to understand.
				</p>
			</li>
			<li>
				<p>
                    Officially supported by Odin.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="amd-gpu-profiler-amd-rgp" >
    AMD GPU Profiler (AMD RGP)
</h5>
<ul>
	<li>
		<p>
            https://gpuopen.com/rgp/
		</p>
	</li>
	<li>
		<p>
            RGP historically is single-frame focused, though driver/driver tools have timeline features for profiling
		</p>
	</li>
</ul>
<h5
	id="intel-gpa" >
    Intel GPA
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h5
	id="nsight-systems" >
    <s>Nsight Systems</s>
</h5>
<ul>
	<li>
		<p>
            https://developer.nvidia.com/nsight-systems
		</p>
	</li>
	<li>
		<p>
            [2025/10/04]
		</p>
		<ul>
			<li>
				<p>
                    Alt + Scroll:
				</p>
				<ul>
					<li>
						<p>
                            Scrolls horizontally.
						</p>
					</li>
					<li>
						<p>
                            I didn't like that.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Ctrl + Scroll:
				</p>
				<ul>
					<li>
						<p>
                            Zoom.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20251004101221.png" width="576" >
                    .
				</p>
			</li>
			<li>
				<p>
                    I thought the information was pretty &quot;bad&quot; and not specific to Vulkan.
				</p>
			</li>
			<li>
				<p>
                    I recorded 1m18s of gameplay, taking a few mins to generate the profile.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="choosing-the-space-to-compute-lighting" >
    Choosing the Space to compute Lighting
</h2>
<h5
	id="view-space" >
    View Space
</h5>
<ul>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Since view space places the camera at the origin, numbers tend to stay small and preserve precision. This is an important consideration when rendering large worlds. When coordinates become large (e.g. 1000km, they cannot represent small differences; details smaller than ~6 cm are lost.
				</p>
			</li>
			<li>
				<p>
                    View-space normals allow efficient compression: since the camera always looks down the −Z axis, we only need to store x and y components and reconstruct z, saving G-buffer bandwidth. This is a reason why several engines prefer view-space normals for deferred shading. With smaller positions, depth reconstruction is also more stable. This compression does not work for world-space normals, where all directions are equally likely.
				</p>
			</li>
			<li>
				<p>
                    The view vector in specular/PBR models is simply the negative fragment position in view space. The camera position is (0,0,0), so no extra subtraction is needed. LearnOpenGL notes that this makes the specular term easy to compute and is why many tutorials prefer view-space lighting.
				</p>
				<ul>
					<li>
						<p>
                            LearnOpenGL:
						</p>
						<ul>
							<li>
								<p>
                                    We chose to do the lighting calculations in world space, but most people tend to prefer doing lighting in view space.
								</p>
							</li>
							<li>
								<p>
                                    An advantage of view space is that the viewer's position is always at 
                                    <code>(0,0,0)</code>
                                    &nbsp;so you already got the position of the viewer for free.
								</p>
							</li>
							<li>
								<p>
                                    However, I find calculating lighting in world space more intuitive for learning purposes.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Since the fragment’s z value directly represents the distance from the camera, effects like fog, attenuation and cluster slicing in clustered shading become easier to implement.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Environment maps and image-based lighting (IBL) are usually defined in world space. To sample them, view-space normals must be converted to world space; repeated conversions can add instructions and risk precision loss. Some encoding techniques only support world-space normals.
				</p>
			</li>
			<li>
				<p>
                    Because view-space normals rotate with the camera, specular highlights and reflections may appear to wobble, especially when using normal maps.
				</p>
			</li>
			<li>
				<p>
                    Light positions and directions stored in world space must be transformed into view space each frame. For many lights, this transformation may be non-negligible (though compute shaders can handle it efficiently).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="world-space" >
    World Space
</h5>
<ul>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    World-space normals do not change when the camera moves, so specular highlights from normal maps remain stable. This is useful for physically based rendering (PBR) with image-based lighting, where a consistent normal is needed to look up from environment maps.
				</p>
			</li>
			<li>
				<p>
                    Krzysztof Narkowicz (UE5) notes that world-space normals have beneficial properties: they do not depend on the camera, so specular highlights and reflections on static objects will not wobble when the camera moves. Because their precision does not depend on the camera direction, they remain accurate even for surfaces pointing away from the viewer. In contrast, view-space normals change orientation when the camera rotates, which can make environment map lookups or specular highlights less stable.
				</p>
			</li>
			<li>
				<p>
                    Since most lights and environment maps are defined in world space, you avoid per-fragment transformations. In forward renderers this can simplify the shader because light direction can be computed once in world space and reused.
				</p>
			</li>
			<li>
				<p>
                    Some post-processing effects (SSAO, screen-space reflections) and global illumination techniques operate in world space and expect world-space positions and normals. Having them already in world space can avoid conversions.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Using world-space positions directly means adding large translations (e.g., the camera is at 1 km while shading a small object). The article “The Perils of World Space” explains that 32-bit floats only have high resolution near the origin; far from the origin, sub-centimetre differences cannot be represented. Thus shading calculations (e.g., diffuse or specular dot products) may wobble due to imprecision. This can manifest as flickering when the camera moves.
				</p>
			</li>
			<li>
				<p>
                    World-space normals require all three components to be stored, and world-space positions might need 3×32-bit floats. This increases memory bandwidth in deferred renderers compared with view-space normals, which can be compressed.
				</p>
			</li>
			<li>
				<p>
                    For specular reflections relative to the camera, you must compute the view vector by subtracting the camera position from the fragment position, adding per-fragment cost.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Trick for World Space with precision of View Space
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Instead of letting the camera roam far from the origin, move the world in the opposite direction so that the camera stays near the origin. Pharr describes decomposing the view matrix into rotation and translation, then moving the translation into the model matrices while keeping the camera at the origin; 
                    <code>worldPos – cameraPos</code>
                    &nbsp;is computed in double-precision on the CPU and passed to the GPU as a small value. Many engines (e.g., Cryengine) perform lighting in world space but shift the origin per frame; this provides the stability of view-space lighting while retaining the advantages of world-space normals
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://pharr.org/matt/blog/2018/03/02/rendering-in-camera-space" 
						class="external-link" 
						target="_blank" >
                        Matt Phaar's explanation of the trick
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="bsdf-bidirectional-scattering-distribution-function" >
    BSDF (Bidirectional Scattering Distribution Function)
</h2>
<h5
	id="sources" >
    Sources
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html" 
				class="internal-link" 
				target="_self" >
                PBR in Filament
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Filament pbr paper is nice and readable and even has some pseudo code examples. the renderer is open source (which is also a good reference)&quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;it just cuts right through the BS and just gives you the math you need&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=j-A0mwsJRmk" 
				class="external-link" 
				target="_blank" >
                Physics and Math of Shading - Siggraph
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://haqr.eu/tinyrenderer/" 
				class="external-link" 
				target="_blank" >
                Tiny Renderer Course
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf" 
				class="external-link" 
				target="_blank" >
                Moving Frostbite to Physically Based Rendering 3.0 - Siggraph 2014
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.pbr-book.org/4ed/contents" 
				class="external-link" 
				target="_blank" >
                PBR Book
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Award academy winning book.
				</p>
			</li>
			<li>
				<p>
                    Basically created the meaning of PBR.
				</p>
				<ul>
					<li>
						<p>
                            &quot;I'm finding myself pretty annoyed at how OOP-y it is so far (I think I'm at 4 levels of inheritancs now for the integrators?)&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    [2025/09/10]
				</p>
				<ul>
					<li>
						<p>
                            The reading sounds sloooow and seems to have the CMake mentality.
						</p>
					</li>
					<li>
						<p>
                            Nah fok off.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://learnopengl.com/PBR/Theory" 
				class="external-link" 
				target="_blank" >
                LearnOpenGL PBR
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    It's a super short and not enlightening explanation. The Filament PBR is better.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="samples" >
    Samples
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/SaschaWillems/Vulkan-glTF-PBR" 
				class="external-link" 
				target="_blank" >
                SaschaWillems/Vulkan-glTF-PBR
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/wdas/brdf/tree/main/src/brdfs" 
				class="external-link" 
				target="_blank" >
                BRDF Samples
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://godotshaders.com/shader/complete-cel-shader-for-godot-4/" 
				class="external-link" 
				target="_blank" >
                Cel Shading
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;wrap lighting&quot; → 
                    <code>max((dot(N,L) + wrap) / (1+wrap), 0)</code>
                    &nbsp;creates softer shading.
				</p>
			</li>
			<li>
				<p>
                    Can quantize light intensity into bands for toon-like shading.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="rendering-equation" >
    Rendering Equation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/Rendering_equation" 
				class="external-link" 
				target="_blank" >
                Rendering Equation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="bsdf-bidirectional-scattering-distribution-function" >
    BSDF (Bidirectional Scattering Distribution Function)
</h5>
<ul>
	<li>
		<p>
            A material model is described mathematically by a 
			<strong>
                BSDF
			</strong>
            &nbsp;(Bidirectional Scattering Distribution Function), which is itself composed of two other functions:
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        BRDF
					</strong>
                    &nbsp;(Bidirectional Reflectance Distribution Function)
				</p>
			</li>
			<li>
				<p>
					<strong>
                        BTDF
					</strong>
                    &nbsp;(Bidirectional Transmittance Function).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Since we aim to model commonly encountered surfaces, our standard material model will focus on the BRDF and ignore the BTDF, or approximate it greatly.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=RRE-F57fbXw" 
				class="external-link" 
				target="_blank" >
                Rendering Equation
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    {9:57}
				</p>
				<ul>
					<li>
						<p>
                            Implementation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=XK_p2MxGBQs" 
				class="external-link" 
				target="_blank" >
                Implementing the Rendering Equation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=KkOkx0FiHDA" 
				class="external-link" 
				target="_blank" >
                Rendering Equation and BRDFs
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Great video, super important to understand rendering and Physics Based Rendering (PBR).
				</p>
			</li>
			<li>
				<p>
                    Everything is based on the abstract equation, as being the basis for Based Physics Rendering:
				</p>
				<ul>
					<li>
						<p>
                            <code>outgoing_light = emitted_light + reflected_light</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {10:19}
				</p>
				<ul>
					<li>
						<p>
                            The 'reflected_light' equation is shown
						</p>
					</li>
					<li>
						<p>
                            $f_r(x, \omega_i, \omega_o)$ is the 'Bidirectional Reflectance Distribution Function (BRDF)'
						</p>
					</li>
					<li>
						<p>
                            $L_i$ is the 'color of light'.
						</p>
					</li>
					<li>
						<p>
                            $cos(\theta_i)$ is the representation of the 'Surface Normal'
						</p>
					</li>
					<li>
						<p>
                            ~Then an integral is used to calculate this at different angles, ~I don't know.
						</p>
						<ul>
							<li>
								<p>
                                    Engines don't use the integral.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {10:53}
				</p>
				<ul>
					<li>
						<p>
                            Rendering Equation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {22:58 -&gt; end}
				</p>
				<ul>
					<li>
						<p>
                            It's the most interesting part of the video, although everything is interesting.
						</p>
					</li>
					<li>
						<p>
                            Each parameter of the shader used by Disney is explained.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="brdf-bidirectional-reflectance-distribution-function" >
    BRDF (Bidirectional Reflectance Distribution Function)
</h5>
<ul>
	<li>
		<p>
            The BRDF describes the surface response of a standard material as a function made of two terms:
		</p>
		<ul>
			<li>
				<p>
                    A diffuse component ($f_d$).
				</p>
			</li>
			<li>
				<p>
                    A specular component ($f_r$).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911100411.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The complete surface response can be expressed as such:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911100324.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            This equation characterizes the surface response for incident light from a single direction. The full rendering equation would require to integrate $l$ over the entire hemisphere.
		</p>
	</li>
	<li>
		<p>
            Energy conservation is one of the key components of a good BRDF for physically based rendering. An energy conservative BRDF states that the total amount of specular and diffuse reflectance energy is less than the total amount of incident energy. Without an energy conservative BRDF, artists must manually ensure that the light reflected off a surface is never more intense than the incident light.
		</p>
	</li>
</ul>
<h5
	id="general-terms" >
    General Terms
</h5>
<ul>
	<li>
		<p>
            $v$
		</p>
		<ul>
			<li>
				<p>
                    View unit vector.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $h$
		</p>
		<ul>
			<li>
				<p>
                    Half unit vector between $l$ and $v$.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $l$
		</p>
		<ul>
			<li>
				<p>
                    Incident light unit vector.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $n$
		</p>
		<ul>
			<li>
				<p>
                    Normal surface unit vector.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $\alpha$
		</p>
		<ul>
			<li>
				<p>
                    Roughness, remapped from using input 
                    <code>perceptualRoughness</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tldr" >
    TLDR
</h5>
<ul>
	<li>
		<p>
			<strong>
                Specular Term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
					<em>
                        Cook-Torrance
					</em>
                    &nbsp;specular microfacet model
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        GGX
					</em>
                    &nbsp;normal distribution function
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        Smith-GGX
					</em>
                    &nbsp;height-correlated visibility function.
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        Schlick Fresnel
					</em>
                    &nbsp;function.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Diffuse Term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
					<em>
                        Lambertian
					</em>
                    &nbsp;diffuse model.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float D_GGX(float NoH, float a) {
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = a * a;
&nbsp;&nbsp;&nbsp;&nbsp;float f = (NoH * a2 - NoH) * NoH + 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;return a2 / (PI * f * f);
}

vec3 F_Schlick(float u, vec3 f0) {
&nbsp;&nbsp;&nbsp;&nbsp;return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);
}

float V_SmithGGXCorrelated(float NoV, float NoL, float a) {
&nbsp;&nbsp;&nbsp;&nbsp;float a2 = a * a;
&nbsp;&nbsp;&nbsp;&nbsp;float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
&nbsp;&nbsp;&nbsp;&nbsp;float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
&nbsp;&nbsp;&nbsp;&nbsp;return 0.5 / (GGXV + GGXL);
}

float Fd_Lambert() {
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0 / PI;
}

void BRDF(...) {
&nbsp;&nbsp;&nbsp;&nbsp;// &gt;&gt; Standard Model

&nbsp;&nbsp;&nbsp;&nbsp;vec3 h = normalize(v + l);

&nbsp;&nbsp;&nbsp;&nbsp;float NoV = abs(dot(n, v)) + 1e-5;
&nbsp;&nbsp;&nbsp;&nbsp;float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;float NoH = clamp(dot(n, h), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;float LoH = clamp(dot(l, h), 0.0, 1.0);

&nbsp;&nbsp;&nbsp;&nbsp;// perceptually linear roughness to roughness (see parameterization)
&nbsp;&nbsp;&nbsp;&nbsp;float roughness = perceptualRoughness * perceptualRoughness;

&nbsp;&nbsp;&nbsp;&nbsp;float D = D_GGX(NoH, roughness);
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;F = F_Schlick(LoH, f0);
&nbsp;&nbsp;&nbsp;&nbsp;float V = V_SmithGGXCorrelated(NoV, NoL, roughness);

&nbsp;&nbsp;&nbsp;&nbsp;// specular BRDF
&nbsp;&nbsp;&nbsp;&nbsp;float D = distributionCloth(roughness, NoH);&nbsp;&nbsp;// From the Cloth BRDF.
&nbsp;&nbsp;&nbsp;&nbsp;float V = visibilityCloth(NoV, NoL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// From the Cloth BRDF.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;F = sheenColor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // From the Cloth BRDF.
&nbsp;&nbsp;&nbsp;&nbsp;vec3 Fr = (D * V) * F; 

&nbsp;&nbsp;&nbsp;&nbsp;vec3 energyCompensation = 1.0 + f0 * (1.0 / dfg.y - 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;// Scale the specular lobe to account for multiscattering
&nbsp;&nbsp;&nbsp;&nbsp;Fr *= pixel.energyCompensation;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Without Cloth BRDF
&nbsp;&nbsp;&nbsp;&nbsp;// diffuse BRDF
&nbsp;&nbsp;&nbsp;&nbsp;// Conversion of base color to diffuse:
&nbsp;&nbsp;&nbsp;&nbsp;vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 Fd = diffuseColor * Fd_Lambert();&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// With Cloth BRDF
&nbsp;&nbsp;&nbsp;&nbsp;float diffuse = diffuse(roughness, NoV, NoL, LoH);
&nbsp;&nbsp;&nbsp;&nbsp;#if defined(MATERIAL_HAS_SUBSURFACE_COLOR)
&nbsp;&nbsp;&nbsp;&nbsp;// energy conservative wrap diffuse
&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= saturate((dot(n, light.l) + 0.5) / 2.25);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;vec3 Fd = diffuse * pixel.diffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &lt;&lt;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &gt;&gt; Cloth BRDF
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;#if defined(MATERIAL_HAS_SUBSURFACE_COLOR)
&nbsp;&nbsp;&nbsp;&nbsp;// cheap subsurface scatter
&nbsp;&nbsp;&nbsp;&nbsp;Fd *= saturate(subsurfaceColor + NoL);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 color = Fd + Fr * NoL;
&nbsp;&nbsp;&nbsp;&nbsp;color *= (lightIntensity * lightAttenuation) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp;#else
&nbsp;&nbsp;&nbsp;&nbsp;vec3 color = Fd + Fr;
&nbsp;&nbsp;&nbsp;&nbsp;color *= (lightIntensity * lightAttenuation * NoL) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &lt;&lt;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// &gt;&gt; Clear Coat
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// remapping and linearization of clear coat roughness
&nbsp;&nbsp;&nbsp;&nbsp;clearCoatPerceptualRoughness = clamp(clearCoatPerceptualRoughness, 0.089, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;clearCoatRoughness = clearCoatPerceptualRoughness * clearCoatPerceptualRoughness;

&nbsp;&nbsp;&nbsp;&nbsp;// clear coat BRDF
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;Dc = D_GGX(clearCoatRoughness, NoH);
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;Vc = V_Kelemen(clearCoatRoughness, LoH);
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;Fc = F_Schlick(0.04, LoH) * clearCoat; // clear coat strength
&nbsp;&nbsp;&nbsp;&nbsp;float Frc = (Dc * Vc) * Fc;

&nbsp;&nbsp;&nbsp;&nbsp;// &lt;&lt;


&nbsp;&nbsp;&nbsp;&nbsp;// account for energy loss in the base layer
&nbsp;&nbsp;&nbsp;&nbsp;return color * ((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc);
}


void main() {
&nbsp;&nbsp;&nbsp;&nbsp;// I believe this is completely geared towards Directional Lights.

&nbsp;&nbsp;&nbsp;&nbsp;vec3 l = normalize(-lightDirection);
&nbsp;&nbsp;&nbsp;&nbsp;float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// lightIntensity is the illuminance
&nbsp;&nbsp;&nbsp;&nbsp;// at perpendicular incidence in lux
&nbsp;&nbsp;&nbsp;&nbsp;float illuminance = lightIntensity * NoL;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 luminance = BSDF(v, l) * illuminance;
}

</code></pre>
<h3
	id="specular-brdf" >
    Specular BRDF
</h3>
<ul>
	<li>
		<p>
            For the specular term, $f_r$ is a mirror BRDF that can be modeled with the 
			<em>
                Fresnel law
			</em>
            , noted in the 
			<em>
                Cook-Torrance
			</em>
            &nbsp;approximation of the microfacet model integration:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093903.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            This function can be simplified by introducing a Visibility Function.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911095038.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911094731.png" width="" >
            .
		</p>
	</li>
</ul>
<h5
	id="normal-distribution-function-specular-d" >
    Normal distribution function (Specular D)
</h5>
<ul>
	<li>
		<p>
			<em>
                Burley
			</em>
            &nbsp;observed that long-tailed normal distribution functions (NDF) are a good fit for real-world surfaces.
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                GGX
			</em>
            &nbsp;distribution is a distribution with long-tailed falloff and short peak in the highlights, with a simple formulation suitable for real-time implementations. It is also a popular model, equivalent to the 
			<em>
                Trowbridge-Reitz
			</em>
            &nbsp;distribution, in modern physically based renderers.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093757.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Specular D term
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> float D_GGX(float NoH, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp; float a = NoH * roughness;
&nbsp;&nbsp;&nbsp;&nbsp; float k = roughness / (1.0 - NoH * NoH + a * a);
&nbsp;&nbsp;&nbsp;&nbsp; return k * k * (1.0 / PI);
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Specular D term, optimized for fp16
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> #define MEDIUMP_FLT_MAX&nbsp;&nbsp;&nbsp;&nbsp;65504.0
 #define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)
 
 float D_GGX(float roughness, float NoH, const vec3 n, const vec3 h) {
&nbsp;&nbsp;&nbsp;&nbsp; vec3 NxH = cross(n, h);
&nbsp;&nbsp;&nbsp;&nbsp; float a = NoH * roughness;
&nbsp;&nbsp;&nbsp;&nbsp; float k = roughness / (dot(NxH, NxH) + a * a);
&nbsp;&nbsp;&nbsp;&nbsp; float d = k * k * (1.0 / PI);
&nbsp;&nbsp;&nbsp;&nbsp; return saturateMediump(d);
 }
</code></pre>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911121900.png" width="600" >
            .
		</p>
	</li>
</ul>
<h5
	id="geometric-shadowing-visibility-function-specular-g-specular-v" >
    Geometric Shadowing / Visibility Function (Specular G / Specular V)
</h5>
<ul>
	<li>
		<p>
			<em>
                Eric Heitz
			</em>
            &nbsp;showed in that the 
			<em>
                Smith
			</em>
            &nbsp;geometric shadowing function is the correct and exact term to use.
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                Smith
			</em>
            &nbsp;formulation is the following:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911094346.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            Consider:
		</p>
	</li>
	<li>
		<p>
			<strong>
                Specular V term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The GLSL implementation of the visibility term, is a bit more expensive than we would like since it requires two 
                    <code>sqrt</code>
                    &nbsp;operations.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> float V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp; float a2 = roughness * roughness;
&nbsp;&nbsp;&nbsp;&nbsp; float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
&nbsp;&nbsp;&nbsp;&nbsp; float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
&nbsp;&nbsp;&nbsp;&nbsp; return 0.5 / (GGXV + GGXL);
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Approximated specular V term
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This approximation is mathematically wrong but saves two square root operations and is good enough for real-time mobile applications
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> float V_SmithGGXCorrelatedFast(float NoV, float NoL, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp; float a = roughness;
&nbsp;&nbsp;&nbsp;&nbsp; float GGXV = NoL * (NoV * (1.0 - a) + a);
&nbsp;&nbsp;&nbsp;&nbsp; float GGXL = NoV * (NoL * (1.0 - a) + a);
&nbsp;&nbsp;&nbsp;&nbsp; return 0.5 / (GGXV + GGXL);
 }
</code></pre>
		<ul>
			<li>
				<p>
                    [2025/09/13] Note:
				</p>
				<ul>
					<li>
						<p>
                            If roughness is 0, then the final result is 
                            <code>1 / (4 * NoL * NoV)</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            I tested this, it's correct.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911121941.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="fresnel-specular-f" >
    Fresnel (Specular F)
</h5>
<ul>
	<li>
		<p>
            This effect models the fact that the amount of light the viewer sees reflected from a surface depends on the viewing angle and on the index of refraction (IOR) of the material.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911095317.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    When looking at the water straight down (at normal incidence) you can see through the water. However, when looking further out in the distance (at grazing angle, where perceived light rays are getting parallel to the surface), you will see the specular reflections on the water become more intense.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Schlick
			</em>
            &nbsp;describes an inexpensive approximation of the 
			<em>
                Fresnel
			</em>
            &nbsp;term for the 
			<em>
                Cook-Torrance
			</em>
            &nbsp;specular BRDF:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911095503.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            This Fresnel function can be seen as interpolating between the incident specular reflectance and the reflectance at grazing angles.
		</p>
	</li>
	<li>
		<p>
			<strong>
                $f_0$ (Base Reflectance or Base Reflectivity)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a constant that represents the specular reflectance at normal incidence and is achromatic for dielectrics, and chromatic for metals.
				</p>
			</li>
			<li>
				<p>
                    The actual value depends on the index of refraction of the interface.
				</p>
			</li>
			<li>
				<p>
                    If dia-electric: use base reflectivity of 0.04; else: is a metal, use albedo as base reflectivity.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        n (Index of Refraction) (IOR)
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            base_reflectivity of 0.04 is the same as IOR = 1.5.
						</p>
					</li>
					<li>
						<p>
                            IOR 1.5 is the default for blender.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250917094252.png" width="175" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Calculating $f_0$ and Remapping
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The Fresnel term relies on $f_0$ , the specular reflectance at normal incidence angle, and is achromatic for dielectrics.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Remapping
							</em>
                            :
						</p>
<pre><code class="language-glsl" data-lang="glsl"> vec3 f0 = 0.16 * reflectance * reflectance
</code></pre>
						<ul>
							<li>
								<p>
                                    See the Material -&gt; Reflectance part to understand the remapping.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Computing $f_0$ for dielectric and metallic materials in GLSL
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl"> vec3 f0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + baseColor * metallic;
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
            $f_{90}$.
		</p>
		<ul>
			<li>
				<p>
                    Reflectance at grazing angles.
				</p>
			</li>
			<li>
				<p>
                    Approaches 100% for smooth materials.
				</p>
			</li>
			<li>
				<p>
                    Observation of real world materials show that both dielectrics and conductors exhibit achromatic specular reflectance at grazing angles and that the Fresnel reflectance is 1.0 at 90°.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Specular F term
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> vec3 F_Schlick(float u, vec3 f0, float f90) {
&nbsp;&nbsp;&nbsp;&nbsp; return f0 + (vec3(f90) - f0) * pow(1.0 - u, 5.0);
 }
</code></pre>
		<ul>
			<li>
				<p>
                    Using $f_{90}$ set to 1, the Schlick approximation for the Fresnel term can be optimized for scalar operations by refactoring the code slightly.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> vec3 F_Schlick(float u, vec3 f0) {
&nbsp;&nbsp;&nbsp;&nbsp; float f = pow(1.0 - u, 5.0);
&nbsp;&nbsp;&nbsp;&nbsp; return f + f0 * (1.0 - f);
 }
</code></pre>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911121956.png" width="600" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Godot Code Snippet
					</em>
                    :
				</p>
<pre><code class="language-glsl" data-lang="glsl"> float fresnel(float amount, vec3 normal, vec3 view)
 {
&nbsp;&nbsp;&nbsp;&nbsp; return pow((1.0 - clamp(dot(normalize(normal), normalize(view)), 0.0, 1.0 )), amount);
 }
 
 void fragment()
 {
&nbsp;&nbsp;&nbsp;&nbsp; vec3 base_color = vec3(0.0);
&nbsp;&nbsp;&nbsp;&nbsp; float basic_fresnel = fresnel(3.0, NORMAL, VIEW);
&nbsp;&nbsp;&nbsp;&nbsp; ALBEDO = base_color + basic_fresnel;
 }
</code></pre>
				<ul>
					<li>
						<p>
							<em>
                                Colorful Fresnel:
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    This snippet lets you colorize the fresnel by multiplying it with an RGB-value and set the intensity to either tone down the effect or, if you crank it up, make it glow. You need to enable Glow in the Environment node. (The 
                                    <code>clamp()</code>
                                    &nbsp;has been removed allowing the fresnel to go beyond 1.0). You can also make the fresnel glow by assigning it to EMISSION.
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250917094949.png" width="400" >
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Not-colorful / colorful + glow.
										</p>
									</li>
								</ul>
							</li>
						</ul>
<pre><code class="language-glsl" data-lang="glsl"> vec3 fresnel_glow(float amount, float intensity, vec3 color, vec3 normal, vec3 view)
 {
&nbsp;&nbsp;&nbsp;&nbsp; return pow((1.0 - dot(normalize(normal), normalize(view))), amount) * color * intensity;
 }
 
 void fragment()
 {
&nbsp;&nbsp;&nbsp;&nbsp; vec3 base_color = vec3(0.5, 0.2, 0.9);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 fresnel_color = vec3(0.0, 0.7, 0.9);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 fresnel = fresnel_glow(4.0, 4.5, fresnel_color, NORMAL, VIEW);
&nbsp;&nbsp;&nbsp;&nbsp; ALBEDO = base_color + fresnel;
 }
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="energy-compensation" >
    Energy Compensation
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911093336.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Single Scaterring vs Multiscattering
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911102335.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911102417.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This solution is therefore not suitable for real-time rendering.
		</p>
	</li>
	<li>
		<p>
            The idea is to add an energy compensation term as an additional BRDF lobe.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 energyCompensation = 1.0 + f0 * (1.0 / dfg.y - 1.0);
// Scale the specular lobe to account for multiscattering
Fr *= pixel.energyCompensation;
</code></pre>
<h3
	id="diffuse-brdf" >
    Diffuse BRDF
</h3>
<ul>
	<li>
		<p>
            The diffuse term of the BRDF:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911101127.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            Our implementation will instead use a simple 
			<em>
                Lambertian BRDF
			</em>
            &nbsp;that assumes a uniform diffuse response over the microfacets hemisphere:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911101237.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Diffuse Lambertian BRDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In practice, the diffuse reflectance is multiplied later
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> float Fd_Lambert() {
&nbsp;&nbsp;&nbsp;&nbsp; return 1.0 / PI;
 }
 
 vec3 Fd = diffuseColor * Fd_Lambert();
</code></pre>
	</li>
	<li>
		<p>
            However, the diffuse part would ideally be coherent with the specular term and take into account the surface roughness. Both the 
			<em>
                Disney diffuse BRDF
			</em>
            &nbsp;and 
			<em>
                Oren-Nayar
			</em>
            &nbsp;model take the roughness into account and create some retro-reflection at grazing angles. Given our constraints we decided that the extra runtime cost does not justify the slight increase in quality. This sophisticated diffuse model also renders image-based and spherical harmonics more difficult to express and implement.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Disney diffuse BRDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911101446.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911101459.png" width="" >
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> float F_Schlick(float u, float f0, float f90) {
&nbsp;&nbsp;&nbsp;&nbsp; return f0 + (f90 - f0) * pow(1.0 - u, 5.0);
 }
 
 float Fd_Burley(float NoV, float NoL, float LoH, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp; float f90 = 0.5 + 2.0 * roughness * LoH * LoH;
&nbsp;&nbsp;&nbsp;&nbsp; float lightScatter = F_Schlick(NoL, 1.0, f90);
&nbsp;&nbsp;&nbsp;&nbsp; float viewScatter = F_Schlick(NoV, 1.0, f90);
&nbsp;&nbsp;&nbsp;&nbsp; return lightScatter * viewScatter * (1.0 / PI);
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Lambertian diffuse BRDF vs Disney diffuse BRDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The material used is fully dialetric.
				</p>
			</li>
			<li>
				<p>
                    The surface response is very similar with both BRDFs but the Disney one exhibits some nice retro-reflections at grazing angles (look closely at the left edge of the spheres).
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911101749.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    We could allow artists/developers to choose the Disney diffuse BRDF depending on the quality they desire and the performance of the target device. It is important to note however that the Disney diffuse BRDF is not energy conserving as expressed here.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="material" >
    Material
</h2>
<h3
	id="base-color-albedo" >
    Base Color / Albedo
</h3>
<ul>
	<li>
		<p>
            Diffuse albedo for non-metallic surfaces, and specular color for metallic surfaces.
		</p>
	</li>
	<li>
		<p>
            Linear RGB 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            It should be devoid of lighting information, except for micro-occlusion.
		</p>
	</li>
	<li>
		<p>
			<em>
                For Non-Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Represents the reflected color and should be an sRGB value in the range 50-240 (strict range) or 30-240 (tolerant range).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                For Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Represents both the specular color and reflectance.
				</p>
			</li>
			<li>
				<p>
                    Use values with a luminosity of 67% to 100% (170-255 sRGB).
				</p>
			</li>
			<li>
				<p>
                    Oxidized or dirty metals should use a lower luminosity than clean metals to take into account the non-metallic components.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="roughness-value-roughness-map" >
    Roughness Value / Roughness Map
</h3>
<ul>
	<li>
		<p>
            Perceived smoothness (0.0) or roughness (1.0) of a surface. Smooth surfaces exhibit sharp reflections
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093528.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Rough (left), smooth (right).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093458.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Remapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911104026.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911104037.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="metallic-map" >
    Metallic Map
</h3>
<ul>
	<li>
		<p>
            Whether a surface appears to be dielectric (0.0) or conductor (1.0).
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            Is almost a binary value. Pure conductors have a metallic value of 1 and pure dielectrics have a metallic value of 0. You should try to use values close at or close to 0 and 1. Intermediate values are meant for transitions between surface types (metal to rust for instance).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093402.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Non-Metallic.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911093417.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Metallic.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="reflectance" >
    Reflectance
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
            Fresnel reflectance at normal incidence for dielectric surfaces. This replaces an explicit index of refraction
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                For Non-Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Should be set to 127 sRGB (0.5 linear, 4% reflectance) if you cannot find a proper value. Do not use values under 90 sRGB (0.35 linear, 2% reflectance).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                For Metallic Materials
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is ignored (calculated from the base color).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We will use the remapping for dielectric surfaces:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911103051.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    For 
                    <code>reflectance = 0.5</code>
                    , 
                    <code>f0 = 0.04</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The goal is to map onto a range that can represent the Fresnel values of both common dielectric surfaces (4% reflectance) and gemstones (8% to 16%).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911103131.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The mapping function is chosen to yield a 4% Fresnel reflectance value for an input reflectance of 0.5 (or 128 on a linear RGB gray scale).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911103206.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        No
					</strong>
                    &nbsp;real world material has a value under 2%.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911103248.png" width="448" >
            .
		</p>
	</li>
</ul>
<h3
	id="emission" >
    Emission
</h3>
<ul>
	<li>
		<p>
            Additional diffuse albedo to simulate emissive surfaces (such as neons, etc.) This parameter is mostly useful in an HDR pipeline with a bloom pass
		</p>
	</li>
	<li>
		<p>
            Linear RGB 
            <code>[0..1]</code>
            &nbsp;+ exposure compensation.
		</p>
	</li>
</ul>
<h3
	id="normal-map-displacement-map" >
    Normal Map, Displacement Map
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_ZbkOZNgwNk" 
				class="external-link" 
				target="_blank" >
                PBR Textures in 3 minutes
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.a23d.co/blog/different-maps-in-pbr-textures/" 
				class="external-link" 
				target="_blank" >
                PBR Textures Showcase
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=cM7RjEtZGHw" 
				class="external-link" 
				target="_blank" >
                Bump, Normal, Displacement, and Parallax Mapping
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Great video. No formulas or implementation, though.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="displacement-map" >
    Displacement Map
</h5>
<ul>
	<li>
		<p>
            Actually generate the geometry deformation; it's not faking anything.
		</p>
	</li>
	<li>
		<p>
            A lot more expensive then Bump Map or Normal Map.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911231808.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Requirements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You can have a really high-res Displacement Map, but if you don't have enough vertices to displace, then you will not get the geometric detail.
				</p>
				<ul>
					<li>
						<p>
                            This is not the same for Normal Maps; a high-res Normal Map give high detail, regardless of the vertex count.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Displacement Map vs Displacement Map + Normal Map
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The Displacement Map is usually used with a Normal Map.
				</p>
				<ul>
					<li>
						<p>
                            Just by moving vertices around, you are 
							<em>
                                not
							</em>
                            &nbsp;changing the normals. To see the visual changes, you need the normals that the geometry will have after the displacement.
						</p>
					</li>
					<li>
						<p>
                            How can I get the Normal Map? You can use the Displacement Map as a Bump Map, which will give you the information you need to get the Normal Map.
						</p>
					</li>
					<li>
						<p>
                            You should have a Normal Map if you intend to use the Displacement Map at runtime, as it's cheaper then having to calculate the normals on the fly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911232555.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    You 
					<strong>
                        can
					</strong>
                    &nbsp;use a Displacement Map without a Normal Map, but you need to &quot;apply&quot; the Displacement Map so you calculate the new normals after the Displacement.
				</p>
			</li>
			<li>
				<p>
                    If you don't apply (and thus re-calculate the surface normals), you will need a Normal Map.
				</p>
			</li>
			<li>
				<p>
                    In the end, you 
					<strong>
                        need
					</strong>
                    &nbsp;the new normals, in one way or another.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Used for
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Offline Terrain Generation.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250911232137.png" width="500" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Offline Sculptures.
				</p>
				<ul>
					<li>
						<p>
                            Some fine details that are hard to model, and you may want geometry, instead of faking with a Normal Map.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250911231924.png" width="450" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Per-Pixel Displacement Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's a technique to get the 
					<em>
                        visual
					</em>
                    &nbsp;of a displacement map, without generating new geometry.
				</p>
			</li>
			<li>
				<p>
                    The trick is not 
					<em>
                        elevating
					</em>
                    &nbsp;the geometry with the Displacement Mapping, but &quot;craving&quot; the geometry.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911233759.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Renders the green point, instead of the blue point.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This is a lot cheaper then having a Displacement Map generating the geometry, but still has a cost, as the fragment shader needs to figure out what pixel to actually shade.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Parallax Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a way to approximate the result of 
					<em>
                        Per-Pixel Displacement Mapping
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911234430.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            With 
							<em>
                                Per-Pixel Displacement Mapping
							</em>
                            , the frag shader would have to figure out what's the correct point to shade. It will look for the blue point B.
						</p>
					</li>
					<li>
						<p>
                            With 
							<em>
                                Parallax Mapping
							</em>
                            , the height between the A point and the correct height H(A) is used as an approximation to determine where the blue point B is. In this example, the technique misses the B point and reaches P, but this is the final pixel that will be drawn.
						</p>
						<ul>
							<li>
								<p>
                                    Even tho seems like a &quot;big miss&quot;, the final visual looks fine.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911234814.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911234847.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            If the surface is rotated, things begin to not look so good.
						</p>
					</li>
					<li>
						<p>
                            Looking head on is better.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Steep Parallax Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A better approximation for 
					<em>
                        Per-Pixel Displacement Mapping
					</em>
                    &nbsp;then 
					<em>
                        Parallax Mapping
					</em>
                    , but a considerable more expensive then 
					<em>
                        Parallax Mapping
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235213.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            It does multiple texture reads instead of just one, in order to determine a better &quot;stopping point&quot; for the 'correct pixel to shade'.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235433.png" width="400" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            It's better, but if the angle is too exagerated, the problem returns.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Parallax Occlusion Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A better approximation for 
					<em>
                        Per-Pixel Displacement Mapping
					</em>
                    &nbsp;then 
					<em>
                        Step Parallax Mapping
					</em>
                    , but a bit more expensive then 
					<em>
                        Step Parallax Mapping
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235525.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            It adds one extra step at the end of the 
							<em>
                                Step Parallax Mapping
							</em>
                            &nbsp;evaluation.
						</p>
					</li>
					<li>
						<p>
                            This extra step doesn't perform any new texture read, it just better guesses the 'correct pixel to shade' based on the position of the previous step and the final step.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It gives more &quot;continuity&quot; for the guesses. It's smoother.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911235820.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000032.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            The stairs uses the Parallax Occlusion Mapping; it's just a flat plain.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000107.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            All the walls uses the Parallax Occlusion Mapping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000151.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000230.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                What about shadow casting?
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Displacement Mapping and all techniques that approximate the result of Displacement Mapping 
					<strong>
                        can
					</strong>
                    &nbsp;cast shadows.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912000441.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://apoorvaj.io/exploring-bump-mapping-with-webgl/" 
				class="external-link" 
				target="_blank" >
                WebGL Demo of different displacement techniques
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    [2025/09/12] Didn't work on Firefox, Brave, or Chrome.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="normal-map" >
    Normal Map
</h5>
<ul>
	<li>
		<p>
			<strong>
                Tangent Space
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=htr3vELCmnY" 
						class="external-link" 
						target="_blank" >
                        Explanation, with visualization of the Tangent Space
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="http://wiki.polycount.com/wiki/Normal_Map_Technical_Details" 
						class="external-link" 
						target="_blank" >
                        Tech Details
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://terathon.com/blog/tangent-space.html" 
						class="external-link" 
						target="_blank" >
                        Tangent Space - Eric Lengyel
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            [2025/09/15]
						</p>
						<ul>
							<li>
								<p>
                                    This is the one I chose to use.
								</p>
							</li>
							<li>
								<p>
                                    Raylib does this same implementation in 
                                    <code>GenMeshTangents</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="http://www.mikktspace.com/" 
						class="external-link" 
						target="_blank" >
                        mikktspace
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The implementation is designed, specifically, to make the generation of tangent space as resilient as possible to a 3D model being moved from one application to another. That is generate the same tangent spaces even if there is a change in index list(s), ordering of faces/vertices of a face, and/or the removal of degenerate primitives. Both triangles and quads are supported.
						</p>
					</li>
					<li>
						<p>
                            This makes it easy for anyone to integrate the implementation into their own application and thus reproduce the same tangent spaces. This also makes the code a perfect candidate for an implementation standard. We hope the standard will be adopted by as many developers as possible.
						</p>
					</li>
					<li>
						<p>
                            The standard is used in Blender 2.57 and is also used by default in xNormal since version 3.17.5 in the form of a built-in tangent space plugin (binary and code).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/wrapperup/odin-mikktspace/blob/main/mikktspace.odin" 
						class="external-link" 
						target="_blank" >
                        Mikktspace in Odin
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://github.com/wrapperup/odin-mikktspace/blob/main/example/example.odin" 
								class="external-link" 
								target="_blank" >
                                Example
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Smooth Shading / Flat Shading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Apparently my procedural Meshes are smooth by default, due to my implementation.
				</p>
				<ul>
					<li>
						<p>
                            If adjacent faces share the same vertex a
						</p>
					</li>
					<li>
						<p>
                            If triangles do not share vertex normals (i.e., each triangle has its own vertex normal equal to the face normal), lighting will be flat (sharp edges between faces).nd that vertex has a single normal (an average), shading will be smooth across the faces.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Meshes coming from models may or may not be smooth, depending on how it was imported.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A RGB texture encoding surface normals (X, Y, Z).
		</p>
	</li>
	<li>
		<p>
            Overrides per-pixel normal vectors, giving the illusion of complex surface detail under lighting without changing geometry.
		</p>
	</li>
	<li>
		<p>
            Used for small details/deformations; doesn't work well for something that is too deep or elevated; the illusion breaks.
		</p>
	</li>
	<li>
		<p>
            The coordinates from the Normal Map are actually in local coordinates from the point evaluated.
		</p>
		<ul>
			<li>
				<p>
                    This make sense, as we want the normals to make sense, even if the character is moving.
				</p>
			</li>
			<li>
				<p>
                    This is why there's a lof of blue in a normal map. The more blue the map is, the less disturbed the normal of a point is.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Color intuition
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Red: inclining the normal towards the X direction (X+ == right).
				</p>
			</li>
			<li>
				<p>
                    Green: inclining towards the Y direction (Y+ == up).
				</p>
			</li>
			<li>
				<p>
                    Blue: not inclining.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911232302.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.texturecan.com/post/3/DirectX-vs-OpenGL-Normal-Map/" 
				class="external-link" 
				target="_blank" >
                NormalMap DirectX vs NormalMap OpenGL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Blending normal maps
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reoriented normal mapping
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> vec3 t = texture(baseMap,&nbsp;&nbsp; uv).xyz * vec3( 2.0,&nbsp;&nbsp;2.0, 2.0) + vec3(-1.0, -1.0,&nbsp;&nbsp;0.0);
 vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,&nbsp;&nbsp;1.0, -1.0);
 vec3 r = normalize(t * dot(t, u) - u * t.z);
 return r;
</code></pre>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911115624.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        UDN Blending
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Its main advantage is the low number of shader instructions it requires.
						</p>
					</li>
					<li>
						<p>
                            While it leads to a reduction in details over flat areas, UDN blending is interesting if blending must be performed at runtime.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl"> vec3 t = texture(baseMap,&nbsp;&nbsp; uv).xyz * 2.0 - 1.0;
 vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
 vec3 r = normalize(t.xy + u.xy, t.z);
 return r;
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="height-map" >
    ~Height Map
</h5>
<ul>
	<li>
		<p>
            Usually referred to as a Bump Map, but they aren't 
			<em>
                really
			</em>
            &nbsp;the same.
		</p>
	</li>
	<li>
		<p>
            Grayscale texture, encoding relative surface elevation; it represents the actual height/elevation values, 
			<em>
                not the variations
			</em>
            &nbsp;as a Bump Map would do.
		</p>
	</li>
	<li>
		<p>
            It can be used in different contexts:
		</p>
		<ul>
			<li>
				<p>
                    To generate normals (essentially turning it into a bump/normal map).
				</p>
			</li>
			<li>
				<p>
                    To drive 
					<strong>
                        parallax mapping
					</strong>
                    &nbsp;(screen-space depth illusion).
				</p>
			</li>
			<li>
				<p>
                    To drive 
					<strong>
                        displacement mapping
					</strong>
                    &nbsp;(real geometric change).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="bump-map" >
    <s>Bump Map</s>
</h5>
<ul>
	<li>
		<p>
            Grayscale texture where brightness represents surface height 
			<em>
                variations
			</em>
            . White = high, black = low.
		</p>
	</li>
	<li>
		<p>
            It does not store absolute &quot;height,&quot; but only brightness variations that are sampled to compute a local slope.
		</p>
	</li>
	<li>
		<p>
            No depth, no parallax.
		</p>
	</li>
	<li>
		<p>
            Very lightweight (single-channel grayscale).
		</p>
	</li>
	<li>
		<p>
            Typically used for adding simple surface detail in older or performance-constrained engines.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911232217.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            Requires additional texture reads. You have to know how the height is changing in regions around the current point.
		</p>
	</li>
	<li>
		<p>
            &quot;Would be nice to just pre-record the normals (as that what we actually want), instead of having to compute the normals through a Bump Map? Yes! That's why a Normal Map exists&quot;.
		</p>
	</li>
	<li>
		<p>
            The Normal Map stores the normals, instead of the variation of the normals, like a Bump Map.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911231258.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Visually, at runtime, they will look exactly the same; not always, but close enough; the parameters need to be the same.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Normal Map is the modernized version of a Bump Map.
		</p>
	</li>
</ul>
<h3
	id="ambient-occlusion-map" >
    Ambient Occlusion Map
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
            Defines how much of the ambient light is accessible to a surface point. It is a per-pixel shadowing factor between 0.0 and 1.0.
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[0..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            AO is an 
			<em>
                approximation of diffuse global illumination
			</em>
            , focusing purely on occlusion from nearby geometry, approximating how exposed each point in a scene is to ambient lighting.
		</p>
	</li>
	<li>
		<p>
            More specifically, it estimates the amount of indirect light that reaches a surface point by considering occlusion from nearby geometry.
		</p>
		<ul>
			<li>
				<p>
                    Areas that are tightly enclosed or near other surfaces (e.g., corners, creases) receive less ambient light and appear darker.
				</p>
			</li>
			<li>
				<p>
                    Areas that are more open or exposed receive more ambient light and appear brighter.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            AO is not full global illumination; it ignores directional light transport and color bleeding—it’s a simplified model to capture the general “shadowing” effect of ambient light.
		</p>
	</li>
	<li>
		<p>
            The idea for Ambient Occlusion is to determine how bright or dark a region should be based on what is occluding it.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917181932.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917182017.png" width="800" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917182035.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="ambient-occlusion-map" >
    Ambient Occlusion Map
</h5>
<ul>
	<li>
		<p>
			<strong>
                Diffuse
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> // diffuse indirect
 vec3 indirectDiffuse = max(irradianceSH(n), 0.0) * Fd_Lambert();
 
 // ambient occlusion
 indirectDiffuse *= texture2D(aoMap, outUV).r;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Specular
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> float f90 = clamp(dot(f0, 50.0 * 0.33), 0.0, 1.0);
 // cheap luminance approximation
 float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
</code></pre>
<pre><code class="language-glsl" data-lang="glsl"> float computeSpecularAO(float NoV, float ao, float roughness) {
&nbsp;&nbsp;&nbsp;&nbsp; return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);
 }
 
 // specular indirect
 vec3 indirectSpecular = evaluateSpecularIBL(r, perceptualRoughness);
 
 // ambient occlusion
 float ao = texture2D(aoMap, outUV).r;
 indirectSpecular *= computeSpecularAO(NoV, ao, roughness);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Horizon
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> // specular indirect
 vec3 indirectSpecular = evaluateSpecularIBL(r, perceptualRoughness);
 
 // horizon occlusion with falloff, should be computed for direct specular too
 float horizon = min(1.0 + dot(r, n), 1.0);
 indirectSpecular *= horizon * horizon;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Suggestions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    : Option 4 is the correct one, 3 is acceptable in the absence of IBL, and 1 is a non-physics-based hack.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    ~multiply only the albedo.
				</p>
				<ul>
					<li>
						<p>
                            Blender does it this way.
						</p>
					</li>
					<li>
						<p>
                            I felt that it greatly increases the contrast in the object. Even in the most illuminated points, there are dark regions.
						</p>
					</li>
					<li>
						<p>
                            If you multiply the base color texture directly by AO (texture-level multiplication), you may inadvertently change the metallic F0 appearance. Avoid multiplying the base color used for F0 in the specular path; instead apply AO only to the diffuse/indirect parts.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~multiply only the diffuse.
				</p>
				<ul>
					<li>
						<p>
                            I felt that it greatly increases the contrast in the object. Even in the most illuminated points, there are dark regions.
						</p>
					</li>
					<li>
						<p>
                            Do not multiply light_accumulation by AO — that would darken direct lighting and specular highlights.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~multiply the ambient_final
				</p>
				<ul>
					<li>
						<p>
                            If you have no IBL yet, multiply the AO into ambient_final. Once you add IBL, multiply AO into the indirect diffuse term (the irradiance / ambient diffuse) and apply a reduced or rougness-weighted AO to the indirect specular if you want occlusion to affect glossy reflections.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    apply only to ambient indirect:
				</p>
<pre><code class="language-glsl" data-lang="glsl">// -&gt; Indirect diffuse (irradiance)
vec3 irradiance; // from diffuse irradiance probe / spherical harmonics / ambient color
// the diffuse response (Lambertian) is usually: irradiance * albedo / PI
vec3 ambient_diffuse = irradiance * (albedo * (1.0 / PI));
// apply AO to indirect diffuse (AO modulates the irradiance * albedo term)
ambient_diffuse *= ao;

// -&gt;Indirect specular (IBL)
// prefilteredSpecular and a BRDF LUT give you the specular IBL contribution:
vec3 prefilteredColor; // sample prefiltered environment map with roughness
vec2 brdfLUT;          // result from split-sum integration: (scale, bias)
vec3 ambient_specular = prefilteredColor * (brdfLUT.x * F0 + brdfLUT.y);
// Optionally attenuate indirect specular by AO depending on roughness.
// Rationale: very smooth surfaces reflect far-away environment less affected by local occluders.
float specularAO = mix(1.0, ao, clamp(1.0 - roughness, 0.0, 1.0)); // lerp: smooth -&gt; less AO effect
ambient_specular *= specularAO;

// -&gt; Combine
vec3 ambient_indirect = ambient_diffuse + ambient_specular;
// final (linear)
vec3 final_color = light_accumulation + ambient_indirect + emissive;
return final_color;
</code></pre>
			</li>
		</ol>
	</li>
</ul>
<h3
	id="anisotropy" >
    Anisotropy
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
            Amount of anisotropy.
		</p>
	</li>
	<li>
		<p>
            Scalar 
            <code>[-1..1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            Note that negative values will align the anisotropy with the bitangent direction instead of the tangent direction.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105626.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    For a rough metallic surface.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="anisotropy-specular-brdf" >
    Anisotropy Specular BRDF
</h5>
<ul>
	<li>
		<p>
            The standard material model described previously can only describe isotropic surfaces, that is, surfaces whose properties are identical in all directions. Many real-world materials, such as brushed metal, can, however, only be replicated using an anisotropic model.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105315.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                Isotropic Specular BRDF
			</em>
            &nbsp;described previously can be modified to handle anisotropic materials.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Burley's anisotropic NDF
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> float at = max(roughness * (1.0 + anisotropy), 0.001);
 float ab = max(roughness * (1.0 - anisotropy), 0.001);
 
 float D_GGX_Anisotropic(float NoH, const vec3 h,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const vec3 t, const vec3 b, float at, float ab) {
&nbsp;&nbsp;&nbsp;&nbsp; float ToH = dot(t, h);
&nbsp;&nbsp;&nbsp;&nbsp; float BoH = dot(b, h);
&nbsp;&nbsp;&nbsp;&nbsp; float a2 = at * ab;
&nbsp;&nbsp;&nbsp;&nbsp; highp vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
&nbsp;&nbsp;&nbsp;&nbsp; highp float v2 = dot(v, v);
&nbsp;&nbsp;&nbsp;&nbsp; float w2 = a2 / v2;
&nbsp;&nbsp;&nbsp;&nbsp; return a2 * w2 * w2 * (1.0 / PI);
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Anisotropic visibility function
			</strong>
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float at = max(roughness * (1.0 + anisotropy), 0.001);
float ab = max(roughness * (1.0 - anisotropy), 0.001);

float V_SmithGGXCorrelated_Anisotropic(float at, float ab, float ToV, float BoV,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float ToL, float BoL, float NoV, float NoL) {
&nbsp;&nbsp;&nbsp;&nbsp;float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
&nbsp;&nbsp;&nbsp;&nbsp;float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
&nbsp;&nbsp;&nbsp;&nbsp;float v = 0.5 / (lambdaV + lambdaL);
&nbsp;&nbsp;&nbsp;&nbsp;return saturateMediump(v);
}
</code></pre>
<h3
	id="clear-coat" >
    Clear Coat
</h3>
<h5
	id="parameter" >
    Parameter
</h5>
<ul>
	<li>
		<p>
			<strong>
                Clear Coat
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Strength of the clear coat layer.
				</p>
			</li>
			<li>
				<p>
                    Scalar 
                    <code>[0..1]</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Clear Coat Roughness
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Perceived smoothness or roughness of the clear coat layer.
				</p>
			</li>
			<li>
				<p>
                    Scalar 
                    <code>[0..1]</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911104913.png" width="500" >
            .
		</p>
	</li>
</ul>
<h5
	id="clear-coat-specular-brdf" >
    Clear Coat Specular BRDF
</h5>
<ul>
	<li>
		<p>
            The standard material model is a good fit for isotropic surfaces made of a single layer.
		</p>
	</li>
	<li>
		<p>
            Multi-layer materials are fairly common, particularly materials with a thin translucent layer over a standard layer.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Car paints, soda cans, lacquered wood, acrylic, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911104505.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            A clear coat layer can be simulated as an extension of the standard material model by adding a second specular lobe, which implies evaluating a second specular BRDF.
		</p>
	</li>
	<li>
		<p>
            To simplify the implementation and parameterization, the clear coat layer will always be isotropic and dielectric.
		</p>
	</li>
	<li>
		<p>
            Our model will however not simulate inter reflection and refraction behaviors.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911104550.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            It's a 
			<em>
                Cook-Torrance
			</em>
            &nbsp;specular microfacet model, with a 
			<em>
                GGX
			</em>
            &nbsp;normal distribution function, a 
			<em>
                Kelemen
			</em>
            &nbsp;visibility function, and a 
			<em>
                Schlick Fresnel
			</em>
            &nbsp;function.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Kelemen visibility term
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> float V_Kelemen(float LoH) {
&nbsp;&nbsp;&nbsp;&nbsp; return 0.25 / (LoH * LoH);
 }
</code></pre>
	</li>
</ul>
<h3
	id="sheen" >
    Sheen
</h3>
<h5
	id="parameters" >
    Parameters
</h5>
<ul>
	<li>
		<p>
			<strong>
                Color
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Specular tint to create two-tone specular fabrics (defaults to 0.04 to match the standard reflectance).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Subsurface Color
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Tint for the diffuse color after scattering and absorption through the material.
				</p>
			</li>
			<li>
				<p>
                    To create a velvet-like material, the base color can be set to black (or a dark color). Chromaticity information should instead be set on the sheen color. To create more common fabrics such as denim, cotton, etc. use the base color for chromaticity and use the default sheen color or set the sheen color to the luminance of the base color.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="cloth-specular-brdf" >
    Cloth Specular BRDF
</h5>
<ul>
	<li>
		<p>
            All the material models described previously are designed to simulate dense surfaces, both at a macro and at a micro level. Clothes and fabrics are however often made of loosely connected threads that absorb and scatter incident light. The microfacet BRDFs presented earlier do a poor job of recreating the nature of cloth due to their underlying assumption that a surface is made of random grooves that behave as perfect mirrors. When compared to hard surfaces, cloth is characterized by a softer specular lobe with a large falloff and the presence of fuzz lighting, caused by forward/backward scattering. Some fabrics also exhibit two-tone specular colors (velvets for instance).
		</p>
	</li>
	<li>
		<p>
            A traditional microfacet BRDF fails to capture the appearance of a sample of denim fabric. The surface appears rigid (almost plastic-like), more similar to a tarp than a piece of clothing. This figure also shows how important the softer specular lobe caused by absorption and scattering is to the faithful recreation of the fabric.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105748.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            Velvet is an interesting use case for a cloth material model. As shown below, this type of fabric exhibits strong rim lighting due to forward and backward scattering. These scattering events are caused by fibers standing straight at the surface of the fabric. When the incident light comes from the direction opposite to the view direction, the fibers will forward-scatter the light. Similarly, when the incident light from the same direction as the view direction, the fibers will scatter the light backward.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911105824.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            The 
			<em>
                cloth specular BRDF
			</em>
            &nbsp;we use is a modified microfacet BRDF as described by 
			<em>
                Ashikhmin
			</em>
            &nbsp;and 
			<em>
                Premoze
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ashikhmin's Velvet NDF
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> float D_Ashikhmin(float roughness, float NoH) {
&nbsp;&nbsp;&nbsp;&nbsp; // Ashikhmin 2007, "Distribution-based BRDFs"
&nbsp;&nbsp;&nbsp;&nbsp; float a2 = roughness * roughness;
&nbsp;&nbsp;&nbsp;&nbsp; float cos2h = NoH * NoH;
&nbsp;&nbsp;&nbsp;&nbsp; float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 &gt; 0 in fp16
&nbsp;&nbsp;&nbsp;&nbsp; float sin4h = sin2h * sin2h;
&nbsp;&nbsp;&nbsp;&nbsp; float cot2 = -cos2h / (a2 * sin2h);
&nbsp;&nbsp;&nbsp;&nbsp; return 1.0 / (PI * (4.0 * a2 + 1.0) * sin4h) * (4.0 * exp(cot2) + sin4h);
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Charlie NDF
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Optimized to properly fit in half float formats.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> float D_Charlie(float roughness, float NoH) {
&nbsp;&nbsp;&nbsp;&nbsp; // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
&nbsp;&nbsp;&nbsp;&nbsp; float invAlpha&nbsp;&nbsp;= 1.0 / roughness;
&nbsp;&nbsp;&nbsp;&nbsp; float cos2h = NoH * NoH;
&nbsp;&nbsp;&nbsp;&nbsp; float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 &gt; 0 in fp16
&nbsp;&nbsp;&nbsp;&nbsp; return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
 }
</code></pre>
	</li>
</ul>
<h5
	id="cloth-diffuse-brdf" >
    Cloth Diffuse BRDF
</h5>
<ul>
	<li>
		<p>
			<strong>
                Sheen
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    To offer better control over the appearance of cloth and to give users the ability to recreate two-tone specular materials, we introduce the ability to directly modify the specular reflectance.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250911110124.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Subsurface Scattering
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911110609.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="direct-lighting" >
    Direct Lighting
</h2>
<h3
	id="parametrization" >
    Parametrization
</h3>
<ul>
	<li>
		<p>
            To simplify the implementation, all luminous powers will converted to luminous intensities () before being sent to the shader. The conversion is light dependent and is explained in the previous sections.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Type
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Directional, point, spot or area
				</p>
			</li>
			<li>
				<p>
                    Can be inferred from other parameters (e.g. a point light has a length, radius, inner angle and outer angle of 0).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Direction
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used for directional lights, spot lights, photometric point lights, and linear and tubular area lights (orientation)
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Color
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The color of emitted light, as a linear RGB color. Can be specified as an sRGB color or a color temperature in the tools
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Intensity
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The light's brightness. The unit depends on the type of light
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Falloff radius
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Maximum distance of influence
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Inner angle
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Angle of the inner cone for spot lights, in degrees
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Outer angle
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Angle of the outer cone for spot lights, in degrees
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Length
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Length of the area light, used to create linear or tubular lights
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Radius
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Radius of the area light, used to create spherical or tubular lights
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Photometric profile
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Texture representing a photometric light profile, works only for punctual lights
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Masked profile
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Boolean indicating whether the IES profile is used as a mask or not. When used as a mask, the light's brightness will be multiplied by the ratio between the user specified intensity and the integrated IES profile intensity. When not used as a mask, the user specified intensity is ignored but the IES multiplier is used instead
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Photometric multiplier
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Brightness multiplier for photometric lights (if IES as mask is turned off)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="color-temperature" >
    Color Temperature
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911113125.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            I got a little lost about this. See this 
			<a
				href="https://google.github.io/filament/Filament.html.html#mjx-eqn%3Akrystek" 
				class="internal-link" 
				target="_self" >
                session
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Convert from the XYZ space to linear RGB with a simple 3×3 matrix.
		</p>
	</li>
	<li>
		<p>
            Conversion using the inverse matrix for the sRGB color space:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250911113236.png" width="387" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The result of these operations is a linear RGB triplet in the sRGB color space.
		</p>
	</li>
	<li>
		<p>
            Since we care about the chromaticity of the results, we must apply a normalization step to avoid clamping values greater than 1.0 and distort resulting colors:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911113304.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            We must finally apply the sRGB opto-electronic conversion function (OECF) to obtain a displayable value (the value should remain linear if passed to the renderer for shading).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911113351.png" width="443" >
            .
		</p>
	</li>
</ul>
<h3
	id="directional-lights" >
    Directional Lights
</h3>
<ul>
	<li>
		<p>
            The main purpose of directional lights is to recreate important light sources for outdoor environment, i.e. the sun and/or the moon. While directional lights do not truly exist in the physical world, any light source sufficiently far from the light receptor can be assumed to be directional
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911110921.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111039.png" width="" >
            .
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Illuminance
					</strong>
                    &nbsp;is measured with the unit 
					<strong>
                        Lux
					</strong>
                    &nbsp;($lx$); $lx$ is the symbol, like $W$ for 
					<em>
                        Watts
					</em>
                    .
                    <br>
                    <img src="assets/image_20250911111413.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Dynamic directional lights are particularly cheap to evaluate at runtime.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 l = normalize(-lightDirection);
float NoL = clamp(dot(n, l), 0.0, 1.0);
// lightIntensity is the illuminance
// at perpendicular incidence in lux
float illuminance = lightIntensity * NoL;
vec3 luminance = BSDF(v, l) * illuminance;
</code></pre>
<h3
	id="punctual-lights" >
    Punctual Lights
</h3>
<ul>
	<li>
		<p>
            For punctual lights following the inverse square law, we use:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111706.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            Where $d$ is the distance from a point at the surface to the light.
		</p>
	</li>
</ul>
<h5
	id="point-lights" >
    Point Lights
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911111739.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111759.png" width="" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911111829.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Physically based punctual lights
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Note that the light intensity used in this piece of code is the luminous intensity in , converted from the luminous power CPU-side. This snippet is not optimized and some of the computations can be offloaded to the CPU (for instance the square of the light's inverse falloff radius, or the spot scale and angle).
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> float getSquareFalloffAttenuation(vec3 posToLight, float lightInvRadius) {
&nbsp;&nbsp;&nbsp;&nbsp; float distanceSquare = dot(posToLight, posToLight);
&nbsp;&nbsp;&nbsp;&nbsp; float factor = distanceSquare * lightInvRadius * lightInvRadius;
&nbsp;&nbsp;&nbsp;&nbsp; float smoothFactor = max(1.0 - factor * factor, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp; return (smoothFactor * smoothFactor) / max(distanceSquare, 1e-4);
 }
 
 float getSpotAngleAttenuation(vec3 l, vec3 lightDir,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float innerAngle, float outerAngle) {
&nbsp;&nbsp;&nbsp;&nbsp; // the scale and offset computations can be done CPU-side
&nbsp;&nbsp;&nbsp;&nbsp; float cosOuter = cos(outerAngle);
&nbsp;&nbsp;&nbsp;&nbsp; float spotScale = 1.0 / max(cos(innerAngle) - cosOuter, 1e-4)
&nbsp;&nbsp;&nbsp;&nbsp; float spotOffset = -cosOuter * spotScale
 
&nbsp;&nbsp;&nbsp;&nbsp; float cd = dot(normalize(-lightDir), l);
&nbsp;&nbsp;&nbsp;&nbsp; float attenuation = clamp(cd * spotScale + spotOffset, 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp; return attenuation * attenuation;
 }
 
 vec3 evaluatePunctualLight() {
&nbsp;&nbsp;&nbsp;&nbsp; vec3 l = normalize(posToLight);
&nbsp;&nbsp;&nbsp;&nbsp; float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 posToLight = lightPosition - worldPosition;
 
&nbsp;&nbsp;&nbsp;&nbsp; float attenuation;
&nbsp;&nbsp;&nbsp;&nbsp; attenuation&nbsp;&nbsp;= getSquareFalloffAttenuation(posToLight, lightInvRadius);
&nbsp;&nbsp;&nbsp;&nbsp; attenuation *= getSpotAngleAttenuation(l, lightDir, innerAngle, outerAngle);
 
&nbsp;&nbsp;&nbsp;&nbsp; vec3 luminance = (BSDF(v, l) * lightIntensity * attenuation * NoL) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp; return luminance;
 }
 
 
 vec3 l = normalize(-lightDirection);
 float NoL = clamp(dot(n, l), 0.0, 1.0);
 
 // lightIntensity is the illuminance
 // at perpendicular incidence in lux
 float illuminance = lightIntensity * NoL;
 vec3 luminance = BSDF(v, l) * illuminance;
</code></pre>
	</li>
</ul>
<h5
	id="spot-lights" >
    Spot Lights
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911111900.png" width="400" >
            .
		</p>
	</li>
	<li>
        <img src="assets/image_20250911111959.png" width="500" >

	</li>
	<li>
		<p>
            <img src="assets/image_20250911112027.png" width="400" >
            .
		</p>
	</li>
</ul>
<h3
	id="photometric-lights" >
    Photometric Lights
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250911112803.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911112748.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            Implementation:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float getPhotometricAttenuation(vec3 posToLight, vec3 lightDir) {
&nbsp;&nbsp;&nbsp;&nbsp;float cosTheta = dot(-posToLight, lightDir);
&nbsp;&nbsp;&nbsp;&nbsp;float angle = acos(cosTheta) * (1.0 / PI);
&nbsp;&nbsp;&nbsp;&nbsp;return texture2DLodEXT(lightProfileMap, vec2(angle, 0.0), 0.0).r;
}

vec3 evaluatePunctualLight() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 l = normalize(posToLight);
&nbsp;&nbsp;&nbsp;&nbsp;float NoL = clamp(dot(n, l), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 posToLight = lightPosition - worldPosition;

&nbsp;&nbsp;&nbsp;&nbsp;float attenuation;
&nbsp;&nbsp;&nbsp;&nbsp;attenuation&nbsp;&nbsp;= getSquareFalloffAttenuation(posToLight, lightInvRadius);
&nbsp;&nbsp;&nbsp;&nbsp;attenuation *= getSpotAngleAttenuation(l, lightDirection, innerAngle, outerAngle);
&nbsp;&nbsp;&nbsp;&nbsp;attenuation *= getPhotometricAttenuation(l, lightDirection);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This is the addition to the Punctual Light. It requires a lightProfileMap, etc.

&nbsp;&nbsp;&nbsp;&nbsp;float luminance = (BSDF(v, l) * lightIntensity * attenuation * NoL) * lightColor;
&nbsp;&nbsp;&nbsp;&nbsp;return luminance;
}
</code></pre>
<ul>
	<li>
		<p>
            The light intensity is computed CPU-side and depends on whether the photometric profile is used as a mask.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float multiplier;
// Photometric profile used as a mask
if (photometricLight.isMasked()) {
&nbsp;&nbsp;&nbsp;&nbsp;// The desired intensity is set by the artist
&nbsp;&nbsp;&nbsp;&nbsp;// The integrated intensity comes from a Monte-Carlo
&nbsp;&nbsp;&nbsp;&nbsp;// integration over the unit sphere around the luminaire
&nbsp;&nbsp;&nbsp;&nbsp;multiplier = photometricLight.getDesiredIntensity() /
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;photometricLight.getIntegratedIntensity();
} else {
&nbsp;&nbsp;&nbsp;&nbsp;// Multiplier provided for convenience, set to 1.0 by default
&nbsp;&nbsp;&nbsp;&nbsp;multiplier = photometricLight.getMultiplier();
}

// The max intensity in cd comes from the IES profile
float lightIntensity = photometricLight.getMaxIntensity() * multiplier;
</code></pre>
<h3
	id="mobile-adaptations" >
    Mobile Adaptations
</h3>
<h5
	id="pre-expose-lights" >
    Pre-Expose Lights
</h5>
<ul>
	<li>
		<p>
            &quot;How to store and handle the large range of values produced by the lighting code?&quot;
		</p>
	</li>
	<li>
		<p>
            Assuming computations performed at full precision in the shaders, we still want to be able to store the linear output of the lighting pass in a reasonably sized buffer (
            <code>RGB16F</code>
            &nbsp;or equivalent).
		</p>
	</li>
	<li>
		<p>
            The most obvious and easiest way to achieve this is to simply apply the camera exposure before writing out the result of the lighting pass.
		</p>
	</li>
	<li>
		<p>
            Pre-exposing lights allows the entire shading pipeline to use half precision floats.
		</p>
	</li>
	<li>
		<p>
            In practice we pre-expose the following lights:
		</p>
		<ul>
			<li>
				<p>
                    Punctual lights (point and spot):
				</p>
				<ul>
					<li>
						<p>
                            on the GPU
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Directional light:
				</p>
				<ul>
					<li>
						<p>
                            on the CPU
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    IBLs:
				</p>
				<ul>
					<li>
						<p>
                            on the CPU
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Material emissive:
				</p>
				<ul>
					<li>
						<p>
                            on the GPU
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This can be easily done with:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">fragColor = luminance * camera.exposure;
</code></pre>
<ul>
	<li>
		<p>
            But, this requires intermediate computations to be performed with single precision floats.
		</p>
	</li>
	<li>
		<p>
            We would instead prefer to perform all (or at least most) of the lighting work using half precision floats instead.
		</p>
	</li>
	<li>
		<p>
            Doing so can greatly improve performance and power usage, particularly on mobile devices. Half precision floats are however ill-suited for this kind of work as common illuminance and luminance values (for the sun for instance) can exceed their range.
		</p>
	</li>
	<li>
		<p>
            The solution is to simply pre-expose the lights themselves instead of the result of the lighting pass.
		</p>
	</li>
	<li>
		<p>
            This can be done efficiently on the 
			<strong>
                CPU
			</strong>
            &nbsp;if updating a light's constant buffer is cheap.
		</p>
	</li>
	<li>
		<p>
            This can also be done on the 
			<strong>
                GPU
			</strong>
            , like so:
		</p>
<pre><code class="language-glsl" data-lang="glsl"> // The inputs must be highp/single precision,
 // both for range (intensity) and precision (exposure)
 // The output is mediump/half precision
 float computePreExposedIntensity(highp float intensity, highp float exposure) {
&nbsp;&nbsp;&nbsp;&nbsp; return intensity * exposure;
 }
 
 Light getPointLight(uint index) {
&nbsp;&nbsp;&nbsp;&nbsp; Light light;
&nbsp;&nbsp;&nbsp;&nbsp; uint lightIndex = // fetch light index;
 
&nbsp;&nbsp;&nbsp;&nbsp; // the intensity must be highp/single precision
&nbsp;&nbsp;&nbsp;&nbsp; highp vec4 colorIntensity&nbsp;&nbsp;= lightsUniforms.lights[lightIndex][1];
 
&nbsp;&nbsp;&nbsp;&nbsp; // pre-expose the light
&nbsp;&nbsp;&nbsp;&nbsp; light.colorIntensity.w = computePreExposedIntensity(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colorIntensity.w, frameUniforms.exposure);
 
&nbsp;&nbsp;&nbsp;&nbsp; return light;
 }
</code></pre>
	</li>
</ul>
<h2
	id="shadows" >
    Shadows
</h2>
<h3
	id="shadow-map" >
    Shadow Map
</h3>
<ul>
	<li>
		<p>
            &quot;The scene is first rendered at the point of view of the light, and the result of that image is stored in a image called Shadow Map&quot;.
		</p>
		<ul>
			<li>
				<p>
                    It stores the depth map.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;If the light source doesn't 'see' something, then color the pixel dark&quot;.
		</p>
	</li>
	<li>
		<p>
            The final result is a pixelated shadow. To improve this, PCF (Percentage Closer Filtering) can be done.
		</p>
		<ul>
			<li>
				<p>
                    4x4 PCF is ok, but adding offsets helps in randomness and makes the effect more natural.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;You want the shadow area to be smallest as possible, while containing all the objects in the camera's view frustum&quot;.
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="http://the-witness.net/news/2010/03/graphics-tech-shadow-maps-part-1/" 
				class="external-link" 
				target="_blank" >
                Shadow Mapping Pt1 - The Witness
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="http://the-witness.net/news/2010/04/graphics-tech-shadow-maps-part-2-save-25-texture-memory-and-possibly-much-more/" 
				class="external-link" 
				target="_blank" >
                Shadow Mapping Pt2 - The Witness
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/" 
				class="external-link" 
				target="_blank" >
                Shadow Mapping Summary - The Witness
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/lights_and_shadows.html" 
				class="external-link" 
				target="_blank" >
                Shadow Mapping - Godot
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://github.com/TheRealMJP/Shadows" 
				class="external-link" 
				target="_blank" >
                Shadows - Samples
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The following techniques are implemented:
				</p>
				<ul>
					<li>
						<p>
                            Cascaded Shadow Maps
						</p>
					</li>
					<li>
						<p>
                            Stabilized Cascaded Shadow Maps
						</p>
					</li>
					<li>
						<p>
                            Automatic Cascade Fitting based on depth buffer analysis, as in 
							<a
								href="https://software.intel.com/en-us/articles/sample-distribution-shadow-maps" 
								class="external-link" 
								target="_blank" >
                                Sample Distribution Shadow Maps
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Various forms of Percentage Closer Filtering
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.2569&rep=rep1&type=pdf" 
								class="external-link" 
								target="_blank" >
                                Variance Shadow Maps
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://dl.acm.org/doi/pdf/10.5555/1375714.1375739" 
								class="external-link" 
								target="_blank" >
                                Exponential Variance Shadow Maps
							</a>
                            &nbsp;(EVSM).
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://momentsingraphics.de/I3D2015.html" 
								class="external-link" 
								target="_blank" >
                                Moment Shadow Maps
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://therealmjp.github.io/posts/shadow-maps/" 
						class="external-link" 
						target="_blank" >
                        A Sampling of Shadow Techniques
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://therealmjp.github.io/posts/shadow-sample-update/" 
						class="external-link" 
						target="_blank" >
                        Shadow Sample Update
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.alexandre-pestana.com/shadows-using-dithering-and-temporal-supersampling/" 
				class="external-link" 
				target="_blank" >
                Improved shadows using dithering and temporal supersampling
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="percentage-closer-filtering-pcf" >
    Percentage Closer Filtering (PCF)
</h5>
<ul>
	<li>
		<p>
            .
		</p>
	</li>
</ul>
<h3
	id="soft-shadows" >
    Soft-Shadows
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=NCptEJ1Uevg" 
				class="external-link" 
				target="_blank" >
                Soft Shadows - OGLDEV
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/" 
				class="external-link" 
				target="_blank" >
                Contact-hardening Soft Shadows Made Fast
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Usual for area lights.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917182959.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917183050.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            We will not do proper shading from this light source, but only compute what 
			<em>
                percentage of the area
			</em>
            &nbsp;of the light is covered.
		</p>
	</li>
</ul>
<h5
	id="raytracing" >
    Raytracing
</h5>
<ul>
	<li>
		<p>
            It's the proper way to solve it, but it's costly; the other techniques are approximations.
		</p>
	</li>
	<li>
		<p>
            Send rays from the point to the light source.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917183327.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            Approximate the percentage of the area that is visible to the light source, via the ratio of rays that hit the light vs rays that didn't hit the light.
		</p>
	</li>
</ul>
<h5
	id="percentage-closer-soft-shadows-pcss" >
    Percentage Closer Soft Shadows (PCSS)
</h5>
<ul>
	<li>
		<p>
            Presented at Siggraph in 2005.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917184109.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            The PCF sample varies through out the shadow, so the shadows closer to the object look sharp and far away from the object look smooth.
		</p>
	</li>
	<li>
		<p>
            Based on the distance to the object from the floor, you decide what filter you should use.
		</p>
		<ul>
			<li>
				<p>
                    How far the occluder is vs how far the point I want to compute is.
				</p>
			</li>
			<li>
				<p>
                    It also uses the occluder size.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250917184331.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Requires a 'Occluder Search' so a situation like below correctly indicates that 
			<em>
                should
			</em>
            &nbsp;be shadow in that point.
		</p>
		<ul>
			<li>
				<p>
                    The shadow in that points comes from the fact that the left side of the light source blocks the object.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250917184636.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            As PCSS requires Occluder Search and a PCF with large radius, depending on the situation, this method of soft shadows is not cheap.
		</p>
		<ul>
			<li>
				<p>
                    Is cheaper than tracing rays, tho.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917184619.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="other-techiniques" >
    ~Other Techiniques
</h5>
<ul>
	<li>
		<p>
            Doesn't work with Shadow Maps, as Shadow Maps just gives you a blunt occlusion information.
		</p>
	</li>
	<li>
		<p>
            Tries to approximate the PCF / PCSS, for soft-shadows instead of computing it.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Variance Shadow Maps (VSM)
			</strong>
            .
		</p>
		<ul>
			<li>
				<ol>
					<li>
					</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Convolution Shadow Maps (CSM)
			</strong>
            .
		</p>
		<ul>
			<li>
				<ol>
					<li>
					</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Exponential Shadow Maps (ESM)
			</strong>
            .
		</p>
		<ul>
			<li>
				<ol>
					<li>
					</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917185335.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            There are improvements to these methods, trying to solve the problems of these approximations.
		</p>
	</li>
</ul>
<h5
	id="radiance-cascades" >
    Radiance Cascades
</h5>
<ul>
	<li>
		<p>
            I saw a video demonstrating the usage of radiance cascades for soft-shadows.
		</p>
	</li>
</ul>
<h2
	id="skybox-skydome" >
    Skybox / Skydome
</h2>
<ul>
	<li>
		<p>
            Steps to reproduce the Skybox from the Vulkan sample HDR:
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Load KTX file.
				</p>
				<ul>
					<li>
						<p>
                            See 
                            <code>api_vulkan_sample.cpp-&gt;load_texture_cubemap (1202)</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    In: 
                    <code>in_pos</code>
                    &nbsp;(vec3).
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Desc Sets: Camera View and Camera Proj in the shader
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    out: 
                    <code>out_uvw</code>
                    &nbsp;(vec3) and 
                    <code>out_pos</code>
                    &nbsp;(vec3).
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> textures.envmap = load_texture_cubemap("textures/uffizi_rgba16f_cube.ktx", vkb::sg::Image::Color);
 
 vkb::initializers::write_descriptor_set(descriptor_sets.object, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 0, &matrix_buffer_descriptor),
 vkb::initializers::write_descriptor_set(descriptor_sets.object, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1, &environment_image_descriptor),
</code></pre>
<pre><code class="language-glsl" data-lang="glsl"> // Vertex
 layout (location = 0) in vec3 inPos;
 layout (binding = 0) uniform UBO {
&nbsp;&nbsp;&nbsp;&nbsp; mat4 projection;           // camera.matrices.perspective;
&nbsp;&nbsp;&nbsp;&nbsp; mat4 skybox_modelview;     // camera.view
 } ubo;
 layout (location = 0) out vec3 outUVW;
 layout (location = 1) out vec3 outPos;

 outUVW = inPos;
 outPos = vec3(mat3(ubo.skybox_modelview) * inPos);
 gl_Position = vec4(ubo.projection * vec4(outPos, 1.0));
 
 // Frag
 layout (binding = 1) uniform samplerCube samplerEnvMap;
 layout (location = 0) in vec3 inUVW;
 layout (location = 0) out vec4 outColor0;
 
 vec3 normal = normalize(inUVW);
 color = texture(samplerEnvMap, normal);
 // Color with manual exposure into attachment 0
 outColor0.rgb = vec3(1.0) - exp(-color.rgb * ubo.exposure);
</code></pre>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=8sVvxeKI9Pk" 
				class="external-link" 
				target="_blank" >
                Skybox in OpenGL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>See 
			<em>
                UI
			</em>
            &nbsp;and 
			<em>
                Skybox
			</em>
            &nbsp;from 
			<strong>
                Kohi Engine
			</strong>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Yea.. The engine is an insane mess.
				</p>
			</li>
			<li>
				<p>
                    The shaders are confusing and use the camera matrix and model matrix to draw UI, wtf.
				</p>
			</li>
			<li>
				<p>
                    It's impossible to find out how the graphics pipeline is created. It's an infinite wormhole.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="transparency" >
    Transparency
</h2>
<h3
	id="alpha" >
    Alpha
</h3>
<pre><code class="language-glsl" data-lang="glsl">// baseColor has already been premultiplied
vec4 shadeSurface(vec4 baseColor) {
&nbsp;&nbsp;&nbsp;&nbsp;float alpha = baseColor.a;

&nbsp;&nbsp;&nbsp;&nbsp;vec3 diffuseColor = evaluateDiffuseLighting();
&nbsp;&nbsp;&nbsp;&nbsp;vec3 specularColor = evaluateSpecularLighting();&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;return vec4(diffuseColor + specularColor, alpha);
}
</code></pre>
<h5
	id="alpha-blend" >
    Alpha Blend
</h5>
<ul>
	<li>
		<p>
            With Z-Buffer Rasterization, the order matters.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919112453.png" width="350" >
            .
		</p>
		<ul>
			<li>
				<p>
                    If renderer back to front, it works fine.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919112636.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            With A-Buffer Rasterization, the objects get sorted based on the alpha, so we don't have this problem.
		</p>
		<ul>
			<li>
				<p>
                    GPUs use Z-Buffer, so we are stuck with it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="alpha-testing" >
    Alpha Testing
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250919114210.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            If the alpha is below a certain threshold, discard.
		</p>
	</li>
	<li>
		<p>
            Alpha Testing with mipmapping can have problems:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250919114716.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919114804.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    The alpha ends up converging to a value below the threshold
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919114848.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            At far away, the character loses its beard.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="hashed-alpha-testing" >
    Hashed Alpha Testing
</h5>
<ul>
	<li>
		<ol>
			<li>
			</li>
		</ol>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919114942.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            Test randomly.
		</p>
	</li>
	<li>
		<p>
            The discard is made in software, not in hardware.
		</p>
	</li>
	<li>
		<p>
            It's really noise, as it looks like dithering.
		</p>
	</li>
</ul>
<h5
	id="alpha-distribution" >
    Alpha Distribution
</h5>
<ul>
	<li>
		<ol>
			<li>
			</li>
		</ol>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919115145.png" width="450" >
            .
		</p>
	</li>
	<li>
        <img src="assets/image_20250919115306.png" width="240" >
&nbsp;&nbsp;- Alpha Distribution + Alpha to Coverage.

	</li>
	<li>
		<p>
            Uses dithering first.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919115220.png" width="500" >
            .
		</p>
	</li>
</ul>
<h5
	id="alpha-to-coverage" >
    Alpha to Coverage
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250919114419.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            You get smoother pixels than with Alpha Testing.
		</p>
	</li>
	<li>
		<p>
            It adds different values of alpha, instead of 0 or 1.
		</p>
		<ul>
			<li>
				<p>
                    With 4x, you can get 4 different values of alpha: 0.0, 0.25, 0.5, 0.75.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919114509.png" width="" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Alpha to Coverage (left), Alpha Testing (right).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="order-independent-transparency" >
    Order-Independent Transparency
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/3d_rendering_limitations.html#transparency-sorting" 
				class="external-link" 
				target="_blank" >
                Godot 4 - Render Limitations
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Godot doesn't do OIT.
				</p>
			</li>
			<li>
				<p>
                    The article shows how to deal with it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/standard_material_3d.html#transparency" 
				class="external-link" 
				target="_blank" >
                Godot 4 - Transparency and limitations
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="depth-peeling" >
    Depth Peeling
</h5>
<ul>
	<li>
        <img src="assets/image_20250919112921.png" width="400" >

	</li>
	<li>
		<p>
            Layer 1:
		</p>
		<ul>
			<li>
				<p>
                    Render as full opaque.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Layer 2:
		</p>
		<ul>
			<li>
				<p>
                    Use the depth buffer from Layer 1 to perform additional depth test while rendering Layer 2.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Etc, etc.
		</p>
	</li>
	<li>
		<p>
            The amount of layers depend on the object.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919113300.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            For every layer, you have to render the scene again; 4 layers = 4 times the cost.
		</p>
	</li>
</ul>
<h5
	id="quotsoftware-a-bufferquot" >
    &quot;Software A-Buffer&quot;
</h5>
<ul>
	<li>
		<p>
            To avoid the costs of Depth Peeling, we soft-implement A-Buffer.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919113439.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            &quot;Order-Independent Transparency in OpenGL 4.X - Nvidia&quot;.
		</p>
	</li>
</ul>
<h3
	id="refraction" >
    Refraction
</h3>
<ul>
	<li>
		<p>
            You need to know the light that is coming from behind the surface.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919110848.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            The front and back need to be considered.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919111138.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The rays refract in and out.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919111240.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919111345.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            A normal render gives you the depth and normals of the front.
		</p>
	</li>
	<li>
		<p>
            We render the back as a pre-pass, to get the depth and normals of the back.
		</p>
	</li>
	<li>
		<p>
            The difference between the depth value from the back and the front will give you the thickness of the object.
		</p>
	</li>
	<li>
		<p>
            This is an approximation for how long the ray will travel inside that object.
		</p>
	</li>
	<li>
		<p>
            &quot;If I were to travel this much, where will I end up in the Back texture?&quot;.
		</p>
	</li>
	<li>
		<p>
            This gives you the direction of the exiting ray, so you can sample an environment map.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919111835.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            To see other objects, besides the environment map, the objects need to be rendered first, etc; a process similar to parallax mapping is used to solve this.
		</p>
	</li>
	<li>
		<p>
            Super fast, cool.
		</p>
	</li>
</ul>
<h2
	id="global-illumination-indirect-lighting" >
    Global Illumination / Indirect Lighting
</h2>
<ul>
	<li>
		<p>
            A broad term that refers to any algorithm or technique that simulates how light bounces around a scene, not just directly from light sources but also after interactions with surfaces.
		</p>
	</li>
	<li>
		<p>
            It encompasses both 
			<strong>
                direct lighting
			</strong>
            &nbsp;(light coming straight from a source) and 
			<strong>
                indirect lighting
			</strong>
            &nbsp;(light that has bounced one or more times).
		</p>
	</li>
</ul>
<h3
	id="terms" >
    Terms
</h3>
<h5
	id="irradiance" >
    Irradiance
</h5>
<ul>
	<li>
		<p>
			<strong>
                Irradiance (scalar)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    At a surface point, the integral of incoming radiance over the hemisphere (units: W/m²).
				</p>
			</li>
			<li>
				<p>
                    Often the quantity of interest for diffuse shading.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Irradiance field
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    An Irradiance Field is the continuous phenomenon.
				</p>
			</li>
			<li>
				<p>
                    A function that maps spatial position (and sometimes orientation) to irradiance.
				</p>
			</li>
			<li>
				<p>
                    In papers this term can mean the true continuous field, or a specific continuous representation (e.g., a voxel grid, analytic basis, or neural field).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Irradiance probes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    An Irradiance Probe is a discrete measurement of that phenomenon.
				</p>
			</li>
			<li>
				<p>
                    A set of sampled measurements placed at discrete spatial locations.
				</p>
			</li>
			<li>
				<p>
                    Each probe stores an irradiance representation (examples: spherical-harmonic coefficients, a small cubemap, or directional coefficients).
				</p>
			</li>
			<li>
				<p>
                    During rendering the scene samples/interpolates between probes to approximate the irradiance at arbitrary points.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="techniques" >
    Techniques
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html" 
				class="external-link" 
				target="_blank" >
                Hammersley Points on the Hemisphere
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
            <img src="assets/image_2025-09-19_20-52-54.png" width="400" >
		</p>
		<ul>
			<li>
				<p>
                    Appeared in Surfels.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="parameterizations-sampling-layouts-for-the-sphere" >
    Parameterizations / sampling layouts for the sphere
</h4>
<h5
	id="octahedral-maps" >
    Octahedral Maps
</h5>
<ul>
	<li>
		<p>
            A bijective mapping (with a fold) that encodes a unit 3D direction 
            <code>n = (x,y,z)</code>
            &nbsp;into 2D texture coordinates 
            <code>u,v ∈ [0,1]</code>
            .
		</p>
	</li>
	<li>
		<p>
            Designed to pack the sphere into a single square texture with less angular distortion than latitude–longitude and usually fewer wasted texels than cube maps.
		</p>
	</li>
	<li>
		<p>
            Commonly used to store normals, unit vectors (reflection vectors, tangent-space directions), or per-direction scalar/vector fields (e.g., an environment map sampled per texel).
		</p>
	</li>
</ul>
<h5
	id="cube-maps" >
    Cube Maps
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html#annex/importancesamplingfortheibl" 
				class="internal-link" 
				target="_self" >
                Filament Importance Sampling for the IBL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Precomputing $L_{DFG}$
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The term $L_{DFG}$ is only dependent on $n.v$. Below, the normal is arbitrarily set to $n = [0, 0, 1]$ and $v$ is chosen to satisfy $n.v$. The vector $h_i$ is the $D_{GGX}(\alpha)$ important direction sample $i$.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> float GDFG(float NoV, float NoL, float a) {
&nbsp;&nbsp;&nbsp;&nbsp; float a2 = a * a;
&nbsp;&nbsp;&nbsp;&nbsp; float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
&nbsp;&nbsp;&nbsp;&nbsp; float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
&nbsp;&nbsp;&nbsp;&nbsp; return (2 * NoL) / (GGXV + GGXL);
 }
 
 float2 DFG(float NoV, float a) {
&nbsp;&nbsp;&nbsp;&nbsp; float3 V;
&nbsp;&nbsp;&nbsp;&nbsp; V.x = sqrt(1.0f - NoV*NoV);
&nbsp;&nbsp;&nbsp;&nbsp; V.y = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp; V.z = NoV;
 
&nbsp;&nbsp;&nbsp;&nbsp; float2 r = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp; for (uint i = 0; i &lt; sampleCount; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float2 Xi = hammersley(i, sampleCount);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float3 H = importanceSampleGGX(Xi, a, N);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float3 L = 2.0f * dot(V, H) * H - V;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float VoH = saturate(dot(V, H));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float NoL = saturate(L.z);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float NoH = saturate(H.z);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NoL &gt; 0.0f) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float G = GDFG(NoV, NoL, a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Gv = G * VoH / NoH;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Fc = pow(1 - VoH, 5.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x += Gv * (1 - Fc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.y += Gv * Fc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; return r * (1.0f / sampleCount);
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Filament Engine coordinates system
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922082120.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    To simplify the rendering of reflections, IBL cubemaps are stored mirrored on the X axis. This is the default behaviour of the 
                    <code>cmgen</code>
                    &nbsp;tool. This means that an IBL cubemap used as environment background needs to be mirrored again at runtime. An easy way to achieve this for skyboxes is to use textured back faces. Filament does this by default.
				</p>
			</li>
			<li>
				<p>
                    To convert equirectangular environment maps to horizontal/vertical cross cubemaps we position the +Z face in the center of the source rectilinear environment map.
				</p>
			</li>
			<li>
				<p>
                    When specifying a skybox or an IBL in Filament, the specified cubemap is oriented such that its -Z face points towards the +Z axis of the world (this is because filament assumes mirrored cubemaps). However, because environments and skyboxes are expected to be pre-mirrored, their -Z (back) face points towards the world's -Z axis as expected (and the camera looks toward that direction by default).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="directional-data-represent-or-approximate-functions-on-the-sphere-bases-or-parametric-lobes" >
    Directional Data (Represent or approximate functions on the sphere (bases or parametric lobes))
</h4>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-1-a-brief-and-incomplete-history-of-baked-lighting-representations/" 
				class="external-link" 
				target="_blank" >
                SG Series Part 1: A Brief (and Incomplete) History of Baked Lighting Representations
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Sounds very interesting and relevant.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h6
	id="when-an-sh-sg-wavelet-can-replace-a-cubemap-oct-map-and-when-it-cannot" >
    When an SH/SG/wavelet can “replace” a cubemap/oct map — and when it cannot
</h6>
<ul>
	<li>
		<p>
			<strong>
                Replace (acceptable / typical):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Low-frequency lighting (diffuse irradiance): SH (low-order) is commonly used instead of sampling a full cubemap at runtime because SH compactly encodes low-frequency content and allows analytic convolution with Lambertian cosine. That avoids per-pixel cubemap lookups for diffuse IBL.
				</p>
			</li>
			<li>
				<p>
                    Compact specular approximation: Representing an environment by a small number of SG lobes can replace a cubemap for fast approximate glossy shading or importance sampling when the environment is lobe-like.
				</p>
			</li>
			<li>
				<p>
                    Compression / streaming: Wavelets (or hierarchical transforms) can replace a naive cubemap storage by providing a compressed, multiresolution representation that is progressively refinable.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cannot fully replace (or will be lossy / expensive to use):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Detailed, high-frequency reflections (sharp mirror-like): Full-resolution cubemap/oct textures or prefiltered mipmap chains (PMREM) are the usual approach. SH needs very high band count (many coefficients) to represent sharp features, and SG requires many lobes to approximate complex high-frequency structure — both become expensive or inaccurate.
				</p>
			</li>
			<li>
				<p>
                    Arbitrary sampling and filtering: A texture parameterization (cubemap/oct) is a direct sampling representation and is straightforward to sample, filter (with caveats) and prefilter with hardware. Basis expansions require projection and reconstruction steps before sampling in the standard pipeline.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="haar-wavelets" >
    Haar Wavelets
</h5>
<ul>
	<li>
		<p>
            A family of localized, multiresolution basis functions (Haar is the simplest wavelet) that represent signals with coarse-to-fine detail. Haar wavelets are piecewise-constant, have compact support, and provide spatial locality and hierarchical decomposition.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Typical form (1D/2D idea):
			</strong>
            &nbsp;scaling functions and wavelet functions that split signal into averages + differences at successive scales. On the sphere one can build analogous spherical wavelet bases (e.g., via hierarchical partitioning of the sphere).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Properties:
			</strong>
            &nbsp;spatially localized, multi-resolution (supports progressive refinement), good at representing localized/high-frequency features and discontinuities, many coefficients are zero or small for sparse signals, not globally smooth (Haar is discontinuous). Wavelet transforms can be fast (O(n)). Rotation is awkward for bases tied to a fixed partitioning.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Common graphics uses:
			</strong>
            &nbsp;compression and multi-resolution representation of environment maps or textures, adaptive shading, fast hierarchical importance sampling / level-of-detail, GPU-friendly encodings, and sparse approximations of signals with local sharp features.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Trade-offs:
			</strong>
            &nbsp;better for localized/high-frequency structure and compression; Haar specifically is low-order (blocky) unless higher-order wavelets are used; rotation and analytic convolution are not generally simple in the wavelet domain without additional structure.
		</p>
	</li>
</ul>
<h5
	id="spherical-gaussians-sg" >
    Spherical Gaussians (SG)
</h5>
<ul>
	<li>
		<p>
			<strong>
                What it is (short):
			</strong>
            &nbsp;parametric, localized “lobe” functions on the sphere that approximate a single-peaked angular distribution (an axis-aligned Gaussian-like lobe).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Typical form (common form):
			</strong>
            &nbsp;$G(\omega;\mu,\kappa)=\exp\big(\kappa(\mu\cdot\omega-1)\big)$, where $\mu$ is the lobe axis and $\kappa$ (or similar) controls concentration (larger $\kappa$ = narrower lobe). (Different papers use slightly different normalization/scales.)
		</p>
	</li>
	<li>
		<p>
			<strong>
                Properties:
			</strong>
            &nbsp;strongly localized, easily rotated by changing $\mu$, analytic approximations exist for products and convolutions with some BRDF lobes (useful approximations), compact parametric representation (axis + sharpness), cheap evaluation of a single lobe. Not an orthogonal basis. Multiple SGs can be summed to approximate complex lobes.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Common graphics uses:
			</strong>
            &nbsp;representing specular lobes and glossy reflections, analytic or semi-analytic shading and convolution approximations, importance sampling, fitting environment lighting with a sum of lobes for real-time shading. SGs are also used in prefiltered environment maps where single-lobe behavior is important.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Trade-offs:
			</strong>
            &nbsp;simple and efficient for localized lobes; approximating arbitrary functions requires many SGs; not linear-orthonormal (so projection/coefficients don’t have the same algebraic niceties as SH).
		</p>
	</li>
</ul>
<h5
	id="spherical-harmonics-sh" >
    Spherical Harmonics (SH)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf" 
				class="external-link" 
				target="_blank" >
                An Efficient Representation for Irradiance Environment Maps - Ramamoorthi &amp; Hanrahan - Siggraph 2001
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://cseweb.ucsd.edu/~ravir/papers/freqenv/freqenv.pdf" 
				class="external-link" 
				target="_blank" >
                Frequency Space Environment Map Rendering - Ramamoorthi &amp; Hanrahan- Siggraph 2002
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Spherical harmonic reflection map (SHRM)&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://pdfs.semanticscholar.org/566f/c019459435ac3ad25d9a4941d5da02d7ba59.pdf" 
				class="external-link" 
				target="_blank" >
                Lighting and Material of Halo 3 - Siggraph 2008
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://media.gdcvault.com/gdc08/slides/S6220i1.pdf" 
				class="external-link" 
				target="_blank" >
                Lighting and Material of Halo 3 - Siggraph 2008
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Bungie pioneered baked SH lighting in a shipped game with Halo 3 (Xbox 360, 2007). Halo 3’s engine precomputed “light probe” textures: each texel stored multiple SH coefficients (the slides cite 9–16 floats per texel) representing the incoming diffuse light at that point. These SH lightmaps were then sampled in shaders, so that static geometry received baked global illumination, and dynamic models could be lit by dot-producting their SH transfer vectors against the light-probe SH. (Siggraph 2008 “Lighting and Materials of Halo 3” notes SH lightmaps as a natural extension of lightmaps.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html#annex/sphericalharmonics" 
				class="internal-link" 
				target="_self" >
                Filament - Spherical Harmonics
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    C++ implementation to compute a non-normalized SH basis:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> static inline size_t SHindex(ssize_t m, size_t l) {
&nbsp;&nbsp;&nbsp;&nbsp; return l * (l + 1) + m;
 }
 
 void computeShBasis(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* const SHb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t numBands,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const vec3& s)
 {
&nbsp;&nbsp;&nbsp;&nbsp; // handle m=0 separately, since it produces only one coefficient
&nbsp;&nbsp;&nbsp;&nbsp; double Pml_2 = 0;
&nbsp;&nbsp;&nbsp;&nbsp; double Pml_1 = 1;
&nbsp;&nbsp;&nbsp;&nbsp; SHb[0] =&nbsp;&nbsp;Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp; for (ssize_t l = 1; l &lt; numBands; l++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Pml = ((2 * l - 1) * Pml_1 * s.z - (l - 1) * Pml_2) / l;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pml_2 = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pml_1 = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex(0, l)] = Pml;
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; double Pmm = 1;
&nbsp;&nbsp;&nbsp;&nbsp; for (ssize_t m = 1; m &lt; numBands ; m++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pmm = (1 - 2 * m) * Pmm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Pml_2 = Pmm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Pml_1 = (2 * m + 1)*Pmm*s.z;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // l == m
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex(-m, m)] = Pml_2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex( m, m)] = Pml_2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m + 1 &lt; numBands) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // l == m+1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex(-m, m + 1)] = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex( m, m + 1)] = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ssize_t l = m + 2; l &lt; numBands; l++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Pml = ((2 * l - 1) * Pml_1 * s.z - (l + m - 1) * Pml_2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / (l - m);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pml_2 = Pml_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pml_1 = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex(-m, l)] = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex( m, l)] = Pml;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; double Cm = s.x;
&nbsp;&nbsp;&nbsp;&nbsp; double Sm = s.y;
&nbsp;&nbsp;&nbsp;&nbsp; for (ssize_t m = 1; m &lt;= numBands ; m++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ssize_t l = m; l &lt; numBands; l++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex(-m, l)] *= Sm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHb[SHindex( m, l)] *= Cm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Cm1 = Cm * s.x - Sm * s.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Sm1 = Sm * s.x + Cm * s.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cm = Cm1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sm = Sm1;
&nbsp;&nbsp;&nbsp;&nbsp; }
 }
</code></pre>
		<ul>
			<li>
				<p>
                    C++ code to compute $\hat{C}_l$:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> static double factorial(size_t n, size_t d = 1);
 
 // &lt; cos(theta) &gt; SH coefficients pre-multiplied by 1 / K(0,l)
 double computeTruncatedCosSh(size_t l) {
&nbsp;&nbsp;&nbsp;&nbsp; if (l == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return M_PI;
&nbsp;&nbsp;&nbsp;&nbsp; } else if (l == 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2 * M_PI / 3;
&nbsp;&nbsp;&nbsp;&nbsp; } else if (l & 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; const size_t l_2 = l / 2;
&nbsp;&nbsp;&nbsp;&nbsp; double A0 = ((l_2 & 1) ? 1.0 : -1.0) / ((l + 2) * (l - 1));
&nbsp;&nbsp;&nbsp;&nbsp; double A1 = factorial(l, l_2) / (factorial(l_2) * (1 &lt;&lt; l));
&nbsp;&nbsp;&nbsp;&nbsp; return 2 * M_PI * A0 * A1;
 }
 
 // returns n! / d!
 double factorial(size_t n, size_t d ) {
&nbsp;&nbsp;&nbsp;&nbsp;d = std::max(size_t(1), d);
&nbsp;&nbsp;&nbsp;&nbsp;n = std::max(size_t(1), n);
&nbsp;&nbsp;&nbsp;&nbsp;double r = 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;if (n == d) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// intentionally left blank
&nbsp;&nbsp;&nbsp;&nbsp;} else if (n &gt; d) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( ; n&gt;d ; n--) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r *= n;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( ; d&gt;n ; d--) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r *= d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = 1.0 / r;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return r;
 }
</code></pre>
	</li>
	<li>
		<p>
            Basis functions $Y_{\ell}^m(\theta,\phi)$ indexed by degree $\ell\ge 0$ and order $-\ell\le m\le\ell$. A function $f(\omega)$ on the sphere is expanded as $f(\omega)=\sum_{\ell=0}^{L}\sum_{m=-\ell}^{\ell} c_{\ell m} Y_{\ell}^m(\omega)$.
		</p>
	</li>
	<li>
		<p>
            Are an orthonormal basis for functions on the sphere. In real-time lighting they are used to compactly represent low-frequency angular functions (environment illumination, visibility, convolution kernels).
		</p>
	</li>
	<li>
		<p>
            Irradiance probes commonly store SH coefficients so the renderer can approximate diffuse lighting quickly.
		</p>
	</li>
	<li>
		<p>
			<em>
                Why is it useful for Irradiance / Probes
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Compression
					</strong>
                    : low-frequency lighting (diffuse environment lighting, soft shadows) is well-approximated by a small number of SH bands (e.g. 9 coefficients).
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Linear projection
					</strong>
                    : you can project an environment (cubemap, sampling) onto SH. Once you have certain coefficients​, you store those in a probe instead of storing a full cubemap.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Fast evaluation
					</strong>
                    : to evaluate the approximated radiance or irradiance at some direction $\omega$, evaluate the SH basis at $\omega$ and form the dot product with coefficients: $f(\omega)=\sum a_{l}^{m}Y_{l}^{m}(\omega)$. That dot product is inexpensive for small L.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Convolution property (why diffuse works well)
					</strong>
                    : for Lambertian reflection you need the cosine-weighted integral of incoming radiance. The cosine kernel is low-frequency and its SH representation has non-zero weight only on low bands. Convolving $L_i$​ with the cosine kernel reduces to scaling SH bands by precomputed factors. Practically, this means you can compute irradiance from the projected SH coefficients cheaply without re-sampling the entire environment at render time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=dDQTHFeJf5M" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    A demonstration of spherical harmonics used to construct the surface of the earth at increasing angular resolution.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/shorts/t06UTZAxCgw" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Demo - Earth Magnetic Field
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=Ziz7t1HHwBw" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Visualization
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    We describe the possible fundamental vibrations on a sphere in three dimensions by counting, mirroring and rotating nodal lines.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/shorts/IlvTHPClwHI" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Idk, wtf.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=M--6_0F62pQ" 
				class="external-link" 
				target="_blank" >
                Spherical Harmonics in Quantum Mechanics
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The video is cool.
				</p>
			</li>
			<li>
				<p>
                    The idea is to take this 1D visualization for the energy states of the electron:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919134538.png" width="350" >
                    &nbsp;
                    <img src="assets/image_20250919134703.png" width="200" >
				</p>
			</li>
			<li>
				<p>
                    And arrive at this 3D visualization:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919134409.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    All the visual characteristics of the visualization come from the ways in which the nodes can be represented.
				</p>
			</li>
			<li>
				<p>
                    Apparently nodes can be radial or angular. The angular representations appear when considering that the node can be a plane.
				</p>
			</li>
			<li>
				<p>
                    It is these nodes represented as a plane that make the shapes more interesting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The &quot;overlap&quot; I mentioned is not about spatial overlap. It's about mathematical independence.
		</p>
	</li>
	<li>
		<p>
            Spherical harmonics are precisely the spherical analogue of the Fourier transform.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Fourier Series (for a function on a circle):
			</strong>
            &nbsp;Any function on a 1D circle (like a sound wave over time) can be broken down into a sum of simple, orthogonal basis functions: sines and cosines of different frequencies (
            <code>sin(nθ)</code>
            , 
            <code>cos(nθ)</code>
            ).
		</p>
		<ul>
			<li>
				<p>
                    The low-frequency sines/cosines capture the broad, smooth shape.
				</p>
			</li>
			<li>
				<p>
                    The high-frequency ones capture the sharp details and edges.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Spherical Harmonics (for a function on a sphere):
			</strong>
            &nbsp;Any function on a 2D sphere (like an environment map) can be broken down into a sum of simple, orthogonal basis functions: the spherical harmonics (
            <code>Y_lm(θ, φ)</code>
            ).
		</p>
		<ul>
			<li>
				<p>
                    The low-
                    <code>l</code>
                    &nbsp;(low-frequency) SHs capture the broad, smooth lighting (the average color, the dominant light direction).
				</p>
			</li>
			<li>
				<p>
                    The high-
                    <code>l</code>
                    &nbsp;(high-frequency) SHs capture the sharp details and edges (sharp reflections, tiny light sources).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We are not projecting a 3D scene onto a sphere.
		</p>
		<ul>
			<li>
				<p>
                    This is called environment map capture (e.g., taking a 360° photo). That gives us a function 
                    <code>f(θ, φ)</code>
                    &nbsp;that is defined on the surface of a sphere.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The Spherical Harmonic transform is the next step. We are taking that already-spherical function 
            <code>f(θ, φ)</code>
            &nbsp;and projecting it onto the spherical harmonic basis functions.
		</p>
	</li>
	<li>
		<p>
            The word &quot;projection&quot; here is used in the linear algebra sense, just like projecting a vector onto a set of basis axes.
		</p>
	</li>
	<li>
		<p>
            Imagine your environment map 
            <code>f(ω)</code>
            &nbsp;is a vector in a giant, infinite-dimensional space.
		</p>
	</li>
	<li>
		<p>
            The spherical harmonics 
            <code>Ylm(ω)</code>
            &nbsp;form a complete set of orthonormal basis vectors for that space.
		</p>
	</li>
	<li>
		<p>
            Projecting 
            <code>f</code>
            &nbsp;onto a specific basis vector 
            <code>Ylm</code>
            &nbsp;is how we find the coefficient 
            <code>clm</code>
            &nbsp;for that function. The formula for this projection is the inner product:&nbsp;&nbsp;
            <code>c_lm = ∫ f(ω) * Y_lm(ω) dω</code>
            .
		</p>
	</li>
	<li>
		<p>
            This is identical to how in 3D space, you find the 
            <code>x</code>
            -component of a vector 
            <code>V</code>
            &nbsp;by projecting it onto the unitX basis vector: 
            <code>V_x = V • unitX</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                &quot;Orthonormalization&quot;
			</strong>
            &nbsp;means we have ensured two things for our basis functions 
            <code>Y_lm</code>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Orthogonal:
					</strong>
                    &nbsp;
                    <code>∫ Y_lm(ω) * Y_l'm'(ω) dω = 0</code>
                    &nbsp;if 
                    <code>(l, m) ≠ (l', m')</code>
                    &nbsp;(they are independent).
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Normalized:
					</strong>
                    &nbsp;
                    <code>∫ Y_lm(ω) * Y_lm(ω) dω = 1</code>
                    &nbsp;(each one has a &quot;unit length&quot;).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This orthonormality is what makes the math so clean and the coefficients independent.
		</p>
	</li>
	<li>
		<p>
            In Quantum Mechanics, the spherical harmonics 
            <code>Y_lm</code>
            &nbsp;are famous because they are the 
			<strong>
                angular solutions to the Laplace equation in spherical coordinates.
			</strong>
		</p>
	</li>
	<li>
		<p>
            This describes the probability distribution of an electron around a hydrogen atom (its orbital). The shapes of the s, p, d, f orbitals are visualizations of the 
            <code>Y_lm</code>
            &nbsp;functions!
		</p>
		<ul>
			<li>
				<p>
                    <code>Y00</code>
                    &nbsp;is the s-orbital (spherical).
				</p>
			</li>
			<li>
				<p>
                    <code>Y1m</code>
                    &nbsp;are the three p-orbitals (dumbbell shaped along x, y, z).
				</p>
			</li>
			<li>
				<p>
                    <code>Y2m</code>
                    &nbsp;are the five d-orbitals (cloverleaf shapes).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                In Computer Graphics:
			</strong>
            &nbsp;We are using the exact same mathematical functions to describe the distribution of light energy around a point. The &quot;orbital&quot; is now the &quot;irradiance environment.&quot;
		</p>
	</li>
	<li>
		<p>
            The key difference is one of interpretation:
		</p>
	</li>
	<li>
		<p>
            In Quantum Mechanics, you're solving for a wavefunction.
		</p>
	</li>
	<li>
		<p>
            In Computer Graphics, you're using the SH basis to compactly represent a function (light) defined on a sphere.
		</p>
	</li>
	<li>
		<p>
			<strong>
                The process for computer graphics
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    For a render engineer, the process is this:
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<strong>
                        Capture/Define:
					</strong>
                    &nbsp;Start with an environment map 
                    <code>f(ω)</code>
                    . This is your function on the sphere.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Project (Precompute/Integrate):
					</strong>
                    &nbsp;For each SH basis function 
                    <code>Y_lm</code>
                    &nbsp;you care about (e.g., the first 9), compute the coefficient 
                    <code>c_lm</code>
                    &nbsp;by integrating the product 
                    <code>f(ω) * Y_lm(ω)</code>
                    &nbsp;over the entire sphere. This is the &quot;transformation&quot; into the SH frequency space.&nbsp;&nbsp;
                    <code>c_lm = ∫ f(ω) * Y_lm(ω) dω</code>
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Reconstruct (Runtime):
					</strong>
                    &nbsp;To get the approximate value of the environment at any direction 
                    <code>ω</code>
                    , you evaluate the sum:&nbsp;&nbsp;
                    <code>f(ω) ≈ Σ c_lm * Y_lm(ω)</code>
                    &nbsp;for 
                    <code>l=0...N-1</code>
                    .
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
            The reason this is a &quot;convolution&quot; is that the rendering equation often includes a cosine term (
            <code>n • ω</code>
            ). The magic is that projecting this cosine lobe into SH space results in analytic attenuation factors (
            <code>A_l</code>
            ) that you can just multiply by your 
            <code>c_lm</code>
            &nbsp;coefficients 
			<em>
                before
			</em>
            &nbsp;the reconstruction step. This turns a complex integral into a simple dot product of two SH vectors (lighting coefficients and attenuated coefficients).
		</p>
	</li>
	<li>
		<p>
            So, you were right on all counts. It is a Fourier-style transform. It is a projection onto an orthonormal basis. And it uses the same elegant math as quantum physics to solve a seemingly unrelated problem in computer graphics with breathtaking efficiency.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Application
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=jN7FX5COASM" 
						class="external-link" 
						target="_blank" >
                        Spherical Harmonics Exponentials for Efficient Glossy Reflections
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            I watched a bit of the video, very technical and specific, about an optimization for computing glossiness.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250920105624.png" width="500" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Ringing happens when you try using high order spherical harmonics.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="solutions" >
    Solutions
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=Qz0KTGYJtUk" 
				class="external-link" 
				target="_blank" >
                Coding Adventure: Ray Tracing
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=C1H4zIiCOaI" 
				class="external-link" 
				target="_blank" >
                Coding Adventure: More Ray Tracing!
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="restir-gi" >
    ReSTIR GI
</h5>
<ul>
	<li>
		<p>
            ReSTIR GI is a spatio-temporal resampling algorithm for path/path-sample reuse (improving sampling of indirect lighting), i.e., a sampling/resampling approach for path/path-trace-based GI rather than a probe or voxel store.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://research.nvidia.com/publication/2021-06_restir-gi-path-resampling-real-time-path-tracing" 
				class="external-link" 
				target="_blank" >
                ReSTIR GI
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_1g-XhlI_5A" 
				class="external-link" 
				target="_blank" >
                ReSTIR GI Demo - Kajiya
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/EmbarkStudios/kajiya" 
				class="external-link" 
				target="_blank" >
                Kajiya
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/EmbarkStudios/kajiya/blob/main/docs/gi-overview.html" 
				class="internal-link" 
				target="_self" >
                ReSTIR GI - How it was implemented on Kajiya
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://cs.dartmouth.edu/~wjarosz/publications/bitterli20spatiotemporal.html" 
				class="external-link" 
				target="_blank" >
                Siggraph 2020 - Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="lumen" >
    Lumen
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://dev.epicgames.com/documentation/en-us/unreal-engine/lumen-global-illumination-and-reflections-in-unreal-engine" 
				class="external-link" 
				target="_blank" >
                Lumen - Unreal Engine 5
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    We settled on Mesh Signed Distance Fields for our Software Ray Tracing geometry representation. These give reliable occlusion, all areas have coverage, and we still get fast software ray tracing through sphere tracing, which skips through empty space. The intersection with the distance field surface only gives us the hit position and normal, we can’t find the material attributes or the lighting.
				</p>
			</li>
			<li>
				<p>
                    We tried runtime voxelization and voxel cone tracing, but merging geometry properties into a volume causes lots of leaking, especially in the lower mip maps.
				</p>
			</li>
			<li>
				<p>
                    We also tried voxel bit bricks, where we stored 1 bit per voxel to mark whether it contains geometry or not. Simple ray marching of bit bricks was surprisingly slow and after adding a proximity map for acceleration, we just decided to drop voxels and arrived at a Global Distance Field
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=2GYXuM10riw" 
				class="external-link" 
				target="_blank" >
                Radiance Caching for Real-time Global Illumination - 2021
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I watched the first 10 minutes of the video.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Keywords:
		</p>
		<ul>
			<li>
				<p>
                    Downsample incoming radiance.
				</p>
			</li>
		</ul>
	</li>
	<li>
        <img src="assets/image_20250919103905.png" width="350" >

	</li>
	<li>
		<p>
            Probes:
		</p>
		<ul>
			<li>
				<p>
                    Octahedral atlas with border.
				</p>
			</li>
			<li>
				<p>
                    8x8 per probe, resulting in 64 traces per probe.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919104113.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919104206.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919104235.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="screen-space-radiance-caching" >
    Screen Space Radiance Caching
</h5>
<ul>
	<li>
		<ol>
			<li>
			</li>
		</ol>
	</li>
	<li>
		<p>
            UE5 - Instead of tracing for every single pixel on screen, we bundle up our rays and we trace from a much smaller set of pixels.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=oJDonbFZbHk" 
				class="external-link" 
				target="_blank" >
                Two-Level Radiance Caching - AMD - GDC 2023
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Instead tradeoff between pathtracing and probes.
				</p>
			</li>
			<li>
				<p>
                    Less noise with less samples, sounds like a good idea.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=57F1ezwH7Mk" 
				class="external-link" 
				target="_blank" >
                Enshourded - 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    SDF Rays.
				</p>
			</li>
			<li>
				<p>
                    Spatial Cascaded Cache.
				</p>
			</li>
			<li>
				<p>
                    Froxel Volumes.
				</p>
			</li>
			<li>
				<p>
                    Etc.
				</p>
			</li>
			<li>
				<p>
                    Intense.
				</p>
			</li>
			<li>
				<p>
                    I don't know if it is Forward+ or Deferred Rendering...
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="radiance-cascades-rc" >
    Radiance Cascades (RC)
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/@Alexander_Sannikov/videos" 
				class="external-link" 
				target="_blank" >
                Author's channel
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://drive.google.com/file/d/1L6v1_7HY2X-LV3Ofb6oyTIxgEaP4LOI6/view" 
				class="external-link" 
				target="_blank" >
                Radiance Cascades: A Novel Approach to Calculating Global Illumination - August 2023
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=TrHHTQqmAaM" 
				class="external-link" 
				target="_blank" >
                Radiance Cascades - ExileCon 2023
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/TrHHTQqmAaM?feature=shared&t=2246" 
				class="external-link" 
				target="_blank" >
                Implementation of Radiance Cascades in World Space, purely
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=3so7xdZHKxw" 
				class="external-link" 
				target="_blank" >
                Exploring Radiance Cascades; soft-shadows, etc
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=6O9-BUDk_-c" 
				class="external-link" 
				target="_blank" >
                2D Global Illumination with Radiance Cascades
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://x.com/mxacop/status/1822851233708732579" 
				class="external-link" 
				target="_blank" >
                3D Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Raikiri/LegitEngine" 
				class="external-link" 
				target="_blank" >
                Legit Engine
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    A rendergraph-based graphical framework for Vulkan, in C++.
				</p>
			</li>
			<li>
				<p>
                    The author of Radiance Cascades contributed to this engine.
				</p>
			</li>
			<li>
				<p>
                    Radiance Cascades is not implemented in this engine.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            They require a lot of compute and memory in 3D space.
		</p>
	</li>
	<li>
		<p>
            For 2D and screen-space 3D (like in Path of Exile 2) the amount of data you store is small enough that RC is an efficient solution, but it doesn't scale well for large 3D worlds.
		</p>
	</li>
	<li>
		<p>
            Path of Exile 2.
		</p>
	</li>
	<li>
		<p>
            Godot Discussion:
		</p>
		<ul>
			<li>
				<p>
                    Juan (against):
				</p>
				<ul>
					<li>
						<p>
                            Despite the hype, radiance cascades actually aren't all that practical, or at least aren't any more practical than competing techniques, in world space mode.
						</p>
					</li>
					<li>
						<p>
                            Radiance cascades shine in screen space mode (which is why they work excellently for Path of Exile), so they're less an alternative to Lumen/SDFGI and more an alternative to SSGI.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    fakhraldin (in favor):
				</p>
				<ul>
					<li>
						<p>
                            Suggested Radiance Cascades.
						</p>
					</li>
					<li>
						<p>
                            This GI solution is not restricted to 2D. Why should a probe based GI be restricted to only 2D in the first place? This doesn't make any sense for every graphics developer who got experience with probe based GI techniques, strange.
						</p>
					</li>
					<li>
						<p>
                            Radiance Cascades are not restricted to screen space but can be expanded to polygonal hardware ray tracing as well. Alexander clearly confirms this 
							<a
								href="https://youtu.be/bYTw3ISxgUw?feature=shared&t=74" 
								class="external-link" 
								target="_blank" >
                                here
							</a>
                            . And again it is strange to claim the opposite to every experienced graphics developer. In fact there are several released triple A titles, which use probe based GI with polygonal hardware ray tracing instead of screen space.
						</p>
					</li>
					<li>
						<p>
                            Screen Space is still being used even by triple A studios. Even Software Lumen itself does partially use SSGI for details of close objects among other techniques. Remember, Lumen is composed of several GI techniques. Million dollar game productions do rely on Screen Space. You don't come around using screen space for high frequency details in cross-gen graphics. Signed distance fields and voxel solutions are missing high frequency details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Other people against:
				</p>
				<ul>
					<li>
						<p>
                            We both very explicitly say that yes, radiance cascades can be used in world space. Their limitations just don't make them a better or more practical alternative to SDFGI/HDDAGI. We both very explicitly say that radiance cascades could be a great alternative to SSGI.
						</p>
					</li>
					<li>
						<p>
                            I would like to see someone create a 3D radiance cascades solution (open-world would be even better). I'm a bit skeptical about its performance since, even in screen space, it's not that impressive compared to other screen space solutions, though it does look better.
						</p>
					</li>
					<li>
						<p>
                            Juan stated in his thread, open-world is actually radiance cascade's greatest weakness as a world space effect.
						</p>
					</li>
					<li>
						<p>
                            This is actually what makes radiance cascades (as a screen space effect) really good and why it's used in production in Path of Exile: the cost is the same as other SSGI approaches, but the quality is much higher.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Neither SDFGI nor HDDAGI are proven as practical solutions. SDFGI is being replaced by HDDAGI due to its inefficacy, and HDDAGI isn't released yet. Neither have effective parity with production-proven GI techniques and are ultimately experimental.
				</p>
			</li>
			<li>
				<p>
                    Take Avatar Frontiers of Pandora for example. Their technique is currently seen as the most sophisticated dynamic GI solution for cross-gen and next-gen realtime video games.
				</p>
			</li>
			<li>
				<p>
                    But it may surprise many people that their solution actually shares a similar ground concept of &quot;radiance cascades&quot;. They also use a probe based system. Instead of using radiance cascades, they combine different techniques like world space, screen space for high frequency details and ray tracing per hardware RT or compute shaders RT as a fallback. Similar to radiance cascades they implement additional different layers to achieve a wider spectrum of GI. They capture the world's details by &quot;different grades of detection&quot; so to speak.
				</p>
			</li>
			<li>
				<p>
                    The solution with &quot;radiance cascades&quot; is way less complicated, more performant and more scalable for hardware. Just like with SDFGI and HDDAGI we already use a probe grid. &quot;Radiance Cascades&quot; is just adding hierarchical probe grids with different resolutions to the existing one. This step increases detail capture and quality tremendously at cheap costs even with ray tracing.
				</p>
			</li>
			<li>
				<p>
                    We don't even need to make additional probe grids mandatory. It could be optional in the editor and even be offered as an in-game option. The more grid levels you can add, the more quality you can achieve according to your liking and machine. It is highly flexible.
				</p>
			</li>
			<li>
				<p>
                    From a technical standpoint i really don't see insurmountable objections against this solution, as it doesn't even interfere dramatically with the existing one. Rather it can serve as an additional, supportive and optional layer to the basic probe grid. If you don't want to apply it for world space, than don't do it. There are many another ways.
				</p>
			</li>
			<li>
				<p>
                    &quot;Radiance Cascades&quot; can be combined with world space and hardware rt or compute shaders rt to achieve similar results to ubisoft's GI solution, if not even better. Many features in godot turned out to be short-lived obsolete code. But i really don't see &quot;Radiance Cascades&quot; as such. It rather could serve as a basis for further development and options, which build upon it.
				</p>
			</li>
			<li>
				<p>
                    Our resources are limited and it would truly be a missed opportunity not to take advantage of this low-hanging fruit from which a great tree could grow.
				</p>
			</li>
			<li>
				<p>
                    World space radiance cascades has occlusion challenges (sound familiar?) and memory consumption challenges - just like pretty much all real time GI solutions.
				</p>
			</li>
			<li>
				<p>
                    However due to the specific nature of these challenges for radiance cascades, any practical implementation of world space radiance cascades will be limited to 3, at most 4, cascades.
				</p>
			</li>
			<li>
				<p>
                    What if you need GI for an open world map, for example? You might be able to make it work beyond that range, but most potential approaches are challenging to implement, and will likely be expensive to run.
				</p>
			</li>
			<li>
				<p>
                    For example, one potential approach is a cascade of radiance cascades. Literally running the entire thing multiple times at multiple sizes, and interpolating between them.
				</p>
			</li>
			<li>
				<p>
                    So, you might say: &quot;well maybe it can just be a higher quality short range alternative to SDFGI/HDDAGI?&quot; You may have some misconceptions about the level of quality of world space radiance cascades, compared to its much more impressive screen space counterpart.
				</p>
			</li>
			<li>
				<p>
                    Watch 
					<a
						href="https://www.youtube.com/watch?v=5Ua-h1pg6yM" 
						class="external-link" 
						target="_blank" >
                        this video that Sannikov himself posted
					</a>
                    . Does the blockiness and crawliness of the lighting look familiar to you? Does the volume representation look familiar to you? The quality tradeoffs of world space radiance cascades are very similar to the quality tradeoffs of SDFGI/HDDAGI. By replacing SDFGI/HDDAGI with world space radiance cascades, you are literally swapping it out with a technique that has practically the same quality, but much more limited range. You're gaining nothing, and losing something.
				</p>
			</li>
			<li>
				<p>
                    For screen space radiance cascades however, that's a different story. Pretty much everyone agrees it's incredible - probably the best screen space GI the industry has to offer right now, both in terms of performance and quality.
				</p>
			</li>
			<li>
				<p>
                    Author of Radiance Cascades, commenting on the HDDAGI PR:
				</p>
				<ul>
					<li>
						<p>
                            First, I never pitched 3d RC as the ultimate GI solution. I never even pitched it as a good GI solution. I wouldn't even call it practically viable by my standards, to be honest. I'm just saying that it's a direct improvement (in pretty much all parameters) over anything that has a regular grid (or nested grids) of radiance probes. DDGI for example.
						</p>
					</li>
					<li>
						<p>
                            Second, the screenspace version of RC is only limited to on-screen occluders and light sources if screenspace raymarching is used. However, screenspace cascades can store worldspace radiance intervals (including offscreen geometry) if you have a way of casting worldspace rays, using either a BVH, an SDM or a voxel raymarcher of some sort. The main limitation of this approach is that it only allows storing radiance on the surface of the depth buffer and you can't use it for example for volumetric lighting.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Juan apparently thought of an approach that's even better than HDDAGI, and will eventually work on that instead of continuing HDDAGI.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="dynamic-diffuse-global-illumination-ddgi-ray-traced-irradiance-fields" >
    Dynamic Diffuse Global Illumination (DDGI) / Ray-Traced Irradiance Fields
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.gdcvault.com/play/1026182/" 
				class="external-link" 
				target="_blank" >
                &quot;Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields&quot; - Majercik 2019
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=KufJBCTdn_o" 
						class="external-link" 
						target="_blank" >
                        Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields - Majercik 2019
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Much of the talk is about:
				</p>
				<ul>
					<li>
						<p>
                            Fixing very common light leaks in techniques involving light probes.
						</p>
						<ul>
							<li>
								<p>
                                    <img src="assets/image_20250919095820.png" width="350" >
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250919095845.png" width="350" >
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250919095750.png" width="350" >
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Better automatic placing of Light Probes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;Up to 256 rays per probe per frame, scaled down in some cases&quot;.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Limitations
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Don't sample on the surface, as it's really unstable.
						</p>
						<ul>
							<li>
								<p>
                                    1mm up and you are ok, 1mm down and you are inside the surface, where everything is black.
								</p>
							</li>
							<li>
								<p>
                                    Use a bias to improve this.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjSgIuTlZ_vAhXxKX0KHeo-BNEQFjAEegQICRAD&url=http%3A%2F%2Fjcgt.org%2Fpublished%2F0008%2F02%2F01%2Fpaper-lowres.pdf&usg=AOvVaw2vJzwNmZPF7b5pjAf4Vtv8" 
				class="external-link" 
				target="_blank" >
                &quot;Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields&quot; - Majercik 2019
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://jcgt.org/published/0010/02/01/paper-lowres.pdf" 
				class="external-link" 
				target="_blank" >
                &quot;Scaling Probe-Based Real-Time Dynamic Global Illumination for Production&quot; - Majercik 2021
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://cescg.org/wp-content/uploads/2022/04/Rohacek-Improving-Probes-in-Dynamic-Diffuse-Global-Illumination.pdf" 
				class="external-link" 
				target="_blank" >
                &quot;Improving Probes in Dynamic Diffuse Global Illumination&quot; - Rohacek 2022
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            DDGI isn't an alternative to RTXGI, but a way to implement it using light probes.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=L1vhle74AEU" 
				class="external-link" 
				target="_blank" >
                Voxel engine with DDGI
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Probes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Uses probe volumes (a set of points in space storing irradiance + visibility).
				</p>
			</li>
			<li>
				<p>
                    A probe typically holds an estimate of 
					<em>
                        irradiance
					</em>
                    &nbsp;or sometimes 
					<em>
                        radiance distribution
					</em>
                    &nbsp;directly (often SH coefficients).
				</p>
				<ul>
					<li>
						<p>
                            Comparing to PRT, the DDGI Probes represent the current lighting, not a precomputed transfer.
						</p>
					</li>
					<li>
						<p>
                            PRT probe = precomputed transfer.
						</p>
						<ul>
							<li>
								<p>
                                    “This is how light at this spot responds to any lighting, given the static scene geometry.”
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            DDGI probe = runtime-sampled irradiance.
						</p>
						<ul>
							<li>
								<p>
                                    “This is the actual indirect lighting at this spot right now, given whatever is in the scene.”
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Probes store the incoming light in every single direction for rays passing through their center.
				</p>
			</li>
			<li>
				<p>
                    It may also store depth/visibility information (to reduce light leakage).
				</p>
			</li>
			<li>
				<p>
                    Each probe gathers lighting from the environment using ray tracing (usually hardware-accelerated).
				</p>
			</li>
			<li>
				<p>
                    Lighting between probes is interpolated at runtime.
				</p>
			</li>
			<li>
				<p>
                    When shading a point on a surface we sample the probes that are nearby, and blend for smooth lighting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Requires a set of probes, each storing low-frequency irradiance (spherical harmonics, octahedral maps, or similar).
		</p>
	</li>
	<li>
		<p>
            Probes can be updated progressively with ray tracing, amortizing cost across frames.
		</p>
	</li>
	<li>
		<p>
            Usually only practical for low-frequency GI (no fine detail).
		</p>
	</li>
	<li>
		<p>
            Bias samples for probes that just had changes in irradiance, like importance sampling, could speed convergence after edits.
		</p>
	</li>
</ul>
<h5
	id="screen-space-indirect-lighting-with-visibility-bitmask-vbao-ssilvb" >
    Screen Space Indirect Lighting with Visibility Bitmask (VBAO) (SSILVB)
</h5>
<ul>
	<li>
		<p>
            The technique is essentially an extension to ground-truth ambient occlusion (GTAO).
		</p>
	</li>
	<li>
		<p>
            Huge performance gain from GTAO.
		</p>
	</li>
	<li>
		<p>
            Quality visuals of near raytracing ambient occlusion.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://arxiv.org/pdf/2301.11376" 
				class="external-link" 
				target="_blank" >
                Screen Space Indirect Lighting with Visibility Bitmask - 2023
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://cybereality.com/screen-space-indirect-lighting-with-visibility-bitmask-improvement-to-gtao-ssao-real-time-ambient-occlusion-algorithm-glsl-shader-implementation/" 
				class="external-link" 
				target="_blank" >
                SSAO vs GTAO vs SSILVB and implementation of SSILVB
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I didn't read it properly.
				</p>
			</li>
			<li>
				<p>
                    The implementation is adapted from &quot;Screen Space Indirect Lighting with Visibility Bitmask&quot; by Olivier Therrien https://cdrinmatane.github.io/posts/cgspotlight-slides/.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_RhsLkQRoi4" 
				class="external-link" 
				target="_blank" >
                SSILVB - Demo
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="horizon-based-indirect-lighting" >
    Horizon-Based Indirect Lighting
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf" 
				class="external-link" 
				target="_blank" >
                Horizon-Based Indirect Lighting - Benoit Patapom Mayoux 2018
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Patapom/GodComplex/tree/master/Tests/TestHBIL" 
				class="external-link" 
				target="_blank" >
                HBIL Demo by Patapom (the author)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            &quot;The ideal companion for your far-field indirect lighting solution&quot;.
		</p>
	</li>
	<li>
		<p>
            Treat the depth buffer as sort of a height field and march across that in slices.
		</p>
	</li>
	<li>
		<p>
            A horizon tells if new samples are hidden behind old samples.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918121447.png" width="300" >
            &nbsp;
            <img src="assets/image_20250918121534.png" width="300" >
            .
		</p>
	</li>
</ul>
<h5
	id="multi-scale-ambient-occlusion-msao" >
    Multi-Scale Ambient Occlusion (MSAO)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.comp.nus.edu.sg/~lowkl/publications/mssao_visual_computer_2012.pdf" 
				class="external-link" 
				target="_blank" >
                Efficient screen-space approach to high-quality multiscale ambient occlusion - 2012
			</a>
		</p>
	</li>
	<li>
		<p>
            &quot;I know HBAO+ is released but this method is far cheaper as you can see on that table in the end of the paper (They tested on GTX 460M! and it is 23ms average). I believe this method will give us far superior visuals than just SSAO.&quot;
		</p>
	</li>
	<li>
		<p>
			<strong>
                Wicked Engine 2024
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This was my favourite SSAO so far because it handles large areas and small detail alike without any noise or temporal issues. It works by computing the AO in a deinterleaved version of the depth buffer that is contained in a Texture2DArray. It computes the AO in multiple resolutions, then upsamples and combines all of them into a final texture with bilateral blurring.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="screen-space-reflection-ssr" >
    Screen Space Reflection (SSR)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://josselinsomervilleroberts.github.io/papers/Report_INF584.pdf" 
				class="external-link" 
				target="_blank" >
                Screen Space Reflections - 
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Used to capture reflections based on the rendered scene (using the previous frame for instance) by ray-marching in the depth buffer.
		</p>
	</li>
	<li>
		<p>
            SSR gives great results but can be very 
			<em>
                expensive
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/environment_and_post_processing.html#screen-space-reflections-ssr" 
				class="external-link" 
				target="_blank" >
                SSR - Godot
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=AHrG-rur3nQ" 
				class="external-link" 
				target="_blank" >
                SSR - Wicked Engine 2017 Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I implemented screen space reflections around two years ago but never showed it off so here you go.
				</p>
			</li>
			<li>
				<p>
                    This is the simplest technique that I know of. It is using binary search when raymarching in view space.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="distant-environment-probes-cube-map-ibl" >
    Distant Environment Probes / Cube Map IBL
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html#lighting/imagebasedlights" 
				class="internal-link" 
				target="_self" >
                IBL with Cube Maps - Filament
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=yEkryaaAsBU" 
				class="external-link" 
				target="_blank" >
                Lightmaps, Ambient Color, IBL with CubeMaps, Probe-based Lighting
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Used to capture lighting information at “infinity”, where parallax can be ignored. Distant probes typically contain the sky, distant landscape features or buildings, etc.
		</p>
	</li>
	<li>
		<p>
            The light is assumed to come from infinitely far away (which means every point on the object's surface uses the same environment map).
		</p>
	</li>
	<li>
		<p>
            They are either captured by the engine or acquired from a camera as high dynamic range images (HDRI).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Irradiance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The whole environment contributes light to a given point on the object's surface.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Radiance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The resulting light bouncing off of the object.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Incident lighting must be applied consistently to the diffuse and specular parts of the BRDF.
		</p>
	</li>
	<li>
		<p>
            Typically, the environment image is acquired offline in the real world, or generated by the engine either offline or at run time; either way, local or distant probes are used.
		</p>
	</li>
	<li>
		<p>
            Obviously the environment image must be acquired somehow and as we'll see below it needs to be pre-processed before it can be used for lighting.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911114146.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Implementing a fully dynamic day/night cycle requires for instance to recompute the distant light probes dynamically.
				</p>
			</li>
			<li>
				<p>
                    As probes only capture basic color information and direction, very shiny surfaces are not very doable.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918205514.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Far Cry 3 used probes. In that game you wouldn't find any shiny metallic object, as the probes cannot represent that type of lighting very easily.
				</p>
			</li>
			<li>
				<p>
                    IBL Cube Maps, on the other hand, could represent metals much better.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918205618.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Images, in particular cubemaps, are a great way to encode such an “environment light”.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Processing Light Probes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We saw previously that the radiance of an IBL is computed by integrating over the surface's hemisphere.
				</p>
			</li>
			<li>
				<p>
                    Since this would obviously be too expensive to do in real-time, we must first pre-process our light probes to convert them into a format better suited for real-time interactions.
				</p>
			</li>
			<li>
				<p>
                    The sections below will discuss the techniques used to accelerate the evaluation of light probes:
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Specular reflectance
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    pre-filtered importance sampling and split-sum approximation
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Diffuse reflectance
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    irradiance map and spherical harmonics
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Implementation (Filament)
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> vec3 irradianceSH(vec3 n) {
&nbsp;&nbsp;&nbsp;&nbsp; // uniform vec3 sphericalHarmonics[9]
&nbsp;&nbsp;&nbsp;&nbsp; // We can use only the first 2 bands for better performance
&nbsp;&nbsp;&nbsp;&nbsp; return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphericalHarmonics[0]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[1] * (n.y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[2] * (n.z)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[3] * (n.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[4] * (n.y * n.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[5] * (n.y * n.z)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[6] * (3.0 * n.z * n.z - 1.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[7] * (n.z * n.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sphericalHarmonics[8] * (n.x * n.x - n.y * n.y);
 }
 
 // NOTE: this is the DFG LUT implementation of the function above
 vec2 prefilteredDFG_LUT(float coord, float NoV) {
&nbsp;&nbsp;&nbsp;&nbsp; // coord = sqrt(roughness), which is the mapping used by the
&nbsp;&nbsp;&nbsp;&nbsp; // IBL prefiltering code when computing the mipmaps
&nbsp;&nbsp;&nbsp;&nbsp; return textureLod(dfgLut, vec2(NoV, coord), 0.0).rg;
 }
 
 vec3 evaluateSpecularIBL(vec3 r, float perceptualRoughness) {
&nbsp;&nbsp;&nbsp;&nbsp; // This assumes a 256x256 cubemap, with 9 mip levels
&nbsp;&nbsp;&nbsp;&nbsp; float lod = 8.0 * perceptualRoughness;
&nbsp;&nbsp;&nbsp;&nbsp; // decodeEnvironmentMap() either decodes RGBM or is a no-op if the
&nbsp;&nbsp;&nbsp;&nbsp; // cubemap is stored in a float texture
&nbsp;&nbsp;&nbsp;&nbsp; return decodeEnvironmentMap(textureCubeLodEXT(environmentMap, r, lod));
 }
 
 vec3 evaluateIBL(vec3 n, vec3 v, vec3 diffuseColor, vec3 f0, vec3 f90, float perceptualRoughness) {
&nbsp;&nbsp;&nbsp;&nbsp; float NoV = max(dot(n, v), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 r = reflect(-v, n);
 
&nbsp;&nbsp;&nbsp;&nbsp; // Specular indirect
&nbsp;&nbsp;&nbsp;&nbsp; vec3 indirectSpecular = evaluateSpecularIBL(r, perceptualRoughness);
&nbsp;&nbsp;&nbsp;&nbsp; vec2 env = prefilteredDFG_LUT(perceptualRoughness, NoV);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 specularColor = f0 * env.x + f90 * env.y;
 
&nbsp;&nbsp;&nbsp;&nbsp; // Diffuse indirect
&nbsp;&nbsp;&nbsp;&nbsp; // We multiply by the Lambertian BRDF to compute radiance from irradiance
&nbsp;&nbsp;&nbsp;&nbsp; // With the Disney BRDF we would have to remove the Fresnel term that
&nbsp;&nbsp;&nbsp;&nbsp; // depends on NoL (it would be rolled into the SH). The Lambertian BRDF
&nbsp;&nbsp;&nbsp;&nbsp; // can be baked directly in the SH to save a multiplication here
&nbsp;&nbsp;&nbsp;&nbsp; vec3 indirectDiffuse = max(irradianceSH(n), 0.0) * Fd_Lambert();
 
 
&nbsp;&nbsp;&nbsp;&nbsp; // Indirect contribution
&nbsp;&nbsp;&nbsp;&nbsp; return diffuseColor * indirectDiffuse + indirectSpecular * specularColor;
 }
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Implementation (Vulkan-glTF-PBR)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The snippets below come from 
                    <code>material_pbr.frag</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // Calculation of the lighting contribution from an optional Image Based Light source.
 // Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
 // See our README.md on Environment Maps [3] for additional discussion.
 vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
 {
&nbsp;&nbsp;&nbsp;&nbsp; float lod = (pbrInputs.perceptualRoughness * uboParams.prefilteredCubeMipLevels);
&nbsp;&nbsp;&nbsp;&nbsp; // retrieve a scale and bias to F0. See [1], Figure 3
&nbsp;&nbsp;&nbsp;&nbsp; vec3 brdf = (texture(samplerBRDFLUT, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
&nbsp;&nbsp;&nbsp;&nbsp; vec3 diffuseLight = SRGBtoLINEAR(tonemap(texture(samplerIrradiance, n))).rgb;
&nbsp;&nbsp;&nbsp;&nbsp; vec3 specularLight = SRGBtoLINEAR(tonemap(textureLod(prefilteredMap, reflection, lod))).rgb;
&nbsp;&nbsp;&nbsp;&nbsp; vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp; vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
&nbsp;&nbsp;&nbsp;&nbsp; // For presentation, this allows us to disable IBL terms
&nbsp;&nbsp;&nbsp;&nbsp; // For presentation, this allows us to disable IBL terms
&nbsp;&nbsp;&nbsp;&nbsp; diffuse *= uboParams.scaleIBLAmbient;
&nbsp;&nbsp;&nbsp;&nbsp; specular *= uboParams.scaleIBLAmbient;
&nbsp;&nbsp;&nbsp;&nbsp; return diffuse + specular;
 }
</code></pre>
		<ul>
			<li>
				<p>
                    Code where the IBL is calculated and used.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // Bla bla bla, basic lighting.
 vec3 F = specularReflection(pbrInputs);
 float G = geometricOcclusion(pbrInputs);
 float D = microfacetDistribution(pbrInputs);
 const vec3 u_LightColor = vec3(1.0);
 vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
 vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
 vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);
 
 // Calculate lighting contribution from image based lighting source (IBL)
 color += getIBLContribution(pbrInputs, n, reflection);
 const float u_OcclusionStrength = 1.0f;
 
 // -&gt; Ambient Occlusion
 // Apply optional PBR terms for additional (optional) shading
 if (material.occlusionTextureSet &gt; -1) {
&nbsp;&nbsp;&nbsp;&nbsp; float ao = texture(aoMap, (material.occlusionTextureSet == 0 ? inUV0 : inUV1)).r;
&nbsp;&nbsp;&nbsp;&nbsp; color = mix(color, color * ao, u_OcclusionStrength);
 }
 
 // Emissive
 vec3 emissive = material.emissiveFactor.rgb * material.emissiveStrength;
 if (material.emissiveTextureSet &gt; -1) {
&nbsp;&nbsp;&nbsp;&nbsp; emissive *= SRGBtoLINEAR(texture(emissiveMap, material.emissiveTextureSet == 0 ? inUV0 : inUV1)).rgb;
 };
 color += emissive;
 outColor = vec4(color, baseColor.a);
</code></pre>
	</li>
</ul>
<h5
	id="reflection-probes-cube-map-reflections" >
    Reflection Probes / Cube Map Reflections
</h5>
<ul>
	<li>
		<p>
            Store environment 
			<em>
                radiance
			</em>
            &nbsp;(not just 
			<em>
                irradiance
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
            Stores a cube map texture of the surroundings, representing light incoming from all directions.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used for specular reflections (environment mapping).
				</p>
			</li>
			<li>
				<p>
                    Mipmapped cube maps can be used with roughness filtering (for PBR specular).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Good fits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Games with a lot of metals, as that's where cube maps &quot;shine&quot; (literally).
				</p>
			</li>
			<li>
				<p>
                    Racing games are a good fit.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    They are static; if the scene changes, the cubemap needs to be regenerated, and that's expensive.
				</p>
			</li>
			<li>
				<p>
                    Doesn't handle self-reflections.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250918204816.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/reflection_probes.html#doc-reflection-probes" 
				class="external-link" 
				target="_blank" >
                Reflection Probes - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Reflection probes are used as a source of reflected and ambient light for objects inside their area of influence.
				</p>
			</li>
			<li>
				<p>
                    They can be used to provide more accurate reflections than VoxelGI and SDFGI while being fairly cheap on system resources.
				</p>
			</li>
			<li>
				<p>
                    Since reflection probes can also store ambient light, they can be used as a low-end alternative to VoxelGI and SDFGI when baked lightmaps aren't viable (e.g. in procedurally generated levels).
				</p>
			</li>
			<li>
				<p>
                    Good reflections, but poor indirect lighting.
				</p>
			</li>
			<li>
				<p>
                    Indirect lighting can be disabled, set to a constant color spread throughout the probe, or automatically read from the probe's environment (and applied as a cubemap). This essentially acts as local ambient lighting. Reflections and indirect lighting are blended with other nearby probes.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918153234.png" width="350" >
                    &nbsp;
                    <img src="assets/image_20250918153250.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    It interacts with LightmapGI:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250918153218.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Reflection probes can also be used at the same time as SSR to provide reflections for off-screen objects.
				</p>
				<ul>
					<li>
						<p>
                            Godot will blend together the SSRs and reflections from reflection probes.
						</p>
					</li>
					<li>
						<p>
                            This way you can get the best of both worlds: high-quality reflections for general room structure (that remain present when off-screen), while also having real-time reflections for small details.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250918153004.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To get reasonably accurate reflections, you should generally have one ReflectionProbe node per room (sometimes more for large rooms).
				</p>
			</li>
			<li>
				<p>
                    The extents don't have to be square, and you can even rotate the ReflectionProbe node to fit rooms that aren't aligned with the X/Z grid.
				</p>
				<ul>
					<li>
						<p>
                            Use this to your advantage to better cover rooms without having to place too many ReflectionProbe nodes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/reflection_probes.html#reflectionprobe-properties" 
						class="external-link" 
						target="_blank" >
                        Properties
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Blending
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            To make transitions between reflection sources smoother, Godot supports automatic probe blending:
						</p>
						<ul>
							<li>
								<p>
                                    Up to 4 ReflectionProbes can be blended together at a given location. A ReflectionProbe will also fade out smoothly back to environment lighting when it isn't touching any other ReflectionProbe node.
								</p>
							</li>
							<li>
								<p>
                                    SDFGI and VoxelGI will blend in smoothly with ReflectionProbes if used. This allows placing ReflectionProbes strategically to get more accurate (or fully real-time) reflections where needed, while still having rough reflections available in the VoxelGI or SDFGI's area of influence.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            To make several ReflectionProbes blend with each other, you need to have part of each ReflectionProbe overlap each other's area. The extents should only overlap as little as possible with other reflection probes to improve rendering performance (typically a few units in 3D space).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Performance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            ReflectionProbes with their update mode set to 
							<em>
                                Always
							</em>
                            &nbsp;are much more expensive than probes with their update mode set to 
							<em>
                                Once
							</em>
                            &nbsp;(the default). Suited for integrated graphics when using the Once update mode.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Rotate the camera 6 times to render the 6 faces of the cube.
		</p>
	</li>
	<li>
		<p>
            You only render the plane, not the Tea Pot.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918101524.png" width="250" >
            &nbsp;
            <img src="assets/image_20250918101708.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            Instead of using the environment map loaded, you use the cubemap generated. So the reflection ON the Tea Pot only comes from this Cube Map.
		</p>
	</li>
	<li>
		<p>
            You should also use the Cube Map on the mirror image of the Tea Pot (made when using Planar Reflections).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918102206.png" width="350" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The mirror image is clearer now.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918095737.png" width="400" >
            .
		</p>
	</li>
</ul>
<h5
	id="planar-reflections-flat-mirror" >
    Planar Reflections / Flat Mirror
</h5>
<ul>
	<li>
		<p>
            Used to capture reflections by rendering the scene mirrored by a plane. This technique works only for flat surfaces such as building floors, roads and water.
		</p>
	</li>
	<li>
		<p>
            Instead of reflecting the entire world, we reflect the camera; it's the same thing.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918101612.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2024/12/wicked-engines-graphics-in-2024/" 
				class="external-link" 
				target="_blank" >
                Wicked Engine 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I’m disappointed whenever I see a modern game not supporting proper mirror reflections or if it has screen space reflection (SSR) on flat water. That’s why in Wicked Engine I’d like to show that planar reflection is still relevant and it should be one of the first choices of a game when a reflection needs to be rendered. The planar reflection is the perfect solution for a mirror because that’s what it was made for, and it’s good enough to use even on a large water surface with waves, like an ocean or a lake. Even though the waves are not totally accurate to be represented, it’s still a lot better than noisy SSR that cuts of abruptly.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919090214.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In Wicked Engine, the planar reflections are using a second full depth prepass + color pass with all the forward rendering pipeline capabilities. Although most of the secondary effects are turned off for them, simply by not running those passes for planar reflections. Also they don’t generate visibility buffer, only depth buffer in the prepass. Planar reflections rendering is also scheduled in the frame asynchronously to the main camera’s compute effects, so there is also room to utilize the modern graphics API to render them. Compared to the main camera, planar reflections are rendered in quarter of the main camera resolution in both axes so they become less dependent on the pixel shader performance, but more geometry heavy, which helps a bit with async compute passes at the same time. To combat the low resolution look, I choose to render them at 4x MSAA right now for some additional anti-aliasing. Quarter resolution means that the resolution is 1/16 compared to the main camera, and adding 4x MSAA on top doesn’t bring back the full detail, but I found it quite nice, for now, although it can be tweaked easily if needed.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="discarded-solutions" >
    Discarded Solutions
</h3>
<h5
	id="voxel-cone-tracing-gi-vct-voxel-gi-sparse-voxel-octree-gi-svogi-voxel-traced-global-illumination-vtgi" >
    Voxel Cone Tracing GI (VCT) / Voxel GI / Sparse Voxel Octree GI (SVOGI) / Voxel Traced Global Illumination (VTGI)
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://research.nvidia.com/sites/default/files/pubs/2011-09_Interactive-Indirect-Illumination/GIVoxels-pg2011-authors.pdf" 
				class="external-link" 
				target="_blank" >
                Interactive Indirect Illumination Using Voxel Cone Tracing - 2011
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://onlinelibrary.wiley.com/doi/10.1111/cgf.15262" 
				class="external-link" 
				target="_blank" >
                Dynamic Voxel Based Global Illumination
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Instead of using rays, we use voxel cones.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918110456.png" width="450" >
            &nbsp;
            <img src="assets/image_20250918110515.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    This is a high resolution of voxelization.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Just like mipmaps, we generate lower and lower resolutions of this.
		</p>
	</li>
	<li>
		<p>
            And cones are used, where each cone accounts for a range of directions, instead of a single direction.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918110613.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            The cone tracing technique works best with a regular voxel grid because we perform ray-marching against the data like with screen space reflections for example.
		</p>
	</li>
	<li>
		<p>
            A regular voxel grid consumes more memory, but it is faster to create (voxelize), and more cache efficient to traverse (ray-march).
		</p>
	</li>
	<li>
		<p>
            The nice thing about this technique is that we can retrieve all sorts of effects. We have “free” ambient occlusion by default when doing this cone tracing, light bouncing, but we can retrieve reflections, refractions and shadows as well from this voxel structure with additional ray march steps. We can have a configurable amount of light bounces. Cone tracing code can be shared between the bouncing and querying shader and different types of rays as well. The entire thing remains fully on the GPU, the CPU is only responsible for command buffer generation.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Limitations / Drawbacks
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The main drawback being the limited resolution.
				</p>
			</li>
			<li>
				<p>
                    Voxel GI gives plausible multi-bounce GI but costs in memory, bandwidth and costly voxelization/update;
				</p>
			</li>
			<li>
				<p>
                    The UE5 presentation does make a good argument against cone tracing for generic use (which unreal engine targets), there will always be some artifacts and those will be super bad in specific scenes.
				</p>
			</li>
			<li>
				<p>
                    Comparing to RTGI, voxel based is faster but less accurate and less dynamic.
				</p>
			</li>
			<li>
				<p>
                    Voxel-based lighting is only faster than ray traced global illumination solutions that favor quality over performance. RTGI solutions that prioritize performance are faster than Voxel cone tracing.
				</p>
			</li>
			<li>
				<p>
                    Indiana Jones runs at 1080 60FPS on Series S with RTGI and KCD2 runs at 1080P 30 FPS on Series S.
				</p>
			</li>
			<li>
				<p>
                    Voxel cone tracing is an obsolete technological dead end - too heavy to run on last-gen consoles and mobile, inferior to RT on modern desktop and console hardware.
				</p>
			</li>
			<li>
				<p>
                    KCD2 (Kingdom Come: Deliverance II) only uses it because CryEngine supports it but doesn’t support ray tracing. And CryEngine is still stuck using voxel lighting because the Star Citizen devs poached CryTek’s best graphics engineers, and those engineers then proceeded to add ray tracing to Star Citizen’s fork of CryEngine.
				</p>
			</li>
			<li>
				<p>
                    SVOGI is inaccurate as balls.
				</p>
			</li>
			<li>
				<p>
                    You must love light leaking through every room corner. It's cheap crappy raytracing and it looks like cheap crappy raytracing.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Implementation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://wickedengine.net/2017/08/voxel-based-global-illumination/" 
						class="external-link" 
						target="_blank" >
                        Wicked Engine Implementation
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    First, we have our scene model with polygonal meshes. We need to convert it to a voxel representation. The voxel structure is a 3D texture which holds the direct illumination of the voxelized geometries in each pixel. There is an optional step here which I describe later. Once we have this, we can pre-integrate it by creating a mipmap chain for the resource. This is essential for cone tracing because we want to ray-march the texture with quadrilinear interpolation (sampling a 3D texture with min-mag-mip-linear filtering). We can then retrieve the bounced direct illumination in a final screen space cone tracing pass. The additional step in the middle is relevant if we want more bounces, because we can dispatch additional cone tracing compute shader passes for the whole structure (not in screen space).
				</p>
			</li>
			<li>
				<p>
					<strong>
                        1.) Voxelization
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The most involving part is definitely the first one, the voxelization step. It involves making use of advanced graphics API features like geometry shaders, abandoning the output merger and writing into resources “by hand”. We can also make use of new hardware features like conservative rasterization and rasterizer ordered views, but we will implement them in the shaders as well.
						</p>
					</li>
					<li>
						<p>
                            The main trick to be able to run this in real time is that we need to parallelize the process well. For that, we will exploit the fixed function rasterization hardware, and we will get a pixel shader invocation for each voxel which will be rendered. We also do only a single render pass for every object.
						</p>
					</li>
					<li>
						<p>
                            We need to integrate the following pipeline to our scene rendering algorithm:
						</p>
					</li>
					<li>
						<p>
							<strong>
                                1.) Vertex shader
							</strong>
						</p>
					</li>
					<li>
						<p>
                            The voxelizing vertex shader needs to transform vertices into world space and pass through the attributes to the geometry shader stage. Or just do a pass through and transform to world space in the GS, doesn’t matter.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                2.) Geometry shader
							</strong>
						</p>
					</li>
					<li>
						<p>
                            This will be responsible to select the best facing axis of each triangle received from the vertex shader. This is important because we want to voxelize each triangle once, on the axis it is best visible, otherwise we would get seams and bad looking results.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl"> // select the greatest component of the face normal input[3] is the input array of three vertices
 float3 facenormal = abs(input[0].nor + input[1].nor + input[2].nor);
 uint maxi = facenormal[1] &gt; facenormal[0] ? 1 : 0;
 maxi = facenormal[2] &gt; facenormal[maxi] ? 2 : maxi;
</code></pre>
				<ul>
					<li>
						<p>
                            After we determined the dominant axis, we need to project to it orthogonally by swizzling the position’s xyz components, then setting the z component to 1 and scaling it to clip space.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl"> for (uint i = 0; i &lt; 3; ++i)
 {
 // voxel space pos:
&nbsp;&nbsp;&nbsp;&nbsp; output[i].pos = float4((input[i].pos.xyz - g_xWorld_VoxelRadianceDataCenter) / g_xWorld_VoxelRadianceDataSize, 1);
&nbsp;&nbsp;&nbsp;&nbsp; // Project onto dominant axis:
&nbsp;&nbsp;&nbsp;&nbsp; if (maxi == 0)
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[i].pos.xyz = output[i].pos.zyx;
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; else if (maxi == 1)
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[i].pos.xyz = output[i].pos.xzy;
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; // projected pos:
&nbsp;&nbsp;&nbsp;&nbsp; output[i].pos.xy /= g_xWorld_VoxelRadianceDataRes;
&nbsp;&nbsp;&nbsp;&nbsp; output[i].pos.z = 1;
&nbsp;&nbsp;&nbsp;&nbsp; output[i].N = input[i].nor;
&nbsp;&nbsp;&nbsp;&nbsp; output[i].tex = input[i].tex;
&nbsp;&nbsp;&nbsp;&nbsp; output[i].P = input[i].pos.xyz;
&nbsp;&nbsp;&nbsp;&nbsp; output[i].instanceColor = input[i].instanceColor;
 }
</code></pre>
				<ul>
					<li>
						<p>
                            At the end, we could also expand our triangle a bit to be more conservative to avoid gaps. We could also just be setting a conservative rasterizer state if we have hardware support for it and avoid the expansion here.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl"> 
 // Conservative Rasterization setup:
 float2 side0N = normalize(output[1].pos.xy - output[0].pos.xy);
 float2 side1N = normalize(output[2].pos.xy - output[1].pos.xy);
 float2 side2N = normalize(output[0].pos.xy - output[2].pos.xy);
 const float texelSize = 1.0f / g_xWorld_VoxelRadianceDataRes;
 output[0].pos.xy += normalize(-side0N + side2N)*texelSize;
 output[1].pos.xy += normalize(side0N - side1N)*texelSize;
 output[2].pos.xy += normalize(side1N - side2N)*texelSize;
</code></pre>
				<ul>
					<li>
						<p>
                            It is important to pass the vertices’ world position to the pixel shader, because we will use that directly to index into our voxel grid data structure and write into it. We will also need texture coords and normals for correct diffuse color and lighting.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                3.) Pixel shader
							</strong>
						</p>
					</li>
					<li>
						<p>
                            After the geometry shader, the rasterizer unit schedules some pixel shader invocations for our voxels, so in the pixel shader we determine the color of the voxel and write it into our data structure. We probably need to sample our base texture of the surface and evaluate direct lighting which affects the fragment (the voxel). While evaluating the lighting, use a forward rendering approach, so iterate through the nearby lights for the fragment and do the light calculations for the diffuse part of the light. Leave the specular out of it, because we don’t care about the view dependent part now, we want to be able to query lighting from any direction anyway later. I recommend using a simplified lighting model, but try to keep it somewhat consistent with your main lighting model which is probably a physically based model (at least it is for me and you should also have one) and account for the energy loss caused by leaving out the specularity.
						</p>
					</li>
					<li>
						<p>
                            When you calculated the color of the voxel, write it out by using the following trick: I didn’t bind a render target for the render pass, but I have set an Unordered Access View by calling OMSetRenderTargetsAndUnorderedAccessViews(). So the shader returns nothing, but we write into our voxel grid in the shader code. My voxel grid is a RWStructuredBuffer here to be able to support atomic operations easily, but later it will be converted to a 3D texture for easier filtering and better cache utilization. The Structured buffer is a linear array of VoxelType of size gridDimensions X
							<em>
                                Y
							</em>
                            Z. VoxelType is a structure holding a 32 bit uint for the voxel color (packed HDR color with 0-255 RGB, an emissive multiplier in 7 bits and the last bit indicates if the voxel is empty or not). The structure also contains a normal vector packed into a uint. Our interpolated 3D world position comes in handy when determining the write position into the buffer, just truncate and flatten the interpolated world position which you received from the geometry shader. For writing the results, you must use atomic max operations on the voxel uints. You could be writing to a texture here without atomic operations, but using rasterizer ordered views, but they don’t support volume resources, so a multi pass approach would be necessary for the individual slices of the texture.
						</p>
					</li>
					<li>
						<p>
                            An additional note: If you have generated shadow maps, you can use them in your lighting calculations here to get more proper illumination when cone tracing. If you don’t have shadow maps, you can even use the voxel grid to retrieve (soft) shadow information for the scene later.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        2.) Filtering the data
					</strong>
                    :
				</p>
			</li>
			<li>
				<p>
					<strong>
                        3.) Cone Tracing
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            We have the voxel scene ready for our needs, so let’s query it for information. To gather the global illumination for the scene, we have to run the cone tracing in screen space for every pixel on the screen once. This can happen in the forward rendering object shaders or against the gbuffer in a deferred renderer, when rendering a full screen quad, or in a compute shader. In forward rendering, we may lose some performance because of the worse thread utilization if we have many small triangles. A Z-prepass is an absolute must have if we are doing this in forward rendering. We don’t want to shade a pixel multiple times because this is a heavy computation.
						</p>
					</li>
					<li>
						<p>
                            For diffuse light bounces, we need the pixel’s surface normal and world position at minimum. From the world position, calculate the voxel grid coordinate, then shoot rays in the direction of the normal and around the normal in a hemisphere. But the ray should not start at the surface voxel, but the next voxel along the ray, so we don’t accumulate the current surface’s lighting. Begin ray marching, and each step sample your voxel from increasing mip levels, accumulate color and alpha and when alpha reaches 1, exit and divide the distance travelled. Do this for each ray, and in the end divide the accumulated result with the number of rays as well. Now you have light bounce information and ambient occlusion information as well, just add it to your diffuse light buffer.
						</p>
					</li>
					<li>
						<p>
                            Assembling the hemisphere: You can create a hemisphere on a surface by using a static array of precomputed randomized positions on a sphere and the surface normal. First, if you do a 
							<em>
                                reflect(surfaceNormal, randomPointOnSphere),
							</em>
                            &nbsp;you get a random point on a sphere with variance added by the normal vector. This helps with banding as discrete precomputed points get modulated by surface normal. We still have a sphere, but we want the upper half of it, so check if a point goes below the “horizon” and force it to go to the other direction if it does:
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/using_voxel_gi.html" 
				class="external-link" 
				target="_blank" >
                VoxelGI - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Good reflections and indirect lighting, but beware of leaks.
				</p>
			</li>
			<li>
				<p>
                    Due to its voxel-based nature, VoxelGI will exhibit light leaks if walls and floors are too thin. It's recommended to make sure all solid surfaces are at least as thick as one voxel.
				</p>
			</li>
			<li>
				<p>
                    Streaking artifacts may also be visible on sloped surfaces. In this case, tweaking the bias properties or rotating the VoxelGI node can help combat this.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Performance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The bake's number of subdivisions can be adjusted to balance between performance and quality. The VoxelGI rendering quality can be adjusted in the Project Settings. The rendering can optionally be performed at half resolution (and then linearly scaled) to improve performance significantly.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.cryengine.com/docs/static/engines/cryengine-5/categories/23756816/pages/25535599" 
				class="external-link" 
				target="_blank" >
                SVOGI - CryEngine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=dyH0W-AVqu8" 
				class="external-link" 
				target="_blank" >
                SVOGI - Demo in Kingdom Come: Deliverance
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The voxel based approach from the &quot;old&quot; CryEngine 3 was fascinating and it's a real shame very few games effectively supported it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=4-KSMRjUqGU" 
				class="external-link" 
				target="_blank" >
                Voxel Cone Tracing GI - Demo 2011
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I think it's actually viable for a commercial project. At very least as a fallback for RTX (where it's unsupported or inefficient). I also working on porting it to Unity HDRP.
				</p>
			</li>
			<li>
				<p>
                    Shame Voxel Cone Tracing/VXGI is not even used as a fallback whenever DXR (DirectX Raytracing) is not supported.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="voxel-cone-traced-reflections" >
    Voxel Cone Traced Reflections
</h5>
<ul>
	<li>
		<p>
            Sometimes used for specular approximation.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=3tDLFceRXoM" 
				class="external-link" 
				target="_blank" >
                Voxel Traced GI/Reflections - Demo 2019
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="global-illumination-based-on-surfels-gibs-surfel-gi" >
    Global Illumination Based on Surfels (GIBS) (Surfel GI)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=h1ocYFrtsM4" 
				class="external-link" 
				target="_blank" >
                Global Illumination Based on Surfels - EA 2021
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://m4xc.dev/blog/surfel-maintenance/" 
				class="external-link" 
				target="_blank" >
                Surfel Maintenance for Global Illumination - January 2025
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Impressions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is a technique different from the classic ones currently used. It does not use probes or voxels.
				</p>
			</li>
			<li>
				<p>
                    It is a somewhat elegant technique.
				</p>
			</li>
			<li>
				<p>
                    The presentation covers many of the points I had doubts about, it seems well developed.
				</p>
			</li>
			<li>
				<p>
                    I believe that if the camera moves very quickly, or a new scene appears in front of the player quickly, the technique suffers because it has to update all the surfels.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Surfel-based GI is not inherently ray-traced, however, EA GIBS implementation (and several production uses) do use ray queries/ray tracing as the primary means to place surfels and to evaluate visibility/irradiance, so practical surfel-GI systems are often implemented with ray tracing.
		</p>
	</li>
	<li>
		<p>
            It is completely geared toward Raytracing, given its nature.
		</p>
	</li>
	<li>
		<p>
            Frostbite Engine / EA.
		</p>
	</li>
	<li>
		<p>
            An image is discretized in pixels, a surface is discretized in surfels.
		</p>
	</li>
	<li>
		<p>
            It's an interactive screen space gap filling.
		</p>
	</li>
	<li>
		<p>
            The screen is split into 16x16 tiles and the algorithm finds the tile with the lowest surfel coverage.
		</p>
	</li>
	<li>
		<p>
            If a tile passes a randomized threshold, spawn a surfel.
		</p>
	</li>
	<li>
		<p>
            The result is cached for further use.
		</p>
	</li>
	<li>
		<p>
            Uses Radial Gaussian Depth, inspired by DDGI.
		</p>
	</li>
	<li>
		<p>
            One surfel shares the irradiance with another surfel.
		</p>
	</li>
</ul>
<h5
	id="screen-space-indirect-lighting-ssil" >
    Screen-Space Indirect Lighting (SSIL)
</h5>
<ul>
	<li>
		<p>
            “Where should I 
			<em>
                add
			</em>
            &nbsp;light because nearby surfaces reflect it?”
		</p>
	</li>
	<li>
		<p>
            SSIL tries to estimate the contribution of nearby surfaces reflecting light into shaded areas, using only the information already available in the screen-space buffers (depth, normals, and sometimes color).
		</p>
	</li>
	<li>
		<p>
            Can both darken (occlusion) and brighten areas by adding bounced light.
		</p>
	</li>
	<li>
		<p>
            Think of SSIL as color bleeding + soft bounce lighting in screen space.
		</p>
	</li>
	<li>
		<p>
            Many SSIL techniques use analytic / horizon-based or hemisphere sampling approaches, and some SSIL variants use screen-space ray-marching (ray-marching against the depth buffer). SSIL only becomes hardware/world-space ray-tracing if you explicitly add a BVH-trace pass (i.e. a hybrid that is no longer “pure” screen-space).
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/environment_and_post_processing.html#screen-space-indirect-lighting-ssil" 
				class="external-link" 
				target="_blank" >
                SSIL - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    SSIL provides indirect lighting for small details or dynamic geometry that other global illumination techniques cannot cover. This applies to bounced diffuse lighting, but also emissive materials.
				</p>
			</li>
			<li>
				<p>
                    SSIL also provides a subtle ambient occlusion effect, similar to SSAO, but with less detail.
				</p>
			</li>
			<li>
				<p>
                    Good 
					<em>
                        secondary
					</em>
                    &nbsp;source of indirect lighting, but no reflections.
				</p>
			</li>
			<li>
				<p>
                    SSIL works best for small-scale details, as it cannot provide accurate indirect lighting for large structures on its own. SSIL can provide real-time indirect lighting in situations where other GI techniques fail to capture small-scale details or dynamic objects. Its screen-space nature will result in some artifacts, especially when objects enter and leave the screen. SSIL works using the last frame's color (before post-processing) which means that emissive decals and custom shaders are included (as long as they're present on screen).
				</p>
			</li>
			<li>
				<p>
					<em>
                        Usage
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            This feature only provides 
							<strong>
                                indirect lighting
							</strong>
                            . It is 
							<em>
                                not
							</em>
                            &nbsp;a full global illumination solution.
						</p>
						<ul>
							<li>
								<p>
                                    This makes it different from screen-space global illumination (SSGI) offered by other 3D engines.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            SSIL is meant to be used as a complement to other global illumination techniques such as VoxelGI, SDFGI and LightmapGI.
						</p>
					</li>
					<li>
						<p>
                            SSIL can be combined with SSR and/or SSAO for greater visual quality (at the cost of performance).
						</p>
					</li>
					<li>
						<p>
                            When SSIL is enabled on its own, the effect may not be that noticeable, which is intended.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Performance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The SSIL quality and number of blur passes can be adjusted in the Project Settings. By default, SSIL rendering is performed at half resolution (and then linearly scaled) to ensure a reasonable performance level.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ssgi-screen-space-global-illumination" >
    SSGI (Screen-Space Global Illumination)
</h5>
<ul>
	<li>
		<p>
            &quot;Standard raytracing in screenspace&quot;.
		</p>
	</li>
	<li>
		<p>
            It is an image-space approximation that often uses screen-space ray-marching or hemisphere sampling (i.e. “rays” marched through the depth buffer), which is different from hardware/true world-space ray tracing.
		</p>
	</li>
	<li>
		<p>
            Computes GI from information available in the screen buffer (depth, normals). Fast but limited to visible surfaces and can produce artifacts.
		</p>
	</li>
	<li>
		<p>
            Screen-space sampling / ray marching in screen-space. Not a full ray tracer.
		</p>
	</li>
	<li>
		<p>
            Most real-time SSGI implementations use temporal and/or spatial denoising (or temporal accumulation) because the raw results are noisy or contain high-frequency sampling error unless you pay a high sampling cost.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=dmdyqzelBIY" 
				class="external-link" 
				target="_blank" >
                Implementing SSGI with Joint Bileteral Filtering as a Denoiser
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It also discusses techniques for reducing GI resolution and using image upscaling; this improves performance with practically no visual difference.
				</p>
			</li>
			<li>
				<p>
                    Etc; several other small techniques are discussed.
				</p>
			</li>
			<li>
				<p>
                    All of this in the video was made to apply a 
					<a
						href="https://reshade.me/" 
						class="external-link" 
						target="_blank" >
                        ReShade
					</a>
                    &nbsp;to Skyrim; in the final seconds of the video the before-and-after difference with the new GI technique is shown.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://dev.epicgames.com/documentation/en-us/unreal-engine/screen-space-global-illumination-in-unreal-engine" 
				class="external-link" 
				target="_blank" >
                SSGI in Unreal Engine 5
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Is a feature that aims to create natural-looking lighting by adding dynamic indirect lighting to objects within the screen view. SSGI also makes it possible to have dynamic lighting from emissive surfaces, such as neon lights or other bright surfaces.
				</p>
			</li>
			<li>
				<p>
                    Screen Space Global Illumination works best as a supplimental indirect lighting illumination method to precomputed lighting from 
					<a
						href="https://dev.epicgames.com/documentation/en-us/unreal-engine/global-illumination-in-unreal-engine" 
						class="external-link" 
						target="_blank" >
                        Lightmass
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    SSGI, like other screen space effects, is best used in conjunction with other indirect lighting techniques, such as 
					<a
						href="https://dev.epicgames.com/documentation/en-us/unreal-engine/global-illumination-in-unreal-engine" 
						class="external-link" 
						target="_blank" >
                        precomputed lighting from lightmass
					</a>
                    . When you have large objects that block portions of the screen, SSGI becomes apparent when it's being used as the sole indirect lighting illumination for the scene. For example, using baked lighting reduces screen space artifacts when transitioning behind a large occluder where a bright object may be located. SSGI is recommended as a means to improve indirect lighting illumination in your scene but not as a sole indirect lighting method.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@14.0/manual/Override-Screen-Space-GI.html" 
				class="external-link" 
				target="_blank" >
                SSGI in Unity
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2024/12/wicked-engines-graphics-in-2024/" 
				class="external-link" 
				target="_blank" >
                Wicked Engine 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I also experimented with a screen space global illumination (SSGI) that I wanted to base on the “multi scale screen space ambient occlusion” (MSAO) that I got from the 
					<a
						href="https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/MiniEngine" 
						class="external-link" 
						target="_blank" >
                        DirectX Miniengine
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Just like MSAO, I wanted SSGI to not have to use any temporal accumulation.
				</p>
			</li>
			<li>
				<p>
                    This technique currently can only add lighting, not remove it, but it’s meant to be used together with MSAO which handles only ambient occlusion. However, I might revisit and improve this because in real scenes I didn’t find its quality good enough, especially on small scale as I had to use a lot of blur to hide the sub-sampling.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            SSGI only provides bounce lighting for objects that are on the screen, meaning if you have a large red object that is bouncing red light into the scene, and you turn away, all the red light disappears.
		</p>
	</li>
	<li>
		<p>
            That’s a pretty big limitation but it can work in some cases, such as top-down camera views. Those usually don’t have significant overlapping elements and objects take up less of the screen space so lighting changes usually aren’t as jarring.
		</p>
	</li>
	<li>
		<p>
            I wouldn’t use it as the sole source of GI for a first/third person project, but it can be used to augment baked lighting, as it will provide bounce light and occlusion for movable objects/lights that otherwise wouldn’t.
		</p>
	</li>
	<li>
		<p>
            Think of SSGI as a subset/approximation of what 
			<em>
                path tracing
			</em>
            &nbsp;would compute, but with significant limitations:
		</p>
		<ul>
			<li>
				<p>
                    Path tracing can see the entire scene, SSGI only sees what’s on screen.
				</p>
			</li>
			<li>
				<p>
                    Path tracing accounts for multiple bounces, SSGI usually only approximates one diffuse bounce.
				</p>
			</li>
			<li>
				<p>
                    Path tracing is unbiased (given enough samples), SSGI is inherently biased.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Bad implementations of SSGI can run worse than some Path Tracing implementations.
		</p>
	</li>
</ul>
<h5
	id="ssrtgi-screen-space-ray-traced-global-illumination" >
    SSRTGI (Screen-Space Ray-Traced Global Illumination)
</h5>
<ul>
	<li>
		<p>
			<em>
                SSGI vs SRTGI
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    All SSRTGI implementations are SSGI (because they use screen buffers), but not all SSGI implementations are SSRTGI (because some use hemisphere sampling, cone approximations, analytic occlusion, or other non-ray-march methods).
				</p>
			</li>
			<li>
				<p>
                    Instead of sampling nearby pixels like SSGI does, SSRTGI performs actual ray marching or ray queries in screen space to simulate diffuse rays bouncing off surfaces.
				</p>
			</li>
			<li>
				<p>
                    Honestly... it seems the same thing, the term sounds interchangeable.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Still limited to screen-space data (can’t see off-screen geometry), but captures more accurate light transport within the visible region.
		</p>
	</li>
	<li>
		<p>
            Usually produces better spatial coherence and more accurate occlusion than SSGI. Can also support multiple samples per pixel for more realistic diffuse scattering.
		</p>
	</li>
	<li>
		<p>
            Heavier than SSGI because of ray marching and denoising. However, still cheaper than full path tracing since it avoids tracing into the full scene BVH.
		</p>
	</li>
</ul>
<h5
	id="ray-traced-ambient-occlusion-rtao" >
    Ray-Traced Ambient Occlusion (RTAO)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/boksajak/RTAO" 
				class="external-link" 
				target="_blank" >
                RTAO Implementation
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Ray Traced Ambient Occlusion (RTAO) implemented using DirectX Raytracing (DXR)
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ray-traced-global-illumination-rtxgi" >
    Ray-Traced Global Illumination (RTXGI)
</h5>
<ul>
	<li>
		<p>
            NVIDIA’s RTXGI is implemented as volumes of probes (probe grids/DDGI-style) where probes are updated (ray-traced) and store irradiance/distance-to-geometry for shading.
		</p>
	</li>
	<li>
		<p>
            RTXGI fits into the modern game engine by directly replacing existing indirect lighting approaches such as screen-space ray casting, precomputed lightmaps, and baked irradiance probes. We combine ray tracing, fast irradiance updates, and a moment-based depth scheme for occlusion calculations to create a scalable system without bake times or light leaks. RTXGI is supported on any DXR-enabled GPU and provides developers with an ideal starting point to bring the benefits of real-time ray tracing to their existing tools, knowledge, and capabilities.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.nvidia.com/en-us/on-demand/session/gtcsj20-s22692/" 
				class="external-link" 
				target="_blank" >
                RTXGI
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/NVIDIA-RTX/RTXGI" 
				class="external-link" 
				target="_blank" >
                RTXGI
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    RTXGI v2.0 Update including Neural Radiance Cache and Spatial Hash Radiance Cache
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/NVIDIAGameWorks/RTXGI-DDGI" 
				class="external-link" 
				target="_blank" >
                RTXGI
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    RTXGI is less prominent as a mainstream, engine-integrated solution today.
				</p>
			</li>
			<li>
				<p>
                    Industry momentum has shifted toward hybrid ray-tracing + sampling/resampling approaches (Lumen, ReSTIR/RTXDI, hardware path tracing) and improved probe/volume variants (DDGI/modern probe grids).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Unreal Engine
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Available on UE4 with the RTXGI Plugin and NVIDIA maintained an RTX-focused UE branch, and some community forks claim UE5 support, but 
					<em>
                        RTXGI is not the default/integrated GI in mainline Unreal Engine 5
					</em>
                    &nbsp;and NVIDIA’s official plugin work was effectively put on hold/limited after early UE5 versions.
				</p>
			</li>
			<li>
				<p>
                    Unreal Engine 5 uses Lumen.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ground-truth-ambient-occlusion-gtao" >
    Ground Truth Ambient Occlusion (GTAO)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf" 
				class="external-link" 
				target="_blank" >
                “Practical Realtime Strategies for Accurate Indirect Occlusion&quot; - 2016
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Works almost identically to HBAO, but with a few key differences:
		</p>
		<ul>
			<li>
				<p>
                    The heavy math is moved outside of the loop, needed to be calculated once per slice, so the performance is comparable with HBAO+.
				</p>
			</li>
			<li>
				<p>
                    Consider the cosine of the angle, just like HBAO+ does.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="distance-field-ambient-occlusion-dfao" >
    Distance Field Ambient Occlusion (DFAO)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://advances.realtimerendering.com/s2015/DynamicOcclusionWithSignedDistanceFields.ppt" 
				class="external-link" 
				target="_blank" >
                Dynamic Occlusion with Signed Distance Fields - Unreal Engine 2015
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://dev.epicgames.com/documentation/en-us/unreal-engine/distance-field-ambient-occlusion-in-unreal-engine" 
				class="external-link" 
				target="_blank" >
                Unreal 5 DFAO
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Unlike SSAO, occlusion is computed from world-space occluders, so there are no artifacts from missing data off-screen.
		</p>
	</li>
	<li>
		<p>
            It supports dynamic scene changes; the rigid meshes can be moved or hidden, and it will affect the occlusion.
		</p>
	</li>
	<li>
		<p>
            Distance Field AO quality is determined by the resolution of the Mesh Distance Field it represents. Since AO is very soft shadowing, so even if the surfaces aren't represented properly, occlusion further from the surface will be accurate. It's often not noticeable with sky occlusion. However, make sure that the larger details of the mesh are well represented in the Mesh Distance Field for good results.
		</p>
	</li>
	<li>
		<p>
            The cost of Distance Field AO is primarily GPU time and video memory. DFAO has been optimized such that it can run on medium-spec PC, PlayStation 4, and Xbox One. Currently, it has a much more reliable cost so that it's mostly constant (with a slight dependency on object-density).
		</p>
	</li>
	<li>
		<p>
            In cases with a static camera and mostly flat surfaces, DFAO is 1.6x faster when compared to earlier implementations. In complex scenes with foliage and a fast moving camera, the latest optimizations are 5.5x faster. The cost of Distance Field AO on PlayStation 4 for a full game scene is around 3.7ms.
		</p>
	</li>
	<li>
		<p>
            DFAO relies on an SDF that encodes the minimum signed distance from any point in space to the nearest surface (positive outside, negative inside, or a variant with only unsigned distances).
		</p>
	</li>
</ul>
<h5
	id="scalable-ambient-obscurance-hbao-sao" >
    Scalable Ambient Obscurance (HBAO+ / SAO)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf" 
				class="external-link" 
				target="_blank" >
                &quot;Scalable Ambient Obscurance&quot; - 2012
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It had nothing to do with HBAO, it's actually an optimization of Alchemy Screen-Space Ambient Occlusion.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250919082620.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="hierarhcial-digital-differential-analyzer-global-illumination-hddagi" >
    Hierarhcial Digital Differential Analyzer Global Illumination (HDDAGI)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://research.dreamworks.com/wp-content/uploads/2018/07/talk_hierarchical_digital_OpenVDB_v4-Edited.pdf" 
				class="external-link" 
				target="_blank" >
                Hierarhcial Digital Differential Analyzer for Efficient Ray-Marching in OpenVDB - 2013
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/godotengine/godot/pull/86267" 
				class="external-link" 
				target="_blank" >
                PR para HDDAGI para Godot
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=9Dj9lvBkY-o" 
				class="external-link" 
				target="_blank" >
                HDDAGI - Godot Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            This is a new global illumination system meant to supersede SDFGI.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Key advantages are
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Much, much faster. Significantly lower frame time, orders of magnitude faster cascad
				</p>
			</li>
			<li>
				<p>
                    Generally higher quality (less arctifacting).
				</p>
			</li>
			<li>
				<p>
                    Much better occclusion (a 
					<em>
                        lot
					</em>
                     less light leaked).
				</p>
			</li>
			<li>
				<p>
                    Less memory usage.
                    <br>
                    It is meant as a drop-in replacement. Should work as a replacement for SDFGI.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Known issues
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                     For some reason gets DEVICE LOST on Intel GPUs. No idea why.
				</p>
			</li>
			<li>
				<p>
                     Sharp Reflections not always play good with TAA (wobbly).
				</p>
			</li>
			<li>
				<p>
                     Darkening (occlusion) on some corners, just like SDFGI. I tried different techniques to see if any worked better. DDGI Octahedral VSM gets rid of them, but also leaks a lot more light, so I am unconvinced. Have other ideas to try, but I don’t have infinite time 🙁
				</p>
			</li>
			<li>
				<p>
                     SDFGI spherical harmonics turned out to be buggy and not energy conserving. This makes GI look more saturated and have more light than in HDDAGI (which some people may appreciate more), but It’s a bug 😢. Wondering how this can be compensated.
				</p>
			</li>
			<li>
				<p>
                     Still some further pending optimizations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Future
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                     Dynamic object support.
				</p>
			</li>
			<li>
				<p>
                     High density mode (sub-probes).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="sdfgi-signed-distance-field-global-illumination" >
    SDFGI (Signed Distance Field Global Illumination)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.docdroid.net/YNntL0e/godot-sdfgi-pdf" 
				class="external-link" 
				target="_blank" >
                &quot;SDFGI Solving the accessible Global Illumination problem in Godot&quot; - Outubro 2022
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This paper is 
					<em>
                        absolutely
					</em>
                    &nbsp;important to understand how SDFGI was made.
				</p>
			</li>
			<li>
				<p>
                    Requirements
				</p>
				<ul>
					<li>
						<p>
                            Easy to use (no scene or object setup at import time, no setting up SDF, cards,
						</p>
					</li>
					<li>
						<p>
                            lightmaps, etc). Ideally enable with one click, no set-up.
						</p>
					</li>
					<li>
						<p>
                            Real-time (or at least fast updates).
						</p>
					</li>
					<li>
						<p>
                            Good enough quality (no light leaks -or keep to minimum-).
						</p>
					</li>
					<li>
						<p>
                            Supports both diffuse and reflected light.
						</p>
					</li>
					<li>
						<p>
                            Supports light into transparent objects.
						</p>
					</li>
					<li>
						<p>
                            Works as source of light for volumetric fog.
						</p>
					</li>
					<li>
						<p>
                            Works in all hardware that supports Vulkan, even IGP.
						</p>
					</li>
					<li>
						<p>
                            Can work in VR (so, using TAA is not required).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Sacrifices
				</p>
				<ul>
					<li>
						<p>
                            Not the best possible quality (high frequency GI missing, has to be&nbsp;&nbsp;compensated with screen space lighting).
						</p>
					</li>
					<li>
						<p>
                            Poor dynamic object support (dynamic objects get light from environment, but don't contribute to it). Light blocking may be added to some extent in the future.
						</p>
					</li>
					<li>
						<p>
                            Needs to use cascades.
						</p>
					</li>
					<li>
						<p>
                            Limited amount of samples means small emissive objects are spotty.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Previous work
				</p>
				<ul>
					<li>
						<p>
                            Uses DDGI by Morgan McGuire as a base.
						</p>
					</li>
					<li>
						<p>
                            Uses Signed Distance Fields generated with 
							<a
								href="https://www.comp.nus.edu.sg/~tants/jfa.html" 
								class="external-link" 
								target="_blank" >
                                Jump Flood
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://arxiv.org/pdf/2007.14394" 
				class="external-link" 
				target="_blank" >
                Signed Distance Fields Dynamic Diffuse Global Illumination - 2020
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Global Illumination (GI) is of utmost importance in the field of photo-realistic rendering. However, its computation has always been very complex, especially diffuse GI. State of the art real-time GI methods have limitations of different nature, such as light leaking, performance issues, special hardware requirements, noise corruption, bounce number limitations, among others. To overcome these limitations, we propose a novel approach of computing dynamic diffuse GI with a signed distance fields approximation of the scene and discretizing the space domain of the irradiance function. With this approach, we are able to estimate real-time diffuse GI for dynamic lighting and geometry, without any precomputations and supporting multi-bounce GI, providing good quality lighting and high performance at the same time. Our algorithm is also able to achieve better scalability, and manage both large open scenes and indoor high-detailed scenes without being corrupted by noise.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                My opinions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Knowing the Godot implementation, I find the visuals simply uninspiring.
				</p>
			</li>
			<li>
				<p>
                    It sounds bad for me to go for this solution when I didn't even use this for Godot games.
				</p>
			</li>
			<li>
				<p>
                    I've always found the performance somewhat poor, but it could simply be the low-quality implementation in the editor.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It’s not screen-space (since it doesn’t rely only on what’s visible on screen).
		</p>
	</li>
	<li>
		<p>
            It’s also not a full path-traced solution; instead it’s a form of voxel-based GI accelerated by signed distance fields.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Future in Godot
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    SDFGI will be replaced either way as it has many limitations that can't be resolved (such as slow cascade generation speed).
				</p>
			</li>
			<li>
				<p>
                    A bounded GI implementation to supersede VoxelGI may be added in the future, but it's not guaranteed.
				</p>
			</li>
			<li>
				<p>
                    There are plans to replace it with HDDAGI.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SDFGI vs VoxelGI
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    SDFGI provides better real-time ability than baked lightmaps, but worse real-time ability than VoxelGI.
				</p>
				<ul>
					<li>
						<p>
                            SDFGI supports dynamic lights, but 
							<em>
                                not
							</em>
                            &nbsp;dynamic occluders or dynamic emissive surfaces.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Using 
					<em>
                        Use Occlusion
					</em>
                    &nbsp;has a small performance cost, but it often results in fewer leaks compared to VoxelGI.
				</p>
			</li>
			<li>
				<p>
                    Newer on Godot, when compared to VoxelGI. SDFGI was implemented as a new feature in Godot 4.0 release.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/using_sdfgi.html#doc-using-sdfgi" 
				class="external-link" 
				target="_blank" >
                SDFGI - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=QFKPrDv-Ue8" 
						class="external-link" 
						target="_blank" >
                        SDFGI - Godot Demo
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    SDFGI is something akin to a dynamic real-time lightmap (but it does not requiere unwrapping, nor does it use textures). It’s enabled and it automatically works by generating global illumination for static objects. It does not require raytracing, and it runs in most current (and some years old) dedicated GPUs, even medium-end budget CPUs from some years ago (SDFGI was developed and tested on a GeForce 1060, running at a stable 60 FPS).
				</p>
			</li>
			<li>
				<p>
                    Light changes 
					<strong>
                        are real-time
					</strong>
                    , meaning any change in lighting conditions will result in an 
					<strong>
                        immediate update
					</strong>
                    . Dynamic objects are supported only for receiving light from the environment, but they don’t contribute to lighting. Some degree of support is planned for this eventually, but not immediately.
				</p>
			</li>
			<li>
				<p>
                    SDFGI also supports specular reflections, 
					<strong>
                        both sharp and rough
					</strong>
                    , so full PBR scenes should “just work”. In the image below you can see both of them in checkerboard roughness texture.
				</p>
			</li>
			<li>
				<p>
                    SDFGI is mostly leak free, unlike VCT techniques which are the most common in use today (like SVOGI/GIProbe/etc). As long as walls are thicker than a voxel for a given cascade, light won’t go through.
				</p>
				<ul>
					<li>
						<p>
                            Leaks can be reduced significantly by enabling the 
							<em>
                                Use Occlusion
							</em>
                            &nbsp;property.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    GI level of detail varies depending on the distance between the camera and surface.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Caviats / Issues
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Cascade shifts may be visible when the camera moves fast. This can be made less noticeable by adjusting the cascade sizes or using fog.
						</p>
					</li>
					<li>
						<p>
                            Good reflections and indirect lighting, but beware of leaks and visible cascade shifts.
						</p>
					</li>
					<li>
						<p>
                            SDFGI has some downsides due to its cascaded nature. When the camera moves, cascade shifts may be visible in indirect lighting.
						</p>
						<ul>
							<li>
								<p>
                                    This can be alleviated by adjusting the cascade size, but also by adding fog (which will make distant cascade shifts less noticeable).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Performance will suffer if the camera moves too fast. This can be fixed in two ways:
						</p>
						<ul>
							<li>
								<p>
                                    Ensuring the camera doesn't move too fast in any given situation.
								</p>
							</li>
							<li>
								<p>
                                    Temporarily disabling SDFGI in the Environment resource if the camera needs to be moved at a high speed, then enabling SDFGI once the camera speed slows down.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            When SDFGI is enabled, it will also take some time for global illumination to be fully converged (25 frames by default). This can create a noticeable transition effect while GI is still converging.
						</p>
						<ul>
							<li>
								<p>
                                    To hide this, you can use a ColorRect node that spans the whole viewport and fade it out when switching scenes using an AnimationPlayer node.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The signed distance field is only updated when the camera moves in and out of a cascade. This means that if geometry is modified in the distance, the global illumination appearance will be correct once the camera gets closer. However, if a nearby object with a bake mode set to Static or Dynamic is moved (such as a door), the global illumination will appear incorrect until the camera moves away from the object.
						</p>
					</li>
					<li>
						<p>
                            SDFGI's sharp reflections are only visible on opaque materials. Transparent materials will only use rough reflections, even if the material's roughness is lower than 0.2.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Performance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The number of cascades can be adjusted to balance performance and quality. The number of rays thrown per frame can be adjusted in the Project Settings. The rendering can optionally be performed at half resolution (and then linearly scaled) to improve performance significantly.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Setting up
					</em>
                    :
				</p>
				<ol>
					<li>
						<p>
                            Make sure your MeshInstance nodes have their 
							<strong>
                                Global Illumination &gt; Mode
							</strong>
                            &nbsp;property set to 
							<strong>
                                Static
							</strong>
                            &nbsp;in the inspector.
						</p>
						<ul>
							<li>
								<p>
                                    Any Mesh can receive Indirect Lighting, but only static meshes can contribute to Indirect Lighting.
								</p>
							</li>
							<li>
								<p>
                                    For meshes:
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                Disabled:
											</strong>
										</p>
										<ul>
											<li>
												<p>
                                                    The mesh won't be taken into account in SDFGI generation. The mesh will receive indirect lighting from the scene, but it will not contribute indirect lighting to the scene.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<strong>
                                                Static (default):
											</strong>
										</p>
										<ul>
											<li>
												<p>
                                                    The mesh will be taken into account in SDFGI generation. The mesh will both receive 
													<em>
                                                        and
													</em>
                                                    &nbsp;contribute indirect lighting to the scene. If the mesh is changed in any way after SDFGI is generated, the camera must move away from the object then move back close to it for SDFGI to regenerate. Alternatively, SDFGI can be toggled off and back on. If neither is done, indirect lighting will look incorrect.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<strong>
                                                Dynamic (not supported with SDFGI):
											</strong>
										</p>
										<ul>
											<li>
												<p>
                                                    The mesh won't be taken into account in SDFGI generation. The mesh will receive indirect lighting from the scene, but it will not contribute indirect lighting to the scene.
												</p>
											</li>
											<li>
												<p>
                                                    This acts 
													<em>
                                                        identical
													</em>
                                                    &nbsp;to the Disabled bake mode when using SDFGI.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    For lights:
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                Disabled:
											</strong>
										</p>
										<ul>
											<li>
												<p>
                                                    The light will 
													<em>
                                                        not
													</em>
                                                    &nbsp;be taken into account for SDFGI baking. The light won't contribute indirect lighting to the scene.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<strong>
                                                Static:
											</strong>
										</p>
										<ul>
											<li>
												<p>
                                                    The light will be taken into account for SDFGI baking. The light will contribute indirect lighting to the scene. If the light is changed in any way after baking, indirect lighting will look incorrect until the camera moves away from the light and back (which causes SDFGI to be baked again). will look incorrect. If in doubt, use this mode for level lighting.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<strong>
                                                Dynamic (default):
											</strong>
										</p>
										<ul>
											<li>
												<p>
                                                    The light won't be taken into account for SDFGI baking, but it will still contribute indirect lighting to the scene in real-time. This option is slower compared to 
													<strong>
                                                        Static
													</strong>
                                                    . Only use the 
													<strong>
                                                        Dynamic
													</strong>
                                                    &nbsp;global illumination mode on lights that will change significantly during gameplay.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Add a WorldEnvironment node and create an Environment resource for it.
						</p>
					</li>
					<li>
						<p>
                            Edit the Environment resource, scroll down to the 
							<strong>
                                SDFGI
							</strong>
                            &nbsp;section and unfold it.
						</p>
					</li>
					<li>
						<p>
                            Enable 
							<strong>
                                SDFGI &gt; Enabled
							</strong>
                            .
						</p>
					</li>
				</ol>
				<ul>
					<li>
						<p>
                            SDFGI will automatically follow the camera when it moves, so you do not need to configure extents (unlike VoxelGI).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/using_sdfgi.html#environment-sdfgi-properties" 
						class="external-link" 
						target="_blank" >
                        Properties
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/using_sdfgi.html#adjusting-sdfgi-performance-and-quality" 
						class="external-link" 
						target="_blank" >
                        Performance and Quality
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    To make a specific light emit more or less indirect energy without affecting the amount of direct light emitted by the light, adjust the 
					<strong>
                        Indirect Energy
					</strong>
                    &nbsp;property in the Light3D inspector.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It is not a screen-space effect, so it can provide global illumination for off-screen elements (unlike SSIL).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918145006.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918145148.png" width="400" >
            .
		</p>
	</li>
</ul>
<h5
	id="lighting-grid-hierarchy" >
    Lighting Grid Hierarchy
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.cemyuksel.com/research/lgh/real-time_rendering_with_lgh_i3d2019.pdf" 
				class="external-link" 
				target="_blank" >
                Real-Time Rendering with Lighting Grid Hierarchy - 2019
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.cemyuksel.com/research/lgh/lgh.pdf" 
				class="external-link" 
				target="_blank" >
                Lighting Grid Hierarchy for Self-illuminating Explosions - Siggraph 2017
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.cemyuksel.com/research/lgh/" 
				class="external-link" 
				target="_blank" >
                Lighting Grid Hierarchy
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Focusing on temporal coherency to avoid flickering in animations, we introduce 
			<em>
                lighting grid hierarchy
			</em>
            &nbsp;for approximating the volumetric illumination at different resolutions. Using this structure we can efficiently approximate the lighting at any point inside or outside of the explosion volume as a mixture of lighting contributions from all levels of the hierarchy. As a result, we are able to capture high-frequency details of local illumination, as well as the potentially strong impact of distant illumination. Most importantly, this hierarchical structure allows us to efficiently precompute volumetric shadows, which substantially accelerates the lighting computation. Finally, we provide a scalable approach for computing the multiple scattering of light within the smoke volume using our lighting grid hierarchy.
		</p>
	</li>
	<li>
		<p>
            Ray tracing 
			<em>
                can
			</em>
            &nbsp;be layered on top for visibility injection, but the technique itself does not depend on it.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=BHQ4RhWl-vc" 
				class="external-link" 
				target="_blank" >
                Lighting Grid Hierarchy with Raytracing Hardware Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    100k VPL (100.000 Virtual Point Lights).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="screen-space-directional-occlusion-ssdo" >
    Screen-Space Directional Occlusion (SSDO)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://ascane.github.io/projects/06_ssdo/report.pdf" 
				class="external-link" 
				target="_blank" >
                Real-time Approximated Global Illumination From SSAO to SSDO - 2016
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="precomputed-radiance-transfer-prt" >
    Precomputed Radiance Transfer (PRT)
</h5>
<ul>
	<li>
		<p>
			<strong>
                My understanding
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Based on the explanations in &quot;A Data-Driven Paradigm for Precomputed Radiance Transfer - 2022&quot; and &quot;Neural Precomputed Radiance Transfer - 2022&quot;, I understood that this strategy is an intermediate between baking and dynamic.
				</p>
			</li>
			<li>
				<p>
                    The idea would be to compute different types of lighting on a mesh, choosing which to apply based on the mesh's current direct lighting conditions.
				</p>
			</li>
			<li>
				<p>
                    It uses Spherical Harmonics directly, but another basis can be used.
				</p>
			</li>
			<li>
				<p>
                    ChatGPT:
				</p>
				<ul>
					<li>
						<p>
                            PRT is a technique that moves expensive, direction-dependent light transport calculations offline so that, at runtime, shading under complex (often dynamic) lighting can be evaluated with a small number of dot-products.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://jankautz.com/publications/prtSIG02.pdf" 
				class="external-link" 
				target="_blank" >
                Precomputed Radiance Transfer for Real-Time Rendering in Dynamic, Low-Frequency Lighting Environments - Siggraph 2002
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250921164439.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250921154944.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250921160349.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250921160533.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250921162247.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250921162207.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250921162225.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=k3hzcrjoFbc" 
				class="external-link" 
				target="_blank" >
                A Data-Driven Paradigm for Precomputed Radiance Transfer - Unity 2022
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://arxiv.org/pdf/2206.13112" 
						class="external-link" 
						target="_blank" >
                        A Data-Driven Paradigm for Precomputed Radiance Transfer - Unity 2022
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Very interesting.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921162915.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921162927.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=voyOq7VJfl0" 
				class="external-link" 
				target="_blank" >
                Neural Precomputed Radiance Transfer - 2022
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Neural PRT:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250921160243.png" width="500" >
                            .
						</p>
					</li>
					<li>
						<p>
                            A CNN encoder is the part of a convolutional neural network (CNN) that compresses input data into a compact, meaningful representation called a latent representation. It functions by progressively down-sampling and extracting hierarchical features from the input, such as an image, through a series of convolutional and pooling layers. The goal of the encoder is to reduce the input's dimensionality while retaining essential information, making it a compressed version of the original data that can then be used by a 
							<a
								href="https://www.google.com/search?client=firefox-b-d&cs=1&sca_esv=730c08a984f2ad03&q=decoder&sa=X&ved=2ahUKEwjG282txeqPAxU_DLkGHUz-FOgQxccNegQIBRAB&mstk=AUtExfAVbBz0aoEqs_sqNypyuG83mjn4wS_fhnPddU8y0J29NIhf6yRTh4vEVUQ_JRo4od2X2VFHzl7uOlei5viFjVOo2ubHYl-lOzoZVzSoyHn-pwoefuSFLzyUbrZRSyraUUPn1UR73Cjq92zGAU1UFYc2dLo2WUIHl5vl17vIr3vnnj4&csui=3" 
								class="external-link" 
								target="_blank" >
                                decoder
							</a>
                            &nbsp;for tasks like reconstruction or pixel-level prediction
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921161241.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            &quot;Even with 5 circle harmonic bands (25 coefficients), spherical harmonics tend to cutoff the high frequency angular signals, this is visible on the mirror, for example&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Instead of dealing with rays, PRT deals with functions on a sphere.
		</p>
	</li>
	<li>
		<p>
            Traditional PRT suggests as choice of basis:
		</p>
		<ul>
			<li>
				<p>
                    Spherical Harmonics
				</p>
			</li>
			<li>
				<p>
                    Haar Wavelets.
				</p>
			</li>
			<li>
				<p>
                    Spherical Gaussians.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921155754.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The choice of basis has been one of the main domains of research.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is designed for 
					<em>
                        static
					</em>
                    &nbsp;geometry (or limited deformation) and is primarily targeted at low-frequency environment lighting and shadowing / soft interreflection effects that can be precomputed.
				</p>
			</li>
			<li>
				<p>
                    Partially replaced by real-time ray-tracing / dynamic probe systems for workflows that require runtime changes. PRT is efficient for low-frequency, mostly-static content (precomputation), but for highly dynamic environments engines increasingly use real-time methods (RT + denoising, probe volumes) to handle scene changes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=04YUZ3bWAyg" 
				class="external-link" 
				target="_blank" >
                PRT Probes - The Division 1 - 2016
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It is not normal PRT, but rather PRT Probes.
				</p>
			</li>
			<li>
				<p>
                    I watched about the first 20 minutes and some other segments of the video.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921163440.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921164329.png" width="400" >
                    <img src="assets/image_20250921164606.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921164546.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921165103.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            After considerations, we settled on the Half Life 2 Ambient Cube Basis (HL2), which is not a real basis but 6 vectores aligned; so it requires only six floats.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The probes are placed automatically via a 4x4 meters raycast grid, spawning a probe on every ray hit; also, spawn probes alongside building walls, to avoid them looking flat.
				</p>
			</li>
			<li>
				<p>
                    The storage on disk is via a 2D grid with 64x64 meters, with maximum of 1000 probes, but usually 200 probes per sector. The sectors are streamed in and out as the player moves.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921165504.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250921165706.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Manhattan == Manhattan city map.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="voxel-ambient-occlusion-vxao" >
    Voxel Ambient Occlusion (VXAO)
</h5>
<ul>
	<li>
		<p>
            Not in screen space.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.nvidia.com/en-us/geforce/news/nvidia-vxao-voxel-ambient-occlusion/" 
				class="external-link" 
				target="_blank" >
                Nvidia VXAO - 2016
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Unlike VXGI which controls all illumination, VXAO is only utilized for Ambient Occlusion, enabling us to integrate it into a wider array of games and game engines that use traditional illumination technologies.
		</p>
	</li>
	<li>
		<p>
            It’s more accurate than SSAO and its derivatives, casts deeper, richer shadows that account for even the smallest details in a scene, and runs faster than other competing effects when they’re rendered at a similar quality.
		</p>
	</li>
	<li>
		<p>
            Even still, HBAO+’s Ambient Occlusion shadowing is far from the level of fidelity offered by VXAO, which avoids the caveats of screen space techniques, enabling us to deliver the most accurate and realistic Ambient Occlusion shadowing seen to date.
		</p>
	</li>
	<li>
		<p>
            With VXAO, occlusion and lighting information is gathered from a ‘world space’ voxel representation of the scene, which takes into account a large area around the viewer. Included in this voxelization are objects and details currently invisible to the viewer, and those behind the viewer, too. The result is scene-wide Ambient Occlusion shadowing, instead of ‘screen space’ shadowing based on what you can currently see. This allows AO shadows to be cast into a scene from objects near to the player but just outside of their view, and from occluded objects in the distance large enough to affect the appearance of the scene.
		</p>
	</li>
	<li>
		<p>
            Use on:
		</p>
		<ul>
			<li>
				<p>
                    Rise of the Tomb Raider.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=VWiSex0NhlI" 
				class="external-link" 
				target="_blank" >
                SSAO vs HBAO+ vs VXAO, Rise of the Tomb Raider
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="mssao-multi-resolution-screen-space-ambient-occlusion" >
    MSSAO (Multi-Resolution Screen-Space Ambient Occlusion)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.comp.nus.edu.sg/~lowkl/publications/mssao_cgi2011.pdf" 
				class="external-link" 
				target="_blank" >
                MSSAO 2011
			</a>
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917182637.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            You can combine results from different occlusion radius.
		</p>
	</li>
	<li>
		<p>
            It is a technique from a 2010 paper.
		</p>
	</li>
</ul>
<h5
	id="ssao-screen-space-ambient-occlusion" >
    SSAO (Screen-Space Ambient Occlusion)
</h5>
<ul>
	<li>
		<p>
            “Where should I 
			<em>
                remove
			</em>
            &nbsp;light because it’s blocked?”
		</p>
	</li>
	<li>
		<p>
            Ray Traced Ambient Occlusion itself is an approximation of Indirect Light, and SSAO is an approximation of Ray Traced Ambient Occlusion.
		</p>
		<ul>
			<li>
				<p>
                    So it's an approximation of an approximation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            SSAO only acts on 
			<em>
                ambient light
			</em>
            . It does not affect direct light.
		</p>
	</li>
	<li>
		<p>
            Think of SSAO as a shadow-only pass, faking soft contact shadows.
		</p>
	</li>
	<li>
		<p>
            Ray Traced AO would be the &quot;correct&quot; ambient occlusion, but that is kinda difficult to say as Ambient Occlusion itself is a &quot;fake term&quot;; SSAO approximates it.
		</p>
	</li>
	<li>
		<p>
            It's much faster then Ray Traced AO.
		</p>
	</li>
	<li>
		<p>
            Approximates ambient occlusion as a cheap GI term; bent normals can guide diffuse light injection.
		</p>
	</li>
	<li>
		<p>
            Screen-space sampling; rasterization-based.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/environment_and_post_processing.html#screen-space-ambient-occlusion-ssao" 
				class="external-link" 
				target="_blank" >
                SSAO - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    If you want to force SSAO to work with direct light too, use the 
					<strong>
                        Light Affect
					</strong>
                    &nbsp;parameter. Even though this is not physically correct, some artists like how it looks.
				</p>
			</li>
			<li>
				<p>
                    SSAO looks best when combined with a real source of indirect light, like 
					<em>
                        VoxelGI
					</em>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250917181805.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="combined-adaptive-compute-ambient-occlusion-cacao" >
    Combined Adaptive Compute Ambient Occlusion (CACAO)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://gpuopen.com/fidelityfx-cacao/" 
				class="external-link" 
				target="_blank" >
                AMD FidelityFX Combined Adaptive Compute Ambient Occlusion
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Released in May 2020.
		</p>
	</li>
	<li>
		<p>
            As of 2023, it became part of the AMD FidelityFX SDK.
		</p>
	</li>
	<li>
		<p>
            Updated in May 2025.
		</p>
	</li>
	<li>
		<p>
            &quot;Artist control, etc, but deviates from the rendering equation&quot;.
		</p>
	</li>
</ul>
<h5
	id="screen-space-global-illumination-based-invariance-ssvgi" >
    Screen-Space Global Illumination Based-Invariance (SSVGI)
</h5>
<ul>
	<li>
		<p>
            The author of Radiance Cascading worked on this technique for PoE1.
		</p>
	</li>
	<li>
		<p>
            Uses exclusively image space data.
		</p>
	</li>
	<li>
		<p>
            Calculates GI for every point from scratch.
		</p>
	</li>
	<li>
		<p>
            Still needs denoising.
		</p>
	</li>
	<li>
		<p>
            Uses Screen Space Shadow Hierarchy.
		</p>
		<ul>
			<li>
				<p>
                    &quot;Shadow cascade&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="light-propagation-volumes-lpv" >
    Light Propagation Volumes (LPV)
</h5>
<ul>
	<li>
		<p>
            First introduced by Crytek in 2009.
		</p>
	</li>
	<li>
		<p>
            LV calculation of global illumination consists of three steps:
		</p>
		<ul>
			<li>
				<p>
                    Injection virtual points lights obtained from Reflective Shadow Maps into LPV 3D grid.
				</p>
			</li>
			<li>
				<p>
                    Propagation of light intensity in grid stored in spherical harmonics coefficients.
				</p>
			</li>
			<li>
				<p>
                    Lookup for light intensity in LPV while scene rendering.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            LPV sits in the same family as Voxel-GI (both use a 3D grid) and is functionally closer to runtime probe/volume methods like DDGI than to precomputed PRT — but LPV’s propagation approach and data layout make its behavior and trade-offs distinct.
		</p>
		<ol>
			<li>
				<p>
                    Inject light into a 3D regular grid (the “volume”) from direct light sources or from virtual point lights / reflective shadow maps. The injected values are usually stored as low-order spherical harmonics (SH) or simple directional bands per cell.
				</p>
			</li>
			<li>
				<p>
                    Iteratively propagate those values between neighboring grid cells (a diffusion / scattering sweep). The propagation step moves energy through the grid and approximates multiple diffuse bounces.
				</p>
			</li>
			<li>
				<p>
                    At shading time, the renderer samples the grid (trilinear / tetrahedral interpolation) and uses the sampled radiance/SH to illuminate surfaces (usually only the diffuse term).
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
            Key implementation notes: LPV normally stores very low angular detail (few SH bands or directional channels) and relies on repeated propagation iterations to spread light. It does not explicitly store full scene geometry inside the grid (although depth/normal heuristics can be used to reduce obvious leakage).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    LPV fell out of favor in many production engines because its core design produces persistent, hard-to-fix artifacts (notably light bleeding and poor directional fidelity) and because alternative runtime GI approaches (probe-based DDGI variants, voxel-cone tracing, and hardware-accelerated ray-traced GI) offer better trade-offs for modern, dynamic scenes and artist workflows. The choice is engineering- and platform-dependent; LPV still makes sense in limited cases (very low-cost, low-frequency indirect lighting), but it is no longer the common “go-to” for high-quality dynamic GI in AAA engines.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://dev.epicgames.com/documentation/en-us/unreal-engine/light-propagation-volumes?application_version=4.27" 
				class="external-link" 
				target="_blank" >
                LPV - Unreal Engine 5
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Deprecated in UE5, used in UE4.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://cg.ivd.kit.edu/publications/p2009/LPVIC3_Kaplanyan_2009/LPVIC3_Kaplanyan_2009.pdf?utm_source=chatgpt.com" 
				class="external-link" 
				target="_blank" >
                Light Propagation Volumes - Cry Engine 3 - 2009
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/djbozkosz/Light-Propagation-Volumes" 
				class="external-link" 
				target="_blank" >
                LPV Implementation Demo
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="ambient-color" >
    Ambient Color
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250918204343.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            Usually 2 colors, applied depending on the normal of the surface.
		</p>
	</li>
</ul>
<h5
	id="instant-radiosity-quotvirtual-lightsquot" >
    Instant Radiosity (&quot;Virtual Lights&quot;)
</h5>
<ul>
	<li>
		<p>
            It's not instant, and has nothing to do with the 'Radiosity' method.
		</p>
	</li>
	<li>
		<ol>
			<li>
			</li>
		</ol>
	</li>
	<li>
		<p>
            Approximates GI by spawning virtual point lights (VPLs) from primary light bounces.
		</p>
	</li>
	<li>
		<p>
            Then renders the scene lit by these many point lights (with importance sampling and clamping to reduce artifacts).
		</p>
	</li>
	<li>
		<p>
            It’s an approximation to many-bounce light transport.
		</p>
	</li>
	<li>
		<p>
            The method requires finding secondary bounces to spawn virtual point lights (VPLs). This is traditionally done with ray tracing.
		</p>
		<ul>
			<li>
				<p>
                    However, simplified rasterization approximations (e.g., reflective shadow maps) exist that avoid explicit ray casting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A &quot;Light Source&quot; is the Sun, and a &quot;Virtual Light&quot; is the Moon.
		</p>
	</li>
	<li>
		<p>
            Starting from the light source, generate virtual lights placed where the light illuminates a surface, by sampling random directions from the light source.
		</p>
	</li>
	<li>
		<p>
            The virtual lights account for indirect illumination; the indirect illumination becomes direct illumination from the virtual lights.
		</p>
	</li>
	<li>
		<p>
            It converts the problem of indirect illumination into the problem of rendering many light sources.
		</p>
	</li>
	<li>
		<p>
            It can account for one or many bounces of light; you just need to keep creating virtual lights.
		</p>
	</li>
	<li>
		<p>
            This is the opposite of Path Tracing; it's called 
			<em>
                Light Tracing
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918112329.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            CryEngine 3:
		</p>
		<ul>
			<li>
				<p>
                    This class of approaches is based on the idea of representing indirect lighting as a cloud set of virtual point light sources (VPL). Consequently, this technique has a great potential to speed up with GPU. Its main advantages are&nbsp;&nbsp;good veracity and absence of any scene/lighting/camera constraints. Unfortunately, the main disadvantage of these methods is inadequate performance primarily because of the necessity to render at least 300-400 shadow- casting VPLs for an arbitrary scene to represent the precise solution without artifacts and flickering.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="horizon-based-ambient-occlusion-hbao" >
    Horizon-Based Ambient Occlusion (HBAO)
</h5>
<ul>
	<li>
		<p>
            &quot;Image-Space Horizon-based Ambient Occlusion&quot; - Nvidia Siggraph 2008.
		</p>
	</li>
	<li>
		<p>
            Very expensive trigonometry operations and too slow at the time.
		</p>
	</li>
</ul>
<h5
	id="alchemy-screen-space-ambient-obscurance-alchemyao" >
    Alchemy Screen-Space Ambient Obscurance (AlchemyAO)
</h5>
<ul>
	<li>
		<p>
            HBAO+ is an optimization of this technique.
		</p>
	</li>
</ul>
<h5
	id="metropolis-light-transport-mlt" >
    Metropolis Light Transport (MLT)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://graphics.stanford.edu/papers/metro/metro.pdf" 
				class="external-link" 
				target="_blank" >
                Metropolis Light Transport
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Siggraph 1997.
		</p>
	</li>
	<li>
		<p>
            Monte Carlo method that explores light paths in a “mutation” process, emphasizing important contributions (e.g., caustics).
		</p>
	</li>
	<li>
		<p>
            Ray tracing-based Monte Carlo.
		</p>
	</li>
</ul>
<h5
	id="path-tracing" >
    Path Tracing
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=iOlehM5kNSk" 
				class="external-link" 
				target="_blank" >
                Ray Tracing, Path Tracing, Global Illumination, BVH
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Great video. Very illustrative.
				</p>
			</li>
			<li>
				<p>
                    Path Tracing and Global Illumination:
				</p>
				<ul>
					<li>
						<p>
                            Nothing &quot;new&quot; in the explanations. It's based on a lot of material I studied.
						</p>
					</li>
					<li>
						<p>
                            Sometimes it complicates some explanations, making things seem a bit magical and &quot;untouchable&quot;
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    BVH: Binary Volume Hierarchy.
				</p>
				<ul>
					<li>
						<p>
                            Maybe it's the most relevant explanation.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20251006231423.png" width="400" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20251006231924.png" width="400" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Interesting performance statistics.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The video ends at 22:15.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing/introduction-global-illumination-path-tracing.html" 
				class="external-link" 
				target="_blank" >
                Global Illumination and Path Tracing
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The standard method for computing global illumination today.
		</p>
	</li>
	<li>
		<p>
            Finds light paths starting from the 
			<em>
                camera
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Project a ray and pick a random direction.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918104831.png" width="250" >
            &nbsp;
            <img src="assets/image_20250918105000.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            It tries to find all possible light paths starting from the camera to the light source.
		</p>
	</li>
	<li>
		<p>
            The amount of light paths consider is indicated by the SPP (Samples Per pixel).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918105138.png" width="250" >
            &nbsp;
            <img src="assets/image_20250918105219.png" width="250" >
            &nbsp;
            <img src="assets/image_20250918105246.png" width="250" >
            &nbsp;
            <img src="assets/image_20250918105337.png" width="250" >
            &nbsp;
            <img src="assets/image_20250918105419.png" width="250" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Denoiser
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250918105955.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<ol>
					<li>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    Use the samples from the neighboring pixels, to estimate the indirect illumination for the current pixel.
				</p>
			</li>
			<li>
				<p>
                    AI and Deep Learning is used today.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Spacial Denoising
					</em>
                    :
				</p>
			</li>
			<li>
				<p>
					<em>
                        Temporal Denoising
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Cheaper and it doesn't blur.
						</p>
					</li>
					<li>
						<p>
                            For a game that has a camera moving all the time, you'll have to use:
						</p>
						<ul>
							<li>
								<p>
                                    Motion Vectors.
								</p>
								<ul>
									<li>
										<p>
                                            How things moved between frames.
										</p>
									</li>
									<li>
										<p>
                                            <img src="assets/image_20250918121801.png" width="300" >
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Reject samples that were reprojected incorrectly.
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250918121813.png" width="300" >
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Joint Bileteral Filter
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250918121942.png" width="350" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Takes into account the depth and normals.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250918122051.png" width="350" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    My understanding is that there is less blur based on the depth buffer, in the image on the left.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="photon-mapping" >
    Photon Mapping
</h5>
<ul>
	<li>
		<p>
            1995 to 2001.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://web.cs.wpi.edu/~emmanuel/courses/cs563/write_ups/zackw/photon_mapping/PhotonMapping.html" 
				class="external-link" 
				target="_blank" >
                Photon Mapping
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Two-pass algorithm: first, photons are traced from light sources and stored; second, the radiance is gathered at surfaces to compute illumination.
		</p>
	</li>
	<li>
		<p>
            Handles caustics and diffuse interreflections.
		</p>
	</li>
	<li>
		<p>
            Uses Ray tracing (photon tracing) + data structure (k-d tree for photon storage).
		</p>
	</li>
	<li>
		<p>
            CryEngine 3:
		</p>
		<ul>
			<li>
				<p>
                    These methods are less popular than the others in real-time graphics because of their performance issues. Usually this class of techniques is based on the classical photon-mapping approach. These methods usually use GPU texture fetching and rendering units to accelerate the photon map evaluation. The usual optimizations for these techniques are irradiance caching, importance sampling, and the incremental approach. One drawback of these methods is that the scene needs to be preprocessed to get the unique representation for the photon map. Another problem is photon map updates caused by scene and lighting changes, which leads to highly inconsistent performance and intermittent stalls.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="radiosity" >
    Radiosity
</h5>
<ul>
	<li>
		<ol>
			<li>
			</li>
		</ol>
	</li>
	<li>
		<p>
            Origin of the 
			<em>
                Cornell Box
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Radiosity is a global illumination method that solves light transport between diffuse-only surfaces by discretizing geometry into patches and solving a linear system of energy exchange.
		</p>
	</li>
	<li>
		<p>
            Produces smooth, view-independent GI (often offline or precomputed).
		</p>
	</li>
	<li>
		<p>
            Surface-based; patch-to-patch energy exchange (matrix solve). Ray tracing is optional for visibility (hemicube or ray casting).
		</p>
	</li>
	<li>
		<p>
            It doesn't use ray tracing inherently. Radiosity is based on solving a radiosity matrix (energy exchange between surface patches).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918104614.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918104634.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918104652.png" width="350" >
            .
		</p>
	</li>
</ul>
<h3
	id="lightmaps" >
    Lightmaps
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250918111953.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            It doesn't matter what method we use for computing the GI.
		</p>
	</li>
	<li>
		<p>
            Access the data from a texture; trilinear filter it and we are done.
		</p>
	</li>
	<li>
		<p>
            Easy and cheap.
		</p>
	</li>
	<li>
		<p>
            Only works for static scenes.
		</p>
	</li>
</ul>
<h5
	id="light-maps" >
    Light Maps
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250918112212.png" width="350" >
            .
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250918112234.png" width="174" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=39iBnWTXR8M" 
				class="external-link" 
				target="_blank" >
                Lightmaps Demo - Wicked Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="http://the-witness.net/news/2010/03/graphics-tech-texture-parameterization/" 
				class="external-link" 
				target="_blank" >
                Lightmap Parameterization - The Witness
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="http://the-witness.net/news/2010/09/hemicube-rendering-and-integration/" 
				class="external-link" 
				target="_blank" >
                Hemicube Rendering and Integration - The Witness
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="http://the-witness.net/news/2011/07/irradiance-caching-part-1/" 
				class="external-link" 
				target="_blank" >
                Irradiance Caching Pt1 - The Witness
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.ludicon.com/castano/blog/2014/07/irradiance-caching-continued/" 
				class="external-link" 
				target="_blank" >
                Irradiance Caching Pt2 - The Witness
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.raylib.com/examples/shaders/loader.html?name=shaders_lightmap_rendering" 
				class="external-link" 
				target="_blank" >
                Lightmap in Raylib
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    See the source in VSCode.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Specularity changes based on the angle of the camera, so it cannot be baked into the geometry; this is view dependent.
				</p>
			</li>
			<li>
				<p>
                    No specular indirect lighting baked.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918203936.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="light-bleeding" >
    Light Bleeding
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.unity3d.com/6000.1/Documentation/Manual/ProgressiveLightmapper-UVOverlap.html" 
				class="external-link" 
				target="_blank" >
                Fixing light bleeding in Lightmaps - Unity
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Solutions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If you provide lightmap UVs yourself, add margins using your modeling package.
						</p>
					</li>
					<li>
						<p>
                            ~If Unity automatically generates the lightmap UVs for a Model, you can tell Unity to increase the pack margin. Bla bla bla.
						</p>
					</li>
					<li>
						<p>
                            Increase the resolution:
						</p>
						<ul>
							<li>
								<p>
                                    Of the entire lightmap. This will increase the number of pixels between the charts and therefore reduce the likelihood of bleeding. The downside is that your lightmap may become too large.
								</p>
							</li>
							<li>
								<p>
                                    Of a single GameObject. This allows you to increase lightmap resolution only for GameObjects that have overlapping UVs. Though less likely, this can also increase your lightmap size.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            I believe what Unity means is:
						</p>
						<ul>
							<li>
								<p>
                                    It must use a different texture for lightmaps, overlaid on top of the albedo.
								</p>
							</li>
							<li>
								<p>
                                    Therefore, it makes sense to talk about &quot;increasing the lightmap resolution&quot; since it's a separate texture.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://helpx.adobe.com/substance-3d-bake/common-issues/aliasing-on-uv-seams.html" 
				class="external-link" 
				target="_blank" >
                Aliasing on UV Seams - Adobe
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Solutions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Increase the output texture resolution of the Bakers.
						</p>
					</li>
					<li>
						<p>
                            Increase the Anti-aliasing setting (note: it may take more time to compute).
						</p>
					</li>
					<li>
						<p>
                            Align the UVs to the pixel grid in the UV editor of the 3D modeling software.
						</p>
					</li>
					<li>
						<p>
                            Give a better Texel Ratio to UVs.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                My question
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            the light is baked in, so I guess it makes sense to be a UV issue, causing the texture bleeding
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    devsh:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250901174203.png" width="250" >
                            .
						</p>
					</li>
					<li>
						<p>
                            welcome to the fundamental problem with lightmapping
						</p>
					</li>
					<li>
						<p>
                            Pixar solves it with 
							<a
								href="https://github.com/wdas/ptex" 
								class="external-link" 
								target="_blank" >
                                PTEX
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Per-Face Texture Mapping for Production Rendering&quot;.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            as a mere mortal you need to clamp the max mip level, anisotropy, and add padding texels around every UV island
						</p>
					</li>
					<li>
						<p>
                            you may also want to adjust the way you island your faces
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            Interesting, I've never heard of this. I'm not using mipmap nor AA for now, I'm still setting things up
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Devsh:
				</p>
				<ul>
					<li>
						<p>
                            well then it's bilinear interpolation bleed
						</p>
					</li>
					<li>
						<p>
                            your pixel centers are not on the edge, there are no padding/border pixels.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            so it's not a problem with the UVs?
						</p>
					</li>
					<li>
						<p>
                            I'm a bit confused, is this fixed by implementing AA or mipmap?
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Devsh:
				</p>
				<ul>
					<li>
						<p>
                            no, it's made worse by mip-mapping
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            so, from what I'm seeing, this is caused when generating the lightmap and baking the light color into the albedo texture? The lack of padding or UV overlap, etc. So, from what I'm understanding, this isn't caused by some oversight on my part, but this is an external issue that my render engine could fix at runtime? You said something about &quot;bilinear interpolation bleed&quot; &quot;clamp the max mip level, anisotropy and add padding texels around every UV island&quot;, so I got confused about who's to blame for the artifact, my rendering engine or external software used to generate the lightmap?
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Devsh:
				</p>
				<ul>
					<li>
						<p>
                            both, you need to generate the input data better, and your engine needs to take care not to accidentally enable mip-mapping later on
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Caio:
				</p>
				<ul>
					<li>
						<p>
                            just a final clarification: are you considering that the lightmap is from a separate texture from the albedo, or the light is baked into the albedo? This is a free model, I didn't make the light baking myself. So when you say &quot;generate the input data better&quot;, are you referring to the texture the light was baked into, or some other &quot;input&quot;? Finally, if it is the case that I can't rebake the texture, is there something I can do to reduce the artifact, or are all my options just to keep it from getting worse with mipmapping?
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="post-processing" >
    Post-Processing
</h2>
<h3
	id="color-spaces-hdr-sdr-tonemapping-exposure" >
    Color Spaces, HDR / SDR, ToneMapping, Exposure
</h3>
<h5
	id="color-spaces" >
    Color Spaces
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=AvgCkHrcj90" 
				class="external-link" 
				target="_blank" >
                Simplified Color Theory
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=FTKP0Y9MVus" 
				class="external-link" 
				target="_blank" >
                Color Theory, Vectorscope
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=texTxhcfEkY" 
				class="external-link" 
				target="_blank" >
                Color Correction: Color Spaces, Contrast, Saturation, Brightness, Gamma Correction
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=wbn5ULLtkHs" 
				class="external-link" 
				target="_blank" >
                Order of Post-Processing Effects, HDR, Tone Mapping
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=fv-wlo8yVhk" 
				class="external-link" 
				target="_blank" >
                Color Spaces, sRGB, HSV, RVL, OKLAB
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://oklch.com/#64.54,0.1422,360,100" 
				class="external-link" 
				target="_blank" >
                OKLAB: Color Picker and Converter
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="linear" >
    Linear
</h5>
<pre><code class="language-glsl" data-lang="glsl">vec3 srgb_to_linear_approx(vec3 srgb) {
    return pow(srgb, vec3(2.2));
}

vec3 linear_to_srgb_approx(vec3 linear) {
    return pow(linear, vec3(1.0 / 2.2));
}
vec3 linear_to_srgb(vec3 color) {
    //if going to srgb, clamp from 0 to 1.
    color = clamp(color, vec3(0.0), vec3(1.0));
    const vec3 a = vec3(0.055f);
    return mix((vec3(1.0f) + a) * pow(color.rgb, vec3(1.0f / 2.4f)) - a, 12.92f * color.rgb, lessThan(color.rgb, vec3(0.0031308f)));
}


vec3 srgb_to_linear(vec3 srgb) {
    vec3 cutoff = step(vec3(0.04045), srgb);
    vec3 low    = srgb / 12.92;
    vec3 high   = pow((srgb + 0.055) / 1.055, vec3(2.4));
    return mix(low, high, cutoff);
}

vec3 linear_to_srgb(vec3 linear) {
    vec3 cutoff = step(vec3(0.0031308), linear);
    vec3 low  = linear * 12.92;
    vec3 high  = pow(linear, vec3(1.0/2.4)) * 1.055 - 0.055;
    return mix(low, high, cutoff);
}
</code></pre>
<h5
	id="hdr-sdr-ldr" >
    HDR, SDR, LDR
</h5>
<ul>
	<li>
		<p>
            The word 
			<em>
                dynamic
			</em>
            &nbsp;refers to the range of luminance (brightness) values that can be represented and displayed — from the darkest blacks to the brightest highlights.
		</p>
	</li>
	<li>
		<p>
			<strong>
                HDR (High Dynamic Range):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    A standard that represents a wide range of brightness and color, preserving details in both dark and bright areas.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Brightness
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Can reach 600–2000+ nits depending on the display, allowing much brighter highlights.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Color Gamut
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Often uses Rec.2020 or DCI-P3, covering a wider range of colors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Formats
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Multiple formats exist (HDR10, HDR10+, Dolby Vision, HLG), requiring display and content compatibility.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SDR (Standard Dynamic Range):
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The traditional display standard with limited brightness and color range, typically around 100 nits and Rec.709 gamut.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Brightness
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Typically limited to around 100 nits peak brightness.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Color Gamut
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Typically uses Rec.709 color space (sRGB).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Formats
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Standardized and widely compatible, but visually limited.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        LDR (Low Dynamic Range):
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            A more generic term for images or rendering with restricted tonal range, often limited to 8-bit precision and prone to clipping in highlights and shadows.
						</p>
					</li>
					<li>
						<p>
                            All LDR fits inside SDR; it's an informal subset.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818075403.png" width="275" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818074643.png" width="275" >
            .
		</p>
	</li>
	<li>
		<h5
			id="exposure" >
            Exposure
		</h5>
	</li>
	<li>
		<p>
            In most rendering pipelines, exposure is applied as a simple scalar multiplier on the scene-linear color:
		</p>
		<ul>
			<li>
				<p>
                    <code>color_exposed = color_linear * k</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            where 
            <code>k</code>
            &nbsp;is some gain factor.
		</p>
	</li>
	<li>
		<p>
            Many engines define 
            <code>k</code>
            &nbsp;relative to an exposure offset in 
			<strong>
                stops
			</strong>
            &nbsp;(like in photography). Each stop corresponds to doubling or halving the light.
		</p>
	</li>
	<li>
		<p>
            For example:
		</p>
<pre><code class="language-glsl" data-lang="glsl"> color *= exp2(ev);
</code></pre>
		<ul>
			<li>
				<p>
                    <code>ev</code>
                    &nbsp;= exposure value in stops.
				</p>
			</li>
			<li>
				<p>
                    <code>exp2(ev)</code>
                    &nbsp;= $2^{ev}$.
				</p>
			</li>
			<li>
				<p>
                    <code>ev = +1.0</code>
                    &nbsp;→ multiply color by 2 (one stop brighter).
				</p>
			</li>
			<li>
				<p>
                    <code>ev = -1.0</code>
                    &nbsp;→ multiply color by 0.5 (one stop darker).
				</p>
			</li>
			<li>
				<p>
                    <code>ev = 0.0</code>
                    &nbsp;→ multiply by 1 (no change).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            See https://google.github.io/filament/Filament.md.html#imagingpipeline/physicallybasedcamera for more information.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// Computes the camera's EV100 from exposure settings
// aperture in f-stops
// shutterSpeed in seconds
// sensitivity in ISO
float exposureSettings(float aperture, float shutterSpeed, float sensitivity) {
&nbsp;&nbsp;&nbsp;&nbsp;return log2((aperture * aperture) / shutterSpeed * 100.0 / sensitivity);
}

// Computes the exposure normalization factor from
// the camera's EV100
float exposure(float ev100) {
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0 / (pow(2.0, ev100) * 1.2);
}

float ev100 = exposureSettings(aperture, shutterSpeed, sensitivity);
float exposure = exposure(ev100);

vec4 color = evaluateLighting();
color.rgb *= exposure;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Material
				</p>
				<ul>
					<li>
						<p>
                            Base color: sRGB 0.81, 0, 0
						</p>
					</li>
					<li>
						<p>
                            Metallic: 0
						</p>
					</li>
					<li>
						<p>
                            Roughness: 0
						</p>
					</li>
					<li>
						<p>
                            Reflectance: 0.5
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Indirect light: IBL
				</p>
				<ul>
					<li>
						<p>
                            256×256 cubemap generated by cmgen from office.exr
						</p>
					</li>
					<li>
						<p>
                            Multiplier: 35,000
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Direct light: directional light
				</p>
				<ul>
					<li>
						<p>
                            Linear color: 1.0, 0.96, 0.95
						</p>
					</li>
					<li>
						<p>
                            Intensity: 120,000 lux
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Exposure
				</p>
				<ul>
					<li>
						<p>
                            Aperture: f/16
						</p>
					</li>
					<li>
						<p>
                            Shutter speed: 1/125s
						</p>
					</li>
					<li>
						<p>
                            ISO: 100
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918080857.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tone-mapping" >
    Tone Mapping
</h5>
<ul>
	<li>
		<p>
            Filament: Perform post-processing on the scene-referred data (linear space, before tone-mapping) as much as possible.
		</p>
	</li>
	<li>
		<p>
			<em>
                Range Compression
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Convert HDR luminance to LDR luminance.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Color Space Conversion
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Convert LDR luminance to the desired color space (RGB, XYZ, CMYK, etc).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Baked as LUT
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    “Bakes” the transform:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        3D LUT:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Encodes the full color mapping (linear → display).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        1D LUTs:
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            Sometimes used for individual transfer functions (e.g., gamma, log encoding).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This is less flexible (changing exposure or dynamic response means regenerating the LUT) but can be faster or simpler.
				</p>
			</li>
			<li>
				<p>
                    This allows both dynamic range compression 
					<em>
                        and
					</em>
                    &nbsp;color grading in one lookup.
				</p>
			</li>
			<li>
				<p>
                    Common in offline workflows (film, photography), less common in real-time engines because:
				</p>
				<ul>
					<li>
						<p>
                            Needs large 3D textures for precision.
						</p>
					</li>
					<li>
						<p>
                            Harder to tweak exposure/gamma without regenerating the LUT.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ACES
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Industry-standard color pipeline used in film/VFX.
				</p>
			</li>
			<li>
				<p>
                    ACES defines a full rendering pipeline:
				</p>
				<ol>
					<li>
						<p>
                            Input color space conversion (scene-linear → ACEScg).
						</p>
					</li>
					<li>
						<p>
                            Rendering transform (RRT).
						</p>
					</li>
					<li>
						<p>
                            Output transform (ODT) for the target display (sRGB, Rec.709, HDR10, etc.).
						</p>
						<ul>
							<li>
								<p>
                                    The ODT contains the tone mapping curve that compresses HDR highlights, so the final result isn’t “blown out.”
								</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    If you’re implementing “ACES without LUT” and using the standard analytical approximation (often seen in game engines, e.g. the Narkowicz ACES fit), you are applying that curve. That’s why your results look controlled.
				</p>
			</li>
			<li>
				<p>
                    Core includes a tone-mapping-like step in the RRT+ODT chain.
				</p>
			</li>
			<li>
				<p>
                    The ACES RRT+ODT math is the “recipe.” If you would bake this into a LUT, the LUT would be a “pre-baked version of the recipe” so software can apply it quickly without recalculating everything.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                AgX
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/EaryChow/AgX" 
						class="external-link" 
						target="_blank" >
                        AgX
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://projects.blender.org/blender/blender/pulls/106355" 
						class="external-link" 
						target="_blank" >
                        AgX in Blender
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        AgX without LUT
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            You’re skipping its actual rendering transform, so you’re just doing a color space conversion, not a tonemap.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    AgX is normally delivered and used as a full view transform (shaper + contrast + color transforms) in OCIO configs and as pre-baked LUTs.
				</p>
			</li>
			<li>
				<p>
                    A more recent open-source rendering transform for 3D (often seen in Blender).
				</p>
			</li>
			<li>
				<p>
                    Similar idea to ACES: a defined rendering transform that compresses HDR → display space with filmic-like contrast.
				</p>
			</li>
			<li>
				<p>
                    AgX is newer and designed around filmic contrast with a wider shoulder/roll-off.
				</p>
			</li>
			<li>
				<p>
                    The official AgX distribution is often provided as LUTs (for Blender, Nuke, etc.).
				</p>
			</li>
			<li>
				<p>
                    If you apply only the matrix transforms (input → working space → output primaries) but skip the LUT (the part that encodes the log-like shaper + contrast mapping), you’re basically just viewing scene-linear → display without the tonemapping curve.
				</p>
			</li>
			<li>
				<p>
                    Result: very bright, blown-out highlights.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Luminance visualization for debug
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Implementation of a custom debug tone-mapping operator for luminance visualization:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> vec3 Tonemap_DisplayRange(const vec3 x) {
&nbsp;&nbsp;&nbsp;&nbsp; // The 5th color in the array (cyan) represents middle gray (18%)
&nbsp;&nbsp;&nbsp;&nbsp; // Every stop above or below middle gray causes a color shift
&nbsp;&nbsp;&nbsp;&nbsp; float v = log2(luminance(x) / 0.18);
&nbsp;&nbsp;&nbsp;&nbsp; v = clamp(v + 5.0, 0.0, 15.0);
&nbsp;&nbsp;&nbsp;&nbsp; int index = int(floor(v));
&nbsp;&nbsp;&nbsp;&nbsp; return mix(debugColors[index], debugColors[min(15, index + 1)], fract(v));
 }
 
 const vec3 debugColors[16] = vec3[](
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // black
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.0, 0.1647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// darkest blue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.0, 0.3647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// darker blue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.0, 0.6647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dark blue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.0, 0.9647),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// blue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.9255, 0.9255),&nbsp;&nbsp; // cyan
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.5647, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dark green
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.0, 0.7843, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// green
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(1.0, 1.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // yellow
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.90588, 0.75294, 0.0), // yellow-orange
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(1.0, 0.5647, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// orange
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(1.0, 0.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bright red
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.8392, 0.0, 0.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// red
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(1.0, 0.0, 1.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // magenta
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(0.6, 0.3333, 0.7882),&nbsp;&nbsp; // purple
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3(1.0, 1.0, 1.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// white
 );
</code></pre>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922081941.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="bloom-glow" >
    Bloom / Glow
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/environment_and_post_processing.html#glow" 
				class="external-link" 
				target="_blank" >
                Glow - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The idea of levels is interesting, and the use of a Glow Map is very cool, giving a lens dirt look.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918115611.png" width="750" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Filament Engine code:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec4 surfaceShading() {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 color = evaluateLights();
&nbsp;&nbsp;&nbsp;&nbsp;// rgb = color, w = exposure compensation
&nbsp;&nbsp;&nbsp;&nbsp;vec4 emissive = getEmissive();
&nbsp;&nbsp;&nbsp;&nbsp;color.rgb += emissive.rgb * pow(2.0, ev100 + emissive.w - 3.0);
&nbsp;&nbsp;&nbsp;&nbsp;color.rgb *= exposure;
&nbsp;&nbsp;&nbsp;&nbsp;return color;
}
</code></pre>
<ul>
	<li>
		<p>
            ChatGPT code, I think:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// Note: FBO is FrameBuffer Object (Color Attachment).

// Bright-pass fragment shader (extract bright areas)
#version 330 core
in vec2 vUV;
out vec4 FragColor;

uniform sampler2D sceneTex;&nbsp;&nbsp;&nbsp;&nbsp;// HDR scene texture (RGB, float)
uniform float threshold;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // brightness threshold
uniform float knee;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// soft knee (0..1). 0 = hard threshold

// Convert RGB luminance (sRGB or linear - be consistent with your pipeline)
float luminance(vec3 c) {
&nbsp;&nbsp;&nbsp;&nbsp;// If your sceneTex is linear, use linear luminance.
&nbsp;&nbsp;&nbsp;&nbsp;return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 color = texture(sceneTex, vUV).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;float l = luminance(color);

&nbsp;&nbsp;&nbsp;&nbsp;// smooth threshold (Reinhard-style soft knee)
&nbsp;&nbsp;&nbsp;&nbsp;float t = threshold;
&nbsp;&nbsp;&nbsp;&nbsp;float k = knee * t;
&nbsp;&nbsp;&nbsp;&nbsp;float soft = clamp((l - (t - k)) / (k + 1e-6), 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;float contribution = max(l - t, 0.0) / (max(l, 1e-6)) ; // preserves color hue for very bright
&nbsp;&nbsp;&nbsp;&nbsp;// Blend soft and hard:
&nbsp;&nbsp;&nbsp;&nbsp;float mask = max(contribution, soft);

&nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(color * mask, 1.0);
}

// Separable Gaussian blur fragment shader (use twice: horizontal then vertical)
#version 330 core
in vec2 vUV;
out vec4 FragColor;

uniform sampler2D image;
uniform vec2 texelSize;&nbsp;&nbsp; // 1.0 / textureSize (width, height)
uniform vec2 direction;&nbsp;&nbsp; // (1,0) horizontal pass, (0,1) vertical pass

// 9-tap Gaussian weights (can be adjusted). Symmetric kernel.
const float weights[9] = float[](
&nbsp;&nbsp;&nbsp;&nbsp;0.051, 0.0918, 0.12245, 0.1531, 0.1633, 0.1531, 0.12245, 0.0918, 0.051
);

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 result = vec3(0.0);
&nbsp;&nbsp;&nbsp;&nbsp;// center tap
&nbsp;&nbsp;&nbsp;&nbsp;result += texture(image, vUV).rgb * weights[4];

&nbsp;&nbsp;&nbsp;&nbsp;// sample pairs
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= 4; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 offset = direction * texelSize * float(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 t1 = texture(image, vUV + offset).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 t2 = texture(image, vUV - offset).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float w = weights[4 + i]; // symmetric indexing where center is index 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// weights array arranged so index maps: 0..8 with center at 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += (t1 + t2) * w;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(result, 1.0);
}

// Composite fragment shader (add bloom to scene + optional tonemapping)
#version 330 core
in vec2 vUV;
out vec4 FragColor;

uniform sampler2D sceneTex;&nbsp;&nbsp; // original HDR scene (no bright-pass)
uniform sampler2D bloomTex;&nbsp;&nbsp; // blurred bright-pass
uniform float bloomIntensity; // how much bloom to add
uniform float exposure;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // optional exposure for tonemapping
uniform bool&nbsp;&nbsp;applyTonemap;&nbsp;&nbsp; // whether to apply simple tonemap

vec3 acesFilm(vec3 x) {
&nbsp;&nbsp;&nbsp;&nbsp;// small ACES tone curve approximation (optional)
&nbsp;&nbsp;&nbsp;&nbsp;const float a = 2.51;
&nbsp;&nbsp;&nbsp;&nbsp;const float b = 0.03;
&nbsp;&nbsp;&nbsp;&nbsp;const float c = 2.43;
&nbsp;&nbsp;&nbsp;&nbsp;const float d = 0.59;
&nbsp;&nbsp;&nbsp;&nbsp;const float e = 0.14;
&nbsp;&nbsp;&nbsp;&nbsp;return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
}

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;vec3 hdr = texture(sceneTex, vUV).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 bloom = texture(bloomTex, vUV).rgb;

&nbsp;&nbsp;&nbsp;&nbsp;vec3 combined = hdr + bloom * bloomIntensity;

&nbsp;&nbsp;&nbsp;&nbsp;vec3 mapped = combined;
&nbsp;&nbsp;&nbsp;&nbsp;if (applyTonemap) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapped = acesFilm(combined * exposure);
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// simple exposure clamp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapped = 1.0 - exp(-combined * exposure);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(mapped, 1.0);
}
</code></pre>
<h3
	id="etc" >
    Etc
</h3>
<h5
	id="lut-look-up-table" >
    LUT (Look Up Table)
</h5>
<ul>
	<li>
		<p>
            Applies a color transformation by remapping colors according to a precomputed table. Usually for grading, stylization, or fine-tuned color correction.
		</p>
	</li>
	<li>
		<p>
            Takes already tonemapped LDR (or sometimes linear HDR) colors and remaps them for a particular “look.”
		</p>
	</li>
	<li>
		<p>
			<em>
                1D LUT
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Adjusts a single channel independently (e.g., gamma, exposure).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                3D LUT
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Remaps full RGB triples (commonly used in film and games for grading).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Format
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>.cube</code>
				</p>
			</li>
			<li>
				<p>
                    <code>.png</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=xxlBTiNvYzE" 
				class="external-link" 
				target="_blank" >
                LUT 1D and LUT3D
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Godot LUT Applying
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec3 apply_bcs(vec3 color, vec3 bcs) {
    color = mix(vec3(0.0f), color, bcs.x);
    color = mix(vec3(0.5f), color, bcs.y);
    color = mix(vec3(dot(vec3(1.0f), color) * 0.33333f), color, bcs.z);
    return color;
}

#ifdef USE_1D_LUT
vec3 apply_color_correction(vec3 color) {
    color.r = texture(source_color_correction, vec2(color.r, 0.0f)).r;
    color.g = texture(source_color_correction, vec2(color.g, 0.0f)).g;
    color.b = texture(source_color_correction, vec2(color.b, 0.0f)).b;
    return color;
}
#else
vec3 apply_color_correction(vec3 color) {
    return textureLod(source_color_correction, color, 0.0).rgb;
}
#endif
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                LUT Generation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Code of 
                    <code>genbrdflut.vert</code>
                    &nbsp;and 
                    <code>genbrdflut.frag</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // Vertex Shader
 #version 450
 layout (location = 0) out vec2 outUV;
 void main()
 {
&nbsp;&nbsp;&nbsp;&nbsp; outUV = vec2((gl_VertexIndex &lt;&lt; 1) & 2, gl_VertexIndex & 2);
&nbsp;&nbsp;&nbsp;&nbsp; gl_Position = vec4(outUV * 2.0f - 1.0f, 0.0f, 1.0f);
 }
 
 
 // Frag Shader
 #version 450
 layout (location = 0) in vec2 inUV;
 layout (location = 0) out vec4 outColor;
 layout (constant_id = 0) const uint NUM_SAMPLES = 1024u;
 const float PI = 3.1415926536;
 // Based omn http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
 float random(vec2 co)
 {
&nbsp;&nbsp;&nbsp;&nbsp; float a = 12.9898;
&nbsp;&nbsp;&nbsp;&nbsp; float b = 78.233;
&nbsp;&nbsp;&nbsp;&nbsp; float c = 43758.5453;
&nbsp;&nbsp;&nbsp;&nbsp; float dt= dot(co.xy ,vec2(a,b));
&nbsp;&nbsp;&nbsp;&nbsp; float sn= mod(dt,3.14);
&nbsp;&nbsp;&nbsp;&nbsp; return fract(sin(sn) * c);
 }
 vec2 hammersley2d(uint i, uint N)
 {
&nbsp;&nbsp;&nbsp;&nbsp; // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
&nbsp;&nbsp;&nbsp;&nbsp; uint bits = (i &lt;&lt; 16u) | (i &gt;&gt; 16u);
&nbsp;&nbsp;&nbsp;&nbsp; bits = ((bits & 0x55555555u) &lt;&lt; 1u) | ((bits & 0xAAAAAAAAu) &gt;&gt; 1u);
&nbsp;&nbsp;&nbsp;&nbsp; bits = ((bits & 0x33333333u) &lt;&lt; 2u) | ((bits & 0xCCCCCCCCu) &gt;&gt; 2u);
&nbsp;&nbsp;&nbsp;&nbsp; bits = ((bits & 0x0F0F0F0Fu) &lt;&lt; 4u) | ((bits & 0xF0F0F0F0u) &gt;&gt; 4u);
&nbsp;&nbsp;&nbsp;&nbsp; bits = ((bits & 0x00FF00FFu) &lt;&lt; 8u) | ((bits & 0xFF00FF00u) &gt;&gt; 8u);
&nbsp;&nbsp;&nbsp;&nbsp; float rdi = float(bits) * 2.3283064365386963e-10;
&nbsp;&nbsp;&nbsp;&nbsp; return vec2(float(i) /float(N), rdi);
 }
 // Based on http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_slides.pdf
 vec3 importanceSample_GGX(vec2 Xi, float roughness, vec3 normal)
 {
&nbsp;&nbsp;&nbsp;&nbsp; // Maps a 2D point to a hemisphere with spread based on roughness
&nbsp;&nbsp;&nbsp;&nbsp; float alpha = roughness * roughness;
&nbsp;&nbsp;&nbsp;&nbsp; float phi = 2.0 * PI * Xi.x + random(normal.xz) * 0.1;
&nbsp;&nbsp;&nbsp;&nbsp; float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (alpha*alpha - 1.0) * Xi.y));
&nbsp;&nbsp;&nbsp;&nbsp; float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
&nbsp;&nbsp;&nbsp;&nbsp; // Tangent space
&nbsp;&nbsp;&nbsp;&nbsp; vec3 up = abs(normal.z) &lt; 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 tangentX = normalize(cross(up, normal));
&nbsp;&nbsp;&nbsp;&nbsp; vec3 tangentY = normalize(cross(normal, tangentX));
&nbsp;&nbsp;&nbsp;&nbsp; // Convert to world Space
&nbsp;&nbsp;&nbsp;&nbsp; return normalize(tangentX * H.x + tangentY * H.y + normal * H.z);
 }
 // Geometric Shadowing function
 float G_SchlicksmithGGX(float dotNL, float dotNV, float roughness)
 {
&nbsp;&nbsp;&nbsp;&nbsp; float k = (roughness * roughness) / 2.0;
&nbsp;&nbsp;&nbsp;&nbsp; float GL = dotNL / (dotNL * (1.0 - k) + k);
&nbsp;&nbsp;&nbsp;&nbsp; float GV = dotNV / (dotNV * (1.0 - k) + k);
&nbsp;&nbsp;&nbsp;&nbsp; return GL * GV;
 }
 vec2 BRDF(float NoV, float roughness)
 {
&nbsp;&nbsp;&nbsp;&nbsp; // Normal always points along z-axis for the 2D lookup
&nbsp;&nbsp;&nbsp;&nbsp; const vec3 N = vec3(0.0, 0.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp; vec3 V = vec3(sqrt(1.0 - NoV*NoV), 0.0, NoV);
&nbsp;&nbsp;&nbsp;&nbsp; vec2 LUT = vec2(0.0);
&nbsp;&nbsp;&nbsp;&nbsp; for(uint i = 0u; i &lt; NUM_SAMPLES; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec2 Xi = hammersley2d(i, NUM_SAMPLES);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec3 H = importanceSample_GGX(Xi, roughness, N);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec3 L = 2.0 * dot(V, H) * H - V;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dotNL = max(dot(N, L), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dotNV = max(dot(N, V), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dotVH = max(dot(V, H), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dotNH = max(dot(H, N), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dotNL &gt; 0.0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float G = G_SchlicksmithGGX(dotNL, dotNV, roughness);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float G_Vis = (G * dotVH) / (dotNH * dotNV);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Fc = pow(1.0 - dotVH, 5.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LUT += vec2((1.0 - Fc) * G_Vis, Fc * G_Vis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; return LUT / float(NUM_SAMPLES);
 }
 void main()
 {
&nbsp;&nbsp;&nbsp;&nbsp; outColor = vec4(BRDF(inUV.s, 1.0-inUV.t), 0.0, 1.0);
 }
</code></pre>
	</li>
</ul>
<h5
	id="brightness-contrast-saturation-bcs" >
    Brightness, Contrast, Saturation (BCS)
</h5>
<ul>
	<li>
		<p>
			<strong>
                Brightness, Contrast, Saturation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>bcs.x</code>
                    &nbsp;→ 
					<strong>
                        brightness/contrast scaling
					</strong>
                    &nbsp;(closer to contrast, but with black reference).
				</p>
			</li>
			<li>
				<p>
                    <code>bcs.y</code>
                    &nbsp;→ 
					<strong>
                        bias toward mid-gray
					</strong>
                    &nbsp;(brightness adjustment).
				</p>
			</li>
			<li>
				<p>
                    <code>bcs.z</code>
                    &nbsp;→ 
					<strong>
                        saturation
					</strong>
                    &nbsp;(grayscale ↔ color).
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// GODOT
vec3 apply_bcs(vec3 color, vec3 bcs) {
    color = mix(vec3(0.0f), color, bcs.x);
    color = mix(vec3(0.5f), color, bcs.y);
    color = mix(vec3(dot(vec3(1.0f), color) * 0.33333f), color, bcs.z);
    return color;
}
</code></pre>
<h2
	id="anti-aliasing" >
    Anti-Aliasing
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/3d_antialiasing.html" 
				class="external-link" 
				target="_blank" >
                Anti-Aliasing in Godot 4
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="dlaa-dlss" >
    DLAA / DLSS
</h5>
<ul>
	<li>
		<p>
            Deep learning approaches.
		</p>
	</li>
	<li>
		<p>
            Use dedicated HW (tensor cores) for learned reconstruction.
		</p>
	</li>
	<li>
		<p>
            Can be used purely for AA (DLAA) or for upscaling+AA (DLSS).
		</p>
	</li>
	<li>
		<p>
            Good quality but hardware- and driver-dependent.
		</p>
	</li>
	<li>
		<p>
            Neural-network–based temporal method, no upscaling. Produces very high-quality AA, sharper than TAA, with excellent stability and minimal ghosting.
		</p>
	</li>
	<li>
		<p>
            Limitation: only available on RTX-class GPUs with Tensor cores.
		</p>
	</li>
</ul>
<h5
	id="smaa-subpixel-morphological-anti-aliasing" >
    SMAA (Subpixel Morphological Anti-Aliasing)
</h5>
<ul>
	<li>
		<p>
            Screen-space post-process filter.
		</p>
	</li>
	<li>
		<p>
            Enhanced morphological approach with pattern detection and optional temporal/supersampling modes.
		</p>
	</li>
	<li>
		<p>
            Better quality than FXAA for subpixel details.
		</p>
	</li>
	<li>
		<p>
            Image-based edge detection + pattern matching + blending. Optional 
			<em>
                SMAA T2x
			</em>
            &nbsp;(temporal) and 
			<em>
                SMAA 4x
			</em>
            &nbsp;(spatial + temporal + supersampling) modes.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Pros:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Good quality / cost balance; preserves more detail than FXAA.
				</p>
			</li>
			<li>
				<p>
                    Preserves more detail than FXAA/MLAA.
				</p>
			</li>
			<li>
				<p>
                    Detects diagonal/subpixel edges better.
				</p>
			</li>
			<li>
				<p>
                    Simple to integrate (one or two passes).
				</p>
			</li>
			<li>
				<p>
                    Stable cost, doesn’t require motion vectors.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cons:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Still a post-process (no true geometric sampling), optional temporal features add complexity.
				</p>
			</li>
			<li>
				<p>
                    Still a screen-space morphological filter: cannot fix shader aliasing or subpixel shimmering in motion.
				</p>
			</li>
			<li>
				<p>
                    Higher cost than FXAA but still lighter than MSAA/TAA.
				</p>
			</li>
			<li>
				<p>
                    Temporal variants (T2x, 4x) require history management, increasing complexity.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="cmaa-conservative-morphological-anti-aliasing" >
    CMAA (Conservative Morphological Anti-Aliasing)
</h5>
<ul>
	<li>
		<p>
            Screen-space post-process filter.
		</p>
	</li>
	<li>
		<p>
            Lightweight post-process edge filter, designed as a cheaper alternative to SMAA/FXAA.
		</p>
	</li>
	<li>
		<p>
            Its design goals are to be a better alternative to FXAA by:
		</p>
		<ol>
			<li>
				<p>
                    Being minimally invasive so it can be acceptable as a replacement in a wide range of applications, including worst case scenarios such as text, repeating patterns, certain geometries (power lines, mesh fences, foliage), and moving images.
				</p>
			</li>
			<li>
				<p>
                    Running efficiently on low-medium range GPU hardware, such as integrated GPUs (or, in our case, mobile GPUs).
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
            CMAA has four basic logical steps:
		</p>
		<ol>
			<li>
				<p>
                    Image analysis for colour discontinuities (afterwards stored in a local compressed 'edge' buffer). The method used is not unique to CMAA.
				</p>
			</li>
			<li>
				<p>
                    Extracting locally dominant edges with a small kernel. (Unique variation of existing algorithms.)
				</p>
			</li>
			<li>
				<p>
                    Handling of simple shapes.
				</p>
			</li>
			<li>
				<p>
                    Handling of symmetrical long edge shapes. (Unique take on the original MLAA shape handling algorithm.)
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<strong>
                Pros:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Very low GPU cost.
				</p>
			</li>
			<li>
				<p>
                    Preserves sharpness better than FXAA in many cases.
				</p>
			</li>
			<li>
				<p>
                    Good fit for low-power or bandwidth-limited platforms.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cons:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Lower quality than SMAA (weaker on diagonal/subpixel edges).
				</p>
			</li>
			<li>
				<p>
                    No temporal stability; flickering/shimmering remains in motion.
				</p>
			</li>
			<li>
				<p>
                    Less widely adopted/documented compared to SMAA.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://developer.samsung.com/galaxy-gamedev/blog/en/2021/06/01/using-conservative-morphological-anti-aliasing-to-improve-game-visuals?utm_source=chatgpt.com" 
				class="external-link" 
				target="_blank" >
                Samsung - Using CMAA to improve visuals
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="fxaa-fast-approximate-anti-aliasing" >
    FXAA (Fast Approximate Anti-Aliasing)
</h5>
<ul>
	<li>
		<p>
            Single-pass post-process edge detection + blur across edges. Very cheap.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Pros:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Minimal cost, easy to integrate.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cons:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Blurs fine detail; cannot fix shader aliasing that is not visible as contrast edges.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="taa-txaa-temporal-anti-aliasing" >
    <s>TAA / TXAA (Temporal Anti-Aliasing)</s>
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=V3y1Xn1CEKM" 
				class="external-link" 
				target="_blank" >
                About and implementation details
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            TXAA is Nvidia’s branded temporal approach that combines MSAA + post filters.
		</p>
	</li>
	<li>
		<p>
            Reduced motion blur, but has a lot of overall blur.
		</p>
	</li>
	<li>
		<p>
            Jitter camera/sample positions per frame; blend current frame with reprojected history using motion vectors.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Pros:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Very effective at removing temporal shimmer and approximating supersampling without shading every sample.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cons:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Requires motion vectors, depth history, good stationary/visibility rejection; can cause ghosting and blur; tuning is scene- and engine-dependent.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Opinions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Playing some modern games can be really fatiguing because TAA makes things look just out-of-focus enough to find myself reflexively squinting at them, which ain't great for eye-health.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="msaa-multisample-anti-aliasing" >
    MSAA (Multisample Anti-Aliasing)
</h5>
<ul>
	<li>
		<p>
            <a href="Vulkan.html#Multisampling Anti-Aliasing (MSAA)">
            Vulkan#Multisampling Anti-Aliasing (MSAA)
            </a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/msaa/README.html" 
				class="external-link" 
				target="_blank" >
                Vulkan Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Multiple coverage samples per pixel calculated during rasterization; shading can be either per-sample or per-pixel depending on pipeline settings.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Pros:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Correct geometric edge AA, stable across frames, no history artifacts.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Cons:
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Multiplies memory bandwidth and (potentially) fragment-shading cost.
				</p>
			</li>
			<li>
				<p>
                    Poor fit for deferred shading unless you maintain multisampled G-buffers or use expensive workarounds.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=jJzJvuM4nZw" 
				class="external-link" 
				target="_blank" >
                MSAA in Vulkan
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Cool.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=jNR5EiqA05c" 
				class="external-link" 
				target="_blank" >
                Advanced video on the subject
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I don't like this guy AT ALL, omfg.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="mfaa-multi-frame-sampled-anti-aliasing" >
    MFAA (Multi-Frame Sampled Anti-Aliasing)
</h5>
<ul>
	<li>
		<p>
            Driver/GPU alternates sample patterns across frames and accumulates to approximate higher-sample MSAA cheaply. Driver-level, not always available.
		</p>
	</li>
	<li>
		<p>
            Can achieve MSAA-like appearance at lower immediate cost, but depends on driver &amp; GPU; not a universal solution for engine-level integration.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=Nef6yWYu0-I" 
				class="external-link" 
				target="_blank" >
                NVIDIA - MSAA and MFAA
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="light-path-rendering-method" >
    Light Path / Rendering Method
</h2>
<ul>
	<li>
		<p>
            <img src="assets/image_20250924121245.png" width="600" >
            .
		</p>
		<ul>
			<li>
				<p>
                    From the Real-Time Rendering 4th Edition.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922203446.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    By Ola Olsson.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="forward-rendering" >
    Forward Rendering
</h3>
<h4
	id="forward" >
    Forward
</h4>
<ul>
	<li>
		<p>
            Geometry is shaded as it is drawn. For each triangle/pixel, the fragment shader loops over the lights that affect that object (or uses some per-object light set).
		</p>
	</li>
	<li>
		<p>
            Lighting for a fragment is computed when that fragment is shaded, using the set of lights you feed to that draw call/shader.
		</p>
	</li>
	<li>
		<p>
            Shading and output to the final render target happen in one pass.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909115709.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Overdraw happens, as the back triangle is 
					<em>
                        shaded
					</em>
                    , but the front triangle overwrites the color on the screen.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909082543.png" width="350" >
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Multipass forward rendering&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909083021.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909082949.png" width="350" >
            .
		</p>
	</li>
</ul>
<h4
	id="tiled-forward-shading" >
    Tiled Forward Shading
</h4>
<ul>
	<li>
		<p>
            Tiled shading can be applied to both forward and deferred rendering methods.
		</p>
	</li>
	<li>
		<p>
            The idea is to split the screen into a grid of tiles and, for each tile, find the list of lights that affect the pixels within that tile.
		</p>
	</li>
	<li>
		<p>
            This has the advantage of reducing overdraw (in deferred rendering) and shading computations of large objects (in forward rendering).
		</p>
	</li>
	<li>
		<p>
            However, this technique suffers from depth discontinuity issues that can lead to large amounts of extraneous work.
		</p>
	</li>
</ul>
<h5
	id="gathering-the-lights" >
    Gathering the lights
</h5>
<ul>
	<li>
		<p>
            We now need to access all relevant lights for each pixel sequentially.
		</p>
	</li>
	<li>
		<p>
            Just using a global list of lights is, of course, terribly inefficient.
		</p>
	</li>
	<li>
		<p>
            On the other hand, creating lists of lights for each pixel individually is both slow and requires lots of storage.
		</p>
	</li>
	<li>
		<p>
            Tiled shading strikes a balance, where we create lists for tiles of pixels.
		</p>
	</li>
	<li>
		<p>
            The list must be conservative, storing all lights that may affect any sample within the tile.
		</p>
	</li>
	<li>
		<p>
            So we trade some compute performance for bandwidth, which, as we have seen, is a good tradeoff on modern GPUs.
		</p>
	</li>
	<li>
		<p>
            Each tile contains a single list of all the lights that might influence any of the pixels inside.
		</p>
	</li>
	<li>
		<p>
            This list is shared between the pixels, so overhead for list maintenance and fetching is low.
		</p>
	</li>
</ul>
<h5
	id="constructing-the-list" >
    Constructing the list
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250922175337.png" width="350" >
            <img src="assets/image_20250922175354.png" width="350" >
            <img src="assets/image_20250922175450.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            For each light, establish the screen space bounding box, illustrated for the green light.
		</p>
	</li>
	<li>
		<p>
            Then add the index of the light to all overlapped tiles.
		</p>
	</li>
	<li>
		<p>
            Then repeat this process for all remaining lights.
		</p>
	</li>
	<li>
		<p>
            The illustration only shows the counts, so you need to imagine the lists being built as well.
		</p>
	</li>
	<li>
		<p>
            In practice, we’d also do a conservative per-tile min/max depth test to cull away lights occupying empty space.
		</p>
	</li>
</ul>
<h5
	id="vertex-shader" >
    Vertex Shader
</h5>
<ul>
	<li>
		<p>
            Vertex Output:
		</p>
<pre><code class="language-glsl" data-lang="glsl"> struct VertexShaderOutput
 {
&nbsp;&nbsp;&nbsp;&nbsp; float3 positionVS&nbsp;&nbsp; : TEXCOORD0;&nbsp;&nbsp;&nbsp;&nbsp;// View space position.
&nbsp;&nbsp;&nbsp;&nbsp; float2 texCoord&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD1;&nbsp;&nbsp;&nbsp;&nbsp;// Texture coordinate
&nbsp;&nbsp;&nbsp;&nbsp; float3 tangentVS&nbsp;&nbsp;&nbsp;&nbsp;: TANGENT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// View space tangent.
&nbsp;&nbsp;&nbsp;&nbsp; float3 binormalVS&nbsp;&nbsp; : BINORMAL;&nbsp;&nbsp;&nbsp;&nbsp; // View space binormal.
&nbsp;&nbsp;&nbsp;&nbsp; float3 normalVS&nbsp;&nbsp;&nbsp;&nbsp; : NORMAL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // View space normal.
&nbsp;&nbsp;&nbsp;&nbsp; float4 position&nbsp;&nbsp;&nbsp;&nbsp; : SV_POSITION;&nbsp;&nbsp;// Clip space position.
 };
</code></pre>
		<ul>
			<li>
				<p>
                    I chose to do all of the lighting in view space, as opposed to world space, because it is easier to work in view space coordinates when implementing deferred shading and forward+ rendering techniques.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>SV_POSITION</code>
                    &nbsp;semantic is applied to the output value from the vertex shader to specify that the value is used as the clip space position, but this semantic can also be applied to an input variable of a pixel shader. When 
                    <code>SV_POSITION</code>
                    &nbsp;is used as an input semantic to a pixel shader, the value is the position of the pixel in screen space. In both the deferred shading and the forward+ shaders, I will use this semantic to get the screen space position of the current pixel.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> VertexShaderOutput VS_main( AppData IN )
 {
&nbsp;&nbsp;&nbsp;&nbsp; VertexShaderOutput OUT;
 
&nbsp;&nbsp;&nbsp;&nbsp; OUT.position = mul( ModelViewProjection, float4( IN.position, 1.0f ) );
 
&nbsp;&nbsp;&nbsp;&nbsp; OUT.positionVS = mul( ModelView, float4( IN.position, 1.0f ) ).xyz;
&nbsp;&nbsp;&nbsp;&nbsp; OUT.tangentVS = mul( ( float3x3 )ModelView, IN.tangent );
&nbsp;&nbsp;&nbsp;&nbsp; OUT.binormalVS = mul( ( float3x3 )ModelView, IN.binormal );
&nbsp;&nbsp;&nbsp;&nbsp; OUT.normalVS = mul( ( float3x3 )ModelView, IN.normal );
 
&nbsp;&nbsp;&nbsp;&nbsp; OUT.texCoord = IN.texCoord;
 
&nbsp;&nbsp;&nbsp;&nbsp; return OUT;
 }
</code></pre>
		<ul>
			<li>
				<p>
                    You will notice that I am pre-multiplying the input vectors by the matrices. This indicates that the matrices are stored in column-major order by default.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fragment-shader-inputs" >
    Fragment Shader Inputs
</h5>
<ul>
	<li>
		<p>
			<strong>
                Material
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Since some material properties can also have an associated texture (for example, diffuse textures, specular textures, or normal textures), we will also use the material to indicate if those textures are present on the object.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> struct Material
 {
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;GlobalAmbient;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;AmbientColor;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;EmissiveColor;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;DiffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;SpecularColor;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; // Reflective value.
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;Reflectance;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp; Opacity;
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp; SpecularPower;
&nbsp;&nbsp;&nbsp;&nbsp; // For transparent materials, IOR &gt; 0.
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp; IndexOfRefraction;
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasAmbientTexture;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasEmissiveTexture;
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasDiffuseTexture;
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasSpecularTexture;
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasSpecularPowerTexture;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasNormalTexture;
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasBumpTexture;
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;HasOpacityTexture;
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp; BumpIntensity;
&nbsp;&nbsp;&nbsp;&nbsp; //-------------------------- ( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp; SpecularScale;
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp; AlphaThreshold;
&nbsp;&nbsp;&nbsp;&nbsp; float2&nbsp;&nbsp;Padding;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------- ( 16 bytes )
 };&nbsp;&nbsp;//--------------------------- ( 16 * 10 = 160 bytes )
</code></pre>
		<ul>
			<li>
				<p>
                    <code>GlobalAmbient</code>
				</p>
				<ul>
					<li>
						<p>
                            Describes the ambient contribution applied to all objects in the scene globally. Technically, this variable should be a global variable (not specific to a single object), but since there is only a single material at a time in the pixel shader, it’s fine to put it here.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Opacity</code>
				</p>
				<ul>
					<li>
						<p>
                            Determines the total opacity of an object. This value can make objects appear transparent. This property is used to render semi-transparent objects in the transparent pass. If the opacity value is less than one (1 being fully opaque and 0 being fully transparent), the object is considered transparent and rendered in the transparent pass instead of the opaque pass.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SpecularPower</code>
				</p>
				<ul>
					<li>
						<p>
                            Determines how shiny the object appears.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>IndexOfRefraction</code>
				</p>
				<ul>
					<li>
						<p>
                            Can be applied to objects that should refract light through them. Since refraction requires environment mapping techniques not implemented in this experiment, this variable will not be used here.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>BumpIntensity</code>
				</p>
				<ul>
					<li>
						<p>
                            If a model has a bump map, the material’s 
                            <code>HasBumpTexture</code>
                            &nbsp;property is set to 
                            <code>true</code>
                            &nbsp;and the model is bump-mapped instead of normal-mapped.
						</p>
					</li>
					<li>
						<p>
                            Normal and bump maps are mutually exclusive, so they can reuse the same texture slot assignment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SpecularScale</code>
				</p>
				<ul>
					<li>
						<p>
                            Scales the specular power value read from a specular power texture. Since textures usually store values as unsigned normalized values, when sampling from the texture the value is read as a floating-point value in the range of 
                            <code>[0..1]</code>
                            . A specular power of 1.0 doesn’t make much sense, so the specular power value read from the texture will be scaled by 
                            <code>SpecularScale</code>
                            &nbsp;before being used for the final lighting computation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>AlphaThreshold</code>
				</p>
				<ul>
					<li>
						<p>
                            Can be used to discard pixels whose opacity is below a certain value using the “discard” command in the pixel shader. This is useful for “cut-out” materials where the object does not need alpha blending but should have holes (for example, a chain-link fence).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The material properties are passed to the pixel shader using a constant buffer.
		</p>
<pre><code class="language-glsl" data-lang="glsl"> cbuffer Material : register( b2 )
 {
&nbsp;&nbsp;&nbsp;&nbsp; Material Mat;
 };

 Texture2D AmbientTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: register( t0 );
 Texture2D EmissiveTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t1 );
 Texture2D DiffuseTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: register( t2 );
 Texture2D SpecularTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t3 );
 Texture2D SpecularPowerTexture&nbsp;&nbsp;: register( t4 );
 Texture2D NormalTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t5 );
 Texture2D BumpTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : register( t6 );
 Texture2D OpacityTexture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: register( t7 );&nbsp;&nbsp;&nbsp;&nbsp;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Lights
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> StructuredBuffer&lt;uint&gt; LightIndexList: register(&nbsp;&nbsp;t9 );
 Texture2D&lt;uint2&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LightGrid:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register( t10 );
 
 struct Light
 {
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Position for point and spot lights (World space).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp; PositionWS;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Direction for spot and directional lights (World space).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp; DirectionWS;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Position for point and spot lights (View space).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp; PositionVS;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Direction for spot and directional lights (View space).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp; DirectionVS;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Color of the light. Diffuse and specular colors are not separated.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp; Color;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * The half angle of the spotlight cone.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;SpotlightAngle;
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * The range of the light.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;Range;
 
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* The intensity of the light.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;Intensity;
 
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Disable or enable the light.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;Enabled;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 bytes )
 
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Is the light selected in the editor?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;Selected;
 
&nbsp;&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * The type of the light.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; uint&nbsp;&nbsp;&nbsp;&nbsp;Type;
&nbsp;&nbsp;&nbsp;&nbsp; float2&nbsp;&nbsp;Padding;
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 bytes )
&nbsp;&nbsp;&nbsp;&nbsp; //--------------------------------------------------------------( 16 * 7 = 112 bytes )
 };
</code></pre>
		<ul>
			<li>
				<p>
                    <code>SpotlightAngle</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the half-angle of the spotlight cone expressed in degrees. Working in degrees is more intuitive than in radians. The spotlight angle is converted to radians in the shader when computing the cosine of the angle between the spotlight direction and the light vector.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Range</code>
				</p>
				<ul>
					<li>
						<p>
                            For point lights, the range is the radius of the sphere that represents the light; for spotlights, it’s the length of the cone that represents the light. Directional lights don’t use range because they are considered infinitely far away, pointing in the same direction everywhere.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Intensity</code>
				</p>
				<ul>
					<li>
						<p>
                            Modulates the computed light contribution. By default, this value is 1 but can make some lights brighter or dimmer than others.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Enabled</code>
				</p>
				<ul>
					<li>
						<p>
                            Lights with 
                            <code>Enabled</code>
                            &nbsp;set to 
                            <code>false</code>
                            &nbsp;are skipped in the shader.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Selected</code>
				</p>
				<ul>
					<li>
						<p>
                            When a light is selected in the scene, its visual representation appears darker (less transparent) to indicate selection.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>Type</code>
				</p>
				<ul>
					<li>
						<p>
                            Can have one of the following values:
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl"> #define POINT_LIGHT 0
 #define SPOT_LIGHT 1
 #define DIRECTIONAL_LIGHT 2
</code></pre>
			</li>
			<li>
				<p>
                    Spot lights, point lights and directional lights are not separated into different structs and all of the properties necessary to define any of those light types are stored in a single struct.
				</p>
			</li>
			<li>
				<p>
                    The Position variable only applies to point and spot lights while the Direction variable only applies to spot and directional lights.
				</p>
			</li>
			<li>
				<p>
                    I store both world space and view space position and direction vectors because I find it easier to work in world space in the application then convert the world space vectors to view space before uploading the lights array to the GPU.
				</p>
			</li>
			<li>
				<p>
                    This way I do not need to maintain multiple light lists at the cost of additional space that is required on the GPU. But even 10,000 lights only require 1.12 MB on the GPU so I figured this was a reasonable sacrifice. But minimizing the size of the light structs could have a positive impact on caching on the GPU and improve rendering performance.
				</p>
			</li>
			<li>
				<p>
                    I chose not to separate the diffuse and specular color contributions because it is rare that these values differ.
				</p>
			</li>
			<li>
				<p>
                    The lights array is accessed through a 
					<strong>
                        StructuredBuffer
					</strong>
                    . Most lighting shader implementations will use a constant buffer to store the lights array but constant buffers are limited to 64 KB in size which means that it would be limited to about 570 lights before running out of constant memory on the GPU. Structured buffers are stored in texture memory which is limited to the amount of texture memory available on the GPU (usually in the GB range on desktop GPUs). Texture memory is also very fast on most GPUs so storing the lights in a structured buffer did not impose a performance impact. In fact, on my particular GPU (NVIDIA GeForce GTX 680) I noticed a considerable performance improvement when I moved the lights array to a structure buffer.
				</p>
<pre><code class="language-glsl" data-lang="glsl"> StructuredBuffer&lt;Light&gt; Lights : register( t8 );
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fragment-shader" >
    Fragment Shader
</h5>
<pre><code class="language-glsl" data-lang="glsl">
float3 ExpandNormal( float3 n )
{
&nbsp;&nbsp;&nbsp;&nbsp;return n * 2.0f - 1.0f;
}

float4 DoNormalMapping( float3x3 TBN, Texture2D tex, sampler s, float2 uv )
{
&nbsp;&nbsp;&nbsp;&nbsp;float3 normal = tex.Sample( s, uv ).xyz;
&nbsp;&nbsp;&nbsp;&nbsp;normal = ExpandNormal( normal );

&nbsp;&nbsp;&nbsp;&nbsp;// Transform normal from tangent space to view space.
&nbsp;&nbsp;&nbsp;&nbsp;normal = mul( normal, TBN );
&nbsp;&nbsp;&nbsp;&nbsp;return normalize( float4( normal, 0 ) );
}

float4 DoBumpMapping( float3x3 TBN, Texture2D tex, sampler s, float2 uv, float bumpScale )
{
&nbsp;&nbsp;&nbsp;&nbsp;// Sample the heightmap at the current texture coordinate.
&nbsp;&nbsp;&nbsp;&nbsp;float height = tex.Sample( s, uv ).r * bumpScale;
&nbsp;&nbsp;&nbsp;&nbsp;// Sample the heightmap in the U texture coordinate direction.
&nbsp;&nbsp;&nbsp;&nbsp;float heightU = tex.Sample( s, uv, int2( 1, 0 ) ).r * bumpScale;
&nbsp;&nbsp;&nbsp;&nbsp;// Sample the heightmap in the V texture coordinate direction.
&nbsp;&nbsp;&nbsp;&nbsp;float heightV = tex.Sample( s, uv, int2( 0, 1 ) ).r * bumpScale;

&nbsp;&nbsp;&nbsp;&nbsp;float3 p = { 0, 0, height };
&nbsp;&nbsp;&nbsp;&nbsp;float3 pU = { 1, 0, heightU };
&nbsp;&nbsp;&nbsp;&nbsp;float3 pV = { 0, 1, heightV };

&nbsp;&nbsp;&nbsp;&nbsp;// normal = tangent x bitangent
&nbsp;&nbsp;&nbsp;&nbsp;float3 normal = cross( normalize(pU - p), normalize(pV - p) );

&nbsp;&nbsp;&nbsp;&nbsp;// Transform normal from tangent space to view space.
&nbsp;&nbsp;&nbsp;&nbsp;normal = mul( normal, TBN );

&nbsp;&nbsp;&nbsp;&nbsp;return float4( normal, 0 );
}

float4 DoDiffuse( Light light, float4 L, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;float NdotL = max( dot( N, L ), 0 );
&nbsp;&nbsp;&nbsp;&nbsp;return light.Color * NdotL;
}

float4 DoSpecular( Light light, Material material, float4 V, float4 L, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;float4 R = normalize( reflect( -L, N ) );
&nbsp;&nbsp;&nbsp;&nbsp;float RdotV = max( dot( R, V ), 0 );

&nbsp;&nbsp;&nbsp;&nbsp;return light.Color * pow( RdotV, material.SpecularPower );
}

// Compute the attenuation based on the range of the light.
float DoAttenuation( Light light, float d )
{
&nbsp;&nbsp;&nbsp;&nbsp;return 1.0f - smoothstep( light.Range * 0.75f, light.Range, d );
}

LightingResult DoPointLight( Light light, Material mat, float4 V, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result;

&nbsp;&nbsp;&nbsp;&nbsp;float4 L = light.PositionVS - P;
&nbsp;&nbsp;&nbsp;&nbsp;float distance = length( L );
&nbsp;&nbsp;&nbsp;&nbsp;L = L / distance;

&nbsp;&nbsp;&nbsp;&nbsp;float attenuation = DoAttenuation( light, distance );

&nbsp;&nbsp;&nbsp;&nbsp;result.Diffuse = DoDiffuse( light, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attenuation * light.Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;result.Specular = DoSpecular( light, mat, V, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation * light.Intensity;

&nbsp;&nbsp;&nbsp;&nbsp;return result;
}


float DoSpotCone( Light light, float4 L )
{
&nbsp;&nbsp;&nbsp;&nbsp;// If the cosine angle of the light's direction 
&nbsp;&nbsp;&nbsp;&nbsp;// vector and the vector from the light source to the point being 
&nbsp;&nbsp;&nbsp;&nbsp;// shaded is less than minCos, then the spotlight contribution will be 0.
&nbsp;&nbsp;&nbsp;&nbsp;float minCos = cos( radians( light.SpotlightAngle ) );
&nbsp;&nbsp;&nbsp;&nbsp;// If the cosine angle of the light's direction vector
&nbsp;&nbsp;&nbsp;&nbsp;// and the vector from the light source to the point being shaded
&nbsp;&nbsp;&nbsp;&nbsp;// is greater than maxCos, then the spotlight contribution will be 1.
&nbsp;&nbsp;&nbsp;&nbsp;float maxCos = lerp( minCos, 1, 0.5f );
&nbsp;&nbsp;&nbsp;&nbsp;float cosAngle = dot( light.DirectionVS, -L );
&nbsp;&nbsp;&nbsp;&nbsp;// Blend between the minimum and maximum cosine angles.
&nbsp;&nbsp;&nbsp;&nbsp;return smoothstep( minCos, maxCos, cosAngle );
}

LightingResult DoSpotLight( Light light, Material mat, float4 V, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result;

&nbsp;&nbsp;&nbsp;&nbsp;float4 L = light.PositionVS - P;
&nbsp;&nbsp;&nbsp;&nbsp;float distance = length( L );
&nbsp;&nbsp;&nbsp;&nbsp;L = L / distance;

&nbsp;&nbsp;&nbsp;&nbsp;float attenuation = DoAttenuation( light, distance );
&nbsp;&nbsp;&nbsp;&nbsp;float spotIntensity = DoSpotCone( light, L );

&nbsp;&nbsp;&nbsp;&nbsp;result.Diffuse = DoDiffuse( light, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation * spotIntensity * light.Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;result.Specular = DoSpecular( light, mat, V, L, N ) * 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation * spotIntensity * light.Intensity;

&nbsp;&nbsp;&nbsp;&nbsp;return result;
}

LightingResult DoDirectionalLight( Light light, Material mat, float4 V, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result;

&nbsp;&nbsp;&nbsp;&nbsp;float4 L = normalize( -light.DirectionVS );

&nbsp;&nbsp;&nbsp;&nbsp;result.Diffuse = DoDiffuse( light, L, N ) * light.Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;result.Specular = DoSpecular( light, mat, V, L, N ) * light.Intensity;

&nbsp;&nbsp;&nbsp;&nbsp;return result;
}


// This lighting result is returned by the 
// lighting functions for each light type.
struct LightingResult
{
&nbsp;&nbsp;&nbsp;&nbsp;float4 Diffuse;
&nbsp;&nbsp;&nbsp;&nbsp;float4 Specular;
};

LightingResult DoLighting( StructuredBuffer&lt;Light&gt; lights, Material mat, float4 eyePos, float4 P, float4 N )
{
&nbsp;&nbsp;&nbsp;&nbsp;float4 V = normalize( eyePos - P );

&nbsp;&nbsp;&nbsp;&nbsp;LightingResult totalResult = (LightingResult)0;

&nbsp;&nbsp;&nbsp;&nbsp;for ( int i = 0; i &lt; NUM_LIGHTS; ++i )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result = (LightingResult)0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Skip lights that are not enabled.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !lights[i].Enabled ) continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Skip point and spot lights that are out of range of the point being shaded.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( lights[i].Type != DIRECTIONAL_LIGHT &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length( lights[i].PositionVS - P ) &gt; lights[i].Range ) continue;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( lights[i].Type )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case DIRECTIONAL_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoDirectionalLight( lights[i], mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case POINT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoPointLight( lights[i], mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case SPOT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoSpotLight( lights[i], mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalResult.Diffuse += result.Diffuse;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalResult.Specular += result.Specular;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return totalResult;
}


[earlydepthstencil]
float4 PS_main( VertexShaderOutput IN ) : SV_TARGET
{
&nbsp;&nbsp;&nbsp;&nbsp;// Everything is in view space.
&nbsp;&nbsp;&nbsp;&nbsp;float4 eyePos = { 0, 0, 0, 1 };
&nbsp;&nbsp;&nbsp;&nbsp;Material mat = Mat;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Diffuse
&nbsp;&nbsp;&nbsp;&nbsp;float4 diffuse = mat.DiffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasDiffuseTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 diffuseTex = DiffuseTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( diffuse.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= diffuseTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffuse = diffuseTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Opacity
&nbsp;&nbsp;&nbsp;&nbsp;float alpha = diffuse.a;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasOpacityTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the material has an opacity texture, use that to override the diffuse alpha.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alpha = OpacityTexture.Sample( LinearRepeatSampler, IN.texCoord ).r;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Ambient
&nbsp;&nbsp;&nbsp;&nbsp;float4 ambient = mat.AmbientColor;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasAmbientTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 ambientTex = AmbientTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( ambient.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ambient *= ambientTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ambient = ambientTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Combine the global ambient term.
&nbsp;&nbsp;&nbsp;&nbsp;ambient *= mat.GlobalAmbient;

&nbsp;&nbsp;&nbsp;&nbsp;// Emissive
&nbsp;&nbsp;&nbsp;&nbsp;float4 emissive = mat.EmissiveColor;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasEmissiveTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 emissiveTex = EmissiveTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( emissive.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emissive *= emissiveTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emissive = emissiveTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Specular
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasSpecularPowerTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mat.SpecularPower = SpecularPowerTexture.Sample( LinearRepeatSampler, IN.texCoord ).r \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* mat.SpecularScale;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Normal mapping
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasNormalTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For scenes with normal mapping, I don't have to invert the binormal.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float3x3 TBN = float3x3( normalize( IN.tangentVS ),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( IN.binormalVS ),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( IN.normalVS ) );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = DoNormalMapping( TBN, NormalTexture, LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Bump mapping
&nbsp;&nbsp;&nbsp;&nbsp;else if ( mat.HasBumpTexture )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For most scenes using bump mapping, I have to invert the binormal.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float3x3 TBN = float3x3( normalize( IN.tangentVS ),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( -IN.binormalVS ), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normalize( IN.normalVS ) );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = DoBumpMapping( TBN, BumpTexture, LinearRepeatSampler, IN.texCoord, mat.BumpIntensity );
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Just use the normal from the model.
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = normalize( float4( IN.normalVS, 0 ) );
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;float4 P = float4( IN.positionVS, 1 );



&nbsp;&nbsp;&nbsp;&nbsp;LightingResult lit = DoLighting( Lights, mat, eyePos, P, N );

&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= float4( lit.Diffuse.rgb, 1.0f ); // Discard the alpha value from the lighting calculations.

&nbsp;&nbsp;&nbsp;&nbsp;float4 specular = 0;
&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.SpecularPower &gt; 1.0f ) // If specular power is too low, don't use it.
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular = mat.SpecularColor;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( mat.HasSpecularTexture )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float4 specularTex = SpecularTexture.Sample( LinearRepeatSampler, IN.texCoord );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( any( specular.rgb ) )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular *= specularTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular = specularTex;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specular *= lit.Specular;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Get the index of the current pixel in the light grid.
&nbsp;&nbsp;&nbsp;&nbsp;uint2 tileIndex = uint2( floor(IN.position.xy / BLOCK_SIZE) );

&nbsp;&nbsp;&nbsp;&nbsp;// Get the start position and offset of the light in the light index list.
&nbsp;&nbsp;&nbsp;&nbsp;uint startOffset = LightGrid[tileIndex].x;
&nbsp;&nbsp;&nbsp;&nbsp;uint lightCount = LightGrid[tileIndex].y;

&nbsp;&nbsp;&nbsp;&nbsp;LightingResult lit = (LightingResult)0; // DoLighting( Lights, mat, eyePos, P, N );

&nbsp;&nbsp;&nbsp;&nbsp;for ( uint i = 0; i &lt; lightCount; i++ )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint lightIndex = LightIndexList[startOffset + i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Light light = Lights[lightIndex];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightingResult result = (LightingResult)0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( light.Type )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case DIRECTIONAL_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoDirectionalLight( light, mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case POINT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoPointLight( light, mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case SPOT_LIGHT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = DoSpotLight( light, mat, V, P, N );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lit.Diffuse += result.Diffuse;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lit.Specular += result.Specular;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= float4( lit.Diffuse.rgb, 1.0f ); // Discard the alpha value from the lighting calculations.
&nbsp;&nbsp;&nbsp;&nbsp;specular *= lit.Specular;

&nbsp;&nbsp;&nbsp;&nbsp;return float4( ( ambient + emissive + diffuse + specular ).rgb, alpha * mat.Opacity );
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                EarlyDepthStencil
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>[earlydepthstencil]</code>
                    &nbsp;attribute before the function indicates that the GPU should take advantage of early depth and stencil culling. This causes the depth/stencil tests to be performed before the pixel shader is executed. This attribute cannot be used on shaders that modify the pixel’s depth value by outputting a value using the 
                    <code>SV_Depth</code>
                    &nbsp;semantic. Since this pixel shader only outputs a color value using the 
                    <code>SV_TARGET</code>
                    &nbsp;semantic, it can take advantage of early depth/stencil testing to provide a performance improvement when a pixel is rejected. Most GPUs will perform early depth/stencil tests anyway even without this attribute, and adding this attribute to the pixel shader did not have a noticeable impact on performance, but I decided to keep the attribute anyway.
				</p>
			</li>
			<li>
				<p>
                    Since all lighting computations are performed in view space, the eye position (the camera position) is always (0, 0, 0).
				</p>
			</li>
			<li>
				<p>
                    This is a nice side effect of working in view space: the camera’s eye position 
					<strong>
                        does not
					</strong>
                    &nbsp;need to be passed as an additional parameter to the shader.
				</p>
				<ul>
					<li>
						<p>
                            Cool.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            First, we need to gather the material properties. If the material has textures associated with its various components, the textures will be sampled before the lighting is computed. After the material properties have been initialized, all the lights in the scene will be iterated, and the lighting contributions will be accumulated and modulated with the material properties to produce the final pixel color.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Comments
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Diffuse
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>any</code>
                            &nbsp;HLSL intrinsic function can be used to determine if any of the color components are non-zero.
						</p>
					</li>
					<li>
						<p>
                            If the material also has a diffuse texture associated with it, then the color from the diffuse texture will be blended with the material’s diffuse color. If the material’s diffuse color is black (0, 0, 0, 0), then the material’s diffuse color will simply be replaced by the color in the diffuse texture.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Opacity
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            By default, the fragment’s transparency value is determined by the alpha component of the diffuse color. If the material has an opacity texture associated with it, the red component of the opacity texture is used as the alpha value, overriding the alpha value in the diffuse texture. In most cases, opacity textures store only a single channel in the first component of the color returned from the 
							<strong>
                                Sample
							</strong>
                            &nbsp;method. To read from a single-channel texture, we must read from the red channel, not the alpha channel. The alpha channel of a single-channel texture will always be 1, so reading the alpha channel from the opacity map (which is most likely a single-channel texture) would not provide the required value.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lighting
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The lighting calculations for the forward rendering technique are performed in the 
                    <code>DoLighting</code>
                    &nbsp;function. This function accepts the following arguments:
				</p>
				<ul>
					<li>
						<p>
                            <code>lights</code>
                            : The lights array (as a structured buffer)
						</p>
					</li>
					<li>
						<p>
                            <code>mat</code>
                            : The material properties that were just computed
						</p>
					</li>
					<li>
						<p>
                            <code>eyePos</code>
                            : The position of the camera in view space (which is always (0, 0, 0))
						</p>
					</li>
					<li>
						<p>
                            <code>P</code>
                            : The position of the point being shaded in view space
						</p>
					</li>
					<li>
						<p>
                            <code>N</code>
                            : The normal of the point being shaded in view space
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The view vector (
                    <code>V</code>
                    ) is computed from the eye position and the position of the shaded pixel in view space.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923140023.png" width="250" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="etc" >
    etc
</h5>
<ul>
	<li>
		<p>
			<strong>
                Wicked Engine
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    All the lights inside the camera are binned to small 8×8 pixel tiles on the screen. Each tile will thus have a minimal list of lights that should be iterated by every pixel inside when lighting up the surface.
				</p>
			</li>
			<li>
				<p>
                    The main optimizations I’ve used for some years now is the “2.5D culling” and the “flat bit arrays” methods, which I really liked.
				</p>
			</li>
			<li>
				<p>
                    I rearranged the light loops so they always operate strictly on one light type (directional/point/spot), which gave some minor performance improvement. So instead of one big loop that checks the type of light and calls the appropriate function, now there are 3 loops for each type. This also allowed to avoid all the tile checking for directional lights, because they are always affecting the full screen, that specific loop is just going over all of them which simplifies the shader further.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Visibility Buffer
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The main twist to the forward rendering is the inclusion of a secondary “visibility buffer”, to aid with effects that would better fit into a deferred renderer.
						</p>
					</li>
					<li>
						<p>
                            I always wanted to support all the post processing that deferred rendering supports, but normally forward rendering doesn’t write any G-Buffer textures to allow this. Some years ago I used a thin G-buffer for this written by the depth prepass.
						</p>
					</li>
					<li>
						<p>
                            Now the depth-prepass for the main camera writes a UINT texture that contains primitive IDs, this is called the visibility buffer.
						</p>
					</li>
					<li>
						<p>
                            This is some overhead compared to depth-only pass, but less than writing a G-buffer with multiple textures.
						</p>
					</li>
					<li>
						<p>
                            From this primitiveID texture any shader can get per-pixel information about any surface properties: depth, normal, roughness, velocity, etc.
						</p>
					</li>
					<li>
						<p>
                            The nice thing about it that we can get this on the async compute queue too, and that’s exactly what happens.
						</p>
					</li>
					<li>
						<p>
                            After the visibility buffer is completed in the prepass, the graphics queue continues rendering shadow maps, planar reflections and updating environment probes, while the compute queue starts working independently on rendering a G-buffer from the visibility buffer, but only if some effects are turned on that would require this:
						</p>
						<ul>
							<li>
								<p>
                                    depth buffer: it is always created from the visibility buffer. The normal depth buffer is always kept in depth write state, it’s never used as a sampled texture. This way the depth test efficiency remains the highest for the color and transparent passes later.
								</p>
							</li>
							<li>
								<p>
                                    velocity: if any of the following effects are turned on: Temporal AA, Motion Blur, FSR upscaling, ray traced shadows/reflections/diffuse, SSR…
								</p>
							</li>
							<li>
								<p>
                                    normal, roughness: if any of the following effects are turned on: SSR, ray traced reflections
								</p>
							</li>
							<li>
								<p>
                                    some other params are simply retrieved from visibility buffer just on demand if effects need it, but not saved as a texture: for example face normal
								</p>
							</li>
							<li>
								<p>
                                    light buffers: these are not separated, so things like blurred diffuse subsurface scattering is not supported. I support a simple wrapped and tinted NdotL term for subsurface scattering instead.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            What does this texture actually store? It’s a single channel 32-bit UINT texture, and normally that wouldn’t be enough to store both primitive and instance ID. But there is a workaround, in which I store 25 bits of meshlet ID and 7 bits of primitive ID. A regular mesh wouldn’t fit into it, since it limits to 128 triangles, but with a lookup table it’s possible to manage.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="disadvantages" >
    Disadvantages
</h5>
<ul>
	<li>
		<p>
            Tiled shading groups samples in rectangular screen-space tiles, using the min and max depth within each tile to define sub frustums. Thus, tiles which contain depth values that are close together, e.g. from a single surface, will be represented with small bounding volumes. However, for tiles where one or more depth discontinuities occur, the depth bounds of the tile must encompass all the empty space between the sample groups (illustrated in Figure 1). This reduces light culling efficiency, in the worst case degenerating to a pure 2D test. This results in a strong dependency between view and performance, which highly is undesirable in real-time applications, as it becomes difficult to guarantee consistent rendering performance at all times.
		</p>
		<ul>
			<li>
				<p>
                    Visually, this means:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922180103.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Toggling on the light geometry, we see that there is a lot of overlap, even in the empty space behind the tree.
				</p>
			</li>
			<li>
				<p>
                    We now should be able to start seeing the shape of the problem with 2D tiles in a 3D world.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922180303.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In 3D:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922180341.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    While actually some of the samples, from the tree, are affected zero of these lights. While the tiger in the wall would only need two of the lights.
				</p>
			</li>
			<li>
				<p>
                    There is a fairly fundamental problem with tiled shading. The basic problem stems from that we are making the intersection between lights and geometry samples, both of which are 3D entities, in a 2D screen space.
				</p>
			</li>
			<li>
				<p>
                    The main practical issue with this is that the resulting light assignment is highly view dependent. This means that we cannot author scenes with any strong guarantee on performance, as a given view of the scene may have a significantly higher screen space light density than average.
				</p>
			</li>
			<li>
				<p>
                    For example, we’d like to be able to construct a scene with, say, maximum 4 lights affecting any part of the scene. In this case, we would like shading cost to be proportional to this, and stable, given different view points.
				</p>
			</li>
			<li>
				<p>
                    Unfortunately, no such correlation exists for tiled shading. In other words shading times are unpredictable, which is a major problem for a real time application.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Avalanche Studios
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The two tiled solutions need quite a bit of massaging to work reasonable well in all situations, especially with large amounts of depth discontinuities. There are proposed solutions that mitigate the problem, such as 2.5D culling, but they further complicate the code.
						</p>
					</li>
					<li>
						<p>
                            I didn’t have to go look for a problematic area, in fact, it was right there in front of my face. This shows how common these scenes actually are in real games, and certainly so in the games that we make.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922204443.png" width="250" >
                            <img src="assets/image_20250922204452.png" width="250" >
                            .
						</p>
					</li>
					<li>
						<p>
                            We are still using a deferred engine, but we could change to forward at any time should we decide that to be better. The important part is, however, that the transparency passes can now use the same lighting structure as the deferred passes, making it a unified lighting solution.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="quotextensions-to-the-tiled-forwardquot" >
    &quot;Extensions to the Tiled Forward&quot;
</h5>
<ul>
	<li>
		<p>
			<strong>
                2.5D Culling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://pt.slideshare.net/slideshow/a-25d-culling-for-forward-siggraph-asia-2012/34909590" 
						class="external-link" 
						target="_blank" >
                        2.5D Culling for Forward+ - AMD Siggraph 2012
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://wickedengine.net/2018/01/optimizing-tile-based-light-culling/" 
						class="external-link" 
						target="_blank" >
                        2.5D Culling for Forward+ - Wicked Engine 2018
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=NGWZm2VhxDs" 
						class="external-link" 
						target="_blank" >
                        2.5D Light Culling for Tiled Forward - Wicked Engine 2017
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Depth discontinuity is the enemy of Forward+.
						</p>
					</li>
					<li>
						<p>
                            With a more aggressive culling we can eliminate false positives and have a much faster render.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922113909.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Avalanche Studios
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Criticizes the use of 2.5D Culling, considering that Cluster Shading yields a better result with less effort.
						</p>
					</li>
					<li>
						<p>
                            This is explained and demonstrated on pages 112 to 121 of this presentation: 
							<a
								href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
								class="external-link" 
								target="_blank" >
                                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            2.5D Culling.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bimodal Clusters / HalfZ
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922113926.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Ola Olsson:
		</p>
		<ul>
			<li>
				<p>
                    This extensions have the problems of:
				</p>
				<ul>
					<li>
						<p>
                            Lack of generality: slopes / multiple layers.
						</p>
					</li>
					<li>
						<p>
                            No solution for transparency.
						</p>
					</li>
					<li>
						<p>
                            Require depth pre-pass, as you have to work with the depth range to apply the extensions.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The use of Clustered Forward Shading removes the need for these extensions.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="samples" >
    Samples
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/3dgep/ForwardPlus" 
				class="external-link" 
				target="_blank" >
                Forward, Deferred, Tile Forward Shading - DirectX11, HLSL - Sample - Jeremiah van Oosten 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    There are 30,000,000,000 files, etc, C++, Visual Studio, CMake, etc. Jeebs.
				</p>
			</li>
			<li>
				<p>
                    The 
					<em>
                        only
					</em>
                    &nbsp;relevant things are the shaders:
				</p>
				<ul>
					<li>
						<p>
                            <code>GraphicsTest\Assets\shaders\CommonInclude.hlsl</code>
						</p>
					</li>
					<li>
						<p>
                            <code>GraphicsTest\Assets\shaders\ForwardPlusRendering.hlsl</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/WindyDarian/Vulkan-Forward-Plus-Renderer" 
				class="external-link" 
				target="_blank" >
                Tile Forward Shading - Sample - Windy Darian
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=ZLNDfPxhqdE" 
						class="external-link" 
						target="_blank" >
                        Sample Demo
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="papers-and-presentations" >
    Papers and Presentations
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://takahiroharada.wordpress.com/wp-content/uploads/2015/04/forward_plus.pdf" 
				class="external-link" 
				target="_blank" >
                Forward+: Bringing Deferred Lighting to the Next Level - AMD 2012
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.3dgep.com/forward-plus/" 
				class="external-link" 
				target="_blank" >
                Forward, Deferred, Tiled Forward - Jeremiah Van Oosten - 2015
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    C++, shaders em HLSL.
				</p>
			</li>
			<li>
				<p>
                    Possui uma Sample acima.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=mkAbE9Z4gxI" 
				class="external-link" 
				target="_blank" >
                Demo - Wicked Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=HIrq4sF5QO8" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=w0gTf6PKHwI" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.gdcvault.com/play/1017627/Advanced-Visual-Effects-with-DirectX" 
				class="external-link" 
				target="_blank" >
                Tiled Forward Shading vs Tiled Deferred Rendering - AMD 2013 (Jason Stewart and Gareth Thomas)
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    The presentation is somewhat poor and the graphics are questionable.
				</p>
			</li>
			<li>
				<p>
                    No real-world lighting cases are presented.
				</p>
			</li>
			<li>
				<p>
                    &quot;Have you looked into Forward Clustered?&quot; Yea, but have not implemented, they are hours worth of work. I don't know if the extra complexity is worth, but I'll probably test it at some point.
				</p>
			</li>
			<li>
				<p>
                    They use Virtual Point Lights for GI, which sounds suspicious..
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="clustered-forward-shading" >
    Clustered Forward Shading
</h4>
<ul>
	<li>
		<p>
            Clustered shading expands on the idea of tiled rendering but adds a segmentation on the 3rd axis. The “clustering” is done in view space, by splitting the frustum into a 3D grid.
		</p>
	</li>
	<li>
		<p>
            Clustered Shading enables using normal information to perform per-cluster back-face culling of lights, again reducing the number of lighting computations.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Clustered Shading vs Tiled Shading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We also show that Clustered Shading not only outperforms tiled shading in many scenes, but also exhibits better worst case behaviour under tricky conditions (e.g. when looking at high-frequency geometry with large discontinuities in depth).
				</p>
			</li>
			<li>
				<p>
                    Additionally, Clustered Shading enables real-time scenes with two to three orders of magnitudes more lights than previously feasible (up to around one million light sources).
				</p>
			</li>
			<li>
				<p>
                    Our implementation shows much less view-dependent performance, and is much faster for some cases that are challenging for tiled shading.
				</p>
			</li>
			<li>
				<p>
                    Compared to tiled shading, clusters generally are smaller, and therefore will be affected by fewer light sources.
				</p>
			</li>
			<li>
				<p>
                    Our implementation shows that both clustered deferred and forward shading offer real-time performance and can scale up to 1M lights. In addition, overhead for the clustering is low, making it competitive even for few lights.
				</p>
			</li>
			<li>
				<p>
                    The shading cost is proportional to the light density.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Clustered Forward vs Clustered Deferred
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Clustered Shading is really decoupled from the choice between deferred or forward rendering. It works with both, so you’re not locked into one or the other. This way you can make an informed choice between the two approaches based on other factors, such as whether you need custom materials and lighting models, or need deferred effects such as screen-space decals, or simply based on performance.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h6
	id="godot" >
    Godot
</h6>
<ul>
	<li>
		<p>
            Clustered lighting uses a compute shader to group lights into a 3D frustum aligned grid.
		</p>
	</li>
	<li>
		<p>
            At render time, pixels can lookup what lights affect the grid cell they are in and only run light calculations for lights that might affect that pixel.
		</p>
	</li>
	<li>
		<p>
            This approach can greatly speed up rendering performance on desktop hardware, but is substantially less efficient on mobile.
		</p>
	</li>
	<li>
		<p>
            There's a default limit of 512 clustered elements that can be present in the current camera view.
		</p>
		<ul>
			<li>
				<p>
                    A clustered element is an omni light, a spot light, a decal or a reflection probe.
				</p>
			</li>
			<li>
				<p>
                    This limit can be increased by adjusting Max Clustered Elements in Project Settings &gt; Rendering &gt; Limits &gt; Cluster Builder.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="high-level-overview" >
    High-level overview
</h5>
<ol>
	<li>
		<p>
            Build the clustering data structure.
		</p>
	</li>
	<li>
		<p>
            Render scene to Z Pre-pass.
		</p>
	</li>
	<li>
		<p>
            Find visible clusters.
		</p>
	</li>
	<li>
		<p>
            Reduce repeated values in the list of visible clusters.
		</p>
	</li>
	<li>
		<p>
            Perform light culling and assign lights to clusters.
		</p>
	</li>
	<li>
		<p>
            Shade samples using light list.
		</p>
	</li>
</ol>
<ul>
	<li>
		<p>
            Steps two and six won’t be covered since they are mostly dependent on the shading model you’re using.
		</p>
	</li>
	<li>
		<p>
            Steps three and four are combined into one and covered in the section on Determining Active Clusters, much like in 
			<a
				href="https://www.3dgep.com/volume-tiled-forward-shading/" 
				class="external-link" 
				target="_blank" >
                Van Oosten’s implementation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="building-the-cluster-grid" >
    Building the Cluster Grid
</h5>
<ul>
	<li>
		<p>
			<strong>
                Depth Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We’ll be focusing on building cluster grids that group samples based on their view space position. We’ll begin by tiling the view frustum exactly the same way you would in tiled shading and then subdividing it along the depth axis multiple times.
				</p>
			</li>
			<li>
				<p>
                    We choose to perform the subdivision in view space, by spacing the divisions exponentially to achieve self-similar subdivisions, such that the clusters become as cubical as possible (Figures 2(c) and 3).
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922162804.png" width="350" >
                    <img src="assets/image_20250922162907.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In Figure 3, we illustrate the subdivisions of a frustum. The number of subdivisions in the Y direction (Sy) is given in screen space (e.g. to form tiles of 32×32 pixels).
				</p>
			</li>
			<li>
				<p>
                    The near plane for a division k, near k, can be calculated from:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922163111.png" width="276" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922163221.png" width="275" >
                    .
				</p>
			</li>
			<li>
				<p>
                    &quot;I settled on a 16x9x24 subdivision because it matches my monitors aspect ratio, but it honestly could have been something else.&quot; - Angel Ortiz.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Doom (2016)
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Uses the one below, which doesn't represent any of the three above.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923200901.png" width="" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Solving: 
                            <img src="assets/image_20250923201004.png" width="500" >
                            .
						</p>
					</li>
					<li>
						<p>
                            The major advantage of the equation above is that the only variable is Z and everything else is a constant.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923201056.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Avalanche Studios
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Another option we have considered, but not yet explored, is to not base it on pixel count, but simply divide the screen into a specific number of tiles regardless of resolution. This may reduce coherency on the GPU side somewhat in some cases, but would also decouple the CPU workload from the GPU workload and allow for some useful CPU side optimizations if the tile counts are known at compile time.
						</p>
					</li>
					<li>
						<p>
                            We are using exponential depth slicing, much like in the paper. There is nothing dictating that this is what we have to use, or for that matter that it is the best or most optimal depth slicing strategy; however, the advantage is that the shape of the clusters remain the same as we go deeper into the depth. On the other hand, clusters get larger in world space, which could potentially result in some distant clusters containing a much larger amount of lights. Depending on the game, it may be worth exploring other options.
						</p>
					</li>
					<li>
						<p>
                            Our biggest problem was that our depth ratio is massive, with near plane as close as 0.1m and far plane way out on the other side of the map, at 50,000m. This resulted in poor utilization of our limited depth slices, currently 16 of them. The step from one slice to the next is very large. Fortunately, in our game we don’t have any actual light sources beyond a distance of 500m. So we simply decided to keep our current distant light system for distances beyond 500m and limit the far range for clustering to that.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922205338.png" width="350" >
                            .
						</p>
					</li>
					<li>
						<p>
                            This improved the situation notably, but was still not ideal. We still burnt half of our slices on the first 7 meters from the camera. Given how our typical scenes look like, that’s likely going to be mostly empty space in most situations. So to improve the situation, we made the first slice special and made that go from near plane to an arbitrary visually tweaked distance, currently 5m. This gave us much better utilization.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Filament Engine
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The depth slicing is not linear, but exponential. In a typical scene, there will be more pixels close to the near plane than to the far plane. An exponential grid of froxels will therefore improve the assignment of lights where it matters the most.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922080354.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            A simple exponential voxelization is unfortunately not enough. The graphic above clearly illustrates how world space is distributed across slices but it fails to show what happens close to the near plane.
						</p>
					</li>
					<li>
						<p>
                            A simple exponential distribution uses up half of the slices very close to the camera. In this particular case, we use 8 slices out of 16 in the first 5 meters. Since dynamic world lights are either point lights (spheres) or spot lights (cones), such a fine resolution is completely unnecessary so close to the near plane.
						</p>
					</li>
					<li>
						<p>
                            Our solution is to manually tweak the size of the first froxel depending on the scene and the near and far planes. By doing so, we can better distribute the remaining froxels across the frustum.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922080541.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            This new distribution is much more efficient and allows a better assignment of the lights throughout the entire frustum.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922080237.png" width="350" >
                            <img src="assets/image_20250922080246.png" width="350" >
                            <img src="assets/image_20250922080156.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            We call a 
							<strong>
                                froxel
							</strong>
                            &nbsp;a voxel in frustum space.
						</p>
					</li>
					<li>
						<p>
                            The frustum voxelization can be executed only once by a first compute shader (as long as the projection matrix does not change).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Screen Slicing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Filament Engine
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            1280x720px, 80x80px tiles.
						</p>
					</li>
					<li>
                        <img src="assets/image_20250922080036.png" width="350" >

					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922202558.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            Cluster assignments is a simple mapping from sample coordinate, to an integer tuple 
            <code>i</code>
            , 
            <code>j</code>
            , 
            <code>k</code>
            .
		</p>
	</li>
	<li>
		<p>
            <code>i</code>
            &nbsp;and 
            <code>j</code>
            &nbsp;are the tile coordinates, which can be derived by dividing 
            <code>gl_FragCoord.xy</code>
            &nbsp;by the tile size.
		</p>
		<ul>
			<li>
				<p>
                    <code>i = bx_screen_space/txc</code>
                    &nbsp;
                    <code>j = by_screen_space/tyc</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>k</code>
            &nbsp;is a logarithmic function of the view space Z of the sample, not simply the logarithm.
		</p>
		<ul>
			<li>
				<p>
                    The logarithmic subdivisions also means that as clusters become larger further away, we get a kind of LOD behaviour and do not end up with insane numbers of clusters, for a wide range of view parameters.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We use this subdivision as it creates self similar clusters that are as cube like as possible. This makes them better suited for culling.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922202238.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            An easy solution is to use Axis Aligned Bounding Boxes (AABB) that enclose each cluster. AABBs built from the max and min points of the clusters will be ever so slightly larger than the actual clusters. We’re okay with this since it ensures that there are no gaps in between volumes due to precision issues. Also, AABB’s can be stored using only only two vec3’s, a max and min point.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Angelo1211/HybridRenderingEngine/blob/master/assets/shaders/ComputeShaders/clusterShader.comp" 
				class="external-link" 
				target="_blank" >
                Building the Cluster Grid - Compute Shader Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            This compute shader is ran once per cluster and aims to obtain the min and max points of the AABB encompassing said cluster.
		</p>
	</li>
	<li>
		<p>
            First, imagine we’re looking at the view frustum from a front camera perspective, like we did in the Tiled Shading animations of part one. Each tile will have a min and max point, which in our coordinate system will be the upper right and bottom left vertices of a tile respectively. After obtaining these two points in screen space we set their Z position equal to the near plane, which in NDC and in my specific setup is equal to -1.
		</p>
		<ul>
			<li>
				<p>
                    I know, I know. I should be using reverse Z, not the default OpenGL layout, I’ll fix that eventually.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Then, we transform these min and max points to view space. Next, we obtain the Z value of the “near” and “far” plane of our target mini-frustum / cluster. And, armed with the knowledge that all rays meet at the origin in view space, a pair of min and max values in screen space and both bounding planes of the cluster, we can obtain the four points intersecting those planes that will represent the four corners of the AABB encompassing said cluster. Lastly, we find the min and max of those points and save their values to the cluster array. And voilà, the grid is complete!
		</p>
	</li>
	<li>
		<p>
            Screen To View:
		</p>
		<ul>
			<li>
				<p>
                    Converts a given point in screen space to view space by taking the reverse transformation steps taken by the graphics pipeline.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Line Intersection to Z Plane:
		</p>
		<ul>
			<li>
				<p>
                    Used to obtain the points on the corners of the AABB that encompasses a cluster. The normal vector of the planes is fixed at 1.0 in the z direction because we are evaluating the points in view space and positive z points towards the camera from this frame of reference.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            When to recalculate:
		</p>
		<ul>
			<li>
				<p>
                    Our list of cluster AABBs will be valid as long as the view frustum stays the same shape. So, it can be calculated once at load time and only recalculated with any changes in FOV or other view field altering camera properties.
				</p>
			</li>
			<li>
				<p>
                    My initial profiling in RenderDoc seems to indicate that the GPU can run this shader really quickly, so I think it wouldn’t be a huge deal either if this was done every frame.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="idk" >
    Idk
</h5>
<ul>
	<li>
		<p>
			<strong>
                From depth to froxel
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Given a near plane $n$, a far plane $m$, a maximum number of depth slices $z$ and a linear depth value in the range 
                    <code>[0..1]</code>
                    , this equation can be used to compute the index of the cluster for a given position.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922081032.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This formula suffers however from the resolution issue mentioned previously. We can fix it by introducing $sn$, a special near value that defines the extent of the first froxel (the first froxel occupies the range 
                    <code>[n..sn]</code>
                    , the remaining froxels 
                    <code>[sn..f]</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    The following equation can be used to compute a linear depth value from 
                    <code>gl_FragCoord.z</code>
                    &nbsp;(assuming a standard OpenGL projection matrix).
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922081150.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This equation can be simplified by pre-computing two terms $c0$ and $c1$:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922081222.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This simplification is important because we will pass the linear $z$ value to a 
                    <code>log2</code>
                    . Since the division becomes a negation under a logarithmic, we can avoid a division by using 
                    <code>-log2(z * c0 + c1)</code>
                    &nbsp;instead.
				</p>
			</li>
			<li>
				<p>
                    Implementation to compute a froxel index from a fragment's screen coordinates:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #define MAX_LIGHT_COUNT 16 // max number of lights per froxel
 
 uniform uvec4 froxels; // res x, res y, count y, count y
 uniform vec4 zParams;&nbsp;&nbsp;// c0, c1, index scale, index bias
 
 uint getDepthSlice() {
&nbsp;&nbsp;&nbsp;&nbsp; return uint(max(0.0, log2(zParams.x * gl_FragCoord.z + zParams.y) *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zParams.z + zParams.w));
 }
 
 uint getFroxelOffset(uint depthSlice) {
&nbsp;&nbsp;&nbsp;&nbsp; uvec2 froxelCoord = uvec2(gl_FragCoord.xy) / froxels.xy;
&nbsp;&nbsp;&nbsp;&nbsp; froxelCoord.y = (froxels.w - 1u) - froxelCoord.y;
 
&nbsp;&nbsp;&nbsp;&nbsp; uint index = froxelCoord.x + froxelCoord.y * froxels.z +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depthSlice * froxels.z * froxels.w;
&nbsp;&nbsp;&nbsp;&nbsp; return index * MAX_FROXEL_LIGHT_COUNT;
 }
 
 uint slice = getDepthSlice();
 uint offset = getFroxelOffset(slice);
 
 // Compute lighting...
</code></pre>
		<ul>
			<li>
				<p>
                    Several uniforms must be pre-computed to perform the index evaluation efficiently.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> froxels[0] = TILE_RESOLUTION_IN_PX;
 froxels[1] = TILE_RESOLUTION_IN_PX;
 froxels[2] = numberOfTilesInX;
 froxels[3] = numberOfTilesInY;
 
 zParams[0] = 1.0f - Z_FAR / Z_NEAR;
 zParams[1] = Z_FAR / Z_NEAR;
 zParams[2] = (MAX_DEPTH_SLICES - 1) / log2(Z_SPECIAL_NEAR / Z_FAR);
 zParams[3] = MAX_DEPTH_SLICES;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                From froxel to depth
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922081542.png" width="" >
                    .
				</p>
			</li>
			<li>
				<p>
                    For $i = 0$, the z value is 0. The result of this equation is in the 
                    <code>[0..1]</code>
                    &nbsp;range and should be multiplied by $f$ to get a distance in world units.
				</p>
			</li>
			<li>
				<p>
                    The compute shader implementation should use 
                    <code>exp2</code>
                    &nbsp;instead of a 
                    <code>pow</code>
                    . The division can be precomputed and passed as a uniform.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="data-structure" >
    Data Structure
</h5>
<ul>
	<li>
		<p>
            They’re implemented solely on the GPU using shader storage buffer objects, so keep in mind that reads and writes have incoherent memory access and 
			<strong>
                will
			</strong>
            &nbsp;require the appropriate barriers to avoid any disasters.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175552.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;At the end, you get an accelerated structure like this, which is just a grid where you can look up your light lists.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Global Light List
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is an array containing all of the lights in a given scene with a size equivalent to the maximum amount of lights possible in the scene.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Global Light Index List
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Every light will have its own unique index based on its location in the Global Light List and that index is stored in the Global Light Index List.
				</p>
			</li>
			<li>
				<p>
                    This array contains the indices of all of the active lights in the scene grouped by cluster.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Light Grid
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Contain information as to how these indices relate to their parent clusters.
				</p>
			</li>
			<li>
				<p>
                    This array has as many elements as there are clusters and each element contains two unsigned ints, one that stores the offset to the Global Light Index List and another that contains the number of lights intersecting the cluster.
				</p>
			</li>
			<li>
				<p>
                    Each cell stores an offset and count that represent a range in ?.
				</p>
			</li>
			<li>
				<p>
                    This range contains a list of 
					<em>
                        light indices
					</em>
                    &nbsp;indicating all the lights that the may affect the samples in the tile.
				</p>
			</li>
			<li>
				<p>
                    The Light Grid provides access to light list for each pixel.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Unlike what’s shown in the diagram, the global light index list does not necessarily store the indices for each cluster sequentially, in fact, it might store them in a completely random order.
		</p>
	</li>
	<li>
		<p>
            If you’re wondering why we need such a convoluted data structure, the quick answer is that it plays nicely with the GPU and works well in parallel. Also, it allows both compute shaders and pixel shaders to read the same data structure and execute the same code. Lastly, it is pretty memory efficient since clusters tend to share the same lights and by storing indices to the global light list instead of the lights themselves we save up memory.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Angelo1211/HybridRenderingEngine/blob/master/assets/shaders/ComputeShaders/clusterCullLightShader.comp" 
				class="external-link" 
				target="_blank" >
                clusterCullLightShader.comp
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Check lights against every cluster of the view frustum. Performs light culling for every cluster in the cluster grid.
				</p>
			</li>
			<li>
				<p>
                    Thread groups sizes are actually relevant in this compute shader since I’m using shared GPU memory to reduce the number of reads and writes by only loading each light once per thread group, instead of once per cluster.
				</p>
			</li>
			<li>
				<p>
                    First, each thread gets its bearings and begins by calculating some initialization values.
				</p>
				<ul>
					<li>
						<p>
                            For example, how many threads there are in a thread group, what it’s linear cluster index is and in how many passes it shall traverse the global light list.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Next, each thread initializes a count variable of how many lights intersect its cluster and a local index light array to zero.
				</p>
			</li>
			<li>
				<p>
                    Once setup is complete, each thread group begins a traversal of a batch of lights. Each individual thread will be responsible for loading a light and writing it to shared memory so other threads can read it.
				</p>
			</li>
			<li>
				<p>
                    A barrier after this step ensures all threads are done loading before continuing.
				</p>
			</li>
			<li>
				<p>
                    Then, each thread performs collision detection for its cluster, using the AABB we determined in step one, against every light in the shared memory array, writing all positive intersections to the local thread index array.
				</p>
			</li>
			<li>
				<p>
                    We repeat these steps until every light in the global light array has been evaluated.
				</p>
			</li>
			<li>
				<p>
                    Next, we atomically add the local number of active lights in a cluster to the globalIndexCount and store the global count value before we add to it.
				</p>
			</li>
			<li>
				<p>
                    This number is our offset to the global light index list and due to the nature of atomic operations we know that it will be 
					<em>
                        unique per cluster
					</em>
                    , since only one thread has access to it at any given time.
				</p>
			</li>
			<li>
				<p>
                    Then, we populate the global light index list by transferring the values from the 
					<strong>
                        local
					</strong>
                    &nbsp;light index list (named visibleLightIndices in the code) into the 
					<strong>
                        global
					</strong>
                    &nbsp;light index list starting at the offset index we just obtained.
				</p>
			</li>
			<li>
				<p>
                    Finally, we write the offset value and the count of how many lights intersected the cluster to the lightGrid array at the given cluster index.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Once this shader is done running the data structures will contain all of the values necessary for a pixel shader to read the list of lights that are affecting a given fragment, since we can use the getClusterIndex function from the previous section to find which cluster a fragment belongs to.
		</p>
	</li>
	<li>
		<p>
            With this, we’ve completed step five and therefore have all the building blocks in place for a working clustered shading implementation.
		</p>
	</li>
	<li>
		<p>
            Even this simple culling method will still manage lights in the order of tens of thousands.
		</p>
	</li>
	<li>
		<p>
			<em>
                Extra Optimizations
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.3dgep.com/volume-tiled-forward-shading/" 
						class="external-link" 
						target="_blank" >
                        Jeremiah Van Oosten’s thesis
					</a>
                    &nbsp;writes about optimizing Clustered Renderers and has links to his testing framework where you can compare different efficient rendering algorithms.
				</p>
			</li>
			<li>
				<p>
                    He goes into detail as to how spatial optimization structures like Boundary Volume Hierarchies (BVH) and efficient light sorting can significantly increase performance and allow for scenes with millions of dynamic light sources in real-time.
				</p>
				<ul>
					<li>
						<p>
                            Right now, it seems that implementing the BVH will be my first task — and specially after how important being familiar with BVH’s will become after Turing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="http://www.cse.chalmers.se/~uffe/ClusteredWithShadows.pdf" 
						class="external-link" 
						target="_blank" >
                        virtual shadow mapping
					</a>
                    &nbsp;enables hundreds of real-time shadow casting dynamic lights.
				</p>
			</li>
			<li>
				<p>
                    It should be considered an alternate clustering method best suited for mobile hardware.
				</p>
			</li>
			<li>
				<p>
                    Doom 2016 goes into optimized shaders to make use of GCN scalar units and saved some Vector General-Purpose Registers(VGPR). Also, by voxelizing environment probes, decals and lights the benefits of the cluster data structure were brought over to nearly all items that influence lighting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Given a screen position and a depth value (whether from a depth buffer or the rasterized depth in a forward pass) we start by looking up the cluster from a 3D texture. Each texel represents a cluster and its light list.
				</p>
			</li>
			<li>
				<p>
                    The red channel gives us an offset to where the light list starts, whereas the green channel contains the light counts. The light lists are then stored in a tightly packed lists of indexes to the lights. The actual light source data is stored as arrays in a constant buffer.
				</p>
			</li>
			<li>
				<p>
                    All in all the data structure is very compact. In a typical artists lit scene it may be around 50- 100kb of data to upload to the GPU every frame.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922205540.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Data coherency
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            So the difference between tiled and clustered is that we pick a light list on a per-pixel basis instead of per-tile, depending on which cluster we fall within. Obviously though, in a lot of cases nearby pixels will choose the same light list, in particular neighbors within the same tile on a similar depth. If we visualize what light lists were chosen, we can see that there are a bunch of different paths taken beyond just the tile boundaries. A number of depth discontinuities from the foliage in front of the player gets clearly visible. This may seem like a big problem, but here we are only talking about fetching different data. This is not a problem for a GPU, it’s something they do all the time for regular texture fetches, and this is even much lower frequency than that.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Filament Engine
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The list of lights per froxel can be passed to the fragment shader either as an SSBO or a texture.
				</p>
			</li>
			<li>
				<p>
                    During the rendering pass, we can compute the ID of the froxel a fragment belongs to and therefore the list of lights that can affect that fragment.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="finding-active-clusters-unique-clusters" >
    Finding Active Clusters / Unique Clusters
</h5>
<ul>
	<li>
		<p>
			<em>
                Motivation
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    This section is optional since active cluster determination is not a crucial part of light culling.
				</p>
			</li>
			<li>
				<p>
                    Even though it isn’t terribly optimal, you can simply perform culling checks for all clusters in the cluster grid every frame.
				</p>
			</li>
			<li>
				<p>
                    Thankfully, determining active clusters doesn’t take much work to implement and can speed up the light culling pass considerably.
				</p>
			</li>
			<li>
				<p>
                    The only drawback is that it 
					<strong>
                        will
					</strong>
                    &nbsp;require a 
					<strong>
                        Depth Pre-pass
					</strong>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Depth Pre-pass
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The depth map generated is used to determine the minimum and maximum depth values within a tile, that is the minimum and maximum depths across the entire tile.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The key idea is that not all clusters will be visible all of the time, and there is no point in performing light culling against clusters you cannot see.
		</p>
	</li>
	<li>
		<p>
            So, we can check every pixel in parallel for their cluster ID and mark it as active on a list of clusters.
		</p>
	</li>
	<li>
		<p>
            This list will most likely be sparsely populated, so we will compact it into another list using atomic operations.
		</p>
	</li>
	<li>
		<p>
            Then, during light culling we will check light “collisions” against the compacted list instead, saving us from having to check every light for every cluster.
		</p>
	</li>
	<li>
		<p>
            To increase efficiency, both Van Oosten and Olsson compact this list into a set of 
			<strong>
                unique clusters
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    We compact the grid into the list of non-zero elements.
				</p>
			</li>
			<li>
				<p>
                    This leaves us with a list of clusters which needs lights assigned to them.
				</p>
			</li>
			<li>
				<p>
                    The most obvious method to find the unique clusters in parallel is to simply sort the cluster keys, and then perform a compaction step that 
					<em>
                        removes any with an identical neighbour
					</em>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250922163401.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Identifying unique clusters
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Local Sorting
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    We sort samples in each screen space tile locally. This allows us to perform the sorting operation in on-chip shared memory, and use local (and therefore smaller) indices to link back to the source pixel.
								</p>
							</li>
							<li>
								<p>
                                    We extract unique clusters from each tile using a parallel compaction. From this, we get the globally unique list of clusters. During the compaction, we also compute and store a link from each sample to its associated cluster.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>
							<em>
                                Page Tables
							</em>
                            </s>
						</p>
						<ul>
							<li>
								<p>
                                    The second technique is similar to the page table approach used by virtual textures (Section 2). However, as the range of possible cluster keys is very large, we cannot use a direct mapping between cluster key and physical storage location for the cluster data; it simply would typically not fit into GPU memory. Instead we use a virtual mapping, and allocate physical pages where any actual keys needs storage. Lefohn et.al. [LSK∗06] provide details on software GPU implementation of virtual address translation. We exploit the fact that all physical pages are allocated in a compact range, and we can therefore compact that range to find the unique clusters.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>
							<em>
                                Other methods
							</em>
                            </s>:
						</p>
						<ul>
							<li>
								<p>
                                    Both sorting and compaction are relatively efficient and readily available GPU building blocks. However, despite steady progress, sorting remains an expensive operation.
								</p>
							</li>
							<li>
								<p>
                                    Methods that rely on adjacent screen-space coherency are not robust, especially with respect to stochastic frame buffers.
								</p>
							</li>
							<li>
								<p>
                                    We therefore focus on techniques that do not suffer from this weaknesses.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Explicit Bounds
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            As the actual view-sample positions and normals typically have tighter bounds, we also evaluate explicit 3D bounds and normal cones.
						</p>
					</li>
					<li>
						<p>
                            We compute the explicit bounds by performing a reduction over the samples in each cluster (e.g., we perform a min-max reduction to find the AABB enclosing each cluster).
						</p>
					</li>
					<li>
						<p>
                            The results of the reduction are stored separately in memory.
						</p>
					</li>
					<li>
						<p>
                            When using page tables, the reduction is difficult to implement efficiently, because of the many-to-one mapping from view samples to cluster data, we would need to make use of atomic operations, and get a high rate of collisions. We deemed this to be impractically expensive.
						</p>
					</li>
					<li>
						<p>
                            We therefore only implement explicit bounds for local sort.
						</p>
					</li>
					<li>
						<p>
                            After the local sort, information about which samples belong to a given cluster is readily available.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">//Input
vec2 pixelID; // The thread x and y id corresponding to the pixel it is representing
vec2 screenDimensions; // The total pixel size of the screen in x and y

//Output
bool clusterActive[];

//We will evaluate the whole screen in one compute shader
//so each thread is equivalent to a pixel
void markActiveClusters(){
&nbsp;&nbsp;&nbsp;&nbsp;//Getting the depth value
&nbsp;&nbsp;&nbsp;&nbsp;vec2 screenCord = pixelID.xy / screenDimensions.xy;
&nbsp;&nbsp;&nbsp;&nbsp;float z = texture(screenCord) //reading the depth buffer

&nbsp;&nbsp;&nbsp;&nbsp;//Getting the linear cluster index value
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterID = getClusterIndex(vec3(pixelID.xy, z));
&nbsp;&nbsp;&nbsp;&nbsp;clusterActive[clusterID] = true;
}
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">//Input
vec3 pixelCoord;&nbsp;&nbsp;// Screen space pixel coordinate with depth
uint tileSizeInPx; // How many pixels a rectangular cluster takes in x and y
uint3 numClusters; // The fixed number of clusters in x y and z axes

//Output
uint clusterIndex; // The linear index of the cluster the pixel belongs to

uint getClusterIndex(vec3 pixelCoord){
&nbsp;&nbsp;&nbsp;&nbsp;// Uses equation (3) from Building a Cluster Grid section
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterZVal&nbsp;&nbsp;= getDepthSlice(pixelCoord.z);

&nbsp;&nbsp;&nbsp;&nbsp;uvec3 clusters&nbsp;&nbsp;&nbsp;&nbsp;= uvec3( uvec2( pixelCoord.xy / tileSizeInPx), clusterZVal);
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterIndex = clusters.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numClusters.x * clusters.y +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numClusters.x * numClusters.y) * clusters.z;
&nbsp;&nbsp;&nbsp;&nbsp;return clusterIndex;
}
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">//Input
bool clusterActive[]; //non-compacted list
uint globalActiveClusterCount; //Number of active clusters

//Output
uint uniqueActiveClusters[]; //compacted list of active clusters

//One compute shader for all clusters, one cluster per thread
void buildCompactClusterList(){
&nbsp;&nbsp;&nbsp;&nbsp;uint clusterIndex&nbsp;&nbsp;= gl_GlobalInvocationID;
&nbsp;&nbsp;&nbsp;&nbsp;if(clusterActive[clusterIndex]){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint offset = atomicAdd(globalActiveClusterCount, 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniqueActiveClusters[offset] = clusterIndex;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h5
	id="light-culling-light-assignment" >
    Light Culling / Light Assignment
</h5>
<ul>
	<li>
		<p>
            This step aims to assign lights to each cluster based on their view space position.
		</p>
	</li>
	<li>
		<p>
            The main idea is that we perform something very similar to a “light volume collision detection” against the active clusters in the scene and append any lights within a cluster to a local list of lights.
		</p>
	</li>
	<li>
		<p>
            Performing this “light volume collision detection” requires that I define clearly what I mean by 
			<em>
                light volume
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            In a nutshell, lights become dimmer with distance. After a certain point they are so dim we can assume they aren’t contributing to shading anymore so, we mark those points as our boundary. The volume contained within the boundary is our light volume and if that volume intersects with the AABB of a cluster, we assume that light is contained within the cluster.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">//Input:
uint light; // A given light index in the shared lights array
uint tile;&nbsp;&nbsp;// The cluster index we are testing

//Checking for intersection given a cluster AABB and a light volume
bool testSphereAABB(uint light, uint tile){
&nbsp;&nbsp;&nbsp;&nbsp;float radius = sharedLights[light].range;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 center&nbsp;&nbsp;= vec3(viewMatrix * sharedLights[light].position);
&nbsp;&nbsp;&nbsp;&nbsp;float squaredDistance = sqDistPointAABB(center, tile);

&nbsp;&nbsp;&nbsp;&nbsp;return squaredDistance &lt;= (radius * radius);
}
</code></pre>
<ul>
	<li>
		<p>
            The main idea is that we check the distance between the point light sphere center and the AABB. If the distance is less than the radius they are intersecting.
		</p>
	</li>
	<li>
		<p>
            For spotlights, the light volume and consequently the collision tests will be very different.
		</p>
		<ul>
			<li>
				<p>
                    Check out 
					<a
						href="https://newq.net/dl/pub/SA2014Practical.pdf" 
						class="external-link" 
						target="_blank" >
                        this
					</a>
                    &nbsp;presentation by Emil Persson that explains how they implemented spotlight culling in Just Cause 3 if you do want to know more.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="light-assignment" >
    Light Assignment
</h5>
<ul>
	<li>
		<p>
            The lights have a limited range, with some falloff which goes to 0 at the boundary.
		</p>
	</li>
	<li>
		<p>
            There is no pre-computation so all geometry and lights are allowed to change freely from frame to frame.
		</p>
	</li>
	<li>
		<p>
            The goal of the light assignment stage is to calculate the list of lights influencing each cluster. Previous designs for tiled deferred shading implementations have by and large utilized a brute force approach to finding the intersection between lights and tiles. That is, light-cluster overlaps were found by, for each tile, iterating over all lights in the scene and testing bounding volumes. This is tolerable for reasonably low numbers of lights and clusters.
		</p>
	</li>
	<li>
		<p>
            To support large numbers of lights and a dynamically varying number of clusters, we use a fully hierarchical approach based on a spatial tree over the lights.
		</p>
	</li>
	<li>
		<p>
            Each frame, we construct a 
			<em>
                bounding volume hierarchy (BVH)
			</em>
            &nbsp;by first sorting the lights according to the Z-order (Morton Code) based on the discretized centre position of each light. We derive the discretization from a dynamically computed bounding volume around all lights.
		</p>
		<ul>
			<li>
				<p>
                    We use a BVH with a branching factor of 32, which is rebuilt each frame.
				</p>
			</li>
			<li>
				<p>
                    When not so many lights are used, there are many other approaches which may be better.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The leaves of the search tree we get directly from the sorted data.
		</p>
	</li>
	<li>
		<p>
            Next, 32 consecutive leaves are grouped into a bounding volume (AABB) to form the first level above the leaves.
		</p>
	</li>
	<li>
		<p>
            The next level is constructed by again combining 32 consecutive elements. We continue until a single root element remains.
		</p>
	</li>
	<li>
		<p>
            For each cluster, we traverse this BVH using depth-first traversal. At each level, the bounding box of the cluster (either explicitly computed from the cluster’s contents or implicitly derived from the cluster’s key) is tested against the bounding volumes of the child nodes. For the leaf nodes, the sphere bounding the light source is used; other nodes store an AABB enclosing the node. The branching factor of 32 allows efficient SIMD-traversal on the GPU and keeps the search tree relatively shallow (up to 5 levels), which is used to avoid expensive recursion (the branching factor should be adjusted depending on the GPU used, the factor of 32 is convenient on current NVIDIA GPUs).
		</p>
	</li>
	<li>
		<p>
			<strong>
                If
			</strong>
            &nbsp;a normal cone is available for a cluster, we use this cone to further reject lights that will not affect any samples in the cluster; etc (to summarize).
		</p>
	</li>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Deriving the explicit cluster bounds was something that could be interesting, but we found that sticking to implicit bounds simplified the technique, while also allowing the light assignment to run on the CPU.
				</p>
			</li>
			<li>
				<p>
                    In addition, this gives us scene independence. This means that we don’t need to know what the scene looks like to fill in the clusters, and this also allows us to evaluate light at any given point in space, even if it’s floating in thin air. This could be relevant for instance for ray-marching effects.
				</p>
			</li>
			<li>
				<p>
                    Given that we are doing the light assignment on the CPU, one may suspect that this will become a significant burden for the CPU. However, our implementation is fast enough to actually save us a bunch of CPU time over our previous solution. In a normal artist lit scene we recorded 0.1ms on one core for clustered shading. The old code supporting our previous forward pass for transparency that was still running in our system was still consuming 0.67ms for the same scene, a cost that we can now eliminate.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Filament Engine
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Before rendering a frame, each light in the scene is assigned to any froxel it intersects with. The result of the lights assignment pass is a list of lights for each froxel.
				</p>
			</li>
			<li>
				<p>
                    Lights assignment can be done in two different ways, on the GPU or on the CPU.
				</p>
			</li>
			<li>
				<p>
                    On GPU:
				</p>
				<ul>
					<li>
						<p>
                            The lights are stored in Shader Storage Buffer Objects (SSBO) and passed to a compute shader that assigns each light to the corresponding froxels.
						</p>
					</li>
					<li>
						<p>
                            The lights assignment can be performed each frame by another compute shader.
						</p>
					</li>
					<li>
						<p>
                            The threading model of compute shaders is particularly well suited for this task. We simply invoke as many workgroups as we have froxels (we can directly map the X, Y and Z workgroup counts to our froxel grid resolution). Each workgroup will in turn be threaded and traverse all the lights to assign.
						</p>
					</li>
					<li>
						<p>
                            Intersection tests imply simple sphere/frustum or cone/frustum tests.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Assigning Lights with Froxels
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Assigning lights to froxels can be implemented on the GPU using two compute shaders.
								</p>
							</li>
							<li>
								<p>
                                    The first one, creates the froxels data (4 planes + a min Z and max Z per froxel) in an SSBO and needs to be run only once.
								</p>
								<ul>
									<li>
										<p>
                                            Projection matrix
										</p>
										<ul>
											<li>
												<p>
                                                    The projection matrix used to render the scene (view space to clip space transformation).
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Inverse projection matrix
										</p>
										<ul>
											<li>
												<p>
                                                    The inverse of the projection matrix used to render the scene (clip space to view space transformation).
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Depth parameters
										</p>
										<ul>
											<li>
												<p>
                                                    <img src="assets/image_20250922083216.png" width="" >
                                                    , maximum number of depth slices, Z near and Z far.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Clip space size
										</p>
										<ul>
											<li>
												<p>
                                                    <img src="assets/image_20250922083239.png" width="" >
                                                    , with $F_x$ the number of tiles on the X axis, $F_r$ the resolution in pixels of a tile and w the width in pixels of the render target.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
<pre><code class="language-glsl" data-lang="glsl"> #version 310 es
 
 precision highp float;
 precision highp int;
 
 
 #define FROXEL_RESOLUTION 80u
 
 layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
 
 layout(location = 0) uniform mat4 projectionMatrix;
 layout(location = 1) uniform mat4 projectionInverseMatrix;
 layout(location = 2) uniform vec4 depthParams; // index scale, index bias, near, far
 layout(location = 3) uniform float clipSpaceSize;
 
 struct Froxel {
&nbsp;&nbsp;&nbsp;&nbsp; // NOTE: the planes should be stored in vec4[4] but the
&nbsp;&nbsp;&nbsp;&nbsp; // Adreno shader compiler has a bug that causes the data
&nbsp;&nbsp;&nbsp;&nbsp; // to not be read properly inside the loop
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane0;
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane1;
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane2;
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane3;
&nbsp;&nbsp;&nbsp;&nbsp; vec2 minMaxZ;
 };
 
 layout(binding = 0, std140) writeonly restrict buffer FroxelBuffer {
&nbsp;&nbsp;&nbsp;&nbsp; Froxel data[];
 } froxels;
 
 shared vec4 corners[4];
 shared vec2 minMaxZ;
 
 vec4 projectionToView(vec4 p) {
&nbsp;&nbsp;&nbsp;&nbsp; p = projectionInverseMatrix * p;
&nbsp;&nbsp;&nbsp;&nbsp; return p / p.w;
 }
 
 vec4 createPlane(vec4 b, vec4 c) {
&nbsp;&nbsp;&nbsp;&nbsp; // standard plane equation, with a at (0, 0, 0)
&nbsp;&nbsp;&nbsp;&nbsp; return vec4(normalize(cross(c.xyz, b.xyz)), 1.0);
 }
 
 void main() {
&nbsp;&nbsp;&nbsp;&nbsp; uint index = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
 
&nbsp;&nbsp;&nbsp;&nbsp; if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // first tile the screen and build the frustum for the current tile
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec2 renderTargetSize = vec2(FROXEL_RESOLUTION * gl_NumWorkGroups.xy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec2 frustumMin = vec2(FROXEL_RESOLUTION * gl_WorkGroupID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec2 frustumMax = vec2(FROXEL_RESOLUTION * (gl_WorkGroupID.xy + 1u));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; corners[0] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustumMin.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (renderTargetSize.y - frustumMin.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; corners[1] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustumMax.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (renderTargetSize.y - frustumMin.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; corners[2] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustumMax.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (renderTargetSize.y - frustumMax.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; corners[3] = vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustumMin.x / renderTargetSize.x * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (renderTargetSize.y - frustumMax.y) / renderTargetSize.y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * clipSpaceSize - 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint froxelSlice = gl_WorkGroupID.z;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minMaxZ = vec2(0.0, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (froxelSlice &gt; 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minMaxZ.x = exp2((float(froxelSlice) - depthParams.y) * depthParams.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * depthParams.w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minMaxZ.y = exp2((float(froxelSlice + 1u) - depthParams.y) * depthParams.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * depthParams.w;
&nbsp;&nbsp;&nbsp;&nbsp; }
 
&nbsp;&nbsp;&nbsp;&nbsp; if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec4 frustum[4];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustum[0] = projectionToView(corners[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustum[1] = projectionToView(corners[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustum[2] = projectionToView(corners[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frustum[3] = projectionToView(corners[3]);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; froxels.data[index].plane0 = createPlane(frustum[0], frustum[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; froxels.data[index].plane1 = createPlane(frustum[1], frustum[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; froxels.data[index].plane2 = createPlane(frustum[2], frustum[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; froxels.data[index].plane3 = createPlane(frustum[3], frustum[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; froxels.data[index].minMaxZ = minMaxZ;
&nbsp;&nbsp;&nbsp;&nbsp; }
 }
</code></pre>
						<ul>
							<li>
								<p>
                                    The second compute shader, runs every frame (if the camera and/or lights have changed) and assigns all the lights to their respective froxels.
								</p>
								<ul>
									<li>
										<p>
                                            Light index buffer
										</p>
										<ul>
											<li>
												<p>
                                                    For each froxel, the index of each light that affects said froxel. The indices for point lights are written first and if there is enough space left, the indices for spot lights are written as well. A sentinel of value 0×7fffffffu separates point and spot lights and/or marks the end of the froxel's list of lights. Each froxel has a maximum number of lights (point + spot).
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Point lights buffer
										</p>
										<ul>
											<li>
												<p>
                                                    Array of structures describing the scene's point lights.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Spot lights buffer
										</p>
										<ul>
											<li>
												<p>
                                                    Array of structures describing the scene's spot lights.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Froxels buffer
										</p>
										<ul>
											<li>
												<p>
                                                    The list of froxels represented by planes, created by the previous compute shader.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
<pre><code class="language-glsl" data-lang="glsl"> #version 310 es
 precision highp float;
 precision highp int;
 
 #define LIGHT_BUFFER_SENTINEL 0x7fffffffu
 #define MAX_FROXEL_LIGHT_COUNT 32u
 
 #define THREADS_PER_FROXEL_X 8u
 #define THREADS_PER_FROXEL_Y 8u
 #define THREADS_PER_FROXEL_Z 1u
 #define THREADS_PER_FROXEL (THREADS_PER_FROXEL_X * \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THREADS_PER_FROXEL_Y * THREADS_PER_FROXEL_Z)
 
 layout(local_size_x = THREADS_PER_FROXEL_X,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_size_y = THREADS_PER_FROXEL_Y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_size_z = THREADS_PER_FROXEL_Z) in;
 
 // x = point lights, y = spot lights
 layout(location = 0) uniform uvec2 totalLightCount;
 layout(location = 1) uniform mat4 viewMatrix;
 
 layout(binding = 0, packed) writeonly restrict buffer LightIndexBuffer {
&nbsp;&nbsp;&nbsp;&nbsp; uint index[];
 } lightIndexBuffer;
 
 struct PointLight {
&nbsp;&nbsp;&nbsp;&nbsp; vec4 positionFalloff; // x, y, z, falloff
&nbsp;&nbsp;&nbsp;&nbsp; vec4 colorIntensity;&nbsp;&nbsp;// r, g, b, intensity
&nbsp;&nbsp;&nbsp;&nbsp; vec4 directionIES;&nbsp;&nbsp;&nbsp;&nbsp;// dir x, dir y, dir z, IES profile index
 };
 
 layout(binding = 1, std140) readonly restrict buffer PointLightBuffer {
&nbsp;&nbsp;&nbsp;&nbsp; PointLight lights[];
 } pointLights;
 
 struct SpotLight {
&nbsp;&nbsp;&nbsp;&nbsp; vec4 positionFalloff; // x, y, z, falloff
&nbsp;&nbsp;&nbsp;&nbsp; vec4 colorIntensity;&nbsp;&nbsp;// r, g, b, intensity
&nbsp;&nbsp;&nbsp;&nbsp; vec4 directionIES;&nbsp;&nbsp;&nbsp;&nbsp;// dir x, dir y, dir z, IES profile index
&nbsp;&nbsp;&nbsp;&nbsp; vec4 angle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // angle scale, angle offset, unused, unused
 };
 
 layout(binding = 2, std140) readonly restrict buffer SpotLightBuffer {
&nbsp;&nbsp;&nbsp;&nbsp; SpotLight lights[];
 } spotLights;
 
 struct Froxel {
&nbsp;&nbsp;&nbsp;&nbsp; // NOTE: the planes should be stored in vec4[4] but the
&nbsp;&nbsp;&nbsp;&nbsp; // Adreno shader compiler has a bug that causes the data
&nbsp;&nbsp;&nbsp;&nbsp; // to not be read properly inside the loop
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane0;
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane1;
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane2;
&nbsp;&nbsp;&nbsp;&nbsp; vec4 plane3;
&nbsp;&nbsp;&nbsp;&nbsp; vec2 minMaxZ;
 };
 
 layout(binding = 3, std140) readonly restrict buffer FroxelBuffer {
&nbsp;&nbsp;&nbsp;&nbsp; Froxel data[];
 } froxels;
 
 shared uint groupLightCounter;
 shared uint groupLightIndexBuffer[MAX_FROXEL_LIGHT_COUNT];
 
 float signedDistanceFromPlane(vec4 p, vec4 plane) {
&nbsp;&nbsp;&nbsp;&nbsp; // plane.w == 0.0, simplify computation
&nbsp;&nbsp;&nbsp;&nbsp; return dot(plane.xyz, p.xyz);
 }
 
 void synchronize() {
&nbsp;&nbsp;&nbsp;&nbsp; memoryBarrierShared();
&nbsp;&nbsp;&nbsp;&nbsp; barrier();
 }
 
 void main() {
&nbsp;&nbsp;&nbsp;&nbsp; if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; groupLightCounter = 0u;
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; memoryBarrierShared();
 
&nbsp;&nbsp;&nbsp;&nbsp; uint froxelIndex = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
&nbsp;&nbsp;&nbsp;&nbsp; Froxel current = froxels.data[froxelIndex];
 
&nbsp;&nbsp;&nbsp;&nbsp; uint offset = gl_LocalInvocationID.x +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl_LocalInvocationID.y * THREADS_PER_FROXEL_X;
&nbsp;&nbsp;&nbsp;&nbsp; for (uint i = 0u; i &lt; totalLightCount.x &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; groupLightCounter &lt; MAX_FROXEL_LIGHT_COUNT &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset + i &lt; totalLightCount.x; i += THREADS_PER_FROXEL) {
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint currentLight = offset + i;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec4 center = pointLights.lights[currentLight].positionFalloff;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; center.xyz = (viewMatrix * vec4(center.xyz, 1.0)).xyz;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = inversesqrt(center.w);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (-center.z + r &gt; current.minMaxZ.x &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -center.z - r &lt;= current.minMaxZ.y) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (signedDistanceFromPlane(center, current.plane0) &lt; r &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signedDistanceFromPlane(center, current.plane1) &lt; r &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signedDistanceFromPlane(center, current.plane2) &lt; r &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signedDistanceFromPlane(center, current.plane3) &lt; r) {
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint index = atomicAdd(groupLightCounter, 1u);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; groupLightIndexBuffer[index] = currentLight;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; }
 
&nbsp;&nbsp;&nbsp;&nbsp; synchronize();
 
&nbsp;&nbsp;&nbsp;&nbsp; uint pointLightCount = groupLightCounter;
&nbsp;&nbsp;&nbsp;&nbsp; offset = froxelIndex * MAX_FROXEL_LIGHT_COUNT;
 
&nbsp;&nbsp;&nbsp;&nbsp; for (uint i = gl_LocalInvocationIndex; i &lt; pointLightCount;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += THREADS_PER_FROXEL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lightIndexBuffer.index[offset + i] = groupLightIndexBuffer[i];
&nbsp;&nbsp;&nbsp;&nbsp; }
 
&nbsp;&nbsp;&nbsp;&nbsp; if (gl_LocalInvocationIndex == 0u) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pointLightCount &lt; MAX_FROXEL_LIGHT_COUNT) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lightIndexBuffer.index[offset + pointLightCount] = LIGHT_BUFFER_SENTINEL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; }
 }
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    On CPU:
				</p>
				<ul>
					<li>
						<p>
                            The algorithm is different from the GPU implementation. Instead of iterating over every light for each froxel, the engine will “rasterize” each light as froxels. For instance, given a point light’s center and radius, it is trivial to compute the list of froxels it intersects with.
						</p>
					</li>
					<li>
						<p>
                            This technique has the added benefit of providing tighter culling than in the GPU variant. The CPU implementation can also more easily generate a packed list of lights.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="culling" >
    Culling
</h5>
<ul>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Point light
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250922210816.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Our light sources are typically artist placed, scaled for human environments in an outdoor world, so generally speaking from meters to tens of meters. So a light source generally intersects many clusters. The typical sphere-frustum tests that you can find online are not suitable for this sort of culling. They are made for view-frustum culling and based on the assumption that the frustum typically is much larger than the sphere, which is the opposite of what we have here. Typically they simply test sphere vs plane for each six planes of the frustum. This is conservative, but lets through spheres that aren’t completely behind any of the planes, such as in the frustum corners. The result you get is that green rectangle, or essentially a ”cube” of clusters around the light. But that’s also the first thing we compute. We simply compute the screen-space and depth extents of the light analytically first, so this test doesn’t actually help anything at all after that.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922210849.png" width="350" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Most frustum culling code is written with the scenario on the left in mind. We need to handle the scenario on the right.
						</p>
					</li>
					<li>
						<p>
                            One way to go about frustum culling is testing all planes, all edges and all vertices. This would work, but be too costly to outweigh the gains from fewer false positives. A fast, conservative but relatively tight solution is what we are looking for. There are many approaches that seem fitting, but there are also many complications, which has ultimately thrown many of our attempts into the garbage bin. One relatively straightforward approach is to cull against the cluster’s AABB. This is fast and gives fairly decent results, but it’s possible to do better.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922211034.png" width="300" >
                            &nbsp;
                            <img src="assets/image_20250922211119.png" width="124" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Starting with the ”cube” of clusters around the light, in our outer loop we iterate over the slices in z direction. We intersect the sphere with the slice where it is the widest. This results in a circle of a smaller radius than the original sphere, we thus continue in the y direction using a sphere of this smaller radius and the circle’s midpoint. In the center slice we simply proceed with the original sphere. We repeat this procedure in y and have an even smaller sphere. Then in the inner loop we do plane vs. sphere tests in x direction to get a strip of clusters to add the light to.
						</p>
					</li>
					<li>
						<p>
                            To optimize all the math we take advantage of the fact that in view-space, all planes will have components that are zero. A plane in the x direction will have zero y and offset, y direction has zero x and offset, and z-direction is basically only a z offset.
						</p>
					</li>
					<li>
						<p>
                            The resulting culling is somewhat tighter than a plain AABB test, and costs about the same. Where AABB culls around 15-25%, this technique culls around 20-30% from the “cube” of clusters.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922211134.png" width="400" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Spotlight
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            For spotlights we begin by finding the ”cube” of clusters around the light’s sphere, just like for pointlights, except this cube typically is much larger than necessary for a spotlight. However, this analytical test is cheap and goes a long way to limit the search space for following passes. Next we find a tighter ”cube” simply by scanning in all six directions, narrowing it down by doing plane-cone tests. There is likely a neat analytical solution here, but this seemed non- trivial. Given that the plane scanning works fine and is cheap we haven’t really explored that path.
						</p>
					</li>
					<li>
						<p>
                            Note that our cones are sphere-capped rather than flat-capped. That’s because the light attenuation is based on distance (as it should), rather than depth. Sphere-capped cones also generally behave much better for wide angles and doesn’t become extremely large as flat-capped cones can get.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250922211251.png" width="350" >
                            <img src="assets/image_20250922211332.png" width="125" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Finally, for the remaining ”cube” of clusters we cull each cluster with a sphere-capped cone vs. bounding sphere test. For this to work well we have to have relatively cubical shaped clusters, otherwise the bounding sphere becomes way oversized. Overall this technique results in a moderately tight culling that is good enough for us so far, although there is room for some minor improvement.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="shading" >
    Shading
</h5>
<ul>
	<li>
		<p>
            Shading differs from Tiled Shading only in how we look up the cluster for the view sample in question.
		</p>
	</li>
	<li>
		<p>
            For Tiled Shading, a simple 2D lookup, based on the screen-space coordinates, is sufficient to retrieve light-list offset and count. However, for clustered approaches, there no longer exists a direct mapping between the cluster key and the index into the list of unique clusters.
		</p>
	</li>
	<li>
		<p>
            In the sorting approach, we explicitly store this index for each pixel. This is achieved by tracking references back to the originating pixel, and, when the unique cluster list is established, storing the index to the correct pixel in a full screen buffer.
		</p>
	</li>
	<li>
		<p>
            When using page tables, after the unique clusters are found, we store the cluster index back to the physical memory location used to store the cluster key earlier (using the same page table as before). This means that a virtual lookup for the cluster key will yield the cluster index. Thus, each sample can look up the cluster index using the cluster key computed earlier (or re-computed).
		</p>
	</li>
</ul>
<h5
	id="cluster-key-packing" >
    Cluster Key Packing
</h5>
<ul>
	<li>
		<p>
            For maximum performance when using sorting or page tables, we wish to pack the cluster key into as few bits as possible. We allocate 8 bits to each i and j components, which identify the screen-space tile the cluster belongs to. This allows up to 8192 × 8192 size render targets (assuming screen-space tile size of 32 × 32 pixels). The depth index k is determined from settings for the near and far planes and Equation 2. In our scenes, we found 10 bits to be sufficient. This leaves up to 6 bits for the optional normal clustering. Using 6 bits, we can for instance support a resolution up to 3 × 3 subdivisions on each cube face (3 × 3 × 6 = 54 and dlog2 54e = 6). For more restricted environments, the data could be packed more aggressively, saving both time and space.
		</p>
	</li>
</ul>
<h5
	id="tile-sorting" >
    Tile sorting
</h5>
<ul>
	<li>
		<p>
            To the cluster key (between 10 and 16 bits wide) we attach an additional 10 bits of meta-data, which identifies the sample’s original position relative to its tile. We then perform a tile-local sort of the cluster keys and the associated meta-data. The sort only considers the up-to 16 bits of the cluster key; the meta-data is used as a link back to the original sample after sorting. In each tile, we count the number of unique cluster keys. Using a prefix operation over the counts from each tile, we find the total number of unique cluster keys and assign each cluster a unique ID in the range 
            <code>[0...numClusters)</code>
            . We write the unique ID back to each pixel that is a member of the cluster. The unique ID also serves as an offset in memory to where the cluster’s data is stored.
		</p>
	</li>
	<li>
		<p>
            Bounding volumes (AABB and normal cone) can be re-constructed from the cluster keys, in which case each cluster only needs to store its cluster key. For explicit bounding volumes, we additionally store the AABB and/or normal cone. The explicit bounding volumes are computed using a reduction operation: for instance, AABBs can be found using a min- and a max-reduction operation on the sample positions. The meta-data from the locally sorted cluster keys gives us information on which samples belong to a given cluster.
		</p>
	</li>
</ul>
<h5
	id="shadows" >
    Shadows
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.cse.chalmers.se/~uffe/ClusteredWithShadows.pdf" 
				class="external-link" 
				target="_blank" >
                Efficient Virtual Shadow Maps for Many Lights - Ola Olsson - 2014
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This paper builds on clustered shading.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922212154.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Etc
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I saw this in some paper and left it loose; maybe I’ll revisit it later.
				</p>
			</li>
			<li>
				<p>
                    Resolution Matched Shadow Maps (RMSM), must determine which shadow pages are used by the view samples. The method achieves this by first exploiting screen space coherency to reduce duplicate requests from adjacent pixels in screen space. Globally unique requests are then determined by sorting and compacting the remaining requests.
				</p>
			</li>
			<li>
				<p>
                    Garanzha present a similar technique that they call Compress-Sort-Decompress (CSD). Their goal is to find 3D (or 5D) clusters in a frame buffer, which are used to form ray packets. The main differences are that Garanzha et al. treat the frame buffer as a 1D sequence and use run length encoding (RLE) to reduce duplicates before sorting. They expand the result after the sorting.
				</p>
			</li>
			<li>
				<p>
                    The approaches in both RMSMs and CSD rely on the presence of coherency between adjacent input elements, in 2D and 1D respectively. In many cases, this is a reasonable assumption. However, techniques such as multi sampling anti aliasing (MSAA) with alpha-to-coverage, or stochastic transparency, invalidate this assumption. Coherency is still present in the frame buffer, but not between adjacent samples. For scenes with low coherence between adjacent samples, both of these methods degenerate to sorting the entire frame buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It has even been stated that shadow maps are unsuited for many lights. However, when limiting the problem as I have just done, there really is no fundamental reason against shadow maps. And given that they are the de facto standard in the real-time industry, they must clearly be the first stop, if nothing else to provide a benchmark for more clever ideas.
		</p>
	</li>
	<li>
		<p>
            To create shadow maps, we need to perform the following steps each frame, using the current camera view:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250923080409.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    The first step is the same as determining what lights are needed for shading, and we have already seen how this can be achieved using clustered shading and other methods.
				</p>
			</li>
			<li>
				<p>
                    The last step is also fairly trivial, using 
					<em>
                        bindless textures
					</em>
                    , 
					<em>
                        array textures
					</em>
                    &nbsp;or 
					<em>
                        shadow map atlases
					</em>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081229.png" width="250" >
                    <img src="assets/image_20250923081212.png" width="250" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081156.png" width="250" >
                    <img src="assets/image_20250923081136.png" width="250" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081256.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    As we saw before, the shadow map samples can be very tightly grouped, requiring a high shadow map resolution And note how this happens when most of the shadow map would be unused! This is pretty much how it has to be, as the high density comes from looking at something very near the camera, and then we’re guaranteed to not see so very much of the scene. This is highly wasteful and a fantastic opportunity, for...
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081059.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Keyword: Virtual Shadow Maps (Virtual SMs).
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            See pages 181 to 195 of 
							<a
								href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
								class="external-link" 
								target="_blank" >
                                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
							</a>
                            &nbsp;for more information.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081545.png" width="377" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In other terms, this means the difference between impossible on a current console and something we might consider.
				</p>
			</li>
			<li>
				<p>
                    Our method achieves quite uniform shadow quality, this means we can control quality and thus memory usage with a global parameter. This allows more flexibility in memory use while maintaining uniform quality. An interesting idea is to do this dynamically, to ensure a certain memory budget. Should be possible as it is very quick to work out memory usage from the used pages and resolutions.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250923081724.png" width="400" >
                    <img src="assets/image_20250923081802.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Recall that the peak is 322MB without reducing quality.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Cull Shadow Cast Geometry
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            This process is just like normal view frustum culling, in that we are trying to get rid of geometry that is not visible, and that we do this by testing bounding volumes of chunks or batches of triangles.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923081907.png" width="300" >
                            <img src="assets/image_20250923082134.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            What is not like view frustum culling is that we need to perform hundreds of these tests. The view volumes are quite small, or short, given the limited range of the lights. There are 6 adjacent frustra sharing planes. This adjacency means we can share calculations.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082259.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Here is the somewhat condensed code we use to calculate the culling mask, with a bit for each cube face. This is a very efficient test, checking only 6 planes for six frustums. Especially as the plane equations are all ones and zeroes, which means that if the loop is unrolled, most of this code just goes away. I think this is a rather big advantage with cube maps, over using separate frustums (As done in [6]). This efficiency is especially important given that we will be culling a lot more objects than normal culling!
						</p>
					</li>
					<li>
						<p>
                            You see, to enable efficient culling, batches must be small. Intuitively, for any culling, the optimal size of batches correlates to the size of the frustums. If batches are too large, the triangles get replicated into most cube faces.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082424.png" width="350" >
                            .
						</p>
					</li>
					<li>
						<p>
                            So we are trading increased culling work for fewer triangles drawn. Triangle drawing is the biggest performance bottleneck so this is important to be able to tune.
						</p>
					</li>
					<li>
						<p>
                            We used batches of up to 128 triangles, in practice they average around 68 triangles. A batch is represented by an AABB and a list of triangles. The batches are constructed in a pre-process, that builds a tree using agglomerative clustering (see the paper section 6.2.1). Note that the quality of the batches is fairly important for good performance. The batches are stored in a flat array that is loaded into the runtime.
						</p>
						<ul>
							<li>
								<p>
									<input
										type="checkbox" 
										disabled=""
>
                                    These values remind me of &quot;clusters in the rabbit&quot;. See Optimization Techniques -&gt; Cluster.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082534.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082807.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            For efficient culling, we obviously need a hierarchy.
						</p>
					</li>
					<li>
						<p>
                            The important thing is to balance the time spent building and traversing an acceleration structure. This trade-off has been studied by Karras and Aila in context of ray tracing, and is a very interesting read. In short, it suggests to me that the acceleration structure for just a few thousand box queries must be pretty bad to be worth building.
						</p>
					</li>
					<li>
						<p>
                            We used a very simple, full, 32-way BVH which is completely rebuilt each frame. This is in no way the best possible structure, or even the fastest to build, but it has served us well.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923082902.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Here we parallelize the lights, and each light traverses the hierarchy to find the batches that overlap the sphere. These batches are those that may produce a shadow if drawn into the shadow map.
						</p>
					</li>
					<li>
						<p>
                            This produces a list for each light of pairs of cube face masks and batch indexes. The Cube Face Mask is a bit mask where each bit indicates if it overlaps a certain cube face. This tells us what batches to draw to which cube faces of each light.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083025.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083139.png" width="300" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Green: source light BB.
								</p>
							</li>
							<li>
								<p>
                                    Black: Shadow casters.
								</p>
							</li>
							<li>
								<p>
                                    Blue: Clusters containing samples.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Note that the shadow casters are outside of the view volume, and so have no clusters associated, but cast their shadow through the view volume. So we’re interested in finding out what shadows affect the visible samples, and thus determine if the shadow caster needs to be drawn.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083317.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Instead of doing some crazy thing, like shadow volumes, we can figure this out by projecting the shadow caster onto the light source. This gives us these two intervals on the cube face.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250923083405.png" width="300" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Doing the same thing for the clusters, gives us another interval. If the projection of a shadow caster overlaps that of some clusters, i.e. shadow receiver, …it needs to be rendered into this shadow map, else, it doesn’t. Note that the clusters don’t need to form a range for this to work, any overlap will do.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            The subject continues from pages 225 to 243 of 
							<a
								href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
								class="external-link" 
								target="_blank" >
                                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    I found it quite specific and complicated to implement, for something I'm not focusing on right now.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Classic deferred has the advantage that you can iterate light by light, and thus reuse resources such as shadow buffers in between. This saves some memory, which may be needed on current generation consoles. On PC and next-generation consoles this is not nearly as big a problem.
				</p>
			</li>
			<li>
				<p>
                    With the switch to clustered shading the cost of adding a new light to the scene is small. Artists can now be moderate ”wasteful” without causing much problems performance-wise. This is not true for rasterizing shadow buffers. They remain expensive, and relatively speaking going to be more expensive going forward since it’s often a ROP-bound process, and ROPs aren’t getting scaled up nearly as much as ALU. So we still need to be a bit conservative about how many shadow casting lights we add to the scene.
				</p>
			</li>
			<li>
				<p>
                    An observation that was made is that artists often place very similar looking lights close to each other. In some cases it is to get a desired profile of a light, in which case the two lights may in fact be centered at the exact same point. But often it is motivated by the real world, such as two headlights on car. Some vehicles actually have ten or more lights, all pointing in the same general direction. Rendering ten shadow buffers for that may prove to be far too expensive.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250922211554.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Often it works just fine to share a single shadow buffer for these lights. While the shadow may be slightly off, this is usually not something that you will notice unless you are specifically looking for it. To make this work the shadow buffer is decoupled from lights and the light is assigned a shadow buffer and frustum from which to extract shadows. The shadow frustum has to be large enough to include all the different lights that uses it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="transparency" >
    Transparency
</h5>
<ul>
	<li>
		<p>
            When the transparent geometry is considered, the depth range optimization cannot be fully used. Instead, only a more conventional hierarchical depth test can be used. The grid structure can be built once, and quickly pruned to prepare a more efficient instance for opaque geometry. However, as each transparent layer must consider all the lights in the tile, performance does not scale linearly with the depth complexity, but far worse.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922170304.png" width="209" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            To improve on this we extend clustered forward shading by constructing the grid using a 
			<em>
                pre-pass over all geometry
			</em>
            &nbsp;(not just opaque), and flagging clusters as a side effect. This allows us to quickly find the unique clusters used.
		</p>
	</li>
	<li>
		<p>
            As clusters contain only space around actual samples that need shading, efficiency is much better.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922170026.png" width="212" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For deferred shading a single 1080p, 16x MSAA, 16-bit float RGBA buffer requires over 250Mb of memory. In addition, each sample may need to be shaded individually, effectively running shading at a per-sample frequency.
		</p>
	</li>
	<li>
		<p>
            For forward shading, no G-Buffers are required and MSAA is trivially enabled.
		</p>
	</li>
</ul>
<h5
	id="optimized-forward-renderer" >
    Optimized Forward Renderer
</h5>
<ul>
	<li>
		<p>
			<strong>
                High-level overview
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909094633.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909094044.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909094439.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Performance caveats
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909094750.png" width="650" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Triangle Overshading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909095017.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909095147.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="papers-and-presentations" >
    Papers and Presentations
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://google.github.io/filament/Filament.html.html#imagingpipeline/lightpath" 
				class="internal-link" 
				target="_self" >
                Clustered Forward Shading - PBR Filament
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://google.github.io/filament/Filament.html.html#annex/lightassignmentwithfroxels" 
				class="internal-link" 
				target="_self" >
                Froxel Generation - PBR Filament
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf" 
				class="external-link" 
				target="_blank" >
                Clustered Deferred and Forward Shading - Ola Olsson - 2012
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.researchgate.net/profile/Ulf-Assarsson/publication/254463291_Tiled_and_Clustered_Forward_Shading_Supporting_Transparency_and_MSAA/links/55f6cdb608aeba1d9eed7fc6/Tiled-and-Clustered-Forward-Shading-Supporting-Transparency-and-MSAA.pdf?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uIn19" 
				class="external-link" 
				target="_blank" >
                Tiled and Clustered Forward Shading Supporting Transparency and MSAA - Ola Olsson - 2012
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
				class="external-link" 
				target="_blank" >
                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Avalanche Studios did:
				</p>
				<ul>
					<li>
						<p>
                            Just Cause 1 (Forward), Just Cause 2 (Forward), Mad Max (Deferred).
						</p>
					</li>
					<li>
						<p>
                            Just Cause 3, Just Cause 4, Generation Zero, Rage 2.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.aortiz.me/2018/12/21/CG.html" 
				class="external-link" 
				target="_blank" >
                A Primer On Efficient Rendering Algorithms &amp; Clustered Shading - Angel Ortiz - Rockstar North - 2018
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Part 2 explains the implementation of the technique.
				</p>
			</li>
			<li>
				<p>
                    Great read, pretty good, with some implementation explanations and source code in OpenGL.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://github.com/DaveH355/clustered-shading" 
				class="external-link" 
				target="_blank" >
                Cluster Shading OpenGL - David Hu - 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This is not a sample, just a C++ and OpenGL tutorial with some GLSL shaders for reference.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.gdcvault.com/play/1025420/Cluster-Forward-Rendering-and-Anti" 
				class="external-link" 
				target="_blank" >
                Clustered Forward Rendering and Anti-Aliasing in Detroit: Become Human - GDC 2018
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/" 
				class="external-link" 
				target="_blank" >
                Doom (2016) - Graphics Study - Adrian Courreges - 2016
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://pt.slideshare.net/slideshow/siggraph2016-the-devil-is-in-the-details-idtech-666/64714659" 
				class="external-link" 
				target="_blank" >
                Doom (2016) - The Devil is in the Details - Siggraph 2016
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbExyYm9nWElMSzhBTDFtMVVVMHRiNFpxUGRhd3xBQ3Jtc0trRkVqekVNa2NzUy0xZHRFM2lLdERTOUR1amVPcUtEVERiZ1JTeGowdEtZNUx0Y2ZKUUxoT2dwOGJDcEVCNGlMQm1SQmxWT21wQkpaWk5LZWVOeldQWXJzbWFKNzMtRmFVcVE3d1JLVTdVamk1VUdZVQ&q=https%3A%2F%2Fadvances.realtimerendering.com%2Fs2020%2FRenderingDoomEternal.pdf&v=QVbOp1h-Jb4" 
				class="external-link" 
				target="_blank" >
                Rendering the Hellscape of Doom Eternal - idTech - 2020
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="http://advances.realtimerendering.com/s2017/2017_Sig_Improved_Culling_final.pdf" 
				class="external-link" 
				target="_blank" >
                Improved Culling for Tiled and Clustered Rendering - Michal Drobot / Call of Duty / Activision - Siggraph 2017
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://wickedengine.net/2019/02/thoughts-on-light-culling-stream-compaction-vs-flat-bit-arrays/" 
						class="external-link" 
						target="_blank" >
                        Thoughts on Light Culling: Stream Compaction vs Flat Bits Array - Wicked Engine 2019
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.adriancourreges.com/blog/" 
				class="external-link" 
				target="_blank" >
                Graphics Studies compilation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            ~
			<a
				href="https://www.3dgep.com/volume-tiled-forward-shading/" 
				class="external-link" 
				target="_blank" >
                Volume Tiled Forward Shading - Jeremiah Van Oosten - 2017
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Supposedly: Volume &gt; Clustered &gt; Tiled.
				</p>
			</li>
			<li>
				<p>
                    Volume Tiled Forward Shading is based on Tiled and Clustered Forward Shading from Ola Olsson.
				</p>
			</li>
			<li>
				<p>
                    By first constructing a Bounding Volume Hierarchy (BVH) over the lights, we can achieve millions of light sources while maintaining real-time frame rates.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=nyItqF3sM84" 
						class="external-link" 
						target="_blank" >
                        Demo - Jeremiah Van Oosten - 2017
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            So... it seems the only thing he did was add BVH to the technique, however that seems to already be done by default in the culling part of Clustered Shading....
						</p>
					</li>
					<li>
						<p>
                            I don't understand. Did someone copy someone here? I'm confused...
						</p>
					</li>
					<li>
						<p>
                            His master's thesis is huge, but much of it is kind of &quot;padding&quot;, as it's just a presentation of previous works.
						</p>
					</li>
					<li>
						<p>
                            Hmmm idk. He's not wrong, it just sounds odd.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.humus.name/Articles/PracticalClusteredShading.pdf" 
				class="external-link" 
				target="_blank" >
                Practical Clustered Shading - Avalanche Studios 2015
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Exactly the same presentation as 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014'; see that presentation, since it has presenter comments.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbEl2WGFDbXJ1S2hUYmZZdzFraFpIY3g5TnNLd3xBQ3Jtc0ttVHBlNTRRaEcwVXdXRXlCUkdrQzViWWNZRmhwbHNscFNzMTJwN19pX0lySjRuSG1lMkFubVZMZlVIUHNzWnJEcEJQUTNmNDBiRnlPb1ZUTkVjUkV0dlYtN3NTU0xvbi1PZWgzblpJbEF0UkV1T05JTQ&q=http%3A%2F%2Fnewq.net%2Fdl%2Fpub%2FSA2014Practical.pdf&v=QVbOp1h-Jb4" 
				class="external-link" 
				target="_blank" >
                Practical Clustered Shading 2/4 - Avalanche Studios - 2014
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    The presentation comes after 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014', since Just Cause 3 had already been announced, using Clustered Shading.
				</p>
			</li>
			<li>
				<p>
                    The presentation is very similar to 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014'.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/watch?v=uEtI7JRBVXk" 
				class="external-link" 
				target="_blank" >
                Managing many lights in real time with clustered shading - Ola Olsson 2016
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Based on the 'Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche) - 2014' presentation, with basically no changes.
				</p>
			</li>
			<li>
				<p>
                    I preferred to read the former, for better slide visibility and because the presentation is much more in-depth. Also, the earlier presentation seemed to have more enthusiasm and depth; perhaps the audience for this presentation did not show much enthusiasm.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="samples" >
    Samples
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Angelo1211/HybridRenderingEngine/tree/master" 
				class="external-link" 
				target="_blank" >
                HybridRenderingEngine OpenGL (Clustered Forward/Deferred) - Sample - Angel Ortiz - 2018
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Clustered Forward/Deferred Renderer
				</p>
			</li>
			<li>
				<p>
                    Physically Based shading
				</p>
			</li>
			<li>
				<p>
                    Image Based Lighting
				</p>
			</li>
			<li>
				<p>
                    Metallic workflow
				</p>
			</li>
			<li>
				<p>
                    Cook-Torrance specular BRDF (w/ lambert diffuse)
				</p>
			</li>
			<li>
				<p>
                    Ambient Occlusion &amp; Emissive mapping
				</p>
			</li>
			<li>
				<p>
                    Tangent space normal mapping
				</p>
			</li>
			<li>
				<p>
                    HDR/linear lighting
				</p>
			</li>
			<li>
				<p>
                    HDR/LDR skyboxes
				</p>
			</li>
			<li>
				<p>
                    Exposure based tone mapping
				</p>
			</li>
			<li>
				<p>
                    Bloom
				</p>
			</li>
			<li>
				<p>
                    Multisample Anti-aliasing (MSAA)
				</p>
			</li>
			<li>
				<p>
                    Directional &amp; point light sources
				</p>
			</li>
			<li>
				<p>
                    Compute shader based light culling
				</p>
			</li>
			<li>
				<p>
                    Alpha tested foliage (sponza atrium)
				</p>
			</li>
			<li>
				<p>
                    Directional light dynamic shadow mapping
				</p>
			</li>
			<li>
				<p>
                    Static Omnidirectional Shadow Mapping for Point Lights
				</p>
			</li>
			<li>
				<p>
                    Forward, Tiled Forward and Deferred rendering implementations
				</p>
				<ul>
					<li>
						<p>
                            Located in other branches of the repo. Only clustered rendering is actively being developed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Engine:
				</p>
				<ul>
					<li>
						<p>
                            OpenGL 4.5+
						</p>
					</li>
					<li>
						<p>
                            SDL2 backend
						</p>
					</li>
					<li>
						<p>
                            JSON Parsing via Nlohmann: JSON for C++
						</p>
					</li>
					<li>
						<p>
                            Model Loading via ASSIMP (OBJ, FBX, gLTF2.0 etc)
						</p>
					</li>
					<li>
						<p>
                            Scene contents clearly outlined in JSON file
						</p>
					</li>
					<li>
						<p>
                            Multiple image loading paths via stb-image and GLI
						</p>
					</li>
					<li>
						<p>
                            Immediate mode GUI for debugging via ImGUI
						</p>
					</li>
					<li>
						<p>
                            Fully commented for future referencing
						</p>
					</li>
					<li>
						<p>
                            Environment map generation on load for IBL and skyboxes
						</p>
					</li>
					<li>
						<p>
                            Free flight camera
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="deferred-shading" >
    Deferred Shading
</h3>
<h4
	id="deferred" >
    Deferred
</h4>
<ul>
	<li>
		<p>
            Deferred shading is a screen-space shading technique that is performed on a second rendering pass, after the vertex and pixel shaders are rendered.
		</p>
	</li>
	<li>
		<p>
            &quot;I like to call it a &quot;fake rendering&quot;, as at the end of the day you'll be just doing your shading on a quad, not on the geometry&quot;.
		</p>
	</li>
	<li>
		<p>
            A shader that collects all geometry information into buffers, matches the first stage of a deferred renderer.
		</p>
	</li>
	<li>
		<p>
			<strong>
                GBuffer (&quot;Geometry Buffer&quot;)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    G-buffer is a set of textures or render targets used in deferred shading/rendering.
				</p>
			</li>
			<li>
				<p>
                    Instead of directly shading fragments during rasterization (as in forward rendering), the GPU first stores per-fragment data into the G-buffer.
				</p>
			</li>
			<li>
				<p>
                    A later pass (the lighting pass) reads from these buffers to compute lighting, shadows, reflections, etc.
				</p>
			</li>
			<li>
				<p>
                    A typical G-buffer contains attributes such as:
				</p>
				<ul>
					<li>
						<p>
                            World/eye space position of the fragment
						</p>
					</li>
					<li>
						<p>
                            Normals
						</p>
					</li>
					<li>
						<p>
                            Albedo (base color)
						</p>
					</li>
					<li>
						<p>
                            Specular properties
						</p>
					</li>
					<li>
						<p>
                            Possibly depth, roughness, metalness, etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The key point is: the first pass writes geometry information into multiple render targets (the G-buffer), and the second pass consumes it for lighting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909115633.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909120445.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909083205.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922174712.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The problem is from the fact that the innermost loop is over the pixels.
				</p>
			</li>
			<li>
				<p>
                    This requires repeated reading and writing of the G-Buffers and frame buffer.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="disadvantages" >
    Disadvantages
</h5>
<ul>
	<li>
		<p>
			<strong>
                Bandwidth
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909093834.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Consider marking non-persistent attachments as transient (
                    <code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code>
                    &nbsp;/ lazily allocated) so tile-based GPUs can keep them on-tile and reduce bandwidth.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transparency
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Inability to handle transparency within the algorithm, although this problem is a generic one in 
					<a
						href="https://en.wikipedia.org/wiki/Z-buffering" 
						class="external-link" 
						target="_blank" >
                        Z-buffered
					</a>
                    &nbsp;scenes and it tends to be handled by delaying and sorting the rendering of transparent portions of the scene.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://en.wikipedia.org/wiki/Depth_peeling" 
						class="external-link" 
						target="_blank" >
                        Depth peeling
					</a>
                    &nbsp;can be used to achieve 
					<a
						href="https://en.wikipedia.org/wiki/Order-independent_transparency" 
						class="external-link" 
						target="_blank" >
                        order-independent transparency
					</a>
                    &nbsp;in deferred rendering, but at the cost of additional batches and g-buffer size.
				</p>
			</li>
			<li>
				<p>
                    Modern hardware, supporting DirectX 10 and later, is often capable of performing batches fast enough to maintain interactive frame rates.
				</p>
			</li>
			<li>
				<p>
                    When order-independent transparency is desired (commonly for consumer applications) deferred shading is 
					<em>
                        no less
					</em>
                    &nbsp;effective than forward shading using the same technique.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909083851.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Example from GTA V.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Opaque is drawn with deferred renderer.
				</p>
			</li>
			<li>
				<p>
                    Transparent is drawn with forward renderer and then blended with the result of the deferred renderer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Difficulty with using multiple materials
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's possible to use many different materials, but it requires more data to be stored in the G-buffer, which is already quite large and takes up a large amount of the memory bandwidth.
				</p>
			</li>
			<li>
				<p>
                    Memory and bandwidth heavy (multiple render targets).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Another disadvantage of deferred shading is that only a single lighting model can be simulated in the lighting pass. This is due to the fact that it is only possible to bind a single pixel shader when rendering the light geometry. This is usually not an issue for pipelines that make use of übershaders as rendering with a single pixel shader is the norm, however if your rendering pipeline takes advantage of several different lighting models implemented in various pixel shaders then it will be problematic to switch your rendering pipeline to use deferred shading.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Bad MSAA
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Due to separating the lighting stage from the geometric stage, hardware anti-aliasing (MSAA) does not produce correct results anymore since interpolated subsamples would result in nonsensical position, normal, and tangent attributes.
				</p>
			</li>
			<li>
				<p>
                    One of the usual techniques to overcome this limitation is using edge detection (MLAA, FXAA, DLAA, or post MSAA) on the final image and then applying blur over the edges. TAA can also be used.
				</p>
			</li>
			<li>
				<p>
                    DirectX 10 introduced features allowing shaders to access individual samples in multi-sampled render targets (and depth buffers in version 10.1), giving users of this API access to hardware anti-aliasing in deferred shading. These features also allow them to correctly apply HDR luminance mapping to anti-aliased edges, where in earlier versions of the API any benefit of anti-aliasing may have been lost.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Extra complexity
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    G-buffer packing, formats, reconstructing positions, light culling systems, extra render passes and descriptor management.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="variants" >
    Variants
</h5>
<ul>
	<li>
		<p>
            As said by Ola Olsson:
		</p>
	</li>
	<li>
		<p>
            Deferred Lighting
		</p>
		<ul>
			<li>
				<p>
                    Factor out specular and diffuse color.
				</p>
			</li>
			<li>
				<p>
                    G-Buffer only stores normal and shininess.
				</p>
			</li>
			<li>
				<p>
                    Output diffuse and specular shading.
				</p>
			</li>
			<li>
				<p>
                    Second geometry pass which multiple colors.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Light Prepass.
		</p>
		<ul>
			<li>
				<p>
                    Much like the above.
				</p>
			</li>
			<li>
				<p>
                    But with monochromatic specular highlight.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            They offer similar performance as deferred.
		</p>
	</li>
	<li>
		<p>
            Only improves constant factors.
		</p>
	</li>
	<li>
		<p>
            Limits shading model even further.
		</p>
	</li>
</ul>
<h4
	id="tiled-deferred" >
    Tiled Deferred
</h4>
<ul>
	<li>
		<p>
            Tiled deferred shading removes the bandwidth bottleneck from deferred shading, instead making the technique compute bound. This enables efficient usage of devices with a high compute-to-bandwidth ratio, such as modern consoles and GPUs. Modern high-end games are using tiled deferred shading to allow for thousands of lights, which are required to push the limits of visual fidelity.
		</p>
	</li>
	<li>
		<p>
            With large numbers of lights, GI effects can be produced that affect dynamic as well as static geometry.
		</p>
	</li>
	<li>
		<p>
            Steps:
		</p>
		<ol>
			<li>
				<p>
                    Render scene to G-Buffers.
				</p>
			</li>
			<li>
				<p>
                    Cluster assignment.
				</p>
			</li>
			<li>
				<p>
                    Find unique clusters.
				</p>
			</li>
			<li>
				<p>
                    Assign lights to clusters.
				</p>
			</li>
			<li>
				<p>
                    Shade samples.
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
            The first step, rendering the model to populate the G-Buffers, does not differ from traditional deferred shading or from tiled deferred shading. The second step computes for each pixel which cluster it belongs to according to its position (possibly normal). In the third step, we reduce this into a list of unique clusters. The fourth step, assigning lights to clusters, consists of efficiently finding which lights influence which of the unique clusters and produce a list of lights for each cluster. Finally, for each sample, these light lists are accessed to compute the sample’s shading.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175750.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175810.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922175909.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Tiles in 1D, from side
				</p>
			</li>
			<li>
				<p>
                    View Frustum
				</p>
			</li>
			<li>
				<p>
                    4 subdivisions
				</p>
			</li>
			<li>
				<p>
                    Redline is geometry
				</p>
			</li>
			<li>
				<p>
                    Min and max depth per tile
				</p>
			</li>
			<li>
				<p>
                    Light range, rejected, completely hidden
				</p>
			</li>
			<li>
				<p>
                    Another rejected, completely in front
				</p>
			</li>
			<li>
				<p>
                    Rejected in one tile, not others
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="usage" >
    Usage
</h5>
<ul>
	<li>
		<p>
            Uncharted: Drake’s fortune.
		</p>
	</li>
	<li>
		<p>
            Battlefield 3.
		</p>
	</li>
	<li>
		<p>
            PlayStation 3.
		</p>
	</li>
	<li>
		<p>
            Xbox 360.
		</p>
	</li>
</ul>
<h5
	id="optimized-deferred-renderer" >
    Optimized Deferred Renderer
</h5>
<ul>
	<li>
		<p>
			<strong>
                High-level overview
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909093433.png" width="450" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            For SSR you need to take a lot of samples from G-Buffer B, and one sample from the shading color from the TAA pass.
						</p>
						<ul>
							<li>
								<p>
                                    We do the Raymarching using roughness and depth, once that is done we sample the TAA to get the final color.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            DOF: Depth of Field.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Compressing the GBuffer
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Optimized deferred shading renderer:
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909091124.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Random person in the comments: There's a small typo - Normal should be G32 and Emissive should be B32.
						</p>
						<ul>
							<li>
								<p>
                                    Does it make sense? maybe?
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lights
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909091634.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909092350.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Decals
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909092522.png" width="500" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Clustered Decals &gt; D-Buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909092622.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250909092646.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Post-processing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909093149.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=8rNl4A0qGao" 
				class="external-link" 
				target="_blank" >
                Demo and Source Code - Sascha Willems
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Based on my deferred shading example this new example adds shadows from multiple spotlights using shadow mapping. To avoid having multiple render passes for rendering the scene's depth from each of the light's point-of-view the example uses a layered depth attachment and multiple geometry shader invocations, so that an arbitrary number of depth maps can be generated in one pass. Each layer in the attachment corresponds to a light source and the geometry shader does multiple invocations on each vertex to output the scene into the different layers of the attachment. Each invocation uses a different light's mvp matrix. The final scene compositing pass then samples from the depth map array texture to determine if a fragment is shadowed or not.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/SaschaWillems/Vulkan?tab=readme-ov-file#Deferred" 
						class="external-link" 
						target="_blank" >
                        Source code
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=V7PxEpzkY1c" 
				class="external-link" 
				target="_blank" >
                Demo and Source Code
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://github.com/manuelpagliuca/deferred-render-vulkan" 
						class="external-link" 
						target="_blank" >
                        Source Code
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=RGM2eKVL30I" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Deferred lighting is physically based, using Cook-Torrance as the BRDF. In this demo the forward pass is only responsible for drawing the skybox, but could draw other rasterization pipelines not suitable for the deferred passes.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=g85DzhvRHXM" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=M9tOLSFXa5s" 
				class="external-link" 
				target="_blank" >
                Jonathan Blow's criticisms of Deferred Rendering
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    He bullshits and claims it's bad, unjustifiable.
				</p>
			</li>
			<li>
				<p>
                    &quot;Doesn't make sense in the modern day&quot;.
				</p>
			</li>
			<li>
				<p>
                    Counter-argument:
				</p>
				<ul>
					<li>
						<p>
                            Deferred is defined very very simply - do you have a G-buffer? If the answer is yes - you're deferred.
						</p>
					</li>
					<li>
						<p>
                            Pretty much all of high-performance forward renderers do a &quot;depth pre-pass&quot;, which is sort-of like &quot;deferred lite&quot;.
						</p>
					</li>
					<li>
						<p>
                            Forward has a huge benefit of being very bandwidth efficient, but it's very compute inefficient.
						</p>
					</li>
					<li>
						<p>
                            About transparencies - transparency is hard. Most forward renderers suck at transparency, most deferred suck as well. Forward makes it a bit easier, because your architecture is about the same.
						</p>
					</li>
					<li>
						<p>
                            About lighting, Jonathan Blow clearly is not a graphics engineer, there's tiled and clustered rendering that has existed since late 2000s which is typically called Forward+, same techniques are used in deferred, but hey man... the whole lighting argument is over a decade out of date.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Counter-argument:
				</p>
				<ul>
					<li>
						<p>
                            Deferred solves the problem of doing the pricey per-pixel calculations only on the pixels that will be visible in the end result. Which is why, contrary to what he said, basically every engine went deferred. I like the guy but this is maybe the worst take that I've ever heard him say? He doesn't really get why it's used AND he is wildly off the mark about its popularity in general. If anything, forward had a pretty big comeback with phones and VR.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Pro argument:
				</p>
				<ul>
					<li>
						<p>
                            Deferred rendering is an optimization technique to make lighting cheaper, but has massive complexity, VRAM, and image quality downsides. There's not really an upside besides being cheap to process many lights. There's a few ultra high end games that are slowly ditching deferred for forward+ systems. I think in a few years there's a good chance deferred won't be common. Even if raytracing doesn't happen.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Counter-argument:
				</p>
				<ul>
					<li>
						<p>
                            Forward+ still doesn't solve the problem of shadow casting lights. Deferred at least has lower overhead, so the bits of computing power go to shadow mapping purposes.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="clustered-deferred" >
    Clustered Deferred
</h4>
<ul>
	<li>
		<p>
			<em>
                Avalanche Studios
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250922211739.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="adaptive-deferred-shading" >
    Adaptive Deferred Shading
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://youtu.be/9_v8cvd-BSQ?si=ZlpJkttRJFyc821O&t=3081" 
				class="external-link" 
				target="_blank" >
                Explanation by Cem Yuksel {51:21 -&gt; end}
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It's a selective way to choose what to perform shading on.
		</p>
	</li>
	<li>
		<p>
            He compared it with VRS while using deferred shading.
		</p>
	</li>
</ul>
<h2
	id="optimization-techniques" >
    Optimization Techniques
</h2>
<h5
	id="shader-branching" >
    Shader Branching
</h5>
<ul>
	<li>
		<p>
            Math is faster than branching with control flow.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250728154219.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250728154233.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250728154245.png" width="300" >
            .
		</p>
	</li>
</ul>
<h5
	id="gpu-driven-rendering" >
    GPU Driven Rendering
</h5>
<ul>
	<li>
		<p>
			<strong>
                High-level overview
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909090901.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In the real world all culling passes would be a single pass, for performance reasons.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Scene Management
			</strong>
            :
		</p>
		<ul>
			<li>
                <img src="assets/image_20250909090718.png" width="500" >

			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    See 
					<a
						href="https://vkguide.dev/docs/gpudriven/gpu_driven_engines/" 
						class="external-link" 
						target="_blank" >
                        GPU Driven Rendering - VkGuide
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://www.youtube.com/watch?v=oETErEkFICE" 
						class="external-link" 
						target="_blank" >
                        OpenGL Indirect Rendering
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="culling" >
    Culling
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250909090542.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909090657.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            See 
			<a
				href="https://vkguide.dev/docs/gpudriven/compute_culling/" 
				class="external-link" 
				target="_blank" >
                Compute Based Culling - VkGuide
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="culling" >
    Culling
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/occlusion_culling.html" 
				class="external-link" 
				target="_blank" >
                Godot 4 - Occlusion Culling
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.nickdarnell.com/hierarchical-z-buffer-occlusion-culling/" 
				class="external-link" 
				target="_blank" >
                Hierarchical Z-Buffer Culling - 2010
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="http://www.selfshadow.com/talks/rwc_gdc2010_v1.pdf" 
						class="external-link" 
						target="_blank" >
                        Rendering with Conviction - GDC 2010
					</a>
                    &nbsp;presented this technique, which was first introduced on Siggraph 2008.
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://www.nickdarnell.com/hierarchical-z-buffer-occlusion-culling-shadows/" 
						class="external-link" 
						target="_blank" >
                        Hierarchical Z-Buffer Culling - Shadows - 2010
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://www.nickdarnell.com/hierarchical-z-buffer-occlusion-culling-generating-occlusion-volumes/" 
						class="external-link" 
						target="_blank" >
                        Hierarchical Z-Buffer Culling - Generating Occlusion Volumes - 2011
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="frustum-culling" >
    Frustum Culling
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=vJrfcI_bMTA" 
				class="external-link" 
				target="_blank" >
                Frustum Culling - Kohi Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_7s7hH_HtSQ" 
				class="external-link" 
				target="_blank" >
                Tessellation Shader with LOD, Frustum Culling in the Geometry Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The video is pretty cool, but shows absolutely no code or formulas. It's only a theoretical discussion of the techniques.
				</p>
			</li>
			<li>
				<p>
                    Creating geometry in the tessellation shader is better than passing the mesh on the GPU.
				</p>
				<ul>
					<li>
						<p>
                            Data communication between CPU and GPU will always be the bottleneck.
						</p>
					</li>
					<li>
						<p>
                            This is not that precise, as the performance can actually be worse.
						</p>
					</li>
					<li>
						<p>
                            The 
							<strong>
                                real
							</strong>
                            &nbsp;performance gain comes from tessellating based on the distance of the object, by using LOD; if it's far away, tessellate less.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The Frustum Culling is based on the bounding box of the mesh, but as the mesh is too big, we are always rendering every triangle of the mesh, even for triangles we don't see.
				</p>
			</li>
			<li>
				<p>
                    The Geometry Shader can finalize the geometry, as well as culling the triangles we don't need.
				</p>
			</li>
			<li>
				<p>
                    This technique is usually used for terrain, as it's displaced by a height map.
				</p>
			</li>
			<li>
				<p
					class="line-emphasis" >
                    For characters, you would use different models with different poly count, rendering the correct one based on the distance to the camera.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                CPU Frustum Culling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The way this works is that we transform each of the 8 corners of the mesh-space bounding box into screen space, using the object matrix and view-projection matrix. From those, we find the screen-space box bounds, and we check if that box is inside the clip-space view. This way of calculating bounds is on the slow side compared to other formulas, and can have false-positives where it thinks objects are visible when they aren't. All the functions have different tradeoffs, and this one was selected for code simplicity and parallels with the functions we are doing on the vertex shaders.
				</p>
			</li>
			<li>
				<p>
                    We check for visibility before drawing.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> bool is_visible(const RenderObject& obj, const glm::mat4& viewproj) {
&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;glm::vec3, 8&gt; corners {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { 1, 1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { 1, 1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { 1, -1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { 1, -1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { -1, 1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { -1, 1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { -1, -1, 1 },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 { -1, -1, -1 },
&nbsp;&nbsp;&nbsp;&nbsp; };
 
&nbsp;&nbsp;&nbsp;&nbsp; glm::mat4 matrix = viewproj * obj.transform;
 
&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 min = { 1.5, 1.5, 1.5 };
&nbsp;&nbsp;&nbsp;&nbsp; glm::vec3 max = { -1.5, -1.5, -1.5 };
 
&nbsp;&nbsp;&nbsp;&nbsp; for (int c = 0; c &lt; 8; c++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // project each corner into clip space
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glm::vec4 v = matrix * glm::vec4(obj.bounds.origin + (corners[c] * obj.bounds.extents), 1.f);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // perspective correction
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.x = v.x / v.w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.y = v.y / v.w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.z = v.z / v.w;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min = glm::min(glm::vec3 { v.x, v.y, v.z }, min);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max = glm::max(glm::vec3 { v.x, v.y, v.z }, max);
&nbsp;&nbsp;&nbsp;&nbsp; }
 
&nbsp;&nbsp;&nbsp;&nbsp; // check the clip space box is within the view
&nbsp;&nbsp;&nbsp;&nbsp; if (min.z &gt; 1.f || max.z &lt; 0.f || min.x &gt; 1.f || max.x &lt; -1.f || min.y &gt; 1.f || max.y &lt; -1.f) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;
&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp;&nbsp; }
 }
</code></pre>
	</li>
</ul>
<h3
	id="cluster" >
    Cluster
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250909085504.png" width="550" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Each cluster is up to 64 vertices / 124 triangles.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909105901.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909105849.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922140902.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922140841.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250922140820.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/VK_HUAWEI_cluster_culling_shader/clusterculling.html" 
				class="external-link" 
				target="_blank" >
                Cluster Culling Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_HUAWEI_cluster_culling_shader</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="meshoptimizer" >
    MeshOptimizer
</h5>
<ul>
	<li>
		<p>
            From what I saw in the code below, it seems to have several interesting optimizations.
		</p>
	</li>
	<li>
		<p>
            <code>ogldev\DemoLITION\Framework\Source\core_model.cpp:492</code>
		</p>
	</li>
	<li>
		<p>
            It's the last thing done when creating the mesh.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">template&lt;typename VertexType&gt;
void CoreModel::OptimizeMesh(int MeshIndex, std::vector&lt;uint&gt;&Indices, std::vector&lt;VertexType&gt;&Vertices, std::vector&lt;VertexType&gt;& AllVertices)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t NumIndices = Indices.size();
&nbsp;&nbsp;&nbsp;&nbsp;size_t NumVertices = Vertices.size();
&nbsp;&nbsp;&nbsp;&nbsp;// Create a remap table
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned int&gt; remap(NumIndices);
&nbsp;&nbsp;&nbsp;&nbsp;size_t OptVertexCount = meshopt_generateVertexRemap(remap.data(),    // dst addr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indices.data(),  // src indices
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumIndices,      // ...and size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vertices.data(), // src vertices
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumVertices,     // ...and size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(VertexType)); // stride
&nbsp;&nbsp;&nbsp;&nbsp;// Allocate a local index/vertex arrays
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;uint&gt; OptIndices;
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;VertexType&gt; OptVertices;
&nbsp;&nbsp;&nbsp;&nbsp;OptIndices.resize(NumIndices);
&nbsp;&nbsp;&nbsp;&nbsp;OptVertices.resize(OptVertexCount);
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #1: remove duplicate vertices&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_remapIndexBuffer(OptIndices.data(), Indices.data(), NumIndices, remap.data());
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_remapVertexBuffer(OptVertices.data(), Vertices.data(), NumVertices, sizeof(VertexType), remap.data());
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #2: improve the locality of the vertices
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_optimizeVertexCache(OptIndices.data(), OptIndices.data(), NumIndices, OptVertexCount);
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #3: reduce pixel overdraw
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_optimizeOverdraw(OptIndices.data(), OptIndices.data(), NumIndices, &(OptVertices[0].Position.x), OptVertexCount, sizeof(VertexType), 1.05f);
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #4: optimize access to the vertex buffer
&nbsp;&nbsp;&nbsp;&nbsp;meshopt_optimizeVertexFetch(OptVertices.data(), OptIndices.data(), NumIndices, OptVertices.data(), OptVertexCount, sizeof(VertexType));
&nbsp;&nbsp;&nbsp;&nbsp;// Optimization #5: create a simplified version of the model
&nbsp;&nbsp;&nbsp;&nbsp;float Threshold = 1.0f;
&nbsp;&nbsp;&nbsp;&nbsp;size_t TargetIndexCount = (size_t)(NumIndices * Threshold);
&nbsp;&nbsp;&nbsp;&nbsp;float TargetError = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned int&gt; SimplifiedIndices(OptIndices.size());
&nbsp;&nbsp;&nbsp;&nbsp;size_t OptIndexCount = meshopt_simplify(SimplifiedIndices.data(), OptIndices.data(), NumIndices,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&OptVertices[0].Position.x, OptVertexCount, sizeof(VertexType), TargetIndexCount, TargetError);
&nbsp;&nbsp;&nbsp;&nbsp;static int num_indices = 0;
&nbsp;&nbsp;&nbsp;&nbsp;num_indices += (int)NumIndices;
&nbsp;&nbsp;&nbsp;&nbsp;static int opt_indices = 0;
&nbsp;&nbsp;&nbsp;&nbsp;opt_indices += (int)OptIndexCount;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Num indices %d\n", num_indices);
&nbsp;&nbsp;&nbsp;&nbsp;//printf("Target num indices %d\n", TargetIndexCount);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Optimized number of indices %d\n", opt_indices);
&nbsp;&nbsp;&nbsp;&nbsp;SimplifiedIndices.resize(OptIndexCount);
&nbsp;&nbsp;&nbsp;&nbsp;// Concatenate the local arrays into the class attributes arrays
&nbsp;&nbsp;&nbsp;&nbsp;m_Indices.insert(m_Indices.end(), SimplifiedIndices.begin(), SimplifiedIndices.end());
&nbsp;&nbsp;&nbsp;&nbsp;AllVertices.insert(AllVertices.end(), OptVertices.begin(), OptVertices.end());
&nbsp;&nbsp;&nbsp;&nbsp;m_Meshes[MeshIndex].NumIndices = (uint)OptIndexCount;
}
</code></pre>
<h5
	id="draco" >
    Draco
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/google/draco" 
				class="external-link" 
				target="_blank" >
                Draco
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Draco is a library for compressing and decompressing 3D geometric meshes and point clouds. It is intended to improve the storage and transmission of 3D graphics.
		</p>
	</li>
	<li>
		<p>
            By Google.
		</p>
	</li>
</ul>
<h3
	id="lod-mipmap" >
    LOD, MipMap
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=PNvlqsXdQic" 
				class="external-link" 
				target="_blank" >
                Chunking, LODs and Fog
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=qMCOX3m-R28" 
				class="external-link" 
				target="_blank" >
                Mipmap, Minification Filters, Magnification Filters
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    MIP: Latin for 'Much In Little'.
				</p>
				<ul>
					<li>
						<p>
                            It downsizes the image in powers of two.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {5:31 -&gt; 10:10}
				</p>
				<ul>
					<li>
						<p>
                            Explanation of the Filters
						</p>
					</li>
					<li>
						<p>
                            Minification:
						</p>
						<ul>
							<li>
								<p>
                                    Nearest, Linear, Linear_mipmap_nearest and Linear_mipmap_linear.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Magnification:
						</p>
						<ul>
							<li>
								<p>
                                    Nearest, Linear.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {10:14 -&gt; end}
				</p>
				<ul>
					<li>
						<p>
                            GLSL implementation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {19:29 -&gt; 21:02}
				</p>
				<ul>
					<li>
						<p>
                            Differences in the Filters.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/8OtOFN17jxM?si=slwMb0_K0gcraqao&t=68" 
				class="external-link" 
				target="_blank" >
                Mipmap and Trilinear Filter
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Trilinear Filtering: Linear interpolate between levels of mipmapping.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="http://the-witness.net/news/2010/09/computing-alpha-mipmaps/" 
				class="external-link" 
				target="_blank" >
                Improving the mipmap for transparent objects at a distance (foliage) - The Witness
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The idea is very simple: modify the content of the mipmap during its creation.
				</p>
			</li>
			<li>
				<p>
                    It shows a formula to manipulate the final result to get a better look.
				</p>
			</li>
			<li>
				<p>
                    That's all.
				</p>
			</li>
			<li>
				<p>
                    I found it interesting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Using the full chain
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Advantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Hardware trilinear/anisotropic filtering benefits from having all levels available → better quality when minifying.
						</p>
					</li>
					<li>
						<p>
                            Simplifies generation: many GPU/CPU mip-generation algorithms assume a full chain.
						</p>
					</li>
					<li>
						<p>
                            No runtime fallback behavior to a coarser final level.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Disadvantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Increased memory and upload cost (sum of sizes of all mip levels).
						</p>
					</li>
					<li>
						<p>
                            Extra work to generate or upload every level (unless you generate on GPU).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lower mip levels (1 &lt; mipLevels &lt; max)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Advantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Lower memory and upload cost.
						</p>
					</li>
					<li>
						<p>
                            Useful for streaming: allocate only top K levels now, stream lower-res later.
						</p>
					</li>
					<li>
						<p>
                            Useful for textures that will rarely be minified (UI element, near camera).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Disadvantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Potentially poorer filtering when the sampler requests a lower LOD; sampling will effectively use the last available level (coarser detail).
						</p>
					</li>
					<li>
						<p>
                            If you plan to GPU-blit/generate mips, you must still have declared the target number of levels ahead of generation.
						</p>
					</li>
					<li>
						<p>
                            Some runtime tools/algorithms may assume a full chain and need adaptation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="mesh-lod" >
    Mesh: LOD
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/mesh_lod.html" 
				class="external-link" 
				target="_blank" >
                Godot 4 - Mesh LOD
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Godot provides a way to automatically generate less detailed meshes for LOD usage on import, then use those LOD meshes when needed automatically. This is completely transparent to the user. The 
					<a
						href="https://meshoptimizer.org/" 
						class="external-link" 
						target="_blank" >
                        meshoptimizer
					</a>
                    &nbsp;library is used for LOD mesh generation behind the scenes.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="instancing" >
    Instancing
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=Y0Ko0kvwfgA" 
				class="external-link" 
				target="_blank" >
                Billboard Grass and GPU Instancing
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    &quot;Rendering millions of grass&quot;.
				</p>
			</li>
			<li>
				<p>
                    The video is cool.
				</p>
			</li>
			<li>
				<p>
                    We'll use a compute shader.
				</p>
			</li>
			<li>
				<p>
                    We take the thread id of our compute shader thread. For a 300 square space, we can do 
                    <code>position = id.xy - 150</code>
                    &nbsp;so it's centered over the origin.
				</p>
			</li>
			<li>
				<p>
                    As our grass is made of 3 meshes (3 billboard quads), this will result in 3 separate instancing calls.
				</p>
			</li>
			<li>
				<p>
                    To increase the density of grasses in the square space, we can 
                    <code>position *= (1 / density)</code>
                    ; I'll use 
                    <code>density = 2</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    For this example, I'll render 2,160,000 triangles at 523 fps.
				</p>
				<ul>
					<li>
						<p>
                            Screen: 1289x621
						</p>
					</li>
					<li>
						<p>
                            Setup? GTX 1660, apparently.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To get randomness, I did 
                    <code>pos.xz += noise()</code>
                    &nbsp;for the position and 
                    <code>position.y += noise()</code>
                    &nbsp;to get a different height (higher grass will be grouped with higher grasses).
				</p>
				<ul>
					<li>
						<p>
                            This uses a simplex noise.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To animate, I'll just skew the top 2 vertices of the mesh in the vertex shader.
				</p>
				<ul>
					<li>
						<p>
                            {9:20} Explanation of what was done to randomize the intensity and frequency of grass sway movement.
						</p>
					</li>
					<li>
						<p>
                            Hash the instance id to get a hash id. With the hash_id, we check against a threshold to know if we perform a fast cosine or a slow cosine.
						</p>
					</li>
					<li>
						<p>
                            The grass height changed the cosine frequency.
						</p>
					</li>
					<li>
						<p>
                            Etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To get the grass displaced with the terrain displacement, we convert the space coordinates of our grass to uv coordinates, such as they can sample the same height map as the terrain mesh.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250907212336.png" width="500" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    I also introduced a color variance in the grass, by making the tip of the grass more yellow, to show aging of the grass. This affects higher grasses a bit more, as they are older.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=jw00MbIJcrk" 
						class="external-link" 
						target="_blank" >
                        Continuation: Grass Mesh instead of Billboarding and GPU Culling with the Scan and Compact technique
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The video is the continuation of the previous one, changing: noise texture for wind simulation and optimizations with frustum culling with Scan and Compact.
						</p>
						<ul>
							<li>
								<p>
                                    The video is cool, though it has less content than the previous one.
								</p>
							</li>
							<li>
								<p>
                                    It shows no implementation or formulas.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Noise is used for wind movement, more sophisticated using a noise texture with oscillations ~etc, different from the randomization used in the billboarding solution.
						</p>
					</li>
					<li>
						<p>
                            Then, optimization is discussed. This new technique is 
							<em>
                                much
							</em>
                            &nbsp;heavier than the previous, so he uses Frustum Culling to optimize what is actually instanced.
						</p>
						<ul>
							<li>
								<p>
                                    This frustum culling apparently is harder to do, because it requires the Compute Buffer array to be contiguous.
								</p>
							</li>
							<li>
								<p>
                                    He uses: Scan and Compact.
								</p>
							</li>
							<li>
								<p>
                                    The array is scanned, marked for modification and a new array is created with the desired elements.
								</p>
							</li>
							<li>
								<p>
                                    For this, a Prefix Sum Scan is used to define which entries form the new array.
								</p>
								<ul>
									<li>
										<p>
                                            This is not explained.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=PNvlqsXdQic" 
						class="external-link" 
						target="_blank" >
                        Continuation: LOD with Chunking
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The video is quite short, only talking about the optimization below. It shows no implementation or formulas.
						</p>
					</li>
					<li>
						<p>
                            It uses a mesh with lower poly count when the object's distance to the camera is greater than a threshold.
						</p>
					</li>
					<li>
						<p>
                            The justification for using chunking is to help with LOD.
						</p>
						<ul>
							<li>
								<p>
                                    Apparently LOD would be done in chunks (?) which would reduce the need for having a second position buffer, specific to the low-poly LOD mesh.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The final performance is 110fps, with 408MB of VRAM.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="formats" >
    Formats
</h3>
<h5
	id="ktx2" >
    KTX2
</h5>
<ul>
	<li>
		<p>
            Is a container file format for storing texture data optimized for GPU usage. It’s designed to work efficiently with modern graphics APIs like Vulkan, OpenGL, and DirectX.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/tutorial/latest/15_GLTF_KTX2_Migration.html#_understanding_ktx2" 
				class="external-link" 
				target="_blank" >
                KTX2 vs PNG
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://ktxviewer.com/" 
				class="external-link" 
				target="_blank" >
                KTX Viewer Online
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="poly-count-vertex-bound" >
    Poly Count / Vertex Bound
</h3>
<ul>
	<li>
		<p>
            I understand as: problems with poly count.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909101124.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    TBDR: Tile Based Deferred Renderer GPU.
				</p>
			</li>
			<li>
				<p>
                    TBIR: Tile Based Immediate Renderer GPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/zeux/meshoptimizer" 
				class="external-link" 
				target="_blank" >
                MeshOptimizer
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    When a GPU renders triangle meshes, various stages of the GPU pipeline have to process vertex and index data. The efficiency of these stages depends on the data you feed to them; this library provides algorithms to help optimize meshes for these stages, as well as algorithms to reduce the mesh complexity and storage overhead.
				</p>
			</li>
			<li>
				<p>
                    The library provides a C and C++ interface for all algorithms; you can use it from C/C++ or from other languages via FFI (such as P/Invoke).
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/zeux/meshoptimizer/blob/master/gltf/README.html" 
						class="internal-link" 
						target="_self" >
                        gltfack
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            gltfpack is a tool that can automatically optimize glTF files to reduce the download size and improve loading and rendering speed.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="dynamic-resolution" >
    Dynamic Resolution
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250909101707.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909101740.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909101805.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909101851.png" width="500" >
            .
		</p>
	</li>
</ul>
<h3
	id="tiled-based" >
    Tiled-based~
</h3>
<h5
	id="variable-rate-shading-vrs" >
    Variable Rate Shading (VRS)
</h5>
<ul>
	<li>
		<p>
            With VRS you can specify different sampling rates for different parts of the screen. This can be used to optimize performance for either adapting the shading rate to the content, or for adapting the shading rate for things like foveated rendering in VR, where you only need full shading rate at the center of the viewport.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=ES9799W6eMI" 
				class="external-link" 
				target="_blank" >
                Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=FzMZq8B1SEM" 
				class="external-link" 
				target="_blank" >
                VRS - Wicked Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://wickedengine.net/2020/09/variable-rate-shading-first-impressions/" 
				class="external-link" 
				target="_blank" >
                VRS First Impressions - Wicked Engine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            VRS seems to work better with Forward than Deferred Rendering.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/stable/tutorials/3d/variable_rate_shading.html" 
				class="external-link" 
				target="_blank" >
                Godot 4 - VRS
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="tiling-post-processing" >
    Tiling Post-Processing
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2020/01/tile-based-optimization-for-post-processing/" 
				class="external-link" 
				target="_blank" >
                Tiled Based Optimization for Post-Processing - Wicked Engine
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="nanite" >
    Nanite
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=M00DGjAP-mU" 
				class="external-link" 
				target="_blank" >
                Comparing Nanite to LODs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Baz - Nanite is still a deferred renderer, but I 
			<em>
                don't
			</em>
            &nbsp;think Forward or Deferred Renderer is the right choice.
		</p>
	</li>
	<li>
        <img src="assets/image_20250909095458.png" width="650" >

	</li>
	<li>
		<p>
            <img src="assets/image_20250909101431.png" width="500" >
            .
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                🧑‍💻 built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                📅 2025-10-21 .&nbsp;&nbsp;2025-10-30 🚀
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#apis" >
                            APIs
						</a>
						<ul>
							<li>
								<a
									href="#graphics-apis" >
                                    Graphics APIs
								</a>
							</li>
							<li>
								<a
									href="#shader-languages" >
                                    Shader Languages
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#tools" >
                            Tools
						</a>
						<ul>
							<li>
								<a
									href="#capture" >
                                    Capture
								</a>
							</li>
							<li>
								<a
									href="#debuggers" >
                                    Debuggers
								</a>
							</li>
							<li>
								<a
									href="#profilers" >
                                    Profilers
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#choosing-the-space-to-compute-lighting" >
                            Choosing the Space to compute Lighting
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#bsdf-bidirectional-scattering-distribution-function" >
                            BSDF (Bidirectional Scattering Distribution Function)
						</a>
						<ul>
							<li>
								<a
									href="#specular-brdf" >
                                    Specular BRDF
								</a>
							</li>
							<li>
								<a
									href="#diffuse-brdf" >
                                    Diffuse BRDF
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#material" >
                            Material
						</a>
						<ul>
							<li>
								<a
									href="#base-color-albedo" >
                                    Base Color / Albedo
								</a>
							</li>
							<li>
								<a
									href="#roughness-value-roughness-map" >
                                    Roughness Value / Roughness Map
								</a>
							</li>
							<li>
								<a
									href="#metallic-map" >
                                    Metallic Map
								</a>
							</li>
							<li>
								<a
									href="#reflectance" >
                                    Reflectance
								</a>
							</li>
							<li>
								<a
									href="#emission" >
                                    Emission
								</a>
							</li>
							<li>
								<a
									href="#normal-map-displacement-map" >
                                    Normal Map, Displacement Map
								</a>
							</li>
							<li>
								<a
									href="#ambient-occlusion-map" >
                                    Ambient Occlusion Map
								</a>
							</li>
							<li>
								<a
									href="#anisotropy" >
                                    Anisotropy
								</a>
							</li>
							<li>
								<a
									href="#clear-coat" >
                                    Clear Coat
								</a>
							</li>
							<li>
								<a
									href="#sheen" >
                                    Sheen
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#direct-lighting" >
                            Direct Lighting
						</a>
						<ul>
							<li>
								<a
									href="#parametrization" >
                                    Parametrization
								</a>
							</li>
							<li>
								<a
									href="#directional-lights" >
                                    Directional Lights
								</a>
							</li>
							<li>
								<a
									href="#punctual-lights" >
                                    Punctual Lights
								</a>
							</li>
							<li>
								<a
									href="#photometric-lights" >
                                    Photometric Lights
								</a>
							</li>
							<li>
								<a
									href="#mobile-adaptations" >
                                    Mobile Adaptations
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#shadows" >
                            Shadows
						</a>
						<ul>
							<li>
								<a
									href="#shadow-map" >
                                    Shadow Map
								</a>
							</li>
							<li>
								<a
									href="#soft-shadows" >
                                    Soft-Shadows
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#skybox-skydome" >
                            Skybox / Skydome
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#transparency" >
                            Transparency
						</a>
						<ul>
							<li>
								<a
									href="#alpha" >
                                    Alpha
								</a>
							</li>
							<li>
								<a
									href="#order-independent-transparency" >
                                    Order-Independent Transparency
								</a>
							</li>
							<li>
								<a
									href="#refraction" >
                                    Refraction
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#global-illumination-indirect-lighting" >
                            Global Illumination / Indirect Lighting
						</a>
						<ul>
							<li>
								<a
									href="#terms" >
                                    Terms
								</a>
							</li>
							<li>
								<a
									href="#techniques" >
                                    Techniques
								</a>
							</li>
							<li>
								<a
									href="#solutions" >
                                    Solutions
								</a>
							</li>
							<li>
								<a
									href="#discarded-solutions" >
                                    Discarded Solutions
								</a>
							</li>
							<li>
								<a
									href="#lightmaps" >
                                    Lightmaps
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#post-processing" >
                            Post-Processing
						</a>
						<ul>
							<li>
								<a
									href="#color-spaces-hdr-sdr-tonemapping-exposure" >
                                    Color Spaces, HDR / SDR, ToneMapping, Exposure
								</a>
							</li>
							<li>
								<a
									href="#bloom-glow" >
                                    Bloom / Glow
								</a>
							</li>
							<li>
								<a
									href="#etc" >
                                    Etc
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#anti-aliasing" >
                            Anti-Aliasing
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#light-path-rendering-method" >
                            Light Path / Rendering Method
						</a>
						<ul>
							<li>
								<a
									href="#forward-rendering" >
                                    Forward Rendering
								</a>
							</li>
							<li>
								<a
									href="#deferred-shading" >
                                    Deferred Shading
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#optimization-techniques" >
                            Optimization Techniques
						</a>
						<ul>
							<li>
								<a
									href="#culling" >
                                    Culling
								</a>
							</li>
							<li>
								<a
									href="#cluster" >
                                    Cluster
								</a>
							</li>
							<li>
								<a
									href="#lod-mipmap" >
                                    LOD, MipMap
								</a>
							</li>
							<li>
								<a
									href="#instancing" >
                                    Instancing
								</a>
							</li>
							<li>
								<a
									href="#formats" >
                                    Formats
								</a>
							</li>
							<li>
								<a
									href="#poly-count-vertex-bound" >
                                    Poly Count / Vertex Bound
								</a>
							</li>
							<li>
								<a
									href="#dynamic-resolution" >
                                    Dynamic Resolution
								</a>
							</li>
							<li>
								<a
									href="#tiled-based" >
                                    Tiled-based~
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.js" >
		</script>
	</body>
</html>
