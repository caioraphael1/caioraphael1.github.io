<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.94901.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
>
					<summary>
                        Data Oriented Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design-criticisms-of-oop.html" >
                                Criticisms of OOP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design-philosophies.html" >
                                Philosophies
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Data Oriented Design - ECS
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-discussion.html" >
                                Discussion
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-critiques.html" >
                                Critiques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-sources.html" >
                                Sources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-entity.html" >
                                Entity
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-component.html" >
                                Component
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-system.html" >
                                System
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-design-n-greatern-relationship.html" >
                                Design: N-&gt;N relationship
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS-design-discarded-ideas.html" >
                                Design: Discarded Ideas
							</a>
							<ul>
								<li>
									<a
										href="#handle_map-inside-a-sparse_set" >
                                        <s>Handle_Map inside a Sparse_Set</s>
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#thinking-in-terms-of-valid-data-when-the-backing-storage-changes-add-remove-move-resize" >
                                        Thinking in terms of valid data when the backing storage changes (add/remove/move/resize)
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#thinking-in-terms-of-specialization-and-shared-data" >
                                        Thinking in terms of specialization and shared data
									</a>
								</li>
							</ul>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Data Oriented Design - COP
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - COP/Data Oriented Design - COP-cop-compression-oriented-programming-mega-struct.html" >
                                COP (Compression-Oriented Programming) / Mega-Struct
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Design Patterns
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns-definition.html" >
                                Definition
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns-behavioral-patterns.html" >
                                Behavioral Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns-creational-patterns.html" >
                                Creational Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns-structural-patterns.html" >
                                Structural Patterns
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Concepts and Terminology
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Concepts and Terminology-terminology.html" >
                                Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Concepts and Terminology-concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Rules of thumb - Laws - Guidelines and Principles
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Rules of thumb - Laws - Guidelines and Principles/Rules of thumb - Laws - Guidelines and Principles-rules-of-thumb.html" >
                                Rules of Thumb
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Paradigms
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Paradigms-about.html" >
                                About
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Paradigms-procedural.html" >
                                Procedural
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Paradigms-functional.html" >
                                Functional
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Paradigms-oop-object-oriented-programming.html" >
                                OOP (Object-Oriented Programming)
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Production Methodologies
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Production Methodologies/Production Methodologies-design-process.html" >
                                Design Process
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Production Methodologies/Production Methodologies-apps.html" >
                                Apps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Production Methodologies/Production Methodologies-software-testing.html" >
                                Software Testing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Production Methodologies/Production Methodologies-methodologies.html" >
                                Methodologies
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Design: Discarded Ideas
						</h1>
						<p>
							<time
								datetime="2025-03-11" >
                                ðŸ•’ Created: 2025-03-11
							</time>
							<time
								datetime="2026-01-23" >
                                | Updated: 2026-01-23
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h3
	id="handle_map-inside-a-sparse_set" >
    <s>Handle_Map inside a Sparse_Set</s>
</h3>
<pre><code class="language-odin" data-lang="odin">Sparse_Set :: struct($T: typeid, $HANDLE_TYPE: typeid, $LEN: u64 = 10) {
&nbsp;&nbsp;&nbsp;&nbsp;sparse: [LEN]HANDLE_TYPE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ent_handle = sparse[ent]
&nbsp;&nbsp;&nbsp;&nbsp;dense:&nbsp;&nbsp;[dynamic]Key,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ent = dense[ent_handle]
&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;&nbsp; hm.Handle_Map(T, HANDLE_TYPE), // T = hm.get(&sparse_set.data, ent_handle)
}
</code></pre>
<ul>
	<li>
		<p>
            <code>E -&gt; Handle -&gt; T</code>
            &nbsp;is slower than 
            <code>E -&gt; dense_idx -&gt; T</code>
            .
		</p>
	</li>
	<li>
		<p>
            Gives more safety, I think, for having something like generations.
		</p>
	</li>
	<li>
		<p>
            This is a bad idea, as it defeats the whole purpose of having the data packed with a 
            <code>Sparse_Set</code>
            ...
		</p>
	</li>
	<li>
		<p>
            There's no reason to use this.
		</p>
	</li>
</ul>
<h3
	id="thinking-in-terms-of-valid-data-when-the-backing-storage-changes-add-remove-move-resize" >
    Thinking in terms of valid data when the backing storage changes (add/remove/move/resize)
</h3>
<ul>
	<li>
		<p>
            For 
            <code>Timer</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
                    <code>Timer</code>
                    &nbsp;is equivalent to 
                    <code>f32</code>
                    ; it's atomic.
				</p>
			</li>
			<li>
				<p>
                    All timers could share a system: they are all updated via calling 
                    <code>update</code>
                    &nbsp;on them. This means that I have reasons to store them together, even tho this is not a requirement.
				</p>
				<ul>
					<li>
						<p>
                            After further thought, maybe not all timers should be updated equally, as some might want high update precision for visuals, while others are for network or physics.
						</p>
					</li>
					<li>
						<p>
                            Considering the division between processing of data, there could be 
                            <code>_timers_visuals</code>
                            &nbsp;/ 
                            <code>_timers_physics</code>
                            , symbolizing the moment when each of these components should have the system update called.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    No timers are equal: a specific timer is wanted for a system; there's a concept of &quot;timer types&quot;, where a timer is used for AI, or UI, or visuals, etc. Every timer can have a completely different purpose.
				</p>
			</li>
			<li>
				<p>
                    An entity could &quot;have&quot; many timers, and a system wants a specific timer from all timers available.
				</p>
			</li>
			<li>
				<p>
                    &quot;This timer belongs to who/what?&quot;
				</p>
			</li>
			<li>
				<p>
					<em>
                        Used for
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>Damage_Indicator</code>
						</p>
					</li>
					<li>
						<p>
                            <code>AI_State_Machine</code>
						</p>
						<ul>
							<li>
								<p>
                                    This would not be how the AI is used. Utility AI would evaluate the next decision based on the aggregated scores.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For 
            <code>Sprite</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
                    <code>Sprite</code>
                    &nbsp;is equivalent to 
                    <code>f32</code>
                    ; it's atomic.
				</p>
			</li>
			<li>
				<p>
                    Thinking in terms of shared processing:
				</p>
				<ul>
					<li>
						<p>
                            All timers do not share a system.
						</p>
					</li>
					<li>
						<p>
                            The sources say that storing atomic data inside an array doesn't make sense, as grouping things together should have semantic meaning. I go a step further and say it should indicate data that is processed together.
						</p>
					</li>
					<li>
						<p>
                            This indicates that a 
                            <code>[]Sprite</code>
                            &nbsp;or 
                            <code>_sprites: Component(Sprite)</code>
                            &nbsp;doesn't make sense, as all sprites are not processed together.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    There should have specialization in these arrays/components, such as creating new arrays or components for each diference in semantic/processing.
				</p>
			</li>
			<li>
				<p>
                    &quot;This sprite belongs to who/what?&quot;
				</p>
			</li>
			<li>
				<p>
                    Is more about having a reference to a 
                    <code>Sprite</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Used for
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>Damage_Indicator</code>
						</p>
					</li>
					<li>
						<p>
                            shadows sprites.
						</p>
					</li>
					<li>
						<p>
                            projectile sprite.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>Sprite</code>
		</p>
		<ul>
			<li>
				<p>
                    The projectile's sprite could be the &quot;main transform&quot; for that object, but currently I have no good way to query for the sprite.
				</p>
			</li>
			<li>
				<p>
                    Maybe sprites should be a 
                    <code>Sparse_Set</code>
                    , just like 
                    <code>Dynamic_Body</code>
                    , 
                    <code>Area</code>
                    &nbsp;and 
                    <code>Transform2_Node</code>
                    &nbsp;(potentially).
				</p>
			</li>
			<li>
				<p>
                    <code>Damage_Indicator</code>
				</p>
				<ul>
					<li>
						<p>
                            Wants a &quot;pointer&quot; to a Sprite.
						</p>
					</li>
				</ul>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    <s>The 
                    <code>Sprite</code>
                    &nbsp;is an entity</s>.
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Problem
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Queries:
								</p>
								<ul>
									<li>
										<p>
                                            The sprite would be an entity it self, so queries like this wouldn't be possible:
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">for entity, sprite, vel_max, entity_target, damage in sparse.intersect_next(&rd.sprites, &_velocities_max, &_entities_target, &_damages) {
&nbsp;&nbsp;&nbsp;&nbsp;move_to_target_or_damage_target_and_self_destroy(entity, sprite, vel_max^, entity_target^, damage^, world, dt)
} 
</code></pre>
								<ul>
									<li>
										<p>
                                            The entity that has 
                                            <code>&_velocities_max, &_entities_target, &_damages</code>
                                            &nbsp;is not the same that has a 
                                            <code>&rd.sprite</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    A ENTITY_SPRITE uses the 
                                                    <code>rd.sprite</code>
                                                    , while the ENTITY_CHARACTER/ENTITY_CREATURE/ENTITY_PROJECTILE uses the other components.
												</p>
											</li>
											<li>
												<p>
                                                    So, what I mean is, this is a data anomaly: the sprite used will be incorrect.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            &quot;If a 'thing' is an entity, it cannot be considered a 'component' for another entity&quot;.
										</p>
										<ul>
											<li>
												<p>
                                                    The only way for an entity to also be considered a component, would be if when querying for the components, the 
                                                    <code>_children</code>
                                                    &nbsp;component is checked. This would require a recursive check, where not only the entities from 
                                                    <code>c0.dense</code>
                                                    &nbsp;would have to be checked, but also the children of all these entities, recursively.
												</p>
											</li>
											<li>
												<p>
                                                    If I don't want this behavior, I'd have to not use the 
                                                    <code>_children</code>
                                                    &nbsp;sparse set, ensuring that &quot;a 'thing' is either a component OR a entity, not both&quot;.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
				<ol>
					<li>
						<p>
                            Only 
                            <code>Transform2_Node</code>
                            &nbsp;is a component.
						</p>
<pre><code class="language-odin" data-lang="odin">Sprite_Data :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;debug_name:&nbsp;&nbsp; string,

&nbsp;&nbsp;&nbsp;&nbsp;// Tex
&nbsp;&nbsp;&nbsp;&nbsp;tex_path:&nbsp;&nbsp;&nbsp;&nbsp; string,
&nbsp;&nbsp;&nbsp;&nbsp;tex_extent:&nbsp;&nbsp; spatial.Extent,
&nbsp;&nbsp;&nbsp;&nbsp;tex_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u32,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Mesh
&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mesh,

&nbsp;&nbsp;&nbsp;&nbsp;model_matrix: matrix[4, 4]f32,

&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatial.Recti,
&nbsp;&nbsp;&nbsp;&nbsp;flip_x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,
&nbsp;&nbsp;&nbsp;&nbsp;flip_y:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,

&nbsp;&nbsp;&nbsp;&nbsp;tile_size:&nbsp;&nbsp;&nbsp;&nbsp;[2]int,
&nbsp;&nbsp;&nbsp;&nbsp;tile_idx:&nbsp;&nbsp;&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp;_total_tiles: int,

&nbsp;&nbsp;&nbsp;&nbsp;color_mult:&nbsp;&nbsp; [4]f32, // 0 to 1.
&nbsp;&nbsp;&nbsp;&nbsp;color_add:&nbsp;&nbsp;&nbsp;&nbsp;[4]f32, // 0 to 1.
}

sprite_add :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;&nbsp;&nbsp;&nbsp;[2]f32 = {},
&nbsp;&nbsp;&nbsp;&nbsp;rot:&nbsp;&nbsp;&nbsp;&nbsp;f32&nbsp;&nbsp;&nbsp;&nbsp;= 0, 
&nbsp;&nbsp;&nbsp;&nbsp;scale:&nbsp;&nbsp;[2]f32 = { 1, 1 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent: sparse.Key = {},
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (sprite: Sprite) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)
}

tex, tex_idx := rd.texture_get_from_cache_or_append(cmd, &level.textures, "assets/char.png", arena)
sprite_entity := rd.sprite_add(
&nbsp;&nbsp;&nbsp;&nbsp;cmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = cmd,
&nbsp;&nbsp;&nbsp;&nbsp;debug_name&nbsp;&nbsp;= "char",
&nbsp;&nbsp;&nbsp;&nbsp;texture&nbsp;&nbsp;&nbsp;&nbsp; = tex, 
&nbsp;&nbsp;&nbsp;&nbsp;texture_idx = tex_idx,
&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = { 0, 0 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= dynamic_body.trans,
&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= { 16, 31 },
&nbsp;&nbsp;&nbsp;&nbsp;arena&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = arena,
)
sparse.add_as_child(&_children, entity, sprite_entity)
rd.layers_add_draw_option(&level.layers, sprite_entity, 10, true, arena.cpu_alloc)
</code></pre>
					</li>
					<li>
						<p>
                            Everything is a component: 
                            <code>Transform2_Node</code>
                            &nbsp;+ 
                            <code>Texture</code>
                            &nbsp;+ 
                            <code>Mesh</code>
                            &nbsp;+ 
                            <code>Material2D</code>
                            &nbsp;are components.
						</p>
						<ul>
							<li>
								<p>
                                    <code>Mesh</code>
                                    :
								</p>
							</li>
							<li>
								<p>
                                    <code>Material2D</code>
                                    :
								</p>
							</li>
						</ul>
<pre><code class="language-odin" data-lang="odin">Material2D :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;// Tex thing
&nbsp;&nbsp;&nbsp;&nbsp;tex_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u32,

&nbsp;&nbsp;&nbsp;&nbsp;// UV
&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatial.Recti,
&nbsp;&nbsp;&nbsp;&nbsp;flip_x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,
&nbsp;&nbsp;&nbsp;&nbsp;flip_y:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,

&nbsp;&nbsp;&nbsp;&nbsp;tile_size:&nbsp;&nbsp;&nbsp;&nbsp;[2]int,
&nbsp;&nbsp;&nbsp;&nbsp;tile_idx:&nbsp;&nbsp;&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp;_total_tiles: int,

&nbsp;&nbsp;&nbsp;&nbsp;// Frag
&nbsp;&nbsp;&nbsp;&nbsp;color_mult:&nbsp;&nbsp; [4]f32, // 0 to 1.
&nbsp;&nbsp;&nbsp;&nbsp;color_add:&nbsp;&nbsp;&nbsp;&nbsp;[4]f32, // 0 to 1.
}

sprite_create :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;&nbsp;&nbsp;&nbsp;[2]f32 = {},
&nbsp;&nbsp;&nbsp;&nbsp;rot:&nbsp;&nbsp;&nbsp;&nbsp;f32&nbsp;&nbsp;&nbsp;&nbsp;= 0, 
&nbsp;&nbsp;&nbsp;&nbsp;scale:&nbsp;&nbsp;[2]f32 = { 1, 1 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent: sparse.Key = {},
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (sprite: Sprite) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&rd.meshes, entity, /* mesh info */)

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&rd.textures, entity, /* texture info */)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If using an existing texture, this has to be implemented in a sparse set so this is allowed.

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&rd.material2d, entity, /* material2d info */)
}
</code></pre>
					</li>
				</ol>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    The data is stored in an 
                    <code>Handle_Map(T)</code>
                    , using 
                    <code>.handle: Handle</code>
                    &nbsp;to access the data, without any components.
				</p>
				<ul>
					<li>
						<p>
                            This requires the handle to be stored.
						</p>
						<ul>
							<li>
								<p>
                                    Check the strategy &quot;
                                    <code>Sparse_Set</code>
                                    &nbsp;to a 
                                    <code>Handle</code>
                                    &nbsp;to a 
                                    <code>Handle_Map</code>
                                    : &quot;Handle to Handle&quot; / &quot;Pointer to Pointer&quot;&quot;.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>The data is stored in a single 
                    <code>Component(T)</code>
                    , using other components to help differentiate the &quot;type of 
                    <code>T</code>
                    &quot;</s>
				</p>
				<ul>
					<li>
						<p>
                            How would I differentiate &quot;bounciness&quot;?
						</p>
						<ul>
							<li>
								<p>
                                    Maybe there's a &quot;Bounce component&quot;, specifying the &quot;max angle&quot; and &quot;base speed&quot;.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Problems
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    If an entity has a &quot;shadow sprite&quot; and a &quot;main sprite&quot;, there's no way to distinguish between them while using a single data structure. Adding extra components to the same entity, for example, &quot;bouncy component&quot; doesn't help differentiate the sprites while querying.
								</p>
							</li>
							<li>
								<p>
                                    This is where these ideas come from:
								</p>
								<ul>
									<li>
										<p>
                                            &quot;Many 
                                            <code>[]T</code>
                                            /
                                            <code>map[]T</code>
                                            /
                                            <code>Handle_Map</code>
                                            /
                                            <code>Component</code>
                                            &quot;
										</p>
									</li>
									<li>
										<p>
                                            &quot;The 
                                            <code>Sprite</code>
                                            &nbsp;is an entity&quot;
										</p>
									</li>
									<li>
										<p>
                                            &quot;What makes 
                                            <code>T</code>
                                            &nbsp;different from one another is stored inside 
                                            <code>T</code>
                                            , and not related to the data structure&quot;
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Many 
                    <code>[]T</code>
                    /
                    <code>map[]T</code>
                    /
                    <code>Handle_Map</code>
                    /
                    <code>Component</code>
                    </s>.
				</p>
				<ul>
					<li>
						<p>
                            This is a way to tackle specialization; having many storage structures doesn't solve the issue of things changing inside these backing structures.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Killer Problem
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    This is really weird for trying to hold onto a reference of 
                                    <code>T</code>
                                    , as you don't know which of many data structures the data is in.
								</p>
								<ul>
									<li>
										<p>
                                            This is where the main problem of 
                                            <code>Sprite</code>
                                            &nbsp;originated.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>What makes 
                    <code>T</code>
                    &nbsp;different from one another is stored inside 
                    <code>T</code>
                    , and not related to the data structure</s>.
				</p>
				<ul>
					<li>
						<p>
                            This is reaaaally weird, as one could argue that I could have an array of 
                            <code>f32</code>
                            &nbsp;and that it's the job of the 
                            <code>f32</code>
                            &nbsp;to indicate how it should be used.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
            <code>Transform2_Node</code>
		</p>
		<ul>
			<li>
				<p>
                    Before the changes to 
                    <code>Transform2_Node</code>
                    , I could store the 
                    <code>spatial.Transform2_Node</code>
                    &nbsp;inside a 
                    <code>Sparse_Set</code>
                    , but now this is no longer possible as the transforms are stored inside a 
                    <code>Handle_Map</code>
                    &nbsp;inside the spatial library.
				</p>
			</li>
			<li>
				<p>
                    I'd like to reconsider that maybe instead of a 
                    <code>Handle_Map</code>
                    , I could use a 
                    <code>Sparse_Set</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If I want to query this component with other things, I'd have to store the transform with the entity_key.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                -&gt;
							</strong>
                            &nbsp;If you think about it, it's kinda weird that 
                            <code>Transform2_Node</code>
                            &nbsp;is not a component....
						</p>
					</li>
					<li>
						<p>
                            Well for what I revised, it doesn't really seem to be room for letting the 
                            <code>Transform2_Node</code>
                            &nbsp;be a component, even tho it probably should...
						</p>
						<ol>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;is an entity, storing the 
                                    <code>Transform2_Node</code>
                                    &nbsp;as a 
                                    <code>Sparse_Set</code>
                                    </s>.
								</p>
								<ul>
									<li>
										<p>
                                            This is probably the only option.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;stores an 
                                    <code>entity_key</code>
                                    &nbsp;for a 
                                    <code>Transform2_Node</code>
                                    ; the 
                                    <code>Transform2_Node</code>
                                    &nbsp;is stored in a 
                                    <code>Sparse_Set</code>
                                    &nbsp;but the key is not provided; used just like a 
                                    <code>hm.add</code>
                                    .</s>
								</p>
								<ul>
									<li>
										<p>
                                            This doesn't allow for queries and creates unsafer code.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;receives a foreign 
                                    <code>entity_key</code>
                                    &nbsp;to add data to the 
                                    <code>Transform2_Node</code>
                                    &nbsp;sparse set</s>.
								</p>
								<ul>
									<li>
										<p>
                                            This shots it self in the foot, basically.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It's about having a reference to a 
                    <code>Transform2_Node</code>
                    , used by parent/children relationships.
				</p>
			</li>
			<li>
				<p>
                    Currently it uses pointers.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    There's other keys available, besides the Entity, via:
				</p>
				<ol>
					<li>
						<p>
                            <s>Wherever specialization is needed, a new Entity is used</s>.
						</p>
						<ul>
							<li>
								<p>
                                    This possibility was explored in the &quot;The data is stored in an 
                                    <code>Component(T)</code>
                                    , using 
                                    <code>entity</code>
                                    &nbsp;to access the data&quot; idea below, and discarded as not being good.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            A 
                            <code>struct</code>
                            &nbsp;stores a key to the data:
						</p>
						<ol>
							<li>
								<p>
									<input
										type="checkbox" 
										disabled=""
										checked="">
                                    The data is stored in an 
                                    <code>Handle_Map(T)</code>
                                    , using 
                                    <code>.handle: Handle</code>
                                    &nbsp;to access the data, without any components
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                This is just a way to have 
                                                <code>transforms[idx]</code>
                                                , but with a generational system
											</strong>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            When something is deleted or removed from the 
                                            <code>Handle_Map</code>
                                            , the elements in the internal array are not moved, so other handles are not invalidated.
										</p>
									</li>
									<li>
										<p>
                                            A 
                                            <code>Handle_Map</code>
                                            &nbsp;is a way to have a generic array (stack or heap) with ways to check if the entry in the array is valid. It does not care much about cache efficiency.
										</p>
									</li>
									<li>
										<p>
                                            It's possible to remove the necessity of having a handle inside of 
                                            <code>T</code>
                                            .
										</p>
										<ol>
											<li>
												<p>
                                                    The 
                                                    <code>Handle_Map</code>
                                                    &nbsp;stores an array of handles that match the required handle for a get.
												</p>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            How does this solve the current issue:
										</p>
										<ul>
											<li>
												<p>
                                                    In summary, the 
                                                    <code>Sprite</code>
                                                    &nbsp;doesn't hold a POINTER to a transform anymore, but a HANDLE.
												</p>
											</li>
											<li>
												<p>
                                                    When a 
                                                    <code>Dynamic_Body</code>
                                                    &nbsp;moves inside the 
                                                    <code>_dynamic_bodies</code>
                                                    &nbsp;component:
												</p>
												<ul>
													<li>
														<p>
                                                            Previously that would move that Transform2_Node as well, as 
                                                            <code>Body :: struct { using trans: Transform2_Node }</code>
                                                            , and as 
                                                            <code>Sprite.parent</code>
                                                            &nbsp;stores a pointer to that, moving the source would cause corrupted behavior.
														</p>
													</li>
													<li>
														<p>
                                                            Now, the data is no longer inside the 
                                                            <code>Body</code>
                                                            , but inside a 
                                                            <code>spatial.transforms</code>
                                                            , which makes so that when the 
                                                            <code>Body</code>
                                                            &nbsp;moves, the 
                                                            <code>Sprite.parent</code>
                                                            &nbsp;doesn't care.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in an 
                                    <code>[]T</code>
                                    &nbsp;or 
                                    <code>Component(T)</code>
                                    , using 
                                    <code>.ptr_to_t: ^T</code>
                                    &nbsp;to access the data, with or without using components</s>
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in an 
                                    <code>[]T</code>
                                    , using 
                                    <code>.idx_to_t: u32</code>
                                    &nbsp;to access the data, without any components</s>.
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
									<li>
										<p>
                                            It's just like handles, but without a generational index and some useful features that remember a 
                                            <code>Small_Array</code>
                                            ; there's no tracking of available slots.
										</p>
									</li>
									<li>
										<p>
                                            Seems like the handle idea is better.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in an 
                                    <code>[]T</code>
                                    , using 
                                    <code>.idx_to_t: u32</code>
                                    &nbsp;and 
                                    <code>_indices_to_t: Component(u32)</code>
                                    &nbsp;to access the data</s>
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in a 
                                    <code>Component(T)</code>
                                    , using 
                                    <code>.dense_idx: u32</code>
                                    &nbsp;to access the data</s>
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>map: 
                                    <code>key</code>
                                    </s>
								</p>
								<ul>
									<li>
										<p>
                                            I prefer Sparse Sets (Components).
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            <s>The data is indirectly stored inside a manager</s>:
						</p>
						<ol>
							<li>
								<p>
                                    <s>Stored inside a 
                                    <code>Component(Transform_Storage)</code>
                                    </s>.
								</p>
								<ul>
									<li>
										<p>
                                            This doesn't solve the original problem of getting valid data; it only groups similar things together.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>Through a 
                                    <code>Transform_System</code>
                                    </s>
								</p>
								<ul>
									<li>
										<p>
                                            I would need a specific transform, and that I cannot get when all data is inside the 
                                            <code>Transform_System</code>
                                            . This doesn't solve the problem at all, only creates an extra layer of indirection.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    <s>If the only ACTUAL key available is the Entity, and I don't store this key anywhere</s>:
				</p>
				<ol>
					<li>
						<p>
                            <s>Many Array/Map/Handle_Map/Component</s>
						</p>
						<ul>
							<li>
								<p>
                                    This is a way to tackle specialization; having many storage structures doesn't solve the issue of things changing inside these backing structures.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>A 
                            <code>struct</code>
                            &nbsp;stores the data itself</s>:
						</p>
						<ul>
							<li>
								<p>
                                    I'd have to store pointers to the transform of other entities, while their transform for sure is being stored inside an array which changes. This is not possible.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>Component(T)</code>
                            , using 
                            <code>entity</code>
                            &nbsp;to access the data.</s>
						</p>
						<ul>
							<li>
								<p>
                                    The original sparse set design.
								</p>
							</li>
							<li>
								<p>
                                    This allows for all cache being updated on a single system.
								</p>
								<ul>
									<li>
										<p>
                                            This could be weird if the parent changes between updates, for sure.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Indirection: <s>There's an extra level of indirection where you have to go through the entity and check if it exists, and then check if this entity has a transform component</s>.
								</p>
								<ul>
									<li>
										<p>
                                            This is true, BUT this is also true for 
                                            <code>Handle_Map</code>
                                            :
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">trans2_node :: proc(trans: Transform2_Node_Handle) -&gt; (trans_node: ^Transform2_Node) {
&nbsp;&nbsp;&nbsp;&nbsp;trans_node = hm.get(&transforms2, trans)
&nbsp;&nbsp;&nbsp;&nbsp;if trans_node == nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error: not found
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return trans_node
}
</code></pre>
								<ul>
									<li>
										<p>
                                            For 
                                            <code>Sparse_Set</code>
                                            &nbsp;that would be:
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">trans2_node :: proc(trans: sparse.Key) -&gt; (trans_node: ^Transform2_Node) {
&nbsp;&nbsp;&nbsp;&nbsp;trans_node, found := sparse.get(&transforms, trans)
&nbsp;&nbsp;&nbsp;&nbsp;if !found {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error: not found
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return trans_node
}
</code></pre>
								<ul>
									<li>
										<p>
                                            It's the same level of indirection.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Problem
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            &quot;If a 'thing' is an entity, it cannot be considered a 'component' for another entity&quot;.
										</p>
									</li>
									<li>
										<p>
                                            Check the explanation for 
                                            <code>Sprite</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
						<ol>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;is an entity, storing the 
                                    <code>Transform2_Node</code>
                                    &nbsp;as a 
                                    <code>Sparse_Set</code>
                                    </s>.
								</p>
<pre><code class="language-odin" data-lang="odin">transforms: ecs.Component(Transform2_Node)
Transform2_Node :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;using local:&nbsp;&nbsp; Transform2,
&nbsp;&nbsp;&nbsp;&nbsp;parent_entity: sparse.Key,
}

trans2_add :: proc(entity: sparse.Key, pos: [2]f32 = {}, rot: f32 = 0, scale: [2]f32 = { 1.0, 1.0 }, parent: sparse.Key = {}) {
&nbsp;&nbsp;&nbsp;&nbsp;assert(scale != 0)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;trans_node: Transform2_Node
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.pos&nbsp;&nbsp;&nbsp;&nbsp;= pos
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.rot&nbsp;&nbsp;&nbsp;&nbsp;= rot
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.scale&nbsp;&nbsp;= scale
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.parent = parent
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&transforms, entity, trans_node)
}
</code></pre>
								<ul>
									<li>
										<p>
                                            For 
                                            <code>Body</code>
                                            :
										</p>
<pre><code class="language-odin" data-lang="odin">Body_Data :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;handle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^jolt.Body,
&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jolt.Body_ID,

&nbsp;&nbsp;&nbsp;&nbsp;layers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32,
&nbsp;&nbsp;&nbsp;&nbsp;is_sensor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool,
&nbsp;&nbsp;&nbsp;&nbsp;shape:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape,

&nbsp;&nbsp;&nbsp;&nbsp;queued_changes: [dynamic]Body_Queue_Change,
}

// this body has the components: 'trans2', 'Body_Data'
_body_create :: proc(pos: [2]f32, parent: sparse.Key) -&gt; (entity: sparse.Key) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&bodies_data, entity, Body_Data{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// usual things here
&nbsp;&nbsp;&nbsp;&nbsp;})

&nbsp;&nbsp;&nbsp;&nbsp;return
}
</code></pre>
										<ul>
											<li>
												<p>
                                                    Atomicity:
												</p>
												<ul>
													<li>
														<p>
                                                            Body is ALREADY ATOMIC, so breaking it apart might give meaningless queries.
														</p>
													</li>
													<li>
														<p>
                                                            &quot;A body is an entity that has a 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;component and a 
                                                            <code>Body_Data</code>
                                                            &nbsp;component&quot;.
														</p>
													</li>
													<li>
														<p>
                                                            Other components 
															<em>
                                                                could
															</em>
                                                            &nbsp;make sense for a body, such as 
                                                            <code>velocity</code>
                                                            , which would define a &quot;dynamic body&quot;. Those might not actually be &quot;components&quot;, but the ACTUAL DEFINITION of a body.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            For 
                                            <code>Sprite</code>
                                            :
										</p>
<pre><code class="language-odin" data-lang="odin">Sprite_Data :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;debug_name:&nbsp;&nbsp; string,

&nbsp;&nbsp;&nbsp;&nbsp;// Tex
&nbsp;&nbsp;&nbsp;&nbsp;tex_path:&nbsp;&nbsp;&nbsp;&nbsp; string,
&nbsp;&nbsp;&nbsp;&nbsp;tex_extent:&nbsp;&nbsp; spatial.Extent,
&nbsp;&nbsp;&nbsp;&nbsp;tex_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u32,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Mesh
&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mesh,

&nbsp;&nbsp;&nbsp;&nbsp;model_matrix: matrix[4, 4]f32,

&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatial.Recti,
&nbsp;&nbsp;&nbsp;&nbsp;flip_x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,
&nbsp;&nbsp;&nbsp;&nbsp;flip_y:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,

&nbsp;&nbsp;&nbsp;&nbsp;tile_size:&nbsp;&nbsp;&nbsp;&nbsp;[2]int,
&nbsp;&nbsp;&nbsp;&nbsp;tile_idx:&nbsp;&nbsp;&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp;_total_tiles: int,

&nbsp;&nbsp;&nbsp;&nbsp;color_mult:&nbsp;&nbsp; [4]f32, // 0 to 1.
&nbsp;&nbsp;&nbsp;&nbsp;color_add:&nbsp;&nbsp;&nbsp;&nbsp;[4]f32, // 0 to 1.
}

sprite_create :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [2]f32 = {},
&nbsp;&nbsp;&nbsp;&nbsp;rot:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f32&nbsp;&nbsp;&nbsp;&nbsp;= 0, 
&nbsp;&nbsp;&nbsp;&nbsp;scale:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [2]f32 = { 1, 1 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sparse.Key = {},
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (sprite: Sprite) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)
}
</code></pre>
										<ul>
											<li>
												<p>
                                                    Atomicity:
												</p>
												<ul>
													<li>
														<p>
                                                            It doesn't make sense to separate the 
                                                            <code>Texture</code>
                                                            &nbsp;or 
                                                            <code>Mesh</code>
                                                            , as the sprite loses all its meaning without both of them. The rest also only has meaning if in the context of a sprite.
														</p>
													</li>
													<li>
														<p>
                                                            &quot;A sprite is an entity that has a 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;component and a 
                                                            <code>Sprite_Data</code>
                                                            &nbsp;component&quot;.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;stores an 
                                    <code>entity_key</code>
                                    &nbsp;for a 
                                    <code>Transform2_Node</code>
                                    ; the 
                                    <code>Transform2_Node</code>
                                    &nbsp;is stored in a 
                                    <code>Sparse_Set</code>
                                    &nbsp;but the key is not provided; used just like a 
                                    <code>hm.add</code>
                                    .</s>
								</p>
								<ul>
									<li>
										<p>
                                            Rationale
										</p>
										<ul>
											<li>
												<p>
                                                    I could query for 
                                                    <code>Transform2_Node</code>
                                                    &nbsp;data, I think.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<em>
                                                Problem
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    Queries:
												</p>
												<ul>
													<li>
														<p>
                                                            The query will use an &quot;Entity Key&quot; for intersecting 
                                                            <code>Sparse_Set</code>
                                                            s, BUT, in this circumstance, the 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;uses a &quot;Transform Key&quot;, as this key is not one from an entity, but one generated on 
                                                            <code>sparse.add</code>
                                                            /&quot;
                                                            <code>sparse.append</code>
                                                            &quot;. Any query performed with different &quot;keys&quot; are incompatible.
														</p>
														<ul>
															<li>
																<p>
                                                                    Example:
																</p>
																<ul>
																	<li>
																		<p>
                                                                            An entity 
                                                                            <code>5</code>
                                                                            &nbsp;might have a sprite sparse set, and this sprite has the &quot;transform_key&quot; 
                                                                            <code>8</code>
                                                                            ; when querying 
                                                                            <code>(&_sprites, &spatial.transforms)</code>
                                                                            , this will be highly incorrect, as the query will return the &quot;sprite 5&quot; and &quot;transform 5&quot;. This query gives incorrect information.
																		</p>
																	</li>
																</ul>
															</li>
														</ul>
													</li>
													<li>
														<p>
                                                            So: if using 
                                                            <code>Sparse Set</code>
                                                            s this way doesn't give me the query benefit, this strategy gives me nothing.
														</p>
													</li>
													<li>
														<p>
                                                            Sure, the data is more &quot;packed&quot;, but at the cost of confusion in the design, as I 
															<strong>
                                                                could
															</strong>
                                                            &nbsp;perform a query, but that would be incorrect, enabling mistakes if I'm not very aware of what the &quot;transform_key&quot; means.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;receives a foreign 
                                    <code>entity_key</code>
                                    &nbsp;to add data to the 
                                    <code>Transform2_Node</code>
                                    &nbsp;sparse set</s>.
								</p>
<pre><code class="language-odin" data-lang="odin">transforms: ecs.Component(Transform2_Node)

Transform2_Node :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;using local:&nbsp;&nbsp; Transform2,
&nbsp;&nbsp;&nbsp;&nbsp;parent_entity: sparse.Key,
}

trans2_add :: proc(entity: sparse.Key, pos: [2]f32 = {}, rot: f32 = 0, scale: [2]f32 = { 1.0, 1.0 }, parent: sparse.Key = {}) {
&nbsp;&nbsp;&nbsp;&nbsp;assert(scale != 0)

&nbsp;&nbsp;&nbsp;&nbsp;trans_node: Transform2_Node
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.pos&nbsp;&nbsp;&nbsp;&nbsp;= pos
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.rot&nbsp;&nbsp;&nbsp;&nbsp;= rot
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.scale&nbsp;&nbsp;= scale
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.parent = parent

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&transforms, entity, trans_node)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">Body :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;using trans:&nbsp;&nbsp;&nbsp;&nbsp;sparse.Key,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;handle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^jolt.Body,

&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jolt.Body_ID,
&nbsp;&nbsp;&nbsp;&nbsp;layers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32,
&nbsp;&nbsp;&nbsp;&nbsp;is_sensor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool,
&nbsp;&nbsp;&nbsp;&nbsp;shape:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;queued_changes: [dynamic]Body_Queue_Change,
}

// TODO: what would this look like?
_body_create :: proc(entity_key: sparse.Key, pos: [2]f32, parent: spatial.Transform2_Node_Handle) -&gt; (body: Body) {
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity_key, pos, parent = parent)
}
</code></pre>
								<ul>
									<li>
										<p>
											<em>
                                                Problem
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    The key received for 
                                                    <code>_body_create</code>
                                                    &nbsp;is most likely a key used for some other entity (if this is not the case, then this falls within the idea &quot;The 
                                                    <code>Body</code>
                                                    /
                                                    <code>Sprite</code>
                                                    &nbsp;is an entity, storing the 
                                                    <code>Transform2_Node</code>
                                                    &nbsp;as a 
                                                    <code>Sparse_Set</code>
                                                    &quot;), but this means that some problems emerge from the same entity having many things added to a sparse set using the same key.
												</p>
												<ul>
													<li>
														<p>
                                                            The solutions investigated were:
														</p>
														<ol>
															<li>
																<p>
                                                                    Wherever specialization is needed, a new Entity is used.
                                                                    <br>
                                                                    That's all...
																</p>
															</li>
														</ol>
													</li>
													<li>
														<p>
                                                            So this means that it all falls down to the idea &quot;The 
                                                            <code>Body</code>
                                                            /
                                                            <code>Sprite</code>
                                                            &nbsp;is an entity, storing the 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;as a 
                                                            <code>Sparse_Set</code>
                                                            &quot;, and so this current idea is discarded.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
</ul>
<h3
	id="thinking-in-terms-of-specialization-and-shared-data" >
    Thinking in terms of specialization and shared data
</h3>
<ol>
	<li>
		<p>
            There's other keys available, besides the Entity, via:
		</p>
		<ol>
			<li>
				<p>
                    Wherever specialization is needed, a new Entity is used.
				</p>
				<ul>
					<li>
						<p>
                            This is a way to keep using Entity as the ONLY available key.
						</p>
					</li>
					<li>
						<p>
                            It's quite straight forward: need a new key -&gt; create a new entity, which is equivalent to creating a new key.
						</p>
					</li>
					<li>
						<p>
                            Works well when subobjects have independent lifecycles or lots of data/behavior.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    larger entity count and more queries for parent-child walking.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Considerations
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The 
                                    <code>Damage_Indicator</code>
                                    &nbsp;doesn't OWN the sprite; it's just a reference from the entity's sprite.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Use this when the subobject has identity or can exist independently (or if it carries many other components). For small, ephemeral timers itâ€™s overkill.
						</p>
					</li>
					<li>
						<p>
                            Promoting AI and Hitbox to entities is a valid and common approach when those subsystems need identity, separate lifetime, or many components (including timers). It restores the â€œhintâ€ you miss and fits ECS philosophy (composition). Do it selectively: only promote when the subobject has independent behavior; otherwise keep a TimerStorage to avoid entity bloat.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            What are the possible advantages of having a system like this?
                            <br>
                            &quot;the entity dies, but the health bar or AI Controller stays behind&quot;.
						</p>
						<ul>
							<li>
								<p>
                                    Is there advantages for having data like this separate?
								</p>
								<ul>
									<li>
										<p>
                                            Thing for example, what if many entities use the same AI Controller or Health? (I don't know why, probably doesn't make sense); think of Shaco's Boxes.
                                            <br>
                                            this would mean:
                                            <br>
                                            | entity (entity_id) | health (entity_id) |
                                            <br>
                                            |--------------------|--------------------|
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                            <br>
                                            | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                            <br>
                                            | 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
										</p>
									</li>
									<li>
										<p>
                                            Is this currently possible?
										</p>
										<ul>
											<li>
												<p>
                                                    For add:
												</p>
												<ul>
													<li>
														<p>
                                                            <code>component.dense</code>
                                                            &nbsp;would have to increase.
														</p>
													</li>
													<li>
														<p>
                                                            <code>component.data</code>
                                                            &nbsp;stays the same.
														</p>
													</li>
													<li>
														<p>
                                                            <code>component.sparse[new_entity] = component.sparse[existing_entity]</code>
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    For remove:
												</p>
												<ul>
													<li>
														<p>
                                                            It would have to use the dense_idx from one entity and iterate over the whole array trying to find other entries that also use this dense_idx to remove them; something like that.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                How to kill sub-entities when the main entity dies?
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    Use children / parent.
								</p>
							</li>
						</ul>
						<ol>
							<li>
								<p>
                                    There could be a component
								</p>
								<ul>
									<li>
										<p>
                                            If a component, I would do something like:
                                            <br>
                                            | entity (entity_id) | child (entity_id) |
                                            <br>
                                            |--------------------|-------------------|
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
										</p>
									</li>
									<li>
										<p>
                                            So I use something like &quot;component_get_all&quot;, for example.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Other data struct that maps one to another.
								</p>
								<ul>
									<li>
										<p>
                                            Using a map is basically the same as a component, but less efficient for huge amounts of entities, and incoherent with the current design.
										</p>
									</li>
									<li>
										<p>
                                            Remember, a Component is just a Sparse Set for Entities -&gt; T.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The entity could be a struct, instead of a 
                                    <code>u32</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            This makes the 
                                            <code>Entity</code>
                                            &nbsp;and every Entity array fatter; it could be a problem, maybe.
										</p>
									</li>
									<li>
										<p>
                                            Also, children would require a heap allocated array, or a limit on how many children an entity can have by using a stack array.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>A 
                    <code>struct</code>
                    &nbsp;stores a key to the data</s>:
				</p>
				<ul>
					<li>
						<p>
                            Wherever this struct is used, it basically indicates a little bit of OOP in this part of the code.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Core problem
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Exposing direct references (raw pointers or dense indices) into component storage is unsafe because storage can move or be freed.
								</p>
							</li>
						</ul>
					</li>
				</ul>
				<ol>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            The data is stored in an 
                            <code>Handle_Map(T)</code>
                            , using 
                            <code>.handle: Handle</code>
                            &nbsp;to access the data, without any components.
						</p>
						<ul>
							<li>
								<p>
                                    A little bit better than an index, as:
								</p>
								<ul>
									<li>
										<p>
                                            if something moves inside the array, the index could be referencing something incoherent.
										</p>
									</li>
									<li>
										<p>
                                            Now, at least, you get notified on 
                                            <code>get()</code>
                                            &nbsp;that the handle used is invalid.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    A little bit better than a pointer, as:
								</p>
								<ul>
									<li>
										<p>
                                            If the object origin is freed, accessing or dereferencing the pointer would result in a crash
										</p>
									</li>
									<li>
										<p>
                                            Now, at least, the crash won't happen and you get notified that the handle is invalid.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Other Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            A handle has to be stored. Where?
										</p>
										<ol>
											<li>
												<p>
                                                    A Sparse_Set stores the Handle.
												</p>
												<ul>
													<li>
														<p>
                                                            This gives the impression of: &quot;Handle to Handle&quot; or &quot;Pointer to Pointer&quot;.
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            Also, not using components make this data not compatible with queries/systems.
										</p>
										<ul>
											<li>
												<p>
                                                    This is a problem when you consider that querying the components is a way to update all data with same purpose together, improving performance and avoiding coupling data to objects. Not using components makes that the data is coupled with the struct storing the index.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            A 
                                            <code>Timer</code>
                                            &nbsp;would have to have a 
                                            <code>.handle</code>
                                            &nbsp;entry, as for the spec of the handle map library, so the handles can be compared.
										</p>
									</li>
									<li>
										<p>
                                            Extra complexity for each fetch.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Remove
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Not using components would cause to lose the notion of lifetime coupling with the entity.
										</p>
										<ul>
											<li>
												<p>
                                                    The handle has to manually be removed from the handle_map via using its handle.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>[]T</code>
                            , using 
                            <code>.idx_to_t: u32</code>
                            &nbsp;to access the data</s>.
						</p>
						<ul>
							<li>
								<p>
                                    This creates an extra indirection, with the sole purpose so the 
                                    <code>Damage_Indicator</code>
                                    &nbsp;have an index to the 
                                    <code>[]Sprite</code>
                                    &nbsp;via 
                                    <code>Damage_Indicator.sprite_idx: u32</code>
                                    .
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If something moves inside the array, the index could be referencing something incoherent.
										</p>
										<ul>
											<li>
												<p>
                                                    Things WILL move as soon as some entity is destroyed, etc; this happens a lot.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Other Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Not using components make this data not compatible with queries/systems. This is a problem when you consider that querying the components is a way to update all data with same purpose together, improving performance and avoiding coupling data to objects. Not using components makes that the data is coupled with the struct storing the index.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Stored inside
									</em>
                                    :
								</p>
								<ol>
									<li>
										<p>
                                            Timer library.
										</p>
									</li>
									<li>
										<p>
                                            <s>Level</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    A bit annoying. There could be timers outside the level boundaries, for level transitions, etc.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Game</s>
										</p>
										<ul>
											<li>
												<p>
                                                    Sure, but timer library might be basically the same thing, while this would have to happen for every game.
												</p>
											</li>
											<li>
												<p>
                                                    Letting the library store this is more intuitive.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Global scope</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    Ugly. Timer library is better.
												</p>
											</li>
										</ul>
									</li>
								</ol>
							</li>
							<li>
								<p>
									<em>
                                        Remove
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Not using components would cause to lose the notion of lifetime coupling with the entity.
										</p>
										<ul>
											<li>
												<p>
                                                    The element inside that index has to manually be removed from the array via using its index.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>[]T</code>
                            , using 
                            <code>.idx_to_t: u32</code>
                            &nbsp;and 
                            <code>_indices_to_t: Component(u32)</code>
                            &nbsp;to access the data</s>.
						</p>
						<ul>
							<li>
								<p>
                                    This creates an extra indirection, with the sole purpose to allow the 
                                    <code>Damage_Indicator</code>
                                    &nbsp;to also have an index to the 
                                    <code>[]Sprite</code>
                                    &nbsp;via 
                                    <code>Damage_Indicator.sprite_idx: u32</code>
                                    . So both &quot;character&quot; and 
                                    <code>Damage_Indicator</code>
                                    &nbsp;hold into the same 
                                    <code>u32</code>
                                    .
                                    <br>
									<em>
                                        Stored inside
									</em>
                                    :
								</p>
								<ol>
									<li>
										<p>
                                            Timer library.
										</p>
									</li>
									<li>
										<p>
                                            <s>Level</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    A bit annoying. There could be timers outside the level boundaries, for level transitions, etc.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Game</s>
										</p>
										<ul>
											<li>
												<p>
                                                    Sure, but timer library might be basically the same thing, while this would have to happen for every game.
                                                    <br>
                                                    Letting the library store this is more intuitive.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Global scope</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    Ugly. Timer library is better.
												</p>
											</li>
										</ul>
									</li>
								</ol>
							</li>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            While the &quot;character&quot; uses its 
                                            <code>Entity</code>
                                            &nbsp;id to access the u32, the 
                                            <code>Damage_Indicator</code>
                                            &nbsp;uses 
                                            <code>sprite_idx: u32</code>
                                            &nbsp;to get the data.
										</p>
										<ul>
											<li>
												<p>
                                                    This creates incoherences between these two methods of accessing the data. The 
                                                    <code>Entity</code>
                                                    &nbsp;method allows for entities to be moved, removed, etc, while the 
                                                    <code>Damage_Indicator</code>
                                                    &nbsp;is stuck with a 
                                                    <code>u32</code>
                                                    &nbsp;giving it direct access to the 
                                                    <code>[]Sprite</code>
                                                    . In a way, this is a worse/similar version of 
                                                    <code>Damage_Indicator.sprite_dense_idx: u32</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            If something moves inside the array, the index could be referencing something incoherent.
										</p>
										<ul>
											<li>
												<p>
                                                    Things WILL move as soon as some entity is destroyed, etc; this happens a lot.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in a 
                            <code>Component(T)</code>
                            , using 
                            <code>.dense_idx: u32</code>
                            &nbsp;to access the data</s>.
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Storing the 
                                            <code>dense_idx</code>
                                            &nbsp;alone doesn't tell the whole story, as it's not clear WHICH component this 
                                            <code>dense_idx</code>
                                            &nbsp;refers to; this is unsafe.
										</p>
									</li>
									<li>
										<p>
                                            If components are removed, the 
                                            <code>dense_idx</code>
                                            &nbsp;could point to:
										</p>
										<ul>
											<li>
												<p>
                                                    something outside the boundaries of the 
                                                    <code>.data</code>
                                                    &nbsp;array;
												</p>
											</li>
											<li>
												<p>
                                                    or something completely different, unexpected.
												</p>
											</li>
											<li>
												<p>
                                                    In a way, this manages to have both issues of 'pointer invalidation through a free' AND 'idx invalidation for an array through moving the elements'.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>[]T</code>
                            &nbsp;or 
                            <code>Component(T)</code>
                            , using 
                            <code>.ptr_to_t: ^T</code>
                            &nbsp;to access the data, with or without using components</s>.
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Pointers to data inside a 
                                            <code>Component(T)</code>
                                            &nbsp;should not be stored; which is the case for the return of 
                                            <code>sparse.add</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    This pointer is a pointer to a SLOT on the 
                                                    <code>component.data</code>
                                                    &nbsp;array. If this array is resized, or any other thing happens to the contents of this array, the pointer will keep pointing to the same place, but now the data that was previously there might have changed causing random behavior, or might be invalid, causing a crash.
												</p>
											</li>
											<li>
												<p>
                                                    This is the same limitation for when using 
                                                    <code>Handle_Maps</code>
                                                    .
												</p>
											</li>
											<li>
												<p>
                                                    This completely prohibits the usage of this strategy.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Annoyances
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If the object origin is freed, accessing or dereferencing the pointer would result in a crash.
										</p>
										<ul>
											<li>
												<p>
                                                    This is not really a problem if coupling the lifetimes of everything.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>map: 
                            <code>key</code>
                            </s>
						</p>
						<ul>
							<li>
								<p>
                                    I prefer Sparse Sets (Components).
								</p>
							</li>
							<li>
								<p>
                                    Shares the same problems as other storage structures.
								</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    <s>The data is indirectly stored inside a manager</s>:
				</p>
				<ol>
					<li>
						<p>
                            <s>Stored inside a 
                            <code>Component(Timer_Storage)</code>
                            </s>.
						</p>
						<ul>
							<li>
								<p>
                                    This is better interpreted as a 
                                    <code>Component([]Timer)</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This is a way to avoid this:
                                    <br>
                                    | entity | health |
                                    <br>
                                    |--------|--------|
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Wrong problem
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            This doesn't solve the original problem of fetching a specific data, it only groups similar things together. If you want a specific data inside that array, the original problem arises again.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>Through a 
                            <code>Timer_System</code>
                            </s>
						</p>
						<ul>
							<li>
								<p>
                                    This follows up the design from a Tween.
								</p>
							</li>
							<li>
								<p>
                                    The timer would be added to the timer system, which could be all an entity needs for all its timers.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If the same effect happens very frequently, the timer would not reset, but new ones are created instead and accumulating a lot of 
                                            <code>on_end</code>
                                            &nbsp;callbacks.
										</p>
									</li>
									<li>
										<p>
                                            In the same topic, a timer cannot be reset or stopped once it has started.
										</p>
									</li>
									<li>
										<p>
                                            This is just a way to avoid the referencing problem by delegating it to a system. It doesn't solve the problem for 
                                            <code>Sprite</code>
                                            &nbsp;for example. It avoids the &quot;timer type&quot; necessity, it does not solve it.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
		<p>
            <s>If the only ACTUAL key available is the Entity, and I don't store this key anywhere</s>:
		</p>
		<ol>
			<li>
				<p>
                    ~Many Array/Map/Handle_Map/Component
				</p>
				<ul>
					<li>
						<p>
                            Each new data struct represents semantic and intent, so that way I can specialize the data based on which &quot;array&quot; this is stored.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    I think this is a really bad solution, as if I have many specializations, I'd have to have many arrays, with permutations for each specialization.
								</p>
							</li>
							<li>
								<p>
                                    Ex:
								</p>
								<ul>
									<li>
										<p>
                                            sprite_bouncy
										</p>
									</li>
									<li>
										<p>
                                            sprite_bouncy_blinkable
										</p>
									</li>
									<li>
										<p>
                                            sprite_blinkable
										</p>
									</li>
									<li>
										<p>
                                            sprite_shadow
										</p>
									</li>
									<li>
										<p>
                                            etc
										</p>
									</li>
									<li>
										<p>
                                            timers_with_type1: Component(Timer)
										</p>
									</li>
									<li>
										<p>
                                            timers_with_type2: Component(Timer)
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    For Timers in specific, this seems like a huge waste, as every timer is different from another. I would end up having A LOT of different timer components, where most of them are basically empty, as it might be a very specific timer.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>A 
                    <code>struct</code>
                    &nbsp;stores the data itself</s>:
				</p>
				<ul>
					<li>
						<p>
                            This is basically OOPing this part of the code.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Killer Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The MAIN problem of this strategy is &quot;shared data&quot;:
								</p>
								<ul>
									<li>
										<p>
                                            For example, the case of a 
                                            <code>Sprite</code>
                                            &nbsp;for 
                                            <code>Damage_Indicator</code>
                                            , as the sprite is a component from the entity.
										</p>
									</li>
									<li>
										<p>
                                            Every attempt to solve this would fall in one of these 2 ideas discussed:
										</p>
										<ol>
											<li>
												<p>
                                                    <s>&quot;The data is stored in an 
                                                    <code>[]T</code>
                                                    , while 
                                                    <code>_indices_to_t: Component(u32)</code>
                                                    &quot;</s>
												</p>
												<ul>
													<li>
														<p>
                                                            It was argued to be a bad idea.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>A 
                                                    <code>struct</code>
                                                    &nbsp;stores a key to the data</s>
												</p>
											</li>
										</ol>
										<ul>
											<li>
												<p>
                                                    Both ideas are simply a DIFFERENT idea. Trying to solve the sharable problem requires a different design to be implemented. This idea cannot be saved when it comes to shared data, it's a problem from the design: something has ownership to the data and others want to access this data.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    This breaks the idea of storing all data inside the same data struct, which breaks the idea of all Timers being updated together.
								</p>
								<ul>
									<li>
										<p>
                                            For timers, this requires 
                                            <code>update</code>
                                            &nbsp;to be called for each of them.
										</p>
										<ul>
											<li>
												<p>
                                                    As a way to avoid this, when initing a timer, it would be added to a:
												</p>
												<ol>
													<li>
														<p>
                                                            <code>Timer_System</code>
                                                            , passed as a parameter.
														</p>
													</li>
													<li>
														<p>
                                                            global process array, inside the 
                                                            <code>import "shared:eng/timer</code>
                                                            .
														</p>
													</li>
												</ol>
											</li>
											<li>
												<p>
                                                    Regardless, this is not the main problem.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Not so good of a system, as updating a timer is impossible to enforce, so you end up forgetting sometimes.
										</p>
									</li>
									<li>
										<p>
                                            Not so cache efficient for updates.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>The data is stored in an 
                    <code>Component(T)</code>
                    , using 
                    <code>entity</code>
                    &nbsp;to access the data</s>.
				</p>
				<ul>
					<li>
						<p>
                            The original sparse set design.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It was from here that the specialization problem was originated.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</li>
</ol>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-01-23 ðŸš€
			</footer>
		</div>
		<script
			src="/static/studies.94901.js" >
		</script>
	</body>
</html>
