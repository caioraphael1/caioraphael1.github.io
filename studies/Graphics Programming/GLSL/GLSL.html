<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/favicon.ico" >
		<link
			rel="icon" 
			href="/assets/favicon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/favicon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script
			src="/static/docs_load.js" >
		</script>
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			src="https://unpkg.com/@highlightjs/cdn-assets@11.11.1/highlight.min.js" >
		</script>
		<script
			src="https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.min.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
					open="">
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - DOD e COP/Design - DOD e COP.html" >
                                Design - DOD e COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - ECS/Design - ECS.html" >
                                Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Design Patterns/Design - Design Patterns.html" >
                                Design - Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Architecture Patterns.html" >
                                Design - Architecture Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Concepts and Terminology.html" >
                                Design - Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Rules of thumb - Laws - Guidelines and Principles/Design - Rules of thumb - Laws - Guidelines and Principles.html" >
                                Design - Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Paradigms.html" >
                                Design - Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Production Methodologies/Design - Production Methodologies.html" >
                                Design - Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Things
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/NeoVim - Uso/NeoVim - Uso.html" >
                                NeoVim - Uso
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Dependencies.html" >
                                Dependencies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML - Tests/HTML - Tests.html" >
                                HTML - Tests
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Electronics
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<header
				id="central-header" >
				<nav
					id="dropdown-menu" >
					<select
						onchange="if (this.value) window.location.href=this.value" >
						<option
							value="/" 
>
                            🏡 Home
						</option>
						<option
							value="/studies/_index.html" 
							selected="">
                            📖 Studies
						</option>
					</select>
				</nav>
				<button
					class="btn" 
					id="button-color-theme" >
					<i>
                        ☀️ / 🌑
					</i>
				</button>
			</header>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            GLSL
						</h1>
						<p>
							<time
								datetime="2025-07-28" >
                                🕒 Created: 2025-07-28
							</time>
							<time
								datetime="2025-10-29" >
                                | Updated: 2025-10-29
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<ul>
	<li>
		<p>
            I haven't studied much about it. There are a lot of texts here that need to be revised and properly rewritten.
		</p>
	</li>
</ul>
<h3
	id="where-i-stopped" >
    Where I Stopped
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/glsl/latest/index.html" 
				class="external-link" 
				target="_blank" >
                GLSL Spec in Vulkan
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            Learn more about 
            <a href="GLSL.html#Storage Qualifiers">
            GLSL#Storage Qualifiers
            </a>
            , etc.
		</p>
	</li>
</ul>
<h3
	id="about" >
    About
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language" 
				class="external-link" 
				target="_blank" >
                GLSL
			</a>
            &nbsp;(OpenGL Shader Language).
		</p>
	</li>
	<li>
		<p>
            Open standard (Khronos Group).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Works with
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    OpenGL.
				</p>
			</li>
			<li>
				<p>
                    Vulkan.
				</p>
			</li>
			<li>
				<p>
                    WebGL.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How Vulkan uses it
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's the most common shader language used for Vulkan.
				</p>
			</li>
			<li>
				<p>
                    It's human-readable, widely supported, and tools like 
                    <code>glslangValidator</code>
                    &nbsp;convert it to SPIR-V easily.
				</p>
			</li>
			<li>
				<p>
                    Compiling GLSL to SPIR-V:
				</p>
				<ul>
					<li>
						<p>
                            The output is a binary SPIR-V files (
                            <code>vert.spv</code>
                            , 
                            <code>frag.spv</code>
                            ) fed to Vulkan at runtime.
						</p>
					</li>
				</ul>
<pre><code class="language-sh" data-lang="sh"> glslangValidator -V shader.vert -o vert.spv
 glslangValidator -V shader.frag -o frag.spv
</code></pre>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="formats" >
    Formats
</h3>
<ul>
	<li>
		<p>
            every format that does not end in 
            <code>_u/s norm</code>
            , 
            <code>_u/s scaled</code>
            , or 
            <code>_*float/int</code>
            &nbsp;are storing non-linear colors
		</p>
	</li>
	<li>
		<p>
            reads and writes through the texture interface 
			<em>
                will
			</em>
            &nbsp;have conversion to and from linear done for you
		</p>
	</li>
	<li>
		<p>
            A raw memory access, e.g. through a buffer or a copy, does not.
		</p>
	</li>
	<li>
		<p>
            So, if the 
            <code>uniform sampler2D</code>
            &nbsp;is SRGB, I will read it as linear inside the shader? Also, if the color attachment is SRGB, the output will be converted from linear to srgb?
		</p>
		<ul>
			<li>
				<p>
                    only if you are accessing it through the texture/image interface, yes.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="constant-data" >
    Constant Data
</h3>
<ul>
	<li>
		<p>
            This data can be anything we want it to be, for instance it can be used for things such as calculating where an object should be placed inside our world, or computing the overall brightness of an object based on the lights in the scene.
		</p>
	</li>
	<li>
		<p>
            The data remains 
			<em>
                constant
			</em>
            &nbsp;across every shader invocation of a draw call.
		</p>
		<ul>
			<li>
				<p>
                    It differs from other data (e.g. input vertex data) in this sense.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The data can be 
			<strong>
                shared
			</strong>
            &nbsp;between shader stages, as we know it isn’t going to be changed throughout the runtime of a single draw call in a render pipeline.
		</p>
	</li>
	<li>
		<p>
            Constant data is implemented in shader code by using global variables.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Global variables
			</strong>
            &nbsp;have the following format: 
            <code>&lt;layout&gt; &lt;storage&gt; &lt;type&gt; &lt;variable_name&gt;</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(location = 0) in vec4 position;

layout(set = 0, binding = 0) uniform Data
{
&nbsp;&nbsp;&nbsp;&nbsp;mat4 model;
} data;

layout(location = 0) out vec4 o_pos;
</code></pre>
<h3
	id="varying-types" >
    Varying Types
</h3>
<ul>
	<li>
		<p>
            The global variables that use inputs (
            <code>in</code>
            ) and outputs (
            <code>out</code>
            ) are values that 
			<em>
                may vary
			</em>
            &nbsp;from one shader invocation to the next, therefore they 
			<strong>
                shouldn’t
			</strong>
            &nbsp;be used for constant data.
		</p>
	</li>
	<li>
		<p>
            They require a 
            <code>layout location</code>
            &nbsp;which is used to identify a particular input/output.
		</p>
	</li>
	<li>
		<p>
            They have slightly different rules for what they do depending on the shader stage, and have slightly different restrictions on the types of data it can represent. However, generally their use is to feed values from one stage to the next (e.g. from vertex shader to fragment shader).
		</p>
	</li>
</ul>
<h3
	id="uniform-types" >
    Uniform Types
</h3>
<ul>
	<li>
		<p>
            Uniform types are global variables that have either the 
            <code>uniform</code>
            &nbsp;or 
            <code>buffer</code>
            &nbsp;storage type, these are 
			<em>
                uniform buffer objects
			</em>
            &nbsp;and 
			<em>
                shader storage buffer objects
			</em>
            &nbsp;respectively. They describe data which remains constant across an entire draw call, meaning that the values stay the same across the different shader stages and shader invocations.
		</p>
	</li>
	<li>
		<p>
            These values use a 
            <code>layout binding</code>
            &nbsp;and, when working with multiple 
            <code>VkDescriptorSet</code>
            s, we will also give it a 
            <code>layout set</code>
		</p>
	</li>
	<li>
		<p>
			<strong>
                Uniform buffer objects (UBOs)
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Are the more commonly used of the two. They are 
					<em>
                        read-only
					</em>
                    &nbsp;buffers, so trying to edit them in shader code will result in a compile-time error.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Shader storage buffer objects (SSBOs)
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Are like special types of uniform buffer objects, denoted by the storage type 
                    <code>buffer</code>
                    . Unlike UBOs they can be written to, meaning the values 
					<em>
                        can
					</em>
                    &nbsp;be changed in the shaders so therefore they don’t always represent data that is constant.
				</p>
			</li>
			<li>
				<p>
                    Having said this, depending on the implementation, they generally can hold a lot more data as opposed to UBOs.
				</p>
				<ul>
					<li>
						<p>
                            To check how much data we can store in uniform buffers and storage buffers, you can query the physical device for its 
                            <code>VkPhysicalDeviceLimits</code>
                            &nbsp;and check the values 
                            <code>maxUniformBufferRange</code>
                            &nbsp;and 
                            <code>maxStorageBufferRange</code>
                            &nbsp;respectively.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="interface-blocks" >
    Interface Blocks
</h3>
<ul>
	<li>
		<p>
            To implement our constant data we have to use an interface block. Interface blocks in shader code are used to group multiple global variables of the same 
            <code>&lt;storage&gt;</code>
            &nbsp;type.
		</p>
	</li>
	<li>
		<p>
            In theory they aren’t necessarily solely for constant data.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform PerMeshData {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 camera_position;
&nbsp;&nbsp;&nbsp;&nbsp;mat4 model_matrix;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 mesh_color;
} per_mesh_data;
</code></pre>
<ul>
	<li>
		<p>
            Interface blocks are still global variables, and technically still follow the global variable format. However, the difference is that they have to be given a user-defined type.
		</p>
	</li>
	<li>
		<p>
            They work exactly the same way as a 
            <code>struct</code>
            &nbsp;in GLSL/C++. For example, to access the model matrix in this interface block, you’d use 
            <code>per_mesh_data.model_matrix</code>
            .
		</p>
	</li>
</ul>
<h3
	id="cheat-sheet" >
    Cheat Sheet
</h3>
<ul>
	<li>
		<p>
			<strong>
                <code>gl_Position</code>
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Is always in 
					<strong>
                        clip space
					</strong>
                    &nbsp;(homogeneous coordinates before perspective divide).
				</p>
			</li>
			<li>
				<p>
                    After the GPU does the perspective divide (
                    <code>gl_Position.xyz / gl_Position.w</code>
                    ), you get 
					<strong>
                        Normalized Device Coordinates (NDC)
					</strong>
                    &nbsp;in the range 
                    <code>[-1, 1]</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The viewport transform then maps NDC into 
					<strong>
                        window coordinates
					</strong>
                    &nbsp;(pixels on screen).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Model Space -&gt; World Space -&gt; View Space
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec4 vertex_pos_world_space = model.model_matrix * vec4(vertex_pos, 1.0);
vec4 vertex_pos_view_space  = globals.view * vertex_pos_world_space;
gl_Position  = globals.proj * vertex_pos_view_space;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                SCREEN UV
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec2 screen_uv = gl_FragCoord.xy / vec2(viewport_size);

// Godot
vec2 screen_uv = gl_FragCoord.xy * screen_pixel_size;
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">vec2 viewport_resolution = vec2(1920, 1080);
vec2 screen_space_uv = gl_FragCoord.xy / viewport_resolution.xy;
</code></pre>
<ul>
	<li>
		<p>
            <img src="assets/glsl_-_screen_uv.excalidraw" width="260" alt="<excalidraw_not_loaded>" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Vertex Light
			</strong>
            :
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">#ifdef LIGHT_VERTEX_USED
vec3 light_vertex = vertex;
</code></pre>
<h5
	id="enums" >
    Enums
</h5>
<pre><code class="language-glsl" data-lang="glsl">#define GLOW_MODE_ADD 0
#define GLOW_MODE_SCREEN 1
#define GLOW_MODE_SOFTLIGHT 2
#define GLOW_MODE_REPLACE 3
#define GLOW_MODE_MIX 4

if (params.glow_mode == GLOW_MODE_ADD) {
</code></pre>
<h5
	id="bitmasks" >
    Bitmasks
</h5>
<pre><code class="language-glsl" data-lang="glsl">#define FLAG_USE_BCS (1 &lt;&lt; 0)
#define FLAG_USE_GLOW (1 &lt;&lt; 1)
#define FLAG_USE_AUTO_EXPOSURE (1 &lt;&lt; 2)
#define FLAG_USE_COLOR_CORRECTION (1 &lt;&lt; 3)
#define FLAG_USE_FXAA (1 &lt;&lt; 4)
#define FLAG_USE_DEBANDING (1 &lt;&lt; 5)
#define FLAG_CONVERT_TO_SRGB (1 &lt;&lt; 6)

if (bool(params.flags & FLAG_USE_BCS)) {
&nbsp;&nbsp;&nbsp;&nbsp;color.rgb = apply_bcs(color.rgb, params.bcs);
}
</code></pre>
<h2
	id="basic" >
    Basic
</h2>
<h5
	id="comments" >
    Comments
</h5>
<pre><code class="language-glsl" data-lang="glsl">//
/*
*/
</code></pre>
<h5
	id="source-strings" >
    Source Strings
</h5>
<pre><code class="language-glsl" data-lang="glsl">float f\
oo;
// forms a single line equivalent to "float foo;"
// (assuming '\' is the last character before the new-line and "oo" are
// the first two characters of the next line)
</code></pre>
<h3
	id="preprocessors" >
    Preprocessors
</h3>
<pre><code class="language-glsl" data-lang="glsl">#&nbsp;&nbsp;
#define&nbsp;&nbsp;
#undef&nbsp;&nbsp;

#if&nbsp;&nbsp;
#ifdef&nbsp;&nbsp;
#ifndef&nbsp;&nbsp;
#else&nbsp;&nbsp;
#elif&nbsp;&nbsp;
#endif&nbsp;&nbsp;

#error&nbsp;&nbsp;
#pragma&nbsp;&nbsp;

#extension&nbsp;&nbsp;
#version&nbsp;&nbsp;

#line

defined
##
</code></pre>
<ul>
	<li>
		<p>
            <code>#if</code>
            , **
            <code>#ifdef,** </code>
            #ifndef
            <code>, </code>
            #else
            <code>, </code>
            #elif
            <code>, and </code>
            #endif`.
		</p>
		<ul>
			<li>
				<p>
                    Operate as is standard for C++ preprocessors, except for the following:
				</p>
				<ul>
					<li>
						<p>
                            Expressions following 
                            <code>#if</code>
                            &nbsp;and 
                            <code>#elif</code>
                            &nbsp;are further restricted to expressions operating on literal integer constants, plus identifiers consumed by the 
                            <code>defined</code>
                            &nbsp;operator.
						</p>
					</li>
					<li>
						<p>
                            Character constants are not supported.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>#pragma</code>
		</p>
		<ul>
			<li>
				<p>
                    Allows implementation-dependent compiler control. Tokens following 
                    <code>#pragma</code>
                    &nbsp;are not subject to preprocessor macro expansion. If an implementation does not recognize the tokens following 
                    <code>#pragma</code>
                    , then it will ignore that pragma.
				</p>
			</li>
			<li>
				<p>
                    The following pragmas are defined as part of the language.
				</p>
			</li>
			<li>
				<p>
                    The 
					<strong>
                        STDGL
					</strong>
                    &nbsp;pragma is used to reserve pragmas for use by future revisions of this language. No implementation may use a pragma whose first token is 
					<strong>
                        STDGL
					</strong>
                    .
				</p>
<pre><code class="language-glsl" data-lang="glsl"> #pragma STDGL
</code></pre>
			</li>
			<li>
				<p>
                    Can be used to turn off optimizations as an aid in developing and debugging shaders. It can only be used outside function definitions. By default, optimization is turned on for all shaders.
				</p>
<pre><code class="language-glsl" data-lang="glsl"> #pragma optimize(on)
 #pragma optimize(off)
</code></pre>
			</li>
			<li>
				<p>
                    Can be used to enable compiling and annotating a shader with debug information, so that it can be used with a debugger. It can only be used outside function definitions. By default, debug is turned off.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #pragma debug(on)
 #pragma debug(off)
</code></pre>
	</li>
	<li>
		<p>
            <code>#version</code>
		</p>
		<ul>
			<li>
				<p>
                    Shaders should declare the version of the language they are written to.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #version number profile_opt
</code></pre>
		<ul>
			<li>
				<p>
                    Profile arguments:
				</p>
<pre><code class="language-glsl" data-lang="glsl"> core
 compatibility
 es
</code></pre>
				<ul>
					<li>
						<p>
                            The default is 
							<strong>
                                core
							</strong>
                            , if none is provided.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>#error</code>
		</p>
		<ul>
			<li>
				<p>
                    will cause the implementation to put a compile-time diagnostic message into the shader object’s information log (see section 7.12 “Shader, Program and Program Pipeline Queries” of the 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/references.html#references" 
						class="external-link" 
						target="_blank" >
                        OpenGL Specification
					</a>
                    &nbsp;for how to access a shader object’s information log). The message will be the tokens following the 
                    <code>#error</code>
                    &nbsp;directive, up to the first new-line. The implementation must treat the presence of a 
                    <code>#error</code>
                    &nbsp;directive as a compile-time error.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>defined</code>
		</p>
<pre><code class="language-go" data-lang="go"> defined identifier
 defined ( identifier )
</code></pre>
		<ul>
			<li>
				<p>
                    Two tokens in a macro can be concatenated into one token using the token pasting (
                    <code>##</code>
                    ) operator, as is standard for C++ preprocessors.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>#extension</code>
		</p>
		<ul>
			<li>
				<p>
                    Directives to control the behavior of the compiler with respect to extensions are declared with:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #extension extension_name : behavior
 #extension all : behavior
</code></pre>
		<ul>
			<li>
				<p>
                    where 
					<em>
                        extension_name
					</em>
                    &nbsp;is the name of an extension. Extension names are not documented in this specification. The token 
					<strong>
                        all
					</strong>
                    &nbsp;means the behavior applies to all extensions supported by the compiler.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="predefined-macros" >
    Predefined macros
</h5>
<ul>
	<li>
		<p>
            All macro names containing two consecutive underscores (
            <code>__</code>
            ) are reserved for use by underlying software layers. Defining or undefining such a name in a shader does not itself result in an error, but may result in unintended behaviors that stem from having multiple definitions of the same name.
		</p>
		<ul>
			<li>
				<p>
                    <code>__LINE__</code>
				</p>
				<ul>
					<li>
						<p>
                            Will substitute a decimal integer constant that is one more than the number of preceding new-lines in the current source string.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>__FILE__</code>
				</p>
				<ul>
					<li>
						<p>
                            Will substitute a decimal integer constant that says which source string number is currently being processed.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>__VERSION__</code>
				</p>
				<ul>
					<li>
						<p>
                            Will substitute a decimal integer reflecting the version number of the OpenGL Shading Language. The version of the shading language described in this document will have 
                            <code>__VERSION__</code>
                            &nbsp;substitute the decimal integer 460.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            All macro names prefixed with 
            <code>GL_</code>
            &nbsp;are also reserved, and defining or undefining such a name results in a compile-time error.
		</p>
	</li>
</ul>
<h3
	id="basic-types" >
    Basic Types
</h3>
<h5
	id="transparent-types" >
    Transparent Types
</h5>
<p
	class="table" >
    | Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Meaning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | ----------- | ------------------------------------------------------------------ |
    <br>
    | 
	<strong>
        void
	</strong>
    &nbsp;&nbsp;&nbsp; | for functions that do not return a value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        bool
	</strong>
    &nbsp;&nbsp;&nbsp; | a conditional type, taking on values of true or false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        int
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| a signed integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        uint
	</strong>
    &nbsp;&nbsp;&nbsp; | an unsigned integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        float
	</strong>
    &nbsp;&nbsp;&nbsp;| a single-precision floating-point scalar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        double
	</strong>
    &nbsp; | a double-precision floating-point scalar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        vec2
	</strong>
    &nbsp;&nbsp;&nbsp; | a two-component single-precision floating-point vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        vec3
	</strong>
    &nbsp;&nbsp;&nbsp; | a three-component single-precision floating-point vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        vec4
	</strong>
    &nbsp;&nbsp;&nbsp; | a four-component single-precision floating-point vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        dvec2
	</strong>
    &nbsp;&nbsp;&nbsp;| a two-component double-precision floating-point vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        dvec3
	</strong>
    &nbsp;&nbsp;&nbsp;| a three-component double-precision floating-point vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        dvec4
	</strong>
    &nbsp;&nbsp;&nbsp;| a four-component double-precision floating-point vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        bvec2
	</strong>
    &nbsp;&nbsp;&nbsp;| a two-component Boolean vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        bvec3
	</strong>
    &nbsp;&nbsp;&nbsp;| a three-component Boolean vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        bvec4
	</strong>
    &nbsp;&nbsp;&nbsp;| a four-component Boolean vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        ivec2
	</strong>
    &nbsp;&nbsp;&nbsp;| a two-component signed integer vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        ivec3
	</strong>
    &nbsp;&nbsp;&nbsp;| a three-component signed integer vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        ivec4
	</strong>
    &nbsp;&nbsp;&nbsp;| a four-component signed integer vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        uvec2
	</strong>
    &nbsp;&nbsp;&nbsp;| a two-component unsigned integer vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        uvec3
	</strong>
    &nbsp;&nbsp;&nbsp;| a three-component unsigned integer vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        uvec4
	</strong>
    &nbsp;&nbsp;&nbsp;| a four-component unsigned integer vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        mat2
	</strong>
    &nbsp;&nbsp;&nbsp; | a 2 × 2 single-precision floating-point matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        mat3
	</strong>
    &nbsp;&nbsp;&nbsp; | a 3 × 3 single-precision floating-point matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        mat4
	</strong>
    &nbsp;&nbsp;&nbsp; | a 4 × 4 single-precision floating-point matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        mat2x2
	</strong>
    &nbsp; | same as a 
	<strong>
        mat2
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        mat2x3
	</strong>
    &nbsp; | a single-precision floating-point matrix with 2 columns and 3 rows |
    <br>
    | 
	<strong>
        mat2x4
	</strong>
    &nbsp; | a single-precision floating-point matrix with 2 columns and 4 rows |
    <br>
    | 
	<strong>
        mat3x2
	</strong>
    &nbsp; | a single-precision floating-point matrix with 3 columns and 2 rows |
    <br>
    | 
	<strong>
        mat3x3
	</strong>
    &nbsp; | same as a 
	<strong>
        mat3
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        mat3x4
	</strong>
    &nbsp; | a single-precision floating-point matrix with 3 columns and 4 rows |
    <br>
    | 
	<strong>
        mat4x2
	</strong>
    &nbsp; | a single-precision floating-point matrix with 4 columns and 2 rows |
    <br>
    | 
	<strong>
        mat4x3
	</strong>
    &nbsp; | a single-precision floating-point matrix with 4 columns and 3 rows |
    <br>
    | 
	<strong>
        mat4x4
	</strong>
    &nbsp; | same as a 
	<strong>
        mat4
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        dmat2
	</strong>
    &nbsp;&nbsp;&nbsp;| a 2 × 2 double-precision floating-point matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        dmat3
	</strong>
    &nbsp;&nbsp;&nbsp;| a 3 × 3 double-precision floating-point matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        dmat4
	</strong>
    &nbsp;&nbsp;&nbsp;| a 4 × 4 double-precision floating-point matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        dmat2x2
	</strong>
    &nbsp;| same as a 
	<strong>
        dmat2
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        dmat2x3
	</strong>
    &nbsp;| a double-precision floating-point matrix with 2 columns and 3 rows |
    <br>
    | 
	<strong>
        dmat2x4
	</strong>
    &nbsp;| a double-precision floating-point matrix with 2 columns and 4 rows |
    <br>
    | 
	<strong>
        dmat3x2
	</strong>
    &nbsp;| a double-precision floating-point matrix with 3 columns and 2 rows |
    <br>
    | 
	<strong>
        dmat3x3
	</strong>
    &nbsp;| same as a 
	<strong>
        dmat3
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        dmat3x4
	</strong>
    &nbsp;| a double-precision floating-point matrix with 3 columns and 4 rows |
    <br>
    | 
	<strong>
        dmat4x2
	</strong>
    &nbsp;| a double-precision floating-point matrix with 4 columns and 2 rows |
    <br>
    | 
	<strong>
        dmat4x3
	</strong>
    &nbsp;| a double-precision floating-point matrix with 4 columns and 3 rows |
    <br>
    | 
	<strong>
        dmat4x4
	</strong>
    &nbsp;| same as a 
	<strong>
        dmat4
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<h5
	id="floating-point-opaque-types" >
    Floating-Point Opaque Types
</h5>
<p>
    |Type|Meaning|
    <br>
    |---|---|
    <br>
    |
	<strong>
        sampler1D
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture1D
	</strong>
    &nbsp; 
    <br>
	<strong>
        image1D
	</strong>
    |a handle for accessing a 1D texture|
    <br>
    |
	<strong>
        sampler1DShadow
	</strong>
    |a handle for accessing a 1D depth texture with comparison|
    <br>
    |
	<strong>
        sampler1DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture1DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        image1DArray
	</strong>
    |a handle for accessing a 1D array texture|
    <br>
    |
	<strong>
        sampler1DArrayShadow
	</strong>
    |a handle for accessing a 1D array depth texture with comparison|
    <br>
    |
	<strong>
        sampler2D
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture2D
	</strong>
    &nbsp; 
    <br>
	<strong>
        image2D
	</strong>
    |a handle for accessing a 2D texture|
    <br>
    |
	<strong>
        sampler2DShadow
	</strong>
    |a handle for accessing a 2D depth texture with comparison|
    <br>
    |
	<strong>
        sampler2DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture2DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        image2DArray
	</strong>
    |a handle for accessing a 2D array texture|
    <br>
    |
	<strong>
        sampler2DArrayShadow
	</strong>
    |a handle for accessing a 2D array depth texture with comparison|
    <br>
    |
	<strong>
        sampler2DMS
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture2DMS
	</strong>
    &nbsp; 
    <br>
	<strong>
        image2DMS
	</strong>
    |a handle for accessing a 2D multisample texture|
    <br>
    |
	<strong>
        sampler2DMSArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture2DMSArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        image2DMSArray
	</strong>
    |a handle for accessing a 2D multisample array texture|
    <br>
    |
	<strong>
        sampler2DRect
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture2DRect
	</strong>
    &nbsp; 
    <br>
	<strong>
        image2DRect
	</strong>
    |a handle for accessing a rectangle texture|
    <br>
    |
	<strong>
        sampler2DRectShadow
	</strong>
    |a handle for accessing a rectangle texture with comparison|
    <br>
    |
	<strong>
        sampler3D
	</strong>
    &nbsp; 
    <br>
	<strong>
        texture3D
	</strong>
    &nbsp; 
    <br>
	<strong>
        image3D
	</strong>
    |a handle for accessing a 3D texture|
    <br>
    |
	<strong>
        samplerCube
	</strong>
    &nbsp; 
    <br>
	<strong>
        textureCube
	</strong>
    &nbsp; 
    <br>
	<strong>
        imageCube
	</strong>
    |a handle for accessing a cube mapped texture|
    <br>
    |
	<strong>
        samplerCubeShadow
	</strong>
    |a handle for accessing a cube map depth texture with comparison|
    <br>
    |
	<strong>
        samplerCubeArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        textureCubeArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        imageCubeArray
	</strong>
    |a handle for accessing a cube map array texture|
    <br>
    |
	<strong>
        samplerCubeArrayShadow
	</strong>
    |a handle for accessing a cube map array depth texture with comparison|
    <br>
    |
	<strong>
        samplerBuffer
	</strong>
    &nbsp; 
    <br>
	<strong>
        textureBuffer
	</strong>
    &nbsp; 
    <br>
	<strong>
        imageBuffer
	</strong>
    |a handle for accessing a buffer texture|
    <br>
    |
	<strong>
        subpassInput
	</strong>
    |a handle for accessing a floating-point subpass input|
    <br>
    |
	<strong>
        subpassInputMS
	</strong>
    |a handle for accessing a multi-sampled floating-point subpass input|
</p>
<h5
	id="signed-integer-opaque-types" >
    Signed Integer Opaque Types
</h5>
<p>
    |Type|Meaning|
    <br>
    |---|---|
    <br>
    |
	<strong>
        isampler1D
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture1D
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage1D
	</strong>
    |a handle for accessing an integer 1D texture|
    <br>
    |
	<strong>
        isampler1DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture1DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage1DArray
	</strong>
    |a handle for accessing an integer 1D array texture|
    <br>
    |
	<strong>
        isampler2D
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture2D
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage2D
	</strong>
    |a handle for accessing an integer 2D texture|
    <br>
    |
	<strong>
        isampler2DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture2DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage2DArray
	</strong>
    |a handle for accessing an integer 2D array texture|
    <br>
    |
	<strong>
        isampler2DMS
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture2DMS
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage2DMS
	</strong>
    |a handle for accessing an integer 2D multisample texture|
    <br>
    |
	<strong>
        isampler2DMSArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture2DMSArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage2DMSArray
	</strong>
    |a handle for accessing an integer 2D multisample array texture|
    <br>
    |
	<strong>
        isampler2DRect
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture2DRect
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage2DRect
	</strong>
    |a handle for accessing an integer 2D rectangle texture|
    <br>
    |
	<strong>
        isampler3D
	</strong>
    &nbsp; 
    <br>
	<strong>
        itexture3D
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimage3D
	</strong>
    |a handle for accessing an integer 3D texture|
    <br>
    |
	<strong>
        isamplerCube
	</strong>
    &nbsp; 
    <br>
	<strong>
        itextureCube
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimageCube
	</strong>
    |a handle for accessing an integer cube mapped texture|
    <br>
    |
	<strong>
        isamplerCubeArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        itextureCubeArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimageCubeArray
	</strong>
    |a handle for accessing an integer cube map array texture|
    <br>
    |
	<strong>
        isamplerBuffer
	</strong>
    &nbsp; 
    <br>
	<strong>
        itextureBuffer
	</strong>
    &nbsp; 
    <br>
	<strong>
        iimageBuffer
	</strong>
    |a handle for accessing an integer buffer texture|
    <br>
    |
	<strong>
        isubpassInput
	</strong>
    |a handle for accessing an integer subpass input|
    <br>
    |
	<strong>
        isubpassInputMS
	</strong>
    |a handle for accessing a multi-sampled integer subpass input|
</p>
<h5
	id="unsigned-integer-opaque-types" >
    Unsigned Integer Opaque Types
</h5>
<p
	class="table" >
    | Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Meaning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | ------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
    <br>
    | 
	<strong>
        usampler1D
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture1D
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage1D
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | a handle for accessing an unsigned integer 1D texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usampler1DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture1DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage1DArray
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| a handle for accessing an unsigned integer 1D array texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usampler2D
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture2D
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage2D
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | a handle for accessing an unsigned integer 2D texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usampler2DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture2DArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage2DArray
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| a handle for accessing an unsigned integer 2D array texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usampler2DMS
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture2DMS
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage2DMS
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | a handle for accessing an unsigned integer 2D multisample texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usampler2DMSArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture2DMSArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage2DMSArray
	</strong>
    &nbsp;| a handle for accessing an unsigned integer 2D multisample array texture |
    <br>
    | 
	<strong>
        usampler2DRect
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture2DRect
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage2DRect
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | a handle for accessing an unsigned integer rectangle texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        usampler3D
	</strong>
    &nbsp; 
    <br>
	<strong>
        utexture3D
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimage3D
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | a handle for accessing an unsigned integer 3D texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usamplerCube
	</strong>
    &nbsp; 
    <br>
	<strong>
        utextureCube
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimageCube
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | a handle for accessing an unsigned integer cube mapped texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        usamplerCubeArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        utextureCubeArray
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimageCubeArray
	</strong>
    &nbsp;| a handle for accessing an unsigned integer cube map array texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usamplerBuffer
	</strong>
    &nbsp; 
    <br>
	<strong>
        utextureBuffer
	</strong>
    &nbsp; 
    <br>
	<strong>
        uimageBuffer
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | a handle for accessing an unsigned integer buffer texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        atomic_uint
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| a handle for accessing an unsigned integer atomic counter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        usubpassInput
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| a handle for accessing an unsigned-integer subpass input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
	<strong>
        usubpassInputMS
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| a handle for accessing a multi-sampled unsigned-integer subpass input&nbsp;&nbsp; |
</p>
<h5
	id="sampler-opaque-types" >
    Sampler Opaque Types
</h5>
<p
	class="table" >
    | Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Meaning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | ----------------- | ------------------------------------------------------------------------------------- |
    <br>
    | 
	<strong>
        sampler
	</strong>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| a handle for accessing state describing how to sample a texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
	<strong>
        samplerShadow
	</strong>
    &nbsp;| a handle for accessing state describing how to sample a depth texture with comparison |
</p>
<h5
	id="pointers" >
    Pointers
</h5>
<ul>
	<li>
		<p>
            There are no pointer types.
		</p>
	</li>
</ul>
<h5
	id="integers" >
    Integers
</h5>
<ul>
	<li>
		<p>
            For OpenGL:
		</p>
		<ul>
			<li>
				<p>
                    unsigned integers have exactly 32 bits of precision.
				</p>
			</li>
			<li>
				<p>
                    signed integers use 32 bits, including a sign bit, in two’s complement form.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For Vulkan:
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        mediump
					</strong>
                    &nbsp;and 
					<strong>
                        lowp
					</strong>
                    &nbsp;integers are as defined by the SPIR-V 
					<strong>
                        RelaxedPrecision
					</strong>
                    &nbsp;decoration.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        highp
					</strong>
                    &nbsp;unsigned integers have exactly 32 bits of precision.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        highp
					</strong>
                    &nbsp;signed integers use 32 bits, including a sign bit, in two’s complement form.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="floats" >
    Floats
</h5>
<pre><code class="language-glsl" data-lang="glsl">float a, b = 1.5;&nbsp;&nbsp;&nbsp;&nbsp;// single-precision floating-point
double c, d = 2.0LF; // double-precision floating-point
</code></pre>
<ul>
	<li>
		<p>
            When the suffix 
            <code>lf</code>
            &nbsp;or 
            <code>LF</code>
            &nbsp;is present, the literal has type 
            <code>double</code>
            . Otherwise, the literal has type 
            <code>float</code>
            .
		</p>
	</li>
	<li>
		<p>
            A decimal point (
            <code>.</code>
            ) is not needed if the exponent part is present.
		</p>
	</li>
</ul>
<h5
	id="vectors" >
    Vectors
</h5>
<pre><code class="language-glsl" data-lang="glsl">vec2 texcoord1, texcoord2;
vec3 position;
vec4 myRGBA;
ivec2 textureLookup;
bvec3 less;
</code></pre>
<h5
	id="matrices" >
    Matrices
</h5>
<ul>
	<li>
		<p>
            Matrix types beginning with &quot;
            <code>mat</code>
            &quot; have single-precision components while matrix types beginning with &quot;
            <code>dmat</code>
            &quot; have double-precision components.
		</p>
	</li>
	<li>
		<p>
            The first number in the type is the number of 
			<strong>
                columns
			</strong>
            , the second is the number of 
			<strong>
                rows
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            If there is only one number, the matrix is square.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">mat2 mat2D;
mat3 optMatrix;
mat4 view, projection;
mat4x4 view; // an alternate way of declaring a mat4
mat3x2 m;&nbsp;&nbsp;&nbsp;&nbsp;// a matrix with 3 columns and 2 rows
dmat4 highPrecisionMVP;
dmat2x4 dm;
</code></pre>
<h5
	id="atomic-counters" >
    Atomic Counters
</h5>
<ul>
	<li>
		<p>
            OpenGL:
		</p>
		<ul>
			<li>
				<p>
                    Atomic counter types (e.g. 
					<strong>
                        atomic_uint
					</strong>
                    ) are opaque handles to counters, declared and behaving as described above for opaque types. The variables they declare specify which counter to access when using the built-in atomic counter functions as described in “
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/builtinfunctions.html#atomic-counter-functions" 
						class="external-link" 
						target="_blank" >
                        Atomic Counter Functions
					</a>
                    ”. They are bound to buffers as described in “
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#atomic-counter-layout-qualifiers" 
						class="external-link" 
						target="_blank" >
                        Atomic Counter Layout Qualifiers
					</a>
                    ”.
				</p>
			</li>
			<li>
				<p>
                    Members of structures cannot be declared as atomic counter types.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Vulkan:
		</p>
		<ul>
			<li>
				<p>
                    Atomic counter types are not available when targeting Vulkan.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="arrays" >
    Arrays
</h3>
<pre><code class="language-glsl" data-lang="glsl">float frequencies[3];

uniform vec4 lightPosition[4u];

light lights[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Unsized. Valid in GLSL, illegal in ESSL.

const int numLights = 2;
light lights[numLights];

vec4 a[3][2];

// a shader storage block, introduced in section 4.3.7 "Buffer Variables"
buffer b {
&nbsp;&nbsp;&nbsp;&nbsp;float u[]; // an error, unless u gets statically sized by link time
&nbsp;&nbsp;&nbsp;&nbsp;vec4 v[];&nbsp;&nbsp;// okay, v will be sized dynamically, if not statically
} name[3];&nbsp;&nbsp;&nbsp;&nbsp; // when the block is arrayed, all u will be the same size, but not necessarily all v, if sized dynamically
</code></pre>
<ul>
	<li>
		<p>
            Arrays only have a single dimension (a single number within “[ ]”), however, arrays of arrays can be declared.
		</p>
	</li>
	<li>
		<p>
            Any type can be formed into an array.
		</p>
	</li>
	<li>
		<p>
            All arrays are inherently homogeneous; made of elements all having the same type and size, with one exception. An array of shader storage blocks whose last member is a runtime-sized array allows the individual blocks to have different sizes and hence a different number of elements in the trailing array.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Explicitly Sized
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The number of elements in the array is explicitly given.
				</p>
			</li>
			<li>
				<p>
                    It is a compile-time error if:
				</p>
				<ul>
					<li>
						<p>
                            an explicitly sized array is indexed with a constant expression greater than or equal to the declared size.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Runtime Sized
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The number of elements is not given and the array is the outermost dimension of the last declared member of a shader storage block (see section “
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
						class="external-link" 
						target="_blank" >
                        Interface Blocks
					</a>
                    ”). The array size is inferred at run-time from the size of the data store backing the shader storage block.
				</p>
			</li>
			<li>
				<p>
                    It is a compile-time error if:
				</p>
				<ul>
					<li>
						<p>
                            a runtime array is passed as a function argument.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Unsized
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    The number of array elements is not given and the array is not runtime sized.
				</p>
			</li>
			<li>
				<p>
                    Unsized arrays may become explicitly sized following either an explicitly-sized initializer or a redeclaration with an explicit size (Explicitly-sized and runtime-sized arrays may not be redeclared). It is a compile-time error to redeclare an array with a different underlying member type.
				</p>
			</li>
			<li>
				<p>
                    It is a compile-time error if:
				</p>
				<ul>
					<li>
						<p>
                            an unsized array is indexed with anything other than a constant integral expression.
						</p>
					</li>
					<li>
						<p>
                            an unsized array is declared as a formal parameter to a function.
						</p>
					</li>
					<li>
						<p>
                            an unsized array is declared as the return type of a function.
						</p>
					</li>
					<li>
						<p>
                            an unsized array is passed as a function argument.
						</p>
					</li>
					<li>
						<p>
                            an unsized array is redeclared with a size less than or equal to any constant index used earlier in the shader to index the array.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Undefined behavior results from indexing an array with a non-constant expression that’s greater than or equal to the array’s size or less than 0.
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to assign either to or from a runtime-sized or unsized array (rather than specific elements). Note, this is a rare case that initializers and assignments appear to have different semantics. An initializer for an unsized array is valid and will size the array, but the equivalent assigment is not valid. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float a[5];
float b[];
// An initializer sizes an array ...
float c[] = a;&nbsp;&nbsp;// c is explicitly size 5
// ... but the equivalent assignment is not valid
float d[];
d = a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error. Assignment to an unsized array
// It is never valid to assign from an unsized array
float e[] = b;&nbsp;&nbsp;// Error. b is unsized so cannot be assigned
</code></pre>
<ul>
	<li>
		<p>
            Alternatively, the initializer-list syntax can be used to initialize an array of arrays:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec4[2](vec4(0.0), vec4(1.0)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec4[2](vec4(0.0), vec4(1.0)) };
</code></pre>
<ul>
	<li>
		<p>
            For arrays of arrays, any unsized dimension is explicitly sized by the initializer:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec4[2](vec4(0.0), vec4(1.0)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec4[2](vec4(0.0), vec4(1.0)) };
</code></pre>
<h5
	id="array-type" >
    Array Type
</h5>
<ul>
	<li>
		<p>
            An array type can be formed by specifying a non-array type
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float[5]&nbsp;&nbsp;&nbsp;&nbsp;// an array of size [5] of float
float[2][3] // an array of size [2] of array of size [3] of float,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// not size [3] of float[2]
</code></pre>
<ul>
	<li>
		<p>
            Such an array type can be used anywhere any other type can be used, including as the return value from a function, as a constructor of an array and in declarations.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// As a function return type
float[5] foo() { }
// As an array constructor
float[5](3.4, 4.2, 5.0, 5.2, 1.1)
// In declaring an unnamed parameter
void foo(float[5])
// In normal declarations
float[5] a;

// The following 3 declarations are equivalent:
vec4 a[3][2]; // size-3 array of size-2 array of vec4
vec4[2] a[3];
vec4[3][2] a;
</code></pre>
<ul>
	<li>
		<p>
            If such an array type is unsized and used as a constructor then the size of the array is inferred from the constructor arguments. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);
float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);&nbsp;&nbsp;// Constructor also of type float[5]
</code></pre>
<h5
	id="length-method" >
    Length Method
</h5>
<ul>
	<li>
		<p>
            The return value has type 
            <code>int</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">float a[5];
a.length(); // returns 5

vec4 a[3][2];
a.length()&nbsp;&nbsp;&nbsp;&nbsp;// returns 3
a[x].length() // returns 2
</code></pre>
<ul>
	<li>
		<p>
            It is a compile-time error to use the 
            <code>length()</code>
            &nbsp;method on an unsized array. The return value is a constant expression if and only if the array is explicitly-sized.
		</p>
	</li>
</ul>
<h3
	id="structs" >
    Structs
</h3>
<pre><code class="language-glsl" data-lang="glsl">struct light {
&nbsp;&nbsp;&nbsp;&nbsp;float intensity;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 position;
} lightVar;
</code></pre>
<ul>
	<li>
		<p>
            In this example, 
            <code>light</code>
            &nbsp;becomes the name of the new type, and 
            <code>lightVar</code>
            &nbsp;becomes a variable of type 
            <code>light</code>
            .
		</p>
	</li>
	<li>
		<p>
            To declare variables of the new type, use its name (without the keyword 
            <code>struct</code>
            ).
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">light lightVar2;
</code></pre>
<ul>
	<li>
		<p>
            Comptime errors:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">struct S { float f; }; // Allowed: S is defined as a structure.

struct T {
&nbsp;&nbsp;&nbsp;&nbsp;S;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error: anonymous structures disallowed
&nbsp;&nbsp;&nbsp;&nbsp;struct { ... }; // Error: embedded structures disallowed
&nbsp;&nbsp;&nbsp;&nbsp;S s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Allowed: nested structure with a name.
};
</code></pre>
<h3
	id="functions" >
    Functions
</h3>
<ul>
	<li>
		<p>
            Functions that do not return a value must be declared as 
            <code>void</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    There is no default function return type.
				</p>
			</li>
			<li>
				<p>
                    The keyword 
                    <code>void</code>
                    &nbsp;cannot be used in any other declarations (except for empty formal or actual parameter lists), or a compile-time error results.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="storage-qualifiers" >
    Storage Qualifiers
</h2>
<ul>
	<li>
		<p>
            Local variables can only use the 
			<strong>
                const
			</strong>
            &nbsp;storage qualifier (or use no storage qualifier).
		</p>
	</li>
	<li>
		<p>
            Note that function parameters can use 
			<strong>
                const
			</strong>
            , 
			<strong>
                in
			</strong>
            , and 
			<strong>
                out
			</strong>
            &nbsp;qualifiers, but as 
			<em>
                parameter qualifiers
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Function return types and structure members do not use storage qualifiers.
		</p>
	</li>
	<li>
		<p>
            Initializers in global declarations may only be used in declarations of global variables with no storage qualifier, with a 
			<strong>
                const
			</strong>
            &nbsp;qualifier, or with a 
			<strong>
                uniform
			</strong>
            &nbsp;qualifier. Global variables without storage qualifiers that are not initialized in their declaration or by the application will not be initialized, but rather will enter 
			<em>
                main()
			</em>
            &nbsp;with undefined values.
		</p>
	</li>
</ul>
<h5
	id="ltnone-defaultgt" >
    &lt;none: default&gt;
</h5>
<ul>
	<li>
		<p>
            If no qualifier is present on a global variable, then the variable has no linkage to the application or shaders running on other pipeline stages.
		</p>
	</li>
	<li>
		<p>
            For either global or local unqualified variables, the declaration will appear to allocate memory associated with the processor it targets.
		</p>
	</li>
	<li>
		<p>
            This variable will provide read/write access to this allocated memory.
		</p>
	</li>
</ul>
<h5
	id="const" >
    const
</h5>
<ul>
	<li>
		<p>
            a variable whose value cannot be changed.
		</p>
	</li>
	<li>
		<p>
            Named compile-time constants or read-only variables can be declared using the 
			<strong>
                const
			</strong>
            &nbsp;qualifier. The 
			<strong>
                const
			</strong>
            &nbsp;qualifier can be used with any of the non-void transparent basic data types, as well as with structures and arrays of these. It is a compile-time error to write to a 
			<strong>
                const
			</strong>
            &nbsp;variable outside of its declaration, so they must be initialized when declared. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">const vec3 zAxis = vec3 (0.0, 0.0, 1.0);
const float ceiling = a + b; // a and b not necessarily constants
</code></pre>
<ul>
	<li>
		<p>
            Structure members may not be qualified with 
			<strong>
                const
			</strong>
            . Structure variables can be declared as 
			<strong>
                const
			</strong>
            , and initialized with a structure constructor or initializer.
		</p>
	</li>
	<li>
		<p>
            Initializers for 
			<strong>
                const
			</strong>
            &nbsp;declarations at global scope must be constant expressions
		</p>
	</li>
	<li>
		<p>
			<strong>
                Constant Expressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    SPIR-V specialization constants are expressed in GLSL as 
					<strong>
                        const
					</strong>
                    &nbsp;with the layout qualifier 
					<strong>
                        constant_id
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        constant expression
					</em>
                    &nbsp;is one of
				</p>
				<ul>
					<li>
						<p>
                            A literal value (e.g. 
							<strong>
                                5
							</strong>
                            &nbsp;or 
							<strong>
                                true
							</strong>
                            ).
						</p>
					</li>
					<li>
						<p>
                            A variable declared with the 
							<strong>
                                const
							</strong>
                            &nbsp;qualifier and an initializer, where the initializer is a constant expression. This includes both 
							<strong>
                                const
							</strong>
                            &nbsp;declared with a specialization-constant layout qualifier, e.g. 
							<strong>
                                layout
							</strong>
                            (
							<strong>
                                constant_id
							</strong>
                            &nbsp;= …​), and those declared without a specialization-constant layout qualifier.
						</p>
					</li>
					<li>
						<p>
                            Built-in variables qualified as 
							<strong>
                                const
							</strong>
                            .
						</p>
					</li>
					<li>
						<p>
                            An expression formed by an operator on operands that are all constant expressions, including getting an element of a constant array, or a member of a constant structure, or components of a constant vector. However, the lowest precedence operators of the sequence operator (
							<strong>
                                ,
							</strong>
                            ) and the assignment operators (
							<strong>
                                =
							</strong>
                            , 
							<strong>
                                +=
							</strong>
                            , 
							<strong>
                                …​
							</strong>
                            ) are not included in the operators that can create a constant expression. Also, an array access with a specialization constant as an index does not result in a constant expression.
						</p>
					</li>
					<li>
						<p>
                            Valid use of the 
							<strong>
                                length
							</strong>
                            () method on an explicitly sized object, whether or not the object itself is constant (implicitly sized or run-time sized arrays do not return a constant expression).
						</p>
					</li>
					<li>
						<p>
                            A constructor whose arguments are all constant expressions.
						</p>
					</li>
					<li>
						<p>
                            For non-specialization constants only: The value returned by certain built-in function calls whose arguments are all constant expressions, including at least the list below. Any other built-in function that does not access memory (not the texture lookup functions, image access, atomic counter, etc.), that has a non-
							<strong>
                                void
							</strong>
                            &nbsp;return type, that has no 
							<strong>
                                out
							</strong>
                            &nbsp;parameter, and is not a noise function might also be considered a constant. When a function is called with an argument that is a specialization constant, the result is not a constant expression.
						</p>
						<ul>
							<li>
								<p>
                                    Angle and Trigonometric Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                radians
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                degrees
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                sin
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                cos
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                asin
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                acos
											</strong>
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Exponential Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                pow
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                exp
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                log
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                exp2
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                log2
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                sqrt
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                inversesqrt
											</strong>
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Common Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                abs
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                sign
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                floor
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                trunc
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                round
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                ceil
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                mod
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                min
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                max
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                clamp
											</strong>
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Geometric Functions
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                length
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                dot
											</strong>
										</p>
									</li>
									<li>
										<p>
											<strong>
                                                normalize
											</strong>
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Function calls to user-defined functions (non-built-in functions) cannot be used to form constant expressions.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    A 
					<em>
                        constant integral expression
					</em>
                    &nbsp;is a constant expression that evaluates to a scalar signed or unsigned integer.
				</p>
			</li>
			<li>
				<p>
                    Constant expressions will be evaluated in an invariant way so as to create the same value in multiple shaders when the same constant expressions appear in those shaders.
				</p>
			</li>
			<li>
				<p>
                    Constant expressions respect the 
					<strong>
                        precise
					</strong>
                    &nbsp;and 
					<strong>
                        invariant
					</strong>
                    &nbsp;qualifiers but will be always be evaluated in an invariant way, independent of the use of such qualification, so as to create the same value in multiple shaders when the same constant expressions appear in those shaders.
				</p>
			</li>
			<li>
				<p>
                    Constant-expressions may be evaluated by a host platform, and are therefore not required to compute the same value that the same expression would evaluate to on the shader execution target. However, the host must use the same or greater precision than the target would use. When the precision qualification cannot be determined, the expression is evaluated at 
					<strong>
                        highp
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    Specialization-constant expressions are never evaluated by the compiler front end, but instead retain the expression’s operations needed to evaluate them later on the host.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="in" >
    in
</h5>
<ul>
	<li>
		<p>
            linkage into a shader from a previous stage, variable is copied in.
		</p>
	</li>
	<li>
		<p>
            Shader input variables are declared with the 
			<strong>
                in
			</strong>
            &nbsp;storage qualifier. They form the input interface between previous stages of the API pipeline and the declaring shader. Input variables must be declared at global scope. Values from the previous pipeline stage are copied into input variables at the beginning of shader execution. It is a compile-time error to write to a variable declared as an input.
		</p>
	</li>
	<li>
		<p>
            Only the input variables that are statically read need to be written by the previous stage; it is allowed to have superfluous declarations of input variables. This is shown in the following table.
		</p>
	</li>
</ul>
<p
	class="table" >
    |&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp; |
    <br>
    |---|---|---|---|---|
    <br>
    |Treatment of Mismatched Input Variables|&nbsp;&nbsp; |Consuming Shader (input variables)|&nbsp;&nbsp; |&nbsp;&nbsp; |
    <br>
    |No Declaration|Declared but no Static Use|Declared and Static Use|
    <br>
    |Generating Shader (output variables)|No Declaration|Allowed|Allowed|Link-Time Error|
    <br>
    |Declared but no Static Use|Allowed|Allowed|Allowed (values are undefined)|
    <br>
    |Declared and Static Use|Allowed|Allowed|Allowed (values are potentially undefined)|
</p>
<ul>
	<li>
		<p>
            Consumption errors are based on static use only. Compilation may generate a warning, but not an error, for any dynamic use the compiler can deduce that might cause consumption of undefined values.
		</p>
	</li>
	<li>
		<p>
            See “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/builtins.html#built-in-variables" 
				class="external-link" 
				target="_blank" >
                Built-In Variables
			</a>
            ” for a list of the built-in input names.
		</p>
	</li>
	<li>
		<p>
            Vertex shader input variables (or attributes) receive per-vertex data. It is a compile-time error to use auxiliary storage or interpolation qualifiers on a vertex shader input. The values copied in are established by the API or through the use of the layout identifier 
			<strong>
                location
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a vertex shader input with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
			<li>
				<p>
                    A structure
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Example declarations in a vertex shader:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in vec4 position;
in vec3 normal;
in vec2 texCoord[4];
</code></pre>
<ul>
	<li>
		<p>
            It is expected that graphics hardware will have a small number of fixed vector locations for passing vertex inputs. Therefore, the OpenGL Shading Language defines each non-matrix input variable as taking up one such vector location. There is an implementation-dependent limit on the number of locations that can be used, and if this is exceeded it will cause a link-time error. (Declared input variables that are not statically used do not count against this limit.) A scalar input counts the same amount against this limit as a 
			<strong>
                vec4
			</strong>
            , so applications may want to consider packing groups of four unrelated float inputs together into a vector to better utilize the capabilities of the underlying hardware. A matrix input will use up multiple locations. The number of locations used will equal the number of columns in the matrix.
		</p>
	</li>
	<li>
		<p>
            Tessellation control, evaluation, and geometry shader input variables get the per-vertex values written out by output variables of the same names in the previous active shader stage. For these inputs, 
			<strong>
                centroid
			</strong>
            &nbsp;and interpolation qualifiers are allowed, but have no effect. Since tessellation control, tessellation evaluation, and geometry shaders operate on a set of vertices, each input variable (or input block, see 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            &nbsp;below) needs to be declared as an array. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in float foo[]; // geometry shader input for vertex "out float foo"
</code></pre>
<ul>
	<li>
		<p>
            Each element of such an array corresponds to one vertex of the primitive being processed. Each array can optionally have a size declared. For geometry shaders, the array size will be set by, (or if provided must be consistent with) the input 
			<strong>
                layout
			</strong>
            &nbsp;declaration(s) establishing the type of input primitive, as described later in “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#input-layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                Input Layout Qualifiers
			</a>
            ”.
		</p>
	</li>
	<li>
		<p>
            Some inputs and outputs are 
			<em>
                arrayed
			</em>
            , meaning that for an interface between two shader stages either the input or output declaration requires an extra level of array indexing for the declarations to match. For example, with the interface between a vertex shader and a geometry shader, vertex shader output variables and geometry shader input variables of the same name must have matching types, except that the geometry shader will have one more array dimension than the vertex shader, to allow for vertex indexing. If such an arrayed interface variable is not declared with the necessary additional input or output array dimension, a link-time error will result. Geometry shader inputs, tessellation control shader inputs and outputs, and tessellation evaluation inputs all have an additional level of arrayness relative to other shader inputs and outputs. These inputs and outputs are known as 
			<em>
                per-vertex-arrayed
			</em>
            &nbsp;inputs and outputs. Component limits for arrayed interfaces (e.g. 
			<em>
                gl_MaxTessControlInputComponents
			</em>
            ) are limits per vertex, not limits for the entire interface.
		</p>
	</li>
	<li>
		<p>
            For non-arrayed interfaces (meaning array dimensionally stays the same between stages), it is a link-time error if the input variable is not declared with the same type, including array dimensionality, as the matching output variable.
		</p>
	</li>
	<li>
		<p>
            The link-time type-matching rules apply to all declared input and output variables, whether or not they are used.
		</p>
	</li>
	<li>
		<p>
            Additionally, tessellation evaluation shaders support per-patch input variables declared with the 
			<strong>
                patch
			</strong>
            &nbsp;and 
			<strong>
                in
			</strong>
            &nbsp;qualifiers. Per-patch input variables are filled with the values of per-patch output variables written by the tessellation control shader. Per-patch inputs may be declared as one-dimensional arrays, but are not indexed by vertex number. Applying the 
			<strong>
                patch
			</strong>
            &nbsp;qualifier to inputs can only be done in tessellation evaluation shaders. As with other input variables, per-patch inputs must be declared using the same type and qualification as per-patch outputs from the previous (tessellation control) shader stage. It is a compile-time error to use 
			<strong>
                patch
			</strong>
            &nbsp;with inputs in any other stage.
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a tessellation control, tessellation evaluation or geometry shader input with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Fragment shader inputs get per-fragment values, typically interpolated from a previous stage’s outputs. The auxiliary storage qualifiers 
			<strong>
                centroid
			</strong>
            &nbsp;and 
			<strong>
                sample
			</strong>
            &nbsp;can also be applied, as well as the interpolation qualifiers 
			<strong>
                flat
			</strong>
            , 
			<strong>
                noperspective
			</strong>
            , and 
			<strong>
                smooth.
			</strong>
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a fragment shader input with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Fragment shader inputs that are, or contain, integral or double-precision floating-point types must be qualified with the interpolation qualifier 
			<strong>
                flat
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            Fragment inputs are declared as in the following examples:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in vec3 normal;
centroid in vec2 TexCoord;
noperspective in float temperature;
flat in vec3 myColor;
noperspective centroid in vec2 myTexCoord;
</code></pre>
<ul>
	<li>
		<p>
            The fragment shader inputs form an interface with the last active shader in the vertex processing pipeline. For this interface, the last active shader stage output variables and fragment shader input variables of the same name must match in type and qualification, with a few exceptions: The storage qualifiers must, of course, differ (one is 
			<strong>
                in
			</strong>
            &nbsp;and one is 
			<strong>
                out
			</strong>
            ). Also, interpolation qualification (e.g. 
			<strong>
                flat
			</strong>
            ) and auxiliary qualification (e.g. 
			<strong>
                centroid
			</strong>
            ) may differ. These mismatches are allowed between any pair of stages. When interpolation or auxiliary qualifiers do not match, those provided in the fragment shader supersede those provided in previous stages. If any such qualifiers are completely missing in the fragment shaders, then the default is used, rather than any qualifiers that may have been declared in previous stages. That is, what matters is what is declared in the fragment shaders, not what is declared in shaders in previous stages.
		</p>
	</li>
	<li>
		<p>
            When an interface between shader stages is formed using shaders from two separate program objects, it is not possible to detect mismatches between inputs and outputs when the programs are linked. When there are mismatches between inputs and outputs on such interfaces, the values passed across the interface will be partially or completely undefined.
		</p>
	</li>
	<li>
		<p>
            Shaders can ensure matches across such interfaces either by using input and output layout qualifiers (sections “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#input-layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                Input Layout Qualifiers
			</a>
            ” and “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#output-layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                Output Layout Qualifiers
			</a>
            ”) or by using identical input and output declarations of blocks or variables. Complete rules for interface matching are found in section 7.4.1 “Shader Interface Matching” of the 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/references.html#references" 
				class="external-link" 
				target="_blank" >
                OpenGL Specification
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Compute shaders do not permit user-defined input variables and do not form a formal interface with any other shader stage. See “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/builtins.html#compute-shader-special-variables" 
				class="external-link" 
				target="_blank" >
                Compute Shader Special Variables
			</a>
            ” for a description of built-in compute shader input variables. All other input to a compute shader is retrieved explicitly through image loads, texture fetches, loads from uniforms or uniform buffers, or other user supplied code. Redeclaration of built-in input variables in compute shaders is not permitted.
		</p>
	</li>
</ul>
<h5
	id="out" >
    out
</h5>
<ul>
	<li>
		<p>
            linkage out of a shader to a subsequent stage, variable is copied out.
		</p>
	</li>
	<li>
		<p>
            Shader output variables are declared with the 
			<strong>
                out
			</strong>
            &nbsp;storage qualifier. They form the output interface between the declaring shader and the subsequent stages of the API pipeline. Output variables must be declared at global scope. During shader execution they will behave as normal unqualified global variables. Their values are copied out to the subsequent pipeline stage on shader exit. Only output variables that are read by the subsequent pipeline stage need to be written; it is allowed to have superfluous declarations of output variables.
		</p>
	</li>
	<li>
		<p>
            There is 
			<em>
                not
			</em>
            &nbsp;an 
			<strong>
                inout
			</strong>
            &nbsp;storage qualifier for declaring a single variable name as both input and output to a shader. Also, a variable cannot be declared with both the 
			<strong>
                in
			</strong>
            &nbsp;and the 
			<strong>
                out
			</strong>
            &nbsp;qualifiers, this will result in a compile-time or link-time error. Output variables must be declared with different names than input variables. However, nesting an input or output inside an interface block with an instance name allows the same names with one referenced through a block instance name.
		</p>
	</li>
	<li>
		<p>
            Vertex, tessellation evaluation, and geometry output variables output per-vertex data and are declared using the 
			<strong>
                out
			</strong>
            &nbsp;storage qualifier. Applying 
			<strong>
                patch
			</strong>
            &nbsp;to an output can only be done in a tessellation control shader. It is a compile-time error to use 
			<strong>
                patch
			</strong>
            &nbsp;on outputs in any other stage.
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to declare a vertex, tessellation evaluation, tessellation control, or geometry shader output with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Individual outputs are declared as in the following examples:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out vec3 normal;
centroid out vec2 TexCoord;
invariant centroid out vec4 Color;
flat out vec3 myColor;
sample out vec4 perSampleColor;
</code></pre>
<ul>
	<li>
		<p>
            These can also appear in interface blocks, as described in “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            ”. Interface blocks allow simpler addition of arrays to the interface from vertex to geometry shader. They also allow a fragment shader to have the same input interface as a geometry shader for a given vertex shader.
		</p>
	</li>
	<li>
		<p>
            Tessellation control shader output variables are used to output per-vertex and per-patch data. Per-vertex output variables are arrayed (see 
			<em>
                arrayed
			</em>
            &nbsp;under “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#input-variables" 
				class="external-link" 
				target="_blank" >
                Input Variables
			</a>
            ”) and declared using the 
			<strong>
                out
			</strong>
            &nbsp;qualifier without the 
			<strong>
                patch
			</strong>
            &nbsp;qualifier. Per-patch output variables are declared using the 
			<strong>
                patch
			</strong>
            &nbsp;and 
			<strong>
                out
			</strong>
            &nbsp;qualifiers.
		</p>
	</li>
	<li>
		<p>
            Since tessellation control shaders produce an arrayed primitive comprising multiple vertices, each per-vertex output variable (or output block, see 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            &nbsp;below) needs to be declared as an array. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out float foo[]; // feeds next stage input "in float foo[]"
</code></pre>
<ul>
	<li>
		<p>
            Each element of such an array corresponds to one vertex of the primitive being produced. Each array can optionally have a size declared. The array size will be set by (or if provided must be consistent with) the output layout declaration(s) establishing the number of vertices in the output patch, as described later in “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#tessellation-control-outputs" 
				class="external-link" 
				target="_blank" >
                Tessellation Control Outputs
			</a>
            ”.
		</p>
	</li>
	<li>
		<p>
            Each tessellation control shader invocation has a corresponding output patch vertex, and may assign values to per-vertex outputs only if they belong to that corresponding vertex. If a per-vertex output variable is used as an l-value, it is a compile-time or link-time error if the expression indicating the vertex index is not the identifier 
			<em>
                gl_InvocationID
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            The order of execution of a tessellation control shader invocation relative to the other invocations for the same input patch is undefined unless the built-in function 
			<strong>
                barrier
			</strong>
            () is used. This provides some control over relative execution order. When a shader invocation calls 
			<strong>
                barrier
			</strong>
            (), its execution pauses until all other invocations have reached the same point of execution. Output variable assignments performed by any invocation executed prior to calling 
			<strong>
                barrier
			</strong>
            () will be visible to any other invocation after the call to 
			<strong>
                barrier
			</strong>
            () returns.
		</p>
	</li>
	<li>
		<p>
            Because tessellation control shader invocations execute in undefined order between barriers, the values of per-vertex or per-patch output variables will sometimes be undefined. Consider the beginning and end of shader execution and each call to 
			<strong>
                barrier
			</strong>
            () as synchronization points. The value of an output variable will be undefined in any of the three following cases:
		</p>
		<ol>
			<li>
				<p>
                    At the beginning of execution.
				</p>
			</li>
			<li>
				<p>
                    At each synchronization point, unless
				</p>
				<ul>
					<li>
						<p>
                            the value was well-defined after the previous synchronization point and was not written by any invocation since, or
						</p>
					</li>
					<li>
						<p>
                            the value was written by exactly one shader invocation since the previous synchronization point, or
						</p>
					</li>
					<li>
						<p>
                            the value was written by multiple shader invocations since the previous synchronization point, and the last write performed by all such invocations wrote the same value.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    When read by a shader invocation, if
				</p>
				<ul>
					<li>
						<p>
                            the value was undefined at the previous synchronization point and has not been written by the same shader invocation since, or
						</p>
					</li>
					<li>
						<p>
                            the output variable is written to by any other shader invocation between the previous and next synchronization points, even if that assignment occurs in code following the read.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
            Fragment outputs output per-fragment data and are declared using the 
			<strong>
                out
			</strong>
            &nbsp;storage qualifier. It is a compile-time error to use auxiliary storage qualifiers or interpolation qualifiers in a fragment shader output declaration. It is a compile-time error to declare a fragment shader output with, or that contains, any of the following types:
		</p>
		<ul>
			<li>
				<p>
                    A 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#booleans" 
						class="external-link" 
						target="_blank" >
                        boolean type
					</a>
				</p>
			</li>
			<li>
				<p>
                    A double-precision scalar or vector (
					<strong>
                        double
					</strong>
                    , 
					<strong>
                        dvec2
					</strong>
                    , 
					<strong>
                        dvec3
					</strong>
                    , 
					<strong>
                        dvec4
					</strong>
                    )
				</p>
			</li>
			<li>
				<p>
                    An 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#opaque-types" 
						class="external-link" 
						target="_blank" >
                        opaque type
					</a>
				</p>
			</li>
			<li>
				<p>
                    A matrix type
				</p>
			</li>
			<li>
				<p>
                    A structure
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Fragment outputs are declared as in the following examples:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out vec4 FragmentColor;
out uint Luminosity;
</code></pre>
<ul>
	<li>
		<p>
            Compute shaders have no built-in output variables, do not support user-defined output variables and do not form a formal interface with any other shader stage. All outputs from a compute shader take the form of the side effects such as image stores and operations on atomic counters.
		</p>
	</li>
</ul>
<h5
	id="attribute" >
    attribute
</h5>
<ul>
	<li>
		<p>
            compatibility profile only and vertex language only; same as in when in a vertex shader
		</p>
	</li>
</ul>
<h5
	id="uniform" >
    uniform
</h5>
<ul>
	<li>
		<p>
            value does not change across the primitive being processed, uniforms form the linkage between a shader, API, and the application.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                uniform
			</strong>
            &nbsp;qualifier is used to declare global variables whose values are the same across the entire primitive being processed. All 
			<strong>
                uniform
			</strong>
            &nbsp;variables are read-only and are initialized externally either at link time or through the API. The link-time initial value is either the value of the variable’s initializer, if present, or 0 if no initializer is present. Opaque types cannot have initializers, or a compile-time error results. When targeting Vulkan, it is a compile-time error to declare 
			<strong>
                uniform
			</strong>
            &nbsp;variables outside a block.
		</p>
	</li>
	<li>
		<p>
            Example declarations are:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">uniform vec4 lightPosition;
uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time
</code></pre>
<ul>
	<li>
		<p>
            The 
			<strong>
                uniform
			</strong>
            &nbsp;qualifier can be used with any of the basic data types, or when declaring a variable whose type is a structure, or an array of any of these.
		</p>
	</li>
	<li>
		<p>
            There is an implementation-dependent limit on the amount of storage for uniforms that can be used for each type of shader and if this is exceeded it will cause a compile-time or link-time error. Uniform variables that are declared but not used do not count against this limit. The number of user-defined uniform variables and the number of built-in uniform variables that are used within a shader are added together to determine whether available uniform storage has been exceeded.
		</p>
	</li>
	<li>
		<p>
            Uniforms in shaders all share a single global name space when linked into a program or separable program. Hence, the types, initializers, and any location specifiers of all statically used uniform variables with the same name must match across all shaders that are linked into a single program. However it is not required to repeat the initializer or location specifier in all the linked shaders. While this single uniform name space is cross stage, a uniform variable name’s scope is per stage: If a uniform variable name is declared in one stage (e.g. a vertex shader) but not in another (e.g. a fragment shader), then that name is still available in the other stage for a different use.
		</p>
	</li>
</ul>
<h5
	id="varying" >
    varying
</h5>
<ul>
	<li>
		<p>
            compatibility profile only and vertex and fragment languages only; same as out when in a vertex shader and same as in when in a fragment shader
		</p>
	</li>
</ul>
<h5
	id="buffer" >
    buffer
</h5>
<ul>
	<li>
		<p>
            value is stored in a buffer object, and can be read or written both by shader invocations and the API.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                buffer
			</strong>
            &nbsp;qualifier is used to declare global variables whose values are stored in the data store of a buffer object bound through the API. Buffer variables can be read and written, with the underlying storage shared among all active shader invocations. Buffer variable memory reads and writes within a single shader invocation are processed in order. However, the order of reads and writes performed in one invocation relative to those performed by another invocation is largely undefined. Buffer variables may be qualified with memory qualifiers affecting how the underlying memory is accessed, as described in “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#memory-qualifiers" 
				class="external-link" 
				target="_blank" >
                Memory Qualifiers
			</a>
            ”.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                buffer
			</strong>
            &nbsp;qualifier can be used to declare interface blocks (see “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#interface-blocks" 
				class="external-link" 
				target="_blank" >
                Interface Blocks
			</a>
            ”), which are then referred to as shader storage blocks. It is a compile-time error to declare buffer variables outside a block.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// use buffer to create a buffer block (shader storage block)
buffer BufferName { // externally visible name of buffer
&nbsp;&nbsp;&nbsp;&nbsp;int count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// typed, shared memory...
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp;&nbsp;&nbsp;vec4 v[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // last member may be an array that is not sized
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// until after link time (dynamically sized)
} Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // name of block within the shader
</code></pre>
<ul>
	<li>
		<p>
            There are implementation-dependent limits on the number of shader storage blocks used for each type of shader, the combined number of shader storage blocks used for a program, and the amount of storage required by each individual shader storage block. If any of these limits are exceeded, it will cause a compile-time or link-time error.
		</p>
	</li>
	<li>
		<p>
            If multiple shaders are linked together, then they will share a single global buffer variable name space. Hence, the types of all declared buffer variables with the same name must match across all shaders that are linked into a single program.
		</p>
	</li>
</ul>
<h5
	id="shared" >
    shared
</h5>
<ul>
	<li>
		<p>
            compute shader only; variable storage is shared across all work items in a workgroup.
		</p>
	</li>
	<li>
		<p>
            The 
			<strong>
                shared
			</strong>
            &nbsp;qualifier is used to declare global variables that have storage shared between all work items in a compute shader workgroup. Variables declared as 
			<strong>
                shared
			</strong>
            &nbsp;may only be used in compute shaders (see “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/overview.html#compute-processor" 
				class="external-link" 
				target="_blank" >
                Compute Processor
			</a>
            ”). Any other declaration of a 
			<strong>
                shared
			</strong>
            &nbsp;variable is a compile-time error. Shared variables are implicitly coherent (see “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#memory-qualifiers" 
				class="external-link" 
				target="_blank" >
                Memory Qualifiers
			</a>
            ”).
		</p>
	</li>
	<li>
		<p>
            Variables declared as 
			<strong>
                shared
			</strong>
            &nbsp;may not have initializers and their contents are undefined at the beginning of shader execution. Any data written to 
			<strong>
                shared
			</strong>
            &nbsp;variables will be visible to other work items (executing the same shader) within the same workgroup.
		</p>
	</li>
	<li>
		<p>
            In the absence of synchronization, the order of reads and writes to the same 
			<strong>
                shared
			</strong>
            &nbsp;variable by different invocations of a shader is not defined.
		</p>
	</li>
	<li>
		<p>
            In order to achieve ordering with respect to reads and writes to 
			<strong>
                shared
			</strong>
            &nbsp;variables, control flow barriers must be employed using the 
			<strong>
                barrier
			</strong>
            () function (see “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/builtinfunctions.html#shader-invocation-control-functions" 
				class="external-link" 
				target="_blank" >
                Shader Invocation Control Functions
			</a>
            ”).
		</p>
	</li>
	<li>
		<p>
            There is a limit to the total size of all variables declared as 
			<strong>
                shared
			</strong>
            &nbsp;in a single program. This limit, expressed in units of basic machine units may be determined by using the OpenGL API to query the value of MAX_COMPUTE_SHARED_MEMORY_SIZE.
		</p>
	</li>
</ul>
<h3
	id="auxiliars" >
    Auxiliars
</h3>
<ul>
	<li>
		<p>
            Some input and output qualified variables can be qualified with at most one additional auxiliary storage qualifier
		</p>
	</li>
	<li>
		<p>
            Auxiliary storage qualifiers can only be used with the 
			<strong>
                in
			</strong>
            &nbsp;or 
			<strong>
                out
			</strong>
            &nbsp;storage qualifiers.
		</p>
	</li>
</ul>
<h5
	id="centroid" >
    centroid
</h5>
<ul>
	<li>
		<p>
            centroid-based interpolation
		</p>
	</li>
</ul>
<h5
	id="sample" >
    sample
</h5>
<ul>
	<li>
		<p>
            per-sample interpolation
		</p>
	</li>
</ul>
<h5
	id="patch" >
    patch
</h5>
<ul>
	<li>
		<p>
            per-tessellation-patch attributes
		</p>
	</li>
</ul>
<h3
	id="interface-blocks" >
    Interface Blocks
</h3>
<ul>
	<li>
		<p>
            Input, output, uniform, and buffer variable declarations can be grouped into named interface blocks to provide coarser granularity backing than is achievable with individual declarations. They can have an optional instance name, used in the shader to reference their members. An output block of one programmable stage is backed by a corresponding input block in the subsequent programmable stage. A 
			<em>
                uniform block
			</em>
            &nbsp;is backed by the application with a buffer object. A 
			<em>
                buffer block
			</em>
            , also known as a 
			<em>
                shader storage block
			</em>
            , is also backed by the application with a buffer object. It is a compile-time error to have an input block in a vertex shader or an output block in a fragment shader. These uses are reserved for future use.
		</p>
	</li>
	<li>
		<p>
            An interface block declaration is defined in the grammar as follows:
		</p>
		<ul>
			<li>
				<p>
					<em>
                        interface-block
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        type_qualifier
					</em>
                    &nbsp;
					<em>
                        block-name
					</em>
                    &nbsp;
					<strong>
                        {
					</strong>
                    &nbsp;
					<em>
                        member-list
					</em>
                    &nbsp;
					<strong>
                        }
					</strong>
                    &nbsp;
					<em>
                        instance-nameopt
					</em>
                    &nbsp;
					<strong>
                        ;
					</strong>
				</p>
			</li>
			<li>
				<p>
					<em>
                        block-name
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        identifier
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-list
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-declaration
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-declaration
					</em>
                    &nbsp;
					<em>
                        member-list
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        member-declaration
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        layout-qualifieropt
					</em>
                    &nbsp;
					<em>
                        qualifiersopt
					</em>
                    &nbsp;
					<em>
                        type
					</em>
                    &nbsp;
					<em>
                        declarators
					</em>
                    &nbsp;
					<strong>
                        ;
					</strong>
				</p>
			</li>
			<li>
				<p>
					<em>
                        instance-name
					</em>
                    &nbsp;:
				</p>
			</li>
			<li>
				<p>
					<em>
                        identifier
					</em>
				</p>
			</li>
			<li>
				<p>
					<em>
                        identifier
					</em>
                    &nbsp;
					<em>
                        array-specifier
					</em>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Each of the above elements is discussed below.
		</p>
	</li>
	<li>
		<p>
            First, an example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">uniform Transform {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewProjectionMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;uniform mat3 NormalMatrix;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// allowed restatement of qualifier
&nbsp;&nbsp;&nbsp;&nbsp;float Deformation;
};
</code></pre>
<ul>
	<li>
		<p>
            The above establishes a uniform block named “Transform” with four uniforms grouped inside it.
		</p>
	</li>
	<li>
		<p>
			<em>
                type-qualifier
			</em>
            &nbsp;determines the interface of which the block will be a part and, optionally, additional qualifiers that are applied to the block. It is a compile-time error if it does not include one of the storage qualifiers 
			<strong>
                in
			</strong>
            , 
			<strong>
                out
			</strong>
            , 
			<strong>
                uniform
			</strong>
            &nbsp;or 
			<strong>
                buffer
			</strong>
            . It may optionally include 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#layout-qualifiers" 
				class="external-link" 
				target="_blank" >
                layout qualifiers
			</a>
            , the 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#storage-qualifiers" 
				class="external-link" 
				target="_blank" >
                auxiliary storage qualifier
			</a>
            &nbsp;
			<strong>
                patch
			</strong>
            , and the 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#the-precise-qualifier" 
				class="external-link" 
				target="_blank" >
                precise qualifier
			</a>
            . 
			<strong>
                buffer
			</strong>
            &nbsp;blocks may additionally include 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#memory-qualifiers" 
				class="external-link" 
				target="_blank" >
                Memory Qualifiers
			</a>
            . It is a compile-time error to include any other qualifiers.
		</p>
	</li>
	<li>
		<p>
			<em>
                member-list
			</em>
            &nbsp;declares the variables that are to be grouped into the block. Types and declarators are the same as for other input, output, uniform, and buffer variable declarations outside blocks, with these exceptions:
		</p>
	</li>
	<li>
		<p>
            Initializers are not allowed
		</p>
	</li>
	<li>
		<p>
            Opaque types are not allowed
		</p>
	</li>
	<li>
		<p>
            Structure definitions cannot be nested inside a block
		</p>
	</li>
	<li>
		<p>
            Any of these would result in a compile-time error.
		</p>
	</li>
	<li>
		<p>
            If no optional qualifier is used in a member-declaration, the qualification of the member includes all 
			<strong>
                in
			</strong>
            , 
			<strong>
                out
			</strong>
            , 
			<strong>
                patch
			</strong>
            , 
			<strong>
                uniform
			</strong>
            , or 
			<strong>
                buffer
			</strong>
            &nbsp;as determined by 
			<em>
                interface-qualifier
			</em>
            . If optional qualifiers are used, they can include interpolation qualifiers, auxiliary storage qualifiers, precision qualifiers, and storage qualifiers and they must declare an input, output, or uniform member consistent with the interface qualifier of the block: Input variables, output variables, uniform variables, and 
			<strong>
                buffer
			</strong>
            &nbsp;members can only be in 
			<strong>
                in
			</strong>
            &nbsp;blocks, 
			<strong>
                out
			</strong>
            &nbsp;blocks, 
			<strong>
                uniform
			</strong>
            &nbsp;blocks, and shader storage blocks, respectively.
		</p>
	</li>
	<li>
		<p>
            Repeating the 
			<strong>
                in
			</strong>
            , 
			<strong>
                out
			</strong>
            , 
			<strong>
                patch
			</strong>
            , 
			<strong>
                uniform
			</strong>
            , or 
			<strong>
                buffer
			</strong>
            &nbsp;interface qualifier for a member’s storage qualifier is optional. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in Material {
&nbsp;&nbsp;&nbsp;&nbsp;smooth in vec4 Color1; // legal, input inside in block
&nbsp;&nbsp;&nbsp;&nbsp;smooth vec4 Color2;&nbsp;&nbsp;&nbsp;&nbsp;// legal, 'in' inherited from 'in Material'
&nbsp;&nbsp;&nbsp;&nbsp;vec2 TexCoord;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // legal, TexCoord is an input
&nbsp;&nbsp;&nbsp;&nbsp;uniform float Atten;&nbsp;&nbsp; // illegal, mismatched storage qualifier
};
</code></pre>
<ul>
	<li>
		<p>
            Members of 
			<strong>
                uniform
			</strong>
            &nbsp;or 
			<strong>
                buffer
			</strong>
            &nbsp;storage blocks are always represented in memory as 
			<strong>
                highp
			</strong>
            , regardless of any precision qualifier associated with the declaration. When values are read from or written to such variables they are converted to or from the declared precision as described in 
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#conversion-between-precisions" 
				class="external-link" 
				target="_blank" >
                Conversion Between Precisions
			</a>
            . Operations on the values within the shader will take place using the declared precision as normal.
		</p>
	</li>
	<li>
		<p>
            A 
			<em>
                shader interface
			</em>
            &nbsp;is defined to be one of these:
		</p>
	</li>
	<li>
		<p>
            All the uniform variables and uniform blocks declared in a program. This spans all compilation units linked together within one program.
		</p>
	</li>
	<li>
		<p>
            All the 
			<strong>
                buffer
			</strong>
            &nbsp;blocks declared in a program.
		</p>
	</li>
	<li>
		<p>
            The boundary between adjacent programmable pipeline stages: This spans all the outputs declared in all compilation units of the first stage and all the inputs declared in all compilation units of the second stage. Note that for the purposes of this definition, the fragment shader and the preceding shader are considered to have a shared boundary even though in practice, all values passed to the fragment shader first pass through the rasterizer and interpolator.
		</p>
	</li>
	<li>
		<p>
            The block name (
			<em>
                block-name
			</em>
            ) is used to match within shader interfaces: an output block of one pipeline stage will be matched to an input block with the same name in the subsequent pipeline stage. For uniform or shader storage blocks, the application uses the block name to identify the block. Block names have no other use within a shader beyond interface matching; it is a compile-time error to use a block name at global scope for anything other than as a block name (e.g. use of a block name for a global variable name or function name is currently reserved). It is a compile-time error to use the same block name for more than one block declaration in the same shader interface (as defined above) within one shader, even if the block contents are identical.
		</p>
	</li>
	<li>
		<p>
            Matched block names within a shader interface (as defined above) must match in terms of having the same number of declarations with the same sequence of types and the same sequence of member names, as well as having matching member-wise layout qualification (see next section). Matched uniform or shader storage block names (but not input or output block names) must also either all be lacking an instance name or all having an instance name, putting their members at the same scoping level. When instance names are present on matched block names, it is allowed for the instance names to differ; they need not match for the blocks to match. Furthermore, if a matching block is declared as an array, then the array sizes must also match (or follow array matching rules for the shader interface between consecutive shader stages). Any mismatch will generate a link-time error. A block name is allowed to have different definitions in different shader interfaces within the same shader, allowing, for example, an input block and output block to have the same name.
		</p>
	</li>
	<li>
		<p>
            If an instance name (
			<em>
                instance-name
			</em>
            ) is not used, the names declared inside the block are scoped at the global level and accessed as if they were declared outside the block. If an instance name (
			<em>
                instance-name
			</em>
            ) is used, then it puts all the members inside a scope within its own name space, accessed with the field selector (
			<strong>
                .
			</strong>
            ) operator (analogously to structures). For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">in Light {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 LightPos;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 LightColor;
};
in ColoredTexture {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Color;
&nbsp;&nbsp;&nbsp;&nbsp;vec2 TexCoord;
} Material;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // instance name
vec3 Color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // different Color than Material.Color
vec4 LightPos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// illegal, already defined
...
... = LightPos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accessing LightPos
... = Material.Color; // accessing Color in ColoredTexture block
</code></pre>
<ul>
	<li>
		<p>
            Outside the shading language (i.e., in the API), members are similarly identified except the block name is always used in place of the instance name (API accesses are to shader interfaces, not to shaders). If there is no instance name, then the API does not use the block name to access a member, just the member name.
		</p>
	</li>
	<li>
		<p>
            Within a shader interface, all declarations of the same global name must be for the same object and must match in type and in whether they declare a variable or member of a block with no instance name. The API also needs this name to uniquely identify an object in the shader interface. It is a link-time error if any particular shader interface contains
		</p>
	</li>
	<li>
		<p>
            two different blocks, each having no instance name, and each having a member of the same name, or
		</p>
	</li>
	<li>
		<p>
            a variable outside a block, and a block with no instance name, where the variable has the same name as a member in the block.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">out Vertex {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Position;&nbsp;&nbsp;// API transform/feedback will use "Vertex.Position"
&nbsp;&nbsp;&nbsp;&nbsp;vec2 Texture;
} Coords;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shader will use "Coords.Position"
out Vertex2 {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Color;&nbsp;&nbsp;&nbsp;&nbsp; // API will use "Color"
&nbsp;&nbsp;&nbsp;&nbsp;float Color2;
};
// in same program as Vertex2 above:
out Vertex3 {
&nbsp;&nbsp;&nbsp;&nbsp;float Intensity;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 Color;&nbsp;&nbsp;&nbsp;&nbsp; // ERROR, name collision with Color in Vertex2
};
float Color2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ERROR, collides with Color2 in Vertex2
</code></pre>
<ul>
	<li>
		<p>
            For blocks declared as arrays, the array index must also be included when accessing members, as in this example
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">uniform Transform { // API uses "Transform[2]" to refer to instance 2
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;mat4 ModelViewProjectionMatrix;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 a[]; // array will get implicitly sized
&nbsp;&nbsp;&nbsp;&nbsp;float Deformation;
} transforms[4];
...
... = transforms[2].ModelViewMatrix; // shader access of instance 2
// API uses "Transform.ModelViewMatrix" to query an offset or other query
transforms[x].a.length(); // same length for 'a' for all x
Transform[x];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // illegal, must use 'transforms'
Transform.a.length();&nbsp;&nbsp;&nbsp;&nbsp; // illegal, must use 'transforms'
...transforms[2].a[3]...&nbsp;&nbsp;// if these are the only two dereferences of 'a',
...transforms[3].a[7]...&nbsp;&nbsp;// then 'a' must be size 8, for all
transforms[x]
</code></pre>
<ul>
	<li>
		<p>
            For uniform or shader storage blocks declared as an array, each individual array element corresponds to a separate buffer object bind range, backing one instance of the block. As the array size indicates the number of buffer objects needed, uniform and shader storage block array declarations must specify an array size. A uniform or shader storage block array can only be indexed with a dynamically uniform integral expression, otherwise results are undefined.
		</p>
	</li>
	<li>
		<p>
            When using OpenGL API entry points to identify the name of an individual block in an array of blocks, the name string may include an array index (e.g. 
			<em>
                Transform[2]
			</em>
            ). When using OpenGL API entry points to refer to offsets or other characteristics of a block member, an array index must not be specified (e.g. 
			<em>
                Transform.ModelViewMatrix
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
            Tessellation control, tessellation evaluation and geometry shader input blocks must be declared as arrays and follow the array declaration and linking rules for all shader inputs for the respective stages. All other input and output block arrays must specify an array size.
		</p>
	</li>
	<li>
		<p>
            There are implementation-dependent limits on the number of uniform blocks and the number of shader storage blocks that can be used per stage. If either limit is exceeded, it will cause a link-time error.
		</p>
	</li>
</ul>
<h2
	id="layout-qualifiers" >
    Layout Qualifiers
</h2>
<h3
	id="input-layout-qualifiers" >
    Input Layout Qualifiers
</h3>
<ul>
	<li>
		<p>
            <code>location = N</code>
		</p>
		<ul>
			<li>
				<p>
                    Assigns an input/output location index for vertex inputs, fragment outputs, or varyings. Used for linking stages and for vertex attribute bindings. (maps to SPIR-V 
                    <code>Location</code>
                    ). 
					<a
						href="https://docs.vulkan.org/glsl/latest/chapters/spirvmappings.html?utm_source=chatgpt.com" 
						class="external-link" 
						target="_blank" >
                        docs.vulkan.org
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>binding = B</code>
            &nbsp;and 
            <code>set = S</code>
		</p>
		<ul>
			<li>
				<p>
                    Assign descriptor binding number and descriptor set index for opaque/descriptor resources (uniform buffers, storage buffers, samplers, images).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>offset = N</code>
            &nbsp;and 
            <code>align = A</code>
		</p>
		<ul>
			<li>
				<p>
                    explicitly control byte offsets and alignment of members inside interface/UBO/SSBO blocks; they map to the SPIR-V 
                    <code>Offset</code>
                    /
                    <code>ArrayStride</code>
                    /
                    <code>MatrixStride</code>
                    &nbsp;decorations for struct members.
				</p>
			</li>
			<li>
				<p>
                    Use when you need explicit control over memory layout.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>push_constant</code>
		</p>
		<ul>
			<li>
				<p>
                    (block qualifier)
				</p>
			</li>
			<li>
				<p>
                    Marks a uniform block as push constants.
				</p>
			</li>
			<li>
				<p>
                    They must be declared in the pipeline layout as push-constant ranges.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>constant_id = N</code>
            &nbsp;(specialization constants)
		</p>
		<ul>
			<li>
				<p>
                    Make a 
                    <code>const</code>
                    &nbsp;scalar into a SPIR-V specialization constant whose value can be supplied at pipeline creation time (allows driver optimization without full shader recompile).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Interpolation and qualifiers: 
            <code>flat</code>
            , 
            <code>noperspective</code>
            , 
            <code>centroid</code>
            , 
            <code>sample</code>
            , 
            <code>invariant</code>
		</p>
		<ul>
			<li>
				<p>
                    control interpolation rules or invariance; they map to SPIR-V interpolation/built-in decorations or decorations affecting interpolation
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/location_component_interface.html" 
				class="external-link" 
				target="_blank" >
                Location and Component Interface
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="location" >
    Location
</h5>
<pre><code class="language-glsl" data-lang="glsl">layout(location = 3) in vec4 normal;
const int start = 6;
layout(location = start + 2) in vec4 v;
</code></pre>
<ul>
	<li>
		<p>
            In this example the shader input 
			<em>
                normal
			</em>
            &nbsp;is assigned to vector location number 3 and 
			<em>
                v
			</em>
            &nbsp;is assigned location number 8. For vertex shader inputs, the location specifies the number of the vertex attribute from which input values are taken. For inputs of all other shader types, the location specifies a vector number that can be used to match against outputs from a previous shader stage, even if that shader is in a different program object.
		</p>
	</li>
	<li>
		<p>
            The following language describes how many locations are consumed by a given type. However, geometry shader inputs, tessellation control shader inputs and outputs, and tessellation evaluation inputs all have an additional level of arrayness relative to other shader inputs and outputs. This outer array level is removed from the type before considering how many locations the type consumes.
		</p>
	</li>
	<li>
		<p>
            If the declared input (after potentially removing an outer array level as just described above) is an array of size 
			<em>
                n
			</em>
            &nbsp;and each of the elements takes 
			<em>
                m
			</em>
            &nbsp;locations, it will be assigned 
			<em>
                m
			</em>
            &nbsp;* 
			<em>
                n
			</em>
            &nbsp;consecutive locations starting with the location specified. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(location = 6) in vec4 colors[3];
</code></pre>
<ul>
	<li>
		<p>
            will establish that the shader input 
			<em>
                colors
			</em>
            &nbsp;is assigned to vector location numbers 6, 7, and 8.
		</p>
	</li>
	<li>
		<p>
            If the declared input is an 
			<em>
                n
			</em>
            &nbsp;× 
			<em>
                m
			</em>
            &nbsp;matrix, it will be assigned multiple locations starting with the location specified. The number of locations assigned for each matrix will be the same as for an 
			<em>
                n
			</em>
            -element array of 
			<em>
                m
			</em>
            -component vectors. For example,
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(location = 9) in mat4 transforms[2];
</code></pre>
<ul>
	<li>
		<p>
            will establish that shader input 
			<em>
                transforms
			</em>
            &nbsp;is assigned to vector locations 9-16, with 
			<em>
                transforms[0]
			</em>
            &nbsp;being assigned to locations 9-12, and 
			<em>
                transforms[1]
			</em>
            &nbsp;being assigned to locations 13-16.
		</p>
	</li>
	<li>
		<p>
            If the declared input is a structure or block, its members will be assigned consecutive locations in their order of declaration, with the first member assigned the location provided in the layout qualifier. For a structure, this process applies to the entire structure. It is a compile-time error to use a 
			<strong>
                location
			</strong>
            &nbsp;qualifier on a member of a structure. For a block, this process applies to the entire block, or until the first member is reached that has a 
			<strong>
                location
			</strong>
            &nbsp;layout qualifier.
		</p>
	</li>
	<li>
		<p>
            When a block member is declared with a 
			<strong>
                location
			</strong>
            &nbsp;qualifier, its location comes from that qualifier; the member’s 
			<strong>
                location
			</strong>
            &nbsp;qualifier overrides the block-level declaration. Subsequent members are again assigned consecutive locations, based on the newest location, until the next member declared with a 
			<strong>
                location
			</strong>
            &nbsp;qualifier. The values used for locations do not have to be declared in increasing order.
		</p>
	</li>
	<li>
		<p>
            If a block has no block-level 
			<strong>
                location
			</strong>
            &nbsp;layout qualifier, it is required that either all or none of its members have a 
			<strong>
                location
			</strong>
            &nbsp;layout qualifier, or a compile-time error results. For some blocks declared as arrays, the 
			<strong>
                location
			</strong>
            &nbsp;can only be applied at the block level: When a block is declared as an array where additional locations are needed for each member for each block array element, it is a compile-time error to specify locations on the block members. For 
			<em>
                arrayed
			</em>
            &nbsp;interfaces (those generally having an extra level of arrayness due to interface expansion), the outer array is stripped before applying this rule.
		</p>
	</li>
	<li>
		<p>
            When generating SPIR-V, all 
			<strong>
                in
			</strong>
            &nbsp;and 
			<strong>
                out
			</strong>
            &nbsp;qualified user-declared (non built-in) variables and blocks (or all their members) must have a shader-specified 
			<strong>
                location
			</strong>
            . Otherwise, a compile-time error is generated.
		</p>
	</li>
	<li>
		<p>
            The locations consumed by block and structure members are determined by applying the rules above recursively as though the structure member were declared as an input variable of the same type. For example:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(location = 3) in struct S
{
&nbsp;&nbsp;&nbsp;&nbsp;vec3 a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// gets location 3
&nbsp;&nbsp;&nbsp;&nbsp;mat2 b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// gets locations 4 and 5
&nbsp;&nbsp;&nbsp;&nbsp;vec4 c[2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // gets locations 6 and 7
&nbsp;&nbsp;&nbsp;&nbsp;layout(location = 8) vec2 A; // ERROR, can't use on struct member
} s;
layout(location = 4) in block
{
&nbsp;&nbsp;&nbsp;&nbsp;vec4 d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// gets location 4
&nbsp;&nbsp;&nbsp;&nbsp;vec4 e;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// gets location 5
&nbsp;&nbsp;&nbsp;&nbsp;layout(location = 7) vec4 f; // gets location 7
&nbsp;&nbsp;&nbsp;&nbsp;vec4 g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// gets location 8
&nbsp;&nbsp;&nbsp;&nbsp;layout(location = 1) vec4 h; // gets location 1
&nbsp;&nbsp;&nbsp;&nbsp;vec4 i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// gets location 2
&nbsp;&nbsp;&nbsp;&nbsp;vec4 j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// gets location 3
&nbsp;&nbsp;&nbsp;&nbsp;vec4 k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ERROR, location 4 already used
};
</code></pre>
<ul>
	<li>
		<p>
            The number of input locations available to a shader is limited. For vertex shaders, the limit is the advertised number of vertex attributes. For all other shaders, the limit is implementation-dependent and must be no less than one fourth of the advertised maximum input component count.
		</p>
	</li>
	<li>
		<p>
            program will fail to link if any attached shader uses a location greater than or equal to the number of supported locations, unless device-dependent optimizations are able to make the program fit within available hardware resources.
            <br>
            A program will fail to link if explicit location assignments leave the linker unable to find space for other variables without explicit assignments.
            <br>
            For the purposes of determining if a non-vertex input matches an output from a previous shader stage, the 
			<strong>
                location
			</strong>
            &nbsp;layout qualifier (if any) must match.
		</p>
	</li>
</ul>
<h5
	id="component" >
    Component
</h5>
<ul>
	<li>
		<p>
            The 
			<strong>
                component
			</strong>
            &nbsp;qualifier allows the location to be more finely specified for scalars and vectors, down to the individual components within a location that are consumed. It is a compile-time error to use 
			<strong>
                component
			</strong>
            &nbsp;without also specifying the 
			<strong>
                location
			</strong>
            &nbsp;qualifier (order does not matter). The components within a location are 0, 1, 2, and 3. A variable or block member starting at component 
			<em>
                N
			</em>
            &nbsp;will consume components 
			<em>
                N
			</em>
            , 
			<em>
                N+1
			</em>
            , 
			<em>
                N+2
			</em>
            , …​ up through its size. It is a compile-time error if this sequence of components gets larger than 3. A scalar 
			<strong>
                double
			</strong>
            &nbsp;will consume two of these components, and a 
			<strong>
                dvec2
			</strong>
            &nbsp;will consume all four components available within a location. A 
			<strong>
                dvec3
			</strong>
            &nbsp;or 
			<strong>
                dvec4
			</strong>
            &nbsp;can only be declared without specifying a 
			<strong>
                component
			</strong>
            . A 
			<strong>
                dvec3
			</strong>
            &nbsp;will consume all four components of the first location and components 0 and 1 of the second location. This leaves components 2 and 3 available for other component-qualified declarations.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// a consumes components 2 and 3 of location 4
layout(location = 4, component = 2) in vec2 a;

// b consumes component 1 of location 4
layout(location = 4, component = 1) in float b;

// ERROR: c overflows component 3
layout(location = 3, component = 2) in vec3 c;

// d consumes components 2 and 3 of location 5
layout(location = 5, component = 2) in double d;

// ERROR: e overflows component 3 of location 6
layout(location = 6, component = 2) in dvec2 e;

// ERROR: f overlaps with g
layout(location = 7, component = 0) in vec2 f;
layout(location = 7, component = 1) in float g;

layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and components 0 and 1 of location 9
layout(location = 9, component = 2) in double i; // okay, compts 2 and 3
</code></pre>
<ul>
	<li>
		<p>
            If the variable is an array, each element of the array, in order, is assigned to consecutive locations, but all at the same specified component within each location. For example:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// component 3 is consumed in each of 6 locations
layout(location = 2, component = 3) in float d[6];
</code></pre>
<ul>
	<li>
		<p>
            That is, location 2 component 3 will hold 
			<em>
                d[0]
			</em>
            , location 3 component 3 will hold 
			<em>
                d[1]
			</em>
            , …​, up through location 7 component 3 holding 
			<em>
                d[5]
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            This allows packing of two arrays into the same set of locations:
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// e consumes beginning (components 0, 1 and 2) of each of 6 slots
layout(location = 0, component = 0) in vec3 e[6];

// f consumes last component of the same 6 slots
layout(location = 0, component = 3) in float f[6];
</code></pre>
<ul>
	<li>
		<p>
            If applying this to an array of arrays, all levels of arrayness are removed to get to the elements that are assigned per location to the specified component. These non-arrayed elements will fill the locations in the order specified for arrays of arrays in “
			<a
				href="https://docs.vulkan.org/glsl/latest/chapters/variables.html?utm_source=chatgpt.com#arrays" 
				class="external-link" 
				target="_blank" >
                Arrays
			</a>
            ”.
		</p>
	</li>
	<li>
		<p>
            It is a compile-time error to apply the 
			<strong>
                component
			</strong>
            &nbsp;qualifier to a matrix, a structure, a block, or an array containing any of these. It is a compile-time error to use 
			<strong>
                component
			</strong>
            &nbsp;1 or 3 as the beginning of a 
			<strong>
                double
			</strong>
            &nbsp;or 
			<strong>
                dvec2
			</strong>
            . It is a link-time error to specify different components for the same variable within a program.
		</p>
	</li>
</ul>
<h5
	id="location-aliasing" >
    Location Aliasing
</h5>
<ul>
	<li>
		<p>
			<em>
                Location aliasing
			</em>
            &nbsp;is causing two variables or block members to have the same location number. 
			<em>
                Component aliasing
			</em>
            &nbsp;is assigning the same (or overlapping) component numbers for two location aliases. (Recall if 
			<strong>
                component
			</strong>
            &nbsp;is not used, components are assigned starting with 0.) With one exception, location aliasing is allowed only if it does not cause component aliasing; it is a compile-time or link-time error to cause component aliasing. Further, when location aliasing, the aliases sharing the location must have the same underlying numerical type and bit width (floating-point or integer, 32-bit versus 64-bit, etc.) and the same auxiliary storage and interpolation qualification. The one exception where component aliasing is permitted is when targeting OpenGL for two input variables (not block members) to a vertex shader, which are allowed to have component aliasing. This vertex-variable component aliasing is intended only to support vertex shaders where each execution path accesses at most one input per aliased component. Implementations are permitted, but not required, to generate link-time errors if they detect that every path through the vertex shader executable accesses multiple inputs aliased to any single component.
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Graphics Programming/GPU/GPU.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                🧑‍💻 built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                📅 2025-10-21 .&nbsp;&nbsp;2025-10-30 🚀
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<ul>
						<li>
							<a
								href="#where-i-stopped" >
                                Where I Stopped
							</a>
						</li>
						<li>
							<a
								href="#about" >
                                About
							</a>
						</li>
						<li>
							<a
								href="#formats" >
                                Formats
							</a>
						</li>
						<li>
							<a
								href="#constant-data" >
                                Constant Data
							</a>
						</li>
						<li>
							<a
								href="#varying-types" >
                                Varying Types
							</a>
						</li>
						<li>
							<a
								href="#uniform-types" >
                                Uniform Types
							</a>
						</li>
						<li>
							<a
								href="#interface-blocks" >
                                Interface Blocks
							</a>
						</li>
						<li>
							<a
								href="#cheat-sheet" >
                                Cheat Sheet
							</a>
						</li>
					</ul>
					<li>
						<a
							href="#basic" >
                            Basic
						</a>
						<ul>
							<li>
								<a
									href="#preprocessors" >
                                    Preprocessors
								</a>
							</li>
							<li>
								<a
									href="#basic-types" >
                                    Basic Types
								</a>
							</li>
							<li>
								<a
									href="#arrays" >
                                    Arrays
								</a>
							</li>
							<li>
								<a
									href="#structs" >
                                    Structs
								</a>
							</li>
							<li>
								<a
									href="#functions" >
                                    Functions
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#storage-qualifiers" >
                            Storage Qualifiers
						</a>
						<ul>
							<li>
								<a
									href="#auxiliars" >
                                    Auxiliars
								</a>
							</li>
							<li>
								<a
									href="#interface-blocks" >
                                    Interface Blocks
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#layout-qualifiers" >
                            Layout Qualifiers
						</a>
						<ul>
							<li>
								<a
									href="#input-layout-qualifiers" >
                                    Input Layout Qualifiers
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.js" >
		</script>
	</body>
</html>
