<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.88482.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<header>
				<a
					href="/" 
					class="site-logo" >
                    Caio Raphael
				</a>
				<p
					class="breadcrums-division" >
                    /
				</p>
				<a
					href="/studies/_index.html" 
					class="breadcrumbs-studies" >
                    Studies
				</a>
			</header>
			<nav>
				<details
					open="">
					<summary>
                        Vulkan
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                Samples
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                Core
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                Render Loop
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                Synchronization and Cache Control
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                Command Buffers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                Pipelines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                Compute Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                Resources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                Depth
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                Mapping Data to Shaders
							</a>
							<ul>
								<li>
									<a
										href="#shader-alignment" >
                                        Shader Alignment
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#comparisons" >
                                        Comparisons
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#input-attributes" >
                                        Input Attributes
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#push-constants" >
                                        Push Constants
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#descriptors-sets" >
                                        Descriptors Sets
									</a>
									<ul>
										<li>
											<a
												href="#about" >
                                                About
											</a>
										</li>
										<li>
											<a
												href="#allocation" >
                                                Allocation
											</a>
										</li>
										<li>
											<a
												href="#descriptor-types" >
                                                Descriptor Types
											</a>
										</li>
										<li>
											<a
												href="#updates" >
                                                Updates
											</a>
										</li>
										<li>
											<a
												href="#descriptor-set-layout" >
                                                Descriptor Set Layout
											</a>
										</li>
										<li>
											<a
												href="#binding" >
                                                Binding
											</a>
										</li>
										<li>
											<a
												href="#strategy-descriptor-indexing-codeext_descriptor_indexing-code" >
                                                Strategy: Descriptor Indexing (<code>EXT_descriptor_indexing</code>)
											</a>
										</li>
										<li>
											<a
												href="#strategy-descriptor-buffers-codeext_descriptor_buffer-code" >
                                                Strategy: Descriptor Buffers (<code>EXT_descriptor_buffer</code>)
											</a>
										</li>
										<li>
											<a
												href="#strategy-push-descriptor-codevk_khr_push_descriptor-code" >
                                                Strategy: Push Descriptor (<code>VK_KHR_push_descriptor</code>)
											</a>
										</li>
										<li>
											<a
												href="#strategy-bindful-classic-strategy-slot-based-frequency-based" >
                                                <s>Strategy: Bindful / Classic strategy (Slot-based / Frequency-based)</s>
											</a>
										</li>
									</ul>
								</li>
								<li>
									<a
										href="#specialization-constants" >
                                        Specialization Constants
									</a>
									<ul>
									</ul>
								</li>
								<li>
									<a
										href="#physical-storage-buffer-codekhr_buffer_device_address-code" >
                                        Physical Storage Buffer (<code>KHR_buffer_device_address</code>)
									</a>
								</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                Memory Allocation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                HDR Support
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                Profiling
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                Mobile
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                VR
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                Video Decoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                SPIR-V
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                Web
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Render Engineering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                Graphics APIs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                Shader Languages
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                Choosing the Space to compute Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                BSDF (Bidirectional Scattering Distribution Function)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                Material
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                Direct Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                Shadows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                Skybox / Skydome
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                Transparency
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                Global Illumination / Indirect Lighting
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                Global Illumination - Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                Global Illumination - Discarded Solutions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                Lightmaps
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                Post-Processing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                Anti-Aliasing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                Light Path / Rendering Method
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                Optimization Techniques
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Graphics and Shaders
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                Sources
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                Math, Linear Algebra
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                Spaces, Transformations and Graphics Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                Common Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                Shaders
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GLSL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                Basic
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                Storage Qualifiers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                Layout Qualifiers
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        GPU
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                Execution Building Blocks
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                Specialized units &amp; instructions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                Cache
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                GPU VA (Virtual Address)
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                Tiled-GPUs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Slang
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang-slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Font Rendering
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                Techniques
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                Text Processing Pipeline
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                Concepts
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                Formats
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                Libs
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                Tools
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                Fonts
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        OpenGL
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                About
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Mapping Data to Shaders
						</h1>
						<p>
							<time
								datetime="2025-08-01" >
                                üïí Created: 2025-08-01
							</time>
							<time
								datetime="2026-01-22" >
                                | Updated: 2026-01-22
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h3
	id="shader-alignment" >
    Shader Alignment
</h3>
<h5
	id="minimum-dynamic-offset-cbv-allocation-granularity" >
    Minimum Dynamic-Offset / CBV Allocation Granularity
</h5>
<ul>
	<li>
		<p>
            GPUs and drivers require that when you bind or use a portion of a large buffer as a uniform/constant buffer the start address and/or size line up to an alignment.
		</p>
	</li>
	<li>
		<p>
            That alignment is the ‚Äúminimum dynamic-offset‚Äù (Vulkan) or the CBV/constant buffer granularity (D3D12).
		</p>
	</li>
	<li>
		<p>
            It lets the driver map many small logical buffers into a single big GPU buffer efficiently.
		</p>
	</li>
	<li>
		<p>
            If you bind at an unaligned offset the API/driver will reject it or you will get wrong data or degraded performance.
		</p>
	</li>
	<li>
		<p>
            Drivers can report 64, 128, 256, or other powers of two.
		</p>
	</li>
	<li>
		<p>
            UBO alignment is usually larger than SSBO alignment because UBO usage and caches are handled differently by the hardware.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Value
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Many APIs and drivers use 256 bytes as the Minimum Dynamic-Offset on common desktop GPUs.
				</p>
				<ul>
					<li>
						<p>
                            VkGuide:
						</p>
					</li>
				</ul>
<pre><code class="language-cpp" data-lang="cpp">struct MaterialConstants {&nbsp;&nbsp;// written into uniform buffers later
&nbsp;&nbsp;&nbsp;&nbsp;glm::vec4 colorFactors; // multiply the color texture
&nbsp;&nbsp;&nbsp;&nbsp;glm::vec4 metal_rough_factors;
&nbsp;&nbsp;&nbsp;&nbsp;glm::vec4 extra[14];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding, we need it anyway for uniform buffers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it needs to meet a minimum requirement for its alignment. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;256 bytes is a good default alignment for this which all the gpus we target meet, so we are adding those vec4s to pad the structure to 256 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
};
</code></pre>
			</li>
			<li>
				<p>
                    But not every platform or GPU guarantees 256. Mobile or integrated GPUs may have different values.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceLimits</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>minUniformBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
                                    <code>VkDescriptorBufferInfo</code>
                                    &nbsp;structure for uniform buffers.
								</p>
							</li>
							<li>
								<p>
                                    When a descriptor of type 
                                    <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
                                    &nbsp;or 
                                    <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                    &nbsp;is updated, the 
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    Similarly, dynamic offsets for uniform buffers 
									<strong>
                                        must
									</strong>
                                    &nbsp;be multiples of this limit.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minStorageBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
                                    <code>VkDescriptorBufferInfo</code>
                                    &nbsp;structure for storage buffers.
								</p>
							</li>
							<li>
								<p>
                                    When a descriptor of type 
                                    <code>DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
                                    &nbsp;or 
                                    <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                    &nbsp;is updated, the 
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    Similarly, dynamic offsets for storage buffers 
									<strong>
                                        must
									</strong>
                                    &nbsp;be multiples of this limit.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minTexelBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkBufferViewCreateInfo
									</a>
                                    &nbsp;structure for texel buffers.
								</p>
							</li>
							<li>
								<p>
                                    If the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-texelBufferAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>texelBufferAlignment</code>
									</a>
                                    &nbsp;feature is enabled, this limit is equivalent to the maximum of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-uniformTexelBufferOffsetAlignmentBytes" 
										class="external-link" 
										target="_blank" >
                                        <code>uniformTexelBufferOffsetAlignmentBytes</code>
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-storageTexelBufferOffsetAlignmentBytes" 
										class="external-link" 
										target="_blank" >
                                        <code>storageTexelBufferOffsetAlignmentBytes</code>
									</a>
                                    &nbsp;members of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceTexelBufferAlignmentProperties
									</a>
                                    , but smaller alignment is 
									<strong>
                                        optionally
									</strong>
                                    &nbsp;allowed by 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-storageTexelBufferOffsetSingleTexelAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>storageTexelBufferOffsetSingleTexelAlignment</code>
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-uniformTexelBufferOffsetSingleTexelAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>uniformTexelBufferOffsetSingleTexelAlignment</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    If the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-texelBufferAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>texelBufferAlignment</code>
									</a>
                                    &nbsp;feature is not enabled, 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkBufferViewCreateInfo
									</a>
                                    ::
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be a multiple of this value.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Best practice
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Query the GPU at runtime and align your buffer ranges to the reported value.
				</p>
			</li>
			<li>
				<p>
                    Assert size at compile time:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">static_assert(sizeof(MaterialConstants) == 256, "MaterialConstants must be 256 bytes");
</code></pre>
	</li>
</ul>
<h5
	id="default-layouts" >
    Default Layouts
</h5>
<ul>
	<li>
		<p>
			<strong>
                UBOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std140.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SSBOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std430.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std430 (Vulkan).
				</p>
			</li>
			<li>
				<p>
                    Source: 
					<a
						href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf" 
						class="external-link" 
						target="_blank" >
                        GLSL Spec 4.60.8
					</a>
                    , page 90.
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.pdf" 
								class="external-link" 
								target="_blank" >
                                OpenGL Spec 4.6
							</a>
                            , page 146 (7.6.2.2).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="alignment-options" >
    Alignment Options
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/interfaces.html#interfaces-resources-layout" 
				class="external-link" 
				target="_blank" >
                Offset and Stride Assignment
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            There are different alignment requirements depending on the specific resources and on the features enabled.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platform dependency
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        32-bit IEEE-754
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 4 bytes.
						</p>
					</li>
					<li>
						<p>
                            The standard for desktop, mobile, OpenGL ES and Vulkan.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        16-bit half precision
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 2 bytes.
						</p>
					</li>
					<li>
						<p>
                            In rare cases, like embedded or custom OpenGL drivers.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        64-bit IEEE-754 double
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 8 bytes.
						</p>
					</li>
					<li>
						<p>
                            Non-standard case.
						</p>
					</li>
					<li>
						<p>
                            Would require headers redefining 
                            <code>GLfloat</code>
                            &nbsp;as 
                            <code>double</code>
                            , not compliant with spec.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            C layout ‚âà 
            <code>std430</code>
            &nbsp;only if you manually match packing and alignment. Otherwise, it‚Äôs platform-dependent.
		</p>
	</li>
</ul>
<p
	class="table" >
    | GLSL type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| C equivalent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Typical C (x86_64) - Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Typical C (x86_64) - Size | Typical C (x86_64) - Stride |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std140 - Base Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std140 - Occupied Size |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std140 - Stride | std430 - Base Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std430 - Occupied Size |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std430 - Stride |
    <br>
    | -------------------------------- | --------------------------------------------------- | -----------------------------: | -----------------------------------: | --------------------------: | -----------------------------------------------------------------------------------------: | ------------------------------------: | ---------------------------------------: | ----------------------: | ----------------------------------------------------: | ------------------------------------------: |
    <br>
    | 
    <code>bool</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| C 
    <code>_Bool</code>
    &nbsp;(native) ‚Äî or use 
    <code>int32_t</code>
    &nbsp;to match GLSL |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 | 16 (std140 rounds scalar arrays to vec4) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>int</code>
    &nbsp;/ 
    <code>uint</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>int32_t</code>
    &nbsp;/ 
    <code>uint32_t</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>float</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>double</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>double</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 (rounded to dvec4 alignment) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |
    <br>
    | 
    <code>vec2</code>
    &nbsp;/ 
    <code>ivec2</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[2]</code>
    &nbsp;/ 
    <code>int32_t[2]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |
    <br>
    | 
    <code>vec3</code>
    &nbsp;/ 
    <code>ivec3</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[3]</code>
    &nbsp;/ 
    <code>int32_t[3]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>vec4</code>
    &nbsp;/ 
    <code>ivec4</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[4]</code>
    &nbsp;/ 
    <code>int32_t[4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>dvec2</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[2]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>dvec3</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[3]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |
    <br>
    | 
    <code>dvec4</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |
    <br>
    | 
    <code>mat2</code>
    &nbsp;(2√ó2 float, column-major) | 
    <code>float[2][2]</code>
    &nbsp;(2 columns of 
    <code>vec2</code>
    )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 2 = 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 √ó 2 = 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec2 as stride (8) |
    <br>
    | 
    <code>mat3</code>
    &nbsp;(3√ó3 float, column-major) | 
    <code>float[3][3]</code>
    &nbsp;(3 columns of 
    <code>vec3</code>
    )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 36 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 3 = 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 3 = 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each column has vec3 as stride (16) |
    <br>
    | 
    <code>mat4</code>
    &nbsp;(4√ó4 float)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float[4][4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 x 4 = 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 √ó 4 = 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each column has vec4 as stride (16) |
    <br>
    | 
    <code>T[]</code>
    &nbsp;(Array of T)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>T[]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alignof(T) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(T) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(T) | base_align(T), rounded up to vec4 base align (16 for 32-bit scalars; 32 for 64-bit/double) | occupied per element = rounded stride |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base_align(T), rounded up to 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_align(T) | occupied per element = sizeof(T) rounded to alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_align(T) |
    <br>
    | 
    <code>vec3[]</code>
    &nbsp;(Array of vec3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float[3][]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>struct</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>struct { ... }</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(member alignment) | struct size padded to that alignment |&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct) (padded) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(member align) rounded up to vec4 (16) |&nbsp;&nbsp;struct size padded to multiple of 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(struct) rounded up to 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max(member align) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct size padded to that alignment | sizeof(struct) (padded to member alignment) |
</p>
<h5
	id="scalar-alignment" >
    Scalar Alignment
</h5>
<ul>
	<li>
		<p>
            Looks like 
			<em>
                std430
			</em>
            , but its vectors are even more compact?
		</p>
	</li>
	<li>
		<p>
            Also known as (?) The spec doesn't say.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#EXT_scalar_block_layout" 
				class="external-link" 
				target="_blank" >
                <code>EXT_scalar_block_layout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.2.
				</p>
			</li>
			<li>
				<p>
                    This extension allows most storage types to be aligned in 
                    <code>scalar</code>
                    &nbsp;alignment.
				</p>
			</li>
			<li>
				<p>
                    Make sure to set 
                    <code>--scalar-block-layout</code>
                    &nbsp;when running the SPIR-V Validator.
				</p>
			</li>
			<li>
				<p>
                    A big difference is being able to straddle the 16-byte boundary.
				</p>
			</li>
			<li>
				<p>
                    In GLSL this can be used with 
                    <code>scalar</code>
                    &nbsp;keyword and extension
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="extended-alignment-std140" >
    Extended Alignment (std140)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.oreilly.com/library/view/opengl-programming-guide/9780132748445/app09lev1sec2.html" 
				class="external-link" 
				target="_blank" >
                Source
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Conservative, padded layout used for uniform blocks.
		</p>
	</li>
	<li>
		<p>
            Widely supported.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Caveats
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Avoiding usage of vec3&quot;
				</p>
				<ul>
					<li>
						<p>
                            Usually applies to std140, because some hardware vendors seem to not follow the spec strictly. Although, everything should work when using std430.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Array of 
                                <code>vec3</code>
                                &nbsp;(ARRAY)
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Alignment will be 4x of a 
                                    <code>float</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Size will be 
                                    <code>alignment * amount of elements</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">// Scalars
&nbsp;&nbsp;&nbsp;&nbsp;float -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp; -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;
// Vectors
&nbsp;&nbsp;&nbsp;&nbsp;// Base alignments
&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;&nbsp;-&gt;&nbsp;&nbsp;8 bytes&nbsp;&nbsp;// 2 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;
// Arrays
&nbsp;&nbsp;&nbsp;&nbsp;// Size of the element type, rounded up to a multiple of the size of `vec4` (behave like `vec4` slots).
&nbsp;&nbsp;&nbsp;&nbsp;// Arrays of types are not necessarily tightly packed.
&nbsp;&nbsp;&nbsp;&nbsp;// An array of floats in such a block will not be the equivalent to an array of floats in C/C++. Arrays will only match their C/C++ definitions if the type is a multiple of 16 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;// Ex: `float arr[N]` uses 16 bytes per element.

// Matrices
&nbsp;&nbsp;&nbsp;&nbsp;// Treated as arrays of vectors. 
&nbsp;&nbsp;&nbsp;&nbsp;// They are column-major by default; you can change it with `layout(row_major)` or `layout(column_major)`.

// Struct
&nbsp;&nbsp;&nbsp;&nbsp;// The biggest struct member, rounded up to multiples of the size of `vec4` (behave like `vec4` slots).
&nbsp;&nbsp;&nbsp;&nbsp;// Struct members are effectively padded so that each member starts on a 16-byte boundary when necessary.
&nbsp;&nbsp;&nbsp;&nbsp;// The struct size will be the space needed by its members.
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">layout(std140) uniform U { float a[3]; }; // size = 3 * 16 = 48 bytes
</code></pre>
	</li>
</ul>
<h5
	id="base-alignment-std430" >
    Base Alignment (std430)
</h5>
<ul>
	<li>
		<p>
			<strong>
                Allowed usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    SSBOs, Push Constants.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#KHR_uniform_buffer_standard_layout" 
						class="external-link" 
						target="_blank" >
                        <code>KHR_uniform_buffer_standard_layout</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Core in Vulkan 1.2.
						</p>
					</li>
					<li>
						<p>
                            Allows the use of 
                            <code>std430</code>
                            &nbsp;memory layout in UBOs.
						</p>
					</li>
					<li>
						<p>
                            These memory layout changes are only applied to 
                            <code>Uniforms</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#KHR_relaxed_block_layout" 
						class="external-link" 
						target="_blank" >
                        <code>KHR_relaxed_block_layout</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Core in Vulkan 1.1; all Vulkan 1.1+ devices support relaxed block layout.
						</p>
					</li>
					<li>
						<p>
                            This extension allows implementations to indicate they can support more variation in block 
                            <code>Offset</code>
                            &nbsp;decorations.
						</p>
					</li>
					<li>
						<p>
                            This comes up when using 
                            <code>std430</code>
                            &nbsp;memory layout where a 
                            <code>vec3</code>
                            &nbsp;(which is 12 bytes) is still defined as a 16 byte alignment.
						</p>
					</li>
					<li>
						<p>
                            With relaxed block layout an application can fit a 
                            <code>float</code>
                            &nbsp;on either side of the 
                            <code>vec3</code>
                            &nbsp;and maintain the 16 byte alignment between them.
						</p>
					</li>
					<li>
						<p>
                            Currently there is no way in GLSL to legally express relaxed block layout, but a developer can use the 
                            <code>--hlsl-offsets</code>
                            &nbsp;with 
                            <code>glslang</code>
                            &nbsp;to produce the desired offsets.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Relaxed layout used for shader-storage blocks and allows much tighter packing.
		</p>
	</li>
	<li>
		<p>
            Requires newer GLSL 4.3+ or equivalent support.
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">// Scalars
&nbsp;&nbsp;&nbsp;&nbsp;float -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp; -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;
// Vectors
&nbsp;&nbsp;&nbsp;&nbsp;// Base alignments
&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;&nbsp;-&gt;&nbsp;&nbsp;8 bytes&nbsp;&nbsp;// 2 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;
// Arrays
&nbsp;&nbsp;&nbsp;&nbsp;// array stride is the natural alignment of the element. 
&nbsp;&nbsp;&nbsp;&nbsp;// Ex: `float arr[N]` uses 4 bytes per element.

// Matrices
&nbsp;&nbsp;&nbsp;&nbsp;// Treated as arrays of vectors. 
&nbsp;&nbsp;&nbsp;&nbsp;// They are column-major by default; you can change it with `layout(row_major)` or `layout(column_major)`.
&nbsp;&nbsp;&nbsp;&nbsp;
// Struct
&nbsp;&nbsp;&nbsp;&nbsp;// Struct packing is tighter and follows natural alignments (less padding).
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, binding=0) buffer B { float a[3]; }; // size = 3 * 4 = 12 bytes
</code></pre>
	</li>
</ul>
<h3
	id="comparisons" >
    Comparisons
</h3>
<ul>
	<li>
		<p>
			<strong>
                Input Attributes vs Uniform Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;If you want a shader to access a resource that is 
					<em>
                        not
					</em>
                    &nbsp;on vertex buffers, they must go through a descriptor set&quot;.
				</p>
			</li>
			<li>
				<p>
                    With Vertex Buffers we can pass arbitrary attributes to the vertex shader for each vertex.
				</p>
			</li>
			<li>
				<p>
                    Including global variables as vertex data would be a waste of memory, and it would require us to update the vertex buffer whenever the transformation changes.
				</p>
			</li>
			<li>
				<p>
                    The right way to tackle this in Vulkan is to use Resource Descriptors
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Uniform Buffers vs Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ChatGPT...
				</p>
			</li>
			<li>
				<p>
                    &quot;Lets say I want to send the time, would it be optimal to send it as a ubo or a push constant? The time should not change between draw calls (it's irrelevant) in the same frame. Seems like a UBO I only need to set it once and every object would benefit from it, but a push constant needs to be send for every object?&quot;
				</p>
				<ul>
					<li>
						<p>
                            Exactly. For your ‚Äútime‚Äù value, a Uniform Buffer is generally the more optimal choice in this scenario.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Push Constants
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You must call 
                                    <code>vkCmdPushConstants</code>
                                    &nbsp;for each command buffer section where shaders need it.
								</p>
							</li>
							<li>
								<p>
                                    Since push constants are set per draw/dispatch scope, if you have many objects, you‚Äôd be redundantly re-sending the same value (time) multiple times in the same frame.
								</p>
							</li>
							<li>
								<p>
                                    There‚Äôs no automatic ‚Äúshared‚Äù state ‚Äî every pipeline that uses it must get the value pushed explicitly.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Uniform Buffers
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You can store the time in a uniform buffer once per frame, bind it once in a descriptor set, and then every draw call will see the same value without re-uploading.
								</p>
							</li>
							<li>
								<p>
                                    Works well for ‚Äúglobal‚Äù frame data (view/proj matrices, time, frame index, etc.).
								</p>
							</li>
							<li>
								<p>
                                    Binding a pre-allocated UBO in a descriptor set has low overhead and avoids per-draw constant pushing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Performance implication:
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    If the data is the same for all draws in a frame, a UBO avoids redundant driver calls and state changes, and makes it easier to keep the command buffer lean. Push constants are better suited for per-object or per-draw small data.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Storage Image vs. Storage Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    While both storage images and storage buffers allow for read-write access in shaders, they have different use cases:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Storage Images
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Ideal for 2D or 3D data that benefits from texture operations like filtering or addressing modes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Storage Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Better for arbitrary structured data or when you need to access data in a non-uniform pattern.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Texel Buffer vs. Storage Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Texel buffers and storage buffers also have different strengths:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Texel Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Provide texture-like access to buffer data, allowing for operations like filtering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Storage Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            More flexible for general-purpose data storage and manipulation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Do keep constant data small, where 128 bytes is a good rule of thumb.
				</p>
			</li>
			<li>
				<p>
                    Do use push constants if you do not want to set up a descriptor set/UBO system.
				</p>
			</li>
			<li>
				<p>
                    Do make constant data directly available in the shader if it is pre-determinable, such as with the use of specialization constants.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Avoid
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Avoid indexing in the shader if possible, such as dynamically indexing into 
                    <code>buffer</code>
                    &nbsp;or 
                    <code>uniform</code>
                    &nbsp;arrays, as this can disable shader optimisations in some platforms.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Failing to use the correct method of constant data will negatively impact performance, causing either reduced FPS and/or increased BW and load/store activity.
				</p>
			</li>
			<li>
				<p>
                    On Mali, register mapped uniforms are effectively free. Any spilling to buffers in memory will increase load/store cache accesses to the per thread uniform fetches.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="input-attributes" >
    Input Attributes
</h3>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            The only shader stage in core Vulkan that has an input attribute controlled by Vulkan is the vertex shader stage (
            <code>SHADER_STAGE_VERTEX</code>
            ).
		</p>
<pre><code class="language-glsl" data-lang="glsl">#version 450
layout(location = 0) in vec3 inPosition;

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position = vec4(inPosition, 1.0);
}
</code></pre>
	</li>
	<li>
		<p>
            Other shader stages, such as a fragment shader stage, have input attributes, but the values are determined from the output of the previous stages run before it.
		</p>
	</li>
	<li>
		<p>
            This involves declaring the interface slots when creating the 
            <code>VkPipeline</code>
            &nbsp;and then binding the 
            <code>VkBuffer</code>
            &nbsp;before draw time with the data to map.
		</p>
	</li>
	<li>
		<p>
            Before calling 
            <code>vkCreateGraphicsPipelines</code>
            &nbsp;a 
            <code>VkPipelineVertexInputStateCreateInfo</code>
            &nbsp;struct will need to be filled out with a list of 
            <code>VkVertexInputAttributeDescription</code>
            &nbsp;mappings to the shader.
		</p>
<pre><code class="language-c" data-lang="c">VkVertexInputAttributeDescription input = {};
input.location = 0;
input.binding&nbsp;&nbsp;= 0;
input.format&nbsp;&nbsp; = FORMAT_R32G32B32_SFLOAT; // maps to vec3
input.offset&nbsp;&nbsp; = 0;
</code></pre>
	</li>
	<li>
		<p>
            The only thing left to do is bind the vertex buffer and optional index buffer prior to the draw call.
		</p>
<pre><code class="language-c" data-lang="c">vkBeginCommandBuffer();
// ...
vkCmdBindVertexBuffer();
vkCmdDraw();
// ...
vkCmdBindVertexBuffer();
vkCmdBindIndexBuffer();
vkCmdDrawIndexed();
// ...
vkEndCommandBuffer();
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxVertexInputAttributes</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxVertexInputAttributeOffset</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-layout" >
    Memory Layout
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250908081102.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081144.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081235.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Single binding.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081301.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    One binding per attribute.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            One binding or many bindings? It doesn't matter that much. In some cases one is better, etc, don't worry too much about it.
		</p>
	</li>
</ul>
<h5
	id="vertex-input-binding-vertex-buffer" >
    Vertex Input Binding / Vertex Buffer
</h5>
<ul>
	<li>
		<p>
            Tell Vulkan how to pass this data format to the vertex shader once it's been uploaded into GPU memory
		</p>
	</li>
	<li>
		<p>
            A vertex binding describes at which rate to load data from memory throughout the vertices.
		</p>
	</li>
	<li>
		<p>
            It specifies the number of bytes between data entries and whether to move to the next data entry after each vertex or after each instance.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputBindingDescription.html" 
				class="external-link" 
				target="_blank" >
                <code>VkVertexInputBindingDescription</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>binding</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the index of the binding in the array of bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>stride</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the number of bytes from one entry to the next.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>inputRate</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>VERTEX_INPUT_RATE_VERTEX</code>
						</p>
						<ul>
							<li>
								<p>
                                    Move to the next data entry after each vertex.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VERTEX_INPUT_RATE_INSTANCE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Move to the next data entry after each instance.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            We're not going to use instanced rendering, so we'll stick to per-vertex data.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputAttributeDescription.html" 
				class="external-link" 
				target="_blank" >
                <code>VkVertexInputAttributeDescription</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Describes how to handle vertex input.
				</p>
			</li>
			<li>
				<p>
                    An attribute description struct describes how to extract a vertex attribute from a chunk of vertex data originating from a binding description.
				</p>
			</li>
			<li>
				<p>
                    We have two attributes, position and color, so we need two attribute description structs.
				</p>
			</li>
			<li>
				<p>
                    <code>binding</code>
				</p>
				<ul>
					<li>
						<p>
                            Tells Vulkan from which binding the per-vertex data comes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>location</code>
				</p>
				<ul>
					<li>
						<p>
                            References the 
                            <code>location</code>
                            &nbsp;directive of the input in the vertex shader.
						</p>
						<ul>
							<li>
								<p>
                                    The input in the vertex shader with location 
                                    <code>0</code>
                                    &nbsp;is the position, which has two 32-bit float components.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>format</code>
				</p>
				<ul>
					<li>
						<p>
                            Describes the type of data for the attribute.
						</p>
					</li>
					<li>
						<p>
                            Implicitly defines the byte size of attribute data.
						</p>
					</li>
					<li>
						<p>
                            A bit confusingly, the formats are specified using the same enumeration as color formats.
						</p>
					</li>
					<li>
						<p>
                            The following shader types and formats are commonly used together:
						</p>
						<ul>
							<li>
								<p>
                                    <code>float</code>
                                    : 
                                    <code>FORMAT_R32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec2</code>
                                    : 
                                    <code>FORMAT_R32G32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec3</code>
                                    : 
                                    <code>FORMAT_R32G32B32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec4</code>
                                    : 
                                    <code>FORMAT_R32G32B32A32_SFLOAT</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            As you can see, you should use the format where the amount of color channels matches the number of components in the shader data type.
						</p>
					</li>
					<li>
						<p>
                            It is allowed to use more channels than the number of components in the shader, but they will be silently discarded.
						</p>
						<ul>
							<li>
								<p>
                                    If the number of channels is lower than the number of components, then the BGA components will use default values of 
                                    <code>(0, 0, 1)</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The color type (
                            <code>SFLOAT</code>
                            , 
                            <code>UINT</code>
                            , 
                            <code>SINT</code>
                            ) and bit width should also match the type of the shader input. See the following examples:
						</p>
						<ul>
							<li>
								<p>
                                    <code>ivec2</code>
                                    : 
                                    <code>FORMAT_R32G32_SINT</code>
                                    , a 2-component vector of 32-bit signed integers
								</p>
							</li>
							<li>
								<p>
                                    <code>uvec4</code>
                                    : 
                                    <code>FORMAT_R32G32B32A32_UINT</code>
                                    , a 4-component vector of 32-bit unsigned integers
								</p>
							</li>
							<li>
								<p>
                                    <code>double</code>
                                    : 
                                    <code>FORMAT_R64_SFLOAT</code>
                                    , a double-precision (64-bit) float
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>offset</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the number of bytes since the start of the per-vertex data to read from.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Graphics Pipeline Vertex Input Binding
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    For the following vertices:
				</p>
<pre><code class="language-odin" data-lang="odin">Vertex :: struct {
¬† ¬† pos: ¬† eng.Vec2,
¬† ¬† color: eng.Vec3,
}

vertices := [?]Vertex{
¬† ¬† { { ¬†0.0, -0.5 }, { 1.0, 0.0, 0.0 } },
¬† ¬† { { ¬†0.5, ¬†0.5 }, { 0.0, 1.0, 0.0 } },
¬† ¬† { { -0.5, ¬†0.5 }, { 0.0, 0.0, 1.0 } },
}
</code></pre>
			</li>
			<li>
				<p>
                    We setup this in the Graphics Pipeline creation:
				</p>
<pre><code class="language-odin" data-lang="odin">vertex_binding_descriptor := vk.VertexInputBindingDescription{
&nbsp;&nbsp;&nbsp;&nbsp;binding ¬† = 0,
&nbsp;&nbsp;&nbsp;&nbsp;stride ¬† ¬†= size_of(Vertex),
&nbsp;&nbsp;&nbsp;&nbsp;inputRate = .VERTEX,
}
vertex_attribute_descriptor := [?]vk.VertexInputAttributeDescription{
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binding ¬†= 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format ¬† = .R32G32_SFLOAT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset ¬† = cast(u32)offset_of(Vertex, pos),
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binding ¬†= 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format ¬† = .R32G32B32_SFLOAT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset ¬† = cast(u32)offset_of(Vertex, color),
&nbsp;&nbsp;&nbsp;&nbsp;},
}
vertex_input_create_info := vk.PipelineVertexInputStateCreateInfo {
&nbsp;&nbsp;&nbsp;&nbsp;sType ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† = .PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;vertexBindingDescriptionCount ¬† = 1,
&nbsp;&nbsp;&nbsp;&nbsp;pVertexBindingDescriptions ¬† ¬† ¬†= &vertex_binding_descriptor,
&nbsp;&nbsp;&nbsp;&nbsp;vertexAttributeDescriptionCount = len(vertex_attribute_descriptor),
&nbsp;&nbsp;&nbsp;&nbsp;pVertexAttributeDescriptions ¬† ¬†= &vertex_attribute_descriptor[0],
}
</code></pre>
			</li>
			<li>
				<p>
                    The pipeline is now ready to accept vertex data in the format of the 
                    <code>vertices</code>
                    &nbsp;container and pass it on to our vertex shader.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Vertex Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If you run the program now with validation layers enabled, you'll see that it complains that there is no vertex buffer bound to the binding.
				</p>
			</li>
			<li>
				<p>
                    The next step is to create a vertex buffer and move the vertex data to it so the GPU is able to access it.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Creating
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Follow the tutorial for creating a buffer, specifying 
                            <code>BUFFER_USAGE_VERTEX_BUFFER</code>
                            &nbsp;as the 
                            <code>BufferCreateInfo</code>
                            &nbsp;
                            <code>usage</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="index-buffer" >
    Index Buffer
</h5>
<ul>
	<li>
		<p>
			<strong>
                Motivation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Drawing a rectangle takes two triangles, which means that we need a vertex buffer with six vertices. The problem is that the data of two vertices needs to be duplicated, resulting in redundancies.
				</p>
			</li>
			<li>
				<p>
                    The solution to this problem is to use an index buffer.
				</p>
			</li>
			<li>
				<p>
                    An index buffer is essentially an array of pointers into the vertex buffer.
				</p>
			</li>
			<li>
				<p>
                    It allows you to reorder the vertex data, and reuse existing data for multiple vertices.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250806072114.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            The first three indices define the upper-right triangle, and the last three indices define the vertices for the bottom-left triangle.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It is possible to use either 
                    <code>uint16_t</code>
                    &nbsp;or 
                    <code>uint32_t</code>
                    &nbsp;for your index buffer depending on the number of entries in 
                    <code>vertices</code>
                    . We can stick to 
                    <code>uint16_t</code>
                    &nbsp;for now because we‚Äôre using less than 65535 unique vertices.
				</p>
			</li>
			<li>
				<p>
                    Just like the vertex data, the indices need to be uploaded into a 
                    <code>VkBuffer</code>
                    &nbsp;for the GPU to be able to access them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Creating
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Follow the tutorial for creating a buffer, specifying 
                    <code>BUFFER_USAGE_INDEX_BUFFER</code>
                    &nbsp;as the 
                    <code>BufferCreateInfo</code>
                    &nbsp;
                    <code>usage</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Using
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We first need to bind the index buffer, just like we did for the vertex buffer.
				</p>
			</li>
			<li>
				<p>
                    The difference is that you can only have a 
					<strong>
                        single
					</strong>
                    &nbsp;index buffer. It‚Äôs unfortunately not possible to use different indices for each vertex attribute, so we do still have to completely duplicate vertex data even if just one attribute varies.
				</p>
			</li>
			<li>
				<p>
                    An index buffer is bound with 
                    <code>vkCmdBindIndexBuffer</code>
                    &nbsp;which has the index buffer, a byte offset into it, and the type of index data as parameters.
				</p>
				<ul>
					<li>
						<p>
                            As mentioned before, the possible types are 
                            <code>INDEX_TYPE_UINT16</code>
                            &nbsp;and 
                            <code>INDEX_TYPE_UINT32</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Just binding an index buffer doesn‚Äôt change anything yet, we also need to change the drawing command to tell Vulkan to use the index buffer.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Remove
					</em>
                    &nbsp;the 
                    <code>vkCmdDraw</code>
                    &nbsp;line and replace it with 
                    <code>vkCmdDrawIndexed</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="push-constants" >
    Push Constants
</h3>
<ul>
	<li>
		<p>
            A Push Constant is a small bank of values accessible in shaders.
		</p>
	</li>
	<li>
		<p>
            These are designed for small amount (a few dwords) of high frequency data to be updated per-recording of the command buffer.
		</p>
	</li>
	<li>
		<p>
            So that the shader can understand where this data will be sent, we specify a special push constants 
            <code>&lt;layout&gt;</code>
            &nbsp;in our shader code.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(push_constant) uniform MeshData {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 model;
} mesh_data;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Choosing to use Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In early implementations of Vulkan on Arm Mali, this was usually the fastest way of pushing data to your shaders. In more recent times, we have observed on Mali devices that 
					<em>
                        overall
					</em>
                    &nbsp;they can be slower. If performance is something you are trying to maximise on Mali devices, descriptor sets may be the way to go. However, other devices may still favour push constants.
				</p>
			</li>
			<li>
				<p>
                    Having said this, descriptor sets are one of the more complex features of Vulkan, making the convenience of push constants still worth considering as a go-to method, especially if working with trivial data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxPushConstantsSize</code>
				</p>
				<ul>
					<li>
						<p>
                            guaranteed at least 
                            <code>128</code>
                            &nbsp;bytes on all devices.
						</p>
					</li>
					<li>
						<p
							class="line-emphasis" >
                            If you're using Vulkan 1.4 the minimum was increased to 256.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/push_constants.html#push-constants" 
				class="external-link" 
				target="_blank" >
                Push Constants
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="offsets" >
    Offsets
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250829073932.png" width="525" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">layout(push_constant, std430) uniform pc {
&nbsp;&nbsp;&nbsp;&nbsp;layout(offset = 32) vec4 data;
};

layout(location = 0) out vec4 outColor;

void main() {
&nbsp;&nbsp; outColor = data;
}
</code></pre>
<pre><code class="language-c" data-lang="c">VkPushConstantRange range = {};
range.stageFlags = SHADER_STAGE_FRAGMENT;
range.offset = 32;
range.size = 16;
</code></pre>
	</li>
</ul>
<h5
	id="updating" >
    Updating
</h5>
<ul>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Push constants can be incrementally updated over the course of a command buffer.
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">// vkBeginCommandBuffer()
vkCmdBindPipeline();
vkCmdPushConstants(offset: 0, size: 16, value = [0, 0, 0, 0]);
vkCmdDraw(); // values = [0, 0, 0, 0]

vkCmdPushConstants(offset: 4, size: 8, value = [1 ,1]);
vkCmdDraw(); // values = [0, 1, 1, 0]

vkCmdPushConstants(offset: 8, size: 8, value = [2, 2]);
vkCmdDraw(); // values = [0, 1, 2, 2]
// vkEndCommandBuffer()
</code></pre>
		<ul>
			<li>
				<p>
                    Interesting how old values are kept. Values that were not changed are preserved.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="lifetime" >
    Lifetime
</h5>
<ul>
	<li>
		<p>
            <code>vkCmdPushConstants</code>
            &nbsp;is tied to the 
            <code>VkPipelineLayout</code>
            &nbsp;usage and therefore why they must match before a call to a command such as 
            <code>vkCmdDraw()</code>
            .
		</p>
	</li>
	<li>
		<p>
            Because push constants are not tied to descriptors, the use of 
            <code>vkCmdBindDescriptorSets</code>
            &nbsp;has no effect on the lifetime or 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#descriptorsets-compatibility" 
				class="external-link" 
				target="_blank" >
                pipeline layout compatibility
			</a>
            &nbsp;of push constants.
		</p>
	</li>
	<li>
		<p>
            The same way it is possible to bind descriptor sets that are never used by the shader, the same is true for push constants.
		</p>
	</li>
</ul>
<h5
	id="cpu-performance" >
    CPU Performance
</h5>
<ul>
	<li>
		<p>
            Push one struct once per draw instead of many separate vkCmdPushConstants calls (one call writing a small struct is far cheaper).
		</p>
	</li>
	<li>
		<p>
            Many small state changes cause the driver to update internal tables, validate, or patch commands ‚Äî that‚Äôs CPU work and cannot be avoided without batching.
		</p>
	</li>
	<li>
		<p>
			<em>
                Observations
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    5 push calls were taking 7.65us. I groupped all them in 1 single push call, now taking 3.08us.
				</p>
			</li>
			<li>
				<p>
                    This was substancial, as at the time I was issuing this push calls hundreds of time per frame; I later reduced this number, but anyway, could be significant.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="descriptors-sets" >
    Descriptors Sets
</h3>
<h4
	id="about" >
    About
</h4>
<ul>
	<li>
		<p>
            <code>VkDescriptorSet</code>
		</p>
	</li>
	<li>
		<p>
            One Descriptor -&gt; One Resource.
		</p>
	</li>
	<li>
		<p>
            They are always organized in Descriptor Sets.
		</p>
		<ul>
			<li>
				<p>
                    One or more descriptors contained.
				</p>
			</li>
			<li>
				<p>
                    Combine descriptors which are used in conjunction.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A handle or pointer into a resource.
		</p>
		<ul>
			<li>
				<p>
                    Note that is not just a pointer, but a pointer + metadata.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A core mechanism used to bind resources to shaders.
		</p>
	</li>
	<li>
		<p>
            Holds the binding information that connects shader inputs to data such as 
            <code>VkBuffer</code>
            &nbsp;resources and 
            <code>VkImage</code>
            &nbsp;textures.
		</p>
	</li>
	<li>
		<p>
            Think of it as a set of GPU-side pointers that you bind once.
		</p>
	</li>
	<li>
		<p>
            The internal representation of a descriptor set is whatever the driver wants it to be.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/" 
				class="external-link" 
				target="_blank" >
                Article by Arseny Kapoulkine
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/descriptor_management/README.html" 
				class="external-link" 
				target="_blank" >
                Sample talking about best practices
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Content
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Where to find a Resource.
				</p>
			</li>
			<li>
				<p>
                    Usage type of a Resource.
				</p>
			</li>
			<li>
				<p>
                    Offsets, sometimes.
				</p>
			</li>
			<li>
				<p>
                    Some metadata, sometimes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250813080426.png" width="500" >
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Note - only set 0 and 2 are used in this shader
layout(set = 0, binding = 0) uniform sampler2D myTextureSampler;

layout(set = 0, binding = 2) uniform uniformBuffer0 {
&nbsp;&nbsp;&nbsp;&nbsp;float someData;
} ubo_0;

layout(set = 0, binding = 3) uniform uniformBuffer1 {
&nbsp;&nbsp;&nbsp;&nbsp;float moreData;
} ubo_1;

layout(set = 2, binding = 0) buffer storageBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float myResults;
} ssbo;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                API
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/screenshot_2025-08-06_162739.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250807073221.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxBoundDescriptorSets</code>
				</p>
			</li>
			<li>
				<p>
                    Per stage limit
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorSamplers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorUniformBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorStorageBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorSampledImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorStorageImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorInputAttachments</code>
				</p>
			</li>
			<li>
				<p>
                    Per type limit
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageResources</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetSamplers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetUniformBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetUniformBuffersDynamic</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageBuffersDynamic</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetSampledImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetInputAttachments</code>
				</p>
			</li>
			<li>
				<p>
                    <code>VkPhysicalDeviceDescriptorIndexingProperties</code>
                    &nbsp;if using 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/EXT_descriptor_indexing.html#EXT_descriptor_indexing" 
						class="external-link" 
						target="_blank" >
                        Descriptor Indexing
					</a>
				</p>
			</li>
			<li>
				<p>
                    <code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>
                    &nbsp;if using 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/EXT_inline_uniform_block.html#EXT_inline_uniform_block" 
						class="external-link" 
						target="_blank" >
                        Inline Uniform Block
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=d5p44idnZLQ" 
				class="external-link" 
				target="_blank" >
                Visual explanation {0:00 -&gt; 5:35}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Nice.
				</p>
			</li>
			<li>
				<p>
                    The rest of the video is meh.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="difficulties" >
    Difficulties
</h5>
<ul>
	<li>
		<p>
			<strong>
                Problems
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;They are not bad but they very much force a specific rendering style: you have triple / quadrupled nested for loops, binding your things based on usage and then rebind descriptor sets as needed.&quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;Many of us are moving towards bindless rendering, where you just bind everything once in one big descriptor set, and then index into it at will; tho, Vulkan 1.0 does not greatly support, and also the descriptor count for it was quite low&quot;.
				</p>
			</li>
			<li>
				<p>
                    Cannot update descriptors after binding in a command buffer.
				</p>
			</li>
			<li>
				<p>
                    All descriptors must be valid, even if not used.
				</p>
			</li>
			<li>
				<p>
                    Descriptor arrays must be sampled uniformly.
				</p>
				<ul>
					<li>
						<p>
                            Different invocations can‚Äôt use different indices.
						</p>
					</li>
					<li>
						<p>
                            Can sample ‚Äúdynamically uniform‚Äù, e.g. runtime-based index.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Upper limit on descriptor counts.
				</p>
			</li>
			<li>
				<p>
                    Discourages GPU-driven rendering architectures.
				</p>
				<ul>
					<li>
						<p>
                            Due to the need to set up descriptor sets per draw call it‚Äôs hard to adapt any of the aforementioned schemes to GPU-based culling or command submission.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solutions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Descriptor Indexing
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Available in 1.3, optional in 1.2, or 
                            <code>EXT_descriptor_indexing</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Update descriptors after binding.
						</p>
					</li>
					<li>
						<p>
                            Update unused descriptors.
						</p>
					</li>
					<li>
						<p>
                            Relax requirement that all descriptors must be valid, even if unused.
						</p>
					</li>
					<li>
						<p>
                            Non-uniform array indexing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Buffer Device Address
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Available in 1.3, optional in 1.2, or 
                            <code>KHR_buffer_device_address</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Directly access buffers through addresses without a descriptor.
						</p>
					</li>
					<li>
						<p>
                            See [[#Physical Storage Buffer]] below.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Descriptor Buffers ‚Äì EXT_descriptor_buffer
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Manage descriptors directly.
						</p>
					</li>
					<li>
						<p>
                            <s>Similar to D3D12‚Äôs descriptor model </s>.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="allocation" >
    Allocation
</h4>
<ul>
	<li>
		<p>
            A scheme that works well is to use free lists of descriptor set pools; whenever you need a descriptor set pool, you allocate one from the free list and use it for subsequent descriptor set allocations in the current frame on the current thread. Once you run out of descriptor sets in the current pool, you allocate a new pool. Any pools that were used in a given frame need to be kept around; once the frame has finished rendering, as determined by the associated fence objects, the descriptor set pools can reset via 
            <code>vkResetDescriptorPool</code>
            &nbsp;and returned to free lists. While it‚Äôs possible to free individual descriptors from a pool via 
            <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
            , this complicates the memory management on the driver side and is not recommended.
		</p>
	</li>
	<li>
		<p>
            When a descriptor set pool is created, application specifies the maximum number of descriptor sets allocated from it, as well as the maximum number of descriptors of each type that can be allocated from it. In Vulkan 1.1, the application doesn‚Äôt have to handle accounting for these limits ‚Äì it can just call vkAllocateDescriptorSets and handle the error from that call by switching to a new descriptor set pool. Unfortunately, in Vulkan 1.0 without any extensions, it‚Äôs an error to call vkAllocateDescriptorSets if the pool does not have available space, so application must track the number of sets and descriptors of each type to know beforehand when to switch to a different pool.
		</p>
	</li>
	<li>
		<p>
            Different pipeline objects may use different numbers of descriptors, which raises the question of pool configuration. A straightforward approach is to create all pools with the same configuration that uses the worst-case number of descriptors for each type ‚Äì for example, if each set can use at most 16 texture and 8 buffer descriptors, one can allocate all pools with maxSets=1024, and pool sizes 16
			<em>
                1024 for texture descriptors and 8
			</em>
            1024 for buffer descriptors. This approach can work but in practice it can result in very significant memory waste for shaders with different descriptor count ‚Äì you can‚Äôt allocate more than 1024 descriptor sets out of a pool with the aforementioned configuration, so if most of your pipeline objects use 4 textures, you‚Äôll be wasting 75% of texture descriptor memory.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Strategies
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Two alternatives that provide a better balance memory use:
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    Measure an average number of descriptors used in a shader pipeline per type for a characteristic scene and allocate pool sizes accordingly. For example, if in a given scene we need 3000 descriptor sets, 13400 texture descriptors, and 1700 buffer descriptors, then the average number of descriptors per set is 4.47 textures (rounded up to 5) and 0.57 buffers (rounded up to 1), so a reasonable configuration of a pool is maxSets=1024, 5*1024 texture descriptors, 1024 buffer descriptors. When a pool is out of descriptors of a given type, we allocate a new one ‚Äì so this scheme is guaranteed to work and should be reasonably efficient on average.
				</p>
			</li>
			<li>
				<p>
                    Group shader pipeline objects into size classes, approximating common patterns of descriptor use, and pick descriptor set pools using the appropriate size class. This is an extension of the scheme described above to more than one size class. For example, it‚Äôs typical to have large numbers of shadow/depth prepass draw calls, and large numbers of regular draw calls in a scene ‚Äì but these two groups have different numbers of required descriptors, with shadow draw calls typically requiring 0 to 1 textures per set and 0 to 1 buffers when dynamic buffer offsets are used. To optimize memory use, it‚Äôs more appropriate to allocate descriptor set pools separately for shadow/depth and other draw calls. Similarly to general-purpose allocators that can have size classes that are optimal for a given application, this can still be managed in a lower-level descriptor set management layer as long as it‚Äôs configured with application specific descriptor set usages beforehand.
				</p>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            Descriptors are like pointers, so as any pointer they need to allocate space to live ahead of time.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How many
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Its possible to have 1 very big descriptor pool that handles the entire engine, but that means we need to know what descriptors we will be using for everything ahead of time.
				</p>
			</li>
			<li>
				<p>
                    That can be very tricky to do at scale. Instead, we will keep it simpler, and we will have 
					<em>
                        multiple descriptor pools for different parts of the project
					</em>
                    , and try to be more accurate with them.
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            I don't know what that actually means in practice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPool.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorPool</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Maintains a pool of descriptors, from which descriptor sets are allocated.
				</p>
			</li>
			<li>
				<p>
                    Descriptor pools are externally synchronized, meaning that the application 
					<strong>
                        must
					</strong>
                    &nbsp;not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.
				</p>
			</li>
			<li>
				<p>
                    They are very opaque.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorPoolCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Contains a type of descriptor (same 
                            <code>VkDescriptorType</code>
                            &nbsp;as on the bindings above ), alongside a ratio to multiply the 
                            <code>maxSets</code>
                            &nbsp;parameter is.
						</p>
					</li>
					<li>
						<p>
                            This lets us directly control how big the pool is going to be. 
                            <code>maxSets</code>
                            &nbsp;controls how many 
                            <code>VkDescriptorSets</code>
                            &nbsp;we can create from the pool in total, and the pool sizes give how many individual bindings of a given type are owned.
						</p>
					</li>
					<li>
						<p>
                            <code>flags</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorPoolCreateFlagBits
									</a>
                                    &nbsp;specifying certain supported operations on the pool.
								</p>
							</li>
							<li>
								<p>
                                    <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
								</p>
								<ul>
									<li>
										<p>
                                            Determines if individual descriptor sets can be freed or not:
										</p>
									</li>
									<li>
										<p>
                                            We're not going to touch the descriptor set after creating it, so we don't need this flag. You can leave 
                                            <code>flags</code>
                                            &nbsp;to its default value of 
                                            <code>0</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND</code>
								</p>
								<ul>
									<li>
										<p>
                                            Descriptor pool creation 
											<strong>
                                                may
											</strong>
                                            &nbsp;fail with the error 
                                            <code>ERROR_FRAGMENTATION</code>
                                            &nbsp;if the total number of descriptors across all pools (including this one) created with this bit set exceeds 
                                            <code>maxUpdateAfterBindDescriptorsInAllPools</code>
                                            , or if fragmentation of the underlying hardware resources occurs.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>maxSets</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the maximum number of descriptor sets that 
									<strong>
                                        can
									</strong>
                                    &nbsp;be allocated from the pool.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>poolSizeCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of elements in 
                                    <code>pPoolSizes</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pPoolSizes</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorPoolSize
									</a>
                                    &nbsp;structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
								</p>
							</li>
							<li>
								<p>
                                    If multiple 
                                    <code>VkDescriptorPoolSize</code>
                                    &nbsp;structures containing the same descriptor type appear in the 
                                    <code>pPoolSizes</code>
                                    &nbsp;array then the pool will be created with enough storage for the total number of descriptors of each type.
								</p>
							</li>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkDescriptorPoolSize</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            <code>type</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is the type of descriptor.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>descriptorCount</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is the number of descriptors of that type to allocate. If 
                                                    <code>type</code>
                                                    &nbsp;is 
                                                    <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                                    &nbsp;then 
                                                    <code>descriptorCount</code>
                                                    &nbsp;is the number of bytes to allocate for descriptors of this type.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetAllocateInfo</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    <code>descriptorPool</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the pool which the sets will be allocated from.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorSetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Determines the number of descriptor sets to be allocated from the pool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSetLayouts</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkAllocateDescriptorSets()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The allocated descriptor sets are returned in 
                    <code>pDescriptorSets</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    When a descriptor set is allocated, the initial state is largely uninitialized and all descriptors are undefined, with the exception that samplers with a non-null 
                    <code>pImmutableSamplers</code>
                    &nbsp;are initialized on allocation.
				</p>
			</li>
			<li>
				<p>
                    Descriptors also become undefined if the underlying resource or view object is destroyed.
				</p>
			</li>
			<li>
				<p>
                    Descriptor sets containing undefined descriptors 
					<strong>
                        can
					</strong>
                    &nbsp;still be bound and used, subject to the following conditions:
				</p>
				<ul>
					<li>
						<p>
                            For descriptor set bindings created with the 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;bit set:
						</p>
						<ul>
							<li>
								<p>
                                    All descriptors in that binding that are dynamically used 
									<strong>
                                        must
									</strong>
                                    &nbsp;have been populated before the descriptor set is 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
										class="external-link" 
										target="_blank" >
                                        consumed
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            For descriptor set bindings created without the 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;bit set:
						</p>
						<ul>
							<li>
								<p>
                                    All descriptors in that binding that are statically used 
									<strong>
                                        must
									</strong>
                                    &nbsp;have been populated before the descriptor set is 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
										class="external-link" 
										target="_blank" >
                                        consumed
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Descriptor bindings with descriptor type of 
                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            &nbsp;
							<strong>
                                can
							</strong>
                            &nbsp;be undefined when the descriptor set is 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
								class="external-link" 
								target="_blank" >
                                consumed
							</a>
                            ; though values in that block will be undefined.
						</p>
					</li>
					<li>
						<p>
                            Entries that are not used by a pipeline 
							<strong>
                                can
							</strong>
                            &nbsp;have undefined descriptors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAllocateInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSetAllocateInfo
							</a>
                            &nbsp;structure describing parameters of the allocation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorSets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSet
							</a>
                            &nbsp;handles in which the resulting descriptor set objects are returned.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Multithreading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor pools are externally synchronized, meaning that the application 
					<strong>
                        must
					</strong>
                    &nbsp;not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.
				</p>
			</li>
			<li>
				<p>
                    Command Pools are used to allocate, free, reset, and update descriptor sets. By creating multiple descriptor pools, each application host thread is able to manage a descriptor set in each descriptor pool at the same time.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="best-practices" >
    Best Practices
</h5>
<ul>
	<li>
		<p>
            Don‚Äôt allocate descriptor sets if nothing in the set changed. In the model with slots that are shared between different stages, this can mean that if no textures are set between two draw calls, you don‚Äôt need to allocate the descriptor set with texture descriptors.
		</p>
	</li>
	<li>
		<p>
            Don't allocate descriptor sets from descriptor pools on performance critical code paths.
		</p>
	</li>
	<li>
		<p>
            Don't allocate, free or update descriptor sets every frame, unless it is necessary.
		</p>
	</li>
	<li>
		<p>
            Don't set 
            <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
            &nbsp;if you do not need to free individual descriptor sets.
		</p>
		<ul>
			<li>
				<p>
                    Setting 
                    <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
                    &nbsp;may prevent the implementation from using a simpler (and faster) allocator.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="descriptor-types" >
    Descriptor Types
</h4>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#descriptorsets-types" 
				class="external-link" 
				target="_blank" >
                Descriptor Types
			</a>
            .
		</p>
	</li>
</ul>
<h6
	id="overview" >
    Overview
</h6>
<ul>
	<li>
		<p>
            For buffers, application must choose between uniform and storage buffers, and whether to use dynamic offsets or not. Uniform buffers have a limit on the maximum addressable size ‚Äì on desktop hardware, you get up to 64 KB of data, however on mobile hardware some GPUs only provide 16 KB of data (which is also the guaranteed minimum by the specification). The buffer resource can be larger than that, but shader can only access this much data through one descriptor.
		</p>
	</li>
	<li>
		<p>
            On some hardware, there is no difference in access speed between uniform and storage buffers, however for other hardware depending on the access pattern uniform buffers can be significantly faster. Prefer uniform buffers for small to medium sized data especially if the access pattern is fixed (e.g. for a buffer with material or scene constants). Storage buffers are more appropriate when you need large arrays of data that need to be larger than the uniform buffer limit and are indexed dynamically in the shader.
		</p>
	</li>
	<li>
		<p>
            For textures, if filtering is required, there is a choice of combined image/sampler descriptor (where, like in OpenGL, descriptor specifies both the source of the texture data, and the filtering/addressing properties), separate image and sampler descriptors (which maps better to Direct3D 11 model), and image descriptor with an immutable sampler descriptor, where the sampler properties must be specified when pipeline object is created.
		</p>
	</li>
	<li>
		<p>
            The relative performance of these methods is highly dependent on the usage pattern; however, in general immutable descriptors map better to the recommended usage model in other newer APIs like Direct3D 12, and give driver more freedom to optimize the shader. This does alter renderer design to a certain extent, making it necessary to implement certain dynamic portions of the sampler state, like per-texture LOD bias for texture fade-in during streaming, using shader ALU instructions.
		</p>
	</li>
</ul>
<h5
	id="storage-images" >
    Storage Images
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
		</p>
	</li>
	<li>
		<p>
            Is a descriptor type that allows shaders to read from and write to an image without using a fixed-function graphics pipeline.
		</p>
	</li>
	<li>
		<p>
            This is particularly useful for compute shaders and advanced rendering techniques.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_storage_images" 
				class="external-link" 
				target="_blank" >
                Storage Images and Implementation
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// FORMAT_R32_UINT
layout(set = 0, binding = 0, r32ui) uniform uimage2D storageImage;

// example usage for reading and writing in GLSL
const uvec4 texel = imageLoad(storageImage, ivec2(0, 0));
imageStore(storageImage, ivec2(1, 1), texel);
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Use cases
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Image Processing
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Storage images are ideal for image processing tasks like filters, blurs, and other post-processing effects.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="sampler" >
    Sampler
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_SAMPLER</code>
            &nbsp;and 
            <code>DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler samplerDescriptor;
layout(set = 0, binding = 1) uniform texture2D sampledImage;

// example usage of using texture() in GLSL
vec4 data = texture(sampler2D(sampledImage,&nbsp;&nbsp;samplerDescriptor), vec2(0.0, 0.0));
</code></pre>
<h5
	id="combined-image-sampler" >
    Combined Image Sampler
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
		</p>
	</li>
	<li>
		<p>
            On some implementations, it 
			<em>
                may
			</em>
            &nbsp;be more efficient to sample from an image using a combination of sampler and sampled image that are stored together in the descriptor set in a combined descriptor.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D combinedImageSampler;

// example usage of using texture() in GLSL
vec4 data = texture(combinedImageSampler, vec2(0.0, 0.0));
</code></pre>
<h5
	id="uniform-buffer-ubo-uniform-buffer-object" >
    Uniform Buffer / UBO (Uniform Buffer Object)
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
		</p>
	</li>
	<li>
		<p>
            Uniform buffers can also have 
			<a
				href="https://docs.vulkan.org/guide/latest/descriptor_dynamic_offset.html" 
				class="external-link" 
				target="_blank" >
                dynamic offsets at bind time
			</a>
            &nbsp;(
            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
            ).
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform uniformBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float a;
&nbsp;&nbsp;&nbsp;&nbsp;int b;
} ubo;

// example of reading from UBO in GLSL
int x = ubo.b + 1;
vec3 y = vec3(ubo.a);
</code></pre>
<ul>
	<li>
		<p>
            Uniform Buffers commonly use 
            <code>std140</code>
            &nbsp;layout (strict alignment rules, predictable padding).
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Source: ChatGPT. I want to confirm.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">/* UBO: small read-only data (std140) */
layout(set = 0, binding = 0, std140) uniform SceneParams {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 viewProj;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 lightPos;
&nbsp;&nbsp;&nbsp;&nbsp;float time;
} scene;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                UBO (Uniform Buffer Object)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ‚ÄúUniform buffer object‚Äù is more of an OpenGL-era name, but some Vulkan tutorials and developers still use it informally to mean the same thing ‚Äî the buffer that holds uniform data.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="storage-buffer-ssbo-shader-storage-buffer-object" >
    Storage Buffer / SSBO (Shader Storage Buffer Object)
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
		</p>
	</li>
	<li>
		<p>
            GLSL uses distinct address spaces: 
            <code>uniform</code>
            &nbsp;‚Üí UBO, 
            <code>buffer</code>
            &nbsp;‚Üí SSBO.
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>std430</code>
            &nbsp;layout by default (tighter packing, fewer padding requirements).
		</p>
	</li>
	<li>
		<p>
            SSBO (Shader Storage Buffer Object) is a OpenGL term.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// Implicit std430 (default)
layout(set = 0, binding = 0) buffer storageBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float a;
&nbsp;&nbsp;&nbsp;&nbsp;int b;
} ssbo;

// Explicit std430
layout(set = 0, binding = 1, std430) buffer ParticleData {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 pos[];
} particles;

// Reading and writing to a SSBO in GLSL
ssbo.a = ssbo.a + 1.0;
ssbo.b = ssbo.b + 1;
</code></pre>
<ul>
	<li>
		<p>
            <code>BufferBlock</code>
            &nbsp;and 
            <code>Uniform</code>
            &nbsp;would have been seen prior to 
			<a
				href="https://docs.vulkan.org/guide/latest/extensions/shader_features.html#KHR_storage_buffer_storage_class" 
				class="external-link" 
				target="_blank" >
                <code>KHR_storage_buffer_storage_class</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Storage buffers can also have dynamic offsets at bind time 
			<a
				href="https://docs.vulkan.org/guide/latest/descriptor_dynamic_offset.html" 
				class="external-link" 
				target="_blank" >
                <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Why SSBO for dynamic arrays
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>std430</code>
                    &nbsp;allows tight packing and runtime-sized arrays 
                    <code>(T data[])</code>
                    , which is ideal for dynamic-length storage.
				</p>
			</li>
			<li>
				<p>
                    SSBOs allow arbitrary indexing, read/write, and atomics.
				</p>
			</li>
			<li>
				<p>
                    maxStorageBufferRange is usually much larger than 
                    <code>maxUniformBufferRange</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    You can use 
                    <code>*_DYNAMIC</code>
                    &nbsp;descriptors to bind multiple subranges of one large backing buffer cheaply.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Many arrays
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A buffer block may contain multiple arrays, but only the last member of the block may be a runtime-sized (unsized) array 
                    <code>T x[]</code>
                    . All other arrays must be fixed-size (compile-time constant) or you must implement sizing/offsets yourself.
				</p>
				<ul>
					<li>
						<p>
                            This is 
							<strong>
                                invalid
							</strong>
                            , even with descriptor indexing:
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set = 0, binding = 0) buffer FixedArrays { 
&nbsp;&nbsp;&nbsp;&nbsp;vec4 A[]; 
&nbsp;&nbsp;&nbsp;&nbsp;vec2 B[]; 
&nbsp;&nbsp;&nbsp;&nbsp;mat4 C[]; 
&nbsp;&nbsp;&nbsp;&nbsp;some_struct D[];
} fixedArrays;
</code></pre>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    Use a 
                    <code>uint x[]</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            32-bit words; simplest and portable.
						</p>
					</li>
					<li>
						<p>
                            This is effectively an untyped byte/word blob stored in the SSBO and you manually reinterpret (cast) it in the shader
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set = 0, binding = 0) buffer PackedBytes {
&nbsp;&nbsp;&nbsp;&nbsp;uint countA;&nbsp;&nbsp; // number of A elements
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetA;&nbsp;&nbsp;// offset into data[] in uint words
&nbsp;&nbsp;&nbsp;&nbsp;uint countB;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetB;&nbsp;&nbsp;// offset into data[] in uint words
&nbsp;&nbsp;&nbsp;&nbsp;uint countC;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetC;

&nbsp;&nbsp;&nbsp;&nbsp;uint data[];&nbsp;&nbsp; // payload in 32-bit words
} pb;

// helpers
float readFloat(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return uintBitsToFloat(pb.data[baseWordIndex]);
}

vec2 readVec2(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return vec2(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 0]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 1])
&nbsp;&nbsp;&nbsp;&nbsp;);
}

vec3 readVec3(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return vec3(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 0]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 1]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 2])
&nbsp;&nbsp;&nbsp;&nbsp;);
}

vec4 readVec4(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;return vec4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 0]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 1]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 2]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintBitsToFloat(pb.data[baseWordIndex + 3])
&nbsp;&nbsp;&nbsp;&nbsp;);
}

mat4 readMat4(uint baseWordIndex) {
&nbsp;&nbsp;&nbsp;&nbsp;// mat4 stored column-major as 16 floats (4 columns of vec4)
&nbsp;&nbsp;&nbsp;&nbsp;return mat4(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 4),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 8),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readVec4(baseWordIndex + 12)
&nbsp;&nbsp;&nbsp;&nbsp;);
}
</code></pre>
			</li>
			<li>
				<p>
                    Use a 
                    <code>vec4 x[]</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            128-bit blocks; simpler alignment for vec4/mat4 data.
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">// Pack everything into vec4 blocks for simple alignment
layout(std430, set = 0, binding = 0) buffer Packed {
&nbsp;&nbsp;&nbsp;&nbsp;uint countA;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetA; // in vec4-blocks
&nbsp;&nbsp;&nbsp;&nbsp;uint countB;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetB; // in vec4-blocks
&nbsp;&nbsp;&nbsp;&nbsp;uint countC;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetC; // in vec4-blocks
&nbsp;&nbsp;&nbsp;&nbsp;uint countD;
&nbsp;&nbsp;&nbsp;&nbsp;uint offsetD; // in vec4-blocks

&nbsp;&nbsp;&nbsp;&nbsp;vec4 blocks[]; // single runtime-sized array (last member)
} packed;

// helpers
vec4 getA(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;return packed.blocks[packed.offsetA + i];
}

vec2 getB(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;return packed.blocks[packed.offsetB + i].xy; // we store each B in one vec4 block
}

mat4 getC(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;uint base = packed.offsetC + i * 4; // mat4 occupies 4 vec4 blocks
&nbsp;&nbsp;&nbsp;&nbsp;return mat4(packed.blocks[base + 0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packed.blocks[base + 1],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packed.blocks[base + 2],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packed.blocks[base + 3]);
}

// for some_struct D that we store as 1 vec4 per element:
some_struct getD(uint i) {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 v = packed.blocks[packed.offsetD + i];
&nbsp;&nbsp;&nbsp;&nbsp;// decode v -&gt; some_struct fields
}
</code></pre>
			</li>
			<li>
				<p>
                    Use many SSBOs:
				</p>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set=0, binding=0) buffer BufA { vec4 A[]; } bufA;
layout(std430, set=0, binding=1) buffer BufB { vec2 B[]; } bufB;
layout(std430, set=0, binding=2) buffer BufC { mat4 C[]; } bufC;
layout(std430, set=0, binding=3) buffer BufD { some_struct D[]; } bufD;
</code></pre>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="texel-buffer" >
    Texel Buffer
</h5>
<ul>
	<li>
		<p>
            Texel buffers are a way to access buffer data with texture-like operations in shaders.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_texel_buffers" 
				class="external-link" 
				target="_blank" >
                Texel Buffers and Implementation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_format_compatibility_requirements" 
				class="external-link" 
				target="_blank" >
                Compatibility Requirements
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The format specified in the shader (SPIR-V Image Format) must 
					<strong>
                        exactly match
					</strong>
                    &nbsp;the format used when creating the VkImageView (Vulkan Format).
				</p>
			</li>
			<li>
				<p>
                    Require exact format matching between the shader and the view. The views must always match the shader exactly.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_best_practices" 
				class="external-link" 
				target="_blank" >
                Best Practices
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Uniform Texel Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>
				</p>
			</li>
			<li>
				<p>
                    Read-only access.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform textureBuffer uniformTexelBuffer;

// example of reading texel buffer in GLSL
vec4 data = texelFetch(uniformTexelBuffer, 0);
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Use cases
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Lookup Tables
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Uniform texel buffers are useful for implementing lookup tables that need to be accessed with texture-like operations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Storage Texel Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>
				</p>
			</li>
			<li>
				<p>
                    Read-write access.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// FORMAT_R8G8B8A8_UINT
layout(set = 0, binding = 0, rgba8ui) uniform uimageBuffer storageTexelBuffer;

// example of reading and writing texel buffer in GLSL
int offset = int(gl_GlobalInvocationID.x);
vec4 data = imageLoad(storageTexelBuffer, offset);
imageStore(storageTexelBuffer, offset, uvec4(0));
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Use cases
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Particle Systems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Storage texel buffers can be used to store and update particle data in a compute shader, which can then be read by a vertex shader for rendering.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="input-attachment" >
    Input Attachment
</h5>
<ul>
	<li>
		<p>
            <code>DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout (input_attachment_index = 0, set = 0, binding = 0) uniform subpassInput inputAttachment;

// example loading the attachment data in GLSL
vec4 data = subpassLoad(inputAttachment);
</code></pre>
<h4
	id="updates" >
    Updates
</h4>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
            A Descriptor Set, even though created and allocated, is still empty. We need to fill it up with data.
		</p>
	</li>
	<li>
		<p>
            Updates 
			<strong>
                must
			</strong>
            &nbsp;happen outside of a command record and execution.
		</p>
		<ul>
			<li>
				<p>
                    No update after 
                    <code>vkCmdBindDescriptorSets()</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Usually you update before 
                    <code>vkBeginCommandBuffer()</code>
                    &nbsp;or after the 
                    <code>vkQueueSubmit()</code>
                    &nbsp;(if we know the sync is done for cmd).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                If using Descriptor Indexing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptors can be updated after binding in command buffers.
				</p>
				<ul>
					<li>
						<p>
                            Command buffer execution will use most recent updates.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250807094326.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSet.html" 
				class="external-link" 
				target="_blank" >
                <code>VkWriteDescriptorSet</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>dstSet</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the destination descriptor set to update.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dstBinding</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the descriptor binding within that set.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dstArrayElement</code>
				</p>
				<ul>
					<li>
						<p>
                            Remember that descriptors can be arrays, so we also need to specify the first index in the array that we want to update.
						</p>
					</li>
					<li>
						<p>
                            If not using an array, the index is simply 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Is the starting element in that array.
						</p>
					</li>
					<li>
						<p>
                            If the descriptor binding identified by 
                            <code>dstSet</code>
                            &nbsp;and 
                            <code>dstBinding</code>
                            &nbsp;has a descriptor type of 
                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            &nbsp;then 
                            <code>dstArrayElement</code>
                            &nbsp;specifies the starting byte offset within the binding.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorCount</code>
				</p>
				<ul>
					<li>
						<p>
                            It's a descriptor count, 
							<strong>
                                not
							</strong>
                            &nbsp;a descriptor SET count!!
						</p>
					</li>
					<li>
						<p>
                            Is the number of descriptors to update.
						</p>
					</li>
					<li>
						<p>
                            If the descriptor binding identified by 
                            <code>dstSet</code>
                            &nbsp;and 
                            <code>dstBinding</code>
                            &nbsp;has a descriptor type of 
                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            , then 
                            <code>descriptorCount</code>
                            &nbsp;specifies the number of bytes to update.
						</p>
					</li>
					<li>
						<p>
                            Otherwise, 
                            <code>descriptorCount</code>
                            &nbsp;is one of
						</p>
						<ul>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pImageInfo</code>
								</p>
							</li>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pBufferInfo</code>
								</p>
							</li>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pTexelBufferView</code>
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>dataSize</code>
                                    &nbsp;member of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetInlineUniformBlock.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetInlineUniformBlock
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>accelerationStructureCount</code>
                                    &nbsp;of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetAccelerationStructureKHR
									</a>
                                    &nbsp;or 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureNV.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetAccelerationStructureNV
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>descriptorCount</code>
                                    &nbsp;of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetTensorARM.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetTensorARM
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorType</code>
				</p>
				<ul>
					<li>
						<p>
                            We need to specify the type of descriptor again
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorType.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorType
							</a>
                            &nbsp;specifying the type of each descriptor in 
                            <code>pImageInfo</code>
                            , 
                            <code>pBufferInfo</code>
                            , or 
                            <code>pTexelBufferView</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;be the same type as the 
                            <code>descriptorType</code>
                            &nbsp;specified in 
                            <code>VkDescriptorSetLayoutBinding</code>
                            &nbsp;for 
                            <code>dstSet</code>
                            &nbsp;at 
                            <code>dstBinding</code>
                            , 
							<strong>
                                except
							</strong>
                            &nbsp;if 
                            <code>VkDescriptorSetLayoutBinding</code>
                            &nbsp;for 
                            <code>dstSet</code>
                            &nbsp;at 
                            <code>dstBinding</code>
                            &nbsp;is equal to 
                            <code>DESCRIPTOR_TYPE_MUTABLE_EXT</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The type of the descriptor also controls which array the descriptors are taken from.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pBufferInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorBufferInfo
							</a>
                            &nbsp;structures or is ignored, as described below.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDescriptorBufferInfo</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Structure specifying descriptor buffer information
								</p>
							</li>
							<li>
								<p>
                                    Specifies the buffer and the region within it that contains the data for the descriptor.
								</p>
							</li>
							<li>
								<p>
                                    <code>buffer</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the buffer resource or 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/NULL_HANDLE.html" 
												class="external-link" 
												target="_blank" >
                                                NULL_HANDLE
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>offset</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the offset in bytes from the start of 
                                            <code>buffer</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.
										</p>
									</li>
									<li>
										<p>
                                            For 
                                            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                            &nbsp;and 
                                            <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                            &nbsp;descriptor types:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>offset</code>
                                                    &nbsp;is the base offset from which the dynamic offset is applied.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>range</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the size in bytes that is used for this descriptor update, or 
                                            <code>WHOLE_SIZE</code>
                                            &nbsp;to use the range from 
                                            <code>offset</code>
                                            &nbsp;to the end of the buffer.
										</p>
										<ul>
											<li>
												<p>
                                                    When 
                                                    <code>range</code>
                                                    &nbsp;is 
                                                    <code>WHOLE_SIZE</code>
                                                    &nbsp;the effective range is calculated at 
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html" 
														class="external-link" 
														target="_blank" >
                                                        vkUpdateDescriptorSets
													</a>
                                                    &nbsp;by taking the size of 
                                                    <code>buffer</code>
                                                    &nbsp;minus the 
                                                    <code>offset</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            For 
                                            <code>DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                            &nbsp;and 
                                            <code>DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                            &nbsp;descriptor types:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>range</code>
                                                    &nbsp;is the static size used for all dynamic offsets.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pImageInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorImageInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorImageInfo
							</a>
                            &nbsp;structures or is ignored, as described below.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorImageInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDescriptorImageInfo</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    <code>imageLayout</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the layout that the image subresources accessible from 
                                            <code>imageView</code>
                                            &nbsp;will be in at the time this descriptor is accessed.
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            , and 
                                            <code>DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>imageView</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is an image view handle or 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/NULL_HANDLE.html" 
												class="external-link" 
												target="_blank" >
                                                NULL_HANDLE
											</a>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
                                            , 
                                            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            , and 
                                            <code>DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>sampler</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a sampler handle.
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>DESCRIPTOR_TYPE_SAMPLER</code>
                                            &nbsp;and 
                                            <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            &nbsp;if the binding being updated does not use immutable samplers.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pTexelBufferView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferView.html" 
								class="external-link" 
								target="_blank" >
                                VkBufferView
							</a>
                            &nbsp;handles as described in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-buffer-views" 
								class="external-link" 
								target="_blank" >
                                Buffer Views
							</a>
                            &nbsp;section or is ignored, as described below.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkUpdateDescriptorSets()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>descriptorWriteCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorWrites</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorWrites</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkWriteDescriptorSet
							</a>
                            &nbsp;structures describing the descriptor sets to write to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorCopyCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorCopies</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorCopies</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkCopyDescriptorSet
							</a>
                            &nbsp;structures describing the descriptor sets to copy between.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="best-practices" >
    Best Practices
</h5>
<ul>
	<li>
		<p>
            Don‚Äôt update descriptor sets if nothing in the set changed. In the model with slots that are shared between different stages, this can mean that if no textures are set between two draw calls, you don‚Äôt need to update the descriptor set with texture descriptors.
		</p>
	</li>
	<li>
		<p>
            When rendering dynamic objects the application will need to push some amount of per-object data to the GPU, such as the MVP matrix. This data may not fit into the push constant limit for the device, so it becomes necessary to send it to the GPU by putting it into a 
            <code>VkBuffer</code>
            &nbsp;and binding a descriptor set that points to it.
		</p>
	</li>
	<li>
		<p>
            Materials also need their own descriptor sets, which point to the textures they use. We can either bind per-material and per-object descriptor sets separately or collate them into a single set. Either way, complex applications will have a large amount of descriptor sets that may need to change on the fly, for example due to textures being streamed in or out.
		</p>
	</li>
	<li>
		<p>
			<em>
                Not-good Solution: One or more pools per-frame, resetting the pool
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The simplest approach to circumvent the issue is to have one or more 
                    <code>VkDescriptorPool</code>
                    s per frame, reset them at the beginning of the frame and allocate the required descriptor sets from it. This approach will consist of a 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkResetDescriptorPool.html" 
						class="external-link" 
						target="_blank" >
                        vkResetDescriptorPool()
					</a>
                    &nbsp;call at the beginning, followed by a series of 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkAllocateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkAllocateDescriptorSets()
					</a>
                    &nbsp;and 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkUpdateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkUpdateDescriptorSets()
					</a>
                    &nbsp;to fill them with data.
				</p>
			</li>
			<li>
				<p>
                    This is very useful for things like per-frame descriptors. That way we can have descriptors that are used just for one frame, allocated dynamically, and then before we start the frame we completely delete all of them in one go.
				</p>
			</li>
			<li>
				<p>
                    This is confirmed to be a fast path by GPU vendors, and recommended to use when you need to handle per-frame descriptor sets.
				</p>
			</li>
			<li>
				<p>
                    The issue is that these calls can add a significant overhead to the CPU frame time, especially on mobile. In the worst cases, for example calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkUpdateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkUpdateDescriptorSets()
					</a>
                    &nbsp;for each draw call, the time it takes to update descriptors can be longer than the time of the draws themselves.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution: Caching descriptor sets
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A major way to reduce descriptor set updates is to re-use them as much as possible. Instead of calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkResetDescriptorPool.html" 
						class="external-link" 
						target="_blank" >
                        vkResetDescriptorPool()
					</a>
                    &nbsp;every frame, the app will keep the 
                    <code>VkDescriptorSet</code>
                    &nbsp;handles stored with some caching mechanism to access them.
				</p>
			</li>
			<li>
				<p>
                    The cache could be a hashmap with the contents of the descriptor set (images, buffers) as key. This approach is used in our framework by default. It is possible to remove another level of indirection by storing descriptor set handles directly in the materials and/or meshes.
				</p>
			</li>
			<li>
				<p>
                    Caching descriptor sets has a dramatic effect on frame time for our CPU-heavy scene.
				</p>
			</li>
			<li>
				<p>
                    In this game on a 2019 mobile phone it went from 44ms (23fps) to 27ms (37fps). This is a 38% decrease in frame time.
				</p>
			</li>
			<li>
				<p>
                    This system is reasonably easy to implement for a static scene, but it becomes harder when you need to delete descriptor sets. Complex engines may implement techniques to figure out which descriptor sets have not been accessed for a certain number of frames, so they can be removed from the map.
				</p>
			</li>
			<li>
				<p>
                    This may correspond to calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkFreeDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkFreeDescriptorSets()
					</a>
                    , but this solution poses another issue: in order to free individual descriptor sets the pool has to be created with the 
                    <code>DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET</code>
                    &nbsp;flag. Mobile implementations may use a simpler allocator if that flag is not set, relying on the fact that pool memory will only be recycled in block.
				</p>
			</li>
			<li>
				<p>
                    It is possible to avoid using that flag by updating descriptor sets instead of deleting them. The application can keep track of recycled descriptor sets and re-use one of them when a new one is requested.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution: One buffer per-frame
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We will now explore an alternative approach, that is complementary to descriptor caching in some way. Especially for applications in which descriptor caching is not quite feasible, buffer management is another lever for optimizing performance.
				</p>
			</li>
			<li>
				<p>
                    As discussed at the beginning, each rendered object will typically need some uniform data along with it, that needs to be pushed to the GPU somehow. A straightforward approach is to store a 
                    <code>VkBuffer</code>
                    &nbsp;per object and update that data for each frame.
				</p>
			</li>
			<li>
				<p>
                    This already poses an interesting question: is one buffer enough? The problem is that this data will change dynamically and will be in use by the GPU while the frame is in flight.
				</p>
			</li>
			<li>
				<p>
                    Since we do not want to flush the GPU pipeline between each frame, we will need to keep several copies of each buffer, one for each frame in flight.
				</p>
			</li>
			<li>
				<p>
                    Another similar option is to use just one buffer per object, but with a size equal to 
                    <code>num_frames * buffer_size</code>
                    , then offset it dynamically based on the frame index.
				</p>
				<ul>
					<li>
						<p>
                            For each frame, one buffer per object is created and filled with data. This means that we will have many descriptor sets to create, since every object will need one that points to its 
                            <code>VkBuffer</code>
                            . Furthermore, we will have to update many buffers separately, meaning we cannot control their memory layout and we might lose some optimization opportunities with caching.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    We can address both problems by reverting the approach: instead of having a 
                    <code>VkBuffer</code>
                    &nbsp;per object containing per-frame data, we will have a 
                    <code>VkBuffer</code>
                    &nbsp;per frame containing per-object data. The buffer will be cleared at the beginning of the frame, then each object will record its data and will receive a dynamic offset to be used at 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCmdBindDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkCmdBindDescriptorSets()
					</a>
                    &nbsp;time.
				</p>
			</li>
			<li>
				<p>
                    With this approach we will need fewer descriptor sets, as more objects can share the same one: they will all reference the same 
                    <code>VkBuffer</code>
                    , but at different dynamic offsets. Furthermore, we can control the memory layout within the buffer.
				</p>
			</li>
			<li>
				<p>
                    Using a single large 
                    <code>VkBuffer</code>
                    &nbsp;in this case shows a performance improvement similar to descriptor set caching.
				</p>
			</li>
			<li>
				<p>
                    For this relatively simple scene stacking the two approaches does not provide a further performance boost, but for a more complex case they do stack nicely:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor caching is necessary when the number of descriptor sets is not just due to 
                            <code>VkBuffer</code>
                            s with uniform data, for example if the scene uses a large amount of materials/textures.
						</p>
					</li>
					<li>
						<p>
                            Buffer management will help reduce the overall number of descriptor sets, thus cache pressure will be reduced and the cache itself will be smaller.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    (2025-09-08)
				</p>
				<ul>
					<li>
						<p>
                            I personally liked this technique much more than descriptor caching.
						</p>
					</li>
					<li>
						<p>
                            It sounds more concrete than fiddling with descriptor sets.
						</p>
					</li>
					<li>
						<p>
                            Reminds me of Buffer Device Address.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Update already allocated but no longer referenced descriptor sets, instead of resetting descriptor pools and reallocating new descriptor sets.
				</p>
			</li>
			<li>
				<p>
                    Prefer reusing already allocated descriptor sets, and not updating them with the same information every time.
				</p>
			</li>
			<li>
				<p>
                    Consider caching your descriptor sets when feasible.
				</p>
			</li>
			<li>
				<p>
                    Consider using a single (or few) 
                    <code>VkBuffer</code>
                    &nbsp;per frame with dynamic offsets.
				</p>
			</li>
			<li>
				<p>
                    Batch calls to vkAllocateDescriptorSets if possible ‚Äì on some drivers, each call has measurable overhead, so if you need to update multiple sets, allocating both in one call can be faster;
				</p>
			</li>
			<li>
				<p>
                    To update descriptor sets, either use vkUpdateDescriptorSets with descriptor write array, or use 
                    <code>vkUpdateDescriptorSetWithTemplate</code>
                    &nbsp;from Vulkan 1.1. Using the descriptor copy functionality of 
                    <code>vkUpdateDescriptorSets</code>
                    &nbsp;is tempting with dynamic descriptor management for copying most descriptors out of a previously allocated array, but this can be slow on drivers that allocate descriptors out of write-combined memory. Descriptor templates can reduce the amount of work application needs to do to perform updates ‚Äì since in this scheme you need to read descriptor information out of shadow state maintained by application, descriptor templates allow you to tell the driver the layout of your shadow state, making updates substantially faster on some drivers.
				</p>
			</li>
			<li>
				<p>
                    Prefer dynamic uniform buffers to updating uniform buffer descriptors. Dynamic uniform buffers allow to specify offsets into buffer objects using pDynamicOffsets argument of vkCmdBindDescriptorSets without allocating and updating new descriptors. This works well with dynamic constant management where constants for draw calls are allocated out of large uniform buffers, substantially reduce CPU overhead, and can be more efficient on GPU. While on some GPUs the number of dynamic buffers must be kept small to avoid extra overhead in the driver, one or two dynamic uniform buffers should work well in this scheme on all architectures.
				</p>
			</li>
			<li>
				<p>
                    On some drivers, unfortunately the allocate &amp; update path is not very optimal ‚Äì on some mobile hardware, it may make sense to cache descriptor sets based on the descriptors they contain if they can be reused later in the frame.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="descriptor-set-layout" >
    Descriptor Set Layout
</h4>
<ul>
	<li>
		<p>
            Contains the information about what that descriptor set holds.
		</p>
	</li>
	<li>
		<p>
            Specifies the types of resources that are going to be accessed by the pipeline, just like a render pass specifies the types of attachments that will be accessed.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How many
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You need to specify a descriptor set layout for each descriptor set when creating the pipeline layout.
				</p>
				<ul>
					<li>
						<p>
                            You can use this feature to put descriptors that vary per-object and descriptors that are shared into separate descriptor sets.
						</p>
					</li>
					<li>
						<p>
                            In that case, you avoid rebinding most of the descriptors across draw calls which are potentially more efficient.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Since the buffer structure is identical across frames, one layout suffices.
				</p>
				<ul>
					<li>
						<p>
                            Create only 1 descriptor set layout, regardless of frames in-flight.
						</p>
					</li>
					<li>
						<p>
                            This layout defines the type of resource (e.g., 
                            <code>VKDESCRIPTORTYPEUNIFORMBUFFER</code>
                            ) and its binding point.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetLayout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Opaque handle to a descriptor set layout object.
				</p>
			</li>
			<li>
				<p>
                    Is defined by an array of zero or more descriptor bindings.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Where it's used
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkPipelineLayoutCreateInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>vkDescriptorSetAllocateInfo</code>
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorSetLayoutBinding</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Structure specifying a descriptor set layout binding.
						</p>
					</li>
					<li>
						<p>
                            Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that can access the binding, and (if using immutable samplers) an array of sampler descriptors.
						</p>
					</li>
					<li>
						<p>
                            Bindings that are not specified have a 
                            <code>descriptorCount</code>
                            &nbsp;and 
                            <code>stageFlags</code>
                            &nbsp;of zero, and the value of 
                            <code>descriptorType</code>
                            &nbsp;is undefined.
						</p>
					</li>
					<li>
						<p>
                            <code>binding</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
								</p>
							</li>
							<li>
								<p>
                                    Used in the shader and the type of descriptor, which is a uniform buffer object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>descriptorType</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorType.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorType
									</a>
                                    &nbsp;specifying which type of resource descriptors are used for this binding.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>descriptorCount</code>
						</p>
						<ul>
							<li>
								<p>
									<strong>
                                        Insight
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            It's a descriptor count, 
											<strong>
                                                not a descriptor SET count
											</strong>
                                            !! It's just to specify how many resources is expected to be in that binding.
										</p>
									</li>
									<li>
										<p>
                                            It makes complete sense to be used for arrays.
										</p>
									</li>
									<li>
										<p>
                                            Caio:
										</p>
										<ul>
											<li>
												<p>
                                                    What happens if the values don't match? For example, trying to get the index 5 of the array, when the binding was described having 
                                                    <code>descriptorCount = 1</code>
                                                    &nbsp;?
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Oni:
										</p>
										<ul>
											<li>
												<p>
                                                    I don't know if this is specified. I guess it's only going to update the first element. So you're going to read bogus data. Maybe it changes between different drivers, no idea.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<strong>
                                        What value to use
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            A MVP transformation is in a single uniform buffer, so we using a 
                                            <code>descriptorCount</code>
                                            &nbsp;of 
                                            <code>1</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            In other words, a whole struct counts as 
                                            <code>1</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Is the number of descriptors contained in the binding, accessed in a shader as an array.
								</p>
								<ul>
									<li>
										<p>
                                            Except if 
                                            <code>descriptorType</code>
                                            &nbsp;is 
                                            <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                            &nbsp;in which case 
                                            <code>descriptorCount</code>
                                            &nbsp;is the size in bytes of the inline uniform block.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorCount</code>
                                    &nbsp;is zero this binding entry is reserved and the resource 
									<em>
                                        must
									</em>
                                    &nbsp;not be accessed from any stage via this binding within any pipeline using the set layout.
								</p>
							</li>
							<li>
								<p>
                                    It is possible for the shader variable to represent an array of uniform buffer objects, and this property specifies the number of values in the array.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Examples
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            This could be used to specify a transformation for each of the bones in a skeleton for skeletal animation.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>stageFlags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderStageFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkShaderStageFlagBits
									</a>
                                    &nbsp;specifying which pipeline shader stages 
									<strong>
                                        can
									</strong>
                                    &nbsp;access a resource for this binding.
								</p>
								<ul>
									<li>
										<p>
                                            <code>SHADER_STAGE_ALL</code>
                                            &nbsp;is a shorthand specifying all defined shader stages, including any additional stages defined by extensions.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If a shader stage is not included in 
                                    <code>stageFlags</code>
                                    , then a resource 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be accessed from that stage via this binding within any pipeline using the set layout.
								</p>
							</li>
							<li>
								<p>
                                    Other than input attachments which are limited to the fragment shader, there are no limitations on what combinations of stages 
									<strong>
                                        can
									</strong>
                                    &nbsp;use a descriptor binding, and in particular a binding 
									<strong>
                                        can
									</strong>
                                    &nbsp;be used by both graphics stages and the compute stage.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pImmutableSamplers</code>
						</p>
						<ul>
							<li>
								<p>
                                    Affects initialization of samplers.
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorType</code>
                                    &nbsp;specifies a 
                                    <code>DESCRIPTOR_TYPE_SAMPLER</code>
                                    &nbsp;or 
                                    <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                    &nbsp;type descriptor, then 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;
									<strong>
                                        can
									</strong>
                                    &nbsp;be used to initialize a set of 
									<em>
                                        immutable samplers
									</em>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorType</code>
                                    &nbsp;is not one of these descriptor types, then 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is 
									<strong>
                                        ignored
									</strong>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Immutable samplers are permanently bound into the set layout and 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be changed; updating a 
                                    <code>DESCRIPTOR_TYPE_SAMPLER</code>
                                    &nbsp;descriptor with immutable samplers is not allowed and updates to a 
                                    <code>DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                    &nbsp;descriptor with immutable samplers does not modify the samplers (the image views are updated, but the sampler updates are ignored).
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is not 
                                    <code>NULL</code>
                                    , then it is a pointer to an array of sampler handles that will be copied into the set layout and used for the corresponding binding. Only the sampler handles are copied; the sampler objects 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be destroyed before the final use of the set layout and any descriptor pools and sets created using it.
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is 
                                    <code>NULL</code>
                                    , then the sampler slots are dynamic and sampler handles 
									<strong>
                                        must
									</strong>
                                    &nbsp;be bound into descriptor sets using this layout. ]
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorSetLayoutCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>pBindings</code>
						</p>
						<ul>
							<li>
								<p>
                                    A pointer to an array of 
                                    <code>VkDescriptorSetLayoutBinding</code>
                                    &nbsp;structures.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>bindingCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of elements in 
                                    <code>pBindings</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayoutCreateFlagBits
									</a>
                                    &nbsp;specifying options for descriptor set layout creation.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCreateDescriptorSetLayout()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Create a new descriptor set layout.
						</p>
					</li>
					<li>
						<p>
                            <code>pCreateInfo</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayoutCreateInfo
									</a>
                                    &nbsp;structure specifying the state of the descriptor set layout object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pAllocator</code>
						</p>
						<ul>
							<li>
								<p>
                                    Controls host memory allocation as described in the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-allocation" 
										class="external-link" 
										target="_blank" >
                                        Memory Allocation
									</a>
                                    &nbsp;chapter.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pSetLayout</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayout
									</a>
                                    &nbsp;handle in which the resulting descriptor set layout object is returned.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineLayoutCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Structure specifying the parameters of a newly created pipeline layout object
				</p>
			</li>
			<li>
				<p>
                    <code>setLayoutCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of descriptor sets included in the pipeline layout.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                How it works
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It's possible to have multiple descriptor sets (
                                    <code>set = 0</code>
                                    , 
                                    <code>set = 1</code>
                                    , etc).
								</p>
							</li>
							<li>
								<p>
                                    &quot;You can have set = 0 being a set that is always bound and never changes, set = 1 is something specific to the current object being rendered, etc.&quot;
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSetLayouts</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkDescriptorSetLayout</code>
                            &nbsp;objects.
						</p>
					</li>
					<li>
						<p>
                            The implementation 
							<em>
                                must
							</em>
                            &nbsp;not access these objects outside of the duration of the command this structure is passed to.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="binding" >
    Binding
</h4>
<ul>
	<li>
		<p>
            A Descriptor state is tracked only inside a command buffer; they are always bound at command buffer level; their state is local to command buffers.
		</p>
		<ul>
			<li>
				<p>
                    They are not bound at queue level or global level, only to command buffers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250806153655.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Which set index to choose
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    According to GPU vendors, each descriptor set slot has a cost, so the fewer we have, the better.
				</p>
			</li>
			<li>
				<p>
                    &quot;Organize shader inputs into &quot;sets&quot; by update frequency.&quot;
				</p>
			</li>
			<li>
				<p>
                    Rarely changes -&gt; low index.
				</p>
			</li>
			<li>
				<p>
                    Changes frequently -&gt; high index.
				</p>
			</li>
			<li>
				<p>
                    Usually Descriptor Set 0 is used to always bind some global scene data, which will contain some uniform buffers and some special textures, and Descriptor Set 1 will be used for per-object data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdBindDescriptorSets</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It needs to be done before the 
                    <code>vkCmdDrawIndexed()</code>
                    &nbsp;calls, for example.
				</p>
			</li>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the command buffer that the descriptor sets will be bound to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pipelineBindPoint</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBindPoint.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineBindPoint
							</a>
                            &nbsp;indicating the type of the pipeline that will use the descriptors. There is a separate set of bind points for each pipeline type, so binding one does not disturb the others.
						</p>
					</li>
					<li>
						<p>
                            Unlike vertex and index buffers, descriptor sets are not unique to graphics pipelines, therefore, we need to specify if we want to bind descriptor sets to the graphics or compute pipeline.
						</p>
					</li>
					<li>
						<p>
                            Indicates the type of the pipeline that will use the descriptor.
						</p>
					</li>
					<li>
						<p>
                            There is a separate set of bind points for each pipeline type, so binding one does not disturb the others.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250806154129.png" width="425" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    A raytracing command takes the currently bound descriptors from the raytracing bind point.
								</p>
							</li>
							<li>
								<p>
                                    A draw command takes the currently bound descriptors from the graphics bind point.
								</p>
							</li>
							<li>
								<p>
                                    The two don't interfere with each other.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>layout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayout.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineLayout
							</a>
                            &nbsp;object used to program the bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstSet</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the 
							<em>
                                set number
							</em>
                            &nbsp;of the 
							<em>
                                first descriptor set
							</em>
                            &nbsp;to be bound.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorSetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorSets</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorSets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of handles to 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSet
							</a>
                            &nbsp;objects describing the descriptor sets to bind to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dynamicOffsetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of dynamic offsets in the 
                            <code>pDynamicOffsets</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDynamicOffsets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>uint32_t</code>
                            &nbsp;values specifying dynamic offsets.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="strategy-descriptor-indexing-codeext_descriptor_indexing-code" >
    Strategy: Descriptor Indexing (
    <code>EXT_descriptor_indexing</code>
    )
</h4>
<h5
	id="plan" >
    Plan
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            SSBOs and UBOs.
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    Can I just put different data without restriction?
				</p>
				<ul>
					<li>
						<p>
                            Yes. See the SSBO section for that.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    SSBOs or UBOs?
				</p>
				<ul>
					<li>
						<p>
                            Using storage buffers exclusively instead of uniform buffers can increase GPU time on some architectures.
						</p>
					</li>
					<li>
						<p>
                            I'll use SSBO, as that was the general recommendation.
						</p>
					</li>
					<li>
						<p>
                            Maybe I'll mix both.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Globals:
		</p>
		<ul>
			<li>
				<p>
                    Camera view/proj, lights, ambient, etc.
				</p>
			</li>
			<li>
				<p>
                    I could just bind this once as well.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Material Data:
		</p>
		<ul>
			<li>
				<p>
                    The Material index is used to look up material data from material storage buffer. The textures can then be accessed using the indices from the material data and the descriptor array.
				</p>
			</li>
			<li>
				<p>
                    I'd use the instance index (or similar) to index into a 
                    <code>[]Material_Data</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Model Matrix / Transforms:
		</p>
		<ul>
			<li>
				<p>
                    Same as material data. I can send via push constants if direct drawing, or via 
                    <code>[]model_matrix</code>
                    &nbsp;if indirect drawing.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Draw Data:
		</p>
		<ul>
			<li>
				<p>
                    Indices to index into the other arrays.
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">struct DrawData
{
&nbsp;&nbsp;&nbsp;&nbsp;uint materialIndex;
&nbsp;&nbsp;&nbsp;&nbsp;uint transformOffset;
&nbsp;&nbsp;&nbsp;&nbsp;uint vertexOffset;
&nbsp;&nbsp;&nbsp;&nbsp;uint unused0; // vec4 padding

&nbsp;&nbsp;&nbsp;&nbsp;// ... extra gameplay data
};
</code></pre>
		<ul>
			<li>
				<p>
                    Vertex Shader:
				</p>
<pre><code class="language-glsl" data-lang="glsl">DrawData dd = drawData[gl_DrawIDARB];
TransformData td = transformData[dd.transformOffset];
vec4 positionLocal = vec4(positionData[gl_VertexIndex + dd.vertexOffset], 1.0);
vec3 positionWorld = mat4x3(td.transform[0], td.transform[1], td.transform[2]) * positionLocal;
</code></pre>
			</li>
			<li>
				<p>
                    Frag Shader:
				</p>
<pre><code class="language-glsl" data-lang="glsl">DrawData dd = drawData[drawId];
MaterialData md = materialData[dd.materialIndex];
vec4 albedo = texture(sampler2D(materialTextures[md.albedoTexture], albedoSampler), uv * vec2(md.tilingX, md.tilingY));
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Overall:
		</p>
		<ul>
			<li>
				<p>
                    <code>[]textures</code>
				</p>
			</li>
			<li>
				<p>
                    <code>[]material_data</code>
				</p>
				<ul>
					<li>
						<p>
                            uv, flip, modulate, etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>[]model_matrices</code>
				</p>
				<ul>
					<li>
						<p>
                            transforms.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>[]draw_data</code>
				</p>
				<ul>
					<li>
						<p>
                            Indices to index into the other arrays.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    vertex/indices
				</p>
				<ul>
					<li>
						<p>
                            As input attributes, to then use Indirect Drawing.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Slots:
		</p>
		<ul>
			<li>
				<p>
                    tex buffer and material data buffer will be in the same set 0, or should they be 0/1?
				</p>
			</li>
			<li>
				<p>
                    Probably every bind is on desc set 0
				</p>
			</li>
			<li>
				<p>
                    The slots are based on frequency, but every single binding I'm talking about might just be bound once globally without problems
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Vertex:
		</p>
		<ul>
			<li>
				<p>
                    Indirect vs Full bindless:
				</p>
				<ul>
					<li>
						<p>
                            I'll use Indirect Drawing for now. ChatGPU deep search didn't give me much.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Go for bindless first with drawing direct. Instead of using the 
                    <code>instanceID</code>
                    &nbsp;or similar, I just send the draw_data index via push constants. this way, the shader will be completely finalized, but then I batch the draws via draw indirect and use the 
                    <code>instanceID</code>
                    &nbsp;instead of the push constants ID
				</p>
				<ul>
					<li>
						<p>
                            What not invert and do indirect first? I cannot do that, as the 
                            <code>instanceID</code>
                            &nbsp;is useless without a bindless design! I NEED to have use for the ID, as I cannot bind desc sets or push constants for each individual draw! bindless first is a MUST.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Having to bind vertex buffers per-draw would not work for a fully bindless design.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    Indirect Drawing:
				</p>
			</li>
			<li>
				<p>
                    Full bindless:
				</p>
				<ul>
					<li>
						<p>
                            Using a large index buffer: We need to bind index data. If just like the vertex data, index data is allocated in one large index buffer, we only need to bind it once using 
                            <code>vkCmdBindIndexBuffer</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Some hardware doesn‚Äôt support vertex buffers as a first-class entity, and the driver has to emulate vertex buffer binding, which causes some CPU-side slowdowns when using 
                            <code>vkCmdBindVertexBuffers</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            In a fully bindless design, we need to assume that all vertex buffers are suballocated in one large buffer and either use per-draw vertex offsets (
                            <code>vertexOffset</code>
                            &nbsp;argument to 
                            <code>vkCmdDrawIndexed</code>
                            ) to have hardware fetch data from it, or pass an offset in this buffer to the shader with each draw call and fetch data from the buffer in the shader. Both approaches can work well, and might be more or less efficient depending on the GPU.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Mesh Shaders.
				</p>
				<ul>
					<li>
						<p>
                            Mesh Shaders is probably what is most true to the bindless strategy, but I won't go that way yet (too soon, too new).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Compute</s>
				</p>
				<ul>
					<li>
						<p>
                            Maybe I could use a compute to do this for me, but then I'd lose the rasterizer.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            Descriptor indexing is also known by the term &quot;bindless&quot;, which refers to the fact that binding individual descriptor sets and descriptors is no longer the primary way we keep shader pipelines fed. Instead, we can bind a huge descriptor set once and just index into a large number of descriptors.
		</p>
	</li>
	<li>
		<p>
            Adds a 
			<strong>
                lot
			</strong>
            &nbsp;of flexibility to how resources are accessed.
		</p>
	</li>
	<li>
		<p>
            &quot;Bindless algorithms&quot; are generally built around this flexibility where we either index freely into a lot of descriptors at once, or update descriptors where we please. In this model, &quot;binding&quot; descriptors is not a concern anymore.
		</p>
	</li>
	<li>
		<p>
            The core functionality of this extension is that we can treat descriptor memory as one massive array, and we can freely access any resource we want at any time, by indexing.
		</p>
	</li>
	<li>
		<p>
            If an array is large enough, an index into that array is indistinguishable from a pointer.
		</p>
	</li>
	<li>
		<p>
            At most, we need to write/copy descriptors to where we need them and we can now consider descriptors more like memory blobs rather than highly structured API objects.
		</p>
	</li>
	<li>
		<p>
            The introduction of descriptor indexing revealed that the descriptor model is all just smoke and mirrors. A descriptor is just a blob of binary data that the GPU can interpret in some meaningful way. The API calls to manage descriptors really just boils down to ‚Äúcopy magic bits here.‚Äù
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor Indexing was created in 2018, so all hardware 2018+ should support it.
				</p>
			</li>
			<li>
				<p>
                    Core in Vulkan 1.2+
				</p>
			</li>
			<li>
				<p>
                    Limits queried using 
                    <code>VkPhysicalDeviceDescriptorIndexingPropertiesEXT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Features queried using 
                    <code>VkPhysicalDeviceDescriptorIndexingFeaturesEXT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Features toggled using 
                    <code>VkPhysicalDeviceDescriptorIndexingFeaturesEXT</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Required for
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Raytracing.
				</p>
			</li>
			<li>
				<p>
                    Many GPU Driven Rendering approaches.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    No costly transfer of descriptor to GPU every frame. Shows up as spending a lot of time in 
                    <code>vkUpdateDescriptorSets</code>
                    &nbsp;(Vulkan)
				</p>
			</li>
			<li>
				<p>
                    More flexible / dynamic rendering architecture
				</p>
			</li>
			<li>
				<p>
                    No manual tracking of per-object resource groups
				</p>
			</li>
			<li>
				<p>
                    Updating matrices and material data can be done in bulk before command recording
				</p>
			</li>
			<li>
				<p>
                    CPU and GPU refer to resources the same way, by index
				</p>
			</li>
			<li>
				<p>
                    GPU can store Texture IDs in a buffer for reference later in the frame ‚Äì many uses
				</p>
			</li>
			<li>
				<p>
                    Easy Vertex Pulling ‚Äì gets rid of binding vertex buffers
				</p>
			</li>
			<li>
				<p>
                    Write resource indexes from one shader into a buffer that another shader reads &amp; uses
				</p>
			</li>
			<li>
				<p>
                    G-Buffer can use material ID instead of values
				</p>
			</li>
			<li>
				<p>
                    Terrain Splatmap contains material IDs allowing many materials to be used, instead of 4
				</p>
			</li>
			<li>
				<p>
                    And more‚Ä¶
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Requires hardware support
				</p>
				<ul>
					<li>
						<p>
                            May be too new for widespread use
						</p>
					</li>
					<li>
						<p>
                            Different ‚Äúfeature levels‚Äù can help ease transition
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Different Performance Penalties
				</p>
				<ul>
					<li>
						<p>
                            Arrays indexing can cause memory indirections
						</p>
						<ul>
							<li>
								<p>
                                    Fetching texture descriptors from an array indexed by material data indexed by material index can add an extra indirection on GPU compared to some alternative designs
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ‚ÄúWith great power comes great responsibility‚Äù
				</p>
				<ul>
					<li>
						<p>
                            GPU can't verify that valid descriptors are bound
						</p>
					</li>
					<li>
						<p>
                            Validation is costlier: happens inside shaders
						</p>
					</li>
					<li>
						<p>
                            Can be difficult to debug
						</p>
					</li>
					<li>
						<p>
                            Descriptor management is up to the Application
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    On some hardware, various descriptor set limits may make this technique impractical to implement; to be able to index an arbitrary texture dynamically from the shader, 
                    <code>maxPerStageDescriptorSampledImages</code>
                    &nbsp;should be large enough to accomodate all material textures - while many desktop drivers expose a large limit here, the specification only guarantees a limit of 16, so bindless remains out of reach on some hardware that otherwise supports Vulkan.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Comparison: Indexing resources without the extension
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250814083757.png" width="600" >
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://chunkstories.xyz/blog/a-note-on-descriptor-indexing/" 
						class="external-link" 
						target="_blank" >
                        Descriptor Indexing, explanation of &quot;dynamic non-uniform&quot;
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Good read.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Constant Indexing
					</em>
                    :
				</p>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D Tex[4];

texture(Tex[0], ...);
texture(Tex[2], ...);

// We can trivially flatten a constant-indexed array into individual resources,
// so, constant indexing requires no fancy hardware indexing support.
layout(set = 0, binding = 0) uniform sampler2D Tex0;
layout(set = 0, binding = 1) uniform sampler2D Tex1;
layout(set = 0, binding = 2) uniform sampler2D Tex2;
layout(set = 0, binding = 3) uniform sampler2D Tex3;
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Image Array Dynamic Indexing
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The dynamic indexing features allow us to use a non-constant expression to index an array.
						</p>
						<ul>
							<li>
								<p>
                                    This has been supported since Vulkan 1.0.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The restriction is that the index must be 
							<em>
                                dynamically uniform
							</em>
                            .
						</p>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D Tex[4];

texture(Tex[dynamically_uniform_expression], ...);
</code></pre>
			</li>
			<li>
				<p>
					<em>
                        Non-uniform vs Texture Atlas vs Texture Array
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Accessing arbitrary textures in a draw call is not a new problem, and graphics programmers have found ways over the years to workaround restrictions in older APIs. Rather than having multiple textures, it is technically possible to pack multiple textures into one texture resource, and sample from the correct part of the texture. This kind of technique is typically referred to as &quot;texture atlas&quot;. Texture arrays (e.g. sampler2DArray) is another feature which can be used for similar purposes.
						</p>
					</li>
					<li>
						<p>
                            Problems with atlas:
						</p>
						<ul>
							<li>
								<p>
                                    Mip-mapping is hard to implement, and must likely be done manually with derivatives and math.
								</p>
							</li>
							<li>
								<p>
                                    Anisotropic filtering is basically impossible.
								</p>
							</li>
							<li>
								<p>
                                    Any other sampler addressing than 
                                    <code>CLAMP_TO_EDGE</code>
                                    &nbsp;is very awkward to implement.
								</p>
							</li>
							<li>
								<p>
                                    Cannot use different texture formats.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Problems with texture array:
						</p>
						<ul>
							<li>
								<p>
                                    All resolutions must match.
								</p>
							</li>
							<li>
								<p>
                                    Number of array layers is limited (just 256 in min-spec).
								</p>
							</li>
							<li>
								<p>
                                    Cannot use different texture formats.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Non-uniform indexing solves these issues since we can freely use multiple sampled image descriptors instead. Atlases and texture arrays still have their place. There are many use cases where these restrictions do not cause problems.
						</p>
					</li>
					<li>
						<p>
                            Non-uniform indexing is not just limited to textures (although that is the most relevant use case). Any descriptor type can be used as long as the device supports it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="features" >
    Features
</h5>
<ul>
	<li>
		<p>
			<strong>
                Update-after-bind
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In Vulkan, you generally have to create a 
                    <code>VkDescriptorSet</code>
                    &nbsp;and update it with all descriptors before you call 
                    <code>vkCmdBindDescriptorSets</code>
                    . After a set is bound, the descriptor set cannot be updated again until the GPU is done using it. This gives drivers a lot of flexibility in how they access the descriptors. They are free to copy the descriptors and pack them somewhere else, promote them to hardware registers, the list goes on.
				</p>
			</li>
			<li>
				<p>
                    Update-After-Bind gives flexibility to applications instead. Descriptors can be updated at any time as long as they are not actually accessed by the GPU. Descriptors can also be updated while the descriptor set is bound to a command buffer, which enables a &quot;streaming&quot; use case.
				</p>
				<ul>
					<li>
						<p>
                            This means the application doesn‚Äôt have to unbind or re-record command buffers just to change descriptors‚Äîreducing CPU overhead in some streaming-resource scenarios.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Concurrent Updates
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Another &quot;hidden&quot; feature of update-after-bind is that it is possible to update the descriptor set from multiple threads. This is very useful for true &quot;bindless&quot; since unrelated tasks might want to update descriptors in different parts of the streamed/bindless descriptor set.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        After and after
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250816104712.png" width="275" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Non-uniform indexing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    While update-after-bind adds flexibility to descriptor management, non-uniform indexing adds great flexibility for shaders.
				</p>
			</li>
			<li>
				<p>
                    It completely removes all restrictions on how we index into arrays, but we must notify our intent to the compiler.
				</p>
			</li>
			<li>
				<p>
                    Normally, drivers and hardware can assume that the dynamically uniform guarantee holds, and optimize for that case.
				</p>
			</li>
			<li>
				<p>
                    If we use the 
                    <code>nonuniformEXT</code>
                    &nbsp;decoration in 
                    <code>GL_EXT_nonuniform_qualifier</code>
                    &nbsp;we can let the compiler know that the guarantee does not necessarily hold, and the compiler will deal with it in the most efficient way possible for the target hardware. The rationale for having to annotate like this is that driver compiler backends would be forced to be more conservative than necessary if applications were not required to use 
                    <code>nonuniformEXT</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        When to use it
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                The invocation group
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The invocation group is a set of threads (invocations) which work together to perform a task.
								</p>
							</li>
							<li>
								<p>
                                    In graphics pipelines, the invocation group is all threads which are spawned as part of a single draw command. This includes multiple instances, and for multi-draw-indirect it is limited to a single 
                                    <code>gl_DrawID</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    In compute pipelines, the invocation group is a single workgroup, so it‚Äôs very easy to know when it is safe to avoid nonuniformEXT.
								</p>
							</li>
							<li>
								<p>
                                    An expression is considered 
									<strong>
                                        dynamically uniform
									</strong>
                                    &nbsp;if all invocations in an invocation group have the same value.
								</p>
								<ul>
									<li>
										<p>
                                            In other words, 
											<strong>
                                                dynamically uniform
											</strong>
                                            &nbsp;means that the index is the same across all threads spawned by a draw command.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Interaction with Subgroups
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It is very easy to think that dynamically uniform just means &quot;as long as the index is uniform in the subgroup, it‚Äôs fine!&quot;. This is certainly true for most (desktop) architectures, but not all.
								</p>
							</li>
							<li>
								<p>
                                    It is technically possible that a value can be subgroup uniform, but still not dynamically uniform. Consider a case where we have a workgroup size of 128 threads, with a subgroup size of 32. Even if each subgroup does 
                                    <code>subgroupBroadcastFirst()</code>
                                    &nbsp;on the index, each subgroup might have different values, and thus, we still technically need 
                                    <code>nonuniformEXT</code>
                                    &nbsp;here. If you know that you have only one subgroup per workgroup however, 
                                    <code>subgroupBroadcastFirst()</code>
                                    &nbsp;is good enough.
								</p>
							</li>
							<li>
								<p>
                                    The safe thing to do is to just add 
                                    <code>nonuniformEXT</code>
                                    &nbsp;if you cannot prove the dynamically uniform property. If the compiler knows that it only really cares about subgroup uniformity, it could trivially optimize away 
                                    <code>nonuniformEXT(subgroupBroadcastFirst())</code>
                                    &nbsp;anyways.
								</p>
							</li>
							<li>
								<p>
                                    The common reason to use subgroups in the first place, is that it was an old workaround for lack of true non-uniform indexing, especially for desktop GPUs. A common pattern would be something like:
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="implementation" >
    Implementation
</h5>
<ul>
	<li>
		<p>
			<strong>
                Exemples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    odin_cool_engine:
				</p>
				<ul>
					<li>
						<p>
                            <code>odin_cool_engine/src/rp_ui.odin</code>
						</p>
						<ul>
							<li>
								<p>
                                    It just sends an index to the compute pipeline via push constants.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>odin_cool_engine/src/renderer.odin:725</code>
						</p>
						<ul>
							<li>
								<p>
                                    It just sends an index to the compute pipeline via push constants.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
					<a
						href="https://docs.vulkan.org/samples/latest/samples/extensions/descriptor_indexing/README.html#_the_sample" 
						class="external-link" 
						target="_blank" >
                        Descriptor Indexing Sample
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Setup
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    Check availability of the extension through 
                    <code>vk.EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME</code>
                    &nbsp;+ 
                    <code>vk.EnumerateDeviceExtensionProperties</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Check supported features of the extension through 
                    <code>vk.GetPhysicalDeviceFeatures2</code>
                    &nbsp;+ 
                    <code>vk.PhysicalDeviceDescriptorIndexingFeatures</code>
                    &nbsp;as the 
                    <code>pNext</code>
                    &nbsp;term.
				</p>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/refpages/latest/refpages/source/VkDescriptorSetLayoutCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetLayoutCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>UPDATE_AFTER_BIND_POOL</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that descriptor sets using this layout must be allocated from a descriptor pool created with the 
                                    <code>UPDATE_AFTER_BIND</code>
                                    &nbsp;bit set.
								</p>
							</li>
							<li>
								<p>
                                    Descriptor set layouts created with this bit set have alternate limits for the maximum number of descriptors per-stage and per-pipeline layout.
								</p>
							</li>
							<li>
								<p>
                                    The non-UpdateAfterBind limits only count descriptors in sets created without this flag. The UpdateAfterBind limits count all descriptors, but the limits may be higher than the non-UpdateAfterBind limits.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/refpages/latest/refpages/source/VkDescriptorBindingFlagBits.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorBindingFlagBits</code>
			</a>
            :
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>PARTIALLY_BOUND</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that descriptors in this binding that are not dynamically used, don't need to contain valid descriptors at the time the descriptors are consumed.
						</p>
						<ul>
							<li>
								<p>
                                    A descriptor is 'dynamically used' if any shader invocation executes an instruction that performs any memory access using the descriptor.
								</p>
							</li>
							<li>
								<p>
                                    If a descriptor is not dynamically used, any resource referenced by the descriptor is not considered to be referenced during command execution.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            This provides so it's not necessary to bind every descriptor. Allows a descriptor array binding to function even when not all array elements are written or valid.
						</p>
					</li>
					<li>
						<p>
                            This is critical if we want to make use of descriptor &quot;streaming&quot;. A descriptor only has to be bound if it is actually used by a shader.
						</p>
					</li>
					<li>
						<p>
                            Without this feature, if you have an array of N descriptors and your shader indexes [0..N-1], all descriptors must be valid; otherwise behavior is undefined even if the shader never touches the uninitialized ones.
						</p>
					</li>
					<li>
						<p>
                            When enabled, you only need to write descriptors that the shader will index. ‚ÄúHoles‚Äù in the array are allowed, provided shader indices never touch them.
						</p>
					</li>
					<li>
						<p>
                            Use this when you want to leave ‚Äúholes‚Äù in a large descriptor array (i.e. not update every element) without pre-filling unused slots with a fallback texture. When this flag is set, descriptors that are not dynamically used by the shader need not contain valid descriptors ‚Äî but if the shader actually accesses an unwritten descriptor you still get undefined/invalid results. This is a convenience to avoid writing N fallback descriptors each time.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    
                    <code>VARIABLE_DESCRIPTOR_COUNT</code>
				</p>
				<ul>
					<li>
						<p>
                            Allows a descriptor binding to have a variable number of descriptors.
						</p>
					</li>
					<li>
						<p>
                            Use a variable amount of descriptors in an array.
						</p>
					</li>
					<li>
						<p>
                            Specifies that this is a variable-sized descriptor binding, whose size will be specified when a descriptor set is allocated using this layout.
						</p>
					</li>
					<li>
						<p>
                            This must 
							<strong>
                                only
							</strong>
                            &nbsp;be used for the last binding in the descriptor set layout (i.e. the binding with the largest value of binding).
						</p>
					</li>
					<li>
						<p>
                            <code>vk.DescriptorSetLayoutBinding.descriptorCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    The value is treated as an upper bound on the size of the binding.
								</p>
							</li>
							<li>
								<p>
                                    The actual count is supplied at allocation time via 
                                    <code>VkDescriptorSetVariableDescriptorCountAllocateInfo</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    For the purposes of counting against limits such as 
                                    <code>maxDescriptorSet</code>
                                    &nbsp;and 
                                    <code>maxPerStageDescriptor</code>
                                    , the full value of 
                                    <code>descriptorCount</code>
                                    &nbsp;is counted, except for descriptor bindings with a descriptor type of 
                                    <code>DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                    , when 
                                    <code>VkDescriptorSetLayoutCreateInfo.flags</code>
                                    &nbsp;does not contain 
                                    <code>DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER</code>
                                    . In this case, 
                                    <code>descriptorCount</code>
                                    &nbsp;specifies the upper bound on the byte size of the binding; thus it counts against the 
                                    <code>maxInlineUniformBlockSize</code>
                                    &nbsp;and 
                                    <code>maxInlineUniformTotalSize</code>
                                    &nbsp;limits instead.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            When we later allocate the descriptor set, we can declare how large we want the array to be.
						</p>
					</li>
					<li>
						<p>
                            Be aware that there is a global limit to the number of descriptors can be allocated at any one time.
						</p>
					</li>
					<li>
						<p>
                            This is extremely useful when using 
                            <code>EXT_descriptor_indexing</code>
                            , since we do not have to allocate a fixed amount of descriptors for each descriptor set.
						</p>
					</li>
					<li>
						<p>
                            In many cases, it is far more flexible to use runtime sized descriptor arrays.
						</p>
					</li>
					<li>
						<p>
                            Use this when you want the shader-visible length of a descriptor-array binding to be allocatable per-descriptor-set (i.e. different sets expose different array lengths) instead of using a single compile-time/ layout upper bound. At allocation you pass the actual count with VkDescriptorSetVariableDescriptorCountAllocateInfo. This reduces bookkeeping/pool usage and lets you avoid allocating the full upper bound for every set. Requires the descriptor-indexing feature be enabled and the variable-size binding must be the last binding in the set
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>UPDATE_AFTER_BIND</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that if descriptors in this binding are updated between when the descriptor set is bound in a command buffer and when that command buffer is submitted to a queue, then the submission will use the most recently set descriptors for this binding and the updates do not invalidate the command buffer. Descriptor bindings created with this flag are also partially exempt from the external synchronization requirement in 
                            <code>vkUpdateDescriptorSetWithTemplateKHR</code>
                            &nbsp;and 
                            <code>vkUpdateDescriptorSets</code>
                            . Multiple descriptors with this flag set can be updated concurrently in different threads, though the same descriptor must not be updated concurrently by two threads. Descriptors with this flag set can be updated concurrently with the set being bound to a command buffer in another thread, but not concurrently with the set being reset or freed.
						</p>
					</li>
					<li>
						<p>
                            Update-after-bind is another critical component of descriptor indexing, which allows us to update descriptors after a descriptor set has been bound to a command buffer.
						</p>
					</li>
					<li>
						<p>
                            This is critical for streaming descriptors, but it also relaxed threading requirements. Multiple threads can update descriptors concurrently on the same descriptor set.
						</p>
					</li>
					<li>
						<p>
                            <code>UPDATE_AFTER_BIND</code>
                            &nbsp;descriptors is somewhat of a precious resource, but min-spec in Vulkan is at least 500k descriptors, which should be more than enough.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>UPDATE_UNUSED_WHILE_PENDING</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that descriptors in this binding can be updated after a command buffer has bound this descriptor set, or while a command buffer that uses this descriptor set is pending execution, as long as the descriptors that are updated are not used by those command buffers. Descriptor bindings created with this flag are also partially exempt from the external synchronization requirement in vkUpdateDescriptorSetWithTemplateKHR and vkUpdateDescriptorSets in the same way as for 
                            <code>UPDATE_AFTER_BIND</code>
                            . If 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;is also set, then descriptors can be updated as long as they are not dynamically used by any shader invocations. If 
                            <code>PARTIALLY_BOUND</code>
                            &nbsp;is not set, then descriptors can be updated as long as they are not statically used by any shader invocations.
						</p>
					</li>
					<li>
						<p>
                            Update-Unused-While-Pending is somewhat subtle, and allows you to update a descriptor while a command buffer is executing.
						</p>
					</li>
					<li>
						<p>
                            The only restriction is that the descriptor cannot actually be accessed by the GPU.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>UPDATE_AFTER_BIND</code>
                    &nbsp;vs 
                    <code>UPDATE_UNUSED_WHILE_PENDING</code>
				</p>
				<ul>
					<li>
						<p>
                            Both involve updates to descriptor sets after they are bound, 
                            <code>UPDATE_UNUSED_WHILE_PENDING</code>
                            &nbsp;is a weaker requirement since it is only about descriptors that are not used, whereas 
                            <code>UPDATE_AFTER_BIND</code>
                            &nbsp;requires the implementation to observe updates to descriptors that are used.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Enabling Non-Uniform Indexing
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    Enable 
                    <code>runtimeDescriptorArray</code>
                    &nbsp;and 
                    <code>shaderSampledImageArrayNonUniformIndexing</code>
                    &nbsp;(required for indexing an array of 
                    <code>COMBINED_IMAGE_SAMPLER</code>
                    ), 
                    <code>descriptorBindingPartiallyBound</code>
                    &nbsp;(optional, to avoid undefined behavior on not fully populated arrays).
				</p>
				<ul>
					<li>
						<p>
                            If in Vulkan &lt;1.2, then the features must be enabled in the 
                            <code>vk.PhysicalDeviceDescriptorIndexingFeatures</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If in Vulkan &gt;=1.2, then the features must be enabled in the 
                            <code>vk.PhysicalDeviceVulkan12Features</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    If this is not followed, you'll get:
								</p>
							</li>
						</ul>
<pre><code class="language-txt" data-lang="txt">[ERROR] --- vkCreateDevice(): pCreateInfo-&gt;pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not include a VkPhysicalDeviceDescriptorIndexingFeatures structure. The features in VkPhysicalDeviceDescriptorIndexingFeatures were promoted in Vulkan 1.2 and is also found in VkPhysicalDeviceVulkan12Features. To prevent one feature setting something to TRUE and the other to FALSE, only one struct containing the feature is allowed.
pNext chain: VkDeviceCreateInfo::pNext -&gt; [STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO] -&gt; [STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO] -&gt; [VkPhysicalDeviceVulkan13Features] -&gt; [VkPhysicalDeviceVulkan12Features] -&gt; [VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT] -&gt; [VkPhysicalDeviceDescriptorIndexingFeatures].
The Vulkan spec states: If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not include a VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures, or VkPhysicalDeviceVulkanMemoryModelFeatures structure (https://vulkan.lunarg.com/doc/view/1.4.328.0/windows/antora/spec/latest/chapters/devsandqueues.html#VUID-VkDeviceCreateInfo-pNext-02830)
</code></pre>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin">vulkan12_features := vk.PhysicalDeviceVulkan12Features{
&nbsp;&nbsp;&nbsp;&nbsp;// etc

&nbsp;&nbsp;&nbsp;&nbsp;descriptorIndexing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Todo: Is this only for VK 1.2?

&nbsp;&nbsp;&nbsp;&nbsp;runtimeDescriptorArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing:

&nbsp;&nbsp;&nbsp;&nbsp;shaderSampledImageArrayNonUniformIndexing = true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing: required for indexing an array of `COMBINED_IMAGE_SAMPLER`.

&nbsp;&nbsp;&nbsp;&nbsp;descriptorBindingPartiallyBound&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing: optional, to avoid undefined behavior on not fully populated arrays.

&nbsp;&nbsp;&nbsp;&nbsp;descriptorBindingVariableDescriptorCount&nbsp;&nbsp;= true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Descriptor Indexing: Allows a descriptor binding to have a variable number of descriptors.

&nbsp;&nbsp;&nbsp;&nbsp;// etc
}
</code></pre>
			</li>
			<li>
				<p>
                    In GLSL use the 
                    <code>GL_EXT_nonuniform_qualifier</code>
                    &nbsp;extension and wrap the index with 
                    <code>nonuniformEXT(...)</code>
                    &nbsp;(or apply 
                    <code>nonuniformEXT</code>
                    &nbsp;to the loaded value) so the compiler emits the SPIR-V 
                    <code>NonUniformEXT</code>
                    &nbsp;decoration.
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
					<strong>
                        In the shader
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Constructors and builtin functions, which all have return types that are not qualified by 
                            <code>nonuniformEXT</code>
                            , will not generate nonuniform results.
						</p>
						<ul>
							<li>
								<p>
                                    Shaders need to use the constructor syntax (or assignment to a 
                                    <code>nonuniformEXT</code>
                                    -qualified variable) to re-add the 
                                    <code>nonuniformEXT</code>
                                    &nbsp;qualifier to the result of builtin functions.
								</p>
							</li>
							<li>
								<p>
                                    Correct:
								</p>
								<ul>
									<li>
										<p>
                                            It is important to note that to be 100% correct, we must use:
										</p>
									</li>
									<li>
										<p>
                                            <code>nonuniformEXT(sampler2D())</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            It is the final argument to a call like 
                                            <code>texture()</code>
                                            &nbsp;which determines if the access is to be considered non-uniform.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Wrong:
								</p>
								<ul>
									<li>
										<p>
                                            It is very common in the wild to see code like:
										</p>
									</li>
									<li>
										<p>
                                            <code>sampler2D(Textures[nonuniformEXT(in_texture_index)], ...)</code>
										</p>
									</li>
									<li>
										<p>
                                            This looks very similar to HLSL, but it is somewhat wrong.
										</p>
									</li>
									<li>
										<p>
                                            Generally, it will work on drivers, but it is not technically correct.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Examples:
								</p>
								<ul>
									<li>
										<p>
                                            <code>sampler2D()</code>
                                            &nbsp;is such a constructor, so we must add 
                                            <code>nonuniformEXT</code>
                                            &nbsp;afterwards.
										</p>
										<ul>
											<li>
												<p>
                                                    <code>out_frag_color = texture(nonuniformEXT(sampler2D(Textures[in_texture_index], ImmutableSampler)), in_uv);</code>
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Other use cases:
						</p>
						<ul>
							<li>
								<p>
                                    The nonuniform qualifier will propagate up to the final argument which is used in the load/store or atomic operation.
								</p>
							</li>
							<li>
								<p>
                                    Examples:
								</p>
<pre><code class="language-glsl" data-lang="glsl">// At the top
#extension GL_EXT_nonuniform_qualifier : require

uniform UBO { vec4 data; } UBOs[];&nbsp;&nbsp; 
vec4 foo = UBOs[nonuniformEXT(index)].data;

buffer&nbsp;&nbsp;SSBO { vec4 data; } SSBOs[]; 
vec4 foo = SSBOs[nonuniformEXT(index)].data;

uniform sampler2D Tex[];
vec4 foo = texture(Tex[nonuniformEXT(index)], uv);

uniform uimage2D Img[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
uint count = imageAtomicAdd(Img[nonuniformEXT(index)], uv, val);
</code></pre>
<pre><code class="language-glsl" data-lang="glsl">#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(local_size_x = 64) in;

layout(set = 0, binding = 0) uniform sampler2D Combined[];
layout(set = 1, binding = 0) uniform texture2D Tex[];
layout(set = 2, binding = 0) uniform sampler Samp[];
layout(set = 3, binding = 0) uniform U { vec4 v; } UBO[];
layout(set = 4, binding = 0) buffer S { vec4 v; } SSBO[];
layout(set = 5, binding = 0, r32ui) uniform uimage2D Img[];

void main()
{
&nbsp;&nbsp;&nbsp;&nbsp;uint index = gl_GlobalInvocationID.x;
&nbsp;&nbsp;&nbsp;&nbsp;vec2 uv = vec2(gl_GlobalInvocationID.yz) / 1024.0;

&nbsp;&nbsp;&nbsp;&nbsp;vec4 a = textureLod(Combined[nonuniformEXT(index)], uv, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec4 b = textureLod(nonuniformEXT(sampler2D(Tex[index], Samp[index])), uv, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec4 c = UBO[nonuniformEXT(index)].v;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 d = SSBO[nonuniformEXT(index)].v;

&nbsp;&nbsp;&nbsp;&nbsp;imageAtomicAdd(Img[nonuniformEXT(index)], ivec2(0), floatBitsToUint(a.x + b.y + c.z + d.w));
}
</code></pre>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caviats:
						</p>
						<ul>
							<li>
								<p>
                                    LOD:
								</p>
								<ul>
									<li>
										<p>
                                            Using implicit LOD with nonuniformEXT can be spicy! If the threads in a quad do not have the same index, LOD might not be computed correctly.
										</p>
									</li>
									<li>
										<p>
                                            The 
                                            <code>quadDivergentImplicitLOD</code>
                                            &nbsp;property lets you know if it will work.
										</p>
									</li>
									<li>
										<p>
                                            In this case however, it is completely fine, since the helper lanes in a quad must come from the same primitive, which all have the same flat fragment input.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Avoinding 
                            <code>nonuniformEXT</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    You might consider using subgroup operations to implement 
                                    <code>nonuniformEXT</code>
                                    &nbsp;on your own.
								</p>
							</li>
							<li>
								<p>
                                    This is technically out of spec, since the SPIR-V specification states that to avoid 
                                    <code>nonuniformEXT</code>
                                    ,
								</p>
							</li>
							<li>
								<p>
                                    the shader must guarantee that the index is &quot;dynamically uniform&quot;.
								</p>
							</li>
							<li>
								<p>
                                    &quot;Dynamically uniform&quot; means the value is the same across all invocations in an &quot;invocation group&quot;.
								</p>
							</li>
							<li>
								<p>
                                    The invocation group is defined to be all invocations (threads) for:
								</p>
								<ul>
									<li>
										<p>
                                            An entire draw command (for graphics)
										</p>
									</li>
									<li>
										<p>
                                            A single workgroup (for compute).
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Avoiding 
                                    <code>nonuniformEXT</code>
                                    &nbsp;with clever programming is far more likely to succeed when writing compute shaders,
								</p>
							</li>
							<li>
								<p>
                                    since the workgroup boundary serves as a much easier boundary to control than entire draw commands.
								</p>
							</li>
							<li>
								<p>
                                    It is often possible to match workgroup to subgroup 1:1, unlike graphics where you cannot control how
								</p>
							</li>
							<li>
								<p>
                                    quads are packed into subgroups at all.
								</p>
							</li>
							<li>
								<p>
                                    The recommended approach here is to just let the compiler do its thing to avoid horrible bugs in the future.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Enabling Update-After-Bind
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    In 
                    <code>VkDescriptorSetLayoutCreateInfo</code>
                    &nbsp;we must pass down binding flags in a separate struct with 
                    <code>pNext</code>
                    .
				</p>
<pre><code class="language-odin" data-lang="odin">bindings_count := len(stage_set_layout.bindings)
descriptor_bindings_flags := make([]vk.DescriptorBindingFlagsEXT, bindings_count, context.temp_allocator)
for i in 0..&lt;len(descriptor_bindings_flags) {
&nbsp;&nbsp;&nbsp;&nbsp;descriptor_bindings_flags[i] = { .PARTIALLY_BOUND }
}
descriptor_bindings_flags[bindings_count - 1] += { .VARIABLE_DESCRIPTOR_COUNT }
&nbsp;&nbsp;&nbsp;&nbsp;// Only the last binding supports VARIABLE_DESCRIPTOR_COUNT.

descriptor_binding_flags_create_info := vk.DescriptorSetLayoutBindingFlagsCreateInfoEXT{
&nbsp;&nbsp;&nbsp;&nbsp;sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = .DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;bindingCount&nbsp;&nbsp;= u32(bindings_count),
&nbsp;&nbsp;&nbsp;&nbsp;pBindingFlags = raw_data(descriptor_bindings_flags),
&nbsp;&nbsp;&nbsp;&nbsp;pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = nil,
}
descriptor_set_layout_create_info := vk.DescriptorSetLayoutCreateInfo{
&nbsp;&nbsp;&nbsp;&nbsp;sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= .DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= {&nbsp;&nbsp;},

&nbsp;&nbsp;&nbsp;&nbsp;bindingCount = u32(bindings_count),
&nbsp;&nbsp;&nbsp;&nbsp;pBindings&nbsp;&nbsp;&nbsp;&nbsp;= raw_data(stage_set_layout.bindings),

&nbsp;&nbsp;&nbsp;&nbsp;pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &descriptor_binding_flags_create_info,
}
</code></pre>
<pre><code class="language-c" data-lang="c">// Num Descriptors
static constexpr uint32_t NumDescriptorsStreaming&nbsp;&nbsp;= 2048;
static constexpr uint32_t NumDescriptorsNonUniform = 64;

// Pool
uint32_t poolCount = NumDescriptorsStreaming + NumDescriptorsNonUniform;
VkDescriptorPoolSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool_size = vkb::initializers::descriptor_pool_size(DESCRIPTOR_TYPE_SAMPLED_IMAGE, poolCount);
VkDescriptorPoolCreateInfo pool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= vkb::initializers::descriptor_pool_create_info(1, &pool_size, 2);

// Allocate
VkDescriptorSetVariableDescriptorCountAllocateInfoEXT variable_info{};
allocate_info.pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &variable_info;

variable_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT;
variable_info.descriptorSetCount = 1;
variable_info.pDescriptorCounts = &NumDescriptorsStreaming;
CHECK(vkAllocateDescriptorSets(get_device().get_handle(), &allocate_info, &descriptors.descriptor_set_update_after_bind));
variable_info.pDescriptorCounts = &NumDescriptorsNonUniform;
CHECK(vkAllocateDescriptorSets(get_device().get_handle(), &allocate_info, &descriptors.descriptor_set_nonuniform));
</code></pre>
			</li>
			<li>
				<p>
                    The 
                    <code>VkDescriptorPool</code>
                    &nbsp;must also be created with 
                    <code>UPDATE_AFTER_BIND</code>
                    . Note that there is global limit to how many UPDATE_AFTER_BIND descriptors can be allocated at any point. The min-spec here is 500k, which should be good enough.
				</p>
			</li>
		</ol>
	</li>
</ul>
<h4
	id="strategy-descriptor-buffers-codeext_descriptor_buffer-code" >
    Strategy: Descriptor Buffers (
    <code>EXT_descriptor_buffer</code>
    )
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://www.khronos.org/blog/vk-ext-descriptor-buffer" 
				class="external-link" 
				target="_blank" >
                Article
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/descriptor_buffer_basic/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Released on (2022-11-21).
		</p>
	</li>
	<li>
		<p>
			<em>
                TLDR
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor sets are now backed by 
                    <code>VkBuffer</code>
                    &nbsp;objects where you 
                    <code>memcpy</code>
                    &nbsp;in descriptors. Delete 
                    <code>VkDescriptorPool</code>
                    &nbsp;and 
                    <code>VkDescriptorSet</code>
                    &nbsp;from the API, and have fun!
				</p>
			</li>
			<li>
				<p>
                    Performance is either equal or better.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Coming from Descriptor Indexing, we use plain uints instead of actual descriptor sets, there are some design questions that come up.
		</p>
	</li>
	<li>
		<p>
            Do we assign one uint per descriptor, or do we try to group them together such that we only need to push one base offset?
		</p>
	</li>
	<li>
		<p>
            If we go with the latter, we might end up having to copy descriptors around. If we go with one uint per descriptor, we just added extra indirection on the GPU. GPU throughput might suffer with the added latency.
		</p>
	</li>
	<li>
		<p>
            On the other hand, having to group descriptors linearly one after the other can easily lead to copy hell. Copying descriptors is still an abstracted operation that requires API calls to perform, and we cannot perform it on the GPU. The overhead of all these calls in the driver can be quite significant, especially in API layering. I‚Äôve seen up to 10 million calls to ‚Äúcopy descriptor‚Äù per second which adds up.
		</p>
	</li>
	<li>
		<p>
            Managing descriptors really starts looking more and more like just any other memory management problem. Let‚Äôs try translating existing API concepts into what they really are under the hood.
		</p>
	</li>
	<li>
		<p>
            <code>vkCreateDescriptorPool</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>vkAllocateMemory</code>
                    . Memory type unknown, but likely 
                    <code>HOST_VISIBLE</code>
                    &nbsp;and 
                    <code>DEVICE_LOCAL</code>
                    . Size of pool computed from pool entries.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkAllocateDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Linear or arena allocation from pool. Size and alignment computed from 
                    <code>VkDescriptorSetLayout</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkUpdateDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Writes raw descriptor data by copying payload from 
                    <code>VkImageView</code>
                    &nbsp;/ 
                    <code>VkSampler</code>
                    &nbsp;/ 
                    <code>VkBufferView</code>
                    . Write offset is deduced from 
                    <code>VkDescriptorSetLayout</code>
                    &nbsp;and binding. The 
                    <code>VkDescriptorSet</code>
                    &nbsp;contains a pointer to 
                    <code>HOST_VISIBLE</code>
                    &nbsp;mapped CPU memory. Copies are similar.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkCmdBindDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Binds the GPU VA of the 
                    <code>VkDescriptorSet</code>
                    &nbsp;somehow.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The descriptor buffer API effectively removes 
            <code>VkDescriptorPool</code>
            &nbsp;and 
            <code>VkDescriptorSet</code>
            . The APIs now expose lower level detail.
		</p>
	</li>
	<li>
		<p>
            For example, there‚Äôs now a bunch of properties to query:
		</p>
<pre><code class="language-c" data-lang="c">typedef struct VkPhysicalDeviceDescriptorBufferPropertiesEXT {
&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¶
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; samplerDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; combinedImageSamplerDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sampledImageDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageImageDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniformTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustUniformTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustStorageTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniformBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustUniformBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustStorageBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputAttachmentDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accelerationStructureDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¶
} VkPhysicalDeviceDescriptorBufferPropertiesEXT;
</code></pre>
	</li>
</ul>
<h4
	id="strategy-push-descriptor-codevk_khr_push_descriptor-code" >
    Strategy: Push Descriptor (
    <code>VK_KHR_push_descriptor</code>
    )
</h4>
<ul>
	<li>
		<p>
            Promoted to core in Vulkan 1.4.
		</p>
	</li>
	<li>
		<p>
            Last modified date: (2017-09-12).
		</p>
	</li>
	<li>
		<p>
            This extension allows descriptors to be written into the command buffer, while the implementation is responsible for managing their memory. Push descriptors may enable easier porting from older APIs and in some cases can be more efficient than writing descriptors into descriptor sets.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/extensions/push_descriptors" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            New Commands
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdPushDescriptorSetKHR</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If Vulkan Version 1.1 or 
            <code>VK_KHR_descriptor_update_template</code>
            &nbsp;is supported:
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdPushDescriptorSetWithTemplateKHR</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            New Structures
		</p>
		<ul>
			<li>
				<p>
                    Extending 
                    <code>VkPhysicalDeviceProperties2</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>VkPhysicalDevicePushDescriptorPropertiesKHR</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            New Enum Constants
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME</code>
				</p>
			</li>
			<li>
				<p>
                    <code>VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION</code>
				</p>
			</li>
			<li>
				<p>
                    Extending 
                    <code>VkDescriptorSetLayoutCreateFlagBits</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Extending VkStructureType:
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If Vulkan Version 1.1 or VK_KHR_descriptor_update_template is supported:
		</p>
		<ul>
			<li>
				<p>
                    Extending 
                    <code>VkDescriptorUpdateTemplateType</code>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="strategy-bindful-classic-strategy-slot-based-frequency-based" >
    <s>Strategy: Bindful / Classic strategy (Slot-based / Frequency-based)</s>
</h4>
<ul>
	<li>
		<p>
            mna (midmidmid):
		</p>
		<ul>
			<li>
				<p>
                    The reason you split up resources into multiple sets is actually to 
					<em>
                        reduce
					</em>
                    &nbsp;the cost of 
                    <code>vkCmdBindDescriptorSets</code>
                    . The idea being that if you've got one set that holds scene-wide data and a different set that holds object-specific data, you only bind the scene stuff 
					<em>
                        once
					</em>
                    &nbsp;and then just leave it bound. Then the per-object updates go faster because you're pushing much smaller descriptor sets into whatever special silicon descriptor sets map to on your particular GPU. Note: there are rules about how you have to arrange your sets (so like the scene-wide one has to be at a lower index than the per-object one), and all of the pipelines you use must have 
					<em>
                        compatible
					</em>
                    &nbsp;layouts for the sets you aren't rebinding every time you switch to a different pipeline. Someone can correct me if I'm wrong, but if you switch to a pipeline that's got an incompatible layout for some descriptor set at index 
					<em>
                        n
					</em>
                    &nbsp;then 
					<em>
                        all
					</em>
                    &nbsp;descriptor sets at indices 
					<em>
                        &gt;= n
					</em>
                    &nbsp;need to be rebound.
				</p>
			</li>
			<li>
				<p>
                    I think the only reason I'd change any of my stuff to bindless is if I hit however many hundreds of thousands of calls to 
                    <code>vkCmdBindDescriptorSets</code>
                    &nbsp;it takes for descriptors to be a per-frame bottleneck.
				</p>
			</li>
			<li>
				<p>
                    But I find descriptors pretty intuitive and easy to work with.
				</p>
			</li>
			<li>
				<p>
                    I 
					<em>
                        didn't
					</em>
                    &nbsp;find them easy to work with when I 
					<em>
                        first
					</em>
                    &nbsp;came to VK (from GL/D3D11-world), but now that I've got some scaffolding set up to manage them, they're easy sauce.
				</p>
			</li>
			<li>
				<p>
                    (They actually map pretty well to having worked with 
					<em>
                        old
					</em>
                    &nbsp;console GPUs where you manage the command queue directly and have to think about resource bindings in terms of physical registers on the GPU. It was helpful to have that background.)
				</p>
			</li>
			<li>
				<p>
                    If you're working with descriptor sets, then you have lots of little objects whose lifetimes you need to track and manage. Getting them grouped into the appropriate set of 
					<em>
                        pools
					</em>
                    &nbsp;cuts that number down to something that's not hard to manage. So, for me, I've got a dynamically allocated and recycled set of descriptor pools for stuff that changes every frame, and then I've got my materials grouped into pack files (for fast content loading) and each of those has one descriptor pool for all the sets for all of its materials. Easy peasy. For bindless, you need to figure out how you're going to divide up the big array of descriptors in your one mega set. There's different strategies for doing that. But you'll get a better description of them out of the bindless fans on the server.
				</p>
			</li>
			<li>
				<p>
                    Implementation-wise, 
					<em>
                        I
					</em>
                    &nbsp;don't think there's a huge complexity difference between the two approaches. Bindless might be 
					<em>
                        conceptually
					</em>
                    &nbsp;simpler since &quot;it's just a big array&quot; doesn't require as big of a mental shift as dividing resources up by usage and update frequency and thinking in 
					<em>
                        those
					</em>
                    &nbsp;terms.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In the ‚Äúclassic‚Äù model, before you draw or dispatch, you must bind each resource to a specific descriptor binding or slot.
		</p>
	</li>
	<li>
		<p>
            Example:
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdBindDescriptorSets(...)</code>
				</p>
			</li>
			<li>
				<p>
                    Binding texture #0 for this draw, texture #1 for that draw, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The shader uses a fixed binding index:
		</p>
		<ul>
			<li>
				<p>
                    <code>layout(set = 0, binding = 3) uniform sampler2D tex;</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you want to change which texture is used, you re-bind that descriptor.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250806171334.png" width="475" >
            .
		</p>
	</li>
</ul>
<h3
	id="specialization-constants" >
    Specialization Constants
</h3>
<ul>
	<li>
		<p>
            Allows a constant value in SPIR-V to be specified at 
            <code>VkPipeline</code>
            &nbsp;creation time.
		</p>
	</li>
	<li>
		<p>
            This is powerful as it replaces the idea of doing preprocessor macros in the high level shading language (GLSL, HLSL, etc).
		</p>
	</li>
	<li>
		<p>
            A way to provide constant values to a SPIR-V shader at pipeline creation time so the compiler can constant-fold, inline, and eliminate branches.
		</p>
		<ul>
			<li>
				<p>
                    This yields code equivalent to having compiled separate shader variants with those constant values baked in.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This is not Vulkan exclusive, but an optimization from SPIR-V. OpenGL 4.6 can also use this feature.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/specialization_constants/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            UBOs and Push Constants suffer from limited optimizations during shader compilation. Specialization Constants can provide those optimizations:
		</p>
		<ul>
			<li>
				<p>
                    Uniform buffer objects (UBOs) are one of the most common approaches when it is necessary to set values within a shader at run-time and are used in many tutorials. UBOs are pushed to the shader just prior to its execution, this is after shader compilation which occurs during 
                    <code>vkCreateGraphicsPipelines</code>
                    . As these values are set after the shader has been compiled, the driver‚Äôs shader compiler has limited scope to perform optimizations to the shader during its compilation. This is because optimizations such as loop unrolling or unused code removal require the compiler to have knowledge of the values controlling them which is not possible with UBOs. Push constants also suffer from the same problems as UBOs, as they are also provided after the shader has been compiled.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Specialization Constants
					</em>
                    &nbsp;are set before pipeline creation meaning these values are known during shader compilation, this allows the driver‚Äôs shader compiler to perform optimizations. In this optimisation process the compiler has the ability to remove unused code blocks and statically unroll which reduces the fragment cycles required by the shader which results in increased performance.
				</p>
			</li>
			<li>
				<p>
                    While specialization constants rely on knowing the required values before pipeline creation occurs, by trading off this flexibility and allowing the compiler to perform these optimizations you can increase the performance of your application easily and reduce shader code size.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use compile-time specialization constants for all control flow. This allows compilation to completely remove unused code blocks and statically unroll loops.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Don‚Äôt
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use control-flow which is parameterized by uniform values; specialize shaders for each control path needed instead.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reduced performance due to less efficient shader programs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">#version 450
layout (constant_id = 0) const float myColor = 1.0;
layout(location = 0) out vec4 outColor;

void main() {
&nbsp;&nbsp;&nbsp;&nbsp;outColor = vec4(myColor);
}
</code></pre>
<pre><code class="language-c" data-lang="c">struct myData {
&nbsp;&nbsp;&nbsp;&nbsp;float myColor = 1.0f;
} myData;

VkSpecializationMapEntry mapEntry = {};
mapEntry.constantID = 0; // matches constant_id in GLSL and SpecId in SPIR-V
mapEntry.offset&nbsp;&nbsp;&nbsp;&nbsp; = 0;
mapEntry.size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sizeof(float);

VkSpecializationInfo specializationInfo = {};
specializationInfo.mapEntryCount = 1;
specializationInfo.pMapEntries&nbsp;&nbsp; = &mapEntry;
specializationInfo.dataSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= sizeof(myData);
specializationInfo.pData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &myData;

VkGraphicsPipelineCreateInfo pipelineInfo = {};
pipelineInfo.pStages[fragIndex].pSpecializationInfo = &specializationInfo;

// Create first pipeline with myColor as 1.0
vkCreateGraphicsPipelines(&pipelineInfo);

// Create second pipeline with same shader, but sets different value
myData.myColor = 0.5f;
vkCreateGraphicsPipelines(&pipelineInfo);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Use cases
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Toggling features:
				</p>
				<ul>
					<li>
						<p>
                            Support for a feature in Vulkan isn‚Äôt known until runtime. This usage of specialization constants is to prevent writing two separate shaders, but instead embedding a constant runtime decision.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Improving backend optimizations:
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Optimizing shader compilation
							</em>
                            &nbsp;from SPIR-V to GPU.
						</p>
					</li>
					<li>
						<p>
                            The ‚Äúbackend‚Äù here refers to the implementation‚Äôs compiler that takes the resulting SPIR-V and lowers it down to some ISA to run on the device.
						</p>
					</li>
					<li>
						<p>
                            Constant values allow a set of optimizations such as 
							<a
								href="https://en.wikipedia.org/wiki/Constant_folding" 
								class="external-link" 
								target="_blank" >
                                constant folding
							</a>
                            , 
							<a
								href="https://en.wikipedia.org/wiki/Dead_code_elimination" 
								class="external-link" 
								target="_blank" >
                                dead code elimination
							</a>
                            , etc. to occur.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Affecting types and memory sizes:
				</p>
				<ul>
					<li>
						<p>
                            It is possible to set the length of an array or a variable type used through a specialization constant.
						</p>
					</li>
					<li>
						<p>
                            It is important to notice that a compiler will need to allocate registers depending on these types and sizes. This means it is likely that a pipeline cache will fail if the difference is significant in registers allocated.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How they work
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The values are supplied using 
                    <code>VkSpecializationInfo</code>
                    &nbsp;attached to the 
                    <code>VkPipelineShaderStageCreateInfo</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    In GLSL (or HLSL ‚Üí SPIR-V) mark a constant with a constant id, e.g. 
                    <code>layout(constant_id = 0) const int MATERIAL_MODE = 0;</code>
				</p>
			</li>
			<li>
				<p>
                    Create 
                    <code>VkSpecializationMapEntry</code>
                    &nbsp;entries mapping 
                    <code>constantID</code>
                    &nbsp;‚Üí offset/size in your data block.
				</p>
			</li>
			<li>
				<p>
                    Fill a contiguous data buffer with the specialization values and set up 
                    <code>VkSpecializationInfo</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Put the 
                    <code>VkSpecializationInfo*</code>
                    &nbsp;into the shader stage 
                    <code>VkPipelineShaderStageCreateInfo</code>
                    &nbsp;before calling 
                    <code>vkCreateGraphicsPipelines</code>
                    . The backend finalizes (specializes/compiles) the shader at pipeline creation time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How it affects the pipeline workflow
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It does not solve the pipeline workflow problem. It provides a system for shader optimization at SPIR-V‚ÜíGPU compile time.
						</p>
					</li>
					<li>
						<p>
                            Specialization lets you get near-compile-time optimizations while still selecting variants at runtime, but it does not avoid having multiple created pipelines if you need multiple different specialized behaviors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    They do not, by themselves, precompile every possible branch permutation and keep them all resident for you. Each distinct set of specialization values that you want available at runtime normally corresponds to a separately created pipeline (the specialization values are applied during pipeline creation).
				</p>
			</li>
			<li>
				<p>
                    If you need multiple variants you must create (or reuse) the pipelines for those values.
				</p>
			</li>
			<li>
				<p>
                    If you have N independent boolean specialization choices, the number of possible specialized pipelines is 2^N (exponential growth). Creating many pipelines increases driver/state memory and creation time; use caching/derivatives/libraries if creation cost or count is a concern.
				</p>
			</li>
			<li>
				<p>
                    You cannot change a specialization constant per draw without binding a different pipeline: the specialization is fixed for the pipeline object, so per-draw changes require binding another pipeline or using a different strategy (uniforms, push constants, dynamic branching).
				</p>
			</li>
			<li>
				<p>
                    Different values mean different pipeline creation (driver work / memory).
				</p>
			</li>
			<li>
				<p>
                    &quot;Is this a way to precompile every branching of a shader?&quot;
				</p>
				<ul>
					<li>
						<p>
                            Yes, but only if you actually create a pipeline for each variant.
						</p>
					</li>
					<li>
						<p>
                            Specialization constants let the driver compile-away branches at pipeline-creation time, but they do not magically produce all variants for you at draw time.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Recommendations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://blogs.igalia.com/itoral/2018/03/20/improving-shader-performance-with-vulkans-specialization-constants/?utm_source=chatgpt.com" 
						class="external-link" 
						target="_blank" >
                        Improving shader performance with vulkan's specialization constants
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            When we create the Vulkan pipeline, we pass this specialization information using the 
                            <code>pSpecializationInfo</code>
                            &nbsp;field of 
                            <code>VkPipelineShaderStageCreateInfo</code>
                            . At that point, the driver will override the default value of the specialization constant with the value provided here before the shader code is optimized and native GPU code is generated, which allows the driver compiler backend to generate optimal code.
						</p>
					</li>
					<li>
						<p>
                            It is possible to compile the same shader with different constant values in different pipelines, so even if a value changes often, so long as we have a finite number of combinations, we can generate optimized pipelines for each one ahead of the start of the rendering loop and just swap pipelines as needed while rendering.
						</p>
					</li>
					<li>
						<p>
                            &quot;promote the UBO array to a push constant&quot;.
						</p>
					</li>
					<li>
						<p>
                            Applying specialization constants in a small number of shaders allowed me to benefit from loop unrolling and, most importantly, UBO promotion to push constants in the SSAO pass, obtaining performance improvements that ranged from 10% up to 20% depending on the configuration.
						</p>
					</li>
					<li>
						<p>
                            In other words:
						</p>
						<ul>
							<li>
								<p>
                                    The article shows how it's possible to pass a value to the shader during graphics pipeline creation so the shader is compiled from SPIR-V to GPU with that constant altered.
								</p>
							</li>
							<li>
								<p>
                                    This helps by allowing the SPIR-V‚ÜíGPU compiler to make optimization choices such as unrolling loops and removing branches; it can also enable UBO promotion.
								</p>
							</li>
							<li>
								<p>
                                    The article does not suggest specialization constants solve the pipeline workflow problem. It focuses on compile-time shader optimizations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="physical-storage-buffer-codekhr_buffer_device_address-code" >
    Physical Storage Buffer (
    <code>KHR_buffer_device_address</code>
    )
</h3>
<ul>
	<li>
		<p>
			<em>
                Impressions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    (2025-09-08)
				</p>
			</li>
			<li>
				<p>
                    No descriptor sets.
				</p>
				<ul>
					<li>
						<p>
                            Cool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Very easy to set up.
				</p>
			</li>
			<li>
				<p>
                    Shader usage is a bit tricky; push constants are required to access buffers in many patterns.
				</p>
			</li>
			<li>
				<p>
                    More prone to programmer errors because there is no automatic bounds checking.
				</p>
			</li>
			<li>
				<p>
                    Hmm, idk, for now not sure.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Adds the ability to have ‚Äúpointers in the shader‚Äù.
		</p>
	</li>
	<li>
		<p>
            Buffer device address is a powerful and unique feature of Vulkan. It exposes GPU virtual addresses directly to the application, and the application can then use those addresses to access buffer data freely through pointers rather than descriptors.
		</p>
	</li>
	<li>
		<p>
            This feature lets you place addresses in buffers and load and store to them inside shaders, with full capability to perform pointer arithmetic and other tricks.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.3.
				</p>
			</li>
			<li>
				<p>
                    Submitted at (2019-01-06), core at (2019-11-25).
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=KHR_buffer_device_address" 
						class="external-link" 
						target="_blank" >
                        Coverage
					</a>
                    :
				</p>
				<ul>
					<li>
						<p>
                            (2025-09-08) 71.6%
						</p>
					</li>
					<li>
						<p>
                            79.8% Windows
						</p>
					</li>
					<li>
						<p>
                            70.9% Linux
						</p>
					</li>
					<li>
						<p>
                            68.7% Android
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lack of safety
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A critical thing to note is that a raw pointer has no idea of how much memory is safe to access. Unlike SSBOs when bounds-checking features are enabled, you must either do range checks yourself or avoid relying on out-of-bounds behavior.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Creating a buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    To be able to grab a device address from a 
                    <code>VkBuffer</code>
                    , you must create the buffer with 
                    <code>SHADER_DEVICE_ADDRESS</code>
                    &nbsp;usage.
				</p>
			</li>
			<li>
				<p>
                    The memory you bind that buffer to must be allocated with the corresponding flag via 
                    <code>pNext</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">VkMemoryAllocateFlagsInfoKHR flags_info{STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR};
flags_info.flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = MEMORY_ALLOCATE_DEVICE_ADDRESS_KHR;
memory_allocation_info.pNext = &flags_info;
</code></pre>
		<ul>
			<li>
				<p>
                    After allocating and binding the buffer, query the address:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c">VkBufferDeviceAddressInfoKHR address_info{STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR};
address_info.buffer = buffer.buffer;
buffer.gpu_address&nbsp;&nbsp;= vkGetBufferDeviceAddressKHR(device, &address_info);
</code></pre>
		<ul>
			<li>
				<p>
                    This address behaves like a normal address; you can offset the 
                    <code>VkDeviceAddress</code>
                    &nbsp;value as you see fit since it is a 
                    <code>uint64_t</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    There is no host-side alignment requirement enforced by the API for this value.
				</p>
			</li>
			<li>
				<p>
                    When using this pointer in shaders, you must provide and respect alignment semantics yourself, because the shader compiler cannot infer anything about a raw pointer loaded from memory.
				</p>
			</li>
			<li>
				<p>
                    You can place this pointer inside another buffer and use it as an indirection.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                <code>GL_EXT_buffer_reference</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In Vulkan GLSL, the 
                    <code>GL_EXT_buffer_reference</code>
                    &nbsp;extension allows declaring buffer blocks as pointer-like types rather than SSBOs. GLSL lacks true pointer types, so this extension exposes pointer-like behavior.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#extension GL_EXT_buffer_reference : require
</code></pre>
		<ul>
			<li>
				<p>
                    You can forward-declare types. Useful for linked lists and similar structures.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(buffer_reference) buffer Position;
</code></pre>
		<ul>
			<li>
				<p>
                    You can declare a buffer reference type. This is not an SSBO declaration, but effectively a pointer-to-struct.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, buffer_reference, buffer_reference_align = 8) writeonly buffer Position {
&nbsp;&nbsp;&nbsp;&nbsp;vec2 positions[];
};
</code></pre>
		<ul>
			<li>
				<p>
                    <code>buffer_reference</code>
                    &nbsp;tags the type accordingly. 
                    <code>buffer_reference_align</code>
                    &nbsp;marks the minimum alignment for pointers of this type.
				</p>
			</li>
			<li>
				<p>
                    You can place the 
                    <code>Position</code>
                    &nbsp;type inside another buffer or another buffer reference type:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer PositionReferences {
&nbsp;&nbsp;&nbsp;&nbsp;Position buffers[];
};
</code></pre>
		<ul>
			<li>
				<p>
                    Now you have an array of pointers.
				</p>
			</li>
			<li>
				<p>
                    You can also place a buffer reference inside push constants, an SSBO, or a UBO.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(std430, set = 0, binding = 0) readonly buffer Pointers {
&nbsp;&nbsp;&nbsp;&nbsp;Positions positions[];
};

layout(std430, push_constant) uniform Registers {
&nbsp;&nbsp;&nbsp;&nbsp;PositionReferences references;
} registers;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Casting pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A key aspect of buffer device address is that we gain the capability to cast pointers freely.
				</p>
			</li>
			<li>
				<p>
                    While it is technically possible (and useful in some cases!) to &quot;cast pointers&quot; with SSBOs with clever use of aliased declarations like so:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) buffer SSBO { float v1[]; };
layout(set = 0, binding = 0) buffer SSBO2 { vec4 v4[]; };
</code></pre>
		<ul>
			<li>
				<p>
                    It gets kind of hairy quickly, and not as flexible when dealing with composite types.
				</p>
			</li>
			<li>
				<p>
                    When we have casts between integers and pointers, we get the full 
					<strong>
                        madness
					</strong>
                    &nbsp;that is pointer arithmetic. Nothing stops us from doing:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#extension GL_EXT_buffer_reference : require
layout(buffer_reference) buffer PointerToFloat { float v; };

PointerToFloat pointer = load_pointer();
uint64_t int_pointer = uint64_t(pointer);
int_pointer += offset;
pointer = PointerToFloat(int_pointer);
pointer.v = 42.0;
</code></pre>
		<ul>
			<li>
				<p>
                    Not all GPUs support 64-bit integers, so it is also possible to use 
                    <code>uvec2</code>
                    &nbsp;to represent pointers. This way, we can do raw pointer arithmetic in 32-bit, which might be more optimal anyways.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">#extension GL_EXT_buffer_reference_uvec2 : require
layout(buffer_reference) buffer PointerToFloat { float v; };
PointerToFloat pointer = load_pointer();
uvec2 int_pointer = uvec2(pointer);
uint carry;
uint lo = uaddCarry(int_pointer.x, offset, carry);
uint hi = int_pointer.y + carry;
pointer = PointerToFloat(uvec2(lo, hi));
pointer.v = 42.0;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Debugging
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    When debugging or capturing an application that uses buffer device addresses, there are some special driver requirements that are not universally supported. Essentially, to be able to capture application buffers which contain raw pointers, we must ensure that the device address for a given buffer remains stable when the capture is replayed in a new process. Applications do not have to do anything here, since tools like RenderDoc will enable the 
                    <code>bufferDeviceAddressCaptureReplay</code>
                    &nbsp;feature for you, and deal with all the magic associated with address capture behind the scenes. If the 
                    <code>bufferDeviceAddressCaptureReplay</code>
                    &nbsp;is not present however, tools like RenderDoc will mask out the 
                    <code>bufferDeviceAddress</code>
                    &nbsp;feature, so beware.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/buffer_device_address/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250813093236.png" width="500" >
            .
		</p>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-10-21 .&nbsp;&nbsp;2026-02-01 üöÄ
			</footer>
		</div>
		<script
			src="/static/studies.88482.js" >
		</script>
	</body>
</html>
