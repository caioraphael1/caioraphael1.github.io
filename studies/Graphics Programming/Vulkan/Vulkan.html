<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/favicon.ico" >
		<link
			rel="icon" 
			href="/assets/favicon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/favicon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script
			src="/static/docs_load.js" >
		</script>
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			src="https://unpkg.com/@highlightjs/cdn-assets@11.11.1/highlight.min.js" >
		</script>
		<script
			src="https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.min.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
					open="">
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Design
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - DOD e COP/Design - DOD e COP.html" >
                                Design - DOD e COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - ECS/Design - ECS.html" >
                                Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Design Patterns/Design - Design Patterns.html" >
                                Design - Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Architecture Patterns.html" >
                                Design - Architecture Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Concepts and Terminology.html" >
                                Design - Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Rules of thumb - Laws - Guidelines and Principles/Design - Rules of thumb - Laws - Guidelines and Principles.html" >
                                Design - Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Paradigms.html" >
                                Design - Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design/Design - Production Methodologies/Design - Production Methodologies.html" >
                                Design - Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Things
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/NeoVim - Uso/NeoVim - Uso.html" >
                                NeoVim - Uso
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Dependencies.html" >
                                Dependencies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Things/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML - Tests/HTML - Tests.html" >
                                HTML - Tests
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Electronics
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Electronics/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<header
				id="central-header" >
				<nav
					id="dropdown-menu" >
					<select
						onchange="if (this.value) window.location.href=this.value" >
						<option
							value="/" 
>
                            🏡 Home
						</option>
						<option
							value="/studies/_index.html" 
							selected="">
                            📖 Studies
						</option>
					</select>
				</nav>
				<button
					class="btn" 
					id="button-color-theme" >
					<i>
                        ☀️ / 🌑
					</i>
				</button>
			</header>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Vulkan
						</h1>
						<p>
							<time
								datetime="2025-08-01" >
                                🕒 Created: 2025-08-01
							</time>
							<time
								datetime="2025-10-28" >
                                | Updated: 2025-10-28
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="about" >
    About
</h2>
<h5
	id="versions" >
    Versions
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/versions.html" 
				class="external-link" 
				target="_blank" >
                Versions and Features Breakdown
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Patch notes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/vulkan_release_summary.html" 
				class="external-link" 
				target="_blank" >
                Version Release Summary
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=7CtjMfDdTdg" 
				class="external-link" 
				target="_blank" >
                Why not use Vulkan 1.0? {12:57 -&gt; end}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    1.0 is harder, with missing features and clunky interfaces.
				</p>
			</li>
			<li>
				<p>
                    The video is pretty nice. I listed the problems it explained about 1.0 and placed them in the documentation below.
				</p>
			</li>
			<li>
				<p>
                    It was well explained and I came to appreciate using Vulkan 1.3+.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="is-oop" >
    Is OOP?
</h5>
<ul>
	<li>
		<p>
            Version 1.3, [2024/02/22].
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250801065314.png" width="375" >
            .
		</p>
	</li>
</ul>
<h5
	id="api-structs" >
    API Structs
</h5>
<ul>
	<li>
		<p>
            Many structures in Vulkan require you to explicitly specify the type of structure in the 
            <code>sType</code>
            &nbsp;member.
		</p>
	</li>
	<li>
		<p>
            Functions that create or destroy an object will have a 
            <code>VkAllocationCallbacks</code>
            &nbsp;parameter that allows you to use a custom allocator for driver memory, which will also be left 
            <code>nullptr</code>
            &nbsp;in this tutorial.
		</p>
	</li>
	<li>
		<p>
            Almost all functions return a 
            <code>VkResult</code>
            &nbsp;that is either 
            <code>VK_SUCCESS</code>
            &nbsp;or an error code. The specification describes which error codes each function can return and what they mean.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>KHR</code>
            &nbsp;postfix, which means that these objects are part of a Vulkan extension.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>pNext</code>
            &nbsp;member can point to an extension structure.
		</p>
	</li>
</ul>
<h3
	id="compatibility" >
    Compatibility
</h3>
<h5
	id="support" >
    Support
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/platforms.html" 
				class="external-link" 
				target="_blank" >
                Platform Support
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/checking_for_support.html" 
				class="external-link" 
				target="_blank" >
                Checking for Vulkan support
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Windows (7 and later)
		</p>
		<ul>
			<li>
				<p>
                    Yes, via the official SDK and drivers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Linux
		</p>
		<ul>
			<li>
				<p>
                    Yes. Native support via Mesa and vendor drivers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Android (5.0+)
		</p>
		<ul>
			<li>
				<p>
                    Yes, most devices from Android 7.0+ support Vulkan.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            macOS
		</p>
		<ul>
			<li>
				<p>
                    No native support — requires MoltenVK (Vulkan-to-Metal wrapper).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            iOS
		</p>
		<ul>
			<li>
				<p>
                    No native support — requires MoltenVK.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Web
		</p>
		<ul>
			<li>
				<p>
                    No native support — experimental via WebGPU or Emscripten with translation layers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Consoles.
		</p>
		<ul>
			<li>
				<p>
                    Partially supported; depends on platform SDKs and NDAs (e.g., Nintendo Switch uses a Vulkan-like API).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="driver-support" >
    Driver support
</h5>
<ul>
	<li>
		<p>
            Vulkan requires updated GPU drivers.
		</p>
	</li>
	<li>
		<p>
            Older or integrated GPUs (especially pre-2013) may lack Vulkan support.
		</p>
	</li>
	<li>
		<p>
            Vendor support varies: NVIDIA, AMD, and Intel generally support Vulkan on most modern hardware.
		</p>
	</li>
</ul>
<h5
	id="compatibility-layers" >
    Compatibility Layers
</h5>
<ul>
	<li>
		<p>
            To increase compatibility.
		</p>
	</li>
	<li>
		<p>
			<strong>
                MoltenVK
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Runs Vulkan on Metal (required for macOS/iOS).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                gfx-rs / wgpu / bgfx
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Abstraction layers to use Vulkan when available, fallback to other APIs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                ANGLE / Zink
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can translate other APIs (e.g., OpenGL) to Vulkan and vice-versa.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="tutorials" >
    Tutorials
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/" 
				class="external-link" 
				target="_blank" >
                Vulkan Specs
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html" 
				class="external-link" 
				target="_blank" >
                Complete Vulkan Spec
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vulkan.lunarg.com/sdk/home" 
				class="external-link" 
				target="_blank" >
                Vulkan SDK
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://pkg.odin-lang.org/vendor/vulkan/" 
				class="external-link" 
				target="_blank" >
                Vulkan Odin
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="tutorials-in-docs" >
    Tutorials in Docs
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://docs.vulkan.org/guide/latest/memory_allocation.html" 
				class="external-link" 
				target="_blank" >
                Docs Vulkan Guide
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I already read everything before the memory allocation section.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://docs.vulkan.org/tutorial/latest/00_Introduction.html" 
				class="external-link" 
				target="_blank" >
                Docs Vulkan Tutorial
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Based on the vulkan-tutorial, with differences:
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.4 as a baseline
						</p>
					</li>
					<li>
						<p>
                            Dynamic rendering instead of render passes
						</p>
					</li>
					<li>
						<p>
                            Timeline semaphores
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://shader-slang.org/" 
								class="external-link" 
								target="_blank" >
                                Slang
							</a>
                            &nbsp;as the primary shading language
						</p>
					</li>
					<li>
						<p>
                            Modern C++ (20) with modules
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/KhronosGroup/Vulkan-Hpp" 
								class="external-link" 
								target="_blank" >
                                Vulkan-Hpp
							</a>
                            &nbsp;with 
							<a
								href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" 
								class="external-link" 
								target="_blank" >
                                RAII
							</a>
						</p>
					</li>
					<li>
						<p>
                            It also contains Vulkan usage clarifications, improved synchronization and new content.
						</p>
					</li>
					<li>
						<p>
                            &quot;This tutorial will use RAII with smart pointers and it will endeavor to demonstrate the latest methods and extensions which should hopefully make Vulkan a joy to use.&quot;
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Does not require knowledge of previous APIs, but you need to know C++ and graphics math.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Holy moly the new C++ API is a pain.
						</p>
					</li>
					<li>
						<p>
                            I preferred to go back to the 
							<em>
                                vulkan-tutorial
							</em>
                            &nbsp;several times and check how it's used in the C API.
						</p>
					</li>
					<li>
						<p>
                            I used this tutorial only as a base to consider the new features.
						</p>
					</li>
					<li>
						<p>
                            I didn't use Slang, I didn't like it; I stayed with GLSL.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://vulkan-tutorial.com/" 
				class="external-link" 
				target="_blank" >
                vulkan-tutorial
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Does not require knowledge of previous APIs, but you need to know C++ and graphics math.
				</p>
			</li>
			<li>
				<p>
                    You can use C, but the tutorial is in C++.
				</p>
			</li>
			<li>
				<p>
                    Vulkan 1.0; shown 
					<a
						href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance" 
						class="external-link" 
						target="_blank" >
                        here
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Uses GLSL for shaders.
				</p>
			</li>
			<li>
				<p>
                    <s>
					<a
						href="https://gist.github.com/terickson001/bdaa52ce621a6c7f4120abba8959ffe6" 
						class="external-link" 
						target="_blank" >
                        vulkan-tutorial example in Odin - terickson001
					</a>
                    </s>.
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.0.
						</p>
					</li>
					<li>
						<p>
                            Window with GLFW.
						</p>
					</li>
					<li>
						<p>
                            1250 lines.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Impressions
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    They use render passes.
								</p>
							</li>
							<li>
								<p>
                                    I tested it and it works.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Interesting
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Minimal use of global variables.
										</p>
									</li>
									<li>
										<p>
                                            Elements are correctly separated into functions.
										</p>
									</li>
									<li>
										<p>
                                            Uses 
                                            <code>"shared:shaderc"</code>
                                            &nbsp;to compile shaders at runtime, in the 
                                            <code>compile_shader</code>
                                            &nbsp;proc.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Bad
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            It came with several syntax errors, weird...
										</p>
									</li>
									<li>
										<p>
                                            There are semaphore errors in validation layers when compiling, drawn in the excalidraw syncs.
										</p>
									</li>
									<li>
										<p>
                                            Uses 
                                            <code>"shared:shaderc"</code>
                                            ..... I don't have that lib.
										</p>
									</li>
									<li>
										<p>
                                            <code>using</code>
                                            &nbsp;everywhere; 35 times in total.
										</p>
									</li>
									<li>
										<p>
                                            I really didn't like some of the ways the person programs.
										</p>
										<ul>
											<li>
												<p>
                                                    The person 
													<em>
                                                        clearly
													</em>
                                                    &nbsp;was a C/C++ programmer.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Does not check for extension availability when creating the instance.
										</p>
									</li>
									<li>
										<p>
                                            Some things are unused:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>create_surface -&gt; surface_create_info</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Stores queue families in an ok way, but deals with them very strangely: 
                                            <code>queue_indices: [QueueFamily]int</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Overall: naaaah.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<a
						href="https://gist.github.com/laytan/ba57af3e5a59ab5cb2fca9e25bcfe262" 
						class="external-link" 
						target="_blank" >
                        vulkan-tutorial example in Odin - laytan
					</a>
                    </s>.
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.0.
						</p>
					</li>
					<li>
						<p>
                            Window with GLFW.
						</p>
					</li>
					<li>
						<p>
                            900 lines.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Impressions
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    They use render passes.
								</p>
							</li>
							<li>
								<p>
                                    I tested it and it works.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Bad
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Global variables everywhere.
										</p>
									</li>
									<li>
										<p>
                                            Everything in main.
										</p>
									</li>
									<li>
										<p>
                                            There are semaphore errors in validation layers when compiling, drawn in my excalidraw syncs sketches.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/bwasty/vulkan-tutorial-rs" 
						class="external-link" 
						target="_blank" >
                        vulkan-tutorial-rust
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~
			<a
				href="https://vkguide.dev/" 
				class="external-link" 
				target="_blank" >
                Vulkan Guide
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    For people with previous experience with Graphics APIs.
				</p>
			</li>
			<li>
				<p>
                    I'm not a big fan of this guide.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Uses
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.3.
						</p>
					</li>
					<li>
						<p>
                            C++, Visual Studio, CMake.
						</p>
					</li>
					<li>
						<p>
                            SDL to create a window.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/charles-lunarg/vk-bootstrap/blob/master/src/VkBootstrap.cpp" 
								class="external-link" 
								target="_blank" >
                                Vk Bootstrap
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Abstracts a big amount of boilerplate that Vulkan has when setting up. Most of that code is written once and never touched again, so we will skip most of it using this library. This library simplifies instance creation, swapchain creation, and extension loading. It will be removed from the project eventually in an optional chapter that explains how to initialize that Vulkan boilerplate the “manual” way.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator" 
								class="external-link" 
								target="_blank" >
                                VMA (Vulkan Memory Allocator)
							</a>
						</p>
						<ul>
							<li>
								<p>
                                    Implements memory allocators for Vulkan, header only. In Vulkan, the user has to deal with the memory allocation of buffers, images, and other resources on their own. This can be very difficult to get right in a performant and safe way. Vulkan Memory Allocator does it for us and allows us to simplify the creation of images and other resources. Widely used in personal Vulkan engines or smaller scale projects like emulators. Very high end projects like Unreal Engine or AAA engines write their own memory allocators.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The tutorial gives you a project with many things already done, and holds your hand for every syntax, file, folder, methodology, etc.
						</p>
						<ul>
							<li>
								<p>
                                    It simply throws a lot of stuff at you.
								</p>
							</li>
							<li>
								<p>
                                    It's a pretty 
									<em>
                                        bloated
									</em>
                                    &nbsp;experience, for sure.
								</p>
							</li>
							<li>
								<p>
                                    I consider that a pain.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/SaschaWillems/Vulkan" 
				class="external-link" 
				target="_blank" >
                Samples Collections in C++
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://gpuopen.com/learn/vulkan-barriers-explained/" 
				class="external-link" 
				target="_blank" >
                Vulkan Barriers Explained
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://gpuopen.com/learn/developing-vulkan-apps/" 
				class="external-link" 
				target="_blank" >
                Vulkan AMD Blog Posts
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/" 
				class="external-link" 
				target="_blank" >
                Writing an Efficient Vulkan Renderer
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="playlists" >
    Playlists
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://www.youtube.com/watch?v=j7e73AkmFUI&list=PLI3kBEQ3yd-D4CmRqdFoNii4z62t3vK6G&index=2" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan with Odin - Nadako
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Vulkan 1.3, with Dynamic Rendering.
				</p>
			</li>
			<li>
				<p>
                    I watched videos 1 through 11.
				</p>
			</li>
			<li>
				<p>
                    They are good videos.
				</p>
			</li>
			<li>
				<p>
                    I do not recommend them to someone who has never seen anything before, because they are not exactly for beginners and their explanations lack some foundation.
				</p>
			</li>
			<li>
				<p>
                    I recommend them as a reference for how to set up in Odin.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=EsEP9iJKBhU&list=PLA0dXqQjCx0RntJy1pqje9uHRF1Z5vZgA" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan - OGLDEV
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    C++, with Visual Studio.
				</p>
			</li>
			<li>
				<p>
                    Assumes you have seen another GPU API before.
				</p>
			</li>
			<li>
				<p>
                    Video 1:
				</p>
				<ul>
					<li>
						<p>
                            Window with GLFW, not explained.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 8:
				</p>
				<ul>
					<li>
						<p>
                            Theory explanation ok; code explanation meh.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 12:
				</p>
				<ul>
					<li>
						<p>
                            Synchronization with 1 frame in-flight.
						</p>
					</li>
					<li>
						<p>
                            Good video.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Video 16</s>:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor Sets.
						</p>
					</li>
					<li>
						<p>
                            Nope. See the spec, guides, or other videos on the subject, I think it's better.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 21:
				</p>
				<ul>
					<li>
						<p>
                            Dynamic Rendering.
						</p>
					</li>
					<li>
						<p>
                            {0:00 -&gt; 12:14}
						</p>
						<ul>
							<li>
								<p>
                                    Explanation of the code to obtain the EXT for Vulkan 1.2, and ignore it for Vulkan 1.3
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The rest of the video is irrelevant, it does not explain anything beyond what to change if someone is following his code line by line.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/watch?v=Est5AvResbE&list=PLn3eTxaOtL2Nr89hYzKPib7tvce-ZO4yB" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan 2024 - GetIntoGameDev
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Overall
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The person seems nice and I like when he draws things.
						</p>
					</li>
					<li>
						<p>
                            Unfortunately 95% of the series videos are code in C++ and he does not do a good job explaining the code.
						</p>
					</li>
					<li>
						<p>
                            I listed some videos below that I considered interesting.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Vulkan 1.3.
				</p>
			</li>
			<li>
				<p>
                    Video 12:
				</p>
				<ul>
					<li>
						<p>
                            Synchronization, with 1 frame in-flight.
						</p>
					</li>
					<li>
						<p>
                            The drawings are nice.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ~Video 13:
				</p>
				<ul>
					<li>
						<p>
                            Multithreaded rendering.
						</p>
					</li>
					<li>
						<p>
                            Nope. See the Multithreading Rendering section to understand why &quot;nope&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Video 26:
				</p>
				<ul>
					<li>
						<p>
                            Barycentric coordinates.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Only code, so nope
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Videos: 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<a
						href="https://www.youtube.com/watch?v=2NVlG9TFT1c&list=PLn3eTxaOtL2NH5nbPHMK7gE07SqhcAjmk&index=3" 
						class="external-link" 
						target="_blank" >
                        Playlist Vulkan - GetIntoGameDev
					</a>
                    </s>.
				</p>
				<ul>
					<li>
						<p>
                            Vulkan 1.2, 2022/01/22.
						</p>
					</li>
					<li>
						<p>
                            Watch the new 2024 version of the tutorials.
						</p>
					</li>
					<li>
						<p>
                            The person sometimes explains on a sheet of paper, which is nice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            <s>
			<a
				href="https://www.youtube.com/watch?v=tLwbj9qys18&list=PLmIqTlJ6KsE1Jx5HV4sd2jOe3V1KMHHgn&index=1" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan - Computer Graphics at TU Wien
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Vulkan 1.2.
				</p>
			</li>
			<li>
				<p>
                    Video 1:
				</p>
				<ul>
					<li>
						<p>
                            SDK, Instances, extensions, physical devices, logical devices.
						</p>
					</li>
					<li>
						<p>
                            Ok.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 2:
				</p>
				<ul>
					<li>
						<p>
                            Presentation Modes, Swapchain.
						</p>
					</li>
					<li>
						<p>
                            {10:20 -&gt; 21:45}
						</p>
						<ul>
							<li>
								<p>
                                    Explanation of all Presentation Modes.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 3:
				</p>
				<ul>
					<li>
						<p>
                            Explanation of Buffers and Images.
						</p>
					</li>
					<li>
						<p>
                            The explanation seemed s a bit rushed and the definition is poorly established.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            I can return and rewatch the video after reading the documentation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 4:
				</p>
				<ul>
					<li>
						<p>
                            Commands, Command Pools, Command Buffers.
						</p>
					</li>
					<li>
						<p>
                            Ok, sure.
						</p>
					</li>
					<li>
						<p>
                            I skipped the descriptor sets part.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 5:
				</p>
				<ul>
					<li>
						<p>
                            Pipelines.
						</p>
					</li>
					<li>
						<p>
                            I skipped it.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 6:
				</p>
				<ul>
					<li>
						<p>
                            Synchronization.
						</p>
					</li>
					<li>
						<p>
                            Skipped.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Impressions
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I don't like the illustrations, nor the tone of the explanation.
						</p>
					</li>
					<li>
						<p>
                            I simply feel I learn more and feel more confident reading the documentation or the spec.
						</p>
					</li>
					<li>
						<p>
                            The videos are &quot;more technical&quot;, but when that is the case documentation is better.
						</p>
					</li>
					<li>
						<p>
                            I prefer a simpler playlist to learn some basic concepts, and to read the documentation for advanced topics.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/@BrendanGalea/videos" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan - Brendan Galea
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    Vulkan 1.0.
				</p>
			</li>
			<li>
				<p>
                    C++, with Visual Studio.
				</p>
			</li>
			<li>
				<p>
                    It's a pain to see C++ code.
				</p>
			</li>
			<li>
				<p>
                    The sketch explanations in the middle of the videos are ok, but the rest is very bad; all code-related parts are unpleasant and with a LOT of mess in C++.
				</p>
			</li>
			<li>
				<p>
                    Video 1:
				</p>
				<ul>
					<li>
						<p>
                            Window with GLFW.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 2:
				</p>
				<ul>
					<li>
						<p>
                            Light explanation of the graphics pipeline.
						</p>
					</li>
					<li>
						<p>
                            {9:54}
						</p>
						<ul>
							<li>
								<p>
                                    Shader compilation, to SPIR-V.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Video 20:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor Sets
						</p>
					</li>
					<li>
						<p>
                            {0:00 -&gt; 5:35} Nice explanation.
						</p>
					</li>
					<li>
						<p>
                            The rest of the video is nah.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=PDPRhlh44TU&list=PLFAIgTeqcARkeHm-RimFyKET6IZPxlBSt&index=1&pp=iAQB" 
				class="external-link" 
				target="_blank" >
                Vulkan playlist - Cakez
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    C++
				</p>
			</li>
			<li>
				<p>
                    Starts by teaching how to install Visual Studio and Git...
				</p>
			</li>
			<li>
				<p>
                    Does not use GLFW, instead creates its own platform layer on Windows to create a window.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=vURfULK5wH4&list=PLS1lqxOwNjOYcAkRHQRpGCwQvJMMRNyOG&index=1&pp=iAQB" 
				class="external-link" 
				target="_blank" >
                Vulkan playlist - Francesco Piscani
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    He uses the vulkan-tutorial.
				</p>
			</li>
			<li>
				<p>
                    Spends the first 4 episodes doing basically nothing, just setting up CMake and Linux.
				</p>
			</li>
			<li>
				<p>
                    Nope, it sounds bad as tutorials.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="talks" >
    Talks
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=p4iZMbXZbW8" 
				class="external-link" 
				target="_blank" >
                Vulkan in Doom 3
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Use RenderDoc extensively.
				</p>
			</li>
			<li>
				<p>
                    1 Render Pass, 1 subpass, 3 attachments.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250506145949.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Buffers and Images
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250506150028.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allocations:
				</p>
				<ul>
					<li>
						<p>
                            VMA for allocators.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250506150330.png" width="275" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250506150344.png" width="275" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    28 shaders + changes =&gt; 100 pipelines total at runtime.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250810104501.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Synchronization:
				</p>
				<ul>
					<li>
						<p>
                            Not much of it. Doom 3 was single-threaded, it didn't require multithreading.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="samples" >
    Samples
</h2>
<ul>
	<li>
		<p>
			<strong>
                To run
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Git clone recursively the repo.
				</p>
			</li>
			<li>
				<p>
                    Build the entire solution.
				</p>
			</li>
			<li>
				<p>
                    <code>Vulkan-Samples\build\windows\app\bin\debug\AMD64</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Copy the 
                    <code>shaders</code>
                    &nbsp;and 
                    <code>assets</code>
                    &nbsp;folders from 
                    <code>Vulkan-Samples</code>
                    &nbsp;to the folder above.
				</p>
			</li>
			<li>
				<p>
                    Type 
                    <code>.\vulkan_samples sample sample_name</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Note
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Normal and hpp have the same performance; or whatever, it does not matter.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impressions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The extension samples were more visually &quot;uninteresting&quot;.
				</p>
			</li>
			<li>
				<p>
                    I saw all API samples, but I didn't see all Extensions.
				</p>
			</li>
			<li>
				<p>
                    There were still other folders besides these two, but I was lazy to check.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="api" >
    API
</h3>
<ul>
	<li>
		<p>
            instancing
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804091417.png" width="375" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Wow, awesome.
				</p>
			</li>
			<li>
				<p>
                    The fps is very high.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            oit_linked_lists (Order Independent Transparency)
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804091728.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            oit_depth_peeling (Order Independent Transparency)
		</p>
		<ul>
			<li>
				<p>
                    The object in the center rotates with the mouse.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250804091553.png" width="550" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            compute_nbody
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090637.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_uniform_buffers.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090448.png" width="425" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            hdr
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090853.png" width="325" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows changing the object, toggling the skybox, changing the exposure, toggling bloom.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            terrain_tessellation
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092025.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Increasing the tessellation factor made it look like the terrain polycount increased.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            timestamp_queries
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092759.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows changing the object, toggling the skybox, changing the exposure, toggling bloom.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            separate_image_sampler
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804091834.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows selecting linear or nearest filtering.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            texture_loading
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092338.png" width="425" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows increasing the LOD bias, reducing image quality.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            texture_mipmap_generation
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804092555.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Allows calibrating the LOD bias, and choosing between mipmap off, bilinear and anisotropic.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            hello_triangle_1_3 / hello_triangle
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804090058.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Nothing special
				</p>
			</li>
			<li>
				<p>
                    No dynamic resize.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="extensions" >
    Extensions
</h3>
<ul>
	<li>
		<p
			class="line-emphasis" >
			<input
				type="checkbox" 
				disabled=""
>
            dynamic_line_rasterization
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250908185944.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This sample demonstrates functions from various extensions related to dynamic line rasterization.
				</p>
			</li>
			<li>
				<p>
                    These functions can be useful for developing CAD applications.
				</p>
			</li>
			<li>
				<p>
                    From the 
                    <code>VK_EXT_line_rasterization</code>
                    &nbsp;extension.
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetLineStippleEXT</code>
                            &nbsp;- sets the stipple pattern.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    From the 
                    <code>VK_EXT_extended_dynamic_state3</code>
                    &nbsp;extension:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetPolygonModeEXT</code>
                            &nbsp;- sets how defined primitives should be rasterized.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetLineRasterizationModeEXT</code>
                            &nbsp;- sets the algorithm for line rasterization.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetLineStippleEnableEXT</code>
                            &nbsp;- toggles stippling for lines.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    And also from core Vulkan:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetLineWidth</code>
                            &nbsp;- sets the line width.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetPrimitiveTopologyEXT</code>
                            &nbsp;- defines which type of primitives is being drawn.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            debug utils
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093636.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Toggle bloom, toggle skybox.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>VK_EXT_debug_utils</code>
                    &nbsp;extension to setup a validation layer messenger callback and pass additional debugging information to debuggers like RenderDoc.
				</p>
			</li>
			<li>
				<p>
                    <code>VK_EXT_debug_utils</code>
                    &nbsp;has been introduced based on feedback for the initial Vulkan debugging extensions 
                    <code>VK_EXT_debug_report</code>
                    &nbsp;and 
                    <code>VK_EXT_debug_marker</code>
                    , combining these into a single instance extension with some added functionality.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Procedure examples
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdBeginDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdInsertDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdEndDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkQueueBeginDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkQueueInsertDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkQueueEndDebugUtilsLabelEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkSetDebugUtilsObjectNameEXT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>vkSetDebugUtilsObjectTagEXT</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            conditional_rendering
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093352.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    A list of 235 parts of the car, which can be disabled to not render.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>VK_EXT_conditional_rendering</code>
                    &nbsp;extension allows the execution of rendering commands to be conditional based on a value taken from a dedicated conditional buffer.
				</p>
			</li>
			<li>
				<p>
                    This may help an application reduce latency by conditionally discarding rendering commands without application intervention.
				</p>
			</li>
			<li>
				<p>
                    This sample demonstrates usage of this extension for conditionally toggling the visibility of sub-meshes of a complex glTF model.
				</p>
			</li>
			<li>
				<p>
                    Instead of having to update command buffers, this is done by updating the aforementioned buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            conservative_rasterization
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093524.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Enabling the conservative rasterization option causes this blending effect.
				</p>
			</li>
			<li>
				<p>
                    <code>VK_EXT_conservative_rasterization</code>
                    &nbsp;changes the way fragments are generated.
				</p>
			</li>
			<li>
				<p>
                    Enables overestimation to generate fragments for every pixel 
					<em>
                        touched
					</em>
                    &nbsp;instead of only pixels that are fully covered.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            color_write_enable
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093158.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Color picker to change the background color.
				</p>
			</li>
			<li>
				<p>
                    Some options for &quot;bit&quot;, changing the triangle color.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>VK_EXT_color_write_enable</code>
                    &nbsp;extension allows toggling the output color attachments using a pipeline dynamic state.
				</p>
			</li>
			<li>
				<p>
                    It allows the program to prepare an additional framebuffer populated with the data from a defined color blend attachment which can be blended dynamically to the final scene.
				</p>
			</li>
			<li>
				<p>
                    The final results are comparable to those obtained with 
                    <code>vkCmdSetColorWriteMaskEXT</code>
                    , but it does not require the GPU driver to support 
                    <code>VK_EXT_extended_dynamic_state3</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_blending
		</p>
		<ul>
			<li>
                <img src="assets/image_20250804094024.png" width="500" >

			</li>
			<li>
				<p>
                    This sample demonstrates the functionality of 
                    <code>VK_EXT_extended_dynamic_state3</code>
                    &nbsp;related to blending.
				</p>
			</li>
			<li>
				<p>
                    It includes the following features:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkCmdSetColorBlendEnableEXT</code>
                            : toggles blending on and off.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetColorBlendEquationEXT</code>
                            : modifies blending operators and factors.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetColorBlendAdvancedEXT</code>
                            : utilizes more complex blending operators.
						</p>
					</li>
					<li>
						<p>
                            <code>vkCmdSetColorWriteMaskEXT</code>
                            : toggles individual channels on and off.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            descriptor_indexing
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093822.png" width="500" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~descriptor_buffer_basic
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093739.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Just boxes rotating, I didn't understand.
				</p>
			</li>
			<li>
				<p>
                    Just textures rotating, I didn't understand.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_multisample_rasterization
		</p>
		<ul>
			<li>
				<p>
                    This sample demonstrates one of the functionalities of 
                    <code>VK_EXT_extended_dynamic_state3</code>
                    &nbsp;related to rasterization samples.
				</p>
			</li>
			<li>
				<p>
                    The extension can be used to dynamically change sampling without the need to swap pipelines.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250908190252.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This thing took quite a while to open, generating binary files, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            dynamic_primitive_clipping
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250908190422.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This sample demonstrates how to apply 
					<em>
                        depth clipping
					</em>
                    &nbsp;using the 
                    <code>vkCmdSetDepthClipEnableEXT()</code>
                    &nbsp;command which is a part of the 
                    <code>VK_EXT_extended_dynamic_state3</code>
                    &nbsp;extension.
				</p>
			</li>
			<li>
				<p>
                    Additionally it also shows how to apply 
					<em>
                        primitive clipping
					</em>
                    &nbsp;using the 
                    <code>gl_ClipDistance[]</code>
                    &nbsp;builtin shader variable.
				</p>
			</li>
			<li>
				<p>
                    It is worth noting that 
					<em>
                        primitive clipping
					</em>
                    &nbsp;and 
					<em>
                        depth clipping
					</em>
                    &nbsp;are two separate features of the fixed-function vertex post-processing stage.
				</p>
			</li>
			<li>
				<p>
                    They're both described in the same chapter of the Vulkan specification (chapter 27.4, &quot;Primitive clipping&quot;).
				</p>
			</li>
			<li>
				<p>
                    What is primitive clipping
				</p>
				<ul>
					<li>
						<p>
                            Primitives produced by vertex/geometry/tessellation shaders are sent to fixed-function vertex post-processing.
						</p>
					</li>
					<li>
						<p>
                            Primitive clipping is a part of post-processing pipeline in which primitives such as points/lines/triangles are culled against the cull volume and then clipped to the clip volume.
						</p>
					</li>
					<li>
						<p>
                            And then they might be further clipped by results stored in the 
                            <code>gl_ClipDistance[]</code>
                            &nbsp;array - values in this array must be calculated in a vertex/geometry/tessellation shader.
						</p>
					</li>
					<li>
						<p>
                            In the past, the fixed-function version of the OpenGL API provided a method to specify parameters for up to 6 clipping planes (half-spaces) that could perform additional primitive clipping. Fixed-function hardware calculated proper distances to these planes and made a decision - should the primitive be clipped against these planes or not (for historical study - search for the 
                            <code>glClipPlane()</code>
                            &nbsp;description).
						</p>
					</li>
					<li>
						<p>
                            Vulkan inherited the idea of primitive clipping, but with one important difference: the user has to calculate the distance to the clip planes on their own in the vertex shader.
						</p>
					</li>
					<li>
						<p>
                            And - because the user does it in a shader - they do not have to use clip planes at all. It can be any kind of calculation, as long as the results are put in the 
                            <code>gl_ClipDistance[]</code>
                            &nbsp;array.
						</p>
					</li>
					<li>
						<p>
                            Values that are less than 0.0 cause the vertex to be clipped. In the case of a triangle primitive the whole triangle is clipped if all of its vertices have values stored in 
                            <code>gl_ClipDistance[]</code>
                            &nbsp;below 0.0. When some of these values are above 0.0 - the triangle is split into new triangles as described in the Vulkan specification.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    What is depth clipping
				</p>
				<ul>
					<li>
						<p>
                            When depth clipping is disabled then effectively there is no near or far plane clipping.
						</p>
					</li>
					<li>
						<p>
                            Depth values of primitives that are behind the far plane are clamped to the far plane depth value (usually 1.0).
						</p>
					</li>
					<li>
						<p>
                            Depth values of primitives that are in front of the near plane are clamped to the near plane depth value (by default it's 0.0, but may be set to -1.0 if we use settings defined in 
                            <code>VkPipelineViewportDepthClipControlCreateInfoEXT</code>
                            &nbsp;structure. This requires the presence of the 
                            <code>VK_EXT_depth_clip_control</code>
                            &nbsp;extension which is not part of this tutorial).
						</p>
					</li>
					<li>
						<p>
                            In this sample the result of depth clipping (or lack of it) is not clearly visible at first. Try to move the viewer position closer to the object and see how the &quot;use depth clipping&quot; checkbox changes object appearance.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~buffer_device_address.
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250804093016.png" width="500" >
                    .
				</p>
			</li>
			<li>
				<p>
                    I didn't understand. It's just things moving.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            ~calibrated_timestamps
		</p>
		<ul>
			<li>
				<p>
                    timestamp_queries, but with other timings.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="core" >
    Core
</h2>
<h3
	id="instance-extensions-validation-layers" >
    Instance / Extensions / Validation Layers
</h3>
<h5
	id="instance" >
    Instance
</h5>
<ul>
	<li>
		<p>
            <code>VkInstance</code>
		</p>
		<ul>
			<li>
				<p>
                    The Vulkan context, used to access drivers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The instance is the connection between your application and the Vulkan library.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkApplicationInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkApplicationInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Optional, but it may provide some useful information to the driver to optimize our specific application.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstanceCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>vkInstanceCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Tells the Vulkan driver which global extensions and validation layers we want to use.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="instance-level-extensions" >
    Instance Level Extensions
</h5>
<ul>
	<li>
		<p>
            <code>vkEnumerateInstanceExtensionProperties()</code>
		</p>
		<ul>
			<li>
				<p>
                    Retrieve a list of supported extensions before creating an instance.
				</p>
			</li>
			<li>
				<p>
                    Each 
                    <code>VkExtensionProperties</code>
                    &nbsp;struct contains the name and version of an extension.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="validation-layers" >
    Validation Layers
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/layers.html" 
				class="external-link" 
				target="_blank" >
                Layers
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Vulkan is designed for high performance and low driver overhead, therefore, it will include very limited error checking and debugging capabilities by default.
		</p>
	</li>
	<li>
		<p>
            The driver will often 
			<strong>
                crash
			</strong>
            &nbsp;instead of returning an error code if you do something wrong, or worse, it will appear to work on your graphics card and completely 
			<strong>
                fail
			</strong>
            &nbsp;on others.
		</p>
	</li>
	<li>
		<p>
            Vulkan allows you to enable extensive checks through a feature known as 
			<em>
                validation layers
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Validation layers are pieces of code that can be inserted between the API and the graphics driver to do things like running extra checks on function parameters and tracking memory management problems.
		</p>
	</li>
	<li>
		<p>
            The nice thing is that you can enable them during development and then completely disable them when releasing your application for zero overhead. Anyone can write their own validation layers, but the Vulkan SDK by LunarG provides a standard set of validation layers. You also need to register a callback function to receive debug messages from the layers.
		</p>
	</li>
	<li>
		<p>
            Because Vulkan is so explicit about every operation and the validation layers are so extensive, it can actually be a lot 
			<em>
                easier
			</em>
            &nbsp;to find out why your screen is black compared to OpenGL and Direct3D!
		</p>
	</li>
	<li>
		<p>
            Common operations in validation layers are:
		</p>
		<ul>
			<li>
				<p>
                    Checking the values of parameters against the specification to detect misuse
				</p>
			</li>
			<li>
				<p>
                    Tracking the creation and destruction of objects to find resource leaks
				</p>
			</li>
			<li>
				<p>
                    Checking thread safety by tracking the threads that calls originate from
				</p>
			</li>
			<li>
				<p>
                    Logging every call and its parameters to the standard output
				</p>
			</li>
			<li>
				<p>
                    Tracing Vulkan calls for profiling and replaying
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            There were formerly two different types of validation layers in Vulkan: 
			<em>
                instance
			</em>
            &nbsp;and 
			<em>
                device
			</em>
            &nbsp;specific.
		</p>
	</li>
	<li>
		<p>
            The idea was that instance layers would only check calls related to global Vulkan objects like instances, and device-specific layers would only check calls related to a specific GPU.
		</p>
	</li>
	<li>
		<p>
            Device-specific layers have now been 
			<strong>
                deprecated
			</strong>
            , which means that instance validation layers apply to all Vulkan calls.
		</p>
	</li>
	<li>
		<p>
            We don’t really need to check for the existence of this extension because it should be implied by the availability of the validation layers.
		</p>
	</li>
	<li>
		<p>
            <code>vkEnumerateInstanceLayerProperties</code>
		</p>
	</li>
	<li>
		<p>
			<strong>
                RenderDoc
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Do not run validation at the same time as RenderDoc, otherwise you'll also be validating RenderDoc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Vulkan Configurator
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Overwrites the normal Layer setup.
				</p>
			</li>
			<li>
				<p>
                    Implicitly loads layers.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        How to use
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            RIGHT-CLICK.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="message-callback" >
    Message Callback
</h5>
<ul>
	<li>
		<p>
            The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program.
		</p>
	</li>
	<li>
		<p>
            This will also allow you to decide which kind of messages you would like to see.
		</p>
	</li>
	<li>
		<p>
            <code>messageSeverity</code>
		</p>
	</li>
	<li>
		<p>
            <code>messageType</code>
		</p>
	</li>
	<li>
		<p>
            <code>pfnUserCallback</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>messageSeverity</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Diagnostic message
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Informational message like the creation of a resource
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Message about behavior that is not necessarily an error, but very likely a bug in your application
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Message about behavior that is invalid and may cause crashes.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>messageType</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Some event has happened that is unrelated to the specification or performance
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Something has happened that violates the specification or indicates a possible mistake
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Potential non-optimal use of Vulkan
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCallbackData</code>
				</p>
				<ul>
					<li>
						<p>
                            Refers to a 
                            <code>VkDebugUtilsMessengerCallbackDataEXT</code>
                            &nbsp;struct containing the details of the message itself, with the most important members being:
						</p>
					</li>
					<li>
						<p>
                            <code>pMessage</code>
						</p>
						<ul>
							<li>
								<p>
                                    The debug message as a null-terminated string
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pObjects</code>
						</p>
						<ul>
							<li>
								<p>
                                    Array of Vulkan object handles related to the message
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>objectCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Number of objects in the array
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pUserData</code>
				</p>
				<ul>
					<li>
						<p>
                            Contains a pointer specified during the setup of the callback and allows you to pass your own data to it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="window-surface-glfw" >
    Window / Surface / GLFW
</h3>
<h5
	id="window" >
    Window
</h5>
<ul>
	<li>
		<p>
            The Vulkan API itself is completely platform-agnostic, which is why we need to use the standardized WSI (Window System Interface) extension to interact with the window manager.
		</p>
	</li>
	<li>
		<p>
            Windows can be created with the native platform APIs or libraries like 
			<a
				href="https://www.glfw.org/" 
				class="external-link" 
				target="_blank" >
                GLFW
			</a>
            &nbsp;and 
			<a
				href="https://www.libsdl.org/" 
				class="external-link" 
				target="_blank" >
                SDL
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Some platforms allow you to render directly to a display without interacting with any window manager through the 
            <code>VK_KHR_display</code>
            &nbsp;and 
            <code>VK_KHR_display_swapchain</code>
            &nbsp;extensions.
		</p>
	</li>
	<li>
		<p>
            These allow you to create a surface that represents the entire screen and could be used to implement your own window manager, for example.
		</p>
	</li>
</ul>
<h5
	id="glfw" >
    GLFW
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://www.glfw.org/docs/latest/topics.html" 
				class="external-link" 
				target="_blank" >
                GLFW Reference
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The very first call in 
            <code>initWindow</code>
            &nbsp;should be 
            <code>glfwInit()</code>
            , which initializes the GLFW library. Because GLFW was originally designed to create an OpenGL context, we need to tell it to not create an OpenGL context with a later call:
		</p>
	</li>
	<li>
		<p>
            Because handling resized windows takes special care that we’ll look into later, disable it for now with another window hint call:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
</code></pre>
<ul>
	<li>
		<p>
            All that’s left now is creating the actual window. Add a 
            <code>GLFWwindow* window;</code>
            &nbsp;private class member to store a reference to it and initialize the window with:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
</code></pre>
<ul>
	<li>
		<p>
            The first three parameters specify the width, height and title of the window. The fourth parameter allows you to optionally specify a monitor to open the window on, and the last parameter is only relevant to OpenGL.
		</p>
	</li>
	<li>
		<p>
            Init:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">void initWindow() {
&nbsp;&nbsp;&nbsp;&nbsp;glfwInit();

&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

&nbsp;&nbsp;&nbsp;&nbsp;window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
}
</code></pre>
<ul>
	<li>
		<p>
            Main loop:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">void mainLoop() {
&nbsp;&nbsp;&nbsp;&nbsp;while (!glfwWindowShouldClose(window)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfwPollEvents();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Destroy:
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">void cleanup() {
&nbsp;&nbsp;&nbsp;&nbsp;glfwDestroyWindow(window);

&nbsp;&nbsp;&nbsp;&nbsp;glfwTerminate();
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Blocking the Thread
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.glfw.org/docs/3.3/group__window.html#ga37bd57223967b4211d60ca1a0bf3c832" 
						class="external-link" 
						target="_blank" >
                        glfw.PollEvents
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.glfw.org/docs/3.3/group__window.html#ga1c5c7eb889c33c7f4d10dd35b327654e" 
						class="external-link" 
						target="_blank" >
                        glfw.SetWindowRefreshCallback
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/glfw/glfw/pull/1426" 
						class="external-link" 
						target="_blank" >
                        PR to improve this
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="surface" >
    Surface
</h5>
<ul>
	<li>
		<p>
            A 
            <code>VkSurfaceKHR</code>
            &nbsp;is an opaque handle representing a platform-specific presentation target (for example, a window on Windows, an X11 window on Linux, or a UIView on iOS). It is created directly from the Vulkan instance together with a native window handle. Conceptually, a surface is:
		</p>
		<ul>
			<li>
				<p>
                    Instance-level: it lives above any physical or logical device.
				</p>
			</li>
			<li>
				<p>
                    Window abstraction: it wraps the OS window or drawable so that Vulkan knows where to submit images for display.
				</p>
			</li>
			<li>
				<p>
                    Device-agnostic: you can create a surface before choosing which GPU you will use.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Once created, the surface is used by a chosen physical device to query presentation support, formats and capabilities, and then by the logical device to build a Swapchain.
		</p>
	</li>
	<li>
		<p>
            A surface itself is not intrinsically tied to any particular physical or logical device, because:
		</p>
		<ul>
			<li>
				<p>
                    Creation: you call 
                    <code>vkCreateSurfaceKHR(instance, …)</code>
                    &nbsp;without involving a 
                    <code>VkPhysicalDevice</code>
                    &nbsp;or 
                    <code>VkDevice</code>
                    &nbsp;handle.
				</p>
			</li>
			<li>
				<p>
                    Lifetime: it exists even before you pick or create a device, and you destroy it with 
                    <code>vkDestroySurfaceKHR(instance, surface, …)</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lifetime
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The surface is tied to the GLFW window's lifecycle.
				</p>
			</li>
			<li>
				<p>
                    It 
					<em>
                        does not change
					</em>
                    &nbsp;when the window is resized, minimized, or restored.
				</p>
			</li>
			<li>
				<p>
                    The same surface handle remains valid until you destroy it (e.g., when closing the window).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            &quot;Window surfaces are part of the larger topic of render targets and presentation&quot;.
		</p>
	</li>
	<li>
		<p>
			<a
				href="http://vulkan2.gpuinfo.org/listsurfaceformats.php?platform=windows" 
				class="external-link" 
				target="_blank" >
                Surface Formats
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="extensions" >
    Extensions
</h5>
<ul>
	<li>
		<p>
            To establish the connection between Vulkan and the window system to present results to the screen, we need to use the WSI (Window System Integration) extensions.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VK_KHR_surface</code>
            &nbsp;exposes a 
            <code>VkSurfaceKHR</code>
            &nbsp;object that represents an abstract type of surface to present rendered images to.
		</p>
	</li>
	<li>
		<p>
            The surface in our program will be backed by the window that we’ve already opened with GLFW.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VK_KHR_surface</code>
            &nbsp;extension is an instance level extension, and we’ve actually already enabled it, because it’s included in the list returned by 
            <code>glfwGetRequiredInstanceExtensions</code>
            . The list also includes some other WSI extensions that we’ll use in the next couple of chapters.
		</p>
	</li>
	<li>
		<p>
            The window surface needs to be created right 
			<strong>
                after
			</strong>
            &nbsp;the instance creation, because it can actually influence the physical device selection.
		</p>
	</li>
	<li>
		<p>
            It should also be noted that window surfaces are an entirely optional component in Vulkan if you just need off-screen rendering.
		</p>
		<ul>
			<li>
				<p>
                    Vulkan allows you to do that without hacks like creating an invisible window (necessary for OpenGL).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Vulkan also allows you to remotely render from a non-presenting GPU or remotely over the internet, or run compute acceleration for AI without a render or presentation target.
		</p>
	</li>
	<li>
		<p>
            Although the 
            <code>VkSurfaceKHR</code>
            &nbsp;object and its usage is platform-agnostic, its creation isn’t because it depends on window system details. For example, it needs the 
            <code>HWND</code>
            &nbsp;and 
            <code>HMODULE</code>
            &nbsp;handles on Windows. Therefore, there is a platform-specific addition to the extension, which on Windows is called 
            <code>VK_KHR_win32_surface</code>
            &nbsp;and is also automatically included in the list from 
            <code>glfwGetRequiredInstanceExtensions</code>
            .
		</p>
	</li>
	<li>
		<p>
            GLFW actually has 
            <code>glfwCreateWindowSurface</code>
            &nbsp;that handles the platform differences for us.
		</p>
	</li>
</ul>
<h5
	id="blocking-the-thread" >
    Blocking the thread
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://stackoverflow.com/questions/45880238/how-to-draw-while-resizing-glfw-window" 
				class="external-link" 
				target="_blank" >
                Difficulties due to GLFW
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A callback 
            <code>glfw.SetWindowRefreshCallback</code>
            &nbsp;allows the swapchain to be recreated while resizing.
		</p>
		<ul>
			<li>
				<p>
                    See [[#Swapchain Recreation]].
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="physical-device-logical-device" >
    Physical Device / Logical Device
</h3>
<h5
	id="physical-device" >
    Physical Device
</h5>
<ul>
	<li>
		<p>
            <code>VkPhysicalDevice</code>
		</p>
	</li>
	<li>
		<p>
            A GPU. Used to query physical GPU details, like features, capabilities, memory size, etc.
		</p>
	</li>
</ul>
<h5
	id="device-level-extensions" >
    Device Level Extensions
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://vulkan.gpuinfo.org/" 
				class="external-link" 
				target="_blank" >
                Vulkan Hardware Database
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="queue-families" >
    Queue Families
</h5>
<ul>
	<li>
		<p>
            Most operations performed with Vulkan, like draw commands and memory operations, are asynchronously executed by submitting them to a 
            <code>VkQueue</code>
            .
		</p>
	</li>
	<li>
		<p>
            Queues are allocated from queue families, where each queue family supports a specific set of operations in its queues.
		</p>
		<ul>
			<li>
				<p>
                    For example, there could be separate queue families for graphics, compute and memory transfer operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The availability of queue families could also be used as a distinguishing factor in physical device selection.
		</p>
		<ul>
			<li>
				<p>
                    It is possible for a device with Vulkan support to not offer any graphics functionality; however, all graphics cards with Vulkan support today will generally support all queue operations that we’re interested in.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We need to check which queue families are supported by the device and which one of these supports the commands that we want to use.
		</p>
	</li>
</ul>
<h5
	id="presentation-support" >
    Presentation support
</h5>
<ul>
	<li>
		<p>
            Although the Vulkan implementation may support window system integration, that does not mean that every device in the system supports it. Therefore, we need to extend 
            <code>createLogicalDevice</code>
            &nbsp;to ensure that a device can present images to the surface we created.
		</p>
	</li>
	<li>
		<p>
            Since the presentation is a queue-specific feature, the problem is actually about finding a queue family that supports presenting to the surface we created.
		</p>
	</li>
	<li>
		<p>
            It’s actually possible that the queue families supporting 
			<strong>
                drawing
			</strong>
            &nbsp;commands and the queue families supporting 
			<strong>
                presentation
			</strong>
            &nbsp;do 
			<em>
                not
			</em>
            &nbsp;overlap.
		</p>
		<ul>
			<li>
				<p>
                    It’s very likely that these end up being the same queue family after all, but throughout the program we will treat them as if they were separate queues for a uniform approach.
				</p>
			</li>
			<li>
				<p>
                    Nevertheless, you could add logic to explicitly prefer a physical device that supports drawing and presentation in the same queue for 
					<em>
                        improved
					</em>
                    &nbsp;performance.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Therefore, we have to take into account that there could be a distinct presentation queue.
		</p>
	</li>
	<li>
		<p>
            We’ll look for a queue family that has the capability of presenting to our window surface. The function to check for that is 
            <code>vkGetPhysicalDeviceSurfaceSupportKHR</code>
            , which takes the physical device, queue family index and surface as parameters.
		</p>
	</li>
	<li>
		<p>
            It should be noted that the availability of a presentation queue, as we checked in the previous chapter, implies that the Swapchain extension must be supported. However, the extension does have to be 
			<em>
                explicitly
			</em>
            &nbsp;enabled.
		</p>
	</li>
	<li>
		<p>
            Not all graphics cards are capable of presenting images directly to a screen for various reasons, for example, because they are designed for servers and don’t have any display outputs. Secondly, since image presentation is heavily tied into the window system and the surfaces associated with windows, it is not part of the Vulkan core. You have to enable the 
            <code>VK_KHR_swapchain</code>
            &nbsp;device extension after querying for its support.
		</p>
	</li>
</ul>
<h5
	id="surface-capabilities" >
    Surface Capabilities
</h5>
<ul>
	<li>
		<p>
            The extents can change when resizing and you should requery the surface properties. Note that if it says the current extent is 
            <code>{UINT32_MAX, UINT32_MAX}</code>
            &nbsp;(happens on some platforms) then you'll need to ask the windowing system for an appropriate new size (but I don't know GLFW well enough to know if 
            <code>GetFramebufferSize</code>
            &nbsp;is the right function for that purpose)
		</p>
	</li>
</ul>
<h5
	id="logical-device" >
    Logical Device
</h5>
<ul>
	<li>
		<p>
            <code>VkDevice</code>
		</p>
	</li>
	<li>
		<p>
            The “logical” GPU context that you actually execute things on.
		</p>
	</li>
	<li>
		<p>
            Where you describe more specifically which VkPhysicalDeviceFeatures you will be using, like multi viewport rendering and 64-bit floats.
		</p>
	</li>
	<li>
		<p>
            You also need to specify which queue families you would like to use.
		</p>
	</li>
</ul>
<h5
	id="queues" >
    Queues
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/queues.html" 
				class="external-link" 
				target="_blank" >
                Queues
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>VkQueue</code>
		</p>
		<ul>
			<li>
				<p>
                    Execution “port” for commands.
				</p>
			</li>
			<li>
				<p>
                    GPUs will have a set of queues with different properties.
				</p>
				<ul>
					<li>
						<p>
                            Some allow only graphics commands, others only allow memory commands, etc.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Command buffers are executed by submitting them into a queue, which will copy the rendering commands onto the GPU for execution.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The queues are automatically created along with the logical device, but we don’t have a handle to interface with them yet.
		</p>
	</li>
	<li>
		<p>
            Device queues are implicitly cleaned up when the device is destroyed.
		</p>
	</li>
	<li>
		<p>
            We can use the 
            <code>vkGetDeviceQueue</code>
            &nbsp;function to retrieve queue handles for each queue family. The parameters are the logical device, queue family, queue index and a pointer to the variable to store the queue handle in. Because we’re only creating a single queue from this family, we’ll simply use index 
            <code>0</code>
            .
		</p>
	</li>
	<li>
		<p>
            Vulkan Guide:
		</p>
		<ul>
			<li>
				<p>
                    It is common to see engines using 3 queue families:
				</p>
				<ul>
					<li>
						<p>
                            One for drawing the frame, other for async compute, and other for data transfer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In this tutorial, we use a single queue that will run all our commands for simplicity.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="multi-queue" >
    Multi-queue
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250731212143.png" width="425" >
            .
		</p>
	</li>
	<li>
		<p>
            Some hardware only has one queue.
		</p>
	</li>
</ul>
<h2
	id="render-loop" >
    Render Loop
</h2>
<ul>
	<li>
		<p>
            Now that everything is ready for rendering, you first ask the 
            <code>VkSwapchainKHR</code>
            &nbsp;for an image to render to. Then you allocate a 
            <code>VkCommandBuffer</code>
            &nbsp;from a 
            <code>VkCommandBufferPool</code>
            &nbsp;or reuse an already allocated command buffer that has finished execution, and “start” the command buffer, which allows you to write commands into it.
		</p>
	</li>
	<li>
		<p>
            Next, you begin rendering by using Dynamic Rendering.
		</p>
	</li>
	<li>
		<p>
            Then create a loop where you bind a 
            <code>VkPipeline</code>
            , bind some 
            <code>VkDescriptorSet</code>
            &nbsp;resources (for the shader parameters), bind the vertex buffers, and then execute a draw call.
		</p>
	</li>
	<li>
		<p>
            If there is nothing more to render, you end the 
            <code>VkCommandBuffer</code>
            . Finally, you submit the command buffer into the queue for rendering. This will begin execution of the commands in the command buffer on the gpu. If you want to display the result of the rendering, you “present” the image you have rendered to to the screen. Because the execution may not have finished yet, you use a semaphore to make the presentation of the image to the screen wait until rendering is finished.
		</p>
	</li>
	<li>
		<p>
            At a high level, rendering a frame in Vulkan consists of a common set of steps:
		</p>
		<ul>
			<li>
				<p>
                    Wait for the previous frame to finish
				</p>
			</li>
			<li>
				<p>
                    Acquire an image from the Swapchain
				</p>
			</li>
			<li>
				<p>
                    Record a command buffer which draws the scene onto that image
				</p>
				<ul>
					<li>
						<p>
                            Re-recording every frame doesn't really take up performance.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Submit the recorded command buffer
				</p>
				<ul>
					<li>
						<p>
                            Takes performance.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Present the Swapchain image
				</p>
				<ul>
					<li>
						<p>
                            Puts it up on the screen.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="swapchain" >
    Swapchain
</h3>
<ul>
	<li>
		<p>
            Vulkan does not have the concept of a &quot;default framebuffer,&quot; hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen.
		</p>
	</li>
	<li>
		<p>
            This infrastructure is known as the 
			<em>
                swapchain
			</em>
            &nbsp;and must be created explicitly in Vulkan.
		</p>
	</li>
	<li>
		<p>
            The Swapchain is essentially a queue of images that are waiting to be presented to the screen.
		</p>
	</li>
	<li>
		<p>
            Our application will acquire such an image to draw to it, and then return it to the queue.
		</p>
	</li>
	<li>
		<p>
            The conditions for presenting an image from the queue depend on how the Swapchain is set up.
		</p>
	</li>
	<li>
		<p>
            The general purpose of the Swapchain is to synchronize the presentation of images with the refresh rate of the screen.
		</p>
		<ul>
			<li>
				<p>
                    This is important to make sure that only complete images are shown.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Every time we want to draw a frame, we have to ask the Swapchain to provide us with an image to render to. When we’ve finished drawing a frame, the image is returned to the Swapchain for it to be presented to the screen at some point.
		</p>
	</li>
	<li>
		<p>
            &quot;Is a collection of render targets&quot;.
		</p>
		<ul>
			<li>
				<p>
                    Render Targets is not a well-defined term.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The number of render targets and conditions for presenting finished images to the screen depends on the present mode.
		</p>
	</li>
	<li>
		<p>
            <code>VkSwapchainKHR</code>
		</p>
		<ul>
			<li>
				<p>
                    Holds the images for the screen.
				</p>
			</li>
			<li>
				<p>
                    It allows you to render things into a visible window.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>KHR</code>
                    &nbsp;suffix shows that it comes from an extension, which in this case is 
                    <code>VK_KHR_swapchain</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=mvkHYAu7i6c" 
				class="external-link" 
				target="_blank" >
                Swapchains
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Good video.
				</p>
			</li>
			<li>
				<p>
                    Pre-rotate on mobile.
				</p>
			</li>
			<li>
				<p>
                    When to recreate, recreation problems, recreation strategies, maintenance.
				</p>
			</li>
			<li>
				<p>
                    Present modes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There are basically three kinds of properties we need to check:
				</p>
				<ul>
					<li>
						<p>
                            Basic surface capabilities (min/max number of images in Swapchain, min/max width and height of images)
						</p>
					</li>
					<li>
						<p>
                            Surface formats (pixel format, color space)
						</p>
					</li>
					<li>
						<p>
                            Available presentation modes
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It is important that we only try to query for Swapchain support after verifying that the extension is available.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="swapchain-creation" >
    Swapchain Creation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCreateInfoKHR.html" 
				class="external-link" 
				target="_blank" >
                <code>VkSwapchainCreateInfoKHR</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>surface</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with 
                            <code>surface</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>minImageCount</code>
				</p>
				<ul>
					<li>
						<p>
                            we also have to decide how many images we would like to have in the Swapchain. However, simply sticking to the minimum means that we may sometimes have to wait on the driver to complete internal operations before we can acquire another image to render to. Therefore, it is recommended to request at least one more image than the minimum:
						</p>
					</li>
				</ul>
<pre><code class="language-c" data-lang="c"> uint32_t imageCount = surfaceCapabilities.minImageCount + 1;
</code></pre>
				<ul>
					<li>
						<p>
                            We should also make sure to not exceed the maximum number of images while doing this, where 
                            <code>0</code>
                            &nbsp;is a special value that means that there is 
							<strong>
                                no
							</strong>
                            &nbsp;maximum
						</p>
					</li>
				</ul>
<pre><code class="language-c" data-lang="c"> if (surfaceCapabilities.maxImageCount &gt; 0 && imageCount &gt; surfaceCapabilities.maxImageCount) {
&nbsp;&nbsp;&nbsp;&nbsp; imageCount = surfaceCapabilities.maxImageCount;
 }
</code></pre>
			</li>
			<li>
				<p>
                    <code>imageFormat</code>
				</p>
				<ul>
					<li>
						<p>
                            For the color space we’ll use SRGB if it is available, because it 
							<a
								href="http://stackoverflow.com/questions/12524623/" 
								class="external-link" 
								target="_blank" >
                                results in more accurate perceived colors
							</a>
                            . It is also pretty much the standard color space for images, like the textures we’ll use later on.
						</p>
					</li>
					<li>
						<p>
                            Because of that we should also use an SRGB color format, of which one of the most common ones is 
                            <code>VK_FORMAT_B8G8R8A8_SRGB</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageColorSpace</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkColorSpaceKHR.html" 
								class="external-link" 
								target="_blank" >
                                VkColorSpaceKHR
							</a>
                            &nbsp;value specifying the way the swapchain interprets image data.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageExtent</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the size (in pixels) of the swapchain image(s).
						</p>
					</li>
					<li>
						<p>
                            The swap extent is the 
							<em>
                                resolution
							</em>
                            &nbsp;of the Swapchain images. It’s almost always exactly equal to the resolution of the window that we’re drawing to 
							<em>
                                in pixels
							</em>
                            .
						</p>
					</li>
					<li>
						<p>
                            The range of the possible resolutions is defined in the 
                            <code>VkSurfaceCapabilitiesKHR</code>
                            &nbsp;structure.
						</p>
					</li>
					<li>
						<p>
                            On some platforms, it is normal that 
                            <code>maxImageExtent</code>
                            &nbsp;
							<strong>
                                may
							</strong>
                            &nbsp;become 
                            <code>(0, 0)</code>
                            , for example when the window is minimized. In such a case, it is not possible to create a swapchain due to the Valid Usage requirements , unless scaling is selected through 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentScalingCreateInfoKHR.html" 
								class="external-link" 
								target="_blank" >
                                VkSwapchainPresentScalingCreateInfoKHR
							</a>
                            , if supported .
						</p>
					</li>
					<li>
						<p>
                            We’ll pick the resolution that best matches the window within the 
                            <code>minImageExtent</code>
                            &nbsp;and 
                            <code>maxImageExtent</code>
                            &nbsp;bounds. But we must specify the resolution in the correct unit.
						</p>
					</li>
					<li>
						<p>
                            GLFW uses two units when measuring sizes: pixels and 
							<a
								href="https://www.glfw.org/docs/latest/intro_guide.html#coordinate_systems" 
								class="external-link" 
								target="_blank" >
                                screen coordinates
							</a>
                            . For example, the resolution 
                            <code>{WIDTH, HEIGHT}</code>
                            &nbsp;that we specified earlier when creating the window is measured in screen coordinates. But Vulkan works with pixels, so the Swapchain extent must be specified in pixels as well.
						</p>
					</li>
					<li>
						<p>
                            Unfortunately, if you are using a high DPI display (like Apple’s Retina display), screen coordinates don’t correspond to pixels. Instead, due to the higher pixel density, the resolution of the window in pixel will be larger than the resolution in screen coordinates. So if Vulkan doesn’t fix the swap extent for us, we can’t just use the original 
                            <code>{WIDTH, HEIGHT}</code>
                            . Instead, we must use 
                            <code>glfwGetFramebufferSize</code>
                            &nbsp;to query the resolution of the window in pixel before matching it against the minimum and maximum image extent.
						</p>
					</li>
					<li>
						<p>
                            The surface capabilities changes every time the window resizes, and it's only used for creating the Swapchain, so it doesn't make sense to cache.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageUsage</code>
				</p>
			</li>
			<li>
				<p>
                    <code>imageSharingMode</code>
                    &nbsp;(Handling multiple queues):
				</p>
				<ul>
					<li>
						<p>
                            We need to specify how to handle Swapchain images that will be used across multiple queue families. That will be the case in our application if the graphics queue family is different from the presentation queue. We’ll be drawing on the images in the Swapchain from the graphics queue and then submitting them on the presentation queue. There are two ways to handle images that are accessed from multiple queues:
						</p>
						<ul>
							<li>
								<p>
                                    <code>VK_SHARING_MODE_EXCLUSIVE</code>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            An image is owned by one queue family at a time, and ownership must be explicitly transferred before using it in another queue family.
										</p>
									</li>
									<li>
										<p>
                                            This option offers the 
											<strong>
                                                best
											</strong>
                                            &nbsp;performance.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_SHARING_MODE_CONCURRENT</code>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Images can be used across multiple queue families without explicit ownership transfers.
										</p>
									</li>
									<li>
										<p>
                                            Concurrent mode requires you to specify in advance between which queue families ownership will be shared using the 
                                            <code>queueFamilyIndexCount</code>
                                            &nbsp;and 
                                            <code>pQueueFamilyIndices</code>
                                            &nbsp;parameters.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If the queue families differ, then we’ll be using the concurrent mode in this tutorial to avoid having to do the ownership chapters, because these involve some concepts that are better explained at a later time.
						</p>
					</li>
					<li>
						<p>
                            If the graphics queue family and presentation queue family are the same, which will be the case on most hardware, then we should stick to exclusive mode. Concurrent mode requires you to specify at least two distinct queue families.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>queueFamilyIndexCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of queue families having access to the image(s) of the swapchain when 
                            <code>imageSharingMode</code>
                            &nbsp;is 
                            <code>VK_SHARING_MODE_CONCURRENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pQueueFamilyIndices</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of queue family indices having access to the images(s) of the swapchain when 
                            <code>imageSharingMode</code>
                            &nbsp;is 
                            <code>VK_SHARING_MODE_CONCURRENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageArrayLayers</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of views in a multiview/stereo surface. For non-stereoscopic-3D applications, this value is 1.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>presentMode</code>
				</p>
			</li>
			<li>
				<p>
                    <code>preTransform</code>
				</p>
				<ul>
					<li>
						<p>
                            We can specify that a certain transform should be applied to images in the Swapchain if it is supported (
                            <code>supportedTransforms</code>
                            &nbsp;in 
                            <code>capabilities</code>
                            ), like a 90-degree clockwise rotation or horizontal flip. To specify that you do not want any transformation, simply specify the current transformation.
						</p>
					</li>
					<li>
						<p>
                            <code>IDENTITY</code>
						</p>
						<ul>
							<li>
								<p>
                                    This would 
									<strong>
                                        not
									</strong>
                                    &nbsp;be optimal on devices that support rotation and will lead to measurable performance loss.
								</p>
							</li>
							<li>
								<p>
                                    It is strongly recommended that 
                                    <code>surface_properties.currentTransform</code>
                                    &nbsp;be used instead. However, the application is required to handle 
                                    <code>preTransform</code>
                                    &nbsp;elsewhere accordingly.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>compositeAlpha</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies if the alpha channel should be used for blending with other windows in the window system.
						</p>
					</li>
					<li>
						<p>
                            You’ll almost always want to simply ignore the alpha channel, hence 
                            <code>OPAQUE</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>clipped</code>
				</p>
				<ul>
					<li>
						<p>
                            If set to 
                            <code>TRUE</code>
                            , then that means that we don’t care about the color of pixels that are obscured, for example, because another window is in front of them.
						</p>
					</li>
					<li>
						<p>
                            Unless you really need to be able to read these pixels back and get predictable results, you’ll get the best performance by enabling clipping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>oldSwapChain</code>
				</p>
				<ul>
					<li>
						<p>
                            Can be an existing 
							<em>
                                non-retired
							</em>
                            &nbsp;swapchain currently associated with 
                            <code>surface</code>
                            , or 
                            <code>NULL_HANDLE</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If the 
                            <code>oldSwapchain</code>
                            &nbsp;is 
                            <code>NULL_HANDLE</code>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    And if the native window referred to by 
                                    <code>pCreateInfo-&gt;surface</code>
                                    &nbsp;is already associated with a Vulkan swapchain, 
                                    <code>ERROR_NATIVE_WINDOW_IN_USE</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be returned.
								</p>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            If the 
                            <code>oldSwapchain</code>
                            &nbsp;is valid:
						</p>
						<ol>
							<li>
								<p>
                                    This 
									<strong>
                                        may
									</strong>
                                    &nbsp;aid in the resource reuse, and also allows the application to still present any images that are already acquired from it.
								</p>
							</li>
							<li>
								<p>
                                    And the 
                                    <code>oldSwapchain</code>
                                    &nbsp;has exclusive full-screen access, that access is released from 
                                    <code>pCreateInfo-&gt;oldSwapchain</code>
                                    . If the command succeeds in this case, the newly created swapchain will automatically acquire exclusive full-screen access from 
                                    <code>pCreateInfo-&gt;oldSwapchain</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    And there are outstanding calls to 
                                    <code>vkWaitForPresent2KHR</code>
                                    , then 
                                    <code>vkCreateSwapchainKHR</code>
                                    &nbsp;
									<strong>
                                        may
									</strong>
                                    &nbsp;block until those calls complete.
								</p>
							</li>
							<li>
								<p>
                                    Any images from 
                                    <code>oldSwapchain</code>
                                    &nbsp;that are not acquired by the application 
									<strong>
                                        may
									</strong>
                                    &nbsp;be freed by the implementation, upon calling 
                                    <code>vkCreateSwapchainKHR</code>
                                    , which 
									<strong>
                                        may
									</strong>
                                    &nbsp;occur even if creation of the new swapchain fails.
								</p>
							</li>
							<li>
								<p>
                                    The 
                                    <code>oldSwapchain</code>
                                    &nbsp;will be retired upon calling 
                                    <code>vkCreateSwapchainKHR</code>
                                    , even if creation of the new swapchain fails.
								</p>
								<ul>
									<li>
										<p>
                                            After 
                                            <code>oldSwapchain</code>
                                            &nbsp;is retired, the application 
											<strong>
                                                can
											</strong>
                                            &nbsp;pass to 
                                            <code>vkQueuePresentKHR</code>
                                            &nbsp;any images it had already acquired from 
                                            <code>oldSwapchain</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    An application may present an image from the old swapchain before an image from the new swapchain is ready to be presented.
												</p>
											</li>
											<li>
												<p>
                                                    As usual, 
                                                    <code>vkQueuePresentKHR</code>
                                                    &nbsp;
													<strong>
                                                        may
													</strong>
                                                    &nbsp;fail if 
                                                    <code>oldSwapchain</code>
                                                    &nbsp;has entered a state that causes 
                                                    <code>ERROR_OUT_OF_DATE</code>
                                                    &nbsp;to be returned.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The application 
									<strong>
                                        can
									</strong>
                                    &nbsp;continue to use a shared presentable image obtained from 
                                    <code>oldSwapchain</code>
                                    &nbsp;until a presentable image is acquired from the new swapchain, as long as it has not entered a state that causes it to return 
                                    <code>ERROR_OUT_OF_DATE</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The application 
									<strong>
                                        can
									</strong>
                                    &nbsp;destroy 
                                    <code>oldSwapchain</code>
                                    &nbsp;to free all memory associated with 
                                    <code>oldSwapchain</code>
                                    .
								</p>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            Regardless if the 
                            <code>oldSwapchain</code>
                            &nbsp;is valid or not:
						</p>
						<ol>
							<li>
								<p>
                                    The new swapchain is created in the 
									<em>
                                        non-retired
									</em>
                                    &nbsp;state.
								</p>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitmask of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCreateFlagBitsKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkSwapchainCreateFlagBitsKHR</code>
							</a>
                            &nbsp;indicating parameters of the swapchain creation.
						</p>
					</li>
					<li>
						<p>
                            <code>VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    When 
                                    <code>VK_EXT_swapchain_maintenance1</code>
                                    &nbsp;is available, you can optionally amortize the cost of swapchain image allocations over multiple frames.
								</p>
							</li>
							<li>
								<p>
                                    When this is used, image views cannot be created until the first time the image is acquired.
								</p>
								<ul>
									<li>
										<p>
                                            The idea is that normally the images and image views are acquired when a Swapchain recreation happens, but if this flag is enabled it is necessary to acquire them after 
                                            <code>result == VK_SUCCESS || result == VK_SUBOPTIMAL_KHR</code>
                                            &nbsp;as the result of 
                                            <code>vkAcquireNextImageKHR</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="present-modes" >
    Present Modes
</h5>
<ul>
	<li>
		<p>
            Common present modes are double buffering (vsync) and triple buffering.
		</p>
	</li>
	<li>
		<p>
            The presentation mode is arguably the most important setting for the Swapchain, because it represents the actual conditions for showing images to the screen. There are four possible modes available in Vulkan:
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_PRESENT_MODE_IMMEDIATE_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            Images submitted by your application are transferred to the screen right away, which may result in tearing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VK_PRESENT_MODE_FIFO_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            The Swapchain is a queue where the display takes an image from the front of the queue when the display is refreshed, and the program inserts rendered images at the back of the queue. If the queue is full, then the program has to wait. This is most similar to vertical sync as found in modern games. The moment that the display is refreshed is known as &quot;vertical blank&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank. Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VK_PRESENT_MODE_MAILBOX_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones. This mode can be used to render frames as fast as possible while still avoiding tearing, resulting in fewer latency issues than standard vertical sync. This is commonly known as &quot;triple buffering,&quot; although the existence of three buffers alone does not necessarily mean that the framerate is unlocked.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Only the 
            <code>VK_PRESENT_MODE_FIFO_KHR</code>
            &nbsp;mode is guaranteed to be available, so we’ll again have to write a function that looks for the best mode that is available:
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250729081154.png" width="375" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Options
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    I think that 
                    <code>VK_PRESENT_MODE_MAILBOX_KHR</code>
                    &nbsp;is a very nice trade-off if energy usage is not a concern. It allows us to avoid tearing while still maintaining fairly low latency by rendering new images that are as up to date as possible right until the vertical blank.
				</p>
			</li>
			<li>
				<p>
                    On mobile devices, where energy usage is more important, you will probably want to use 
                    <code>VK_PRESENT_MODE_FIFO_KHR</code>
                    &nbsp;instead.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250731211715.png" width="375" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250818181535.png" width="375" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Slide from the Samsung talk on [2025/02/25].
						</p>
					</li>
					<li>
						<p>
                            It recommends FIFO and says that mailbox is not as good as it seems because it induces a lot of stutter.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="drawing-directly-to-the-swapchain-vs-blitting-to-the-swapchain" >
    Drawing directly to the Swapchain vs Blitting to the Swapchain
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://vkguide.dev/docs/new_chapter_2/vulkan_new_rendering/#new-draw-loop" 
				class="external-link" 
				target="_blank" >
                Source
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Drawing directly into the swapchain
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is fine for many projects, and it can even be optimal in some cases such as phones.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Restrictions
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Their resolution is fixed to whatever your window size is.
						</p>
						<ul>
							<li>
								<p>
                                    If you want to have higher or lower resolution, and then do some scaling logic, you need to draw into a different image.
								</p>
							</li>
							<li>
								<p>
                                    Swapchain image size (imageExtent / surface extent) is part of swapchain creation and is tied to the surface. If you want an internal render at a different resolution (supersampling, dynamic resolution, lower-res upscaling), you create an offscreen image/render-target at the desired size and then copy/blit/resolve/tone-map into the swapchain image for presentation. The spec and WSI notes treat imageExtent as the surface-presentable size.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The formats of the image used in the swapchain are not guaranteed.
						</p>
						<ul>
							<li>
								<p>
                                    Different OS, drivers, and windowing modes can have different optimal swapchain formats.
								</p>
							</li>
							<li>
								<p>
                                    The WSI model exposes the surface’s supported formats to the application via 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html" 
										class="external-link" 
										target="_blank" >
                                        <code>vkGetPhysicalDeviceSurfaceFormatsKHR</code>
									</a>
                                    &nbsp;(or equivalent WSI queries); the returned list is implementation- and surface-dependent, so you must choose from what the platform/driver exposes. That means formats available for swapchains vary by OS, driver, and surface.
								</p>
							</li>
							<li>
								<p>
                                    Vulkan explicitly states this via 
                                    <code>VkSurfaceFormatKHR</code>
                                    &nbsp;and 
                                    <code>vkGetPhysicalDeviceSurfaceFormatsKHR</code>
                                    . The specification (Section 30.5 &quot;WSI Swapchain&quot;, Vulkan 1.3.275) and tutorials emphasize that the application must query and choose from available formats supported by the surface/device combination. Android documentation (Vulkan on Android) and Windows (DXGI_FORMAT) similarly highlight platform-specific format requirements and HDR needs (e.g., 
                                    <code>VK_FORMAT_A2B10G10R10_UNORM_PACK32</code>
                                    &nbsp;or 
                                    <code>DXGI_FORMAT_R10G10B10A2_UNORM</code>
                                    &nbsp;for HDR10). This variability makes direct rendering inflexible.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            HDR support needs its own very specific formats.
						</p>
						<ul>
							<li>
								<p>
                                    HDR output requires specific color formats and color-space metadata (examples: 10-bit packed UNORM formats or explicit HDR color-space support such as ST2084/Perceptual Quantizer). WSI and sample repos treat HDR as a distinct case (e.g. A2B10G10 formats and HDR color spaces). Support is platform- and driver-dependent.
								</p>
							</li>
							<li>
								<p>
									<a
										href="https://github.com/KhronosGroup/Vulkan-Samples/issues/638" 
										class="external-link" 
										target="_blank" >
                                        HDR Sample discussion
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Swapchain formats are, for the most part, low precision.
						</p>
						<ul>
							<li>
								<p>
                                    Some platforms with High Dynamic Range rendering have higher precision formats, but you will often default to 8 bits per color.
								</p>
							</li>
							<li>
								<p>
                                    So if you want high precision light calculations, systems that would prevent banding, or to be able to go past 1.0 on the normalized color range, you will need a separate image for drawing.
								</p>
								<ul>
									<li>
										<p>
                                            HDR/high-dynamic-range lighting typically uses floating-point or extended-range render targets (e.g. 
                                            <code>R16G16B16A16_SFLOAT</code>
                                            &nbsp;or higher) for intermediate lighting accumulation; final tonemapping reduces values into the presentable format. Because presentable swapchain images are often limited (8-bit), the offscreen high-precision image plus a conversion/tonemap pass is the usual pattern.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Many surfaces expose 8-bit UNORM or sRGB formats (e.g. 
                                    <code>B8G8R8A8_UNORM</code>
                                    /
                                    <code>SRGB</code>
                                    ) as commonly returned swapchain formats. Higher-precision formats (16-bit float per channel or 10-bit packed) exist and are used for HDR/high-precision pipelines, but they are not guaranteed by every surface/driver. Therefore applications that need high-precision lighting/accumulation commonly render into a 16-bit-float render target and tonemap/convert for presentation.
								</p>
							</li>
							<li>
								<p>
                                    Banding artifacts in gradients or low-light scenes are a well-known consequence of limited precision. High-precision rendering (HDR, complex lighting, deferred shading G-Buffers) requires formats like 
                                    <code>VK_FORMAT_R16G16B16A16_SFLOAT</code>
                                    &nbsp;(RGBA16F) to store values outside the [0.0, 1.0] range and prevent banding. While 
									<em>
                                        some
									</em>
                                    &nbsp;swapchains 
									<em>
                                        can
									</em>
                                    &nbsp;support HDR formats (e.g., 10:10:10:2), they are less universally available and not the default. Using RGBA16F directly in a swapchain is often unsupported or inefficient for presentation.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Drawing to a different image and copying/blitting to the swapchain image
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Advantages
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Decouples tonemapping from presentation timing
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Tonemap into an intermediate LDR image that you control. You can finish the tonemap pass earlier and defer the actual transfer/present of the swapchain image to a later point, reducing risk of stalling the present path or blocking on swapchain ownership.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Avoids writing directly to the swapchain
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Writing directly into the swapchain can introduce stalls (wait-for-acquire or present-time synchronization). Using an intermediate LDR image lets you do the heavy work off-swapchain and only do a cheap transfer/present step when convenient.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Enables batching / chaining of postprocesses without touching the swapchain
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    If you need further LDR processing (dithering, temporal AA, UI composite, overlays, readback for screenshots, or additional filters), do those against the intermediate image. This allows composing multiple passes without repeatedly transitioning the swapchain.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Easier support for multiple outputs or different sizes/formats
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You can tonemap once to an LDR image and then blit/copy to different-size or different-format targets (screenshots, streaming encoder, secondary displays) without re-running tonemap.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Allows use of transient/optimized memory for the intermediate
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    The intermediate image can be created as transient (e.g., 
                                    <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>
                                    &nbsp;or tiled transient attachment) to reduce memory pressure and bandwidth compared with always keeping a full persistent LDR buffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Better control over final conversion semantics
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    In shader you control quantization, gamma conversion, ordered/temporal dithering, and color-space tagging. After producing the controlled LDR image you can choose the transfer method (exact copy vs scaled blit) that matches target capabilities, improving visual consistency across vendors.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Improved cross-queue / async workflows
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You can produce the LDR image on a graphics/compute queue and then perform a transfer on a transfer-only queue (or use a dedicated present queue) with explicit ownership transfers, possibly improving throughput if hardware supports it.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Facilitates deterministic screenshots / capture
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Saving an intermediate LDR image for file export is safer (format/bit-depth known) than capturing the swapchain which may have platform-specific transforms applied.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Trade-offs
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Extra GPU memory usage
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You need memory for the intermediate LDR image (unless you use transient attachments), which increases resident memory footprint.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Extra GPU bandwidth and a copy step
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Creating an LDR image then copying/blitting to the swapchain costs memory bandwidth and GPU cycles. This can increase frame time if the transfer is on the critical path.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                More layout transitions and synchronization complexity
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You must manage transitions and possibly ownership transfers (if different queues are used). Incorrect synchronization can cause stalls or correctness bugs.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Potential increased latency if done poorly
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    If the copy/blit is done synchronously right before present, it can add latency compared with rendering directly to the swapchain; the intended decoupling only helps if scheduling is arranged to avoid the critical path.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Implementation complexity
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    Managing an extra render target, transient allocation, and copy logic is more code than rendering directly to the swapchain.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="swapchain-recreation" >
    Swapchain Recreation
</h3>
<h5
	id="when-to-recreate" >
    When to recreate
</h5>
<ul>
	<li>
		<p>
            If the window surface changed such that the Swapchain is no longer compatible with it.
		</p>
	</li>
	<li>
		<p>
            If the window resizes.
		</p>
	</li>
	<li>
		<p>
            If the window minimizes.
		</p>
		<ul>
			<li>
				<p>
                    This case is special because it will result in a framebuffer size of 
                    <code>0</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    We can handle by waiting for the framebuffer size to be back to something greater than 
                    <code>0</code>
                    , indicating that the window is no longer minimized.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If the swapchain image format changed during an application's lifetime, for example, when moving a window from a standard range to a high dynamic range monitor.
		</p>
	</li>
</ul>
<h5
	id="finding-out-that-a-recreation-is-needed" >
    Finding out that a recreation is needed
</h5>
<ul>
	<li>
		<p>
            The 
            <code>vkAcquireNextImageKHR</code>
            &nbsp;and 
            <code>vkQueuePresentKHR</code>
            &nbsp;functions can return the following special values to indicate this.
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_ERROR_OUT_OF_DATE_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            The Swapchain has become incompatible with the surface and can no longer be used for rendering. Usually happens after a window resize.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VK_SUBOPTIMAL_KHR</code>
				</p>
				<ul>
					<li>
						<p>
                            The Swapchain can still be used to successfully present to the surface, but the surface properties are no longer matched exactly.
						</p>
					</li>
					<li>
						<p>
                            You should 
							<strong>
                                ALWAYS
							</strong>
                            &nbsp;recreate the swapchain if the result is suboptimal.
						</p>
					</li>
					<li>
						<p>
                            This result means that it's a &quot;success&quot; but there will be performance penalties.
						</p>
					</li>
					<li>
						<p>
                            Both 
                            <code>VK_SUCCESS</code>
                            &nbsp;and 
                            <code>VK_SUBOPTIMAL_KHR</code>
                            &nbsp;are considered &quot;success&quot; return codes.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If the Swapchain turns out to be out of date when attempting to acquire an image, then it is no longer possible to present to it. Therefore, we should immediately recreate the Swapchain and try again in the next 
            <code>drawFrame</code>
            &nbsp;call.
		</p>
	</li>
	<li>
		<p>
            You could also decide to do that if the Swapchain is suboptimal, but I’ve chosen to proceed anyway in that case because we’ve already acquired an image.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">result = presentQueue.presentKHR( presentInfoKHR );
if (result == vk::Result::eErrorOutOfDateKHR || result == vk::Result::eSuboptimalKHR) {
&nbsp;&nbsp;&nbsp;&nbsp;framebufferResized = false;
&nbsp;&nbsp;&nbsp;&nbsp;recreateSwapChain();
} else if (result != vk::Result::eSuccess) {
&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("failed to present Swapchain image!");
}

currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
</code></pre>
<ul>
	<li>
		<p>
            The 
            <code>vkQueuePresentKHR</code>
            &nbsp;function returns the same values with the same meaning. In this case, we will also recreate the Swapchain if it is suboptimal, because we want the best possible result.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Finding out explicitly
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Although many drivers and platforms trigger 
                    <code>VK_ERROR_OUT_OF_DATE_KHR</code>
                    &nbsp;automatically after a window resize, it is not guaranteed to happen.
				</p>
			</li>
			<li>
				<p>
                    That’s why we’ll add some 
					<em>
                        extra
					</em>
                    &nbsp;code to also handle resizes explicitly:
				</p>
<pre><code class="language-c" data-lang="c"> glfw.SetWindowUserPointer(vulkan_context.glfw_window, vulkan_context)
 glfw.SetFramebufferSizeCallback(vulkan_context.glfw_window, proc "c" (window: glfw.WindowHandle, _, _: i32) {s
&nbsp;&nbsp;&nbsp;&nbsp; vulkan_context := cast(^Vulkan_Context)glfw.GetWindowUserPointer(window)
&nbsp;&nbsp;&nbsp;&nbsp; vulkan_context.glfw_framebuffer_resized = true
 })
</code></pre>
			</li>
			<li>
				<p>
                    &quot;Usually it's not the best idea to depend on this&quot;.
				</p>
				<ul>
					<li>
						<p>
                            Problems with multithreading.
						</p>
					</li>
					<li>
						<p>
                            You depend on the windowing system to notify changes correctly; this can be really tricky on mobile.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="recreating" >
    Recreating
</h5>
<pre><code class="language-c" data-lang="c">void recreateSwapChain() {
&nbsp;&nbsp;&nbsp;&nbsp;device.waitIdle();

&nbsp;&nbsp;&nbsp;&nbsp;cleanupSwapChain();

&nbsp;&nbsp;&nbsp;&nbsp;createSwapChain();
&nbsp;&nbsp;&nbsp;&nbsp;createImageViews();
}
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Synchronization
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    ~Flush and Recreate:
				</p>
				<ul>
					<li>
						<p>
                            &quot;We first call 
                            <code>vkDeviceWaitIdle</code>
                            , because just like in the last chapter, we shouldn’t touch resources that may still be in use.&quot;
						</p>
						<ul>
							<li>
								<p>
                                    This is not enough.
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250818175059.png" width="525" >
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The whole app has to stop and wait for synchronization.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250818180311.png" width="425" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250818180351.png" width="475" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Recreate and check:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250818180214.png" width="375" >
                            .
						</p>
					</li>
					<li>
						<p>
                            You do 
							<strong>
                                not
							</strong>
                            &nbsp;need to stop your rendering at any given point.
						</p>
					</li>
					<li>
						<p>
                            The reason why you are allowed to pass the old swapchain when recreating the new swapchain, is due to this strategy.
						</p>
					</li>
					<li>
						<p>
                            This is the recommendation.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/swapchain_recreation#swapchain-recreation-1" 
								class="external-link" 
								target="_blank" >
                                Strategy
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    This issue is resolved by deferring the destruction of the old swapchain and its remaining present semaphores to the time when the semaphore corresponding to the first present of the new swapchain can be destroyed. Because once the first present semaphore of the new swapchain can be destroyed, the first present operation of the new swapchain is done, which means the old swapchain is no longer being presented.
								</p>
							</li>
							<li>
								<p>
                                    The destruction of both old swapchains must now be deferred to when the first QP of the new swapchain has been processed. If an application resizes the window constantly and at a high rate, we would keep accumulating old swapchains and not free them until it stops.
								</p>
								<ul>
									<li>
										<p>
                                            This potentially accumulates a lot of memory, I think.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    So what's the correct moment then? Only after the new swapchain has completed one full cycle of presentations, that is, when I acquire image index 
                                    <code>0</code>
                                    &nbsp;for the 
									<em>
                                        second
									</em>
                                    &nbsp;time.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Analysis
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    [2025/08/19]
								</p>
							</li>
							<li>
								<p>
                                    Holy, now I understand the problem.
								</p>
							</li>
							<li>
								<p>
                                    I cannot delete anything from the old swapchain until I am sure that everything from the previous one has been presented. I thought that by acquiring the first image of the new swapchain, that would already indicate that it was safe to delete the old swapchain, but that's not true; by doing that, I only guarantee that 1 (ONE) image from the old swapchain has been presented, but the old swapchain may have several images in the queue.
								</p>
							</li>
							<li>
								<p>
                                    However, as made clear, that is not the case.
								</p>
							</li>
							<li>
								<p>
                                    Dealing with this can be a nightmare. Potentially having to handle multiple old swapchains at the same time in case of very frequent resizes (smooth swapchain).
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_swapchain_maintenance1.html" 
						class="external-link" 
						target="_blank" >
                        <code>VK_EXT_swapchain_maintenance1</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            &quot;You should always use this extension if available&quot;.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Support
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Introduced in 2023.
								</p>
							</li>
							<li>
								<p>
                                    [2025/02/25]
								</p>
								<ul>
									<li>
										<p>
                                            Only 25% of Android devices and 20% of desktop GPUs use it.
										</p>
									</li>
									<li>
										<p>
                                            It was added on Android 14.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Adds a collection of window system integration features that were intentionally left out or overlooked in the original 
                            <code>VK_KHR_swapchain</code>
                            &nbsp;extension.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Features
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Allow applications to release previously acquired images without presenting them.
								</p>
							</li>
							<li>
								<p>
                                    Allow applications to defer swapchain memory allocation for improved startup time and memory footprint.
								</p>
							</li>
							<li>
								<p>
                                    Specify a fence that will be signaled when the resources associated with a present operation 
									<strong>
                                        can
									</strong>
                                    &nbsp;be safely destroyed.
								</p>
							</li>
							<li>
								<p>
                                    Allow changing the present mode a swapchain is using at per-present granularity.
								</p>
							</li>
							<li>
								<p>
                                    Allow applications to define the behavior when presenting a swapchain image to a surface with different dimensions than the image.
								</p>
								<ul>
									<li>
										<p>
                                            Using this feature 
											<strong>
                                                may
											</strong>
                                            &nbsp;allow implementations to avoid returning 
                                            <code>VK_ERROR_OUT_OF_DATE_KHR</code>
                                            &nbsp;in this situation.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    This extension makes 
                                    <code>vkQueuePresentKHR</code>
                                    &nbsp;more similar to 
                                    <code>vkQueueSubmit</code>
                                    , allowing it to specify a fence that the application can wait on.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                The problem with 
                                <code>vkDeviceWaitIdle</code>
                                &nbsp;or 
                                <code>vkQueueWaitIdle</code>
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Typically, applications call these functions and assume it’s safe to delete swapchain semaphores and the swapchain itself.
								</p>
							</li>
							<li>
								<p>
                                    The problem is that 
                                    <code>WaitIdle</code>
                                    &nbsp;functions are defined in terms of fences - they only wait for workloads submitted through functions that accept a fence.
								</p>
							</li>
							<li>
								<p>
                                    Unextended 
                                    <code>vkQueuePresent</code>
                                    &nbsp;does not provide a fence parameter.
								</p>
							</li>
							<li>
								<p>
                                    The 
                                    <code>vkDeviceWaitIdle</code>
                                    &nbsp;can’t guarantee that it’s safe to delete swapchain resources.
								</p>
								<ul>
									<li>
										<p>
                                            The validation layers don't trigger errors in this case, but it's just because so many people use it and there's no good alternative.
										</p>
									</li>
									<li>
										<p>
                                            When 
                                            <code>VK_EXT_swapchain_maintenance1</code>
                                            &nbsp;is enabled the validation layer will report an error if the application shutdown sequence relies on 
                                            <code>vkDeviceWaitIdle</code>
                                            &nbsp;or 
                                            <code>vkQueueWaitIdle</code>
                                            &nbsp;to release swapchain resources instead of using a presentation fence.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The extension fixes this problem.
								</p>
							</li>
							<li>
								<p>
                                    By waiting on the presentation fence, the application can safely release swapchain resources.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    To avoid a deadlock, only reset the fence if we are submitting work:
				</p>
				<ul>
					<li>
						<p>
                            If reset is made right after wait for the fence, but the window was resized, then it will happen a deadlock.
						</p>
					</li>
					<li>
						<p>
                            The fence is opened by the signaling of 
                            <code>QueueSubmit</code>
                            , and closed by the 
                            <code>ResetFences</code>
                            .
						</p>
					</li>
				</ul>
<pre><code class="language-cpp" data-lang="cpp"> vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
 
 uint32_t imageIndex;
 VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);
 
 if (result == VK_ERROR_OUT_OF_DATE_KHR) {
&nbsp;&nbsp;&nbsp;&nbsp; recreateSwapChain();
&nbsp;&nbsp;&nbsp;&nbsp; return;
 } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
&nbsp;&nbsp;&nbsp;&nbsp; throw std::runtime_error("failed to acquire Swapchain image!");
 }
 
 // Only reset the fence if we are submitting work
 vkResetFences(device, 1, &inFlightFences[currentFrame]);
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                What to recreate
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The image views need to be recreated because they are based directly on the Swapchain images.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Smooth Swapchain Resizing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Don't bother with smooth swapchain resizing, it's not worth it&quot;.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        My experience
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            [2025/08/04]
						</p>
					</li>
					<li>
						<p>
                            A callback 
                            <code>glfw.SetWindowRefreshCallback</code>
                            &nbsp;allows the swapchain to be recreated while resizing.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Synchronization
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Since the swapchain is recreated all the time, it becomes difficult to manage when the old swapchain should be destroyed along with its resources.
								</p>
							</li>
							<li>
								<p>
                                    <s>At the moment I'm handling the old_swapchain in a &quot;bad&quot; way, and I feel that recreating it every resize frame only worsens synchronization</s>.
								</p>
								<ul>
									<li>
										<p>
                                            It is not necessary to deal with the old_swapchain when using 
                                            <code>vkDeviceWaitIdle()</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            My current implementation:
						</p>
<pre><code class="language-odin" data-lang="odin"> eng.window_init(1280, 720, "Expedicao Hover", proc "c" (window: glfw.WindowHandle) {
&nbsp;&nbsp;&nbsp;&nbsp; context = eng.global_context
&nbsp;&nbsp;&nbsp;&nbsp; // fmt.printfln("REFRESHED")
&nbsp;&nbsp;&nbsp;&nbsp; eng.swapchain_resize()
&nbsp;&nbsp;&nbsp;&nbsp; game_draw(&game, game.cycle_draw.dt_cycles_s)
 })
</code></pre>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="updating-resources-after-recreating" >
    Updating resources after recreating
</h5>
<ul>
	<li>
		<p>
            Destroy every image and view created from the old swapchain (the swapchain destroys its own images).
		</p>
	</li>
	<li>
		<p>
            Update everything that holds a reference to either of those.
		</p>
		<ul>
			<li>
				<p>
                    If anything was created using the swapchain's size you also have to destroy and recreate those and update anything that references them.
				</p>
			</li>
			<li>
				<p>
                    There's no getting around it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="frames-in-flight" >
    Frames In-Flight
</h3>
<h5
	id="motivation" >
    Motivation
</h5>
<ul>
	<li>
		<p>
            The render loop has one glaring flaw: unnecessary 
			<strong>
                idling
			</strong>
            &nbsp;of the host. We are required to wait on the previous frame to finish before we can start rendering the next.
		</p>
	</li>
	<li>
		<p>
            To fix this we allow multiple frames to be in-flight at once, allowing the rendering of one frame to not interfere with the recording of the next.
		</p>
	</li>
	<li>
		<p>
            This control over the number of frames in flight is another example of Vulkan being explicit.
		</p>
	</li>
</ul>
<h5
	id="frame" >
    Frame
</h5>
<ul>
	<li>
		<p>
            There is no concept of a frame in Vulkan. This means that the way you render is entirely up to you. The only thing that matters is when you have to display the frame to the screen, which is done through a swapchain. But there is no fundamental difference between rendering and then sending the images over the network, or saving the images into a file, or displaying it on the screen through the swapchain.
		</p>
	</li>
	<li>
		<p>
            This means it is possible to use Vulkan in an entirely headless mode, where nothing is displayed to the screen. You can render the images and then store them on disk (very useful for testing) or use Vulkan as a way to perform GPU calculations such as a raytracer or other compute tasks.
		</p>
	</li>
</ul>
<h5
	id="how-many-frames-in-flight" >
    How many Frames In-Flight
</h5>
<ul>
	<li>
		<p>
            We choose the number 2 because we don’t want the CPU to get 
			<em>
                too
			</em>
            &nbsp;far ahead of the GPU.
		</p>
		<ul>
			<li>
				<p>
                    With two frames in flight, the CPU and the GPU can be working on their own tasks at the same time. If the CPU finishes early, it will wait till the GPU finishes rendering before submitting more work.
				</p>
			</li>
			<li>
				<p>
                    With three or more frames in flight, the CPU could get ahead of the GPU, adding frames of latency. Generally, extra latency isn’t desired.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="one-per-frame-in-flight" >
    One Per Frame In-Flight
</h5>
<ul>
	<li>
		<p>
			<strong>
                Duplicate
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Resources
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Uniform Buffers.
						</p>
						<ul>
							<li>
								<p>
                                    If modified while a previous frame uses it, corruption occurs.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Dynamic Storage Buffers.
						</p>
						<ul>
							<li>
								<p>
                                    GPU-computed results (e.g., particle positions). Writing to a buffer while an older frame reads it causes hazards.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Color/Depth Attachments.
						</p>
					</li>
					<li>
						<p>
                            Staging Buffers
						</p>
						<ul>
							<li>
								<p>
                                    If updated per frame (e.g., 
                                    <code>vkMapMemory</code>
                                    ), duplication avoids overwriting mid-transfer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Compute Shader Output Buffers:
						</p>
						<ul>
							<li>
								<p>
                                    If frame 
                                    <code>N</code>
                                    &nbsp;writes, and frame 
                                    <code>N+1</code>
                                    &nbsp;reads, duplicate to prevent read-before-write.
								</p>
							</li>
							<li>
								<p>
                                    Use ping-pong buffers (count = frames in-flight).
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Command pool.
				</p>
				<ul>
					<li>
						<p>
                            I have doubts about this; some people do it differently.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Command buffer.
				</p>
			</li>
			<li>
				<p>
                    'present_finished_semaphore'.
				</p>
			</li>
			<li>
				<p>
                    'render_finished_fence'.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Don't duplicate
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Resources
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Static Vertex/Index Buffers:
						</p>
						<ul>
							<li>
								<p>
                                    Initialized once, read-only. No per-frame updates.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Immutable Textures
						</p>
						<ul>
							<li>
								<p>
                                    Loaded once (e.g., via 
                                    <code>VkDeviceMemory</code>
                                    ).
								</p>
							</li>
							<li>
								<p>
                                    Not mapped for change.
								</p>
							</li>
							<li>
								<p>
                                    It's device local.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Static BRDF LUTs.
				</p>
				<ul>
					<li>
						<p>
                            Initialized once, read by all frames.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="advancing-a-frame" >
    Advancing a frame
</h5>
<pre><code class="language-c" data-lang="c">void drawFrame() {
&nbsp;&nbsp;&nbsp;&nbsp;...

&nbsp;&nbsp;&nbsp;&nbsp;currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}
</code></pre>
<ul>
	<li>
		<p>
            By using the modulo (
            <code>%</code>
            ) operator, we ensure that the frame index loops around after every 
            <code>MAX_FRAMES_IN_FLIGHT</code>
            &nbsp;enqueued frames.
		</p>
	</li>
</ul>
<h3
	id="acquire-next-image" >
    Acquire Next Image
</h3>
<ul>
	<li>
		<p>
            <code>vkWaitForFences()</code>
		</p>
		<ul>
			<li>
				<p>
                    Waits on the previous frame.
				</p>
			</li>
			<li>
				<p>
                    Takes an array of fences and waits on the host for either any or all of the fences to be signaled before returning.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>VK_TRUE</code>
                    &nbsp;we pass here indicates that we want to wait for all fences, but in the case of a single one it doesn’t matter.
				</p>
			</li>
			<li>
				<p>
                    This function also has a timeout parameter that we set to the maximum value of a 64 bit unsigned integer, 
                    <code>UINT64_MAX</code>
                    , which effectively disables the timeout.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkAcquireNextImageKHR()</code>
		</p>
		<ul>
			<li>
				<p>
                    Acquire the index of an available image from the swapchain for 
					<strong>
                        rendering
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    If an image was acquired, then it means that this image is 
					<strong>
                        idle
					</strong>
                    &nbsp;(i.e., 
					<strong>
                        not
					</strong>
                    &nbsp;currently being displayed or written to).
				</p>
			</li>
			<li>
				<p>
                    If no image is ready, the call blocks (or returns an error if non-blocking).
				</p>
			</li>
			<li>
				<p>
                    The returned image index is now &quot;
					<em>
                        owned
					</em>
                    &quot; by your app for rendering.
				</p>
			</li>
			<li>
				<p>
                    We only get a swapchain image index from the windowing present system.
				</p>
			</li>
			<li>
				<p>
                    A semaphore/fence is signaled when the image is safe to use.
				</p>
			</li>
			<li>
				<p>
                    <code>timeout</code>
				</p>
				<ul>
					<li>
						<p>
                            If the swapchain doesn’t have any image we can use, it will block the thread with a maximum for the timeout set.
						</p>
					</li>
					<li>
						<p>
                            The measurement unit is nanoseconds.
						</p>
					</li>
					<li>
						<p>
                            1 second is fine: 
                            <code>1_000_000_000</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>semaphore</code>
				</p>
				<ul>
					<li>
						<p>
                            Semaphore to signal.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>fence</code>
				</p>
				<ul>
					<li>
						<p>
                            Fence to signal.
						</p>
					</li>
					<li>
						<p>
                            It is possible to specify a semaphore, fence or both.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pImageIndex</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a variable to output the index of the Swapchain image that has 
							<em>
                                become available
							</em>
                            &nbsp;to use.
						</p>
					</li>
					<li>
						<p>
                            The index refers to the 
                            <code>VkImage</code>
                            &nbsp;in the 
                            <code>swapChainImages</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="image-layout-transitions" >
    Image Layout Transitions
</h5>
<ul>
	<li>
		<p>
            See 
            <a href="Vulkan.html#Images">
            Vulkan#Images
            </a>
            .
		</p>
	</li>
	<li>
		<p>
            Before we can start rendering to an image, we need to transition its layout to one that is suitable for rendering.
		</p>
	</li>
	<li>
		<p>
            Before rendering, we transition the image layout to 
            <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// Before starting rendering, transition the swapchain image to COLOR_ATTACHMENT_OPTIMAL
transition_image_layout(
&nbsp;&nbsp;&nbsp;&nbsp;imageIndex,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::eUndefined,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::eColorAttachmentOptimal,
&nbsp;&nbsp;&nbsp;&nbsp;{},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // srcAccessMask (no need to wait for previous operations)
&nbsp;&nbsp;&nbsp;&nbsp;vk::AccessFlagBits2::eColorAttachmentWrite,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstAccessMask
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eTopOfPipe,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // srcStage
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eColorAttachmentOutput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstStage
);
</code></pre>
<ul>
	<li>
		<p>
            After rendering, we need to transition the image layout back to 
            <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>
            &nbsp;so it can be presented to the screen:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">// After rendering, transition the swapchain image to PRESENT_SRC
transition_image_layout(
&nbsp;&nbsp;&nbsp;&nbsp;imageIndex,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::eColorAttachmentOptimal,
&nbsp;&nbsp;&nbsp;&nbsp;vk::ImageLayout::ePresentSrcKHR,
&nbsp;&nbsp;&nbsp;&nbsp;vk::AccessFlagBits2::eColorAttachmentWrite,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // srcAccessMask
&nbsp;&nbsp;&nbsp;&nbsp;{},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstAccessMask
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eColorAttachmentOutput,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// srcStage
&nbsp;&nbsp;&nbsp;&nbsp;vk::PipelineStageFlagBits2::eBottomOfPipe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dstStage
);
</code></pre>
<h3
	id="render-targets" >
    Render Targets
</h3>
<h5
	id="attachments" >
    Attachments
</h5>
<ul>
	<li>
		<p>
            Nvidia: Use 
            <code>storeOp = DONT_CARE</code>
            &nbsp;rather than 
            <code>UNDEFINED</code>
            &nbsp;layouts to skip unneeded render target writes.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Don't transition color attachments from &quot;safe&quot; to &quot;unsafe&quot; unless required by the algorithm.
		</p>
	</li>
</ul>
<h5
	id="transient-resources" >
    Transient Resources
</h5>
<ul>
	<li>
		<p>
            Transient attachments (or Transient Resources) are render targets (like color/depth buffers) designed to exist only temporarily during a render pass, with their contents discarded afterward. They're optimized for fast on-chip memory access and avoid unnecessary memory operations.
		</p>
	</li>
</ul>
<h5
	id="render-target" >
    Render Target
</h5>
<ul>
	<li>
		<p>
            A Render Target is not a term in Vulkan but it's a term in graphics programming.
		</p>
	</li>
	<li>
		<p>
            It's a term for an image you render into. In Vulkan this is an 
            <code>VkImage</code>
            &nbsp;+ 
            <code>VkImageView</code>
            &nbsp;used as a color/depth attachment in a render pass or as a color attachment in dynamic rendering.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <a href="Vulkan.html#Drawing to a High Precision Image (`R16G16B16A16_SFLOAT`)">
                    Vulkan#Drawing to a High Precision Image (
                    <code>R16G16B16A16_SFLOAT</code>
                    )
                    </a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            It's a Render Target technique to draw into a high-precision image and then copy the result to an SDR image for the swapchain.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Drawing a UI
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The UI texture must preserve alpha in the areas you want to be transparent, for later compositing.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<strong>
                        Draw UI directly to the final render target (swapchain image, or image to blit to the swapchain image)
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            After tonemap, enable blending and draw UI.
						</p>
					</li>
					<li>
						<p>
                            Oni:
						</p>
						<ul>
							<li>
								<p>
                                    For the scene, I render into an RGBA16 image, then I draw 
									<em>
                                        on the swapchain
									</em>
                                    &nbsp;with a tonemapper, then I draw the UI 
									<em>
                                        on the swapchain
									</em>
                                    &nbsp;with blending enabled.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Composite in a shader
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Sample scene image and UI image, compute 
                            <code>out = scene * (1 - alpha_ui) + ui * alpha_ui</code>
                            &nbsp;(or use premultiplied alpha: 
                            <code>out = scene + ui</code>
                            ).
						</p>
						<ul>
							<li>
								<p>
                                    Both ways work; premultiplied alpha avoids some edge artifacts if UI already uses premultiplied data.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<strong>
                Compositing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used to combine render targets, or any other images.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
					<em>
                        Fragment shader
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Render to an image and draw a full-screen triangle/quad that samples the HDR image and outputs LDR color.
						</p>
						<ul>
							<li>
								<p>
                                    Could be the swapchain image if supported, or an intermediate image then blit/copy to swapchain.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Pros
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Simple and guaranteed compatible with swapchain color attachment usage.
								</p>
							</li>
							<li>
								<p>
                                    Useful if you want to draw the UI while making this final composition.
								</p>
								<ul>
									<li>
										<p>
                                            Seems like I'm mixing responsibilities, even though I'm reducing one render pass.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Cons
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Less flexible for arbitrary per-pixel work that requires many conditionals or random write patterns.
								</p>
							</li>
							<li>
								<p>
                                    Need to issue a draw call and set up graphics pipeline.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Compute shader
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Sample HDR image(s), write the LDR pixels to an output image.
						</p>
						<ul>
							<li>
								<p>
                                    Could be the swapchain image if supported, or an intermediate image then blit/copy to swapchain.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Pros
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Flexible: can read multiple inputs and write arbitrary outputs (random writes, multiple passes) without needing geometry.
								</p>
							</li>
							<li>
								<p>
                                    Easy to implement multi-image compositing in one dispatch (read N sampled images + write to storage image).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Cons
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    On some GPUs a simple full-screen fragment pass can be faster due to fixed-function hardware for rasterization and blending.
								</p>
							</li>
						</ul>
					</li>
				</ul>
<pre><code class="language-glsl" data-lang="glsl">#version 450
</code></pre>
			</li>
		</ol>
	</li>
	<li>
<pre><code class="language-" data-lang="">&nbsp;&nbsp;layout(local_size_x = 16, local_size_y = 16) in;
</code></pre>
	</li>
	<li>
<pre><code class="language-" data-lang="">&nbsp;&nbsp;layout(set=0, binding=0) uniform sampler2D gameTex;
&nbsp;&nbsp;layout(set=0, binding=1) uniform sampler2D uiTex;
&nbsp;&nbsp;layout(set=0, binding=2, rgba8) uniform writeonly image2D swapchainImg;
&nbsp;&nbsp;
&nbsp;&nbsp;void main() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 uv = vec2(coord) / textureSize(gameTex, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sample inputs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 game = texture(gameTex, uv).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 ui = texture(uiTex, uv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Tonemap game (example: Reinhard)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game = game / (game + vec3(1.0));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Composite: UI over game
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 final = mix(game, ui.rgb, ui.a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write to swapchain
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(swapchainImg, coord, vec4(final, 1.0));
&nbsp;&nbsp;}
&nbsp;&nbsp;```
&nbsp;&nbsp;```glsl
&nbsp;&nbsp;#version 450
&nbsp;&nbsp;
&nbsp;&nbsp;layout(local_size_x = 16, local_size_y = 16) in;
&nbsp;&nbsp;
&nbsp;&nbsp;layout(binding = 0) uniform sampler2D uSceneHDR;
&nbsp;&nbsp;layout(binding = 1) uniform sampler2D uUI; // optional
&nbsp;&nbsp;layout(binding = 2, rgba8) writeonly uniform image2D outImage; // target LDR image (could be swapchain-compatible image)
&nbsp;&nbsp;
&nbsp;&nbsp;vec3 reinhardTonemap(vec3 c) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return c / (1.0 + c);
&nbsp;&nbsp;}
&nbsp;&nbsp;
&nbsp;&nbsp;vec3 toSRGB(vec3 linear) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pow(linear, vec3(1.0/2.2));
&nbsp;&nbsp;}
&nbsp;&nbsp;
&nbsp;&nbsp;void main() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 size = imageSize(outImage);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pix.x &gt;= size.x || pix.y &gt;= size.y) return;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2 uv = (vec2(pix) + 0.5) / vec2(size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 hdr = texture(uSceneHDR, uv).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float exposure = 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 mapped = reinhardTonemap(hdr * exposure);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapped = toSRGB(mapped);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Optionally composite UI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// vec4 ui = texture(uUI, uv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// vec3 outc = mix(mapped, ui.rgb, ui.a);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(outImage, pix, vec4(mapped, 1.0));
&nbsp;&nbsp;}
&nbsp;&nbsp;```
&nbsp;&nbsp;```c
&nbsp;&nbsp;// Dispatch
&nbsp;&nbsp;vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, computePipe);
&nbsp;&nbsp;vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, ...);
&nbsp;&nbsp;vkCmdDispatch(cmd, swapchain_width/16, swapchain_height/16, 1);
&nbsp;&nbsp;```
</code></pre>
	</li>
</ul>
<h3
	id="dynamic-rendering" >
    Dynamic Rendering
</h3>
<ul>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_KHR_dynamic_rendering" 
						class="external-link" 
						target="_blank" >
                        Dynamic Rendering
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_KHR_dynamic_rendering_local_read" 
						class="external-link" 
						target="_blank" >
                        Dynamic Rendering Local Read
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Used for tiling GPUs.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_EXT_dynamic_rendering_unused_attachments" 
						class="external-link" 
						target="_blank" >
                        Dynamic Rendering Unused Attachments
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_dynamic_rendering_unused_attachments.html" 
								class="external-link" 
								target="_blank" >
                                VK_EXT_dynamic_rendering_unused_attachments
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Requires Vulkan 1.3+.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/proposals/VK_EXT_dynamic_rendering_unused_attachments.adoc" 
								class="external-link" 
								target="_blank" >
                                Proposal
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html" 
								class="external-link" 
								target="_blank" >
                                VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            It relaxes the strict matching rules so a rendering instance and the bound pipelines may disagree about an attachment being “unused” in one but not the other (and relaxes some format/NULL mixing rules described in the extension).
						</p>
					</li>
					<li>
						<p>
							<em>
                                Support
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Pass 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
									</a>
                                    &nbsp;in the 
                                    <code>pNext</code>
                                    &nbsp;chain of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceFeatures2
									</a>
                                    &nbsp;structure passed to 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        vkGetPhysicalDeviceFeatures2
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The struct will be filled in to indicate whether each corresponding feature is supported.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Enabling
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Enable the corresponding feature in 
                                    <code>VkDeviceCreateInfo</code>
                                    &nbsp;(via 
                                    <code>VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT</code>
                                    )
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            This extension lifts some restrictions in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_dynamic_rendering.html" 
								class="external-link" 
								target="_blank" >
                                VK_KHR_dynamic_rendering
							</a>
                            &nbsp;extension to allow render pass instances and bound pipelines within those render pass instances to have an unused attachment specified in one but not the other. It also allows pipelines to use different formats in a render pass as long as the attachment is NULL.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkRenderingAttachmentInfo</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Structure specifying attachment information
				</p>
			</li>
			<li>
				<p>
                    <code>imageView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the image view that will be used for rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>imageLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the layout that 
                            <code>imageView</code>
                            &nbsp;will be in during rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveMode</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlagBits.html" 
								class="external-link" 
								target="_blank" >
                                VkResolveModeFlagBits
							</a>
                            &nbsp;value defining how data written to 
                            <code>imageView</code>
                            &nbsp;will be resolved into 
                            <code>resolveImageView</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is an image view used to write resolved data at the end of rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the layout that 
                            <code>resolveImageView</code>
                            &nbsp;will be in during rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>loadOp</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies what to do with the image before rendering.
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentLoadOp.html" 
								class="external-link" 
								target="_blank" >
                                VkAttachmentLoadOp
							</a>
                            &nbsp;value defining the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-load-operations" 
								class="external-link" 
								target="_blank" >
                                load operation
							</a>
                            &nbsp;for the attachment.
						</p>
					</li>
					<li>
						<p>
                            We’re using 
                            <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>
                            &nbsp;to clear the image to black before rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>storeOp</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies what to do with the image after rendering.
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentStoreOp.html" 
								class="external-link" 
								target="_blank" >
                                VkAttachmentStoreOp
							</a>
                            &nbsp;value defining the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-store-operations" 
								class="external-link" 
								target="_blank" >
                                store operation
							</a>
                            &nbsp;for the attachment.
						</p>
					</li>
					<li>
						<p>
                            We're using 
                            <code>VK_ATTACHMENT_STORE_OP_STORE</code>
                            &nbsp;to store the rendered image for later use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>clearValue</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkClearValue.html" 
								class="external-link" 
								target="_blank" >
                                VkClearValue
							</a>
                            &nbsp;structure defining values used to clear 
                            <code>imageView</code>
                            &nbsp;when 
                            <code>loadOp</code>
                            &nbsp;is 
                            <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkRenderingInfo</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Structure specifying render pass instance begin info.
				</p>
			</li>
			<li>
				<p>
                    Specifies the attachments to render to and the render area.
				</p>
			</li>
			<li>
				<p>
                    Combines the 
                    <code>RenderingAttachmentInfo</code>
                    &nbsp;with other rendering parameters.
				</p>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitmask of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFlagBits.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingFlagBits
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>renderArea</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the render area that is affected by the render pass instance.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Extent Requirements
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The 
                                    <code>rendering_info.renderArea.extent</code>
                                    &nbsp;has to fit inside the 
                                    <code>rendering_attachment.imageView</code>
                                    &nbsp;and hence the image.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If there is an instance of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupRenderPassBeginInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDeviceGroupRenderPassBeginInfo
							</a>
                            &nbsp;included in the 
                            <code>pNext</code>
                            &nbsp;chain and its 
                            <code>deviceRenderAreaCount</code>
                            &nbsp;member is not 
                            <code>0</code>
                            , then 
                            <code>renderArea</code>
                            &nbsp;is ignored, and the render area is defined per-device by that structure.
						</p>
					</li>
					<li>
						<p>
                            CharlesG - LunarG:
						</p>
						<ul>
							<li>
								<p>
                                    Viewports &amp; scissors let you specify a size smaller than the full image, as well as redefining the origin &amp; scale to use. Whereas the renderArea is specifying the actual image dimensions to use. This allows flexibility in how the backing VkImage is used in contrast to the viewport/scissor needs of the rendering itself. In most cases they are going to be “full” so its not like it comes into play always
								</p>
							</li>
							<li>
								<p>
                                    More clarity: viewport &amp; scissor are inputs to the rasterization stage, while the render area is an input for the attachment read/write.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Caio:
						</p>
						<ul>
							<li>
								<p>
                                    So, when comparing these two cases:
								</p>
								<ul>
									<li>
										<p>
                                            1- I use a 1080p image for the 
                                            <code>renderArea</code>
                                            &nbsp;and a 
                                            <code>640p</code>
                                            &nbsp;viewport and center the offset
										</p>
									</li>
									<li>
										<p>
                                            2- I use a 640p image for the 
                                            <code>renderArea</code>
                                            &nbsp;and a 
                                            <code>640p</code>
                                            &nbsp;viewport and center the offset
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Is there a difference between the quality and performance of these two? Or even, is there a visual difference?
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            CharlesG - LunarG:
						</p>
						<ul>
							<li>
								<p>
                                    I don't know tbh.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>colorAttachmentCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in 
                            <code>pColorAttachments</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pColorAttachments</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>colorAttachmentCount</code>
                            &nbsp;
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingAttachmentInfo
							</a>
                            &nbsp;structures describing any color attachments used.
						</p>
					</li>
					<li>
						<p>
                            Each element of the 
                            <code>pColorAttachments</code>
                            &nbsp;array corresponds to an output location in the shader, i.e. if the shader declares an output variable decorated with a 
                            <code>Location</code>
                            &nbsp;value of 
							<strong>
                                X
							</strong>
                            , then it uses the attachment provided in 
                            <code>pColorAttachments[X]</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If the 
                            <code>imageView</code>
                            &nbsp;member of any element of 
                            <code>pColorAttachments</code>
                            &nbsp;is 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NULL_HANDLE.html" 
								class="external-link" 
								target="_blank" >
                                VK_NULL_HANDLE
							</a>
                            , and 
                            <code>resolveMode</code>
                            &nbsp;is not 
                            <code>VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID</code>
                            , writes to the corresponding location by a fragment are discarded.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDepthAttachment</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingAttachmentInfo
							</a>
                            &nbsp;structure describing a depth attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pStencilAttachment</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingAttachmentInfo
							</a>
                            &nbsp;structure describing a stencil attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>viewMask</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitfield of view indices describing which views are active during rendering, when it is not 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>layerCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of layers rendered to in each attachment when 
                            <code>viewMask</code>
                            &nbsp;is 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Specifies the number of layers to render to, which is 1 for a non-layered image.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="multi-view" >
    Multi-view
</h5>
<ul>
	<li>
		<p>
            If 
            <code>VkRenderingInfo.viewMask</code>
            &nbsp;is not 
            <code>0</code>
            , multiview is enabled.
		</p>
	</li>
	<li>
		<p>
            If multiview is enabled, and the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-multiviewPerViewRenderAreas" 
				class="external-link" 
				target="_blank" >
                <code>multiviewPerViewRenderAreas</code>
			</a>
            &nbsp;feature is enabled, and there is an instance of 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM.html" 
				class="external-link" 
				target="_blank" >
                VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
			</a>
            &nbsp;included in the 
            <code>pNext</code>
            &nbsp;chain with 
            <code>perViewRenderAreaCount</code>
            &nbsp;not equal to 
            <code>0</code>
            , then the elements of 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM.html" 
				class="external-link" 
				target="_blank" >
                VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
			</a>
            ::
            <code>pPerViewRenderAreas</code>
            &nbsp;override 
            <code>renderArea</code>
            &nbsp;and define a render area for each view. In this case, 
            <code>renderArea</code>
            &nbsp;
			<strong>
                must
			</strong>
            &nbsp;be an area at least as large as the union of all the per-view render areas.
		</p>
	</li>
</ul>
<h5
	id="render-cmds" >
    Render Cmds
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdBeginRendering</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdEndRendering</code>
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="drawing-commands" >
    Drawing Commands
</h3>
<ul>
	<li>
		<p>
            Specify the Viewport and Scissor.
		</p>
	</li>
	<li>
		<p>
            Bind the pipeline.
		</p>
	</li>
	<li>
		<p>
            Bind the descriptor sets.
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdDraw()</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>vertexCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Even though we don’t have a vertex buffer, we technically still have 3 vertices to draw.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>instanceCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Used for instanced rendering, use 
                            <code>1</code>
                            &nbsp;if you’re not doing that.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstVertex</code>
				</p>
				<ul>
					<li>
						<p>
                            Used as an offset into the vertex buffer, defines the lowest value of 
                            <code>SV_VertexId</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstInstance</code>
				</p>
				<ul>
					<li>
						<p>
                            Used as an offset for instanced rendering, defines the lowest value of 
                            <code>SV_InstanceID</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="multithreading-rendering" >
    <s>Multithreading Rendering</s>
</h3>
<ul>
	<li>
		<p>
            Nah, I don't think it's necessary.
		</p>
	</li>
	<li>
		<p>
            From what I understand, it's about using multiple CPU threads to handle submissions and presentations, etc.
		</p>
	</li>
	<li>
		<p>
            It has nothing to do with frames in flight, btw.
		</p>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://www.youtube.com/watch?v=a49AWmIfjdo" 
				class="external-link" 
				target="_blank" >
                Explanation
			</a>
            </s>.
		</p>
		<ul>
			<li>
				<p>
                    The video explains okay, but nah.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        -&gt;
					</strong>
                    &nbsp;In the next video he says it wasn't exactly a good idea and 
					<em>
                        reverted
					</em>
                    &nbsp;what he did in that video.
				</p>
				<ul>
					<li>
						<p>
                            &quot;It was technically slower and more confusing to do synchronizations&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="render-passes-and-framebuffers" >
    <s>Render Passes and Framebuffers</s>
</h3>
<h5
	id="dynamic-rendering-features-and-differences-from-render-passes" >
    Dynamic Rendering: Features and differences from Render Passes
</h5>
<ul>
	<li>
		<p>
            Replaces 
            <code>VkRenderPass</code>
            &nbsp;and Framebuffers.
		</p>
		<ul>
			<li>
				<p>
                    Instead, we can specify the color, depth, and stencil attachments directly when we begin rendering.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Describe renderpasses inline with command buffer recording.
		</p>
	</li>
	<li>
		<p>
            Provides more flexibility by allowing us to change the attachments we’re rendering to without creating new render pass objects.
		</p>
	</li>
	<li>
		<p>
            Greatly simplifies application architecture.
		</p>
	</li>
	<li>
		<p>
            Synchronization still needs to be done, but now it's even more explicit, truer to its stated nature.
		</p>
		<ul>
			<li>
				<p>
                    We had to do that with Render Passes, but that was bound up in the Render Pass creation.
				</p>
			</li>
			<li>
				<p>
                    Now, the synchronization is more explicit.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tiling GPUs aren't left behind.
		</p>
		<ul>
			<li>
				<p>
                    The v1.4 
                    <code>dynamicRenderingLocalRead</code>
                    , 
                    <code>VK_KHR_dynamic_rendering_local_read</code>
                    &nbsp;brings tiling GPUs to the same capabilities, and they don't need to state the Render Passes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            I wouldn't say that &quot;You should use Render Passes if your hardware isn't new enough&quot;, because it isn't fun.
		</p>
	</li>
	<li>
		<p>
            Better compatibility with modern rendering techniques.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731211439.png" width="425" >
            .
		</p>
	</li>
</ul>
<h5
	id="subpasses" >
    Subpasses
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250930090957.png" width="480" >
            .
		</p>
	</li>
	<li>
		<p>
            <s>
			<strong>
                External subpass dependencies
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Explained by TheMaister 2019; he is part of the Khronos Group.
				</p>
			</li>
			<li>
				<p>
                    The main purpose of external subpass dependencies is to deal with initialLayout and finalLayout of an attachment reference. If initialLayout != layout used in the first subpass, the render pass is forced to perform a layout transition.
				</p>
			</li>
			<li>
				<p>
                    If you don’t specify anything else, that layout transition will wait for nothing before it performs the transition. Or rather, the driver will inject a dummy subpass dependency for you with srcStageMask = TOP_OF_PIPE_BIT. This is not what you want since it’s almost certainly going to be a race condition. You can set up a subpass dependency with the appropriate srcStageMask and srcAccessMask.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        The external subpass dependency is basically just a vkCmdPipelineBarrier injected for you by the driver.
					</strong>
				</p>
			</li>
			<li>
				<p>
                    The whole premise here is that it’s theoretically better to do it this way because the driver has more information, but this is questionable, at least on current hardware and drivers.
				</p>
			</li>
			<li>
				<p>
                    There is a very similar external subpass dependency setup for finalLayout. If finalLayout differs from the last use in a subpass, driver will transition into the final layout automatically. Here you get to change 
                    <code>dstStageMask</code>
                    /
                    <code>dstAccessMask</code>
                    . If you do nothing here, you get 
                    <code>BOTTOM_OF_PIPE</code>
                    , which can actually be just fine. A prime use case here is swapchain images which have 
                    <code>finalLayout = PRESENT_SRC_KHR</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Essentially, 
					<strong>
                        you can ignore external subpass dependencies
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    Their added complexity gives very little gain. Render pass compatibility rules also imply that if you change even minor things like which stages to wait for, you need to create new pipelines!
				</p>
			</li>
			<li>
				<p>
                    This is dumb, and will hopefully be fixed at some point in the spec.
				</p>
			</li>
			<li>
				<p>
                    However, while the usefulness of external subpass dependencies is questionable, they have some convenient use cases I’d like to go over:
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Automatically transitioning 
                                <code>TRANSIENT_ATTACHMENT</code>
                                &nbsp;images
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    If you’re on mobile, you should be using transient images where possible. When using these attachments in a render pass, it makes sense to always have them as initialLayout = UNDEFINED. Since we know that these images can only ever be used in 
                                    <code>COLOR_ATTACHMENT_OUTPUT</code>
                                    &nbsp;or 
                                    <code>EARLY</code>
                                    /
                                    <code>LATE_FRAGMENT_TEST</code>
                                    &nbsp;stages depending on their image format, the external subpass dependency writes itself, and we can just use transient attachments without having to think too hard about how to synchronize them. This is what I do in my Granite engine, and it’s quite useful. Of course, we could just inject a pipeline barrier for this exact same purpose, but that’s more boilerplate.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Automatically transitioning swapchain images
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Typically, swapchain images are always just used once per frame, and we can deal with all synchronization using external subpass dependencies. We want 
                                    <code>initialLayout = UNDEFINED</code>
                                    , and 
                                    <code>finalLayout = PRESENT_SRC_KHR</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
                                    &nbsp;is 
                                    <code>COLOR_ATTACHMENT_OUTPUT</code>
                                    &nbsp;which lets us link up with the swapchain acquire semaphore. For this case, we will need an external subpass dependency. For the 
                                    <code>finalLayout</code>
                                    &nbsp;transition after the render pass, we are fine with 
                                    <code>BOTTOM_OF_PIPE</code>
                                    &nbsp;being used. We’re going to use semaphores here anyways.
								</p>
							</li>
							<li>
								<p>
                                    I also do this in Granite.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="framebuffers" >
    Framebuffers
</h5>
<ul>
	<li>
		<p>
            <code>VkFrameBuffer</code>
		</p>
		<ul>
			<li>
				<p>
                    Holds the target images for a renderpass.
				</p>
			</li>
			<li>
				<p>
                    Only used in legacy tutorials.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Just wrappers to image views.
		</p>
	</li>
	<li>
		<p>
            The attachments of a Framebuffer are the Image Views.
		</p>
	</li>
	<li>
		<p>
            The Framebuffers are used within a Render Pass.
		</p>
	</li>
	<li>
		<p>
            LunarG / Vulkan: &quot;Kinda of a bad name, it's just a couple of image views&quot;.
		</p>
	</li>
	<li>
		<p>
            Only exists to combine images and renderpasses.
		</p>
	</li>
</ul>
<h5
	id="render-passes" >
    Render Passes
</h5>
<ul>
	<li>
		<p>
            <code>VkRenderPass</code>
		</p>
		<ul>
			<li>
				<p>
                    Holds information about the images you are rendering into. All drawing commands have to be done inside a renderpass.
				</p>
			</li>
			<li>
				<p>
                    Only used in legacy tutorials.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Render passes in Vulkan describe the 
			<em>
                type
			</em>
            &nbsp;of images that are used during rendering operations, 
			<em>
                how
			</em>
            &nbsp;they will be used, and 
			<em>
                how
			</em>
            &nbsp;their contents should be treated.
		</p>
	</li>
	<li>
		<p>
            All drawing commands happen inside a &quot;render pass&quot;.
		</p>
	</li>
	<li>
		<p>
            Acts as pseudo render graph.
		</p>
	</li>
	<li>
		<p>
            Allows tiling GPUs to use memory efficiently.
		</p>
		<ul>
			<li>
				<p>
                    Efficient scheduling.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Describe images attachments.
		</p>
	</li>
	<li>
		<p>
            Defines the subpasses.
		</p>
	</li>
	<li>
		<p>
            Declare dependencies between subpasses.
		</p>
	</li>
	<li>
		<p>
            Require 
            <code>VkFrameBuffers</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    Whereas a render pass only describes the type of images, a 
                    <code>VkFramebuffer</code>
                    &nbsp;actually binds specific images to these slots.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250730160923.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Problem
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Great in theory, not so great to use in practice.
				</p>
			</li>
			<li>
				<p>
                    Single object with many responsibilities.
				</p>
				<ul>
					<li>
						<p>
                            Made the API harder to reason about when looking at the code.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Hard to architect into a renderer.
				</p>
				<ul>
					<li>
						<p>
                            Yet another input for pipelines.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The main benefit is for tiling based GPUs.
				</p>
				<ul>
					<li>
						<p>
                            Commonly found in mobile.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;Use Dynamic Rendering, it's much better&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="submit" >
    Submit
</h3>
<ul>
	<li>
		<p>
            Submits the Command Buffers recorded.
		</p>
	</li>
	<li>
		<p>
            <code>vkSubmitInfo</code>
		</p>
		<ul>
			<li>
				<p>
                    The first three parameters specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait.
				</p>
			</li>
			<li>
				<p>
                    We want to wait for writing colors to the image until it’s available, so we’re specifying the stage of the graphics pipeline that writes to the color attachment.
				</p>
			</li>
			<li>
				<p>
                    That means that theoretically, the implementation can already start executing our vertex shader and such while the image is not yet available.
				</p>
			</li>
			<li>
				<p>
                    Each entry in the 
                    <code>waitStages</code>
                    &nbsp;array corresponds to the semaphore with the same index in 
                    <code>pWaitSemaphores</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <code>pCommandBuffers</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies which command buffers to actually submit for execution. We simply submit the single command buffer we have.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSignalSemaphores</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies which semaphores to signal once the command buffer(s) have finished execution.
						</p>
					</li>
					<li>
						<p>
                            In our case we’re using the 
                            <code>renderFinishedSemaphore</code>
                            &nbsp;for that purpose.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkQueueSubmit()</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>fence</code>
				</p>
				<ul>
					<li>
						<p>
                            Is an optional handle to a fence to be 
							<em>
                                signaled
							</em>
                            &nbsp;once all submitted command buffers have completed execution.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The function takes an array of 
                    <code>VkSubmitInfo</code>
                    &nbsp;structures as argument for efficiency when the workload is much larger.
				</p>
			</li>
			<li>
				<p>
                    The last parameter references an optional fence that will be signaled when the command buffers finish execution.
				</p>
			</li>
			<li>
				<p>
                    This allows us to know when it is safe for the command buffer to be reused, thus we want to give it 
                    <code>drawFence</code>
                    . Now we want the CPU to wait while the GPU finishes rendering that frame we just submitted:
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="presentation" >
    Presentation
</h3>
<ul>
	<li>
		<p>
            The last step of drawing a frame is submitting the result back to the Swapchain to have it 
			<em>
                eventually show up
			</em>
            &nbsp;on the screen.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Presentation Engine
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250818172910.png" width="350" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VkPresentInfoKHR</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>pWaitSemaphores</code>
				</p>
				<ul>
					<li>
						<p>
                            Which semaphores to wait on before presentation can happen, just like 
                            <code>VkSubmitInfo</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Since we want to wait on the command buffer to finish execution, thus our triangle being drawn, we take the semaphores which will be signaled and wait on them, thus we use 
                            <code>signalSemaphores</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The next two parameters specify the Swapchains to present images to and the index of the image for each Swapchain.
				</p>
			</li>
			<li>
				<p>
                    This will almost always be single.
				</p>
			</li>
			<li>
				<p>
                    <code>pResults</code>
				</p>
				<ul>
					<li>
						<p>
                            It allows you to specify an array of 
                            <code>VkResult</code>
                            &nbsp;values to check for every Swapchain if presentation was successful.
						</p>
					</li>
					<li>
						<p>
                            It’s not necessary if you’re only using a single Swapchain, because you can use the return value of the present function.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>QueuePresentKHR()</code>
		</p>
		<ul>
			<li>
				<p>
                    Submits a rendered image to the presentation queue.
				</p>
			</li>
			<li>
				<p>
                    Used after queueing all rendering commands and transitioning the image to the correct layout.
				</p>
			</li>
			<li>
				<p>
                    Vulkan transfers ownership of the image to the 'presentation engine'.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How a presentation happens
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Who
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
							<em>
                                GPU
							</em>
                            &nbsp;(via the display controller/hardware), orchestrated by the 
							<em>
                                OS/window system
							</em>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        When
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            At the next vertical blanking interval (
							<strong>
                                Vblank
							</strong>
                            ).
						</p>
						<ul>
							<li>
								<p>
									<strong>
                                        Vblank
									</strong>
                                    &nbsp;is the moment between screen refreshes (e.g., at 60 Hz, every 16.67 ms).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            In a Vulkan workflow, we can be sure that the presentation happened between the 
                            <code>QueuePresentKHR()</code>
                            &nbsp;and the 
                            <code>vkAcquireNextImageKHR()</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    The job of the 
                                    <code>present_complete_semaphore</code>
                                    &nbsp;is to hold this information.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        How
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The GPU's 
							<em>
                                display controller
							</em>
                            &nbsp;reads the image from GPU memory.
						</p>
					</li>
					<li>
						<p>
                            The OS/window system (e.g., X11/Wayland on Linux, Win32 on Windows) composites the image into the application window.
						</p>
					</li>
					<li>
						<p>
                            The final output is scanned out to the display.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Image recycling
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    After presentation, the image is released back to the swapchain.
				</p>
			</li>
			<li>
				<p>
                    It becomes available for re-acquisition via 
                    <code>vkAcquireNextImageKHR</code>
                    &nbsp;(after the next vblank).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="synchronization-and-cache-control" >
    Synchronization and Cache Control
</h2>
<ul>
	<li>
		<p>
            <img src="assets/image_20250801134239.png" width="540" >
            .
		</p>
	</li>
</ul>
<h5
	id="vk_khr_synchronization2" >
    VK_KHR_synchronization2
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/extensions/VK_KHR_synchronization2.html#VK_KHR_synchronization2" 
				class="external-link" 
				target="_blank" >
                <code>VK_KHR_synchronization2</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Nvidia: Use 
            <code>VK_KHR_synchronization2</code>
            , the new functions allow the application to describe barriers more accurately.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Highlights
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    One main change with the extension is to have pipeline stages and access flags now specified together in memory barrier structures.
				</p>
				<ul>
					<li>
						<p>
                            This makes the connection between the two more obvious.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Due to running out of the 32 bits for 
                    <code>VkAccessFlag</code>
                    &nbsp;the 
                    <code>VkAccessFlags2KHR</code>
                    &nbsp;type was created with a 64-bit range. To prevent the same issue for 
                    <code>VkPipelineStageFlags</code>
                    , the 
                    <code>VkPipelineStageFlags2KHR</code>
                    &nbsp;type was also created with a 64-bit range.
				</p>
			</li>
			<li>
				<p>
                    Adds 2 new image layouts 
                    <code>VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR</code>
                    &nbsp;and 
                    <code>VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR</code>
                    &nbsp;to help with making layout transition easier.
				</p>
			</li>
			<li>
				<p>
                    etc.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="queues" >
    Queues
</h3>
<ul>
	<li>
		<p>
            Any synchronization applies globally to a 
            <code>VkQueue</code>
            , there is no concept of a only-inside-this-command-buffer synchronization.
		</p>
	</li>
</ul>
<h5
	id="queueidle-and-deviceidle" >
    QueueIdle and DeviceIdle
</h5>
<ul>
	<li>
		<p>
            These functions can be used as a very rudimentary way to perform synchronization.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Closing the program
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We should wait for the logical device to finish operations before exiting 
                    <code>mainLoop</code>
                    &nbsp;and destroying the window.
				</p>
			</li>
			<li>
				<p>
                    You can also wait for operations in a specific command queue to be finished with 
                    <code>vkQueueWaitIdle</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    You’ll see that the program now exits without problems when closing the window.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Problem
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The problem of 
                    <code>vkDeviceWaitIdle</code>
                    &nbsp;or 
                    <code>vkQueueWaitIdle</code>
                    , due to the lack of fences for 
                    <code>vkQueuePresent</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            See 
                            <a href="Vulkan.html#Recreating">
                            Vulkan#Recreating
                            </a>
                            , about 
                            <code>VK_EXT_swapchain_maintenance1</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use 
                    <code>VK_EXT_swapchain_maintenance1</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    See 
                    <a href="Vulkan.html#Recreating">
                    Vulkan#Recreating
                    </a>
                    , for usage with swapchain.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731212325.png" width="425" >
            .
		</p>
	</li>
</ul>
<h3
	id="blocking-operations" >
    Blocking Operations
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250929150320.png" width="600" >
            .
		</p>
		<ul>
			<li>
				<p>
                    By Samsung 2019.
				</p>
			</li>
			<li>
				<p>
                    I don't know if this information is still valid.
				</p>
			</li>
			<li>
				<p>
                    See the Mobile section for optimizations of 
                    <code>vkQueuePresent</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="examples" >
    Examples
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/synchronization_examples.html" 
				class="external-link" 
				target="_blank" >
                Synchronization examples
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Example 1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
                    &nbsp;– writes to an SSBO, 
                    <code>ACCESS_SHADER_WRITE</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = TRANSFER, srcAccessMask = SHADER_WRITE, dstAccessMask = 0)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = TRANSFER, dstStageMask = COMPUTE, srcAccessMask = 0, dstAccessMask = SHADER_READ)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
                    &nbsp;– read from the same SSBO, 
                    <code>ACCESS_SHADER_READ</code>
				</p>
			</li>
			<li>
				<p>
                    While 
                    <code>StageMask</code>
                    &nbsp;cannot be 0, 
                    <code>AccessMask</code>
                    &nbsp;can be 0.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Recently allocated image, to use in a compute shader as a storage image
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The pipeline barrier looks like:
				</p>
				<ul>
					<li>
						<p>
                            <code>oldLayout = UNDEFINED</code>
						</p>
						<ul>
							<li>
								<p>
                                    Input is garbage
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>newLayout = GENERAL</code>
						</p>
						<ul>
							<li>
								<p>
                                    Storage image compatible layout
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcStageMask = TOP_OF_PIPE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Wait for nothing
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcAccessMask = 0</code>
						</p>
						<ul>
							<li>
								<p>
                                    This is key, there are no pending writes to flush out.
								</p>
							</li>
							<li>
								<p>
                                    This is the only way to use 
                                    <code>TOP_OF_PIPE</code>
                                    &nbsp;in a memory barrier.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstStageMask = COMPUTE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Unblock compute after the layout transition is done
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstAccessMask = SHADER_READ | SHADER_WRITE</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Swapchain Image Transition to PRESENT_SRC
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We have to transition them into 
                    <code>IMAGE_LAYOUT_PRESENT_SRC</code>
                    &nbsp;before passing the image over to the presentation engine.
				</p>
			</li>
			<li>
				<p>
                    Having 
                    <code>dstStageMask = BOTTOM_OF_PIPE</code>
                    &nbsp;and 
                    <code>dstAccessMask = 0</code>
                    &nbsp;is perfectly fine. We don’t care about making this memory 
					<strong>
                        visible
					</strong>
                    &nbsp;to any stage beyond this point. We will use semaphores to synchronize with the presentation engine anyways.
				</p>
			</li>
			<li>
				<p>
                    The pipeline barrier looks like:
				</p>
				<ul>
					<li>
						<p>
                            <code>srcStageMask = COLOR_ATTACHMENT_OUTPUT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Assuming we rendered to swapchain in a render pass.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcAccessMask = COLOR_ATTACHMENT_WRITE</code>
						</p>
					</li>
					<li>
						<p>
                            <code>dstStageMask = BOTTOM_OF_PIPE</code>
						</p>
						<ul>
							<li>
								<p>
                                    After transitioning into this 
                                    <code>PRESENT</code>
                                    &nbsp;layout, we’re not going to touch the image again until we reacquire the image, so 
                                    <code>dstStageMask = BOTTOM_OF_PIPE</code>
                                    &nbsp;is appropriate.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstAccessMask = 0</code>
						</p>
					</li>
					<li>
						<p>
                            <code>oldLayout = COLOR_ATTACHMENT_OPTIMAL</code>
						</p>
					</li>
					<li>
						<p>
                            <code>newLayout = PRESENT_SRC_KHR</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Setting 
                    <code>dstAccessMask = 0</code>
                    &nbsp;on the final 
                    <code>TRANSFER_DST → PRESENT_SRC_KHR</code>
                    &nbsp;barrier means “there is no 
					<em>
                        GPU
					</em>
                    &nbsp;access after this barrier that we are ordering/expressing.” For swapchain-present that is intentional and common: presentation is outside the GPU pipeline, so the barrier only needs to make the 
					<em>
                        producer
					</em>
                    &nbsp;writes (e.g. your blit 
                    <code>TRANSFER_WRITE</code>
                    ) available/visible; the presentation engine performs its own, external visibility semantics.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example 1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = FRAGMENT_SHADER, dstStageMask = ?)</code>
				</p>
			</li>
			<li>
				<p>
                    Vertex shading for future commands can begin executing early, we only need to wait once 
                    <code>FRAGMENT_SHADER</code>
                    &nbsp;is reached.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example 2
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    {5, 6, 7} must wait for {1, 2, 3}.
				</p>
			</li>
			<li>
				<p>
                    A possible execution order here could be:
				</p>
				<ul>
					<li>
						<p>
                            #3
						</p>
					</li>
					<li>
						<p>
                            #2
						</p>
					</li>
					<li>
						<p>
                            #1
						</p>
					</li>
					<li>
						<p>
                            #7
						</p>
					</li>
					<li>
						<p>
                            #6
						</p>
					</li>
					<li>
						<p>
                            #5
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    {1, 2, 3} can execute out-of-order, and so can {5, 6, 7}, but these two sets of commands can not interleave execution.
				</p>
			</li>
			<li>
				<p>
                    In spec lingo {1, 2, 3} 
					<em>
                        happens-before
					</em>
                    &nbsp;{5, 6, 7}.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Chain of Dependencies (1)
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = TRANSFER)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = TRANSFER, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    {5, 6} must wait for {1, 2}.
				</p>
			</li>
			<li>
				<p>
                    We created a chain of dependencies between COMPUTE -&gt; TRANSFER -&gt; COMPUTE.
				</p>
			</li>
			<li>
				<p>
                    When we wait for TRANSFER in 4, we must also wait for anything which is currently blocking TRANSFER.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Chain of dependencies (2)
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = COMPUTE, dstStageMask = TRANSFER)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdMagicDummyTransferOperation</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdPipelineBarrier(srcStageMask = TRANSFER, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    {4} must wait for {1, 2}.
				</p>
			</li>
			<li>
				<p>
                    {6, 7} must wait for {4}.
				</p>
			</li>
			<li>
				<p>
                    The chain is {1, 2} -&gt; {4} -&gt; {6, 7}, and if {4} is noop (no operation), {1, 2} -&gt; {6, 7} is achieved.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="queues" >
    Queues
</h3>
<ul>
	<li>
		<p>
            Any synchronization applies globally to a 
            <code>VkQueue</code>
            , there is no concept of a only-inside-this-command-buffer synchronization.
		</p>
	</li>
	<li>
		<p>
            Graphics pipelines are executable on queues supporting 
            <code>VK_QUEUE_GRAPHICS_BIT</code>
            . Stages executed by graphics pipelines 
			<strong>
                can
			</strong>
            &nbsp;only be specified in commands recorded for queues supporting 
            <code>VK_QUEUE_GRAPHICS_BIT</code>
            .
		</p>
	</li>
</ul>
<h5
	id="queue-family-ownership-transfer" >
    Queue Family Ownership Transfer
</h5>
<ul>
	<li>
		<p>
            Resources created with a 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkSharingMode" 
				class="external-link" 
				target="_blank" >
                VkSharingMode
			</a>
            &nbsp;of 
            <code>VK_SHARING_MODE_EXCLUSIVE</code>
            &nbsp;
			<strong>
                must
			</strong>
            &nbsp;have their ownership explicitly transferred from one queue family to another in order to access their content in a well-defined manner on a queue in a different queue family.
		</p>
	</li>
	<li>
		<p>
            Resources shared with external APIs or instances using external memory 
			<strong>
                must
			</strong>
            &nbsp;also explicitly manage ownership transfers between local and external queues (or equivalent constructs in external APIs) regardless of the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkSharingMode" 
				class="external-link" 
				target="_blank" >
                VkSharingMode
			</a>
            &nbsp;specified when creating them.
		</p>
	</li>
	<li>
		<p>
            If you need to transfer ownership to a different queue family, you need memory barriers, one in each queue to release/acquire ownership.
		</p>
	</li>
	<li>
		<p>
            If memory dependencies are correctly expressed between uses of such a resource between two queues in different families, but no ownership transfer is defined, the contents of that resource are undefined for any read accesses performed by the second queue family.
		</p>
	</li>
	<li>
		<p>
            A queue family ownership transfer consists of two distinct parts:
		</p>
		<ol>
			<li>
				<p>
                    Release exclusive ownership from the source queue family
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers-release" 
								class="external-link" 
								target="_blank" >
                                queue family release operation
							</a>
						</p>
					</li>
					<li>
						<p>
                            Is defined when 
                            <code>dstQueueFamilyIndex</code>
                            &nbsp;is one of those values.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Acquire exclusive ownership for the destination queue family
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers-acquire" 
								class="external-link" 
								target="_blank" >
                                queue family acquire operation
							</a>
						</p>
					</li>
					<li>
						<p>
                            Is defined when 
                            <code>srcQueueFamilyIndex</code>
                            &nbsp;is one of those values.
						</p>
					</li>
				</ul>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    Is defined if the values 
					<strong>
                        are not equal,
					</strong>
                    &nbsp;and either is one of the special queue family values reserved for external memory ownership transfers
				</p>
			</li>
			<li>
				<p>
                    An application 
					<strong>
                        must
					</strong>
                    &nbsp;ensure that these operations occur in the correct order by defining an execution dependency between them, e.g. using a semaphore.
				</p>
			</li>
			<li>
				<p>
                    A 
					<em>
                        release operation
					</em>
                    &nbsp;is used to release exclusive ownership of a range of a buffer or image subresource range. A release operation is defined by executing a 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-buffer-memory-barriers" 
						class="external-link" 
						target="_blank" >
                        buffer memory barrier
					</a>
                    &nbsp;(for a buffer range) or an 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-image-memory-barriers" 
						class="external-link" 
						target="_blank" >
                        image memory barrier
					</a>
                    &nbsp;(for an image subresource range) using a pipeline barrier command, on a queue from the source queue family.
				</p>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Etc, I haven't read much about it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="command-buffers" >
    Command Buffers
</h5>
<ul>
	<li>
		<p>
            The specification states that commands start execution in-order, but complete out-of-order. Don’t get confused by this. The fact that commands start in-order is simply convenient language to make the spec language easier to write.
		</p>
	</li>
	<li>
		<p>
            Unless you add synchronization yourself, all commands in a queue execute out of order. Reordering may happen across command buffers and even 
            <code>vkQueueSubmits</code>
            .
		</p>
	</li>
	<li>
		<p>
            This makes sense, considering that Vulkan only sees a linear stream of commands once you submit, it is a pitfall to assume that splitting command buffers or submits adds some magic synchronization for you.
		</p>
	</li>
	<li>
		<p>
            Frame buffer operations inside a render pass happen in API-order, of course. This is a special exception which the spec calls out.
		</p>
	</li>
</ul>
<h5
	id="queue-submissions-vkqueuesubmit" >
    Queue Submissions (vkQueueSubmit)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#devsandqueues-submission" 
				class="external-link" 
				target="_blank" >
                Queue submission commands
			</a>
		</p>
	</li>
	<li>
		<p>
            It automatically performs a 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-submission-host-writes" 
				class="external-link" 
				target="_blank" >
                domain operation from host to device
			</a>
            &nbsp;for all writes performed before the command executes, so in most cases an explicit memory barrier is not needed for this case.
		</p>
	</li>
	<li>
		<p>
            In the few circumstances where a submit does not occur between the host write and the device read access, writes 
			<strong>
                can
			</strong>
            &nbsp;be made available by using an explicit memory barrier.
		</p>
	</li>
</ul>
<h5
	id="example" >
    Example
</h5>
<ul>
	<li>
		<p>
            <code>vkCmdDispatch (VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT)</code>
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdCopyBuffer (VK_PIPELINE_STAGE_TRANSFER_BIT)</code>
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdDispatch (VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT)</code>
		</p>
	</li>
	<li>
		<p>
            <code>vkCmdPipelineBarrier (srcStageMask = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT)</code>
		</p>
	</li>
	<li>
		<p>
            We would be referring to the two 
            <code>vkCmdDispatch</code>
            &nbsp;commands, as they perform their work in the COMPUTE stage. Even if we split these 4 commands into 4 different 
            <code>vkQueueSubmits</code>
            , we would still consider the same commands for synchronization.
		</p>
	</li>
	<li>
		<p>
            Essentially, the work we are waiting for is 
			<em>
                all commands which have ever been submitted to the queue including any previous commands in the command buffer we’re recording.
			</em>
		</p>
	</li>
</ul>
<h3
	id="execution-dependencies-memory-dependencies-memory-model" >
    Execution Dependencies, Memory Dependencies, Memory Model
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-model" 
				class="external-link" 
				target="_blank" >
                Memory Model
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-model-availability-visibility" 
						class="external-link" 
						target="_blank" >
                        Availability and Visibility
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="data-hazards" >
    Data hazards
</h5>
<ul>
	<li>
		<p>
			<em>
                Execution dependencies
			</em>
            &nbsp;and 
			<em>
                memory dependencies
			</em>
            &nbsp;are used to solve data hazards, i.e. to ensure that read and write operations occur in a well-defined order.
		</p>
		<ul>
			<li>
				<p>
                    An 
					<em>
                        operation
					</em>
                    &nbsp;is an arbitrary amount of work to be executed on the host, a device, or an external entity such as a presentation engine.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Write-after-read hazards
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can be solved with just an execution dependency
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Read-after-write hazards
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Need appropriate memory dependencies to be included between them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Write-after-write hazards
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Need appropriate memory dependencies to be included between them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If an application does not include dependencies to solve these hazards, the results and execution orders of memory accesses are 
			<strong>
                undefined
			</strong>
            .
		</p>
	</li>
</ul>
<h5
	id="execution-dependencies" >
    Execution Dependencies
</h5>
<ul>
	<li>
		<p>
            An 
			<em>
                execution dependency
			</em>
            &nbsp;is a guarantee that for two sets of operations, the first set 
			<strong>
                must
			</strong>
            &nbsp;happen-before the second set. If an operation happens-before another operation, then the first operation 
			<strong>
                must
			</strong>
            &nbsp;complete before the second operation is initiated.
		</p>
	</li>
	<li>
		<p>
			<em>
                Execution dependencies
			</em>
            &nbsp;alone are not sufficient to guarantee that values resulting from writes in one set of operations 
			<strong>
                can
			</strong>
            &nbsp;be read from another set of operations.
		</p>
	</li>
</ul>
<h5
	id="memory-available" >
    Memory Available
</h5>
<ul>
	<li>
		<p>
            Availability operations cause the values generated by specified memory write accesses to become 
			<em>
                available
			</em>
            &nbsp;for future access.
		</p>
	</li>
	<li>
		<p>
            Any 
			<em>
                available
			</em>
            &nbsp;value remains available until a subsequent write to the same memory location occurs (whether it is made available or not) or the memory is freed.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Availability operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cause the values generated by specified memory write accesses to become 
					<em>
                        available
					</em>
                    &nbsp;to a memory domain for future access. Any available value remains available until a subsequent write to the same memory location occurs (whether it is made available or not) or the memory is freed.
				</p>
			</li>
			<li>
				<p>
                    Even with coherent mapping, you still need to have a dependency between the host writing that memory and the GPU operation reading it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            We can say “making memory available” is all about flushing caches.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#vkFlushMappedMemoryRanges" 
				class="external-link" 
				target="_blank" >
                <code>vkFlushMappedMemoryRanges()</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Guarantees that host writes to the memory ranges described by 
                    <code>pMemoryRanges</code>
                    &nbsp;
					<strong>
                        can
					</strong>
                    &nbsp;be made 
					<em>
                        available
					</em>
                    &nbsp;to device access, via 
					<em>
                        availability operations
					</em>
                    &nbsp;from the 
                    <code>VK_ACCESS_HOST_WRITE_BIT</code>
                    &nbsp;access type.
				</p>
			</li>
			<li>
				<p>
                    This is required for CPU writes, which 
                    <code>HOST_COHERENT</code>
                    &nbsp;effectively provides.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Cache example
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    When our L2 cache contains the most up-to-date data there is, we can say that memory is 
					<em>
                        available
					</em>
                    , as L1 caches connected to L2 can pull in the most up-to-date data there is.
				</p>
			</li>
			<li>
				<p>
                    Once a shader stage writes to memory, the L2 cache no longer has the most up-to-date data there is, so that memory is no longer considered 
					<em>
                        available
					</em>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If other caches try to read from L2, it will see undefined data.
						</p>
					</li>
					<li>
						<p>
                            Whatever wrote that data must make those writes 
							<em>
                                available
							</em>
                            &nbsp;before the data can be made 
							<em>
                                visible
							</em>
                            &nbsp;again.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-domain" >
    Memory Domain
</h5>
<ul>
	<li>
		<p>
			<em>
                Memory domain operations
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cause writes that are available to a source memory domain to become available to a destination memory domain (an example of this is making writes available to the host domain available to the device domain).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-visible" >
    Memory Visible
</h5>
<ul>
	<li>
		<p>
			<strong>
                Visibility operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cause values 
					<em>
                        available
					</em>
                    &nbsp;to a memory domain to become 
					<em>
                        visible
					</em>
                    &nbsp;to specified memory accesses.
				</p>
			</li>
			<li>
				<p>
                    Memory barriers are visibility operations. Without them, you wouldn’t have visibility of the memory.
				</p>
				<ul>
					<li>
						<p>
                            The execution barrier ensures the completion of a command, but the 
                            <code>srcStageMask</code>
                            , 
                            <code>dstStageMask</code>
                            , 
                            <code>srcAccessMask</code>
                            &nbsp;and 
                            <code>dstAccessMask</code>
                            &nbsp;are what handles availability.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Once written values are made visible to a particular type of memory access, they 
			<strong>
                can
			</strong>
            &nbsp;be read or written by that type of memory access.
		</p>
	</li>
	<li>
		<p>
            We can say “making memory visible” is all about invalidating caches.
		</p>
	</li>
	<li>
		<p>
            Availability is a necessary part of visibility, but availability alone is not sufficient.
		</p>
		<ul>
			<li>
				<p>
                    You can do things that might have caused visibility, but because the write was not available, they don’t actually make the write visible.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Under the hood, visibility is implementation-specific. The pure-visibility parts typically involve forcing lines out of caches and/or invalidating them. But some kinds of visibility may not require even that.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkInvalidateMappedMemoryRanges.html" 
				class="external-link" 
				target="_blank" >
                <code>vkInvalidateMappedMemoryRanges()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Guarantees that device writes to the memory ranges described by 
                    <code>pMemoryRanges</code>
                    , which have been made 
					<em>
                        available
					</em>
                    &nbsp;to the host memory domain using the 
                    <code>VK_ACCESS_HOST_WRITE_BIT</code>
                    &nbsp;and 
                    <code>VK_ACCESS_HOST_READ_BIT</code>
                    &nbsp;access types, are made 
					<em>
                        visible
					</em>
                    &nbsp;to the host.
				</p>
			</li>
			<li>
				<p>
                    If a range of non-coherent memory is written by the host and then invalidated without first being flushed, its contents are undefined.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="host-coherent" >
    Host Coherent
</h5>
<ul>
	<li>
		<p>
            <code>MEMORY_PROPERTY_HOST_COHERENT</code>
		</p>
		<ul>
			<li>
				<p>
                    If a memory object 
					<em>
                        does
					</em>
                    &nbsp;have this property:
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Writes
							</em>
                            &nbsp;to the memory object from the host are automatically made 
							<em>
                                available
							</em>
                            &nbsp;to the host domain.
						</p>
					</li>
					<li>
						<p>
                            It says that you don't need 
                            <code>vkFlushMappedMemoryRanges()</code>
                            &nbsp;or 
                            <code>vkInvalidateMappedMemoryRanges()</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            This property alone is insufficient for availability. You still need to use synchronization to make sure that reads and writes from CPU and GPU happen in the right order, and you need memory barriers on the GPU side to manage GPU caches (make CPU writes visible to GPU reads, and make GPU writes available to CPU reads).
						</p>
					</li>
					<li>
						<p>
                            Coherency is about &quot;visibility&quot;, but you still need availability.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If a memory object 
					<em>
                        does not
					</em>
                    &nbsp;have this property:
				</p>
				<ul>
					<li>
						<p>
                            <code>vkFlushMappedMemoryRanges()</code>
							<strong>
                                must
							</strong>
                            &nbsp;be called in order to guarantee that writes to the memory object from the host are made 
							<em>
                                available
							</em>
                            &nbsp;to the host domain, where they 
							<strong>
                                can
							</strong>
                            &nbsp;be further made available to the device domain via a domain operation.
						</p>
					</li>
					<li>
						<p>
                            <code>vkInvalidateMappedMemoryRanges()</code>
                            &nbsp;
							<strong>
                                must
							</strong>
                            &nbsp;be called to guarantee that writes which are available to the host domain are made 
							<em>
                                visible
							</em>
                            &nbsp;to host operations.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-dependency" >
    Memory Dependency
</h5>
<ul>
	<li>
		<p>
			<em>
                Memory Dependency
			</em>
            &nbsp;is an 
			<em>
                execution dependency
			</em>
            &nbsp;which includes 
			<em>
                availability
			</em>
            &nbsp;and 
			<em>
                visibility
			</em>
            &nbsp;operations such that:
		</p>
		<ul>
			<li>
				<p>
                    The first set of operations happens-before the 
					<em>
                        availability
					</em>
                    &nbsp;operation.
				</p>
			</li>
			<li>
				<p>
                    The availability operation happens-before the 
					<em>
                        visibility
					</em>
                    &nbsp;operation.
				</p>
			</li>
			<li>
				<p>
                    The visibility operation happens-before the second set of operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It enforces 
			<em>
                availability
			</em>
            &nbsp;and 
			<em>
                visibility
			</em>
            &nbsp;of memory accesses and 
			<em>
                execution order
			</em>
            &nbsp;between two sets of operations.
		</p>
	</li>
	<li>
		<p>
            Most synchronization commands in Vulkan define a memory dependency.
		</p>
	</li>
	<li>
		<p>
            The specific memory accesses that are made 
			<em>
                available
			</em>
            &nbsp;and 
			<em>
                visible
			</em>
            &nbsp;are defined by the 
			<em>
                access scopes
			</em>
            &nbsp;of a memory dependency.
		</p>
	</li>
	<li>
		<p>
            Any type of access that is in a memory dependency’s 
			<em>
                first access scope
			</em>
            &nbsp;is made 
			<em>
                available
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Any type of access that is in a memory dependency’s 
			<em>
                second access scope
			</em>
            &nbsp;has any available writes made 
			<em>
                visible
			</em>
            &nbsp;to it.
		</p>
	</li>
	<li>
		<p>
            Any type of operation that is not in a synchronization command’s access scopes will not be included in the resulting dependency.
		</p>
	</li>
</ul>
<h3
	id="execution-stages" >
    Execution Stages
</h3>
<ul>
	<li>
		<p>
            The Stage Masks are a bit-mask, so it’s perfectly fine to wait for both X and Y work.
		</p>
	</li>
	<li>
		<p>
            By specifying the source and target stages, you tell the driver what operations need to finish before the transition can execute, and what must not have started yet.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Use optimal 
            <code>srcStageMask</code>
            &nbsp;and 
            <code>dstStageMask</code>
            . Most important cases: If the specified resources are accessed only in compute or fragment shaders, use the compute or the fragment stage bits for both masks, to make the barrier fragment-only or compute-only.
		</p>
	</li>
	<li>
		<p>
            Caio: &quot;Wait for 
            <code>srcStageMask</code>
            &nbsp;to finish, before 
            <code>dstStageMask</code>
            &nbsp;can start&quot;.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929151911.png" width="459" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929142618.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929154614.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250929154642.png" width="600" >
            .
		</p>
	</li>
</ul>
<h5
	id="first-synchronization-scope" >
    First synchronization scope
</h5>
<ul>
	<li>
		<p>
            <code>srcStageMask</code>
		</p>
	</li>
	<li>
		<p>
            This represents what we are waiting for.
		</p>
	</li>
	<li>
		<p>
            &quot;What operations need to finish before the transition can execute&quot;.
		</p>
	</li>
</ul>
<h5
	id="second-synchronization-scope" >
    Second synchronization scope
</h5>
<ul>
	<li>
		<p>
            <code>dstStageMask</code>
		</p>
	</li>
	<li>
		<p>
            &quot;What operations must not have started yet&quot;.
		</p>
	</li>
	<li>
		<p>
            Any work submitted after this barrier will need to wait for the work represented by 
            <code>srcStageMask</code>
            &nbsp;before it can execute.
		</p>
	</li>
</ul>
<h5
	id="stages" >
    Stages
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlagBits2.html" 
				class="external-link" 
				target="_blank" >
                VkPipelineStageFlagBits2
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>TOP_OF_PIPE</code>
            &nbsp;and 
            <code>BOTTOM_OF_PIPE</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    These stages are essentially “helper” stages, which do no actual work, but serve some important purposes. Every command will first execute the 
                    <code>TOP_OF_PIPE</code>
                    &nbsp;stage. This is basically the command processor on the GPU parsing the command. 
                    <code>BOTTOM_OF_PIPE</code>
                    &nbsp;is where commands retire after all work has been done.
				</p>
			</li>
			<li>
				<p>
                    Both these pipeline stages are deprecated, and applications should prefer 
                    <code>ALL_COMMANDS</code>
                    &nbsp;and 
                    <code>NONE</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Memory Access
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Never use 
                            <code>AccessMask != 0</code>
                            &nbsp;with these stages. These stages 
							<strong>
                                do not perform memory accesses
							</strong>
                            . Any 
                            <code>srcAccessMask</code>
                            &nbsp;and 
                            <code>dstAccessMask</code>
                            &nbsp;combination with either stage will be meaningless, and spec disallows this.
						</p>
					</li>
					<li>
						<p>
                            <code>TOP_OF_PIPE</code>
                            &nbsp;and 
                            <code>BOTTOM_OF_PIPE</code>
                            &nbsp;are purely there for the sake of execution barriers, not memory barriers.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>TOP_OF_PIPE</code>
		</p>
		<ul>
			<li>
				<p>
                    In the first scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>NONE</code>
						</p>
					</li>
					<li>
						<p>
                            Is basically saying “wait for nothing”, or to be more precise, we’re waiting for the GPU to parse all commands.
						</p>
						<ul>
							<li>
								<p>
                                    We had to parse all commands before getting to the pipeline barrier command to begin with.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In the second scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>ALL_COMMANDS</code>
                            &nbsp;with 
                            <code>VkAccessFlags2</code>
                            &nbsp;set to 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>BOTTOM_OF_PIPE</code>
		</p>
		<ul>
			<li>
				<p>
                    In the first scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>ALL_COMMANDS</code>
                            , with 
                            <code>VkAccessFlags2</code>
                            &nbsp;set to 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In the second scope:
				</p>
				<ul>
					<li>
						<p>
                            Equivalent to 
                            <code>NONE</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Basically translates to “block the last stage of execution in the pipeline”.
						</p>
					</li>
					<li>
						<p>
                            “No work after this barrier is going to wait for us”.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>NONE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies no stages of execution.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>ALL_COMMANDS</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies all operations performed by all commands supported on the queue it is used with.
				</p>
			</li>
			<li>
				<p>
                    Basically drains the entire queue for work.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>ALL_GRAPHICS</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies the execution of all graphics pipeline stages.
				</p>
			</li>
			<li>
				<p>
                    It's the same as 
                    <code>ALL_COMMANDS</code>
                    , but only for render passes.
				</p>
			</li>
			<li>
				<p>
                    Is equivalent to the logical OR of:
				</p>
				<ul>
					<li>
						<p>
                            <code>DRAW_INDIRECT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>COPY_INDIRECT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TASK_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>MESH_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>VERTEX_INPUT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>VERTEX_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TESSELLATION_CONTROL_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TESSELLATION_EVALUATION_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>GEOMETRY_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>FRAGMENT_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>EARLY_FRAGMENT_TESTS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>LATE_FRAGMENT_TESTS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>COLOR_ATTACHMENT_OUTPUT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>CONDITIONAL_RENDERING</code>
						</p>
					</li>
					<li>
						<p>
                            <code>TRANSFORM_FEEDBACK</code>
						</p>
					</li>
					<li>
						<p>
                            <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
						</p>
					</li>
					<li>
						<p>
                            <code>FRAGMENT_DENSITY_PROCESS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>SUBPASS_SHADER</code>
						</p>
					</li>
					<li>
						<p>
                            <code>INVOCATION_MASK</code>
						</p>
					</li>
					<li>
						<p>
                            <code>CLUSTER_CULLING_SHADER</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="order-of-execution-stages" >
    Order of execution stages
</h5>
<ul>
	<li>
		<p>
            Ignoring 
            <code>TOP_OF_PIPE</code>
            &nbsp;and 
            <code>BOTTOM_OF_PIPE</code>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Graphics primitive pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
				<ul>
					<li>
						<p>
                            Parses indirect buffers.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>COPY_INDIRECT_BIT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>INDEX_INPUT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>VERTEX_ATTRIBUTE_INPUT</code>
				</p>
				<ul>
					<li>
						<p>
                            Consumes fixed function VBOs and IBOs
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VERTEX_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TESSELLATION_CONTROL_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TESSELLATION_EVALUATION_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>GEOMETRY_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TRANSFORM_FEEDBACK_BIT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>EARLY_FRAGMENT_TESTS</code>
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Early
							</em>
                            &nbsp;depth/stencil tests.
						</p>
					</li>
					<li>
						<p>
                            Render pass performs its 
                            <code>loadOp</code>
                            &nbsp;of a depth/stencil attachment.
						</p>
					</li>
					<li>
						<p>
                            This stage isn’t all that useful or meaningful except in some very obscure scenarios with frame buffer self-dependencies (aka, 
                            <code>GL_ARB_texture_barrier</code>
                            ).
						</p>
					</li>
					<li>
						<p>
                            When blocking a render pass with 
                            <code>dstStageMask</code>
                            , just use a mask of 
                            <code>EARLY_FRAGMENT_TESTS | LATE_FRAGMENT_TESTS</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>dstStageMask = EARLY_FRAGMENT_TESTS</code>
                            &nbsp;alone might work since that will block 
                            <code>loadOp</code>
                            , but there might be shenanigans with memory barriers if you are 100% pedantic about any memory access happening in 
                            <code>LATE_FRAGMENT_TESTS</code>
                            . If you’re blocking an early stage, it never hurts to block a later stage as well.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>LATE_FRAGMENT_TESTS</code>
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Late
							</em>
                            &nbsp;depth-stencil tests.
						</p>
					</li>
					<li>
						<p>
                            Render pass performs its 
                            <code>storeOp</code>
                            &nbsp;of a depth/stencil attachment when a render pass is done.
						</p>
					</li>
					<li>
						<p>
                            When you’re waiting for a depth map to have been rendered in an earlier render pass, you should use 
                            <code>srcStageMask = LATE_FRAGMENT_TESTS_BIT</code>
                            , as that will wait for the 
                            <code>storeOp</code>
                            &nbsp;to finish its work.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>COLOR_ATTACHMENT_OUTPUT</code>
				</p>
				<ul>
					<li>
						<p>
                            This one is where 
                            <code>loadOp</code>
                            , 
                            <code>storeOp</code>
                            , MSAA resolves and frame buffer blend stage takes place.
						</p>
					</li>
					<li>
						<p>
                            Basically anything that touches a color attachment in a render pass in some way.
						</p>
					</li>
					<li>
						<p>
                            If you’re waiting for a render pass which uses color to be complete, use 
                            <code>srcStageMask = COLOR_ATTACHMENT_OUTPUT</code>
                            , and similar for 
                            <code>dstStageMask</code>
                            &nbsp;when blocking render passes from execution.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Usage as 
                                <code>dstStageMask</code>
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <code>COLOR_ATTACHMENT_OUTPUT</code>
                                    &nbsp;is the appropriate 
                                    <code>dstStageMask</code>
                                    &nbsp;when you are transitioning an image so it can be written as a color attachment.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Graphics mesh pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TASK_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>MESH_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>EARLY_FRAGMENT_TESTS</code>
				</p>
			</li>
			<li>
				<p>
                    <code>FRAGMENT_SHADER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>LATE_FRAGMENT_TESTS</code>
				</p>
			</li>
			<li>
				<p>
                    <code>COLOR_ATTACHMENT_OUTPUT</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Compute pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>COPY_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>COMPUTE_SHADER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transfer pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>COPY_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>TRANSFER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Subpass shading pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>SUBPASS_SHADER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Graphics pipeline commands executing in a render pass with a fragment density map attachment
			</strong>
            : (almost unordered)
		</p>
		<ul>
			<li>
				<p>
                    The following pipeline stage where the fragment density map read happens has 
					<em>
                        no particular order
					</em>
                    &nbsp;relative to the other stages.
				</p>
			</li>
			<li>
				<p>
                    It is logically earlier than 
                    <code>EARLY_FRAGMENT_TESTS</code>
                    , so:
				</p>
				<ul>
					<li>
						<p>
                            <code>FRAGMENT_DENSITY_PROCESS</code>
						</p>
					</li>
					<li>
						<p>
                            <code>EARLY_FRAGMENT_TESTS</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Conditional rendering stage
			</strong>
            : (unordered)
		</p>
		<ul>
			<li>
				<p>
                    Is formally part of both the graphics, and the compute pipeline.
				</p>
			</li>
			<li>
				<p>
                    The predicate read has unspecified order relative to other stages of these pipelines:
				</p>
			</li>
			<li>
				<p>
                    <code>CONDITIONAL_RENDERING</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Host operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>HOST</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Command preprocessing pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>COMMAND_PREPROCESS</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Acceleration structure build operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>ACCELERATION_STRUCTURE_BUILD</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Acceleration structure copy operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>ACCELERATION_STRUCTURE_COPY</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Opacity micromap build operations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only one pipeline stage occurs.
				</p>
			</li>
			<li>
				<p>
                    <code>MICROMAP_BUILD</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ray tracing pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DRAW_INDIRECT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>RAY_TRACING_SHADER</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Video decode pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VIDEO_DECODE</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Video encode pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VIDEO_ENCODE</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Data graph pipeline
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DATA_GRAPH</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="memory-access" >
    Memory Access
</h3>
<ul>
	<li>
		<p>
			<em>
                Access scopes
			</em>
            &nbsp;do not interact with the logically earlier or later stages for either scope - only the stages the application specifies are considered part of each access scope.
		</p>
	</li>
	<li>
		<p>
            These flags represent memory access that can be performed.
		</p>
	</li>
	<li>
		<p>
            Each pipeline stage can perform certain memory accesses, and thus we take the combination of pipeline stage + access mask and we get potentially a very large number of incoherent caches on the system.
		</p>
	</li>
	<li>
		<p>
            Each GPU core has its own set of L1 caches as well.
		</p>
	</li>
	<li>
		<p>
            Real GPUs will only have a fraction of the possible caches here, but as long as we are explicit about this in the API, any GPU driver can simplify this as needed.
		</p>
	</li>
	<li>
		<p>
            Access masks either read from a cache, or write to an L1 cache in our mental model.
		</p>
	</li>
	<li>
		<p>
            Certain access types are only performed by a subset of pipeline stages.
		</p>
	</li>
	<li>
		<p>
            &quot;Had this access (
            <code>srcAccessMask</code>
            ) and it's going to have this access (
            <code>dstAccessMask</code>
            )&quot;.
		</p>
	</li>
	<li>
		<p>
            <code>srcAccessMask</code>
		</p>
		<ul>
			<li>
				<p>
                    Lists the access types that happened 
					<em>
                        before
					</em>
                    &nbsp;the barrier (the producer accesses) and that must be made available/visible by the barrier.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Must describe the kinds of accesses that actually happened before the barrier (the producer accesses you need to make available/visible)
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    It does 
					<em>
                        not
					</em>
                    &nbsp;describe what you want the resource to become after the barrier — that is expressed by 
                    <code>dstAccessMask</code>
                    &nbsp;(what will happen after).
				</p>
			</li>
			<li>
				<p>
                    The stage masks (src/dst stage) specify the pipeline stages that contain those accesses.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        <code>srcAccessMask = 0</code>
					</strong>
                    &nbsp;means “there are no prior GPU memory accesses that this barrier needs to make available” (i.e. nothing to claim as the producer side).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>dstAccessMask</code>
		</p>
		<ul>
			<li>
				<p>
                    Lists the access types that will happen 
					<em>
                        after
					</em>
                    &nbsp;the barrier (the consumer accesses) and that must see the producer’s writes.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        <code>dstAccessMask = 0</code>
					</strong>
                    &nbsp;means “there are no subsequent GPU memory accesses that this barrier needs to order/make visible to” (i.e. no GPU consumer to describe with access bits).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="access-flags" >
    Access Flags
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlagBits2.html" 
				class="external-link" 
				target="_blank" >
                <code>VkAccessFlagBits2</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>MEMORY_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies all read accesses.
				</p>
			</li>
			<li>
				<p>
                    It is always valid in any access mask, and is treated as equivalent to setting all 
                    <code>READ</code>
                    &nbsp;access flags that are valid where it is used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>MEMORY_WRITE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies all write accesses.
				</p>
			</li>
			<li>
				<p>
                    It is always valid in any access mask, and is treated as equivalent to setting all 
                    <code>WRITE</code>
                    &nbsp;access flags that are valid where it is used.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>SHADER_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Same as 
                    <code>SAMPLED_READ</code>
                    &nbsp;+ 
                    <code>STORAGE_READ</code>
                    &nbsp;+ 
                    <code>TILE_ATTACHMENT_READ</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>SHADER_SAMPLED_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies read access to a 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-uniformtexelbuffer" 
						class="external-link" 
						target="_blank" >
                        uniform texel buffer
					</a>
                    &nbsp;or 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-sampledimage" 
						class="external-link" 
						target="_blank" >
                        sampled image
					</a>
                    &nbsp;in any shader pipeline stage.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>HOST_READ</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies read access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.
				</p>
			</li>
			<li>
				<p>
                    Such access occurs in the 
                    <code>PIPELINE_STAGE_2_HOST</code>
                    &nbsp;pipeline stage.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>HOST_WRITE</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies write access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.
				</p>
			</li>
			<li>
				<p>
                    Such access occurs in the 
                    <code>PIPELINE_STAGE_2_HOST</code>
                    &nbsp;pipeline stage.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="access-flag-gt-pipeline-stages" >
    Access Flag -&gt; Pipeline Stages
</h5>
<p
	class="table" >
    | Access flag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Pipeline stages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    |-----------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    <br>
    | 
    <code>NONE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Any&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INDIRECT_COMMAND_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DRAW_INDIRECT</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>COPY_INDIRECT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INDEX_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_INPUT</code>
    , 
    <code>INDEX_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>VERTEX_ATTRIBUTE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_INPUT</code>
    , 
    <code>VERTEX_ATTRIBUTE_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INPUT_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>SHADER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>MICROMAP_BUILD</code>
    , 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COLOR_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COLOR_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>EARLY_FRAGMENT_TESTS</code>
    , 
    <code>LATE_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DEPTH_STENCIL_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>EARLY_FRAGMENT_TESTS</code>
    , 
    <code>LATE_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ALL_TRANSFER</code>
    , 
    <code>COPY</code>
    , 
    <code>RESOLVE</code>
    , 
    <code>BLIT</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    , 
    <code>MICROMAP_BUILD</code>
    , 
    <code>CONVERT_COOPERATIVE_VECTOR_MATRIX</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ALL_TRANSFER</code>
    , 
    <code>COPY</code>
    , 
    <code>RESOLVE</code>
    , 
    <code>BLIT</code>
    , 
    <code>CLEAR</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    , 
    <code>MICROMAP_BUILD</code>
    , 
    <code>CONVERT_COOPERATIVE_VECTOR_MATRIX</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>HOST_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>HOST</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>HOST_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>HOST</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MEMORY_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Any&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MEMORY_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Any&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_SAMPLED_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_STORAGE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_STORAGE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_DECODE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VIDEO_DECODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_DECODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_DECODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_ENCODE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VIDEO_ENCODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_ENCODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_ENCODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>TRANSFORM_FEEDBACK_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>TRANSFORM_FEEDBACK_COUNTER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DRAW_INDIRECT</code>
    , 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFORM_FEEDBACK_COUNTER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>CONDITIONAL_RENDERING_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>CONDITIONAL_RENDERING</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>COMMAND_PREPROCESS_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>COMMAND_PREPROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COMMAND_PREPROCESS_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>COMMAND_PREPROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT_READ</code>
    &nbsp;| 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    , 
    <code>SUBPASS_SHADER</code>
    &nbsp;|
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>FRAGMENT_DENSITY_MAP_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_DENSITY_PROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COLOR_ATTACHMENT_READ_NONCOHERENT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>DESCRIPTOR_BUFFER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_SHADER</code>
    , 
    <code>TESSELLATION_CONTROL_SHADER</code>
    , 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    , 
    <code>GEOMETRY_SHADER</code>
    , 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    , 
    <code>RAY_TRACING_SHADER</code>
    , 
    <code>TASK_SHADER</code>
    , 
    <code>MESH_SHADER</code>
    , 
    <code>SUBPASS_SHADER</code>
    , 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INVOCATION_MASK_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>INVOCATION_MASK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>MICROMAP_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>MICROMAP_BUILD</code>
    , 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MICROMAP_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>MICROMAP_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>OPTICAL_FLOW_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>OPTICAL_FLOW</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>OPTICAL_FLOW_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>OPTICAL_FLOW</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SHADER_TILE_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>SHADER_TILE_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>FRAGMENT_SHADER</code>
    , 
    <code>COMPUTE_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>DATA_GRAPH_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DATA_GRAPH</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DATA_GRAPH_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>DATA_GRAPH</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<h5
	id="pipeline-stage-gt-access-flags" >
    Pipeline Stage -&gt; Access Flags
</h5>
<p
	class="table" >
    | Pipeline stage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Access flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>ACCELERATION_STRUCTURE_WRITE</code>
    , 
    <code>INDIRECT_COMMAND_READ</code>
    , 
    <code>MICROMAP_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>ACCELERATION_STRUCTURE_COPY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>ACCELERATION_STRUCTURE_WRITE</code>
    , 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>ALL_TRANSFER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>ANY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>MEMORY_READ</code>
    , 
    <code>MEMORY_WRITE</code>
    , 
    <code>NONE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>BLIT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>CLEAR</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>CLUSTER_CULLING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>COLOR_ATTACHMENT_OUTPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>COLOR_ATTACHMENT_READ</code>
    , 
    <code>COLOR_ATTACHMENT_READ_NONCOHERENT</code>
    , 
    <code>COLOR_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>COMMAND_PREPROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>COMMAND_PREPROCESS_READ</code>
    , 
    <code>COMMAND_PREPROCESS_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COMPUTE_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_READ</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>CONDITIONAL_RENDERING</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>CONDITIONAL_RENDERING_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>CONVERT_COOPERATIVE_VECTOR_MATRIX</code>
    &nbsp;| 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COPY</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>COPY_INDIRECT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INDIRECT_COMMAND_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DATA_GRAPH</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>DATA_GRAPH_READ</code>
    , 
    <code>DATA_GRAPH_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>DRAW_INDIRECT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INDIRECT_COMMAND_READ</code>
    , 
    <code>TRANSFORM_FEEDBACK_COUNTER_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>EARLY_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    , 
    <code>DEPTH_STENCIL_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>FRAGMENT_DENSITY_PROCESS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>FRAGMENT_DENSITY_MAP_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>FRAGMENT_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>COLOR_ATTACHMENT_READ</code>
    , 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>INPUT_ATTACHMENT_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_READ</code>
    , 
    <code>SHADER_TILE_ATTACHMENT_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;|
    <br>
    | 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT</code>
    &nbsp; | 
    <code>FRAGMENT_SHADING_RATE_ATTACHMENT_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>GEOMETRY_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>HOST</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>HOST_READ</code>
    , 
    <code>HOST_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>INDEX_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INDEX_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>INVOCATION_MASK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>INVOCATION_MASK_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>LATE_FRAGMENT_TESTS</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>DEPTH_STENCIL_ATTACHMENT_READ</code>
    , 
    <code>DEPTH_STENCIL_ATTACHMENT_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>MESH_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>MICROMAP_BUILD</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>MICROMAP_READ</code>
    , 
    <code>MICROMAP_WRITE</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>OPTICAL_FLOW</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>OPTICAL_FLOW_READ</code>
    , 
    <code>OPTICAL_FLOW_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>RAY_TRACING_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>RESOLVE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>TRANSFER_READ</code>
    , 
    <code>TRANSFER_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>SUBPASS_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>INPUT_ATTACHMENT_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>TASK_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TESSELLATION_CONTROL_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TESSELLATION_EVALUATION_SHADER</code>
    &nbsp;&nbsp;&nbsp; | 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>TRANSFORM_FEEDBACK</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>TRANSFORM_FEEDBACK_COUNTER_READ</code>
    , 
    <code>TRANSFORM_FEEDBACK_COUNTER_WRITE</code>
    , 
    <code>TRANSFORM_FEEDBACK_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VERTEX_ATTRIBUTE_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VERTEX_ATTRIBUTE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VERTEX_INPUT</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>INDEX_READ</code>
    , 
    <code>VERTEX_ATTRIBUTE_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VERTEX_SHADER</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>ACCELERATION_STRUCTURE_READ</code>
    , 
    <code>DESCRIPTOR_BUFFER_READ</code>
    , 
    <code>SHADER_READ</code>
    , 
    <code>SHADER_SAMPLED_READ</code>
    , 
    <code>SHADER_STORAGE_READ</code>
    , 
    <code>SHADER_STORAGE_WRITE</code>
    , 
    <code>SHADER_WRITE</code>
    , 
    <code>UNIFORM_READ</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
    <br>
    | 
    <code>VIDEO_DECODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_DECODE_READ</code>
    , 
    <code>VIDEO_DECODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | 
    <code>VIDEO_ENCODE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>VIDEO_ENCODE_READ</code>
    , 
    <code>VIDEO_ENCODE_WRITE</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<h3
	id="pipeline-barriers" >
    Pipeline Barriers
</h3>
<ul>
	<li>
		<p>
            Pipeline barriers also provide synchronization control within a command buffer, but at a single point, rather than with separate signal and wait operations. Pipeline barriers 
			<strong>
                can
			</strong>
            &nbsp;be used to control resource access within a single queue.
		</p>
	</li>
	<li>
		<p>
            Gives control over which pipeline stages need to wait on previous pipeline stages when a command buffer is executed.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Minimize the use of barriers. A barrier may cause a GPU pipeline flush. We have seen redundant barriers and associated wait for idle operations as a major performance problem for ports to modern APIs.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Prefer a buffer/image barrier rather than a memory barrier to allow the driver to better optimize and schedule the barrier, unless the memory barrier allows to merge many buffer/image barriers together.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Group barriers in one call to 
            <code>vkCmdPipelineBarrier2()</code>
            . This way, the worst case can be picked instead of sequentially going through all barriers.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Don’t insert redundant barriers; this limits parallelism; avoid read-to-read barriers.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdPipelineBarrier2()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    When submitted to a queue, it defines memory dependencies between commands that were submitted to the same queue 
					<em>
                        before
					</em>
                    &nbsp;it, and those submitted to the same queue 
					<em>
                        after
					</em>
                    &nbsp;it.
				</p>
			</li>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the command buffer into which the command is recorded.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDependencyInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDependencyInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Specifies the dependency information for a synchronization command.
						</p>
					</li>
					<li>
						<p>
                            This structure defines a set of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
								class="external-link" 
								target="_blank" >
                                memory dependencies
							</a>
                            , as well as 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
								class="external-link" 
								target="_blank" >
                                queue family ownership transfer operations
							</a>
                            &nbsp;and 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-image-layout-transitions" 
								class="external-link" 
								target="_blank" >
                                image layout transitions
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Each member of 
                            <code>pMemoryBarriers</code>
                            , 
                            <code>pBufferMemoryBarriers</code>
                            , and 
                            <code>pImageMemoryBarriers</code>
                            &nbsp;defines a separate 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
								class="external-link" 
								target="_blank" >
                                memory dependency
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>dependencyFlags</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkDependencyFlagBits</code>
									</a>
								</p>
							</li>
							<li>
								<p>
                                    Specifies how execution and memory dependencies are formed.
								</p>
							</li>
							<li>
								<p>
                                    <code>VK_DEPENDENCY_BY_REGION_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that dependencies will be 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-framebuffer-regions" 
												class="external-link" 
												target="_blank" >
                                                framebuffer-local
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_DEPENDENCY_VIEW_LOCAL_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that dependencies will be 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-view-local-dependencies" 
												class="external-link" 
												target="_blank" >
                                                view-local
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_DEPENDENCY_DEVICE_GROUP_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that dependencies are 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-device-local-dependencies" 
												class="external-link" 
												target="_blank" >
                                                non-device-local
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that the render pass will write to and read from the same image with 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-feedbackloop" 
												class="external-link" 
												target="_blank" >
                                                feedback loop enabled
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that source and destination stages are not ignored when performing a 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
												class="external-link" 
												target="_blank" >
                                                queue family ownership transfer
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2.html" 
												class="external-link" 
												target="_blank" >
                                                vkCmdSetEvent2
											</a>
                                            &nbsp;
											<strong>
                                                must
											</strong>
                                            &nbsp;only include the 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-pipeline-stages-masks" 
												class="external-link" 
												target="_blank" >
                                                source stage mask
											</a>
                                            &nbsp;of the first synchronization scope, and that 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2.html" 
												class="external-link" 
												target="_blank" >
                                                vkCmdWaitEvents2
											</a>
                                            &nbsp;
											<strong>
                                                must
											</strong>
                                            &nbsp;specify the complete barrier.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryBarrierCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pMemoryBarriers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pMemoryBarriers</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrier2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkMemoryBarrier2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies a global memory barrier.
								</p>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstAccessMask</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>bufferMemoryBarrierCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pBufferMemoryBarriers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pBufferMemoryBarriers</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferMemoryBarrier2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkBufferMemoryBarrier2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies a buffer memory barrier.
								</p>
							</li>
							<li>
								<p>
                                    Defines a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
										class="external-link" 
										target="_blank" >
                                        memory dependency
									</a>
                                    &nbsp;limited to a range of a buffer, and 
									<strong>
                                        can
									</strong>
                                    &nbsp;define a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
										class="external-link" 
										target="_blank" >
                                        queue family ownership transfer operation
									</a>
                                    &nbsp;for that range.
								</p>
							</li>
							<li>
								<p>
                                    Both 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-access-scopes" 
										class="external-link" 
										target="_blank" >
                                        access scopes
									</a>
                                    &nbsp;are limited to only memory accesses to 
                                    <code>buffer</code>
                                    &nbsp;in the range defined by 
                                    <code>offset</code>
                                    &nbsp;and 
                                    <code>size</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>buffer</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a handle to the buffer whose backing memory is affected by the barrier.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>offset</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is an offset in bytes into the backing memory for 
                                            <code>buffer</code>
                                            ; this is relative to the base offset as bound to the buffer (see 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory.html" 
												class="external-link" 
												target="_blank" >
                                                vkBindBufferMemory
											</a>
                                            ).
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>size</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a size in bytes of the affected area of backing memory for 
                                            <code>buffer</code>
                                            , or 
                                            <code>VK_WHOLE_SIZE</code>
                                            &nbsp;to use the range from 
                                            <code>offset</code>
                                            &nbsp;to the end of the buffer.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>imageMemoryBarrierCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pImageMemoryBarriers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pImageMemoryBarriers</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkImageMemoryBarrier2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies an image memory barrier.
								</p>
							</li>
							<li>
								<p>
                                    Defines a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-dependencies-memory" 
										class="external-link" 
										target="_blank" >
                                        memory dependency
									</a>
                                    &nbsp;limited to an image subresource range, and 
									<strong>
                                        can
									</strong>
                                    &nbsp;define a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
										class="external-link" 
										target="_blank" >
                                        queue family ownership transfer operation
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-image-layout-transitions" 
										class="external-link" 
										target="_blank" >
                                        image layout transition
									</a>
                                    &nbsp;for that subresource range.
								</p>
							</li>
							<li>
								<p>
									<strong>
                                        Image Transition
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If 
                                            <code>oldLayout</code>
                                            &nbsp;is not equal to 
                                            <code>newLayout</code>
                                            , then the memory barrier defines an image layout transition for the specified image subresource range.
										</p>
									</li>
									<li>
										<p>
                                            If this memory barrier defines a 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers" 
												class="external-link" 
												target="_blank" >
                                                queue family ownership transfer operation
											</a>
                                            , the layout transition is only executed once between the queues.
										</p>
									</li>
									<li>
										<p>
                                            When the old and new layout are equal, the layout values are ignored - data is preserved no matter what values are specified, or what layout the image is currently in.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>srcStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstStageMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstAccessMask</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>srcQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>dstQueueFamilyIndex</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>oldLayout</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>newLayout</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>image</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a handle to the image affected by this barrier.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>subresourceRange</code>
								</p>
								<ul>
									<li>
										<p>
                                            Describes the 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-image-views" 
												class="external-link" 
												target="_blank" >
                                                image subresource range
											</a>
                                            &nbsp;within 
                                            <code>image</code>
                                            &nbsp;that is affected by this barrier.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="execution-barrier" >
    Execution Barrier
</h4>
<ul>
	<li>
		<p>
            Every command you submit to Vulkan goes through a set of stages. Draw calls, copy commands and compute dispatches all go through pipeline stages one by one. This represents the heart of the Vulkan synchronization model.
		</p>
	</li>
	<li>
		<p>
            Operations performed by synchronization commands (e.g. 
			<em>
                availability operations
			</em>
            &nbsp;and 
			<em>
                visibility operations
			</em>
            ) are not executed by a defined pipeline stage. However other commands can still synchronize with them by using the synchronization scopes to create a dependency chain.
		</p>
	</li>
	<li>
		<p>
            When we synchronize work in Vulkan, we synchronize work happening in these pipeline stages as a whole, and not individual commands of work.
		</p>
	</li>
	<li>
		<p>
            Vulkan does not let you add fine-grained dependencies between individual commands. Instead you get to look at all work which happens in certain pipeline stages.
		</p>
	</li>
</ul>
<h4
	id="memory-barriers" >
    Memory Barriers
</h4>
<ul>
	<li>
		<p>
            Execution order and memory order are two different things.
		</p>
	</li>
	<li>
		<p>
            Memory barriers are the tools we can use to ensure that caches are flushed and our memory writes from commands executed before the barrier are available to the pending after-barrier commands. They are also the tool we can use to invalidate caches so that the latest data is visible to the cores that will execute after-barrier commands.
		</p>
	</li>
	<li>
		<p>
            In contrast to execution barriers, these access masks only apply to the precise stages set in the stage masks, and are not extended to logically earlier and later stages.
		</p>
	</li>
	<li>
		<p>
            GPUs are notorious for having multiple, incoherent caches which all need to be carefully managed to avoid glitched out rendering.
		</p>
	</li>
	<li>
		<p>
            This means that just synchronizing execution alone is not enough to ensure that different units on the GPU can transfer data between themselves.
		</p>
	</li>
	<li>
		<p>
            Memory being 
			<strong>
                available
			</strong>
            &nbsp;and memory being 
			<strong>
                visible
			</strong>
            &nbsp;are an abstraction over the fact that GPUs have incoherent caches.
		</p>
	</li>
	<li>
		<p>
            For GPU reading operations from CPU-written data, a call to 
            <code>vkQueueSubmit</code>
            &nbsp;acts as a host memory dependency on any CPU writes to GPU-accessible memory, so long as those writes were made 
			<em>
                prior
			</em>
            &nbsp;to the function call.
		</p>
	</li>
	<li>
		<p>
            If you need more fine-grained write dependency (you want the GPU to be able to execute some stuff in a batch while you're writing data, for example), or if you need to read data written by the GPU, you need an explicit dependency.
		</p>
	</li>
	<li>
		<p>
            For in-batch GPU reading, this could be handled by an event; the host sets the event after writing the memory, and the command buffer operation that reads the memory first issues 
            <code>vkCmdWaitEvents</code>
            &nbsp;for that event. And you'll need to set the appropriate memory barriers and source/destination stages.
		</p>
	</li>
	<li>
		<p>
            For CPU reading of GPU-written data, this could be an event, a timeline semaphore, or a fence.
		</p>
	</li>
	<li>
		<p>
            But overall, CPU writes to GPU-accessible memory still need some form of synchronization.
		</p>
	</li>
</ul>
<h4
	id="global-memory-barriers" >
    Global Memory Barriers
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrier2.html" 
				class="external-link" 
				target="_blank" >
                <code>VkMemoryBarrier2</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            A global memory barrier deals with access to any resource, and it’s the simplest form of a memory barrier.
		</p>
	</li>
	<li>
		<p>
            In 
            <code>vkCmdPipelineBarrier2</code>
            , we are specifying 4 things to happen in order:
		</p>
		<ul>
			<li>
				<p>
                    Wait for 
                    <code>srcStageMask</code>
                    &nbsp;to complete
				</p>
			</li>
			<li>
				<p>
                    Make all writes performed in possible combinations of 
                    <code>srcStageMask</code>
                    &nbsp;+ 
                    <code>srcAccessMask</code>
                    &nbsp;
					<strong>
                        available
					</strong>
				</p>
			</li>
			<li>
				<p>
                    Make 
					<strong>
                        available
					</strong>
                    &nbsp;memory 
					<strong>
                        visible
					</strong>
                    &nbsp;to possible combinations of 
                    <code>dstStageMask</code>
                    &nbsp;+ 
                    <code>dstAccessMask</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Unblock work in dstStageMask.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A common misconception I see is that 
            <code>_READ</code>
            &nbsp;flags are passed into 
            <code>srcAccessMask</code>
            , but this is 
			<em>
                redundant
			</em>
            .
		</p>
		<ul>
			<li>
				<p>
                    It does not make sense to make reads available.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Ex
					</strong>
                    : you don’t flush caches when you’re done reading data.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="buffer-memory-barrier" >
    Buffer Memory Barrier
</h4>
<ul>
	<li>
		<p>
            We’re just restricting memory availability and visibility to a specific buffer.
		</p>
	</li>
	<li>
		<p>
            TheMaister: No GPU I know of actually cares, I think it makes more sense to just use VkMemoryBarrier rather than bothering with buffer barriers.
		</p>
	</li>
</ul>
<h4
	id="image-memory-barrier-image-layout-transition" >
    Image Memory Barrier / Image Layout Transition
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageLayout.html" 
				class="external-link" 
				target="_blank" >
                <code>VkImageLayout</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Image subresources can be transitioned from one layout to another as part of a 
			<em>
                memory dependency
			</em>
            &nbsp;(e.g. by using an 
			<em>
                image memory barrier
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
            Image layouts transitions are done as part of an image memory barrier.
		</p>
	</li>
	<li>
		<p>
            The layout transition happens in-between the 
			<strong>
                make available
			</strong>
            &nbsp;and 
			<strong>
                make visible
			</strong>
            &nbsp;stages of a memory barrier.
		</p>
	</li>
	<li>
		<p>
            The layout transition itself is considered a read/write operation, and the rules are basically that memory for the image must be 
			<strong>
                available
			</strong>
            &nbsp;before the layout transition takes place.
		</p>
	</li>
	<li>
		<p>
            After a layout transition, that memory is automatically made 
			<strong>
                available
			</strong>
            &nbsp;(but not 
			<strong>
                visible
			</strong>
            !).
		</p>
	</li>
	<li>
		<p>
            Basically, think of the layout transition as some kind of in-place data munging which happens in L2 cache somehow.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If a layout transition is specified in a memory dependency.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                When
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It happens-after the 
					<em>
                        availability
					</em>
                    &nbsp;operations in the memory dependency, and happens-before the 
					<em>
                        visibility
					</em>
                    &nbsp;operations.
				</p>
			</li>
			<li>
				<p>
                    Layout transitions that are performed via image memory barriers execute in their entirety in 
					<em>
                        submission order
					</em>
                    , relative to other image layout transitions submitted to the same queue, including those performed by render passes.
				</p>
			</li>
			<li>
				<p>
                    This ordering of image layout transitions only applies if the implementation performs actual read/write operations during the transition.
				</p>
			</li>
			<li>
				<p>
                    An application 
					<strong>
                        must
					</strong>
                    &nbsp;not rely on ordering of image layout transitions to influence ordering of other commands.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ensure
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Image layout transitions may perform read and write accesses on all memory bound to the image subresource range, so applications 
					<strong>
                        must
					</strong>
                    &nbsp;ensure that all memory writes have been made 
					<em>
                        available
					</em>
                    &nbsp;before a layout transition is executed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Available
			</em>
            &nbsp;memory is automatically made 
			<em>
                visible
			</em>
            &nbsp;to a layout transition, and writes performed by a layout transition are automatically made 
			<em>
                available
			</em>
            .
		</p>
	</li>
</ul>
<h5
	id="old-layout" >
    Old Layout
</h5>
<ul>
	<li>
		<p>
            The old layout 
			<strong>
                must
			</strong>
            &nbsp;either be 
            <code>UNDEFINED</code>
            , or match the current layout of the image subresource range.
		</p>
		<ul>
			<li>
				<p>
                    If the old layout matches the current layout of the image subresource range, the transition preserves the contents of that range.
				</p>
			</li>
			<li>
				<p>
                    If the old layout is 
                    <code>UNDEFINED</code>
                    , the contents of that range 
					<strong>
                        may
					</strong>
                    &nbsp;be discarded. This can provide performance or power benefits.
				</p>
				<ul>
					<li>
						<p>
                            Nvidia: Use 
                            <code>UNDEFINED</code>
                            &nbsp;when the previous content of the image is not needed.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tile-based architectures may be able to avoid flushing tile data to memory, and immediate style renderers may be able to achieve fast metadata clears to reinitialize frame buffer compression state, or similar.
		</p>
	</li>
	<li>
		<p>
            If the contents of an attachment are not needed after a render pass completes, then applications 
			<strong>
                should
			</strong>
            &nbsp;use 
            <code>DONT_CARE</code>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=RPKu3U9uDF4" 
				class="external-link" 
				target="_blank" >
                Why Need the Old Layout in Vulkan Image Transitions
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Cool.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="recently-allocated-image" >
    Recently allocated image
</h5>
<ul>
	<li>
		<p>
            If we just allocated an image and want to start using it, what we want to do is to just perform a layout transition, but we don’t need to wait for anything in order to do this transition.
		</p>
	</li>
	<li>
		<p>
            It’s important to note that freshly allocated memory in Vulkan is always considered 
			<strong>
                available
			</strong>
            &nbsp;and 
			<strong>
                visible
			</strong>
            &nbsp;to all stages and access types. You cannot have stale caches when the memory was never accessed.
		</p>
	</li>
</ul>
<h3
	id="events-quotsplit-barriersquot" >
    Events / &quot;Split Barriers&quot;
</h3>
<ul>
	<li>
		<p>
            A way to get overlapping work in-between barriers.
		</p>
	</li>
	<li>
		<p>
            The idea of 
            <code>VkEvent</code>
            &nbsp;is to get some unrelated commands in-between the “before” and “after” set of commands
		</p>
	</li>
	<li>
		<p>
            For advanced compute, this is a very important thing to know about, but not all GPUs and drivers can take advantage of this feature.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Use 
            <code>vkCmdSetEvent2</code>
            &nbsp;and 
            <code>vkCmdWaitEvents2</code>
            &nbsp;to issue an asynchronous barrier to avoid blocking execution.
		</p>
	</li>
</ul>
<h5
	id="example" >
    Example
</h5>
<ul>
	<li>
		<p>
			<strong>
                Example 1
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdSetEvent(event, srcStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdWaitEvent(event, dstStageMask = COMPUTE)</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
			<li>
				<p>
                    <code>vkCmdDispatch</code>
				</p>
			</li>
		</ol>
		<ul>
			<li>
				<p>
                    The &quot;
					<em>
                        before
					</em>
                    &quot; set is now {
                    <code>1</code>
                    , 
                    <code>2</code>
                    }, and the &quot;
					<em>
                        after
					</em>
                    &quot; set is {
                    <code>6</code>
                    , 
                    <code>7</code>
                    }.
				</p>
			</li>
			<li>
				<p>
                    <code>4</code>
                    &nbsp;here is not affected by any synchronization and it can fill in the parallelism “bubble” we get when draining the GPU of work from 
                    <code>1</code>
                    , 
                    <code>2</code>
                    , 
                    <code>3</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250930091327.png" width="461" >
            .
		</p>
	</li>
</ul>
<h3
	id="semaphores-and-fences" >
    Semaphores and Fences
</h3>
<ul>
	<li>
		<p>
            These objects are signaled as part of a 
            <code>vkQueueSubmit</code>
            .
		</p>
	</li>
	<li>
		<p>
            To signal a semaphore or fence, all previously submitted commands to the queue must complete.
		</p>
	</li>
	<li>
		<p>
            If this were a regular pipeline barrier, we would have 
            <code>srcStageMask = ALL_COMMANDS_BIT</code>
            . However, 
			<strong>
                we also get a full memory barrier, in the sense that all pending writes are made available.
			</strong>
            &nbsp;Essentially, 
            <code>srcAccessMask = MEMORY_WRITE_BIT</code>
            .
		</p>
	</li>
	<li>
		<p>
            Signaling a fence or semaphore works like a full cache flush. Submitting commands to the Vulkan queue makes all memory access performed by host visible to all stages and access masks. Basically, submitting a batch issues a cache invalidation on host visible memory.
		</p>
	</li>
	<li>
		<p>
            A common mistake is to think that you need to do this invalidation manually when the CPU is writing into staging buffers or similar:
		</p>
		<ul>
			<li>
				<p>
                    <code>srcStageMask = HOST</code>
				</p>
			</li>
			<li>
				<p>
                    <code>dstStageMask = TRANSFER</code>
				</p>
			</li>
			<li>
				<p>
                    <code>srcAccessMask = HOST_WRITE_BIT</code>
				</p>
			</li>
			<li>
				<p>
                    <code>dstAccessMask = TRANSFER_READ</code>
				</p>
			</li>
			<li>
				<p>
                    If the write happened before 
                    <code>vkQueueSubmit</code>
                    , this is automatically done for you.
				</p>
			</li>
			<li>
				<p>
                    This kind of barrier is necessary if you are using 
                    <code>vkCmdWaitEvents</code>
                    &nbsp;where you wait for host to signal the event with 
                    <code>vkSetEvent</code>
                    . In that case, you might be writing the necessary host data 
					<strong>
                        after
					</strong>
                    &nbsp;
                    <code>vkQueueSubmit</code>
                    &nbsp;was called, which means you need a pipeline barrier like this. This is not exactly a common use case, but it’s important to understand when these API constructs are useful.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="semaphore" >
    Semaphore
</h5>
<ul>
	<li>
		<p>
            <code>VkSemaphore</code>
		</p>
	</li>
	<li>
		<p>
            Semaphores facilitate GPU &lt;-&gt; GPU synchronization across Vulkan queues.
		</p>
		<ul>
			<li>
				<p>
                    Used for syncing multiple command buffer submissions one after other.
				</p>
			</li>
			<li>
				<p>
                    The CPU continues running without blocking.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Implicit memory guarantees when waiting for a Semaphore
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    While signalling a semaphore makes all memory 
					<strong>
                        available
					</strong>
                    , waiting for a semaphore makes memory 
					<strong>
                        visible
					</strong>
                    .
				</p>
			</li>
			<li>
				<p>
                    This basically means you do not need a memory barrier if you use synchronization with semaphores since signal/wait pairs of semaphores works like a full memory barrier.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Example
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Queue 1 writes to an SSBO in compute, and consumes that buffer as a UBO in a fragment shader in queue 2.
						</p>
					</li>
					<li>
						<p>
                            We’re going to assume the buffer was created with 
                            <code>QUEUE_FAMILY_CONCURRENT</code>
                            .
						</p>
					</li>
					<li>
						<p>
							<em>
                                Queue 1
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    <code>vkCmdDispatch</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkQueueSubmit(signal = my_semaphore)</code>
								</p>
							</li>
							<li>
								<p>
                                    There is no pipeline barrier needed here.
								</p>
							</li>
							<li>
								<p>
                                    Signalling the semaphore waits for all commands, and all writes in the dispatch are made 
									<strong>
                                        available
									</strong>
                                    &nbsp;to the device before the semaphore is actually signaled.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Queue 2
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    <code>vkCmdBeginRenderPass</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkCmdDraw</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkCmdEndRenderPass</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vkQueueSubmit(wait = my_semaphore, pDstWaitStageMask = FRAGMENT_SHADER)</code>
								</p>
							</li>
							<li>
								<p>
                                    When we wait for the semaphore, we specify which stages should wait for this semaphore, in this case the 
                                    <code>FRAGMENT_SHADER</code>
                                    &nbsp;stage.
								</p>
							</li>
							<li>
								<p>
                                    All relevant memory access is automatically made 
									<strong>
                                        visible
									</strong>
                                    , so we can safely access 
                                    <code>UNIFORM_READ_BIT</code>
                                    &nbsp;in 
                                    <code>FRAGMENT_SHADER</code>
                                    &nbsp;stage, without having extra barriers.
								</p>
							</li>
							<li>
								<p>
                                    The semaphores take care of this automatically, nice!
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Basic signaling / waiting
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Let’s say we have semaphore S and queue operations A and B that we want to execute in order.
						</p>
					</li>
					<li>
						<p>
                            What we tell Vulkan is that operation A will 'signal' semaphore S when it finishes executing, and operation B will 'wait' on semaphore S before it begins executing.
						</p>
					</li>
					<li>
						<p>
                            When operation A finishes, semaphore S will be signaled, while operation B wont start until S is signaled.
						</p>
					</li>
					<li>
						<p>
                            After operation B begins executing, semaphore S is automatically reset back to being unsignaled, allowing it to be used again.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Image Transition on Swapchain Images
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            We need to wait for the image to be acquired, and only then can we perform a layout transition.
						</p>
					</li>
					<li>
						<p>
                            The best way to do this is to use 
                            <code>pDstWaitStageMask = COLOR_ATTACHMENT_OUTPUT_BIT</code>
                            , and then use 
                            <code>srcStageMask = COLOR_ATTACHMENT_OUTPUT_BIT</code>
                            &nbsp;in a pipeline barrier which transitions the swapchain image after semaphore is signaled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Types of Semaphores
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Binary Semaphores
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            A binary semaphore is either unsignaled or signaled.
						</p>
					</li>
					<li>
						<p>
                            It begins life as unsignaled.
						</p>
					</li>
					<li>
						<p>
                            The way we use a binary semaphore to order queue operations is by providing the same semaphore as a 'signal' semaphore in one queue operation and as a 'wait' semaphore in another queue operation.
						</p>
					</li>
					<li>
						<p>
                            Only binary semaphores will be used in this tutorial, further mention of the term semaphore exclusively refers to binary semaphores.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Timeline Semaphores
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250730164111.png" width="425" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Correctly using the Semaphore for 
                <code>vkQueuePresent</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/swapchain_semaphore_reuse.html" 
						class="external-link" 
						target="_blank" >
                        Swapchain Semaphore Reuse
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Since Vulkan SDK 
					<em>
                        1.4.313
					</em>
                    , the validation layer reports cases where the present wait semaphore is not used safely:
				</p>
				<ul>
					<li>
						<p>
                            This is currently reported as 
                            <code>VUID-vkQueueSubmit-pSignalSemaphores-00067</code>
                            &nbsp;or you may see &quot;your VkSemaphore is being signaled by VkQueue, but it may still be in use by VkSwapchainKHR&quot;
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In this context, 
					<em>
                        safely
					</em>
                    &nbsp;means that the Vulkan specification guarantees the semaphore is no longer in use and can be reused.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        The problem
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>vkQueuePresentKHR</code>
                            &nbsp;is different from the 
                            <code>vkQueueSubmit</code>
                            &nbsp;family of functions in that it does not provide a way to signal a semaphore or a fence (without additional extensions).
						</p>
					</li>
					<li>
						<p>
                            This means there is no way to wait for the presentation signal directly. It also means we don’t know whether 
                            <code>VkPresentInfoKHR::pWaitSemaphores</code>
                            &nbsp;are still in use by the presentation operation.
						</p>
					</li>
					<li>
						<p>
                            If 
                            <code>vkQueuePresentKHR</code>
                            &nbsp;could signal, then waiting on that signal would confirm that the present queue operation has finished — including the wait on 
                            <code>VkPresentInfoKHR::pWaitSemaphores</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            In summary, it’s not obvious when it’s safe to reuse present wait semaphores.
						</p>
					</li>
					<li>
						<p>
                            The Vulkan specification does not guarantee that waiting on a 
                            <code>vkQueueSubmit</code>
                            &nbsp;fence also synchronizes presentation operations.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The reuse of presentation resources should rely on 
                    <code>vkAcquireNextImageKHR</code>
                    &nbsp;or additional extensions, rather than on 
                    <code>vkQueueSubmit</code>
                    &nbsp;fences.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Solution options
					</strong>
                    :
				</p>
				<ol>
					<li>
						<p>
                            Allocate one &quot;submit finished&quot; semaphore per swapchain image instead of per in-flight frame.
						</p>
						<ul>
							<li>
								<p>
                                    Allocate the 
                                    <code>submit_semaphores</code>
                                    &nbsp;array based on the number of swapchain images (instead of the number of in-flight frames)
								</p>
							</li>
							<li>
								<p>
                                    Index this array using the acquired swapchain image index (instead of the current in-flight frame index)
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Using 
                            <code>VK_EXT_swapchain_maintenance1</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    See 
                                    <a href="Vulkan.html#Recreating">
                                    Vulkan#Recreating
                                    </a>
                                    , for use with the swapchain.
								</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="fences" >
    Fences
</h5>
<ul>
	<li>
		<p>
            <code>VkFence</code>
		</p>
	</li>
	<li>
		<p>
            Fences facilitate GPU -&gt; CPU synchronization.
		</p>
		<ul>
			<li>
				<p>
                    Used to know if a command buffer has finished being executed on the GPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            While signalling a fence makes all memory available, it does not make them available to the CPU, just within the device. This is where 
            <code>dstStageMask = PIPELINE_STAGE_HOST</code>
            &nbsp;and 
            <code>dstAccessMask = ACCESS_HOST_READ_BIT</code>
            &nbsp;flags come in. If you intend to read back data to the CPU, you must issue a pipeline barrier which makes memory available to the HOST as well.
		</p>
	</li>
	<li>
		<p>
            In our mental model, we can think of this as flushing the GPU L2 cache out to GPU main memory, so that CPU can access it over some bus interface.
		</p>
	</li>
	<li>
		<p>
            In order to signal that fence, any pending writes to that memory must have been made available, so even recycled memory can be safely reused without a memory barrier. This point is kind of subtle, but it really helps your sanity not having to inject memory barriers everywhere.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Similar to semaphores, fences are either in a signaled or unsignaled state.
				</p>
			</li>
			<li>
				<p>
                    Whenever we submit work to execute, we can attach a fence to that work. When the work is finished, the fence will be signaled.
				</p>
			</li>
			<li>
				<p>
                    Then we can make the CPU wait for the fence to be signaled, guaranteeing that the work has finished before the CPU continues.
				</p>
			</li>
			<li>
				<p>
                    Fences must be reset manually to put them back into the unsignaled state.
				</p>
				<ul>
					<li>
						<p>
                            This is because fences are used to control the execution of the CPU, and so the CPU gets to decide when to reset the fence.
						</p>
					</li>
					<li>
						<p>
                            Contrast this to semaphores which are used to order work on the GPU without the CPU being involved.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Unlike the semaphore, the fence 
					<em>
                        does
					</em>
                    &nbsp;block CPU execution.
				</p>
				<ul>
					<li>
						<p>
                            In general, it is preferable to not block the host unless necessary.
						</p>
					</li>
					<li>
						<p>
                            We want to feed the GPU and the host with useful work to do. Waiting on fences to signal is not useful work.
						</p>
					</li>
					<li>
						<p>
                            Thus, we prefer semaphores, or other synchronization primitives not yet covered, to synchronize our work.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Taking a screenshot
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Once we have already done the necessary work on the GPU, we now need to transfer the image from the GPU over to the host and then save the memory to a file.
						</p>
					</li>
					<li>
						<p>
                            We have command buffer A which executes the transfer and fence F. We submit command buffer A with fence F, then immediately tell the host to wait for F to signal. This causes the host to block until command buffer A finishes execution.
						</p>
					</li>
					<li>
						<p>
                            Thus, we are safe to let the host save the file to disk, as the memory transfer has completed.
						</p>
					</li>
					<li>
						<p>
                            Unlike the semaphore example, this example 
							<em>
                                does
							</em>
                            &nbsp;block host execution. This means the host won’t do anything except wait until the execution has finished. For this case, we had to make sure the transfer was complete before we could save the screenshot to disk.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="main-loop-synchronization" >
    Main Loop Synchronization
</h5>
<ul>
	<li>
        <img src="assets/vulkan_sync.excalidraw" width="475" alt="<excalidraw_not_loaded>" >

	</li>
	<li>
		<p>
            <img src="assets/image_20250730182437.png" width="475" >
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=SjhpwVTJON8" 
						class="external-link" 
						target="_blank" >
                        Explanation
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The entire video is just drawings.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250801083016.png" width="475" >
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=FDHpCVN9nis" 
						class="external-link" 
						target="_blank" >
                        Explanation {0:00 -&gt; 6:38}
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Good illustration.
						</p>
					</li>
					<li>
						<p>
                            The rest of the video is just code.
						</p>
					</li>
					<li>
						<p>
                            Does not comment on Multiple Frames In Flight.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="command-buffers" >
    Command Buffers
</h2>
<ul>
	<li>
		<p>
            Commands in Vulkan, like drawing operations and memory transfers, are not executed directly using function calls. You have to record all the operations you want to perform in command buffer objects.
		</p>
	</li>
	<li>
		<p>
            The advantage of this is that when we are ready to tell Vulkan what we want to do, all the commands are submitted together. Vulkan can more efficiently process the commands since all of them are available together.
		</p>
	</li>
	<li>
		<p>
            In addition, this allows command recording to happen in 
			<em>
                multiple threads
			</em>
            &nbsp;if so desired.
		</p>
	</li>
</ul>
<h3
	id="command-pools" >
    Command Pools
</h3>
<ul>
	<li>
		<p>
            Create and allocate Command Buffers.
		</p>
	</li>
	<li>
		<p>
            Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation across multiple command buffers.
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCommandPool.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCreateCommandPool()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>device</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the logical device that creates the command pool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAllocator</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls host memory allocation as described in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-allocation" 
								class="external-link" 
								target="_blank" >
                                Memory Allocation
							</a>
                            &nbsp;chapter.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCommandPool</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPool.html" 
								class="external-link" 
								target="_blank" >
                                VkCommandPool
							</a>
                            &nbsp;handle in which the created pool is returned.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCreateInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkCommandPoolCreateInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>queueFamilyIndex</code>
						</p>
						<ul>
							<li>
								<p>
                                    Designates a queue family as described in section 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#devsandqueues-queueprops" 
										class="external-link" 
										target="_blank" >
                                        Queue Family Properties
									</a>
                                    . All command buffers allocated from this command pool 
									<strong>
                                        must
									</strong>
                                    &nbsp;be submitted on queues from the same queue family.
								</p>
							</li>
							<li>
								<p>
                                    Command buffers are executed by submitting them on one of the device queues (graphics and presentation queues, for example).
								</p>
							</li>
							<li>
								<p>
                                    Each command pool can only allocate command buffers that are submitted on a single type of queue.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask indicating usage behavior for the pool and command buffers allocated from it.
								</p>
							</li>
							<li>
								<p>
                                    <code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Hint that command buffers are rerecorded with new commands very often (may change memory allocation behavior)
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Allow command buffers to be rerecorded individually, without this flag they all have to be reset together
										</p>
									</li>
									<li>
										<p>
                                            If we record a command buffer every frame, we want to be able to reset and rerecord over it, thus, this flag should be enabled so a command buffer can be reset individually.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_COMMAND_POOL_CREATE_PROTECTED_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that command buffers allocated from the pool are protected command buffers.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="management" >
    Management
</h5>
<ul>
	<li>
		<p>
            Manages the memory that is used to store the buffers and command buffers are allocated from them.
		</p>
	</li>
	<li>
		<p>
            Destroying a Command Pool, destroys the Command Buffers associated.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Reset the whole Command Pool
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandPool.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkResetCommandPool</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                initial state
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Any primary command buffer allocated from another 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPool.html" 
								class="external-link" 
								target="_blank" >
                                VkCommandPool
							</a>
                            &nbsp;that is in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                recording or executable state
							</a>
                            &nbsp;and has a secondary command buffer allocated from 
                            <code>commandPool</code>
                            &nbsp;recorded into it, becomes 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                invalid
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Free individual Command Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkFreeCommandBuffers()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>device</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the logical device that owns the command pool.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>commandPool</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the command pool from which the command buffers were allocated.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>commandBufferCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the length of the 
                                    <code>pCommandBuffers</code>
                                    &nbsp;array.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pCommandBuffers</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of handles of command buffers to free.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Any primary command buffer that is in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                recording or executable state
							</a>
                            &nbsp;and has any element of 
                            <code>pCommandBuffers</code>
                            &nbsp;recorded into it, becomes 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                invalid
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="multi-threading" >
    Multi-threading
</h5>
<ul>
	<li>
		<p>
            You can allocate as many 
            <code>VkCommandBuffer</code>
            &nbsp;as you want from a given pool, but you can only record commands from one thread at a time.
		</p>
	</li>
	<li>
		<p>
            If you want multithreaded command recording, you need more 
            <code>VkCommandPool</code>
            &nbsp;objects. For that reason, we will pair a command buffer with its command allocator.
		</p>
	</li>
	<li>
		<p>
            Command pools are externally synchronized, meaning that a command pool 
			<strong>
                must
			</strong>
            &nbsp;not be used concurrently in multiple threads. That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, free, and reset command buffers or the pool itself.
		</p>
	</li>
</ul>
<h3
	id="command-buffer" >
    Command Buffer
</h3>
<h5
	id="creation-allocation" >
    Creation / Allocation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>VkCommandBuffer</code>
                &nbsp;
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Encodes GPU commands.
				</p>
			</li>
			<li>
				<p>
                    All execution that is performed on the GPU itself (not in the driver) has to be encoded in a command buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html" 
				class="external-link" 
				target="_blank" >
                <code>vkAllocateCommandBuffers()</code>
                &nbsp;
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>pAllocateInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkCommandBufferAllocateInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>commandPool</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the command pool from which the command buffers are allocated.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>level</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferLevel.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkCommandBufferLevel</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies if the allocated command buffers are primary or secondary command buffers.
								</p>
							</li>
							<li>
								<p>
                                    `VK_COMMAND_BUFFER_LEVEL_PRIMARY
								</p>
								<ul>
									<li>
										<p>
                                            Command Buffer Primary.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    `VK_COMMAND_BUFFER_LEVEL_SECONDARY
								</p>
								<ul>
									<li>
										<p>
                                            Command Buffer Secondary.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>commandBufferCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of command buffers to allocate from the pool.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCommandBuffers</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of Command Buffer handles in which the resulting command buffer objects are returned. The array 
							<em>
                                must
							</em>
                            &nbsp;be at least the length specified by the 
                            <code>commandBufferCount</code>
                            &nbsp;member of 
                            <code>pAllocateInfo</code>
                            . Each allocated command buffer begins in the initial state.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="lifecycle" >
    Lifecycle
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#commandbuffers-lifecycle" 
				class="external-link" 
				target="_blank" >
                Lifecycle
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731200744.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Reset an single Command Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Once a command buffer has been submitted, it’s still “alive”, and being consumed by the GPU, at this point it is NOT safe to reset the command buffer yet. You need to make sure that the GPU has finished executing all of the commands from that command buffer until you can reset and reuse it.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandBuffer.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkResetCommandBuffer()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>commandBuffer</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the command buffer to reset. The command buffer 
									<strong>
                                        can
									</strong>
                                    &nbsp;be in any state other than 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
										class="external-link" 
										target="_blank" >
                                        pending
									</a>
                                    , and is moved into the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
										class="external-link" 
										target="_blank" >
                                        initial state
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferResetFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkCommandBufferResetFlagBits
									</a>
                                    &nbsp;controlling the reset operation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Any primary command buffer that is in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                recording or executable state
							</a>
                            &nbsp;and has 
                            <code>commandBuffer</code>
                            &nbsp;recorded into it, becomes 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
								class="external-link" 
								target="_blank" >
                                invalid
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            After a command buffer is reset, any objects or memory specified by commands recorded into the command buffer 
							<strong>
                                must
							</strong>
                            &nbsp;no longer be accessed when the command buffer is accessed by the implementation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If the command buffer was already recorded once, then a call to it will implicitly reset it.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="levels" >
    Levels
</h5>
<ul>
	<li>
		<p>
			<strong>
                Primary
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only these can be submitted to queues for execution.
				</p>
			</li>
			<li>
				<p>
                    Cannot be called from other command buffers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Secondary
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Cannot be submitted directly, but can be called from primary command buffers.
				</p>
			</li>
			<li>
				<p>
                    &quot;We won’t make use of the secondary command buffer functionality here, but you can imagine that it’s helpful to reuse common operations from primary command buffers.&quot;
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteCommands.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCmdExecuteCommands()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            A primary command buffer would use this to execute a secondary command buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Re-recording
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If a secondary moves to the invalid state or the initial state, then all primary buffers it is recorded in move to the invalid state. A primary moving to any other state does not affect the state of a secondary recorded in it.
						</p>
					</li>
					<li>
						<p>
                            So, when a secondary command is re-recorded, the primary becomes invalid.
						</p>
					</li>
					<li>
						<p>
                            Eve: &quot;It is not capturing a reference to a command buffer, it is going through and copying all the commands in the command buffer into itself.&quot;
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="command-types" >
    Command Types
</h5>
<ul>
	<li>
		<p>
            Action-Type, State-Type, Sync-Type.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250731202609.png" width="500" >
            .
		</p>
	</li>
</ul>
<h3
	id="command-buffer-recording" >
    Command Buffer Recording
</h3>
<ul>
	<li>
		<p>
            Writes the commands we want to execute into a command buffer.
		</p>
	</li>
	<li>
		<p>
            It’s not possible to append commands to a buffer at a later time.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkBeginCommandBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>vkBeginCommandBuffer()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the handle of the command buffer which is to be put in the recording state.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pBeginInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferBeginInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkCommandBufferBeginInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            Specifies some details about the usage of this specific command buffer.
						</p>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferUsageFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkCommandBufferUsageFlagBits</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Specifies how we’re going to use the command buffer.
								</p>
							</li>
							<li>
								<p>
                                    <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            The command buffer will be rerecorded right after executing it once.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            This is a secondary command buffer that will be entirely within a single render pass.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            The command buffer can be resubmitted while it is also already pending execution.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    None of these flags are applicable for us right now.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pInheritanceInfo</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkCommandBufferInheritanceInfo
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            If the command buffer is a secondary command buffer, then the 
                                            <code>VkCommandBufferInheritanceInfo</code>
                                            &nbsp;structure defines any state that will be inherited from the primary command buffer:
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Used if 
                                    <code>commandBuffer</code>
                                    &nbsp;is a secondary command buffer. If this is a primary command buffer, then this value is ignored.
								</p>
							</li>
							<li>
								<p>
                                    It specifies which state to inherit from the calling primary command buffers.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkEndCommandBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>vkEndCommandBuffer()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The command buffer 
					<strong>
                        must
					</strong>
                    &nbsp;have been in the 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
						class="external-link" 
						target="_blank" >
                        recording state
					</a>
                    , and, if successful, is moved to the 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
						class="external-link" 
						target="_blank" >
                        executable state
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    If there was an error during recording, the application will be notified by an unsuccessful return code returned by 
                    <code>vkEndCommandBuffer</code>
                    , and the command buffer will be moved to the 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#commandbuffers-lifecycle" 
						class="external-link" 
						target="_blank" >
                        invalid state
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="pipelines" >
    Pipelines
</h2>
<ul>
	<li>
		<p>
            In Vulkan, to execute code on the GPU, we need to set up a pipeline.
		</p>
	</li>
	<li>
		<p>
            There are two types of pipelines, Graphics and Compute:
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Compute pipelines
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Are much simpler, because they only require the data for the shader code, and the layout for the descriptors used for data bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Graphics pipelines
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Have to configure a considerable amount of state for all of the fixed-function hardware in the GPU such as color blending, depth testing, or geometry formats.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Both types of pipelines share the shader modules and the layouts, which are built in the same way.
		</p>
	</li>
	<li>
		<p>
            <code>VkPipeline</code>
		</p>
	</li>
</ul>
<h5
	id="pipeline-layout" >
    Pipeline Layout
</h5>
<ul>
	<li>
		<p>
            A collection of 
            <code>DescriptorSetLayouts</code>
            &nbsp;and 
            <code>PushConstantRange</code>
            &nbsp;defining its push constant usage.
		</p>
	</li>
	<li>
		<p>
            PipelineLayouts for a graphics and compute pipeline are made in the same way, and they must be created before the pipeline itself.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayout.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineLayout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPipelineLayoutCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Structure specifying the parameters of a newly created pipeline layout object
						</p>
					</li>
					<li>
						<p>
                            <code>setLayoutCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of descriptor sets included in the pipeline layout.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pSetLayouts</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
                                    <code>VkDescriptorSetLayout</code>
                                    &nbsp;objects.
								</p>
							</li>
							<li>
								<p>
                                    The implementation 
									<em>
                                        must
									</em>
                                    &nbsp;not access these objects outside of the duration of the command this structure is passed to.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCreatePipelineLayout()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>pCreateInfo</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkPipelineLayoutCreateInfo
									</a>
                                    &nbsp;structure specifying the state of the pipeline layout object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkPipelineLayoutCreateFlagBits
									</a>
                                    &nbsp;specifying options for pipeline layout creation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>setLayoutCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    See 
                                    <a href="Vulkan.html#Descriptor Set Layout">
                                    Vulkan#Descriptor Set Layout
                                    </a>
                                    &nbsp;for more information.
								</p>
							</li>
							<li>
								<p>
                                    Is the number of descriptor sets included in the pipeline layout.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pSetLayouts</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
                                    <code>VkDescriptorSetLayout</code>
                                    &nbsp;objects. The implementation 
									<strong>
                                        must
									</strong>
                                    &nbsp;not access these objects outside of the duration of the command this structure is passed to.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pushConstantRangeCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of push constant ranges included in the pipeline layout.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pPushConstantRanges</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushConstantRange.html" 
										class="external-link" 
										target="_blank" >
                                        VkPushConstantRange
									</a>
                                    &nbsp;structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants 
									<strong>
                                        can
									</strong>
                                    &nbsp;be accessed by each stage of the pipeline.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="mesh-shaders" >
    Mesh Shaders
</h3>
<h5
	id="support" >
    Support
</h5>
<ul>
	<li>
		<p>
            [2025/09/12]
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912094010.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            It is important to note that while portability between APIs can be achieved, portability in performance among vendors is much harder. This is one of the reasons why this extension has not been released as a ratified KHR extension and Khronos continues to investigate improvements to geometry rasterization.
		</p>
	</li>
	<li>
		<p>
            There are further aspects that can influence the performance of mesh shaders in a vendor dependent way:
		</p>
		<ul>
			<li>
				<p>
                    The number of maximum output vertices and primitives that a mesh shader is compiled with.
				</p>
			</li>
			<li>
				<p>
                    The number of per-vertex and per-primitive output attributes that are passed to fragment shaders. For example, it may be beneficial to fetch additional attributes in the fragment shader and interpolate them via hardware barycentrics to reduce the output space of the mesh shader.
				</p>
			</li>
			<li>
				<p>
                    The complexity of the culling performed in the mesh shader. For example details regarding the per-vertex and/or per-primitive culling with compact outputs compared to letting the hardware perform culling.
				</p>
			</li>
			<li>
				<p>
                    The usage of additional shared memory. If possible developers should use subgroup operations (such as shuffle) instead.
				</p>
			</li>
			<li>
				<p>
                    The task payload size.
				</p>
			</li>
			<li>
				<p>
                    Task shaders may add overhead, use them only when they can cull a meaningful number of primitives or when actual geometry amplification is desired.
				</p>
			</li>
			<li>
				<p>
                    Do not try to reimplement the fixed-function pipeline, strive for simpler algorithms instead.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250909103948.png" width="137" >
            .
		</p>
	</li>
</ul>
<h5
	id="motivation" >
    Motivation
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250912093325.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912092257.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The current state of the Graphics Pipeline is not a direct mapping of how a GPU operates.
		</p>
	</li>
	<li>
		<p>
            There's a lot of Per Vertex -&gt; Per Primitive -&gt; Per Vertex -&gt; Per Primitive happening inside a Graphics Pipeline.
		</p>
	</li>
	<li>
		<p>
            The idea is to use the flexibility of Compute Shaders and use the GPU more closely as it operates.
		</p>
	</li>
	<li>
		<p>
            Mesh and Task shaders follow the compute programming model and use threads cooperatively to generate meshes within a workgroup. The vertex and index data for these meshes are written similarly to shared memory in compute shaders.
		</p>
	</li>
	<li>
		<p>
            Mesh shader output is directly consumed by the rasterizer, as opposed to the previous approach of using a compute dispatch followed by an indirect draw.
		</p>
	</li>
	<li>
		<p>
            Mesh Shading applications can avoid preallocation of output buffers.
		</p>
	</li>
	<li>
		<p>
            Before deciding to use mesh shaders, developers should ensure they are a good fit for their application. The traditional pipeline may still be best suited to many use cases, and it may not be trivial to improve performance using the mesh shading pipeline given the long evolution and optimization efforts applied to the traditional pipeline stages.
		</p>
	</li>
	<li>
		<p>
            Applications and games dealing with 
			<em>
                high geometric complexity
			</em>
            &nbsp;can, however, benefit from the flexibility of the two-stage approach, which allows 
			<em>
                efficient culling
			</em>
            , 
			<em>
                level-of-detail
			</em>
            &nbsp;techniques as well as 
			<em>
                procedural generation
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Compared to the traditional pipeline, the mesh shaders allow easy access to the topology of the generated primitives and developers are free to repurpose the threads to do both vertex shading and primitive shading work. This is in contrast to tessellation shaders, which, while fast, provide very limited control over the triangles created, and geometry shaders, which use a single-thread programming model that is inefficient for modern streaming processors.
		</p>
	</li>
</ul>
<h5
	id="task-shader" >
    Task Shader
</h5>
<ul>
	<li>
		<p>
            Is optional and provides a way to implement geometry amplification by creating variable mesh shader workgroups directly in the pipeline. Task shader workgroups can output an optional payload, which is visible as read-only input to all its child mesh shader workgroups.
		</p>
	</li>
	<li>
		<p>
            A Task Shader decides how many Mesh Shaders you would like to run.
		</p>
	</li>
</ul>
<h5
	id="meshlets-triangle-clusters" >
    Meshlets / Triangle Clusters
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250912093822.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            When rasterizing geometry, mesh shaders typically make use of pre-computed triangle clusters of an upper bound in the number of vertices and triangles, also sometimes referred to as meshlets. Because task and mesh shaders, like compute, have only workgroup and invocation indices as input, all data fetching is handled by the application directly, which entirely removes fixed-function vertex processing and input assembly. This allows developers to be flexible in the storage of mesh data in both vertex and primitive topology representations. Another very common technique is to leverage the task shader and let one local invocation test one cluster for visibility. Through the use of subgroup operations developers can compute and write out information about the visible clusters into the task shader payload.
		</p>
	</li>
	<li>
		<p>
            The meshlet / primitive cluster dimensions can have an especially big impact for the developer, as when streaming it is ideal to store assets with a fixed clustering in advance. Vendors may have different performance recommendations and so we suggest the use of smaller cluster sizes that work equally well across multiple vendors and process multiple small clusters at once on implementations that perform better with larger clusters. In this area we advise developers to experiment and consult with their hardware vendors for recommendations.
		</p>
	</li>
</ul>
<h5
	id="using-it" >
    Using it
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/VK_NV_mesh_shader/mesh.html" 
				class="external-link" 
				target="_blank" >
                Mesh Shading
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The URL comes from 
                    <code>VK_NV_mesh_shader</code>
                    ; maybe it's relevant?
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://github.com/nvpro-samples/gl_vk_meshlet_cadscene" 
				class="external-link" 
				target="_blank" >
                gl_vk_meshlet_cadscene
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    This OpenGL/Vulkan sample illustrates the use of &quot;mesh shaders&quot; for rendering CAD models.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.gamedev.net/blogs/entry/2293837-insane-draw-call-reduction-with-mesh-shaders-in-vulkan/" 
				class="external-link" 
				target="_blank" >
                Use of Mesh Shader to improve performance - 2024
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912092500.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            The recommended idea is a Mesh Shader to operate on a Meshlet.
		</p>
	</li>
</ul>
<h5
	id="what-a-mesh-shader-enables" >
    What a Mesh Shader enables
</h5>
<ul>
	<li>
		<p>
            You can do very early culling.
		</p>
	</li>
	<li>
		<p>
            It can be faster than the classical Graphics Pipeline, if correctly optimized.
		</p>
	</li>
	<li>
		<p>
			<em>
                Mesh Shader output Execution Mode
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The mesh stage will set either 
                    <code>OutputPoints</code>
                    , 
                    <code>OutputLinesEXT</code>
                    , or 
                    <code>OutputTrianglesEXT</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #extension GL_EXT_mesh_shader : require
 
 // Only 1 of the 3 is allowed
 layout(points) out;
 layout(lines) out;
 layout(triangles) out;
</code></pre>
	</li>
</ul>
<h3
	id="cluster-culling-shader" >
    Cluster Culling Shader
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/VK_HUAWEI_cluster_culling_shader/clusterculling.html" 
				class="external-link" 
				target="_blank" >
                Cluster Culling Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_HUAWEI_cluster_culling_shader</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="graphics-pipeline" >
    Graphics Pipeline
</h2>
<ul>
	<li>
		<p>
            The graphics pipeline is required for all common drawing operations.
		</p>
	</li>
	<li>
		<p>
            Holds the state of the GPU needed to draw. For example: shaders, rasterization options, depth settings.
		</p>
	</li>
	<li>
		<p>
            It describes the configurable state of the graphics card, like the viewport size and depth buffer operation and the programmable state using VkShaderModule objects.
		</p>
	</li>
</ul>
<h5
	id="stages" >
    Stages
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250730155932.png" width="600" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250730083345.png" width="218" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Disabling stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The tessellation and geometry stages can be disabled if you are just drawing simple geometry.
				</p>
			</li>
			<li>
				<p>
                    If you are only interested in depth values, then you can disable the fragment shader stage, which is useful for 
					<a
						href="https://en.wikipedia.org/wiki/Shadow_mapping" 
						class="external-link" 
						target="_blank" >
                        shadow map
					</a>
                    &nbsp;generation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Fixed-function stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Allow you to tweak their operations using parameters, but the way they work is predefined.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Dynamic State
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            While 
							<em>
                                most
							</em>
                            &nbsp;of the pipeline state needs to be baked into the pipeline state, a limited amount of the state can actually be changed without recreating the pipeline at draw time.
						</p>
					</li>
					<li>
						<p>
                            Examples are the size of the viewport, line width and blend constants.
						</p>
					</li>
					<li>
						<p>
                            If you want to use dynamic state and keep these properties out, then you’ll have to fill in a 
                            <code>VkPipelineDynamicStateCreateInfo</code>
                            &nbsp;struct.
						</p>
					</li>
					<li>
						<p>
                            This will cause the configuration of these values to be 
							<strong>
                                ignored
							</strong>
                            , and you will be able (and required) to specify the data at drawing time.
						</p>
					</li>
					<li>
						<p>
                            This results in a more flexible setup and is widespread for things like viewport and scissor state, which would result in a more complex setup when being baked into the pipeline state.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Programmable stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Means that you can upload your own code to the graphics card to apply exactly the operations you want.
				</p>
			</li>
			<li>
				<p>
                    This allows you to use fragment shaders, for example, to implement anything from texturing and lighting to ray tracers. These programs run on many GPU cores simultaneously to process many objects, like vertices and fragments in parallel.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Immutability
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is almost completely immutable, so you must recreate the pipeline from scratch if you want to change shaders, bind different framebuffers or change the blend function.
				</p>
			</li>
			<li>
				<p>
                    The disadvantage is that you’ll have to create a number of pipelines (many VkPipeline objects) that represent all the different combinations of states you want to use in your rendering operations. However, because all the operations you’ll be doing in the pipeline are known in advance, the driver can optimize for it much better.
				</p>
				<ul>
					<li>
						<p>
                            Runtime performance is more predictable because large state changes like switching to a different graphics pipeline are made very explicit.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Only some basic configuration, like viewport size and clear color, can be changed dynamically.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="shader-compilation" >
    Shader Compilation
</h3>
<h5
	id="shader-module" >
    Shader Module
</h5>
<ul>
	<li>
		<p>
            A 
            <code>VkShaderModule</code>
            &nbsp;is a processed shader file.
		</p>
	</li>
	<li>
		<p>
            We create it from a pre-compiled SPIR-V file.
		</p>
	</li>
	<li>
		<p>
            We can call 
            <code>vkDestroyShaderModule</code>
            &nbsp;after they are used for the graphics pipeline creation.
		</p>
	</li>
</ul>
<h3
	id="input-assembly" >
    Input Assembly
</h3>
<ul>
	<li>
		<p>
            Fixed-function stage.
		</p>
	</li>
	<li>
		<p>
            Collects the raw vertex data from the buffers you specify and may also use an index buffer to repeat certain elements without having to duplicate the vertex data itself.
		</p>
	</li>
	<li>
		<p>
            <code>VkPipelineVertexInputStateCreateInfo</code>
		</p>
		<ul>
			<li>
				<p>
                    Describes the format of the vertex data that will be passed to the vertex shader.
				</p>
			</li>
			<li>
				<p>
                    <code>pVertexBindingDescriptions</code>
				</p>
				<ul>
					<li>
						<p>
                            Spacing between data and whether the data is per-vertex or per-instance (see 
							<a
								href="https://en.wikipedia.org/wiki/Geometry_instancing" 
								class="external-link" 
								target="_blank" >
                                instancing
							</a>
                            ).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pVertexAttributeDescriptions</code>
				</p>
				<ul>
					<li>
						<p>
                            Type of the attributes passed to the vertex shader, which binding to load them from and at which offset.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineInputAssemblyStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineInputAssemblyStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Describes two things: what kind of geometry will be drawn from the vertices and if primitive restart should be enabled.
				</p>
			</li>
			<li>
				<p>
                    <code>topology</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_PRIMITIVE_TOPOLOGY_POINT_LIST</code>
						</p>
						<ul>
							<li>
								<p>
                                    points from vertices
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST</code>
						</p>
						<ul>
							<li>
								<p>
                                    line from every two vertices without reuse
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP</code>
						</p>
						<ul>
							<li>
								<p>
                                    the end vertex of every line is used as start vertex for the next line
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>
						</p>
						<ul>
							<li>
								<p>
                                    triangle from every three vertices without reuse
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP</code>
						</p>
						<ul>
							<li>
								<p>
                                    the second and third vertex of every triangle is used as first two vertices of the next triangle
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>primitiveRestartEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Normally, the vertices are loaded from the vertex buffer by index in sequential order, but with an 
							<em>
                                element buffer
							</em>
                            &nbsp;you can specify the indices to use yourself.
						</p>
						<ul>
							<li>
								<p>
                                    This allows you to perform optimizations like reusing vertices.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If you set this to 
                            <code>TRUE</code>
                            , then it’s possible to break up lines and triangles in the 
                            <code>_STRIP</code>
                            &nbsp;topology modes by using a special index of 
                            <code>0xFFFF</code>
                            &nbsp;or 
                            <code>0xFFFFFFFF</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="primitive-topology" >
    Primitive Topology
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250908151239.png" width="450" >
            .
		</p>
	</li>
</ul>
<h3
	id="vertex-shader" >
    Vertex Shader
</h3>
<ul>
	<li>
		<p>
            Programmable stage.
		</p>
	</li>
	<li>
		<p>
            Is run for every vertex and generally applies transformations to turn vertex positions from model space to screen space. It also passes per-vertex data down the pipeline.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VkShaderModule</code>
            &nbsp;objects are created from shader byte code.
		</p>
	</li>
	<li>
		<p>
            Accesses and computes one vertex at a time.
		</p>
	</li>
</ul>
<h3
	id="tessellation-shader" >
    Tessellation Shader
</h3>
<ul>
	<li>
		<p>
            Is run for every vertex and generally applies transformations to turn vertex positions from model space to screen space. It also passes per-vertex data down the pipeline.
		</p>
	</li>
	<li>
		<p>
            You can do tessellation in the Geometry Shader, but the Tessellation Shader is more appropriate and efficient.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081803.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Sending this amount of vertices to the Vertex Shader would be quite more expensive than generating them in the Tessellation Shader.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912082627.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            Tessellation Evaluation Shader.
		</p>
		<ul>
			<li>
				<p>
                    Kinda like a Vertex Shader, after the Tessellation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=OqRMNrvu6TE" 
				class="external-link" 
				target="_blank" >
                Tessellation Shader
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I was too lazy to watch it all.
				</p>
			</li>
			<li>
				<p>
                    The inputs are complicated, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Tessellation output Execution Mode
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The tessellation evaluation stage will set either 
                    <code>Triangles</code>
                    , 
                    <code>Quads</code>
                    , or 
                    <code>Isolines</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // Only 1 of the 3 is allowed
 layout(quads) in;
 layout(isolines) in;
 layout(triangles) in;
</code></pre>
	</li>
</ul>
<h3
	id="geometry-shader" >
    Geometry Shader
</h3>
<ul>
	<li>
		<p>
            Programmable stage.
		</p>
	</li>
	<li>
		<p>
            It operates on 
			<strong>
                primitives
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            Is run on every primitive (triangle, line, point) and can discard it or output more primitives than came in. This is similar to the tessellation shader but much more flexible.
		</p>
	</li>
	<li>
		<p>
            However, it is used little in today’s applications because the 
			<em>
                performance is not that good
			</em>
            &nbsp;on most graphics cards except for Intel’s integrated GPUs.
		</p>
		<ul>
			<li>
				<p>
                    Also, almost all geometry shader use cases can be replaced with a more modern Mesh shader pipeline, which like ray tracing is a wholly new pipeline solution, so it exists outside the standard graphics pipeline setup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912001248.png" width="450" >
            .
		</p>
	</li>
	<li>
        <img src="assets/image_20250912001941.png" width="400" >

	</li>
	<li>
		<p>
            A Vertex Shader is more parallelized than a Geometry Shader.
		</p>
	</li>
	<li>
		<p>
            A Vertex Shader computes one vertex at a time, while a geometry shader gets all the vertices 
			<strong>
                that compose a primitive
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    It does 
					<strong>
                        not
					</strong>
                    &nbsp;have access to the whole mesh, just the vertices that compose the current primitive.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                OpenGL Primitives
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    May be useful.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912002205.png" width="250" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912002244.png" width="250" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Think of the Primitive Inputs as just the amount of vertices you are sending at a time.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912075205.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            The reason for this is that you can get any primitive input and have any primitive output.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912075909.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Use 
                    <code>EndPrimitive()</code>
                    &nbsp;so the line strips are separated.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912080208.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The Vertex Shader can output data to the Geometry Shader, in the form of an array.
				</p>
			</li>
			<li>
				<p>
                    The Geometry Shader can output data to the Fragment Shader, in a form of an interpolated value, using barycentric coordinates.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Instancing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250912080636.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    You can have many instances of a Geometry Shader, where the input is the same but the output changes.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912080739.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250912080803.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081145.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The smoke is a quad facing the camera (billboard).
				</p>
			</li>
			<li>
				<p>
                    The points are converted to quads.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081304.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912081335.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<em>
                Geometry output Execution Mode
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    A geometry stage will set either 
                    <code>OutputPoints</code>
                    , 
                    <code>OutputLineStrip</code>
                    , or 
                    <code>OutputTriangleStrip</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // Only 1 of the 3 is allowed
 layout(points) out;
 layout(line_strip) out;
 layout(triangle_strip) out;
</code></pre>
	</li>
</ul>
<h3
	id="rasterization" >
    Rasterization
</h3>
<ul>
	<li>
		<p>
            Fixed-function stage.
		</p>
	</li>
	<li>
		<p>
            Breaks the primitives into 
			<em>
                fragments
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            These are the pixel elements that they fill on the framebuffer.
		</p>
	</li>
	<li>
		<p>
            Any fragments that fall outside the screen are discarded, and the attributes outputted by the vertex shader are interpolated across the fragments.
		</p>
	</li>
	<li>
		<p>
            Fragments that are behind other primitive fragments can also be discarded here because of depth testing.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineRasterizationStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>polygonMode</code>
				</p>
			</li>
			<li>
				<p>
                    <code>lineWidth</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the width of rasterized line segments.
						</p>
					</li>
					<li>
						<p>
                            The maximum line width that is supported depends on the hardware.
						</p>
					</li>
					<li>
						<p>
                            Any line thicker than 
                            <code>1.0f</code>
                            &nbsp;requires you to enable the 
                            <code>wideLines</code>
                            &nbsp;GPU feature.
						</p>
					</li>
					<li>
						<p>
                            If set to 
                            <code>0.0f</code>
                            , you get: 
                            <code>lineWidth</code>
                            &nbsp;is 0.0, but the line width state is static (
                            <code>pCreateInfos[0].pDynamicState-&gt;pDynamicStates</code>
                            &nbsp;does not contain 
                            <code>VK_DYNAMIC_STATE_LINE_WIDTH</code>
                            ) and 
                            <code>wideLines</code>
                            &nbsp;feature was not enabled. The Vulkan spec states: If the pipeline requires pre-rasterization shader state, and the 
                            <code>wideLines</code>
                            &nbsp;feature is not enabled, and no element of the 
                            <code>pDynamicStates</code>
                            &nbsp;member of 
                            <code>pDynamicState</code>
                            &nbsp;is 
                            <code>VK_DYNAMIC_STATE_LINE_WIDTH</code>
                            , the lineWidth member of pRasterizationState 
							<strong>
                                must
							</strong>
                            &nbsp;be 1.0.
						</p>
					</li>
					<li>
						<p>
                            So, set it to 
                            <code>1.0f</code>
                            &nbsp;by default.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>cullMode</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>NONE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that no triangles are discarded
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>FRONT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that front-facing triangles are discarded
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>BACK</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that back-facing triangles are discarded
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>FRONT_AND_BACK</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that all triangles are discarded.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Following culling, fragments are produced for any triangles which have not been discarded.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>frontFace</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the vertex order for the faces to be considered front-facing.
						</p>
					</li>
					<li>
						<p>
                            <code>COUNTER_CLOCKWISE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that a triangle with positive area is considered front-facing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>CLOCKWISE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that a triangle with negative area is considered front-facing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Any triangle which is not front-facing is back-facing, including zero-area triangles.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>rasterizerDiscardEnable</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            When enabled, primitives are discarded after they are processed by the last active shader stage in the pipeline before rasterization.
						</p>
					</li>
					<li>
						<p>
                            Controls whether primitives are discarded immediately before the rasterization stage. This is important because when this is set to 
                            <code>VK_TRUE</code>
                            &nbsp;the rasterization hardware is not executed.
						</p>
					</li>
					<li>
						<p>
                            There are many Validation Usage errors that will not occur if this is set to 
                            <code>VK_TRUE</code>
                            &nbsp;because some topology hardware is unused and can be ignored.
						</p>
					</li>
					<li>
						<p>
                            Enabling this state is meant for very specific use cases. Prior to compute shaders, this was a common technique for writting geometry shader output to a buffer.
						</p>
					</li>
					<li>
						<p>
                            It can be used to debug/profile non-rasterization bottlenecks.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthClampEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasConstantFactor</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasSlopeFactor</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthBiasClamp</code>
				</p>
				<ul>
					<li>
						<p>
                            See the Depth section for details.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="polygon-mode" >
    Polygon Mode
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250908152312.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            Determines how fragments are generated for geometry.
		</p>
	</li>
	<li>
		<p>
            These modes affect only the 
			<em>
                final
			</em>
            &nbsp;rasterization of polygons. The polygon’s vertices are shaded and the polygon is clipped and possibly culled before these modes are applied.
		</p>
	</li>
	<li>
		<p>
            <code>FILL</code>
		</p>
		<ul>
			<li>
				<p>
                    Fill the area of the polygon with fragments.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>LINE</code>
		</p>
		<ul>
			<li>
				<p>
                    Polygon edges are drawn as lines
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>POINT</code>
		</p>
		<ul>
			<li>
				<p>
                    Polygon vertices are drawn as points
				</p>
			</li>
			<li>
				<p>
                    If 
                    <code>VkPhysicalDeviceMaintenance5Properties</code>
                    ::
                    <code>polygonModePointSize</code>
                    &nbsp;is 
                    <code>VK_TRUE</code>
                    , the point size of the final rasterization of polygons is taken from 
                    <code>PointSize</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Otherwise, the point size of the final rasterization of polygons is 1.0.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>FILL_RECTANGLE_NV</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies that polygons are rendered using polygon rasterization rules, modified to consider a sample within the primitive if the sample location is inside the axis-aligned bounding box of the triangle after projection.
				</p>
			</li>
			<li>
				<p>
                    Note that the barycentric weights used in attribute interpolation 
					<strong>
                        can
					</strong>
                    &nbsp;extend outside the range 
                    <code>[0,1]</code>
                    &nbsp;when these primitives are shaded.
				</p>
			</li>
			<li>
				<p>
                    Special treatment is given to a sample position on the boundary edge of the bounding box. In such a case, if two rectangles lie on either side of a common edge (with identical endpoints) on which a sample position lies, then exactly one of the triangles 
					<strong>
                        must
					</strong>
                    &nbsp;produce a fragment that covers that sample during rasterization.
				</p>
			</li>
			<li>
				<p>
                    Polygons rendered in 
                    <code>FILL_RECTANGLE_NV</code>
                    &nbsp;mode 
					<strong>
                        may
					</strong>
                    &nbsp;be clipped by the frustum or by user clip planes. If clipping is applied, the triangle is culled rather than clipped.
				</p>
			</li>
			<li>
				<p>
                    Area calculation and facingness are determined for 
                    <code>FILL_RECTANGLE_NV</code>
                    &nbsp;mode using the triangle’s vertices.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you have a vertex shader that has 
            <code>PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>
            &nbsp;input and then during rasterization uses 
            <code>POLYGON_MODE_LINE</code>
            , the effective topology is the Line 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/drawing.html#drawing-primitive-topology-class" 
				class="external-link" 
				target="_blank" >
                Topology Class
			</a>
            &nbsp;at that time. This means something like 
            <code>lineWidth</code>
            &nbsp;would be applied when filling in the polygon with 
            <code>POLYGON_MODE_LINE</code>
            .
		</p>
	</li>
</ul>
<h3
	id="fragment-operations" >
    Fragment Operations
</h3>
<h5
	id="order" >
    Order
</h5>
<ol>
	<li>
		<p>
            Discard rectangles test
		</p>
	</li>
	<li>
		<p>
            Scissor test
		</p>
	</li>
	<li>
		<p>
            Exclusive scissor test
		</p>
	</li>
	<li>
		<p>
            Sample mask test
		</p>
	</li>
	<li>
		<p>
            Certain Fragment shading operations:
		</p>
		<ul>
			<li>
				<p>
                    Sample Mask Accesses
				</p>
			</li>
			<li>
				<p>
                    Tile Image Reads
				</p>
			</li>
			<li>
				<p>
                    Depth Replacement
				</p>
			</li>
			<li>
				<p>
                    Stencil Reference Replacement
				</p>
			</li>
			<li>
				<p>
                    Interlocked Operations
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Multisample coverage
		</p>
	</li>
	<li>
		<p>
            Depth bounds test
		</p>
	</li>
	<li>
		<p>
            Stencil test
		</p>
	</li>
	<li>
		<p>
            Depth test
		</p>
	</li>
	<li>
		<p>
            Representative fragment test
		</p>
	</li>
	<li>
		<p>
            Sample counting
		</p>
	</li>
	<li>
		<p>
            Coverage to color
		</p>
	</li>
	<li>
		<p>
            Coverage reduction
		</p>
	</li>
	<li>
		<p>
            Coverage modulation
		</p>
	</li>
</ol>
<h5
	id="early-per-fragment-tests" >
    Early Per-Fragment Tests
</h5>
<ul>
	<li>
		<p>
            OpenGL 4.6:
		</p>
		<ul>
			<li>
				<p>
                    Once fragments are produced by rasterization, a number of per-fragment operations are performed prior to fragment shader execution. If a fragment is discarded during any of these operations, it will not be processed by any subsequent Stage, including fragment shader execution.
				</p>
			</li>
			<li>
				<p>
                    Three fragment operations are performed, and a further three are optionally performed on each fragment, in the following order:
				</p>
				<ul>
					<li>
						<p>
                            the pixel ownership test (see section 14.9.1);
						</p>
					</li>
					<li>
						<p>
                            the scissor test (see section 14.9.2);
						</p>
					</li>
					<li>
						<p>
                            multisample fragment operations (see section 14.9.3);
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If early per-fragment operations are enabled, these tests are also performed:
				</p>
				<ul>
					<li>
						<p>
                            the stencil test (see section 17.3.3);
						</p>
					</li>
					<li>
						<p>
                            the depth buffer test (see section 17.3.4);
						</p>
						<ul>
							<li>
								<p>
                                    The depth buffer test discards the incoming fragment if a depth comparison fails. The comparison is enabled or disabled with the generic Enable and Disable commands using target DEPTH_TEST. When disabled, the depth comparison and subsequent possible updates to the depth buffer value are bypassed and the fragment is passed to the next operation. The stencil value, however, is modified as indicated below as if the depth buffer test passed. If enabled, the comparison takes place and the depth buffer and stencil value may subsequently be modified.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            occlusion query sample counting (see section 17.3.5)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Early fragment tests, as an optimization, exist to prevent unnecessary executions of the Fragment Shader. If a fragment will be discarded based on the Depth Test (due perhaps to being behind other geometry), it saves performance to avoid executing the fragment shader. There is specialized hardware that makes this particularly efficient in many GPUs.
				</p>
			</li>
			<li>
				<p>
                    The most effective way to use early depth test hardware is to run a depth-only pre-processing pass. This means to render all available geometry, using minimal shaders and a rendering pipeline that only writes to the depth buffer. The Vertex Shader should do nothing more than transform positions, and the Fragment Shader does not even need to exist.
				</p>
			</li>
			<li>
				<p>
                    This provides the best performance gain if the fragment shader is expensive, or if you intend to use multiple passes across the geometry.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Limitations
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The Spec states that these operations happen after fragment processing. However, a specification only defines apparent behavior, so the implementation is only required to behave &quot;as if&quot; it happened afterwards.
						</p>
					</li>
					<li>
						<p>
                            Therefore, an implementation is free to apply early fragment tests if the Fragment Shader being used does not do anything that would impact the results of those tests. So if a fragment shader writes to glFragDepth, thus changing the fragment's depth value, then early testing cannot take place, since the test must use the new computed value.
						</p>
					</li>
					<li>
						<p>
                            Do recall that if a fragment shader writes to gl_FragDepth, even conditionally, it must write to it at least once on all codepaths.
						</p>
					</li>
					<li>
						<p>
                            There can be other hardware-based limitations as well. For example, some hardware will not execute an early depth test if the (deprecated) alpha test is active, as these use the same hardware on that platform. Because this is a hardware-based optimization, OpenGL has no direct controls that will tell you if early depth testing will happen.
						</p>
					</li>
					<li>
						<p>
                            Similarly, if the fragment shader discards the fragment with the discard keyword, this will almost always turn off early depth tests on some hardware. Note that even 
							<em>
                                conditional
							</em>
                            &nbsp;use of discard will mean that the FS will turn off early depth tests.
						</p>
					</li>
					<li>
						<p>
                            All of the above limitations apply only to early testing as an optimization. They do not apply to anything below.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    More recent hardware can force early depth tests, using a special fragment shader layout qualifier:
				</p>
				<ul>
					<li>
						<p>
                            <code>layout(early_fragment_tests)</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Vulkan:
								</p>
								<ul>
									<li>
										<p>
                                            Specifying is a way of the application programmer providing a promise to the implementation that it is algorithmically safe to kill the fragments, so you explicitly allow the change in application-visible behavior.
										</p>
									</li>
									<li>
										<p>
                                            Specifying this will make per-fragment tests be performed before fragment shader execution. If this is not declared, per-fragment tests will be performed after fragment shader execution. Only one fragment shader (compilation unit) need declare this, though more than one can. If at least one declares this, then it is enabled.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    OpenGL 4.6:
								</p>
								<ul>
									<li>
										<p>
                                            An explicit control is provided to allow fragment shaders to enable early fragment tests. If the fragment shader specifies the 
                                            <code>early_fragment_tests</code>
                                            &nbsp;layout qualifier, the per-fragment tests will be performed prior to fragment shader execution. Otherwise, they will be performed after fragment shader execution.
										</p>
									</li>
									<li>
										<p>
                                            This will also perform early stencil tests.
										</p>
									</li>
									<li>
										<p>
                                            There is a caveat with this. This feature 
											<em>
                                                cannot
											</em>
                                            &nbsp;be used to violate the sanctity of the depth test. When this is activated, any writes to 
                                            <code>gl_FragDepth</code>
                                            &nbsp;will be 
											<em>
                                                ignored
											</em>
                                            . The value written to the depth buffer will be exactly what was tested 
											<em>
                                                against
											</em>
                                            &nbsp;the depth buffer: the fragment's depth computed through rasterization.
										</p>
									</li>
									<li>
										<p>
                                            This feature exists to ensure proper behavior when using 
											<a
												href="https://wikis.khronos.org/opengl/Image_Load_Store" 
												class="external-link" 
												target="_blank" >
                                                Image Load Store
											</a>
                                            &nbsp;or other 
											<a
												href="https://wikis.khronos.org/opengl/Incoherent_Memory_Access" 
												class="external-link" 
												target="_blank" >
                                                incoherent memory writing
											</a>
                                            . Without turning this on, fragments that fail the depth test would still perform their Image Load/Store operations, since the fragment shader that performed those operations successfully executed. However, with early fragment tests, those tests were run before the fragment shader. So this ensures that image load/store operations will only happen on fragments that pass the depth test.
										</p>
									</li>
									<li>
										<p>
                                            Enabling this feature has consequences for 
											<a
												href="https://wikis.khronos.org/opengl/Fragment_Discarding" 
												class="external-link" 
												target="_blank" >
                                                the results of a discarded fragment.
											</a>
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="viewport-and-scissors" >
    Viewport and Scissors
</h4>
<ul>
	<li>
		<p>
            A viewport basically describes the region of the framebuffer that the output will be rendered to.
		</p>
	</li>
	<li>
		<p>
            Viewports define the transformation from the image to the framebuffer, scissor rectangles define in which region pixels will actually be stored. The rasterizer will discard any pixels outside the scissored rectangles. They function like a filter rather than a transformation.
		</p>
		<ul>
			<li>
				<p>
                    The difference is illustrated below.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250730113603.png" width="475" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Note that the left scissored rectangle is just one of the many possibilities that would result in that image, as long as it’s larger than the viewport.
				</p>
			</li>
			<li>
				<p>
                    So if we wanted to draw to the entire framebuffer, we would specify a scissor rectangle that covers it entirely:
				</p>
<pre><code class="language-cpp" data-lang="cpp"> vk::Rect2D{ vk::Offset2D{ 0, 0 }, swapChainExtent }
</code></pre>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Parameters
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This will almost always be the rectangle 
                    <code>(0, 0)</code>
                    , 
                    <code>(width, height)</code>
                    &nbsp;and in this tutorial that will also be the case.
				</p>
				<ul>
					<li>
						<p>
                            Remember that the size of the Swapchain and its images may differ from the 
                            <code>WIDTH</code>
                            &nbsp;and 
                            <code>HEIGHT</code>
                            &nbsp;of the window.
						</p>
					</li>
					<li>
						<p>
                            The Swapchain images will be used as framebuffers later on, so we should stick to their size.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The 
                    <code>minDepth</code>
                    &nbsp;and 
                    <code>maxDepth</code>
                    &nbsp;values specify the range of depth values to use for the framebuffer. These values must be within the 
                    <code>[0.0f, 1.0f]</code>
                    &nbsp;range, but 
                    <code>minDepth</code>
                    &nbsp;may be higher than 
                    <code>maxDepth</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If you aren’t doing anything special, then you should stick to the standard values of 
                            <code>0.0f</code>
                            &nbsp;and 
                            <code>1.0f</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                As a Dynamic State or Static State
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Viewport(s) and scissor rectangle(s) can either be specified as a static part of the pipeline or as a dynamic state set in the command buffer.
				</p>
			</li>
			<li>
				<p>
                    Independent of how you set them, it’s possible to use multiple viewports and scissor rectangles on some graphics cards, so the structure members reference an array of them. Using multiple requires enabling a GPU feature (see logical device creation).
				</p>
			</li>
			<li>
				<p>
                    It’s often convenient to make viewport and scissor state dynamic as it gives you a lot more flexibility.
				</p>
			</li>
			<li>
				<p>
					<em>
                        With dynamic state
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It’s even possible to specify different viewports and or scissor rectangles within a single command buffer.
						</p>
					</li>
					<li>
						<p>
                            This is widespread and all implementations can handle this dynamic state 
							<em>
                                without
							</em>
                            &nbsp;a performance penalty.
						</p>
					</li>
					<li>
						<p>
                            When opting for dynamic viewport(s) and scissor rectangle(s), you need to enable the respective dynamic states for the pipeline:
						</p>
<pre><code class="language-cpp" data-lang="cpp"> std::vector dynamicStates = {
&nbsp;&nbsp;&nbsp;&nbsp; vk::DynamicState::eViewport,
&nbsp;&nbsp;&nbsp;&nbsp; vk::DynamicState::eScissor
 };
 vk::PipelineDynamicStateCreateInfo dynamicState({}, dynamicStates.size(), dynamicStates.data());
</code></pre>
					</li>
					<li>
						<p>
                            And then you only need to specify their count at pipeline creation time:
						</p>
<pre><code class="language-cpp" data-lang="cpp"> vk::PipelineViewportStateCreateInfo viewportState({}, 1, {}, 1);
</code></pre>
					</li>
					<li>
						<p>
                            The actual viewport(s) and scissor rectangle(s) will then later be set up at drawing time.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
					<em>
                        Without dynamic state
					</em>
                    </s>:
				</p>
				<ul>
					<li>
						<p>
                            The viewport and scissor rectangle need to be set in the pipeline using the 
                            <code>VkPipelineViewportStateCreateInfo</code>
                            &nbsp;struct. This makes the viewport and scissor rectangle for this pipeline immutable. Any changes required to these values would require a new pipeline to be created with the new values.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        What should you use?
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            USE DYNAMIC. There's 
							<strong>
                                no
							</strong>
                            &nbsp;performance penalty.
						</p>
					</li>
					<li>
						<p>
                            Supported since launch.
						</p>
					</li>
					<li>
						<p>
                            LunarG:
						</p>
						<ul>
							<li>
								<p>
                                    <img src="assets/image_20250731211321.png" width="350" >
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="multi-sampling" >
    Multi-Sampling
</h4>
<h5
	id="setup" >
    Setup
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineMultisampleStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineMultisampleStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>rasterizationSamples</code>
				</p>
				<ul>
					<li>
						<p>
                            If the bound pipeline was created without a 
                            <code>VkAttachmentSampleCountInfoAMD</code>
                            &nbsp;or 
                            <code>VkAttachmentSampleCountInfoNV</code>
                            &nbsp;structure, and the 
                            <code>multisampledRenderToSingleSampled</code>
                            &nbsp;feature is not enabled, and the current render pass instance was begun with 
                            <code>vkCmdBeginRendering</code>
                            &nbsp;with a 
                            <code>VkRenderingInfo:colorAttachmentCount</code>
                            &nbsp;parameter greater than 0, then each element of the 
                            <code>VkRenderingInfo:pColorAttachments</code>
                            &nbsp;array with a 
                            <code>imageView</code>
                            &nbsp;not equal to 
                            <code>VK_NULL_HANDLE</code>
                            &nbsp;must have been created with a sample count equal to the value of 
                            <code>rasterizationSamples</code>
                            &nbsp;for the bound graphics pipeline.
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/limits.html#VkSampleCountFlagBits" 
								class="external-link" 
								target="_blank" >
                                VkSampleCountFlagBits
							</a>
                            &nbsp;value specifying the number of samples used in rasterization. This value is ignored for the purposes of setting the number of samples used in rasterization if the pipeline is created with the 
                            <code>VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT</code>
                            &nbsp;dynamic state set, but if 
                            <code>VK_DYNAMIC_STATE_SAMPLE_MASK_EXT</code>
                            &nbsp;dynamic state is not set, it is still used to define the size of the 
                            <code>pSampleMask</code>
                            &nbsp;array as described below.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>sampleShadingEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                can
							</strong>
                            &nbsp;be used to enable 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/primsrast.html#primsrast-sampleshading" 
								class="external-link" 
								target="_blank" >
                                Sample Shading
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>minSampleShading</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a minimum fraction of sample shading if 
                            <code>sampleShadingEnable</code>
                            &nbsp;is 
                            <code>VK_TRUE</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSampleMask</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkSampleMask</code>
                            &nbsp;values used in the 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/fragops.html#fragops-samplemask" 
								class="external-link" 
								target="_blank" >
                                sample mask test
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>alphaToCoverageEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls whether a temporary coverage value is generated based on the alpha component of the fragment’s first color output as specified in the 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/fragops.html#fragops-covg" 
								class="external-link" 
								target="_blank" >
                                Multisample Coverage
							</a>
                            &nbsp;section.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>alphaToOneEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls whether the alpha component of the fragment’s first color output is replaced with one as described in 
							<a
								href="https://docs.vulkan.org/spec/latest/chapters/fragops.html#fragops-covg" 
								class="external-link" 
								target="_blank" >
                                Multisample Coverage
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="resolving" >
    Resolving
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkRenderingAttachmentInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>resolveMode</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlagBits.html" 
								class="external-link" 
								target="_blank" >
                                VkResolveModeFlagBits
							</a>
                            &nbsp;value defining how data written to 
                            <code>imageView</code>
                            &nbsp;will be resolved into 
                            <code>resolveImageView</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If 
                            <code>resolveMode</code>
                            &nbsp;is not 
                            <code>VK_RESOLVE_MODE_NONE</code>
                            , and 
                            <code>resolveImageView</code>
                            &nbsp;is not 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NULL_HANDLE.html" 
								class="external-link" 
								target="_blank" >
                                VK_NULL_HANDLE
							</a>
                            , a render pass multisample resolve operation is defined for the attachment subresource.
						</p>
					</li>
					<li>
						<p>
                            <code>VK_RESOLVE_MODE_NONE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that no resolve operation is done.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_RESOLVE_MODE_SAMPLE_ZERO_BIT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is equal to the value of sample 0.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_RESOLVE_MODE_AVERAGE_BIT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is the average of the sample values.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_RESOLVE_MODE_MIN_BIT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is the minimum of the sample values.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_RESOLVE_MODE_MAX_BIT</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that result of the resolve operation is the maximum of the sample values.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that rather than a multisample resolve, a single sampled color attachment will be downsampled into a Y′CBCR format image specified by an external Android format. Unlike other resolve modes, implementations can resolve multiple times during rendering, or even bypass writing to the color attachment altogether, as long as the final value is resolved to the resolve attachment. Values in the G, B, and R channels of the color attachment will be written to the Y, CB, and CR channels of the external format image, respectively. Chroma values are calculated as if sampling with a linear filter from the color attachment at full rate, at the location the chroma values sit according to 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkPhysicalDeviceExternalFormatResolvePropertiesANDROID" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
									</a>
                                    ::
                                    <code>externalFormatResolveChromaOffsetX</code>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkPhysicalDeviceExternalFormatResolvePropertiesANDROID" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
									</a>
                                    ::
                                    <code>externalFormatResolveChromaOffsetY</code>
                                    , and the chroma sample rate of the resolved image.
								</p>
							</li>
							<li>
								<p>
                                    No range compression or Y′CBCR model conversion is performed by 
                                    <code>VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID</code>
                                    ; applications have to do these conversions themselves. Value outputs are expected to match those that would be read through a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#textures-sampler-YCbCr-conversion-modelconversion" 
										class="external-link" 
										target="_blank" >
                                        Y′CBCR sampler using 
                                        <code>VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY</code>
									</a>
                                    . The color space that the values should be in is defined by the platform and is not exposed via Vulkan.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is an image view used to write resolved data at the end of rendering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>resolveImageLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the layout that 
                            <code>resolveImageView</code>
                            &nbsp;will be in during rendering.
						</p>
					</li>
					<li>
						<p>
                            If 
                            <code>imageView</code>
                            &nbsp;is not 
                            <code>VK_NULL_HANDLE</code>
                            &nbsp;and 
                            <code>resolveMode</code>
                            &nbsp;is not 
                            <code>VK_RESOLVE_MODE_NONE</code>
                            , 
                            <code>resolveImageLayout</code>
                            &nbsp;must not be 
                            <code>VK_IMAGE_LAYOUT_UNDEFINED</code>
                            , 
                            <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>
                            , 
                            <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>
                            , 
                            <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code>
                            , 
                            <code>VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT</code>
                            , 
                            <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>
                            , or 
                            <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code>
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            From Multisample, to Singlesample.
		</p>
	</li>
	<li>
		<p>
            Combine sample values from a single pixel in a multisample attachment and store the result to the corresponding pixel in a single sample attachment.
		</p>
	</li>
	<li>
		<p>
            Multisample resolve operations for attachments execute in the 
            <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code>
            &nbsp;pipeline stage. A final resolve operation for all pixels in the render area happens-after any recorded command which writes a pixel via the multisample attachment to be resolved or an explicit alias of it in the subpass that it is specified.
		</p>
	</li>
	<li>
		<p>
            Any single sample attachment specified for use in a multisample resolve operation 
			<strong>
                may
			</strong>
            &nbsp;have its contents modified at any point once rendering begins for the render pass instance.
		</p>
	</li>
	<li>
		<p>
            Reads from the multisample attachment can be synchronized with 
            <code>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</code>
            . Access to the single sample attachment can be synchronized with 
            <code>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</code>
            &nbsp;and 
            <code>COLOR_ATTACHMENT_WRITE</code>
            . These pipeline stage and access types are used whether the attachments are color or depth/stencil attachments.
		</p>
	</li>
	<li>
		<p>
            When using render pass objects, a subpass dependency specified with the above pipeline stages and access flags will ensure synchronization with multisample resolve operations for any attachments that were last accessed by that subpass. This allows later subpasses to read resolved values as input attachments.
		</p>
	</li>
	<li>
		<p>
            Resolve operations only update values within the defined render area for the render pass instance. However, any writes performed by a resolve operation (as defined by its access masks) to a given attachment 
			<strong>
                may
			</strong>
            &nbsp;read and write back any memory locations within the image subresource bound for that attachment. For depth/stencil images, if 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-separateDepthStencilAttachmentAccess" 
				class="external-link" 
				target="_blank" >
                <code>separateDepthStencilAttachmentAccess</code>
			</a>
            &nbsp;is 
            <code>VK_FALSE</code>
            , writes to one aspect 
			<strong>
                may
			</strong>
            &nbsp;also result in read-modify-write operations for the other aspect. If the subresource is bound to an attachment with 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-feedbackloop" 
				class="external-link" 
				target="_blank" >
                feedback loop enabled
			</a>
            , implementations 
			<strong>
                must
			</strong>
            &nbsp;not access pixels outside of the render area.
		</p>
	</li>
	<li>
		<p>
            As entire subresources could be accessed by multisample resolve operations, applications cannot safely access values outside of the render area via aliased resources during a render pass instance when a multisample resolve operation is performed.
		</p>
	</li>
	<li>
		<p>
            If 
            <code>RESOLVE_MODE_AVERAGE</code>
            &nbsp;is used, and the source format is a floating-point or normalized type, the sample values for each pixel are resolved with implementation-defined numerical precision.
		</p>
	</li>
	<li>
		<p>
            If the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#formats-numericformat" 
				class="external-link" 
				target="_blank" >
                numeric format
			</a>
            &nbsp;of the resolve attachment uses sRGB encoding, the implementation 
			<strong>
                should
			</strong>
            &nbsp;convert samples from nonlinear to linear before averaging samples as described in the “sRGB EOTF” section of the 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#data-format" 
				class="external-link" 
				target="_blank" >
                Khronos Data Format Specification
			</a>
            . In this case, the implementation 
			<strong>
                must
			</strong>
            &nbsp;convert the linear averaged value to nonlinear before writing the resolved result to resolve attachment.
		</p>
	</li>
	<li>
		<p>
            The resolve mode and store operation are independent; it is valid to write both resolved and unresolved values, and equally valid to discard the unresolved values while writing the resolved ones.
		</p>
	</li>
</ul>
<h5
	id="multisampling-anti-aliasing-msaa" >
    Multisampling Anti-Aliasing (MSAA)
</h5>
<ul>
	<li>
		<p>
            Using only one sample per pixel which is equivalent to no multisampling.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Maximum supported
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can be extracted from 
                    <code>VkPhysicalDeviceProperties</code>
                    &nbsp;associated with our selected physical device.
				</p>
			</li>
			<li>
				<p>
                    The highest sample count that Color Image and Depth Image (Buffer) will be the maximum we can support.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                What to Multisample
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The render target.
				</p>
			</li>
			<li>
				<p>
                    If using a depth image, it should also be multisampled.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The multisampled image should only have one mip level.
				</p>
				<ul>
					<li>
						<p>
                            This is enforced by the Vulkan specification in case of images with more than one sample per pixel.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Multi-sampled images cannot be presented directly.
				</p>
				<ul>
					<li>
						<p>
                            This requirement does not apply to the depth buffer, since it won’t be presented at any point.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                DOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use 4x MSAA if possible; it’s not expensive and provides good image quality improvements.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>loadOp = LOAD_OP_CLEAR</code>
                    &nbsp;or 
                    <code>loadOp = LOAD_OP_DONT_CARE</code>
                    &nbsp;for multisampled images.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>storeOp = STORE_OP_DONT_CARE</code>
                    &nbsp;for multisampled images.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>LAZILY_ALLOCATED</code>
                    &nbsp;memory to back the allocated multisampled images; they do not need to be persisted into main memory and therefore do not need physical backing storage.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>pResolveAttachments</code>
                    &nbsp;in a subpass to automatically resolve a multisampled color buffer into a single-sampled color buffer.
				</p>
			</li>
			<li>
				<p>
                    Use 
					<a
						href="http://khronos.org/registry/vulkan/specs/1.2-khr-extensions/html/chap40.html#VK_KHR_depth_stencil_resolve" 
						class="external-link" 
						target="_blank" >
                        <code>VK_KHR_depth_stencil_resolve</code>
					</a>
                    &nbsp;in a subpass to automatically resolve a multisampled depth buffer into a single-sampled depth buffer. Typically this is only useful if the depth buffer is going to be used further, in most cases it is transient and does not need to be resolved.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Avoid
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Avoid using 
                    <code>vkCmdResolveImage()</code>
                    ; this has a significant negative impact on bandwidth and performance.
				</p>
			</li>
			<li>
				<p>
                    Avoid using 
                    <code>loadOp = LOAD_OP_LOAD</code>
                    &nbsp;for multisampled image attachments.
				</p>
			</li>
			<li>
				<p>
                    Avoid using 
                    <code>storeOp = STORE_OP_STORE</code>
                    &nbsp;for multisampled image attachments.
				</p>
			</li>
			<li>
				<p>
                    Avoid using more than 4x MSAA without checking performance.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Failing to get an inline resolve can result in substantially higher memory bandwidth and reduced performance.
				</p>
				<ul>
					<li>
						<p>
                            Manually writing and resolving a 4x MSAA 1080p surface at 60 FPS requires 3.9GB/s of memory bandwidth compared to just 500MB/s when using an inline resolve.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Sample Shading
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There are certain limitations of our current MSAA implementation which may impact the quality of the output image in more detailed scenes. For example, we're currently not solving potential problems caused by shader aliasing, i.e. MSAA only smoothens out the edges of geometry but not the interior filling. This may lead to a situation when you get a smooth polygon rendered on screen but the applied texture will still look aliased if it contains high contrasting colors. One way to approach this problem is to enable 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap27.html#primsrast-sampleshading" 
						class="external-link" 
						target="_blank" >
                        Sample Shading
					</a>
                    &nbsp;which will improve the image quality even further, though at an additional performance cost:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c"> void createLogicalDevice() {
&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp; deviceFeatures.sampleRateShading = VK_TRUE; // enable sample shading feature for the device
&nbsp;&nbsp;&nbsp;&nbsp; ...
 }
 
 void createGraphicsPipeline() {
&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp; multisampling.sampleShadingEnable = VK_TRUE; // enable sample shading in the pipeline
&nbsp;&nbsp;&nbsp;&nbsp; multisampling.minSampleShading = .2f; // min fraction for sample shading; closer to one is smoother
&nbsp;&nbsp;&nbsp;&nbsp; ...
 }
</code></pre>
		<p>
            <img src="assets/image_20250907201921.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Performance Tests
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    [2025/09/07]
				</p>
				<ul>
					<li>
						<p>
                            Done anyway, very approximate.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    MSAAx8 = 900 fps
				</p>
			</li>
			<li>
				<p>
                    MSAAx4 = 1250fps
				</p>
			</li>
			<li>
				<p>
                    MSAAx2 = 1550fps
				</p>
			</li>
			<li>
				<p>
                    MSAA off = 2100fps
				</p>
			</li>
			<li>
				<p>
                    As samples increase, frame time increases approximately by factors 1.35 (x2), 1.68 (x4) and 2.33 (x8) compared to the case without MSAA — this is consistent with substantial per-sample cost increase, but 
					<strong>
                        is not
					</strong>
                    &nbsp;strictly linear with the number of samples (e.g.: x4 is not exactly 4× nor x8 exactly 8×).
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="fragment-shader" >
    Fragment Shader
</h3>
<ul>
	<li>
		<p>
            Programmable stage.
		</p>
	</li>
	<li>
		<p>
            Is invoked for every fragment that survives and determines which framebuffer(s) the fragments are written to and with which color and depth values. It can do this using the interpolated data from the vertex shader, which can include things like texture coordinates and normals for lighting.
		</p>
	</li>
	<li>
		<p>
            The 
            <code>VkShaderModule</code>
            &nbsp;objects are created from shader byte code.
		</p>
	</li>
</ul>
<h3
	id="color-blending" >
    Color Blending
</h3>
<ul>
	<li>
		<p>
            Fixed-function stage.
		</p>
	</li>
	<li>
		<p>
            Controls how the GPU combines the fragment shader’s output with what is already in the framebuffer.
		</p>
	</li>
	<li>
		<p>
            Applies operations to mix different fragments that map to the same pixel in the framebuffer. Fragments can simply overwrite each other, add up or be mixed based upon transparency.
		</p>
	</li>
	<li>
		<p>
            After a fragment shader has returned a color, it needs to be combined with the color that is already in the framebuffer.
		</p>
	</li>
	<li>
		<p>
            This transformation is known as color blending, and there are two ways to do it:
		</p>
		<ul>
			<li>
				<p>
                    Mix the old and new value to produce a final color
				</p>
			</li>
			<li>
				<p>
                    Combine the old and new value using a bitwise operation
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If enabled blending in the pipeline, it will blend the frag shader result with the render_target previous visual.
				</p>
			</li>
			<li>
				<p>
                    So if the frag result has alpha &lt; 1.0, it will blend the clear color with the frag shader result, giving it a &quot;transparent visual&quot; against the clear color.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendAttachmentState.html" 
				class="external-link" 
				target="_blank" >
                <code>vkPipelineColorBlendAttachmentState</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Contains the configuration per attached framebuffer.
				</p>
			</li>
			<li>
				<p>
                    This per-framebuffer struct allows you to configure the first way of color blending:
				</p>
<pre><code class="language-c" data-lang="c"> // Pseudo-code
 if (blendEnable) {
&nbsp;&nbsp;&nbsp;&nbsp; finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);
&nbsp;&nbsp;&nbsp;&nbsp; finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);
 } else {
&nbsp;&nbsp;&nbsp;&nbsp; finalColor = newColor;
 }
 
 finalColor = finalColor & colorWriteMask;
</code></pre>
			</li>
			<li>
				<p>
                    The most common way to use color blending is to implement alpha blending, where we want the new color to be blended with the old color based on its opacity.
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>finalColor</code>
                            &nbsp;should then be computed as follows:
						</p>
<pre><code class="language-c" data-lang="c"> finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor;
 finalColor.a = newAlpha.a;
</code></pre>
					</li>
					<li>
						<p>
                            This can be achieved with the following parameters:
						</p>
<pre><code class="language-cpp" data-lang="cpp"> colorBlendAttachment.blendEnable = vk::True;
 colorBlendAttachment.srcColorBlendFactor = vk::BlendFactor::eSrcAlpha;
 colorBlendAttachment.dstColorBlendFactor = vk::BlendFactor::eOneMinusSrcAlpha;
 colorBlendAttachment.colorBlendOp = vk::BlendOp::eAdd;
 colorBlendAttachment.srcAlphaBlendFactor = vk::BlendFactor::eOne;
 colorBlendAttachment.dstAlphaBlendFactor = vk::BlendFactor::eZero;
 colorBlendAttachment.alphaBlendOp = vk::BlendOp::eAdd;
</code></pre>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>blendEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            If set to 
                            <code>FALSE</code>
                            , then the new color from the fragment shader is passed through unmodified. Otherwise, the two mixing operations are performed to compute a new color.
						</p>
					</li>
					<li>
						<p>
                            The resulting color is AND’d with the 
                            <code>colorWriteMask</code>
                            &nbsp;to determine which channels are actually passed through.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendStateCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineColorBlendStateCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Contains the 
					<em>
                        global
					</em>
                    &nbsp;color blending settings.
				</p>
			</li>
			<li>
				<p>
                    References the array of structures for all the framebuffers and allows you to set blend constants that you can use as blend factors in the aforementioned calculations.
				</p>
			</li>
			<li>
				<p>
                    <code>attachmentCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of 
                            <code>VkPipelineColorBlendAttachmentState</code>
                            &nbsp;elements in 
                            <code>pAttachments</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            It is ignored if the pipeline is created with 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ENABLET</code>
                            , 
                            <code>DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT</code>
                            , and 
                            <code>DYNAMIC_STATE_COLOR_WRITE_MASK_EXT</code>
                            &nbsp;dynamic states set, and either 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT</code>
                            &nbsp;set or the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-advancedBlendCoherentOperations" 
								class="external-link" 
								target="_blank" >
                                advancedBlendCoherentOperations
							</a>
                            &nbsp;feature is not enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAttachments</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkPipelineColorBlendAttachmentState</code>
                            &nbsp;structures defining blend state for each color attachment.
						</p>
					</li>
					<li>
						<p>
                            It is ignored if the pipeline is created with 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ENABLET</code>
                            , 
                            <code>DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT</code>
                            , and 
                            <code>DYNAMIC_STATE_COLOR_WRITE_MASK_EXT</code>
                            &nbsp;dynamic states set, and either 
                            <code>DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT</code>
                            &nbsp;set or the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-advancedBlendCoherentOperations" 
								class="external-link" 
								target="_blank" >
                                advancedBlendCoherentOperations
							</a>
                            &nbsp;feature is not enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>logicOpEnable</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls whether to apply 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#framebuffer-logicop" 
								class="external-link" 
								target="_blank" >
                                Logical Operations
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>logicOp</code>
				</p>
				<ul>
					<li>
						<p>
                            Selects which logical operation to apply.
						</p>
					</li>
					<li>
						<p>
                            If you want to use the second method of blending (a bitwise combination), then you should set 
                            <code>logicOpEnable</code>
                            &nbsp;to 
                            <code>TRUE</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Note that this will automatically disable the first method, as if you had set 
                                    <code>blendEnable</code>
                                    &nbsp;to 
                                    <code>FALSE</code>
                                    &nbsp;for every attached framebuffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>colorWriteMask</code>
                            &nbsp;will also be used in this mode to determine which channels in the framebuffer will actually be affected.
						</p>
					</li>
					<li>
						<p>
                            If disabled both modes, the fragment colors will be written to the framebuffer unmodified.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>blendConstants</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#framebuffer-blendfactors" 
								class="external-link" 
								target="_blank" >
                                blend factor
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="creation" >
    Creation
</h3>
<h5
	id="setup" >
    Setup
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>vkGraphicsPipelineCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>DISABLE_OPTIMIZATION</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies that the created pipeline will not be optimized.
								</p>
							</li>
							<li>
								<p>
                                    Using this flag 
									<strong>
                                        may
									</strong>
                                    &nbsp;reduce the time taken to create the pipeline.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>renderPass</code>
				</p>
				<ul>
					<li>
						<p>
                            Is set to 
                            <code>nullptr</code>
                            &nbsp;because we’re using dynamic rendering instead of a traditional render pass.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>basePipelineHandle</code>
				</p>
			</li>
			<li>
				<p>
                    <code>basePipelineIndex</code>
				</p>
			</li>
			<li>
				<p>
					<em>
                        Graphics Pipelines Inheritance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Vulkan allows you to create a new graphics pipeline by deriving from an existing pipeline.
						</p>
					</li>
					<li>
						<p>
                            The idea of pipeline derivatives is that it is less expensive to set up pipelines when they have much functionality in common with an existing pipeline and switching between pipelines from the same parent can also be done quicker.
						</p>
					</li>
					<li>
						<p>
                            You can either specify the handle of an existing pipeline with 
                            <code>basePipelineHandle</code>
                            &nbsp;or reference another pipeline that is about to be created by index with 
                            <code>basePipelineIndex</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            These values are only used if the 
                            <code>VPIPELINE_CREATE_DERIVATIVE</code>
                            &nbsp;flag is also specified in the 
                            <code>flags</code>
                            &nbsp;field of 
                            <code>VkGraphicsPipelineCreateInfo</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCreateGraphicsPipelines()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>device</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the logical device that creates the graphics pipelines.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pipelineCache</code>
				</p>
				<ul>
					<li>
						<p>
                            Is either 
                            <code>NULL_HANDLE</code>
                            , indicating that pipeline caching is disabled, or to enable caching, the handle of a valid 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCache.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineCache
							</a>
                            &nbsp;object. The implementation 
							<strong>
                                must
							</strong>
                            &nbsp;not access this object outside of the duration of this command.
						</p>
					</li>
					<li>
						<p>
                            A pipeline cache can be used to store and reuse data relevant to pipeline creation across multiple calls to 
                            <code>vkCreateGraphicsPipelines</code>
                            &nbsp;and even across program executions if the cache is stored to a file. This makes it possible to significantly speed up pipeline creation at a later time.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>createInfoCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the length of the 
                            <code>pCreateInfos</code>
                            &nbsp;and 
                            <code>pPipelines</code>
                            &nbsp;arrays.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pCreateInfos</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkGraphicsPipelineCreateInfo
							</a>
                            &nbsp;structures.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAllocator</code>
				</p>
				<ul>
					<li>
						<p>
                            Controls host memory allocation as described in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-allocation" 
								class="external-link" 
								target="_blank" >
                                Memory Allocation
							</a>
                            &nbsp;chapter.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pPipelines</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipeline.html" 
								class="external-link" 
								target="_blank" >
                                VkPipeline
							</a>
                            &nbsp;handles in which the resulting graphics pipeline objects are returned.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="dynamic-rendering-extra-steps" >
    Dynamic Rendering Extra Steps
</h5>
<ul>
	<li>
		<p>
            Changes to the 
            <code>vkGraphicsPipelineCreateInfo</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>vkGraphicsPipelineCreateInfo</code>
                    &nbsp;must be created without a 
                    <code>VkRenderPass</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>VkPipelineRenderingCreateInfo</code>
                    &nbsp;must be included in the 
                    <code>pNext</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If a graphics pipeline is created with a valid 
                            <code>VkRenderPass</code>
                            , the parameters of the 
                            <code>VkPipelineRenderingCreateInfo</code>
                            &nbsp;are ignored.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRenderingCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineRenderingCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>colorAttachmentCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of entries in 
                            <code>pColorAttachmentFormats</code>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pColorAttachmentFormats</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkFormat</code>
                            &nbsp;values defining the format of color attachments used in this pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>depthAttachmentFormat</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
                            <code>VkFormat</code>
                            &nbsp;value defining the format of the depth attachment used in this pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>stencilAttachmentFormat</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
                            <code>VkFormat</code>
                            &nbsp;value defining the format of the stencil attachment used in this pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>viewMask</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a bitfield of view indices describing which views are active during rendering.
						</p>
					</li>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;match 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderingInfo.viewMask
							</a>
                            &nbsp;when rendering.
						</p>
						<ul>
							<li>
								<p>
                                    As defined in 
                                    <code>VkRenderingInfo</code>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Is a bitfield of view indices describing which views are active during rendering, when it is not 
                                            <code>0</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            If 
                                            <code>viewMask</code>
                                            &nbsp;is not 
                                            <code>0</code>
                                            , multiview is enabled.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Formats
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If 
                            <code>depthAttachmentFormat</code>
                            , 
                            <code>stencilAttachmentFormat</code>
                            , or any element of 
                            <code>pColorAttachmentFormats</code>
                            &nbsp;is 
                            <code>UNDEFINED</code>
                            , it indicates that the corresponding attachment is unused within the render pass.
						</p>
					</li>
					<li>
						<p>
                            Valid formats indicate that an attachment 
							<strong>
                                can
							</strong>
                            &nbsp;be used - but it is still valid to set the attachment to 
                            <code>NULL</code>
                            &nbsp;when beginning rendering.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="managing-pipelines-and-reducing-overhead" >
    Managing Pipelines and Reducing overhead
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://devblogs.nvidia.com/vulkan-dos-donts/" 
				class="external-link" 
				target="_blank" >
                Tips and Tricks: Vulkan Dos and Don’ts
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Use pipeline cache.
				</p>
			</li>
			<li>
				<p>
                    Use specialization constants.
				</p>
				<ul>
					<li>
						<p>
                            This may cause a possible decrease in the number of instructions and registers used by the shader.
						</p>
					</li>
					<li>
						<p>
                            Specialization constants can also be used instead of offline shader permutations to minimize the amount of bytecode that needs to be shipped with an application.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Switching pipelines:
				</p>
				<ul>
					<li>
						<p>
                            Avoid frequently switching between pipelines that use different sets of pipeline stages.
						</p>
					</li>
					<li>
						<p
							class="line-emphasis" >
                            Minimize the number of 
                            <code>vkCmdBindPipeline</code>
                            &nbsp;calls, each call has significant CPU cost and GPU cost.
						</p>
						<ul>
							<li>
								<p
									class="line-emphasis" >
                                    Consider 
									<em>
                                        sorting
									</em>
                                    &nbsp;of drawcalls and/or using a low number of dynamic states.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Switching on/off the tessellation, geometry, task and mesh shaders is an expensive operation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Draw calls:
				</p>
				<ul>
					<li>
						<p>
                            Group draw calls, taking into account what kinds of shaders they use.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h6
	id="the-problem" >
    The Problem
</h6>
<ul>
	<li>
		<p>
            Immutable Pipelines.
		</p>
	</li>
	<li>
		<p>
            Each combination of inputs require a dedicated pipeline.
		</p>
		<ul>
			<li>
				<p>
                    Shader, topology, blend mode, vertex layout, cull mode, etc.
				</p>
			</li>
			<li>
				<p>
                    So if we want to do things like toggle depth-testing on and off, we will need 2 pipelines.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Causes a combinatorial explosion of variants.
		</p>
		<ul>
			<li>
				<p>
                    10.000's of pipelines for shipping titles.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Building pipelines is a very expensive operation, and we want to minimize the number of pipelines used as its critical for performance.
		</p>
	</li>
</ul>
<h6
	id="my-decisions" >
    My decisions
</h6>
<ul>
	<li>
		<p>
            [2025/08/10]
		</p>
	</li>
	<li>
		<p>
            Dynamic State is a must.
		</p>
	</li>
	<li>
		<p>
            The use of Shader Object still seems new and may introduce some extra complexity in certain cases.
		</p>
		<ul>
			<li>
				<p>
                    I don't know about mobile support.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The use of Graphics Pipeline Libraries sounds interesting, but at the same time it seems limiting in some moments, for Geometry and Tessellation Shaders.
		</p>
		<ul>
			<li>
				<p>
                    I don't know about mobile support.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Overall, I believe that refactoring a game object to use Shader Object or Graphics Pipeline Libraries sounds &quot;simple&quot;, since it's more about how the pipeline is constructed than how one interacts with shaders or descriptor sets. In other words, it seems like an okay decision to make in the future.
		</p>
	</li>
	<li>
		<p>
            Considering the low support, and the fact that I don't have so many pipelines in mind that actually make these solutions necessary, I prefer to use graphics pipelines manually, in the &quot;default&quot; way.
		</p>
	</li>
	<li>
		<p>
            Regardless, I believe that using Shader Object or Graphics Pipeline 
			<em>
                does not
			</em>
            &nbsp;remove the need to worry about pipeline caching or precautions to avoid switching the pipeline binding all the time.
		</p>
		<ul>
			<li>
				<p>
                    Correct. Extensions change how pipelines are created/linked but do not remove the performance considerations around pipeline creation, pipeline cache usage, or minimizing pipeline re-binding at draw time. Vendors and platform docs recommend pipeline caches, pre-creation, and minimizing pipeline binds.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            What I will do, therefore: caching and sorting of pipelines based on similarity. I will worry more about binding the pipeline in command buffers and their descriptor sets, than the process of facilitating the creation of new pipelines.
		</p>
		<ul>
			<li>
				<p>
                    This plan aligns with widely recommended practical strategies: use pipeline caches (persist to disk where possible), sort and batch by pipeline/descriptor similarity, and create pipelines asynchronously (background threads) to avoid stutter. These practices address the main runtime pain points regardless of whether you later adopt shader-object or pipeline-library extensions.
				</p>
			</li>
			<li>
				<p>
                    Your current decisions are internally consistent and align with common, pragmatic industry practice: prefer stable/default graphics pipelines with pipeline caching, sorting, and background creation as the primary strategy, while keeping code organized so you can adopt 
                    <code>VK_EXT_shader_object</code>
                    &nbsp;or 
                    <code>VK_EXT_graphics_pipeline_library</code>
                    &nbsp;later if/when device support and measured benefits justify the switch.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="mutability-with-codevkdynamicstate-code" >
    Mutability with 
    <code>VkDynamicState</code>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            Implemented.
		</p>
	</li>
	<li>
		<p>
            It's a 
			<em>
                must
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Not everything has to be immutable.
		</p>
	</li>
	<li>
		<p>
            Set desired state while recording command buffers.
		</p>
	</li>
	<li>
		<p>
            Over 70 states can be dynamic.
		</p>
	</li>
	<li>
		<p>
            If we don't use this, we would need to create new pipelines if we wanted to change the resolution of our rendering.
		</p>
	</li>
</ul>
<h5
	id="no-pipelines-with-codevk_ext_shader_object-code" >
    No pipelines, with 
    <code>VK_EXT_shader_object</code>
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/features/latest/features/proposals/VK_EXT_shader_object.html" 
				class="external-link" 
				target="_blank" >
                VK_EXT_shader_object
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/shader_object/README.html#_overview" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/blog/you-can-use-vulkan-without-pipelines-today" 
				class="external-link" 
				target="_blank" >
                Article
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_EXT_shader_object" 
						class="external-link" 
						target="_blank" >
                        Coverage
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    [2025/09/08] 11.29%.
				</p>
				<ul>
					<li>
						<p>
                            33.8% Windows.
						</p>
					</li>
					<li>
						<p>
                            26.3% Linux.
						</p>
					</li>
					<li>
						<p>
                            0% Android.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/vQPN3I040Cs?si=lLHBYbfTle9RHQSx&t=452" 
				class="external-link" 
				target="_blank" >
                Shader Object and implementation in Odin {7:30 -&gt; 11:56}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Questions
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            I don't know where 
                            <code>pColorAttachmentFormats</code>
                            &nbsp;and 
                            <code>depthAttachmentFormat</code>
                            &nbsp;are specified.
						</p>
						<ul>
							<li>
								<p>
                                    I don't know if it's even necessary to specify them anywhere.
								</p>
							</li>
							<li>
								<p>
                                    The words 
                                    <code>attachment</code>
                                    &nbsp;or 
                                    <code>format</code>
                                    &nbsp;do not appear anywhere in the sample or in the spec of the extension.
								</p>
							</li>
						</ul>
					</li>
				</ul>
<pre><code class="language-odin" data-lang="odin">&nbsp;&nbsp;&nbsp;&nbsp; pipeline_rendering_create_info := vk.PipelineRenderingCreateInfo{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = .PIPELINE_RENDERING_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colorAttachmentCount&nbsp;&nbsp;&nbsp;&nbsp;= 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pColorAttachmentFormats = format,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depthAttachmentFormat&nbsp;&nbsp; = .D24_UNORM_S8_UINT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stencilAttachmentFormat = {},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; viewMask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0,
&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/nadako/hello-vulkan-odin/blob/master/src/main.odin" 
						class="external-link" 
						target="_blank" >
                        Code
					</a>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin"> create_shaders :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp; push_constant_ranges := []vk.PushConstantRange {&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stageFlags = {.VERTEX, .FRAGMENT},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = 128,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; This is not used in the Shader Object.
&nbsp;&nbsp;&nbsp;&nbsp; The only place that needs this in its code, is when making the call `vk.CmdPushConstants(cmd, g.pipeline_layout, {.VERTEX, .FRAGMENT}, 0, size_of(push), &push)`.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp; pipeline_layout_ci := vk.PipelineLayoutCreateInfo {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType = .PIPELINE_LAYOUT_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // flags                  = {},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setLayoutCount         = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pSetLayouts            = {},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushConstantRangeCount = u32(len(push_constant_ranges)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPushConstantRanges = raw_data(push_constant_ranges),
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; vk_check(vk.CreatePipelineLayout(g.device, &pipeline_layout_ci, nil, &g.pipeline_layout))&nbsp;&nbsp;// Pipeline
 
 
&nbsp;&nbsp;&nbsp;&nbsp; vert_code := load_file("shaders/shader.vert.spv", context.temp_allocator)&nbsp;&nbsp;// Shader_Info
&nbsp;&nbsp;&nbsp;&nbsp; frag_code := load_file("shaders/shader.frag.spv", context.temp_allocator)&nbsp;&nbsp;// Shader_Info
&nbsp;&nbsp;&nbsp;&nbsp; shader_cis := [2]vk.ShaderCreateInfoEXT {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType = .SHADER_CREATE_INFO_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; codeType = .SPIRV,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; codeSize = len(vert_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCode = raw_data(vert_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pName = "main",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stage = {.VERTEX},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextStage = {.FRAGMENT},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags = {.LINK_STAGE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setLayoutCount:         u32,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     // pSetLayouts:            [^]DescriptorSetLayout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushConstantRangeCount = u32(len(push_constant_ranges)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPushConstantRanges = raw_data(push_constant_ranges),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pSpecializationInfo:    ^SpecializationInfo,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType = .SHADER_CREATE_INFO_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; codeType = .SPIRV,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; codeSize = len(frag_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCode = raw_data(frag_code),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pName = "main",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stage = {.FRAGMENT},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // nextStage:              ShaderStageFlags,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags = {.LINK_STAGE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setLayoutCount:         u32,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     // pSetLayouts:            [^]DescriptorSetLayout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushConstantRangeCount = u32(len(push_constant_ranges)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPushConstantRanges = raw_data(push_constant_ranges),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pSpecializationInfo:    ^SpecializationInfo,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; vk_check(vk.CreateShadersEXT(g.device, 2, raw_data(&shader_cis), nil, raw_data(&g.shaders)))
 }
 
 destroy_shaders :: proc() {
&nbsp;&nbsp;&nbsp;&nbsp; vk.DestroyPipelineLayout(g.device, g.pipeline_layout, nil)
&nbsp;&nbsp;&nbsp;&nbsp; for shader in g.shaders do vk.DestroyShaderEXT(g.device, shader, nil)
 }
 
 render :: proc(cmd: vk.CommandBuffer) {
&nbsp;&nbsp;&nbsp;&nbsp; shader_stages := [2]vk.ShaderStageFlags { {.VERTEX}, {.FRAGMENT} }
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdBindShadersEXT(cmd, 2, raw_data(&shader_stages), raw_data(&g.shaders))
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetVertexInputEXT(cmd, 0, nil, 0, nil) // Shader_Info: vk.VertexInputBindingDescription, vk.VertexInputAttributeDescription.
 
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetViewportWithCount(cmd, 1, &vk.Viewport {&nbsp;&nbsp;// Dynamic
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = f32(g.swapchain.width),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = f32(g.swapchain.height),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minDepth = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxDepth = 1,
&nbsp;&nbsp;&nbsp;&nbsp; })
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetScissorWithCount(cmd, 1, &vk.Rect2D {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extent = {width = g.swapchain.width, height = g.swapchain.height}&nbsp;&nbsp;// Dynamic
&nbsp;&nbsp;&nbsp;&nbsp; })
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetRasterizerDiscardEnable(cmd, false) // Pipeline
 
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetPrimitiveTopology(cmd, .TRIANGLE_LIST)&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetPrimitiveRestartEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
 
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetRasterizationSamplesEXT(cmd, {._1})&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; sample_mask := vk.SampleMask(1)
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetSampleMaskEXT(cmd, {._1}, &sample_mask) // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetAlphaToCoverageEnableEXT(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
 
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetPolygonModeEXT(cmd, .FILL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetCullMode(cmd, {})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetFrontFace(cmd, .COUNTER_CLOCKWISE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
 
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetDepthTestEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetDepthWriteEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetDepthBiasEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetStencilTestEnable(cmd, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipeline
 
&nbsp;&nbsp;&nbsp;&nbsp; b32_false := b32(false)
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetColorBlendEnableEXT(cmd, 0, 1, &b32_false) // Pipeline
 
&nbsp;&nbsp;&nbsp;&nbsp; color_mask := vk.ColorComponentFlags { .R, .G, .B, .A }
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdSetColorWriteMaskEXT(cmd, 0, 1, &color_mask)&nbsp;&nbsp;// Pipeline
 
&nbsp;&nbsp;&nbsp;&nbsp; Push :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color: [3]f32,
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; push := Push { color = { 0, 0.5, 0 } }
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdPushConstants(cmd, g.pipeline_layout, {.VERTEX, .FRAGMENT}, 0, size_of(push), &push)
&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; // vk.CmdBindDescriptorSets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Dynamic
 
&nbsp;&nbsp;&nbsp;&nbsp; vk.CmdDraw(cmd, 3, 1, 0, 0)
 }
</code></pre>
	</li>
	<li>
		<p>
            Ditch pipelines entirely.
		</p>
	</li>
	<li>
		<p>
            Bind compiled shader stages.
		</p>
	</li>
	<li>
		<p>
            It was created primarily for the Nintendo Switch, to reduce the performance gap between Vulkan and NVN (the Switch's native API), which doesn't even have the concept of pipeline state objects and map almost 1:1 to how Nvidia hardware works.
		</p>
	</li>
	<li>
		<p>
            If you want to use Shader Objects, the reason should be &quot;I find it much easier to use/maintain&quot;. Because once you grow you'll encounter friction as the extension is meant for porting old engines, and goes against new features.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Hard to recommend, as for limited support.
				</p>
			</li>
			<li>
				<p>
                    Currently only available on AMD &amp; Nvidia.
				</p>
			</li>
			<li>
				<p>
                    It provides an emulation layer, which make them usable on any device not natively supporting them. but you need to provide the dll file for the layer along with the application.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Shaders
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This extension introduces a new object type 
                    <code>VkShaderEXT</code>
                    &nbsp;which represents a single compiled shader stage. 
                    <code>VkShaderEXT</code>
                    &nbsp;objects may be created either independently or linked with other 
                    <code>VkShaderEXT</code>
                    &nbsp;objects created at the same time. To create 
                    <code>VkShaderEXT</code>
                    &nbsp;objects, applications call 
                    <code>vkCreateShadersEXT()</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    This function compiles the source code for one or more shader stages into 
                    <code>VkShaderEXT</code>
                    &nbsp;objects.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Optional Linking
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Whenever 
                            <code>createInfoCount</code>
                            &nbsp;is greater than one, the shaders being created may optionally be linked together. Linking allows the implementation to perform cross-stage optimizations based on a promise by the application that the linked shaders will always be used together.
						</p>
					</li>
					<li>
						<p>
                            Though a set of linked shaders may perform anywhere between the same to substantially better than equivalent unlinked shaders, this tradeoff is left to the application and linking is never mandatory.
						</p>
					</li>
					<li>
						<p>
                            To specify that shaders should be linked, include the 
                            <code>VK_SHADER_CREATE_LINK_STAGE_BIT_EXT</code>
                            &nbsp;flag in each of the 
                            <code>VkShaderCreateInfoEXT</code>
                            &nbsp;structures passed to 
                            <code>vkCreateShadersEXT()</code>
                            . The presence or absence of 
                            <code>VK_SHADER_CREATE_LINK_STAGE_BIT_EXT</code>
                            &nbsp;must match across all 
                            <code>VkShaderCreateInfoEXT</code>
                            &nbsp;structures passed to a single 
                            <code>vkCreateShadersEXT()</code>
                            &nbsp;call: i.e., if any member of 
                            <code>pCreateInfos</code>
                            &nbsp;includes 
                            <code>VK_SHADER_CREATE_LINK_STAGE_BIT_EXT</code>
                            &nbsp;then all other members must include it too. 
                            <code>VK_SHADER_CREATE_LINK_STAGE_BIT_EXT</code>
                            &nbsp;is ignored if 
                            <code>createInfoCount</code>
                            &nbsp;is one, and a shader created this way is considered unlinked.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The stage of the shader being compiled is specified by 
                    <code>stage</code>
                    . Applications must also specify which stage types will be allowed to immediately follow the shader being created. For example, a vertex shader might specify a 
                    <code>nextStage</code>
                    &nbsp;value of 
                    <code>VK_SHADER_STAGE_FRAGMENT_BIT</code>
                    &nbsp;to indicate that the vertex shader being created will always be followed by a fragment shader (and never a geometry or tessellation shader). Applications that do not know this information at shader creation time or need the same shader to be compatible with multiple subsequent stages can specify a mask that includes as many valid next stages as they wish. For example, a vertex shader can specify a 
                    <code>nextStage</code>
                    &nbsp;mask of 
                    <code>VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_FRAGMENT_BIT</code>
                    &nbsp;to indicate that the next stage could be either a geometry shader or fragment shader (but not a tessellation shader).
				</p>
			</li>
			<li>
				<p>
                    etc, see the 
					<a
						href="https://docs.vulkan.org/features/latest/features/proposals/VK_EXT_shader_object.html#_shaders" 
						class="external-link" 
						target="_blank" >
                        spec
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="reducing-compilation-overhead-with-codevk_ext_graphics_pipeline_libraries-code" >
    Reducing compilation overhead, with 
    <code>VK_EXT_graphics_pipeline_libraries</code>
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/features/latest/features/proposals/VK_EXT_graphics_pipeline_library.html" 
				class="external-link" 
				target="_blank" >
                VK_EXT_graphics_pipeline_library
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/graphics_pipeline_library/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Release: [2022/06/03].
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_EXT_graphics_pipeline_library" 
						class="external-link" 
						target="_blank" >
                        Coverage
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    [2025/09/08] 18.7% coverage.
				</p>
				<ul>
					<li>
						<p>
                            40.7% Windows.
						</p>
					</li>
					<li>
						<p>
                            40.6% Linux.
						</p>
					</li>
					<li>
						<p>
                            4.88% Android.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.khronos.org/blog/reducing-draw-time-hitching-with-vk-ext-graphics-pipeline-library" 
				class="external-link" 
				target="_blank" >
                Extra info
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I've read until the Dynamic State header.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Allows separate compilation of different parts of the graphics pipeline. With this it’s now possible to split up the monolithic pipeline creation into different steps and re-use common parts shared across different pipelines.
		</p>
	</li>
	<li>
		<p>
            Compared to monolithic pipeline state, this results in faster pipeline creation times, making this extension a good fit for applications and games that do a lot of pipeline creation at runtime.
		</p>
	</li>
	<li>
		<p>
            Libraries are partial pipeline objects which cannot be bound directly; they are linked together to form a final executable pipeline.
		</p>
	</li>
	<li>
		<p>
            Encourages reuse of compilation work and reduces startup/runtime stutter for games with many similar pipelines.
		</p>
	</li>
	<li>
		<p>
            Because libraries are precompiled partial pipelines, linking is generally cheaper than compiling whole pipelines from scratch.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Individual pipelines stages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The monolithic pipeline state has been split into distinct parts that can be compiled independently.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Vertex Input Interface
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains the information that would normally be provided to the full pipeline state object by VkPipelineVertexInputStateCreateInfo and VkPipelineInputAssemblyStateCreateInfo.
						</p>
					</li>
					<li>
						<p>
                            &quot;For our engine, this information is not known until draw time, so a pipeline for this stage is still hashed and created at draw time.&quot;
						</p>
					</li>
					<li>
						<p>
                            This stage has no shader code and thus the driver can create it quickly and there are also a fairly small number of these objects.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Pre-Rasterization Shaders
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains vertex, tessellation, and geometry shader stages along with the state associated with 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineViewportStateCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineViewportStateCreateInfo
							</a>
                            , 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineRasterizationStateCreateInfo
							</a>
                            , 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineTessellationStateCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineTessellationStateCreateInfo
							</a>
                            , and 
							<a
								href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPass.html" 
								class="external-link" 
								target="_blank" >
                                VkRenderPass
							</a>
                            &nbsp;(or dynamic rendering).
						</p>
					</li>
					<li>
						<p>
                            The only information you actually need to create the pre-rasterization shader is the SPIR-V code and pipeline layout.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Fragment Shader
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains the fragment shader along with the state in VkPipelineDepthStencilStateCreateInfo and VkRenderPass (or dynamic rendering - although in that case only the viewMask is required).
						</p>
					</li>
					<li>
						<p>
                            If combined with dynamic rendering you can create the fragment shader pipeline with only the SPIR-V and the pipeline layout.
                            <br>
                            This allows the driver to do the heavy lifting of lowering to hardware instructions for the pre-rasterization and fragment shaders with very little information.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Fragment Output Interface
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Contains the VkPipelineColorBlendStateCreateInfo, VkPipelineMultisampleStateCreateInfo, and VkRenderPass (or dynamic rendering)
						</p>
					</li>
					<li>
						<p>
                            Like with the Vertex Input Interface, this stage requires information that we don’t know until draw time, so this state is also hashed and the Fragment Output Interface pipeline is created at draw time.
						</p>
					</li>
					<li>
						<p>
                            It is expected to be very quick to create and also relatively small in number.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Final link
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    With all four individual pipeline library stages created, an application can perform a final link to a full pipeline. This final link is expected to be extremely fast - the driver will have done the shader compilation for the individual stages and thus the link can be performed at draw time at a reasonable cost.
				</p>
			</li>
			<li>
				<p>
                    This is where the big benefit of the extension comes in: we’ve pre-created all of our pre-rasterization and fragment shaders, hashed the small number of vertex input/fragment output interfaces, and can on-demand create a fast linked pipeline library at draw time, thus avoiding a dreaded hitch.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If shader compilation stutter is your concern, this extension is the way to go. This extension lets you create partially-constructed PSOs (Pipeline State Objects) (e.g. one for Vertex another for Pixel Shader), and then combine them to generate the final PSO. This allows splitting the huge monolithic block into smaller monolithic blocks that are easier to handle and design around, making the API more D3D11-like (D3D11 has monolithic Rasterizer State blocks and Blend State blocks).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Creating pipeline libraries
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Creating a pipeline library (part) is similar to creating a pipeline, with the difference that you only need to specify the properties required for that specific pipeline state.
				</p>
				<ul>
					<li>
						<p>
                            E.g. for the vertex input interface you only specify input assembly and vertex input state, which is all required to define the interfaces to a vertex shader.
						</p>
					</li>
				</ul>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp"> VkGraphicsPipelineLibraryCreateInfoEXT library_info{};
 library_info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
 library_info.flags = VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT;
 
 VkPipelineInputAssemblyStateCreateInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input_assembly_state&nbsp;&nbsp;= vkb::initializers::pipeline_input_assembly_state_create_info(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, 0, VK_FALSE);
 VkPipelineVertexInputStateCreateInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertex_input_state&nbsp;&nbsp;&nbsp;&nbsp;= vkb::initializers::pipeline_vertex_input_state_create_info();
 std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = {
&nbsp;&nbsp;&nbsp;&nbsp; vkb::initializers::vertex_input_binding_description(0, sizeof(Vertex), VK_VERTEX_INPUT_RATE_VERTEX),
 };
 std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = {
&nbsp;&nbsp;&nbsp;&nbsp; vkb::initializers::vertex_input_attribute_description(0, 0, VK_FORMAT_R32G32B32_SFLOAT, 0),
&nbsp;&nbsp;&nbsp;&nbsp; vkb::initializers::vertex_input_attribute_description(0, 1, VK_FORMAT_R32G32B32_SFLOAT, sizeof(float) * 3),
&nbsp;&nbsp;&nbsp;&nbsp; vkb::initializers::vertex_input_attribute_description(0, 2, VK_FORMAT_R32G32_SFLOAT, sizeof(float) * 6),
 };
 vertex_input_state.vertexBindingDescriptionCount&nbsp;&nbsp; = static_cast&lt;uint32_t&gt;(vertex_input_bindings.size());
 vertex_input_state.pVertexBindingDescriptions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= vertex_input_bindings.data();
 vertex_input_state.vertexAttributeDescriptionCount = static_cast&lt;uint32_t&gt;(vertex_input_attributes.size());
 vertex_input_state.pVertexAttributeDescriptions&nbsp;&nbsp;&nbsp;&nbsp;= vertex_input_attributes.data();
 
 VkGraphicsPipelineCreateInfo pipeline_library_create_info{};
 pipeline_library_create_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
 pipeline_library_create_info.flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = VK_PIPELINE_CREATE_LIBRARY_BIT_KHR | VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
 pipeline_library_create_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
 pipeline_library_create_info.pNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &library_info;
 pipeline_library_create_info.pInputAssemblyState = &input_assembly_state;
 pipeline_library_create_info.pVertexInputState&nbsp;&nbsp; = &vertex_input_state;
 
 vkCreateGraphicsPipelines(get_device().get_handle(), pipeline_cache, 1, &pipeline_library_create_info, nullptr, &pipeline_library.vertex_input_interface);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Deprecating shader modules
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    With this extension, creating shader modules with 
                    <code>vkCreateShaderModule</code>
                    &nbsp;has been deprecated and you can instead just pass the shader module create info via 
                    <code>pNext</code>
                    &nbsp;into your pipeline shader stage create info. This change bypasses a useless copy and is recommended.
				</p>
			</li>
			<li>
				<p>
                    You can see this in the pre-rasterization and fragment shader library setup parts of the sample below.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp"> VkShaderModuleCreateInfo shader_module_create_info{};
 shader_module_create_info.sType&nbsp;&nbsp;&nbsp;&nbsp;= VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
 shader_module_create_info.codeSize = static_cast&lt;uint32_t&gt;(spirv.size()) * sizeof(uint32_t);
 shader_module_create_info.pCode&nbsp;&nbsp;&nbsp;&nbsp;= spirv.data();
 
 VkPipelineShaderStageCreateInfo shader_Stage_create_info{};
 shader_Stage_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
 // Chain the shader module create info
 shader_Stage_create_info.pNext = &shader_module_create_info;
 shader_Stage_create_info.stage = VK_SHADER_STAGE_VERTEX_BIT;
 shader_Stage_create_info.pName = "main";
 
 VkGraphicsPipelineCreateInfo pipeline_library_create_info{};
 pipeline_library_create_info.stageCount = 1;
 pipeline_library_create_info.pStages&nbsp;&nbsp;&nbsp;&nbsp;= &shader_Stage_create_info;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Linking executables
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Once all pipeline (library) parts have been created, the pipeline executable can be linked together from them:
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp"> std::vector&lt;VkPipeline&gt; libraries = {
&nbsp;&nbsp;&nbsp;&nbsp; pipeline_library.vertex_input_interface,
&nbsp;&nbsp;&nbsp;&nbsp; pipeline_library.pre_rasterization_shaders,
&nbsp;&nbsp;&nbsp;&nbsp; fragment_shader,
&nbsp;&nbsp;&nbsp;&nbsp; pipeline_library.fragment_output_interface
 };
 
 // Link the library parts into a graphics pipeline
 VkPipelineLibraryCreateInfoKHR linking_info{};
 linking_info.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
 linking_info.libraryCount = static_cast&lt;uint32_t&gt;(libraries.size());
 linking_info.pLibraries&nbsp;&nbsp; = libraries.data();
 
 VkGraphicsPipelineCreateInfo executable_pipeline_create_info{};
 executable_pipeline_create_info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
 executable_pipeline_create_info.pNext = &linking_info;
 executable_pipeline_create_info.flags = VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT;
 
 VkPipeline executable = VK_NULL_HANDLE;
 vkCreateGraphicsPipelines(get_device().get_handle(), thread_pipeline_cache, 1, &executable_pipeline_create_info, nullptr, &executable);
</code></pre>
		<ul>
			<li>
				<p>
                    This will result in the pipeline state object to be used at draw time.
				</p>
			</li>
			<li>
				<p>
                    A note on 
                    <code>VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT</code>
                    : This is an optimization flag. If specified, implementations are allowed to do additional optimization passes. This may increase build times but can in turn result in lower runtime costs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Independent Descriptor Sets
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Imagine a situation where the vertex and fragment stage accesses two different descriptor sets.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // Vertex Shader
 layout(set = 0) UBO_X;
 
 // Fragment Shader
 layout(set = 1) UBO_Y;
</code></pre>
		<ul>
			<li>
				<p>
                    Normally when compiling a pipeline, both stages are together and internally a driver will reserve 2 separate descriptor slots for 
                    <code>UBO_X</code>
                    &nbsp;and 
                    <code>UBO_Y</code>
                    . When using graphics pipeline libraries, the driver will see the fragment shader only uses a single descriptor set. It might internally map it to 
                    <code>set 0</code>
                    , but when linking the two libraries, there will be a collision. The 
                    <code>VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT</code>
                    &nbsp;flag ensures the driver will be able to handle this case and not have any collisions. There are some extra constraints when using this flag, but the Validation Layers will detect them for you.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=o1cdo3d2FQk" 
				class="external-link" 
				target="_blank" >
                Explanation
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250810112555.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250810112706.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            Same number of pipelines, but acquired through reuse, instead of recompilation.
						</p>
					</li>
					<li>
						<p>
                            Think of the link step as additive, instead of multiplicative.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250810112848.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250810112905.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Considerations
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            At the time it was said there would be an impact on CPU.
						</p>
					</li>
					<li>
						<p>
                            It was unknown whether it was compatible with mobile or not.
						</p>
					</li>
					<li>
						<p>
                            No libraries were made for Geometry and Tessellation Shaders, as they are difficult.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="one-pipeline-per-shader-variant" >
    ~One pipeline per shader variant
</h5>
<ul>
	<li>
		<p>
            It is the cause of the problem listed above.
		</p>
	</li>
	<li>
		<p>
            Causes a combinatorial explosion of variants.
		</p>
	</li>
</ul>
<h5
	id="single-pipeline-branch-inside-shader-material-id-push-constant" >
    <s>Single pipeline, branch inside shader (material ID / push constant)</s>
</h5>
<ul>
	<li>
		<p>
            No way, seems horrible.
		</p>
	</li>
</ul>
<h3
	id="optimizations" >
    Optimizations
</h3>
<h5
	id="pipeline-cache-with-codevkpipelinecache-code" >
    Pipeline Cache, with 
    <code>VkPipelineCache</code>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://github.com/KhronosGroup/Vulkan-Samples/blob/main/samples/performance/pipeline_cache/README.adoc#vulkan-pipeline-cache" 
				class="external-link" 
				target="_blank" >
                Pipeline cache sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/pipeline_cache.html" 
				class="external-link" 
				target="_blank" >
                Pipeline Cache
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/pipelines.html#pipelines-cache" 
				class="external-link" 
				target="_blank" >
                Pipeline Cache
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            It allows the driver to reuse previously computed pipeline artifacts across pipeline creations (and you can persist cache data between runs).
		</p>
	</li>
	<li>
		<p>
            Avoids repeating expensive 
			<em>
                driver
			</em>
            &nbsp;work; shortens startup time by reusing previously compiled artifacts.
		</p>
	</li>
	<li>
		<p>
            Creating a Vulkan pipeline requires compiling 
            <code>VkShaderModule</code>
            &nbsp;internally. This will have a significant increase in frame time if performed at runtime. To reduce this time, you can provide a previously initialised 
            <code>VkPipelineCache</code>
            &nbsp;object when calling the 
            <code>vkCreateGraphicsPipelines</code>
            &nbsp;or 
            <code>vkCreateComputePipelines</code>
            &nbsp;functions. This object behaves like a cache container which stores the pipeline internal representation for reuse. In order to benefit from using a 
            <code>VkPipelineCache</code>
            &nbsp;object, the data recorded during pipeline creation needs to be saved to disk and reused between application runs.
		</p>
	</li>
	<li>
		<p>
            Vulkan allows an application to obtain the binary data of a 
            <code>VkPipelineCache</code>
            &nbsp;object and save it to a file on disk before terminating the application. This operation can be achieved using two calls to the 
            <code>vkGetPipelineCacheData</code>
            &nbsp;function to obtain the size and 
            <code>VkPipelineCache</code>
            &nbsp;object’s binary data. In the next application run, the 
            <code>VkPipelineCache</code>
            &nbsp;can be initialised with the previous run’s data. This will allow the 
            <code>vkCreateGraphicsPipelines</code>
            &nbsp;or 
            <code>vkCreateComputePipelines</code>
            &nbsp;functions to reuse the baked state and avoid repeating costly operations such as shader compilation.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How to use it
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Create one 
                    <code>VkPipelineCache</code>
                    &nbsp;for related pipeline creation operations (often one per device).
				</p>
			</li>
			<li>
				<p>
                    Pass it into 
                    <code>vkCreateGraphicsPipelines</code>
                    &nbsp;for every create call.
				</p>
			</li>
			<li>
				<p>
                    On exit (or periodically) call 
                    <code>vkGetPipelineCacheData</code>
                    &nbsp;and write to disk; on startup feed that blob into 
                    <code>vkCreatePipelineCache</code>
                    &nbsp;to prepopulate the cache.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>VK_KHR_pipeline_binary</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>VkPipelineCache</code>
                    &nbsp;objects were designed to enable a Vulkan driver to reuse blobs of state or shader code between different pipelines. Originally, the idea was that the driver would know best which parts of state could be reused, and applications only needed to manage storage and threading, simplifying developer code.
				</p>
			</li>
			<li>
				<p>
                    Over time however, 
                    <code>VkPipelineCache</code>
                    &nbsp;objects proved to be too opaque, prompting the Vulkan Working Group to release a number of extensions to provide more application control over them. The current capabilities of 
                    <code>VkPipelineCache</code>
                    &nbsp;objects satisfies many applications, but has shortcomings in more advanced use cases.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Previous difficulties
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>VkPipelineCache</code>
                            &nbsp;API provides no control over the lifetime of the binary objects that it contains. An application wanting to implement an LRU cache, for example, has a hard time using 
                            <code>VkPipelineCache</code>
                            &nbsp;objects.
						</p>
					</li>
					<li>
						<p>
                            Some applications maintain a cache of VkPipeline objects. The VkPipelineCache API makes it impossible to efficiently associate the cached binary objects within a VkPipelineCache object with the application’s own cache entries.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    What’s more, most drivers maintain an internal cache of pipeline-derived binary objects. In some cases, it would be beneficial for the application to directly interact with that internal cache, especially on some specialized platforms.
				</p>
			</li>
			<li>
				<p>
                    The new 
                    <code>VK_KHR_pipeline_binary</code>
                    &nbsp;extension introduces a clean new approach that provides applications with access to binary blobs and the information necessary for optimal caching, while smoothly integrating with the application’s own caching mechanisms.
				</p>
			</li>
			<li>
				<p>
                    It’s worth noting that the 
					<a
						href="https://www.khronos.org/blog/you-can-use-vulkan-without-pipelines-today" 
						class="external-link" 
						target="_blank" >
                        <code>VK_EXT_shader_object</code>
					</a>
                    &nbsp;extension already includes analogous functionality to 
                    <code>VK_KHR_pipeline_binary</code>
                    . The two extensions were worked on concurrently to provide a universally available solution, including devices where the 
                    <code>VK_EXT_shader_object</code>
                    &nbsp;extension cannot yet be supported.
				</p>
			</li>
			<li>
				<p>
                    Applications that do not need the advanced functionality of the new VK_KHR_pipeline_binary extension can continue to use VkPipelineCache objects for their simplicity and optimized implementation. But developers that are not satisfied with the VkPipelineCache API should read on to learn more about this powerful new approach.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.khronos.org/blog/bringing-explicit-pipeline-caching-control-to-vulkan?utm_source=chatgpt.com" 
						class="external-link" 
						target="_blank" >
                        Article
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Read up to 'Caching With VK_KHR_pipeline_binary'.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="optimizing-the-shader-with-codevk_khr_buffer_device_address-code" >
    Optimizing the Shader with 
    <code>VK_KHR_buffer_device_address</code>
</h5>
<ul>
	<li>
		<p>
            See 
            <a href="Vulkan.html#Physical Storage Buffer (VK_KHR_buffer_device_address)">
            Vulkan#Physical Storage Buffer (VK_KHR_buffer_device_address)
            </a>
            .
		</p>
	</li>
	<li>
		<h2
			id="strongsupport-strong" >
			<strong>
                Support
			</strong>
            :
		</h2>
	</li>
</ul>
<h5
	id="pipeline-derivatives" >
    <s>Pipeline derivatives</s>
</h5>
<ul>
	<li>
		<p>
            A creation mechanism to tell the driver that one pipeline is a parent and others are children (derivatives).
		</p>
	</li>
	<li>
		<p>
            The driver may avoid redoing expensive compile/link steps and reuse intermediate data from the parent, reducing creation time.
		</p>
	</li>
	<li>
		<p>
            The intent is faster creation of children by reusing work/data from the parent.
		</p>
	</li>
	<li>
		<p>
            The pipeline creation API provides no way to tell it what state will change. The idea being that, since the implementation can see the parent's state, and it can see what you ask of the child's state, it can tell what's different.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Is it worth it?
			</strong>
            &nbsp;NO.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            No vendor is actually recommending the use of pipeline derivatives, except maybe to speed up pipeline creation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://devblogs.nvidia.com/vulkan-dos-donts/" 
						class="external-link" 
						target="_blank" >
                        Tips and Tricks: Vulkan Dos and Don’ts
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Don’t expect speedup from Pipeline Derivatives.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://developer.samsung.com/game/usage" 
						class="external-link" 
						target="_blank" >
                        Vulkan Usage Recommendations
					</a>
                    , Samsung
				</p>
				<ul>
					<li>
						<p>
                            Pipeline derivatives let applications express &quot;child&quot; pipelines as incremental state changes from a similar &quot;parent&quot;; on some architectures, this can reduce the cost of switching between similar states.
						</p>
					</li>
					<li>
						<p>
                            Many mobile GPUs gain performance primarily through pipeline caches, so pipeline derivatives often provide 
							<strong>
                                no
							</strong>
                            &nbsp;benefit to portable mobile applications.
						</p>
					</li>
					<li>
						<p>
                            Recommendations:
						</p>
						<ul>
							<li>
								<p>
                                    Create pipelines early in application execution. Avoid pipeline creation at draw time.
								</p>
							</li>
							<li>
								<p>
                                    Use a 
									<em>
                                        single pipeline cache
									</em>
                                    &nbsp;for all pipeline creation.
								</p>
							</li>
							<li>
								<p>
                                    Write the pipeline cache to a file between application runs.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Avoid pipeline derivatives.
									</em>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers/blob/master/samples/performance/pipeline_cache/pipeline_cache_tutorial.html" 
						class="internal-link" 
						target="_self" >
                        Vulkan Best Practice for Mobile Developers - Pipeline Management
					</a>
                    , Arm Software, Jul 11, 2019
				</p>
				<ul>
					<li>
						<p>
                            Don't create pipelines at draw time without a pipeline cache (introduces performance stutters).
						</p>
					</li>
					<li>
						<p>
                            Don't use pipeline derivatives as they are not supported.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://github.com/LunarG/VulkanSamples/blob/master/API-Samples/pipeline_derivative/pipeline_derivative.cpp" 
						class="external-link" 
						target="_blank" >
                        Vulkan Samples, LunarG - API-Samples/pipeline_derivative/pipeline_derivative.cpp
					</a>
				</p>
				<ul>
					<li>
						<p>
                            This sample creates pipeline derivative and draws with it. Pipeline derivatives should allow for faster creation of pipelines.
						</p>
					</li>
					<li>
						<p>
                            In this sample, we'll create the default pipeline, but then modify it slightly and create a derivative.
						</p>
					</li>
					<li>
						<p>
                            The derivative will be used to render a simple cube. We may later find that the pipeline is too simple to show any speedup, or that replacing the fragment shader is too expensive, so this sample can be updated then.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Typical use case
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Many pipelines that differ only by a few fields (e.g., different specializations or small state changes).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How to use
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Create a base pipeline with 
                    <code>VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    For similar pipelines (small shader or state differences), create child pipelines with 
                    <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code>
                    &nbsp;and set 
                    <code>basePipelineHandle</code>
                    &nbsp;or 
                    <code>basePipelineIndex</code>
                    &nbsp;pointing to the base.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How it affects the pipeline workflow
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Can materially reduce pipeline creation cost when many similar pipelines are needed.
				</p>
			</li>
			<li>
				<p>
                    Useful at runtime if you must create many variants quickly.
				</p>
			</li>
			<li>
				<p>
                    Still creates separate pipeline objects (state memory + driver bookkeeping).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Not guaranteed to be implemented with identical performance gains on all drivers; behavior is driver-dependent.
		</p>
	</li>
</ul>
<h2
	id="compute-pipeline" >
    Compute Pipeline
</h2>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://vkguide.dev/docs/new_chapter_2/vulkan_shader_code/#initializing-the-layout-and-descriptors" 
				class="external-link" 
				target="_blank" >
                Compute Pipeline Vulkan
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=pzAZ0xjWDv8" 
				class="external-link" 
				target="_blank" >
                Compute Shader in OpenGL
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Cool.
				</p>
			</li>
			<li>
				<p>
                    A compute shader is used to determine an array of positions, then render each point in a graphics pipeline using POINTS as the primitive.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=KN9nHo9kvZs" 
				class="external-link" 
				target="_blank" >
                Poor explanation, with possibly useful code, in Vulkan
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The video's code may be useful based on what I saw.
				</p>
			</li>
			<li>
				<p>
                    Though, the video itself is meh.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A compute shader maps pretty well of how a GPU operates; which is not really the case of a Graphics Pipeline.
		</p>
	</li>
</ul>
<h5
	id="use-cases" >
    Use cases
</h5>
<ul>
	<li>
		<p>
            Calculate images from complex postprocessing chains.
		</p>
	</li>
	<li>
		<p>
            Raytracing or other non-geometry drawing.
		</p>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<ul>
	<li>
		<p>
            We need to create first the pipeline layout for it, and then hook a single shader module for its code.
		</p>
	</li>
	<li>
		<p>
            Once its built, we can execute the compute shader by first calling 
            <code>VkCmdBindPipeline</code>
            &nbsp;and then calling 
            <code>VkCmdDispatch</code>
            .
		</p>
	</li>
</ul>
<h5
	id="using" >
    Using
</h5>
<ul>
	<li>
		<p>
            You generally want to use a memory barrier after the dispatch of the compute shader, so you wait for the compute shader to finish to finally access its data; if that's what you want to do.
		</p>
		<ul>
			<li>
				<p>
                    In OpenGL the 
                    <code>GL_SHADER_STORAGE_BARRIER_BIT</code>
                    &nbsp;is used.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="workgroup" >
    Workgroup
</h5>
<ul>
	<li>
		<p>
            <code>vkCmdDispatch</code>
            .
		</p>
	</li>
	<li>
		<p>
            For an image, I had the decision to only use 2 of those dimensions, that way we can execute one workgroup per group of pixels in the image.
		</p>
	</li>
	<li>
		<p>
            When executing compute shaders, they will get executed in groups of N lanes/threads.
		</p>
	</li>
	<li>
		<p>
            The most difficult part is the decision of partitioning the compute shader between Workgroups and Local Size.
		</p>
	</li>
	<li>
		<p>
            Local Size is also called Workgroup Size, representing the number of threads inside each Workgroup.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912085913.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The code is in OpenGL, but the concept is the same.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The size of the local_size should be ideally related to the size of a warp/wavefront from the GPU, so you don't waste processing power.
		</p>
	</li>
	<li>
		<p>
            For 
            <code>layout(local_size_x = 3, local_size_y = 4, local_size_z = 2)</code>
            , you'll use 
            <code>3 * 4 * 2 = 24</code>
            &nbsp;threads, which is not ideal for a NVIDIA warp size.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250912090019.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="glsl-built-in-variables" >
    GLSL Built-in Variables
</h5>
<ul>
	<li>
        <img src="assets/image_20250912090324.png" width="500" >

	</li>
</ul>
<h5
	id="examples" >
    Examples
</h5>
<ul>
	<li>
		<p>
            The shader code is a very simple shader that will create a gradient from the coordinates of the global invocation ID.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">//GLSL version to use
#version 460

//size of a workgroup for compute
layout (local_size_x = 16, local_size_y = 16) in;

//descriptor bindings for the pipeline
layout(rgba16f,set = 0, binding = 0) uniform image2D image;


void main() 
{
&nbsp;&nbsp;&nbsp;&nbsp;ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
&nbsp;&nbsp;&nbsp;&nbsp;ivec2 size = imageSize(image);

&nbsp;&nbsp;&nbsp;&nbsp;if(texelCoord.x &lt; size.x && texelCoord.y &lt; size.y)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(gl_LocalInvocationID.x != 0 && gl_LocalInvocationID.y != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color.x = float(texelCoord.x)/(size.x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color.y = float(texelCoord.y)/(size.y);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(image, texelCoord, color);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            Inside the shader itself, we can see 
            <code>layout (local_size_x = 16, local_size_y = 16) in;</code>
            &nbsp;(z=1 by default).
		</p>
		<ul>
			<li>
				<p>
                    By doing that, we are setting the size of a single workgroup.
				</p>
			</li>
			<li>
				<p>
                    This means that for every work unit from the 
                    <code>vkCmdDispatch</code>
                    , we will have 16x16 lanes of execution, which works well to write into a 16x16 pixel square.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The next layout statement is for the shader input through descriptor sets. We are setting a single image2D as set 0 and binding 0 within that set.
		</p>
	</li>
	<li>
		<p>
            If local invocation ID is 0 on either X or Y, we will just default to black. This is going to create a grid that will directly display our shader workgroup invocations.
		</p>
	</li>
	<li>
		<p>
            On the shader code, we can access what the lane index is through 
            <code>gl_LocalInvocationID</code>
            &nbsp;variable.
		</p>
	</li>
	<li>
		<p>
            There is also 
            <code>gl_GlobalInvocationID</code>
            &nbsp;and 
            <code>gl_WorkGroupID</code>
            . By using those variables we can find out what pixel exactly do we write from each lane.
		</p>
	</li>
</ul>
<h5
	id="compute-shader-raytracing" >
    Compute Shader Raytracing
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=ioazpKQwWPs&list=PLn3eTxaOtL2NkCvARUlpqJU9pLGhFalK9" 
				class="external-link" 
				target="_blank" >
                Playlist Vulkan Compute Shader Raytracing
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="resources" >
    Resources
</h2>
<ul>
	<li>
		<p>
            Resources are views of memory with associated formatting and dimensionality.
		</p>
	</li>
	<li>
		<p>
            Nvidia: Make sure to always use the minimum set of resource usage flags. Redundant flags may trigger redundant flushes and stalls in barriers and slow down your app unnecessarily.
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html" 
				class="external-link" 
				target="_blank" >
                Resource Creation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="primary-resources" >
    Primary resources
</h5>
<ul>
	<li>
		<p>
            Buffers.
		</p>
		<ul>
			<li>
				<p>
                    Provide access to raw arrays of bytes
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Images.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Can
					</em>
                    &nbsp;be multidimensional and 
					<em>
                        may
					</em>
                    &nbsp;have associated metadata.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Tensors.
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Can
					</em>
                    &nbsp;be multidimensional, contain format information like images and 
					<em>
                        may
					</em>
                    &nbsp;have associated metadata.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Samplers.
		</p>
		<ul>
			<li>
				<p>
                    Used to sample from images at certain coordinates, producing interpolated color values.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-micromaps" 
				class="external-link" 
				target="_blank" >
                Micromaps
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Uses buffers as the backing store for opaque data structures.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-acceleration-structures" 
				class="external-link" 
				target="_blank" >
                Acceleration Structures
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Uses buffers as the backing store for opaque data structures.
				</p>
			</li>
			<li>
				<p>
                    Used for realtime raytracing.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="memory" >
    Memory
</h3>
<h5
	id="host-mapped-memory" >
    Host-Mapped Memory
</h5>
<ul>
	<li>
		<p>
			<strong>
                Minimum Aligment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>nonCoherentAtomSize</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the size and alignment in bytes that bounds 
							<em>
                                concurrent
							</em>
                            &nbsp;access to 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-device-hostaccess" 
								class="external-link" 
								target="_blank" >
                                host-mapped device memory
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            The value 
							<strong>
                                must
							</strong>
                            &nbsp;be a power of two.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-mapping" >
    Memory Mapping
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/memory_allocation.html#_transfer" 
				class="external-link" 
				target="_blank" >
                Data Transfer
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250813094230.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
            <code>vkMapMemory</code>
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Requirements
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            You can only call 
                            <code>vkMapMemory</code>
                            &nbsp;on memory types with the property 
                            <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>
                            , otherwise the driver will return 
                            <code>VK_ERROR_MEMORY_MAP_FAILED</code>
                            .
						</p>
					</li>
					<li>
						<p>
							<strong>
                                <code>DEVICE_LOCAL</code>
                                &nbsp;only memory
							</strong>
                            &nbsp;(without 
                            <code>HOST_VISIBLE</code>
                            ) cannot be mapped. That means you cannot directly 
                            <code>memcpy</code>
                            &nbsp;into it.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Minimum Alignment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceLimits</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>minMemoryMapAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, of host visible memory allocations within the host address space.
								</p>
							</li>
							<li>
								<p>
                                    When mapping a memory allocation with 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory.html" 
										class="external-link" 
										target="_blank" >
                                        vkMapMemory
									</a>
                                    , subtracting 
                                    <code>offset</code>
                                    &nbsp;bytes from the returned pointer will always produce an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    See 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-device-hostaccess" 
										class="external-link" 
										target="_blank" >
                                        https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-device-hostaccess
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ChatGPT:
				</p>
				<ul>
					<li>
						<p>
                            Dynamic offsets:
						</p>
						<ul>
							<li>
								<p>
                                    If you used 
                                    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                    &nbsp;or 
                                    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                    &nbsp;in your 
                                    <code>VkDescriptorSetLayoutBinding</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            That is the definition of a dynamic descriptor.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If you call 
                                    <code>vkCmdBindDescriptorSets(..., dynamicOffsetCount, pDynamicOffsets)</code>
                                    . If 
                                    <code>dynamicOffsetCount &gt; 0</code>
                                    &nbsp;and 
                                    <code>pDynamicOffsets</code>
                                    &nbsp;is non-null you are supplying dynamic offsets at bind time.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            How offsets are applied:
						</p>
						<ul>
							<li>
								<p>
                                    Non-dynamic descriptor:
								</p>
								<ul>
									<li>
										<p>
                                            The 
                                            <code>VkDescriptorBufferInfo.offset</code>
                                            &nbsp;you gave to 
                                            <code>vkUpdateDescriptorSets</code>
                                            &nbsp;is baked into the descriptor.
										</p>
									</li>
									<li>
										<p>
                                            That 
                                            <code>offset</code>
                                            &nbsp;must be a multiple of 
                                            <code>minUniformBufferOffsetAlignment</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Dynamic descriptor:
								</p>
								<ul>
									<li>
										<p>
                                            The descriptor stores a base 
                                            <code>offset</code>
                                            /
                                            <code>range</code>
                                            , and the runtime adds the dynamic offset(s) you pass to 
                                            <code>vkCmdBindDescriptorSets</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Each dynamic offset must be a multiple of 
                                            <code>minUniformBufferOffsetAlignment</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If you are not using Dynamic Offsets in the 
                            <code>vkCmdBindDescriptorSets</code>
                            , nor using offsets in the 
                            <code>VkDescriptorBufferInfo</code>
                            , then you don't need to worry about this limit.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-copy" >
    Memory Copy
</h5>
<ul>
	<li>
		<p>
			<strong>
                Minimum Alignment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceLimits</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>optimalBufferCopyOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the optimal buffer offset alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage2
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer2
									</a>
                                    , and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This value is also the optimal host memory offset alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyMemoryToImage
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyImageToMemory
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    The per texel alignment requirements are enforced, but applications 
									<strong>
                                        should
									</strong>
                                    &nbsp;use the optimal alignment for optimal performance and power use.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>optimalBufferCopyRowPitchAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the optimal buffer row pitch alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage2
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyBufferToImage
									</a>
                                    , 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer2
									</a>
                                    , and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html" 
										class="external-link" 
										target="_blank" >
                                        vkCmdCopyImageToBuffer
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This value is also the optimal host memory row pitch alignment in bytes for 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyMemoryToImage
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html" 
										class="external-link" 
										target="_blank" >
                                        vkCopyImageToMemory
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are enforced, but applications 
									<strong>
                                        should
									</strong>
                                    &nbsp;use the optimal alignment for optimal performance and power use.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-aliasing" >
    Memory Aliasing
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-memory-aliasing" 
				class="external-link" 
				target="_blank" >
                Memory Aliasing
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="buffers" >
    Buffers
</h3>
<ul>
	<li>
		<p>
            Buffers in Vulkan are regions of memory used for storing arbitrary data that can be read by the graphics card.
		</p>
	</li>
	<li>
		<p>
            They are essentially unformatted arrays of bytes.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Types of Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Unformatted array.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Uniform Buffer
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It remains uniform during the execution of a command (like a draw call).
						</p>
					</li>
					<li>
						<p>
                            Only load operations (read only).
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Read&quot; == &quot;Load&quot;.
								</p>
							</li>
							<li>
								<p>
                                    This allows the GPU to cache them efficiently.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Loaded into L2, and further, into a L1 cache.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Storage Buffers
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Allow Load and Store operations.
						</p>
					</li>
					<li>
						<p>
                            Supports atomic operations.
						</p>
					</li>
					<li>
						<p>
                            Data can be loaded from GPU memory into L2-&gt;L1 caches, but can also store data from shaders into memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Texel Buffers
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Uniform Texel Buffer.
						</p>
					</li>
					<li>
						<p>
                            Storage Texel Buffer.
						</p>
					</li>
					<li>
						<p>
                            Formatted view.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Dynamic Buffers
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Dynamic Uniform Buffer.
						</p>
					</li>
					<li>
						<p>
                            Dynamic Texel Buffer.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    ...etc
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Usages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Store vertex data.
				</p>
			</li>
			<li>
				<p>
                    Etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Availability
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The buffer should be available for use in rendering commands until the end of the program, and it does not depend on the Swapchain.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Queues
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Just like the images in the Swapchain, buffers can also be owned by a specific queue family or be shared between multiple at the same time.
				</p>
				<ul>
					<li>
						<p>
                            The buffer will only be used from the graphics queue, so we can stick to exclusive access.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateBuffer.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCreateBuffer()</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    <code>VkBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            A chunk of GPU visible memory
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VkBufferCreateInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>size</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifies the size of the buffer in bytes. Calculating the byte size of the vertex data is straightforward with 
                                    <code>sizeof</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>usage</code>
						</p>
						<ul>
							<li>
								<p>
                                    Indicates for which purposes the data in the buffer is going to be used.
								</p>
							</li>
							<li>
								<p>
                                    It is possible to specify multiple purposes using a bitwise or.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is used to configure sparse buffer memory, which is not relevant right now. We'll leave it at the default value of 
                                    <code>0</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>sharingMode</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specifying the sharing mode of the buffer when it will be accessed by multiple queue families.
								</p>
							</li>
							<li>
								<p>
                                    The buffer will only be used from the graphics queue, so we can stick to exclusive access.
								</p>
							</li>
							<li>
								<p>
                                    NVIDIA:
								</p>
								<ul>
									<li>
										<p>
                                            <code>VkSharingMode</code>
                                            &nbsp;is ignored by the driver, so 
                                            <code>VK_SHARING_MODE_CONCURRENT</code>
                                            &nbsp;incurs no overhead relative to 
                                            <code>VK_SHARING_MODE_EXCLUSIVE</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_SHARING_MODE_EXCLUSIVE</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_SHARING_MODE_CONCURRENT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-allocation" >
    Memory Allocation
</h5>
<ul>
	<li>
		<p>
            Unlike the Vulkan objects we’ve been dealing with so far, buffers do not automatically allocate memory for themselves.
		</p>
	</li>
	<li>
		<p>
            The buffer has been created, but it doesn’t have any memory assigned to it yet.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Memory requirements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The first step of allocating memory for the buffer is to query its memory requirements.
				</p>
			</li>
			<li>
				<p>
                    <code>vkGetBufferMemoryRequirements</code>
				</p>
				<ul>
					<li>
						<p>
                            Returns the memory requirements for specified Vulkan object
						</p>
					</li>
					<li>
						<p>
                            <code>device</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the logical device that owns the buffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>buffer</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the buffer to query.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pMemoryRequirements</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
                                    <code>VkMemoryRequirements</code>
                                    &nbsp;structure in which the memory requirements of the buffer object are returned.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VkMemoryRequirements</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>size</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the size, in bytes, of the memory allocation required for the resource.
								</p>
							</li>
							<li>
								<p>
                                    The size of the required memory in bytes may differ from 
                                    <code>bufferInfo.size</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>alignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    The offset in bytes where the buffer begins in the allocated region of memory, depends on 
                                    <code>bufferInfo.usage</code>
                                    &nbsp;and 
                                    <code>bufferInfo.flags</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryTypeBits</code>
						</p>
						<ul>
							<li>
								<p>
                                    Bit field of the memory types that are suitable for the buffer.
								</p>
							</li>
							<li>
								<p>
                                    Bit 
                                    <code>i</code>
                                    &nbsp;is set if and only if the memory type 
                                    <code>i</code>
                                    &nbsp;in the 
                                    <code>VkPhysicalDeviceMemoryProperties</code>
                                    &nbsp;structure for the physical device is supported for the resource.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Graphics cards can offer different types of memory to allocate from. Each type of memory varies in terms of allowed operations and performance characteristics. We need to combine the requirements of the buffer and our own application requirements to find the right type of memory to use.
				</p>
			</li>
			<li>
				<p>
                    <code>vkGetPhysicalDeviceMemoryProperties</code>
				</p>
				<ul>
					<li>
						<p>
                            Reports memory information for the specified physical device
						</p>
					</li>
					<li>
						<p>
                            We'll use it to find a memory type that is suitable for the buffer itself.
						</p>
					</li>
					<li>
						<p>
                            <code>vkGetPhysicalDeviceMemoryProperties2</code>
                            &nbsp;behaves similarly to 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties.html" 
								class="external-link" 
								target="_blank" >
                                vkGetPhysicalDeviceMemoryProperties
							</a>
                            , with the ability to return extended information in a 
                            <code>pNext</code>
                            &nbsp;chain of output structures.
						</p>
					</li>
					<li>
						<p>
                            <code>memoryHeaps</code>
						</p>
						<ul>
							<li>
								<p>
                                    Are distinct memory resources like dedicated VRAM and swap space in RAM for when VRAM runs out.
								</p>
							</li>
							<li>
								<p>
                                    The different types of memory exist within these heaps.
								</p>
							</li>
							<li>
								<p>
                                    Right now we’ll only concern ourselves with the type of memory and not the heap it comes from, but you can imagine that this can affect performance.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryTypes</code>
						</p>
						<ul>
							<li>
								<p>
                                    Consists of 
                                    <code>VkMemoryType</code>
                                    &nbsp;structs that specify the heap and properties of each memory type.
								</p>
							</li>
							<li>
								<p>
                                    The properties define special features of the memory, like being able to map it so we can write to it from the CPU.
								</p>
							</li>
							<li>
								<p>
                                    <code>VkMemoryType</code>
								</p>
								<ul>
									<li>
										<p>
                                            Structure specifying memory type
										</p>
									</li>
									<li>
										<p>
                                            <code>heapIndex</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Describes which memory heap this memory type corresponds to, and 
													<em>
                                                        must
													</em>
                                                    &nbsp;be less than 
                                                    <code>memoryHeapCount</code>
                                                    &nbsp;from the 
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryProperties.html" 
														class="external-link" 
														target="_blank" >
                                                        VkPhysicalDeviceMemoryProperties
													</a>
                                                    &nbsp;structure.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>propertyFlags</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is a bitmask of 
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryPropertyFlagBits.html" 
														class="external-link" 
														target="_blank" >
                                                        VkMemoryPropertyFlagBits
													</a>
                                                    &nbsp;of properties for this memory type.
												</p>
											</li>
											<li>
												<p>
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryPropertyFlagBits.html" 
														class="external-link" 
														target="_blank" >
                                                        VkMemoryPropertyFlagBits
													</a>
                                                    .
												</p>
												<ul>
													<li>
														<p>
                                                            The most optimal memory has the 
                                                            <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>
                                                            &nbsp;flag and is usually not accessible by the CPU on dedicated graphics cards.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>typeFilter</code>
						</p>
						<ul>
							<li>
								<p>
                                    Specify the bit field of memory types that are suitable.
								</p>
							</li>
							<li>
								<p>
                                    That means that we can find the index of a suitable memory type by simply iterating over them and checking if the corresponding bit is set to 
                                    <code>1</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    However, we’re not just interested in a memory type that is suitable for the vertex buffer.
								</p>
							</li>
							<li>
								<p>
                                    We also need to be able to write our vertex data to that memory.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            We may have more than one desirable property, so we should check if the result of the bitwise AND is not just non-zero, but equal to the desired properties bit field. If there is a memory type suitable for the buffer that also has all the properties we need, then we return its index, otherwise we throw an exception.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Memory Allocation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Memory allocation is now as simple as specifying the size and type, both of which are derived from the memory requirements of the vertex buffer and the desired property.
				</p>
			</li>
			<li>
				<p>
                    <code>VkMemoryAllocateInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>allocationSize</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the size of the allocation in bytes.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>memoryTypeIndex</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is an index identifying a memory type from the 
                                    <code>memoryTypes</code>
                                    &nbsp;array of the 
                                    <code>vkGetPhysicalDeviceMemoryProperties</code>
                                    &nbsp;struct, as defined in the 'memory requirements'.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VkDeviceMemory</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Opaque handle to a device memory object
						</p>
					</li>
					<li>
						<p>
                            A Vulkan device operates on data in device memory via memory objects that are represented in the API by a this handle.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>vkBindBufferMemory()</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If memory allocation was successful, then we can now associate this memory with the buffer using this function.
						</p>
					</li>
					<li>
						<p>
                            <code>offset</code>
						</p>
						<ul>
							<li>
								<p>
                                    Offset within the region of memory.
								</p>
							</li>
							<li>
								<p>
                                    Since this memory is allocated specifically for this the vertex buffer, the offset is simply 
                                    <code>0</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    If the offset is non-zero, then it is required to be divisible by 
                                    <code>memRequirements.alignment</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Initially we allocate the 
                    <code>MemoryAllocateInfo</code>
                    &nbsp;with 
                    <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>
                    &nbsp;and 
                    <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
                    &nbsp;property, but later we can go for 
                    <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>
                    &nbsp;by using staging.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Memory Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is now time to copy the vertex data to the buffer, by performing a 
					<a
						href="https://en.wikipedia.org/wiki/Memory-mapped_I/O" 
						class="external-link" 
						target="_blank" >
                        mapping the buffer memory
					</a>
                    &nbsp;into CPU accessible memory.
				</p>
				<ul>
					<li>
						<p>
                            This is a fundamental Vulkan memory operation: transferring CPU data to a GPU-accessible buffer.
						</p>
					</li>
					<li>
						<p>
							<em>
                                The problem
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    GPU buffers (like 
                                    <code>vertexBuffer</code>
                                    ) reside in memory not directly accessible by the CPU.
								</p>
							</li>
							<li>
								<p>
                                    Vertex data (
                                    <code>vertices</code>
                                    ) exists in CPU-accessible RAM.
								</p>
							</li>
							<li>
								<p>
                                    We need to get 
                                    <code>vertices</code>
                                    &nbsp;into GPU memory (
                                    <code>vertexBufferMemory</code>
                                    ).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                The solution
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Vulkan provides 
									<strong>
                                        <code>vkMapMemory</code>
									</strong>
                                    &nbsp;to temporarily expose GPU memory to the CPU.
								</p>
							</li>
							<li>
								<p>
                                    It maps the GPU's 
                                    <code>vertexBufferMemory</code>
                                    &nbsp;into the CPU's address space.
								</p>
							</li>
							<li>
								<p>
                                    Copies vertex data from 
                                    <code>vertices</code>
                                    &nbsp;(CPU) to 
                                    <code>data</code>
                                    &nbsp;(now CPU-accessible GPU memory).
								</p>
							</li>
							<li>
								<p>
                                    <code>data</code>
                                    &nbsp;acts like regular RAM, but physically points to GPU memory.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>vkMapMemory</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            This function allows us to access a region of the specified memory resource defined by an offset and size.
						</p>
					</li>
					<li>
						<p>
                            The offset and size here are 
                            <code>0</code>
                            &nbsp;and 
                            <code>bufferInfo.size</code>
                            , respectively.
						</p>
					</li>
					<li>
						<p>
                            It is also possible to specify the special value 
                            <code>VK_WHOLE_SIZE</code>
                            &nbsp;to map all of the memory.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    You can now simply 
                    <code>memcpy</code>
                    &nbsp;the vertex data to the mapped memory and unmap it again using 
                    <code>vkUnmapMemory</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Problem
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Unfortunately, the driver may not immediately copy the data into the buffer memory, for example, because of caching.
						</p>
					</li>
					<li>
						<p>
                            It is also possible that writes to the buffer are not visible in the mapped memory yet.
						</p>
					</li>
					<li>
						<p>
                            There are two ways to deal with that problem:
						</p>
						<ul>
							<li>
								<p>
                                    Use a memory heap that is host coherent, indicated with 
                                    <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
								</p>
							</li>
							<li>
								<p>
                                    Call 
                                    <code>vkFlushMappedMemoryRanges</code>
                                    &nbsp;after writing to the mapped memory, and call 
                                    <code>vkInvalidateMappedMemoryRanges</code>
                                    &nbsp;before reading from the mapped memory.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    We went for the first approach, which ensures that the mapped memory always matches the contents of the allocated memory. Do keep in mind that this may lead to slightly worse performance than explicit flushing.
				</p>
				<ul>
					<li>
						<p>
                            We’ll see why that doesn’t matter in the next chapter.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Flushing memory ranges or using a coherent memory heap means that the driver will be aware of our writings to the buffer, but it doesn’t mean that they are actually visible on the GPU yet. The transfer of data to the GPU is an operation that happens in the background, and the specification simply 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap7.html#synchronization-submission-host-writes" 
						class="external-link" 
						target="_blank" >
                        tells us
					</a>
                    &nbsp;that it is guaranteed to be complete as of the next call to 
                    <code>vkQueueSubmit</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="staging-buffer" >
    Staging buffer
</h5>
<ul>
	<li>
		<p>
            One staging buffer in CPU accessible memory to upload the data from the vertex array to, and the final vertex buffer in device local memory. We’ll then use a buffer copy command to move the data from the staging buffer to the actual vertex buffer.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Buffer copy requirements
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Requires a queue family that supports transfer operations, which is indicated using 
                    <code>VK_QUEUE_TRANSFER_BIT</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            The good news is that any queue family with 
                            <code>VK_QUEUE_GRAPHICS_BIT</code>
                            &nbsp;or 
                            <code>VK_QUEUE_COMPUTE_BIT</code>
                            &nbsp;capabilities already implicitly support 
                            <code>VK_QUEUE_TRANSFER_BIT</code>
                            &nbsp;operations.
						</p>
					</li>
					<li>
						<p>
                            If you like a challenge, then you can still try to use a different queue family specifically for transfer operations.
						</p>
						<ul>
							<li>
								<p>
                                    It will require you to make the following modifications to your program:
								</p>
								<ul>
									<li>
										<p>
                                            Modify 
                                            <code>QueueFamilyIndices</code>
                                            &nbsp;and 
                                            <code>findQueueFamilies</code>
                                            &nbsp;to explicitly look for a queue family with the 
                                            <code>VK_QUEUE_TRANSFER_BIT</code>
                                            &nbsp;bit, but not the 
                                            <code>VK_QUEUE_GRAPHICS_BIT</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Modify 
                                            <code>createLogicalDevice</code>
                                            &nbsp;to request a handle to the transfer queue
										</p>
									</li>
									<li>
										<p>
                                            Create a second command pool for command buffers that are submitted on the transfer queue family
										</p>
									</li>
									<li>
										<p>
                                            Change the 
                                            <code>sharingMode</code>
                                            &nbsp;of resources to be 
                                            <code>VK_SHARING_MODE_CONCURRENT</code>
                                            &nbsp;and specify both the graphics and transfer queue families
										</p>
									</li>
									<li>
										<p>
                                            Submit any transfer commands like 
                                            <code>vkCmdCopyBuffer</code>
                                            &nbsp;(which we’ll be using in this chapter) to the transfer queue instead of the graphics queue
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Why would you do this? It’ll teach you a lot about how resources are shared between queue families.
								</p>
							</li>
							<li>
								<p>
                                    Caio: Ok, but why would I do this? I don't know.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Modify the code to only use a 
					<em>
                        host visible buffer
					</em>
                    &nbsp;as temporary buffer and use a 
					<em>
                        device local
					</em>
                    &nbsp;one as actual vertex buffer.
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code>
                            : Buffer can be used as source in a memory transfer operation.
						</p>
					</li>
					<li>
						<p>
                            <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>
                            : Buffer can be used as destination in a memory transfer operation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Buffer copy
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The vertex buffer is now allocated from a memory type that is device local, which generally means that we’re not able to use 
                    <code>vkMapMemory</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            However, we can copy data from the 
                            <code>stagingBuffer</code>
                            &nbsp;to the 
                            <code>vertexBuffer</code>
                            . We have to indicate that we intend to do that by specifying the transfer source flag for the 
                            <code>stagingBuffer</code>
                            &nbsp;and the transfer destination flag for the 
                            <code>vertexBuffer</code>
                            , along with the vertex buffer usage flag.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Memory transfer operations are executed using command buffers, just like drawing commands. Therefore we must first allocate a temporary command buffer.
				</p>
			</li>
			<li>
				<p>
                    You may wish to create a separate command pool for these kinds of short-lived buffers, because the implementation may be able to apply memory allocation optimizations.
				</p>
				<ul>
					<li>
						<p>
                            You should use the 
                            <code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code>
                            &nbsp;flag during command pool generation in that case.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    We’re only going to use the command buffer once and wait with returning from the function until the copy operation has finished executing.
				</p>
				<ul>
					<li>
						<p>
                            It’s good practice to tell the driver about our intent using 
                            <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Contents of buffers are transferred using the 
                    <code>vkCmdCopyBuffer</code>
                    &nbsp;command. It takes the source and destination buffers as arguments, and an array of regions to copy. The regions are defined in 
                    <code>VkBufferCopy</code>
                    &nbsp;structs and consist of a source buffer offset, destination buffer offset and size.
				</p>
				<ul>
					<li>
						<p>
                            It is not possible to specify 
                            <code>VK_WHOLE_SIZE</code>
                            &nbsp;here, unlike the 
                            <code>vkMapMemory</code>
                            &nbsp;command.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This command buffer only contains the copy command, so we can stop recording right after that. Now execute the command buffer to complete the transfer:
				</p>
<pre><code class="language-cpp" data-lang="cpp"> graphicsQueue.submit(vk::SubmitInfo{ .commandBufferCount = 1, .pCommandBuffers = &*commandCopyBuffer }, nullptr);
 graphicsQueue.waitIdle();
</code></pre>
			</li>
			<li>
				<p>
					<strong>
                        Synchronization
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Unlike the draw commands, there are no events we need to wait on this time. We just want to execute the transfer on the buffers immediately.
						</p>
					</li>
					<li>
						<p>
                            There are again two possible ways to wait on this transfer to complete:
						</p>
						<ol>
							<li>
								<p>
                                    We could use a fence and wait with 
                                    <code>vkWaitForFences</code>
                                    , or simply wait for the transfer queue to become idle with 
                                    <code>vkQueueWaitIdle</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    A fence would allow you to schedule multiple transfers simultaneously and wait for all of them complete, instead of executing one at a time. That may give the driver more opportunities to optimize.
								</p>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The improvement may not be visible right now, but its vertex data is now being loaded from high performance memory. This will matter when we’re going to start rendering more complex geometry.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="uniform-buffer" >
    Uniform Buffer
</h5>
<ul>
	<li>
		<p>
			<strong>
                No staging
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We’re going to copy new data to the uniform buffer every frame, so it doesn’t really make any sense to have a staging buffer. It would just add extra overhead in this case and likely degrade performance instead of improving it.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Many
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We should have multiple buffers, because multiple frames may be in flight at the same time and we don’t want to update the buffer in preparation of the next frame while a previous one is still reading from it! Thus, we need to have as many uniform buffers as we have frames in flight, and write to a uniform buffer that is not currently being read by the GPU.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Persistent Mapping
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We map the buffer right after creation using 
                    <code>vkMapMemory</code>
                    &nbsp;to get a pointer to which we can write the data later on. The buffer stays mapped to this pointer for the application’s whole lifetime.
				</p>
			</li>
			<li>
				<p>
                    Not having to map the buffer every time we need to update it increases performances, as mapping is not free.
				</p>
			</li>
			<li>
				<p>
                    This technique is called &quot;persistent mapping&quot; and works on all Vulkan implementations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Updating
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Will generate a new transformation every frame to make the geometry spin around.
				</p>
			</li>
			<li>
				<p>
                    Using a UBO this way is not the most efficient way to pass frequently changing values to the shader. A more efficient way to pass a small buffer of data to shaders is 
					<strong>
                        Push Constants
					</strong>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="images" >
    Images
</h3>
<ul>
	<li>
		<p>
            Images contain format information. Can be multidimensional and may have associated metadata.
		</p>
	</li>
	<li>
		<p>
            An Image, unlike a Buffer, is almost always used within a View.
		</p>
	</li>
	<li>
		<p>
            A texture you can write to and read from.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImage.html" 
				class="external-link" 
				target="_blank" >
                <code>VkImage</code>
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Stored as
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250909135026.png" width="300" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="creation" >
    Creation
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkImageCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>ImageType</code>
				</p>
			</li>
			<li>
				<p>
                    <code>extent</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the dimensions of the image, basically how many texels there are on each axis.
						</p>
					</li>
					<li>
						<p>
                            That’s why 
                            <code>extent.depth</code>
                            &nbsp;must be 
                            <code>1</code>
                            &nbsp;instead of 
                            <code>0</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>format</code>
				</p>
			</li>
			<li>
				<p>
                    <code>tiling</code>
				</p>
			</li>
			<li>
				<p>
                    <code>initialLayout</code>
				</p>
				<ul>
					<li>
						<p>
                            Can 
							<strong>
                                only
							</strong>
                            &nbsp;be one of these 3:
						</p>
						<ul>
							<li>
								<p>
                                    <code>UNDEFINED</code>
								</p>
								<ul>
									<li>
										<p>
                                            Not usable by the GPU and the very first transition will discard the texels.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>PREINITIALIZED</code>
								</p>
								<ul>
									<li>
										<p>
                                            Not usable by the GPU, but the first transition will preserve the texels.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>ZERO_INITIALIZED_EXT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Only if 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-zeroInitializeDeviceMemory" 
												class="external-link" 
												target="_blank" >
                                                zeroInitializeDeviceMemory
											</a>
                                            &nbsp;feature is enabled.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            There are a few situations where it is necessary for the texels to be preserved during the first transition.
						</p>
						<ul>
							<li>
								<p>
                                    One example would be if you wanted to use an image as a staging image in combination with the 
                                    <code>TILING_LINEAR</code>
                                    &nbsp;layout. In that case, you’d want to upload the texel data to it and then transition the image to be a transfer source without losing the data.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            However, we usually don't need this property and can use 
                            <code>UNDEFINED</code>
                            , as we can transition the image to be a transfer destination and then copy texel data to it from a buffer object.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>usage</code>
				</p>
			</li>
			<li>
				<p>
                    <code>samples</code>
				</p>
				<ul>
					<li>
						<p>
                            For multisampling.
						</p>
					</li>
					<li>
						<p>
                            Only relevant for images that will be used as attachments.
						</p>
					</li>
					<li>
						<p>
                            The default for non-multisampled images is one sample.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>mipLevels</code>
				</p>
				<ul>
					<li>
						<p>
                            For mipmapping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>flags</code>
				</p>
				<ul>
					<li>
						<p>
                            Related to sparse images.
						</p>
					</li>
					<li>
						<p>
                            Sparse images are images where only certain regions are actually backed by memory.
						</p>
					</li>
					<li>
						<p>
                            If you were using a 3D texture for a voxel terrain, for example, then you could use this to avoid allocating memory to store large volumes of &quot;air&quot; values.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>sharingMode</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the sharing mode of the image when it will be accessed by multiple queue families.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>queueFamilyIndexCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of entries in the 
                            <code>pQueueFamilyIndices</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pQueueFamilyIndices</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of queue families that will access this image. It is ignored if 
                            <code>sharingMode</code>
                            &nbsp;is not 
                            <code>SHARING_MODE_CONCURRENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="types" >
    Types
</h5>
<ul>
	<li>
		<p>
            Tells Vulkan with what kind of coordinate system the texels in the image are going to be addressed.
		</p>
	</li>
	<li>
		<p>
            1D images
		</p>
		<ul>
			<li>
				<p>
                    Can be used to store an array of data or a gradient.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            2D images
		</p>
		<ul>
			<li>
				<p>
                    Are mainly used for textures.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            3D images
		</p>
		<ul>
			<li>
				<p>
                    Can be used to store voxel volumes, for example.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="usages" >
    Usages
</h5>
<ul>
	<li>
		<p>
			<em>
                Storage Image
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Load and Store.
				</p>
			</li>
			<li>
				<p>
                    Similar to a Storage Buffer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Sampled Image
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only load operations (read only).
				</p>
			</li>
			<li>
				<p>
                    Similar to Uniform Buffers.
				</p>
			</li>
			<li>
				<p>
                    The coordinates are between 0.0 and 1.0.
				</p>
			</li>
			<li>
				<p>
                    If a coordinate doesn't match exactly a pixel, then the result is an interpolation between the neighbouring pixels.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Input Attachment
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only load operations (read only).
				</p>
			</li>
			<li>
				<p>
                    Within a renderpass.
				</p>
			</li>
			<li>
				<p>
                    Framebuffer-local.
				</p>
				<ul>
					<li>
						<p>
                            Access to single coordinate only.
						</p>
					</li>
					<li>
						<p>
                            No access to other coordinates in that image.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="formats" >
    Formats
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/formats.html" 
				class="external-link" 
				target="_blank" >
                Formats
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/formats.html#formats-compatibility-classes" 
				class="external-link" 
				target="_blank" >
                Compatible Formats
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/formats.html#formats-numericformat" 
				class="external-link" 
				target="_blank" >
                Numeric Format
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <code>R8G8B8_SRGB</code>
		</p>
		<ul>
			<li>
				<p>
                    Channels stored as 0–255.
				</p>
			</li>
			<li>
				<p>
                    After conversion, the values are in the 0-1 floating-point range.
				</p>
			</li>
			<li>
				<p>
                    Interpreted using the sRGB nonlinear transfer function (gamma correction).
				</p>
			</li>
			<li>
				<p>
                    When sampled, values are converted to linear color space in the shader automatically.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>R8G8B8_UNORM</code>
		</p>
		<ul>
			<li>
				<p>
                    Each 8-bit channel is an 
					<em>
                        unsigned
					</em>
                    &nbsp;normalized integer.
				</p>
			</li>
			<li>
				<p>
                    Storage range: 0–255.
				</p>
			</li>
			<li>
				<p>
                    Interpreted as floating-point in the shader:
				</p>
				<ul>
					<li>
						<p>
                            0 → 0.0
						</p>
					</li>
					<li>
						<p>
                            255 → 1.0
						</p>
					</li>
					<li>
						<p>
                            Linear mapping between.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>R8G8B8_SNORM</code>
		</p>
		<ul>
			<li>
				<p>
                    Each 8-bit channel is a 
					<em>
                        signed
					</em>
                    &nbsp;normalized integer.
				</p>
			</li>
			<li>
				<p>
                    Storage range: –128 to +127.
				</p>
			</li>
			<li>
				<p>
                    Interpreted as floating-point in the shader:
				</p>
				<ul>
					<li>
						<p>
                            –128 → –1.0
						</p>
					</li>
					<li>
						<p>
                            +127 → +1.0
						</p>
					</li>
					<li>
						<p>
                            Linear mapping between.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="tiling" >
    Tiling
</h5>
<ul>
	<li>
		<p>
            Nvidia: Always use 
            <code>TILING_OPTIMAL</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>TILING_LINEAR</code>
                    &nbsp;is not optimal. Use a staging buffer and 
                    <code>vkCmdCopyBufferToImage()</code>
                    &nbsp;to update images on the device.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Unlike the layout of an image, the tiling mode 
			<strong>
                cannot
			</strong>
            &nbsp;be changed at a later time.
		</p>
	</li>
	<li>
		<p>
            <code>TILING_OPTIMAL</code>
		</p>
		<ul>
			<li>
				<p>
                    The layout is opaque/driver-chosen.
				</p>
			</li>
			<li>
				<p>
                    Is described as an implementation-dependent (opaque) arrangement that the driver/GPU may reorder/tile texels for efficient access; it is the intended layout for GPU use.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        When to use
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Image is used as a framebuffer attachment, sampled texture, or otherwise heavily used by the GPU (most rendering targets).
						</p>
					</li>
					<li>
						<p>
                            You want the GPU/driver to choose a layout that maximizes memory locality and bandwidth for rendering.
						</p>
					</li>
					<li>
						<p>
                            You will perform GPU-side post-processing / tonemapping / sampling / blits before presentation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>TILING_LINEAR</code>
		</p>
		<ul>
			<li>
				<p>
                    The layout is row-major/predictable.
				</p>
			</li>
			<li>
				<p>
                    Lays out texels in row-major order (with row padding possible) and is the layout for which 
                    <code>vkGetImageSubresourceLayout</code>
                    &nbsp;returns meaningful offsets for host access; that is the mechanism used when an application needs direct CPU mapping/reading of image memory.
				</p>
				<ul>
					<li>
						<p>
                            However, in practice applications usually do GPU render → copy to a host-visible staging buffer/image rather than render directly into a linear-host-visible image.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    LINEAR tiling does have functional and performance limitations (fewer supported formats/usages and worse GPU access patterns), which is why it’s rarely used for main rendering; typical use cases are CPU upload/download, debugging, or very small offscreen images. It is not only theoretically usable for CPU readback, but that is the primary practical use. You must query format/usage support for linear tiling because many formats or usages are unsupported in LINEAR.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        When to use
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            You explicitly need to map the image memory from the CPU (direct host read/write) and the driver reports support for the requested format/usage in linear tiling.
						</p>
					</li>
					<li>
						<p>
                            Use cases: readback for screenshots/debugging, direct CPU uploads for small resources, or special interop scenarios where a row-major layout is required.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                GPU OPTIMAL to Host-Visible
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://vulkan-tutorial.com/Texture_mapping/Images" 
						class="external-link" 
						target="_blank" >
                        Strategy applied for 'creating a texture from file'
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If you want to be able to directly access texels in the memory of the image, then you must use 
                            <code>TILING_LINEAR</code>
                            . We will be using a staging buffer instead of a staging image, so this won't be necessary. We will be using 
                            <code>TILING_OPTIMAL</code>
                            &nbsp;for efficient access from the shader.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    : 
                    <code>OPTIMAL</code>
                    &nbsp;+ explicit transfer to a host-visible staging resource when needed.
				</p>
			</li>
			<li>
				<p>
                    Create your render target as 
                    <code>OPTIMAL</code>
                    &nbsp;and allocate 
                    <code>DEVICE_LOCAL</code>
                    &nbsp;memory (fast GPU local). After rendering, 
					<strong>
                        copy
					</strong>
                    &nbsp;or 
					<strong>
                        blit
					</strong>
                    &nbsp;the image to a host-visible staging resource (either a buffer via 
                    <code>vkCmdCopyImageToBuffer</code>
                    &nbsp;or a LINEAR image) and map that staging resource for CPU access. This avoids depending on limited linear support and keeps the GPU path fast.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="layouts" >
    Layouts
</h5>
<ul>
	<li>
		<p>
            <code>GENERAL</code>
		</p>
		<ul>
			<li>
				<p>
                    Supports all types of device access, unless specified otherwise.
				</p>
			</li>
			<li>
				<p>
                    If the 
                    <code>unifiedImageLayouts</code>
                    &nbsp;feature is enabled, the 
                    <code>GENERAL</code>
                    &nbsp;image layout 
					<strong>
                        may
					</strong>
                    &nbsp;be used in place of the other layouts where allowed with no loss of performance.
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Can be included in the 
                                    <code>pNext</code>
                                    &nbsp;chain of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkPhysicalDeviceFeatures2</code>
									</a>
                                    &nbsp;structure passed to 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>vkGetPhysicalDeviceFeatures2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <code>VK_KHR_unified_image_layouts</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            This extension significantly simplifies synchronization in Vulkan by removing the need for image layout transitions in most cases. In particular, it guarantees that using the 
                                            <code>GENERAL</code>
                                            &nbsp;layout everywhere possible is just as efficient as using the other layouts.
										</p>
									</li>
									<li>
										<p>
                                            In the interest of simplifying synchronization in Vulkan, this extension removes image layouts altogether as much as possible. As such, this extension is fairly simple.
										</p>
									</li>
									<li>
										<p>
											<a
												href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/proposals/VK_KHR_unified_image_layouts.adoc" 
												class="external-link" 
												target="_blank" >
                                                Proposal
											</a>
                                            .
										</p>
									</li>
									<li>
										<p>
											<a
												href="https://www.khronos.org/blog/so-long-image-layouts-simplifying-vulkan-synchronisation" 
												class="external-link" 
												target="_blank" >
                                                Article
											</a>
                                            .
										</p>
									</li>
									<li>
										<p>
											<em>
                                                Interacts with
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    VK_VERSION_1_3
												</p>
											</li>
											<li>
												<p>
                                                    VK_EXT_attachment_feedback_loop_layout
												</p>
											</li>
											<li>
												<p>
                                                    VK_KHR_dynamic_rendering
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<em>
                                                Support
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
													<a
														href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_KHR_unified_image_layouts" 
														class="external-link" 
														target="_blank" >
                                                        VK_KHR_unified_image_layouts
													</a>
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>unifiedImageLayouts</code>
                                    &nbsp;(boolean)
								</p>
								<ul>
									<li>
										<p>
                                            Specifies whether usage of 
                                            <code>GENERAL</code>
                                            , where valid, incurs no loss in efficiency.
										</p>
									</li>
									<li>
										<p>
                                            Additionally, it indicates whether it 
											<strong>
                                                can
											</strong>
                                            &nbsp;be used in place of 
                                            <code>ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>unifiedImageLayoutsVideo</code>
                                    &nbsp;(boolean)
								</p>
								<ul>
									<li>
										<p>
                                            Specifies whether 
                                            <code>GENERAL</code>
                                            &nbsp;can be used in place of any of the following image layouts with no loss in efficiency.
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_DECODE_DST</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_DECODE_SRC</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_DECODE_DPB</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_DST</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_SRC</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_DPB</code>
										</p>
									</li>
									<li>
										<p>
                                            <code>VIDEO_ENCODE_QUANTIZATION_MAP</code>
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It can be a useful catch-all image layout, but there are situations where a dedicated image layout must be used instead. For example:
				</p>
				<ul>
					<li>
						<p>
                            <code>PRESENT_SRC</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>SHARED_PRESENT</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>VIDEO_DECODE_SRC</code>
                            , 
                            <code>VIDEO_DECODE_DST</code>
                            , and 
                            <code>VIDEO_DECODE_DPB</code>
                            &nbsp;without the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-unifiedImageLayoutsVideo" 
								class="external-link" 
								target="_blank" >
                                <code>unifiedImageLayoutsVideo</code>
							</a>
                            &nbsp;feature.
						</p>
					</li>
					<li>
						<p>
                            <code>VIDEO_ENCODE_SRC</code>
                            , 
                            <code>VIDEO_ENCODE_DST</code>
                            , and 
                            <code>VIDEO_ENCODE_DPB</code>
                            &nbsp;without the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-unifiedImageLayoutsVideo" 
								class="external-link" 
								target="_blank" >
                                <code>unifiedImageLayoutsVideo</code>
							</a>
                            &nbsp;feature.
						</p>
					</li>
					<li>
						<p>
                            <code>VIDEO_ENCODE_QUANTIZATION_MAP</code>
                            &nbsp;without the 
                            <code>unifiedImageLayoutsVideo</code>
                            &nbsp;feature.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    While 
                    <code>GENERAL</code>
                    &nbsp;suggests that all types of device access are possible, it does not mean that all patterns of memory accesses are safe in all situations.
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#common-render-pass-data-races" 
								class="external-link" 
								target="_blank" >
                                Common Render Pass Data Races
							</a>
                            &nbsp;outlines some situations where data races are unavoidable. For example, when a subresource is used as both an attachment and a sampled image (i.e., not an input attachment), 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-feedbackloop" 
								class="external-link" 
								target="_blank" >
                                enabling feedback loop
							</a>
                            &nbsp;adds extra guarantees which 
                            <code>GENERAL</code>
                            &nbsp;alone does not.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Only in 
                <code>initialLayout</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>UNDEFINED</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that the layout is unknown.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used as the 
                            <code>initialLayout</code>
                            &nbsp;member of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkImageCreateInfo
							</a>
                            .&nbsp;&nbsp;Image memory 
							<strong>
                                cannot
							</strong>
                            &nbsp;be transitioned into this layout.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used in place of the current image layout in a layout transition, but doing so will cause the contents of the image’s memory to be undefined.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
                    <code>PREINITIALIZED</code>
                    </s>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that an image’s memory is in a defined layout and 
							<strong>
                                can
							</strong>
                            &nbsp;be populated by data, but that it has not yet been initialized by the driver.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used as the 
                            <code>initialLayout</code>
                            &nbsp;member of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkImageCreateInfo
							</a>
                            .&nbsp;&nbsp;Image memory 
							<strong>
                                cannot
							</strong>
                            &nbsp;be transitioned into this layout.
						</p>
					</li>
					<li>
						<p>
                            This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data 
							<strong>
                                can
							</strong>
                            &nbsp;be written to memory immediately, without first executing a layout transition.
						</p>
					</li>
					<li>
						<p>
                            Currently, 
                            <code>PREINITIALIZED</code>
                            &nbsp;is only useful with 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#glossary-linear-resource" 
								class="external-link" 
								target="_blank" >
                                linear
							</a>
                            &nbsp;images because there is not a standard layout defined for 
                            <code>TILING_OPTIMAL</code>
                            &nbsp;images.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>
                    <code>ZERO_INITIALIZED_EXT</code>
                    </s>
				</p>
				<ul>
					<li>
						<p>
                            Specifies that an image’s memory is in a defined layout and is zeroed, but that it has not yet been initialized by the driver.
						</p>
					</li>
					<li>
						<p>
                            This layout 
							<strong>
                                can
							</strong>
                            &nbsp;be used as the 
                            <code>initialLayout</code>
                            &nbsp;member of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkImageCreateInfo
							</a>
                            . Image memory 
							<strong>
                                cannot
							</strong>
                            &nbsp;be transitioned into this layout.
						</p>
					</li>
					<li>
						<p>
                            This layout is intended to be used as the initial layout for an image whose contents are already zeroed, either from being explicitly set to zero by an application or from being allocated with 
                            <code>MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Only if 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-zeroInitializeDeviceMemory" 
								class="external-link" 
								target="_blank" >
                                zeroInitializeDeviceMemory
							</a>
                            &nbsp;feature is enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Transfer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>TRANSFER_SRC_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a source image of a transfer command (see the definition of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-pipeline-stages-transfer" 
								class="external-link" 
								target="_blank" >
                                <code>VK_PIPELINE_STAGE_TRANSFER_BIT</code>
							</a>
                            ).
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_TRANSFER_SRC</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>TRANSFER_DST_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a destination image of a transfer command.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid only for image subresources of images created with the 
                            <code>USAGE_TRANSFER_DST</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Present
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>PRESENT_SRC</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used for presenting a presentable image for display.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SHARED_PRESENT</code>
				</p>
				<ul>
					<li>
						<p>
                            Is valid only for shared presentable images, and 
							<strong>
                                must
							</strong>
                            &nbsp;be used for any usage the image supports.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Read
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout allowing read only access as an attachment, or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the depth aspect of a depth/stencil format image allowing read-only access as a depth attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>STENCIL_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the stencil aspect of a depth/stencil format image allowing read-only access as a stencil attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for 
							<em>
                                both
							</em>
                            &nbsp;the depth and stencil aspects of a depth/stencil format image allowing read only access as a depth/stencil attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            It is equivalent to 
                            <code>DEPTH_READ_ONLY_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_READ_ONLY_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>SHADER_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout allowing read-only access in a shader as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_SAMPLED</code>
                            &nbsp;or 
                            <code>USAGE_INPUT_ATTACHMENT</code>
                            &nbsp;usage bits enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Attachments
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout that 
							<em>
                                must
							</em>
                            &nbsp;only be used with attachment accesses in the graphics pipeline.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>COLOR_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a color or resolve attachment in a 
                            <code>VkFramebuffer</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid only for image subresources of images created with the 
                            <code>COLOR_ATTACHMENT</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
					<li>
						<p>
                            Nvidia: Use 
                            <code>COLOR_ATTACHMENT_OPTIMAL</code>
                            &nbsp;image layout for color attachments.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the depth aspect of a depth/stencil format image allowing read and write access as a depth attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>STENCIL_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for the stencil aspect of a depth/stencil format image allowing read and write access as a stencil attachment.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for 
							<em>
                                both
							</em>
                            &nbsp;the depth and stencil aspects of a depth/stencil format image allowing read and write access as a depth/stencil attachment.
						</p>
					</li>
					<li>
						<p>
                            Equivalent to 
                            <code>DEPTH_ATTACHMENT_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_ATTACHMENT_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as either a color attachment or depth/stencil attachment and/or read-only access in a shader as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_ATTACHMENT_FEEDBACK_LOOP</code>
                            &nbsp;usage bit enabled and either the 
                            <code>USAGE_COLOR_ATTACHMENT</code>
                            &nbsp;or 
                            <code>USAGE_DEPTH_STENCIL_ATTACHMENT</code>
                            &nbsp;and either the 
                            <code>USAGE_INPUT_ATTACHMENT</code>
                            &nbsp;or 
                            <code>USAGE_SAMPLED</code>
                            &nbsp;usage bits enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>LAYOUT_RENDERING_LOCAL_READ</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as either a storage image, or a color or depth/stencil attachment and an input attachment.
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with either 
                            <code>USAGE_STORAGE</code>
                            , or both 
                            <code>USAGE_INPUT_ATTACHMENT</code>
                            &nbsp;and either of 
                            <code>USAGE_COLOR_ATTACHMENT</code>
                            &nbsp;or 
                            <code>USAGE_DEPTH_STENCIL_ATTACHMENT</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Attachment Fragment Shading Rate
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            <code>FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL</code>
						</p>
						<ul>
							<li>
								<p>
                                    It 
									<strong>
                                        must
									</strong>
                                    &nbsp;only be used as a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#primsrast-fragment-shading-rate-attachment" 
										class="external-link" 
										target="_blank" >
                                        fragment shading rate attachment
									</a>
                                    &nbsp;or 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#primsrast-shading-rate-image" 
										class="external-link" 
										target="_blank" >
                                        shading rate image
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This layout is valid 
									<em>
                                        only
									</em>
                                    &nbsp;for image subresources of images created with the 
                                    <code>USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT</code>
                                    &nbsp;usage bit enabled.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Fragment Density Map
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>FRAGMENT_DENSITY_MAP_OPTIMAL_EXT</code>
						</p>
						<ul>
							<li>
								<p>
                                    It 
									<strong>
                                        must
									</strong>
                                    &nbsp;only be used as a fragment density map attachment in a 
                                    <code>VkRenderPass</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This layout is valid 
									<em>
                                        only
									</em>
                                    &nbsp;for image subresources of images created with the 
                                    <code>USAGE_FRAGMENT_DENSITY_MAP</code>
                                    &nbsp;usage bit enabled.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Read / Attachment
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for depth/stencil format images allowing read and write access to the stencil aspect as a stencil attachment, and read only access to the depth aspect as a depth attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            Equivalent to 
                            <code>DEPTH_READ_ONLY_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_ATTACHMENT_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies a layout for depth/stencil format images allowing read and write access to the depth aspect as a depth attachment, and read only access to the stencil aspect as a stencil attachment or in shaders as a sampled image, combined image/sampler, or input attachment.
						</p>
					</li>
					<li>
						<p>
                            Equivalent to 
                            <code>DEPTH_ATTACHMENT_OPTIMAL</code>
                            &nbsp;and 
                            <code>STENCIL_READ_ONLY_OPTIMAL</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Video
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VIDEO_DECODE_DST</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#decode-output-picture" 
								class="external-link" 
								target="_blank" >
                                decode output picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-decode-operations" 
								class="external-link" 
								target="_blank" >
                                video decode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>VIDEO_DECODE_DST</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_DECODE_SRC</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_DECODE_DPB</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as an output 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reconstructed-picture" 
								class="external-link" 
								target="_blank" >
                                reconstructed picture
							</a>
                            &nbsp;or an input 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reference-picture" 
								class="external-link" 
								target="_blank" >
                                reference picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-decode-operations" 
								class="external-link" 
								target="_blank" >
                                video decode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_VIDEO_DECODE_DPB</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_DST</code>
				</p>
				<ul>
					<li>
						<p>
                            Reserved for future use.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_SRC</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as an 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#encode-input-picture" 
								class="external-link" 
								target="_blank" >
                                encode input picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-encode-operations" 
								class="external-link" 
								target="_blank" >
                                video encode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_VIDEO_ENCODE_SRC_BIT</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_DPB</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as an output 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reconstructed-picture" 
								class="external-link" 
								target="_blank" >
                                reconstructed picture
							</a>
                            &nbsp;or an input 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#reference-picture" 
								class="external-link" 
								target="_blank" >
                                reference picture
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-encode-operations" 
								class="external-link" 
								target="_blank" >
                                video encode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>USAGE_VIDEO_ENCODE_DPB_BIT</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VIDEO_ENCODE_QUANTIZATION_MAP</code>
				</p>
				<ul>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;only be used as a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#encode-quantization-map" 
								class="external-link" 
								target="_blank" >
                                quantization map
							</a>
                            &nbsp;in a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#video-encode-operations" 
								class="external-link" 
								target="_blank" >
                                video encode operation
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            This layout is valid 
							<em>
                                only
							</em>
                            &nbsp;for image subresources of images created with the 
                            <code>VIDEO_ENCODE_QUANTIZATION_DELTA_MAP</code>
                            &nbsp;or 
                            <code>VIDEO_ENCODE_EMPHASIS_MAP</code>
                            &nbsp;usage bit enabled.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>TENSOR_ALIASING_ARM</code>
		</p>
		<ul>
			<li>
				<p>
                    Specifies the layout that an image created with 
                    <code>TILING_OPTIMAL</code>
                    &nbsp;
					<strong>
                        must
					</strong>
                    &nbsp;be in for it and a tensor bound to the same aliased range of memory to consistently interpret the data in memory.
				</p>
			</li>
			<li>
				<p>
                    See 
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-memory-aliasing" 
						class="external-link" 
						target="_blank" >
                        https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-memory-aliasing
					</a>
                    &nbsp;for a complete set of rules for tensor/image aliasing.
				</p>
			</li>
			<li>
				<p>
                    This layout is valid 
					<em>
                        only
					</em>
                    &nbsp;for image subresources of images created with 
                    <code>USAGE_TENSOR_ALIASING</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="image-views" >
    Image Views
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-image-views" 
				class="external-link" 
				target="_blank" >
                Image Views
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            An image view references a specific part of an image to be used.
		</p>
	</li>
	<li>
		<p>
            <code>VkImageViewCreateInfo</code>
		</p>
		<ul>
			<li>
				<p>
                    <code>viewType</code>
				</p>
				<ul>
					<li>
						<p>
                            Allows you to treat images as 1D textures, 2D textures, 3D textures and cube maps.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>format</code>
				</p>
			</li>
			<li>
				<p>
                    <code>components</code>
				</p>
				<ul>
					<li>
						<p>
                            Allows you to swizzle the color channels around. For example, you can map all of the channels to the red channel for a monochrome texture. You can also map constant values of 
                            <code>0</code>
                            &nbsp;and 
                            <code>1</code>
                            &nbsp;to a channel. In our case we'll stick to the default mapping.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>subresourceRange</code>
				</p>
				<ul>
					<li>
						<p>
                            Describes what the image's purpose is and which part of the image should be accessed. Our images will be used as color targets without any mipmapping levels or multiple layers.
						</p>
					</li>
					<li>
						<p>
                            If you were working on a stereographic 3D application, then you would create a Swapchain with multiple layers. You could then create multiple image views for each image representing the views for the left and right eyes by accessing different layers.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="blit-copy-image-to-image" >
    Blit (Copy image to image)
</h5>
<ul>
	<li>
		<p>
            Transfer a rectangular region of pixel data from one image to another.
		</p>
	</li>
	<li>
		<p>
            Unlike a raw copy (
            <code>vkCmdCopyImage</code>
            ), a blit can perform scaling and apply filtering (
            <code>VK_FILTER_LINEAR</code>
            &nbsp;or 
            <code>VK_FILTER_NEAREST</code>
            ), which is consistent with the historical meaning of bit block transfer with optional transformations.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Name
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Comes from 
					<em>
                        bit block transfer
					</em>
                    &nbsp;(sometimes shortened to 
					<em>
                        bitblt
					</em>
                    ).
				</p>
			</li>
			<li>
				<p>
                    It was introduced in the 1970s in the context of 2D graphics systems, particularly at Xerox PARC.
				</p>
			</li>
			<li>
				<p>
                    The idea was to copy rectangular 
					<strong>
                        blocks of bits (pixels)
					</strong>
                    &nbsp;from one place in memory to another, often with operations like scaling, masking, or raster operations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdBlitImage2</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
			</li>
			<li>
				<p>
                    <code>pBlitImageInfo</code>
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlitImageInfo2.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkBlitImageInfo2</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>srcImage</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the source image.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>srcImageLayout</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the layout of the source image subresources for the blit.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstImage</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the destination image.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>dstImageLayout</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the layout of the destination image subresources for the blit.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>regionCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of regions to blit.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pRegions</code>
						</p>
						<ul>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageBlit2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkImageBlit2</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Defines source and destination subresources, offsets, and extents.
								</p>
							</li>
							<li>
								<p>
                                    Can define multiple regions in a single blit call.
								</p>
							</li>
							<li>
								<p>
                                    For each element of the 
                                    <code>pRegions</code>
                                    &nbsp;array, a blit operation is performed for the specified source and destination regions.
								</p>
							</li>
							<li>
								<p>
									<strong>
                                        Offset
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            The offset entries specify two corners of the rectangular/box region to blit (one corner and the opposite corner).
										</p>
									</li>
									<li>
										<p>
                                            You normally set 
                                            <code>offsets[0]</code>
                                            &nbsp;to the region origin (frequently 
                                            <code>{0,0,0}</code>
                                            ) and 
                                            <code>offsets[1]</code>
                                            &nbsp;to the region end (
                                            <code>{width, height, depth}</code>
                                            ), i.e. the bounds.
										</p>
									</li>
									<li>
										<p>
                                            If left unspecified, that produces the common 
                                            <code>{0,0,0} -&gt; {w,h,1}</code>
                                            &nbsp;box.
										</p>
									</li>
									<li>
										<p>
                                            The Vulkan spec requires both offsets be provided and documents constraints on them (e.g. for 2D images 
                                            <code>z</code>
                                            &nbsp;must be 0/1).
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>srcSubresource</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the subresource to blit from.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>srcOffsets</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a pointer to an array of two 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkOffset3D.html" 
												class="external-link" 
												target="_blank" >
                                                VkOffset3D
											</a>
                                            &nbsp;structures specifying the bounds of the source region within 
                                            <code>srcSubresource</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>dstSubresource</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the subresource to blit into.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>dstOffsets</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a pointer to an array of two 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkOffset3D.html" 
												class="external-link" 
												target="_blank" >
                                                VkOffset3D
											</a>
                                            &nbsp;structures specifying the bounds of the destination region within 
                                            <code>dstSubresource</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>filter</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFilter.html" 
										class="external-link" 
										target="_blank" >
                                        VkFilter
									</a>
                                    &nbsp;specifying the filter to apply if the blits require scaling.
								</p>
							</li>
							<li>
								<p>
                                    Determines how pixels are sampled if scaling occurs.
								</p>
							</li>
							<li>
								<p>
                                    <code>VK_FILTER_NEAREST</code>
                                    &nbsp;for nearest-neighbor scaling.
								</p>
							</li>
							<li>
								<p>
                                    <code>VK_FILTER_LINEAR</code>
                                    &nbsp;for linear interpolation.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Their layouts must be valid for transfer operations (
                            <code>TRANSFER_SRC_OPTIMAL</code>
                            &nbsp;and 
                            <code>TRANSFER_DST_OPTIMAL</code>
                            ).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Restrictions
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Blit operations are supported only if the format and the physical device support 
                    <code>FORMAT_FEATURE_BLIT_SRC_BIT</code>
                    &nbsp;and 
                    <code>FORMAT_FEATURE_BLIT_DST_BIT</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Some formats (like depth/stencil) do not support blitting.
				</p>
			</li>
			<li>
				<p>
                    Multisampled images cannot be used directly as source or destination.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="compression" >
    Compression
</h4>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/image_compression_control/README.html" 
				class="external-link" 
				target="_blank" >
                Sample - Image Compression Control
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/texture_compression_comparison" 
				class="external-link" 
				target="_blank" >
                Sample - Texture Compression Comparison
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="depth" >
    Depth
</h2>
<h3
	id="depth-tests" >
    Depth Tests
</h3>
<h5
	id="shader" >
    Shader
</h5>
<ul>
	<li>
		<p>
            <code>gl_FragDepth</code>
		</p>
		<ul>
			<li>
				<p>
                    Available only in the fragment shader.
				</p>
			</li>
			<li>
				<p>
                    Is an 
					<strong>
                        output
					</strong>
                    &nbsp;variable that is used to establish the depth value for the current fragment.
				</p>
			</li>
			<li>
				<p>
                    It is a 
                    <code>float</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If depth buffering is enabled and no shader writes to 
                    <code>gl_FragDepth</code>
                    , then the fixed function value for depth will be used (this value is contained in the z component of 
                    <code>gl_FragCoord</code>
                    ) otherwise, the value written to 
                    <code>gl_FragDepth</code>
                    &nbsp;is used.
				</p>
			</li>
			<li>
				<p>
                    If a shader statically assigns to 
                    <code>gl_FragDepth</code>
                    , then the value of the fragment's depth may be undefined for executions of the shader that don't take that path. That is, if the set of linked fragment shaders statically contain a write to 
                    <code>gl_FragDepth</code>
                    , then it is responsible for always writing it.
				</p>
			</li>
			<li>
				<p>
                    Available in all versions of glsl.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>gl_FragCoord</code>
		</p>
		<ul>
			<li>
				<p>
                    Available only in the fragment shader.
				</p>
			</li>
			<li>
				<p>
                    Is an 
					<strong>
                        input
					</strong>
                    &nbsp;variable that contains the window relative coordinate (x, y, z, 1/w) values for the fragment.
				</p>
			</li>
			<li>
				<p>
                    This value is the result of fixed functionality that interpolates primitives after vertex processing to generate fragments.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Multi-sampling
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            If multi-sampling, this value can be for any location within the pixel, or one of the fragment samples.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Depth
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The 
                            <code>z</code>
                            &nbsp;component is the depth value that would be used for the fragment's depth if no shader contained any writes to 
                            <code>gl_FragDepth</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            <code>gl_FragCoord.z</code>
                            &nbsp;is the depth value of the fragment that your shader is operating on, 
							<strong>
                                not
							</strong>
                            &nbsp;the current value of the depth buffer at the fragment position.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Changing the origin, by redeclaring it
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>gl_FragCoord</code>
                            &nbsp;may be redeclared with the additional layout qualifier identifiers 
                            <code>origin_upper_left</code>
                            &nbsp;or 
                            <code>pixel_center_integer</code>
                            . By default, 
                            <code>gl_FragCoord</code>
                            &nbsp;assumes a lower-left origin for window coordinates and assumes pixel centers are located at half-pixel centers.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Example
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The 
                                    <code>(x, y)</code>
                                    &nbsp;location 
                                    <code>(0.5, 0.5)</code>
                                    &nbsp;is returned for the lower-left-most pixel in a window. The origin of 
                                    <code>gl_FragCoord</code>
                                    &nbsp;may be changed by redeclaring 
                                    <code>gl_FragCoord</code>
                                    &nbsp;with the 
                                    <code>origin_upper_left</code>
                                    &nbsp;identifier. The values returned can also be shifted by half a pixel in both x and y by 
                                    <code>pixel_center_integer</code>
                                    &nbsp;so it appears the pixels are centered at whole number pixel offsets. This moves the (x, y) value returned by 
                                    <code>gl_FragCoord</code>
                                    &nbsp;of 
                                    <code>(0.5, 0.5)</code>
                                    &nbsp;by default to 
                                    <code>(0.0, 0.0)</code>
                                    &nbsp;with 
                                    <code>pixel_center_integer</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            If 
                            <code>gl_FragCoord</code>
                            &nbsp;is redeclared in any fragment shader in a program, it must be redeclared in all fragment shaders in that program that have static use of 
                            <code>gl_FragCoord</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Redeclaring 
                            <code>gl_FragCoord</code>
                            &nbsp;with any accepted qualifier affects only 
                            <code>gl_FragCoord.x</code>
                            &nbsp;and 
                            <code>gl_FragCoord.y</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            It has no effect on rasterization, transformation or any other part of the OpenGL pipeline or language features.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Available in all versions of glsl.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Depth Execution Modes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    [2025/10/07] Vulkan supports this.
				</p>
				<ul>
					<li>
						<p>
                            Conservative depth can be enabled in Vulkan the same way as in OpenGL (i.e. with 
                            <code>layout(depth_&lt;condition&gt;) out float gl_FragDepth</code>
                            ).
						</p>
					</li>
					<li>
						<p>
                            You can test it and look at the SPIR-V output.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Allows for a possible optimization for implementations that relies on an early depth test to be run before the fragment.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // assume it may be modified in any way
 layout(depth_any) out float gl_FragDepth;
 
 // assume it may be modified such that its value will only increase
 layout(depth_greater) out float gl_FragDepth;
 
 // assume it may be modified such that its value will only decrease
 layout(depth_less) out float gl_FragDepth;
 
 // assume it will not be modified
 layout(depth_unchanged) out float gl_FragDepth;
</code></pre>
		<ul>
			<li>
				<p>
                    <code>GL_ARB_conservative_depth</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Violating the condition​ yields undefined behavior.
				</p>
			</li>
			<li>
				<p>
                    The layout qualifier for 
                    <code>gl_FragDepth</code>
                    &nbsp;specifies constraints on the final value of 
                    <code>gl_FragDepth</code>
                    &nbsp;written by any shader invocation.&nbsp;&nbsp;GL implementations may perform optimizations assuming that the depth test fails (or passes)&nbsp;&nbsp;for a given fragment if all values of 
                    <code>gl_FragDepth</code>
                    &nbsp;consistent with the layout qualifier would fail (or pass).&nbsp;&nbsp;If the final value of 
                    <code>gl_FragDepth</code>
                    &nbsp;is inconsistent with its layout qualifier, the result of the depth test for the corresponding fragment is undefined.&nbsp;&nbsp;However, no error will be generated in this case.&nbsp;&nbsp;When the depth test passes and depth writes are enabled, the value written to the depth buffer is always the value of 
                    <code>gl_FragDepth</code>
                    , whether or not it is consistent with the layout qualifier.
				</p>
			</li>
			<li>
				<p>
                    <code>&lt;depth_any&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The shader compiler will note any assignment to 
                            <code>gl_FragDepth</code>
                            &nbsp;modifying it in an unknown way, and depth testing will always be performed after the shader has executed.
						</p>
					</li>
					<li>
						<p>
                            By default, 
                            <code>gl_FragDepth</code>
                            &nbsp;assumes the 
                            <code>&lt;depth_any&gt;</code>
                            &nbsp;layout qualifier.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>&lt;depth_greater&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The GL will assume that the final value of 
                            <code>gl_FragDepth</code>
                            &nbsp;is greater than or equal to the fragment's interpolated depth value, as given by the 
                            <code>&lt;z&gt;</code>
                            &nbsp;component of 
                            <code>gl_FragCoord</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>&lt;depth_less&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The GL will assume that any modification of 
                            <code>gl_FragDepth</code>
                            &nbsp;will only decrease its value.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>&lt;depth_unchanged&gt;</code>
				</p>
				<ul>
					<li>
						<p>
                            The shader compiler will honor any modification to 
                            <code>gl_FragDepth</code>
                            , but the rest of the GL assume that 
                            <code>gl_FragDepth</code>
                            &nbsp;is not assigned a new value.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    If 
                    <code>gl_FragDepth</code>
                    &nbsp;is redeclared in any fragment shader in a program, it must be redeclared in all fragment shaders in that program that have static assignments to 
                    <code>gl_FragDepth</code>
                    . All redeclarations of 
                    <code>gl_FragDepth</code>
                    &nbsp;in all fragment shaders in a single program must have the same set of qualifiers. Within any shader, the first redeclarations of 
                    <code>gl_FragDepth</code>
                    &nbsp;must appear before any use of 
                    <code>gl_FragDepth</code>
                    . The built-in 
                    <code>gl_FragDepth</code>
                    &nbsp;is only predeclared in fragment shaders, so redeclaring it in any other shader stage will be illegal.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="depth-test" >
    Depth Test
</h5>
<ul>
	<li>
		<p>
            If the test fails, the fragment is discarded.
		</p>
	</li>
	<li>
		<p>
            If the test passes, the depth attachment will be updated with the fragment’s output depth.
		</p>
	</li>
</ul>
<h5
	id="depth-bias" >
    Depth Bias
</h5>
<ul>
	<li>
		<p>
            Requires the 
            <code>VkPhysicalDeviceFeatures::depthBiasClamp</code>
            &nbsp;feature to be supported otherwise 
            <code>VkPipelineRasterizationStateCreateInfo::depthBiasClamp</code>
            &nbsp;must be 
            <code>0.0f</code>
            .
		</p>
	</li>
	<li>
		<p>
            The depth bias values can be set 
			<a
				href="https://docs.vulkan.org/guide/latest/dynamic_state.html" 
				class="external-link" 
				target="_blank" >
                dynamically
			</a>
            &nbsp;using 
            <code>VK_DYNAMIC_STATE_DEPTH_BIAS</code>
            &nbsp;or the 
            <code>VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT</code>
            &nbsp;from 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_extended_dynamic_state2.html" 
				class="external-link" 
				target="_blank" >
                VK_EXT_extended_dynamic_state2
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            The rasterizer can alter the depth values by adding a constant value or biasing them based on a fragment’s slope.
		</p>
	</li>
	<li>
		<p>
            Controls whether to bias fragment depth values.
		</p>
	</li>
	<li>
		<p>
            This is sometimes used for shadow mapping.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Bias Constant Factor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a scalar factor controlling the constant depth value added to each fragment.
				</p>
			</li>
			<li>
				<p>
                    Scales the parameter 
                    <code>r</code>
                    &nbsp;of the depth attachment
				</p>
			</li>
			<li>
				<p>
                    &quot;
                    <code>depthBiasConstantFactor</code>
                    &nbsp;is a scalar factor controlling the constant depth value added to each fragment. The value is in floating point and a typical value seems to be around 2.0-3.0.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bias Slope Factor
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is a scalar factor applied to a fragment’s slope in depth bias calculations.
				</p>
			</li>
			<li>
				<p>
                    Scales the maximum depth slope 
                    <code>m</code>
                    &nbsp;of the polygon.
				</p>
			</li>
			<li>
				<p>
                    &quot;I stumbled upon some Vulkan samples that used a much smaller constant bias, but the slope bias was quite high. However, because the slope bias has a much larger weight than the constant one it pretty much worked the same.&quot;
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bias Clamp
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Is the maximum (or minimum) depth bias of a fragment.
				</p>
			</li>
			<li>
				<p>
                    The scaled terms 
                    <code>depthBiasConstantFactor</code>
                    &nbsp;and 
                    <code>depthBiasSlopeFactor</code>
                    &nbsp;are summed to produce a value which is then clamped to a minimum or maximum value specified.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="depth-bounds" >
    Depth Bounds
</h5>
<ul>
	<li>
		<p>
            If the value is not within the depth bounds, the coverage mask is set to zero.
		</p>
	</li>
	<li>
		<p>
            Requires the 
            <code>VkPhysicalDeviceFeatures::depthBounds</code>
            &nbsp;feature to be supported.
		</p>
	</li>
	<li>
		<p>
            The depth bound values can be set 
			<a
				href="https://docs.vulkan.org/guide/latest/dynamic_state.html" 
				class="external-link" 
				target="_blank" >
                dynamically
			</a>
            &nbsp;using 
            <code>VK_DYNAMIC_STATE_DEPTH_BOUNDS</code>
            &nbsp;or the 
            <code>VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT</code>
            &nbsp;from 
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_extended_dynamic_state.html" 
				class="external-link" 
				target="_blank" >
                VK_EXT_extended_dynamic_state
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="depth-clamp" >
    Depth Clamp
</h5>
<ul>
	<li>
		<p>
            Controls whether to clamp the fragment’s depth values as described in Depth Test.
		</p>
	</li>
	<li>
		<p>
            Before the sample’s 
            <code>Zf</code>
            &nbsp;is compared to 
            <code>Za</code>
            , 
            <code>Zf</code>
            &nbsp;is clamped to 
            <code>[min(n,f), max(n,f)]</code>
            , where 
            <code>n</code>
            &nbsp;and 
            <code>f</code>
            &nbsp;are the 
            <code>minDepth</code>
            &nbsp;and 
            <code>maxDepth</code>
            &nbsp;depth range values of the viewport used by this fragment, respectively.
		</p>
	</li>
	<li>
		<p>
            If set to 
            <code>VK_TRUE</code>
            , then fragments that are beyond the near and far planes are clamped to them as opposed to discarding them.
		</p>
	</li>
	<li>
		<p>
            This is useful in some special cases like 
			<em>
                shadow maps
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            Requires the 
            <code>VkPhysicalDeviceFeatures::depthClamp</code>
            &nbsp;feature to be supported.
		</p>
	</li>
</ul>
<h3
	id="depth-attachment" >
    Depth Attachment
</h3>
<h5
	id="clearing" >
    Clearing
</h5>
<ul>
	<li>
		<p>
            It is always better to clear a depth buffer at the start of the pass with 
            <code>loadOp</code>
            &nbsp;set to 
            <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>
            .
		</p>
	</li>
	<li>
		<p>
            Depth images can also be cleared outside a render pass using 
            <code>vkCmdClearDepthStencilImage</code>
            .
		</p>
	</li>
	<li>
		<p>
            When clearing, notice that 
            <code>VkClearValue</code>
            &nbsp;is a union and 
            <code>VkClearDepthStencilValue depthStencil</code>
            &nbsp;should be set instead of the color clear value.
		</p>
	</li>
</ul>
<h5
	id="multi-sampling" >
    Multi-sampling
</h5>
<ul>
	<li>
		<p>
            The following post-rasterization occurs as a &quot;per-sample&quot; operation. This means when doing multisampling with a color attachment, any &quot;depth buffer&quot; 
            <code>VkImage</code>
            &nbsp;used as well must also have been created with the same 
            <code>VkSampleCountFlagBits</code>
            &nbsp;value.
		</p>
	</li>
	<li>
		<p>
            A 
			<em>
                coverage mask
			</em>
            &nbsp;is generated for each fragment, based on which samples within that fragment are determined to be within the area of the primitive that generated the fragment.
		</p>
	</li>
	<li>
		<p>
            If a fragment operation results in all bits of the coverage mask being 
            <code>0</code>
            , the fragment is discarded.
		</p>
	</li>
	<li>
		<p>
			<em>
                Resolving
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is possible in Vulkan using the 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/cleanup.html#vk_khr_depth_stencil_resolve" 
						class="external-link" 
						target="_blank" >
                        VK_KHR_depth_stencil_resolve
					</a>
                    &nbsp;extension (promoted to Vulkan core in 1.2) to resolve multisampled depth/stencil attachments in a subpass in a similar manner as for color attachments.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="depth-image" >
    Depth Image
</h3>
<h5
	id="formats" >
    Formats
</h5>
<ul>
	<li>
		<p>
            Nvidia: Prefer using 
            <code>D24_UNORM_S8_UINT</code>
            &nbsp;or 
            <code>D32_SFLOAT</code>
            &nbsp;depth formats, 
            <code>D32_SFLOAT_S8_UINT</code>
            &nbsp;is not optimal.
		</p>
	</li>
	<li>
		<p>
            There are a few different depth formats and an implementation may expose support for in Vulkan.
		</p>
	</li>
	<li>
		<p>
            For 
			<strong>
                reading
			</strong>
            &nbsp;from a depth image only 
            <code>D16_UNORM</code>
            &nbsp;and 
            <code>D32_SFLOAT</code>
            &nbsp;are required to support being read via sampling or blit operations.
		</p>
	</li>
	<li>
		<p>
            For 
			<strong>
                writing
			</strong>
            &nbsp;to a depth image 
            <code>FORMAT_D16_UNORM</code>
            &nbsp;is required to be supported. From here at least one of (
            <code>VK_FORMAT_X8_D24_UNORM_PACK32</code>
            &nbsp;
			<strong>
                or
			</strong>
            &nbsp;
            <code>VK_FORMAT_D32_SFLOAT</code>
            ) 
			<strong>
                and
			</strong>
            &nbsp;(
            <code>VK_FORMAT_D24_UNORM_S8_UINT</code>
            &nbsp;
			<strong>
                or
			</strong>
            &nbsp;
            <code>VK_FORMAT_D32_SFLOAT_S8_UINT</code>
            ) must also be supported. This will involve some extra logic when trying to find which format to use if 
			<strong>
                both
			</strong>
            &nbsp;the depth and stencil are needed in the same format.
		</p>
	</li>
</ul>
<h5
	id="aspect-masks" >
    Aspect Masks
</h5>
<ul>
	<li>
		<p>
            Required when performing operations such as image barriers or clearing.
		</p>
	</li>
	<li>
		<p>
            <code>DEPTH</code>
		</p>
	</li>
</ul>
<h5
	id="sharing-mode" >
    Sharing Mode
</h5>
<ul>
	<li>
		<p>
            Nvidia: 
            <code>VkSharingMode</code>
            &nbsp;is ignored by the driver, so 
            <code>VK_SHARING_MODE_CONCURRENT</code>
            &nbsp;incurs no overhead relative to 
            <code>VK_SHARING_MODE_EXCLUSIVE</code>
            .
		</p>
	</li>
</ul>
<h5
	id="layout-transition" >
    Layout Transition
</h5>
<pre><code class="language-c" data-lang="c">// Example of going from undefined layout to a depth attachment to be read and written to

// Core Vulkan example
srcAccessMask = 0;
dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
destinationStage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;

// VK_KHR_synchronization2
srcAccessMask = VK_ACCESS_2_NONE_KHR;
dstAccessMask = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR | VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR;
sourceStage = VK_PIPELINE_STAGE_2_NONE_KHR;
destinationStage = VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR | VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR;
</code></pre>
<ul>
	<li>
		<p>
            If unsure to use only early or late fragment tests for your application, use both.
		</p>
	</li>
</ul>
<h5
	id="copying" >
    Copying
</h5>
<ul>
	<li>
		<p>
            Nvidia: Copy both depth and stencil to avoid a slow path for copying.
		</p>
	</li>
</ul>
<h5
	id="reverse-depth-buffer" >
    Reverse Depth Buffer
</h5>
<ul>
	<li>
		<p>
            See 
            <a href="Graphics Programming, Shaders.html#Projection Matrix">
            Graphics Programming, Shaders#Projection Matrix
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="normal-reconstruction-from-depth" >
    Normal Reconstruction from Depth
</h3>
<ul>
	<li>
		<p>
            You can infer the normals by calculating the derivatives on x and y between pixels of the depth buffer.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.reddit.com/r/GraphicsProgramming/comments/14fevz1/faster_to_calculate_normals_from_depth_than_to/" 
				class="external-link" 
				target="_blank" >
                Discussion
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2019/09/improved-normal-reconstruction-from-depth/" 
				class="external-link" 
				target="_blank" >
                Implementation - Wicked Engine (János Turánszki (turanszkij))
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://atyuwen.github.io/posts/normal-reconstruction/" 
				class="external-link" 
				target="_blank" >
                Implementation - Yuwen Wu (atyuwen)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Need
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;In screen-space decals rendering, normal buffer is required to reject pixels projected onto near-perpendicular surfaces. But back then I was working on a forward pipeline, so no normal buffer was outputted. It seemed the best choice was to reconstruct it directly from depth buffer, as long as we could avoid introducing errors, which was not easy though.&quot;
				</p>
			</li>
			<li>
				<p>
                    So, for a forward shading, this 
					<em>
                        could
					</em>
                    &nbsp;be necessary.
				</p>
			</li>
			<li>
				<p>
                    It could be avoided if saving the normals in a texture to be sent to a post-processing pass; aka, if introduced a bit of deferred in the forward renderer.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Performance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    There's a lot of discussion if this is worthwhile. On a deferred renderer, this could be good, but the gain in performance is not obvious. It really depends on how it was implemented.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="stencil" >
    Stencil
</h3>
<ul>
	<li>
		<p>
            <img src="assets/image_20250929094247.png" width="350" >
            .
		</p>
	</li>
	<li>
		<p>
            1 or 0, if have a fragment from our object.
		</p>
	</li>
</ul>
<h5
	id="used-in" >
    Used in
</h5>
<ul>
	<li>
		<p>
            Portals.
		</p>
	</li>
	<li>
		<p>
            Mirrors.
		</p>
	</li>
	<li>
		<p>
            Outlining
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=SlV7nxqCX8Y" 
				class="external-link" 
				target="_blank" >
                Non-Euclidean - demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=xj3Pi6QmXQc" 
				class="external-link" 
				target="_blank" >
                See through - demo
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="stencil-attachment" >
    Stencil Attachment
</h3>
<ul>
	<li>
		<p>
            The 
            <code>PipelineRenderingCreateInfo</code>
            &nbsp;asks for a 
            <code>stencilAttachmentFormat</code>
            , and 
            <code>RenderingInfo</code>
            &nbsp;asks for 
            <code>pStencilAttachment</code>
            .
		</p>
	</li>
	<li>
		<p>
            This is for cases where you want separate depth and stencil images, instead of merged together, like when having a depth image with 
            <code>D24_UNORM_S8_UINT</code>
            , where the 
            <code>S8_UINT</code>
            &nbsp;is for the stencil.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_separate_depth_stencil_layouts.html" 
				class="external-link" 
				target="_blank" >
                <code>VK_KHR_separate_depth_stencil_layouts</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.2.
				</p>
			</li>
			<li>
				<p>
                    This extension allows image memory barriers for 'depth+stencil' images to have just one of the 
                    <code>IMAGE_ASPECT_DEPTH</code>
                    &nbsp;or 
                    <code>IMAGE_ASPECT_STENCIL</code>
                    &nbsp;aspect bits set, rather than require both. This allows their layouts to be set independently. Image Layouts 
                    <code>IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL</code>
                    , 
                    <code>IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL</code>
                    , 
                    <code>IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL</code>
                    , or 
                    <code>IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL</code>
                    &nbsp;can be used.
				</p>
			</li>
			<li>
				<p>
                    To support depth+stencil images with different layouts for the depth and stencil aspects, the depth+stencil attachment interface has been updated to support a separate layout for stencil.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Structure describing whether the implementation can do depth and stencil image barriers separately.
						</p>
					</li>
					<li>
						<p>
                            It's just a struct with a bool telling if the feature is supported.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>For render passes / subpasses</s>:
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescriptionStencilLayoutKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkAttachmentDescriptionStencilLayout</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Deprecated in Vulkan 1.4.
								</p>
							</li>
							<li>
								<p>
                                    Extends 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkAttachmentDescription2</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Deprecated in Vulkan 1.4.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReferenceStencilLayoutKHR.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkAttachmentReferenceStencilLayout</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Not deprecated.
								</p>
							</li>
							<li>
								<p>
                                    Extends 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReference2.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkAttachmentReference2</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Deprecated in Vulkan 1.4.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="formats" >
    Formats
</h5>
<ul>
	<li>
		<p>
            <code>S8_UINT</code>
		</p>
		<ul>
			<li>
				<p>
                    It makes sense, as it's the same format used for stencil in the depth format 
                    <code>D24_UNORM_S8_UINT</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="mapping-data-to-shaders" >
    Mapping Data to Shaders
</h2>
<h3
	id="shader-memory" >
    Shader Memory
</h3>
<h5
	id="minimum-dynamic-offset-cbv-allocation-granularity" >
    Minimum Dynamic-Offset / CBV Allocation Granularity
</h5>
<ul>
	<li>
		<p>
            GPUs and drivers require that when you bind or use a portion of a large buffer as a uniform/constant buffer the start address and/or size line up to an alignment.
		</p>
	</li>
	<li>
		<p>
            That alignment is the “minimum dynamic-offset” (Vulkan) or the CBV/constant buffer granularity (D3D12).
		</p>
	</li>
	<li>
		<p>
            It lets the driver map many small logical buffers into a single big GPU buffer efficiently.
		</p>
	</li>
	<li>
		<p>
            If you bind at an unaligned offset the API/driver will reject it or you will get wrong data or degraded performance.
		</p>
	</li>
	<li>
		<p>
            Drivers can report 64, 128, 256, or other powers of two.
		</p>
	</li>
	<li>
		<p>
            UBO alignment is usually larger than SSBO alignment because UBO usage and caches are handled differently by the hardware.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Value
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Many APIs and drivers use 256 bytes as the Minimum Dynamic-Offset on common desktop GPUs.
				</p>
				<ul>
					<li>
						<p>
                            VkGuide:
						</p>
					</li>
				</ul>
<pre><code class="language-cpp" data-lang="cpp"> struct MaterialConstants {&nbsp;&nbsp;// written into uniform buffers later
&nbsp;&nbsp;&nbsp;&nbsp; glm::vec4 colorFactors; // multiply the color texture
&nbsp;&nbsp;&nbsp;&nbsp; glm::vec4 metal_rough_factors;
&nbsp;&nbsp;&nbsp;&nbsp; glm::vec4 extra[14];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padding, we need it anyway for uniform buffers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it needs to meet a minimum requirement for its alignment. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256 bytes is a good default alignment for this which all the gpus we target meet, so we are adding those vec4s to pad the structure to 256 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
 };
</code></pre>
			</li>
			<li>
				<p>
                    But not every platform or GPU guarantees 256. Mobile or integrated GPUs may have different values.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkPhysicalDeviceLimits</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>minUniformBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
                                    <code>VkDescriptorBufferInfo</code>
                                    &nbsp;structure for uniform buffers.
								</p>
							</li>
							<li>
								<p>
                                    When a descriptor of type 
                                    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
                                    &nbsp;or 
                                    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                    &nbsp;is updated, the 
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    Similarly, dynamic offsets for uniform buffers 
									<strong>
                                        must
									</strong>
                                    &nbsp;be multiples of this limit.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minStorageBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
                                    <code>VkDescriptorBufferInfo</code>
                                    &nbsp;structure for storage buffers.
								</p>
							</li>
							<li>
								<p>
                                    When a descriptor of type 
                                    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
                                    &nbsp;or 
                                    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                    &nbsp;is updated, the 
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be an integer multiple of this limit.
								</p>
							</li>
							<li>
								<p>
                                    Similarly, dynamic offsets for storage buffers 
									<strong>
                                        must
									</strong>
                                    &nbsp;be multiples of this limit.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minTexelBufferOffsetAlignment</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the minimum 
									<strong>
                                        required
									</strong>
                                    &nbsp;alignment, in bytes, for the 
                                    <code>offset</code>
                                    &nbsp;member of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkBufferViewCreateInfo
									</a>
                                    &nbsp;structure for texel buffers.
								</p>
							</li>
							<li>
								<p>
                                    If the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-texelBufferAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>texelBufferAlignment</code>
									</a>
                                    &nbsp;feature is enabled, this limit is equivalent to the maximum of the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-uniformTexelBufferOffsetAlignmentBytes" 
										class="external-link" 
										target="_blank" >
                                        <code>uniformTexelBufferOffsetAlignmentBytes</code>
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-storageTexelBufferOffsetAlignmentBytes" 
										class="external-link" 
										target="_blank" >
                                        <code>storageTexelBufferOffsetAlignmentBytes</code>
									</a>
                                    &nbsp;members of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html" 
										class="external-link" 
										target="_blank" >
                                        VkPhysicalDeviceTexelBufferAlignmentProperties
									</a>
                                    , but smaller alignment is 
									<strong>
                                        optionally
									</strong>
                                    &nbsp;allowed by 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-storageTexelBufferOffsetSingleTexelAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>storageTexelBufferOffsetSingleTexelAlignment</code>
									</a>
                                    &nbsp;and 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#limits-uniformTexelBufferOffsetSingleTexelAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>uniformTexelBufferOffsetSingleTexelAlignment</code>
									</a>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    If the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#features-texelBufferAlignment" 
										class="external-link" 
										target="_blank" >
                                        <code>texelBufferAlignment</code>
									</a>
                                    &nbsp;feature is not enabled, 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkBufferViewCreateInfo
									</a>
                                    ::
                                    <code>offset</code>
                                    &nbsp;
									<strong>
                                        must
									</strong>
                                    &nbsp;be a multiple of this value.
								</p>
							</li>
							<li>
								<p>
                                    The value 
									<strong>
                                        must
									</strong>
                                    &nbsp;be a power of two.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Best practice
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Query the GPU at runtime and align your buffer ranges to the reported value.
				</p>
			</li>
			<li>
				<p>
                    Assert size at compile time:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c"> static_assert(sizeof(MaterialConstants) == 256, "MaterialConstants must be 256 bytes");
</code></pre>
	</li>
</ul>
<h5
	id="default-layouts" >
    Default Layouts
</h5>
<ul>
	<li>
		<p>
			<strong>
                UBOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std140.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                SSBOs
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std430.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    std430 (Vulkan).
				</p>
			</li>
			<li>
				<p>
                    Source: 
					<a
						href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf" 
						class="external-link" 
						target="_blank" >
                        GLSL Spec 4.60.8
					</a>
                    , page 90.
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.pdf" 
								class="external-link" 
								target="_blank" >
                                OpenGL Spec 4.6
							</a>
                            , page 146 (7.6.2.2).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="alignment-options" >
    Alignment Options
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/interfaces.html#interfaces-resources-layout" 
				class="external-link" 
				target="_blank" >
                Offset and Stride Assignment
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            There are different alignment requirements depending on the specific resources and on the features enabled.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Platform dependency
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        32-bit IEEE-754
					</strong>
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 4 bytes.
						</p>
					</li>
					<li>
						<p>
                            The standard for desktop, mobile, OpenGL ES and Vulkan.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        16-bit half precision
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 2 bytes.
						</p>
					</li>
					<li>
						<p>
                            In rare cases, like embedded or custom OpenGL drivers.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        64-bit IEEE-754 double
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The scalar value is 8 bytes.
						</p>
					</li>
					<li>
						<p>
                            Non-standard case.
						</p>
					</li>
					<li>
						<p>
                            Would require headers redefining 
                            <code>GLfloat</code>
                            &nbsp;as 
                            <code>double</code>
                            , not compliant with spec.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            C layout ≈ 
            <code>std430</code>
            &nbsp;only if you manually match packing and alignment. Otherwise, it’s platform-dependent.
		</p>
	</li>
</ul>
<p
	class="table" >
    | GLSL type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| C equivalent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Typical C (x86_64) - Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Typical C (x86_64) - Size | Typical C (x86_64) - Stride |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std140 - Base Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std140 - Occupied Size |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std140 - Stride | std430 - Base Alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std430 - Occupied Size |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std430 - Stride |
    <br>
    | -------------------------------- | --------------------------------------------------- | -----------------------------: | -----------------------------------: | --------------------------: | -----------------------------------------------------------------------------------------: | ------------------------------------: | ---------------------------------------: | ----------------------: | ----------------------------------------------------: | ------------------------------------------: |
    <br>
    | 
    <code>bool</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| C 
    <code>_Bool</code>
    &nbsp;(native) — or use 
    <code>int32_t</code>
    &nbsp;to match GLSL |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;
    <code>_Bool</code>
    : 1; 
    <code>int32_t</code>
    : 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 | 16 (std140 rounds scalar arrays to vec4) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>int</code>
    &nbsp;/ 
    <code>uint</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>int32_t</code>
    &nbsp;/ 
    <code>uint32_t</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>float</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |
    <br>
    | 
    <code>double</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>double</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 (rounded to dvec4 alignment) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |
    <br>
    | 
    <code>vec2</code>
    &nbsp;/ 
    <code>ivec2</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[2]</code>
    &nbsp;/ 
    <code>int32_t[2]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |
    <br>
    | 
    <code>vec3</code>
    &nbsp;/ 
    <code>ivec3</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[3]</code>
    &nbsp;/ 
    <code>int32_t[3]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>vec4</code>
    &nbsp;/ 
    <code>ivec4</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>float[4]</code>
    &nbsp;/ 
    <code>int32_t[4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>dvec2</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[2]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>dvec3</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[3]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |
    <br>
    | 
    <code>dvec4</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>double[4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 |
    <br>
    | 
    <code>mat2</code>
    &nbsp;(2×2 float, column-major) | 
    <code>float[2][2]</code>
    &nbsp;(2 columns of 
    <code>vec2</code>
    )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 × 2 = 32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 × 2 = 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec2 as stride (8) |
    <br>
    | 
    <code>mat3</code>
    &nbsp;(3×3 float, column-major) | 
    <code>float[3][3]</code>
    &nbsp;(3 columns of 
    <code>vec3</code>
    )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 36 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 × 3 = 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 × 3 = 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each column has vec3 as stride (16) |
    <br>
    | 
    <code>mat4</code>
    &nbsp;(4×4 float)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float[4][4]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 (column size) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 x 4 = 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each column has vec4 as stride (16) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 × 4 = 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each column has vec4 as stride (16) |
    <br>
    | 
    <code>T[]</code>
    &nbsp;(Array of T)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>T[]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alignof(T) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(T) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(T) | base_align(T), rounded up to vec4 base align (16 for 32-bit scalars; 32 for 64-bit/double) | occupied per element = rounded stride |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base_align(T), rounded up to 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_align(T) | occupied per element = sizeof(T) rounded to alignment |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_align(T) |
    <br>
    | 
    <code>vec3[]</code>
    &nbsp;(Array of vec3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
    <code>float[3][]</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 |
    <br>
    | 
    <code>struct</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
    <code>struct { ... }</code>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(member alignment) | struct size padded to that alignment |&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct) (padded) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(member align) rounded up to vec4 (16) |&nbsp;&nbsp;struct size padded to multiple of 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(struct) rounded up to 16 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max(member align) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct size padded to that alignment | sizeof(struct) (padded to member alignment) |
</p>
<h5
	id="scalar-alignment" >
    Scalar Alignment
</h5>
<ul>
	<li>
		<p>
            Looks like 
			<em>
                std430
			</em>
            , but its vectors are even more compact?
		</p>
	</li>
	<li>
		<p>
            Also known as (?) The spec doesn't say.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#VK_EXT_scalar_block_layout" 
				class="external-link" 
				target="_blank" >
                <code>VK_EXT_scalar_block_layout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.2.
				</p>
			</li>
			<li>
				<p>
                    This extension allows most storage types to be aligned in 
                    <code>scalar</code>
                    &nbsp;alignment.
				</p>
			</li>
			<li>
				<p>
                    Make sure to set 
                    <code>--scalar-block-layout</code>
                    &nbsp;when running the SPIR-V Validator.
				</p>
			</li>
			<li>
				<p>
                    A big difference is being able to straddle the 16-byte boundary.
				</p>
			</li>
			<li>
				<p>
                    In GLSL this can be used with 
                    <code>scalar</code>
                    &nbsp;keyword and extension
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="extended-alignment-std140" >
    Extended Alignment (std140)
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.oreilly.com/library/view/opengl-programming-guide/9780132748445/app09lev1sec2.html" 
				class="external-link" 
				target="_blank" >
                Source
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Conservative, padded layout used for uniform blocks.
		</p>
	</li>
	<li>
		<p>
            Widely supported.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Caveats
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Avoiding usage of vec3&quot;
				</p>
				<ul>
					<li>
						<p>
                            Usually applies to std140, because some hardware vendors seem to not follow the spec strictly. Although, everything should work when using std430.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Array of 
                                <code>vec3</code>
                                &nbsp;(ARRAY)
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Alignment will be 4x of a 
                                    <code>float</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Size will be 
                                    <code>alignment * amount of elements</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">// Scalars
&nbsp;&nbsp;&nbsp;&nbsp;float -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp; -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;
// Vectors
&nbsp;&nbsp;&nbsp;&nbsp;// Base alignments
&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;&nbsp;-&gt;&nbsp;&nbsp;8 bytes&nbsp;&nbsp;// 2 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;
// Arrays
&nbsp;&nbsp;&nbsp;&nbsp;// Size of the element type, rounded up to a multiple of the size of `vec4` (behave like `vec4` slots).
&nbsp;&nbsp;&nbsp;&nbsp;// Arrays of types are not necessarily tightly packed.
&nbsp;&nbsp;&nbsp;&nbsp;// An array of floats in such a block will not be the equivalent to an array of floats in C/C++. Arrays will only match their C/C++ definitions if the type is a multiple of 16 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;// Ex: `float arr[N]` uses 16 bytes per element.

// Matrices
&nbsp;&nbsp;&nbsp;&nbsp;// Treated as arrays of vectors. 
&nbsp;&nbsp;&nbsp;&nbsp;// They are column-major by default; you can change it with `layout(row_major)` or `layout(column_major)`.

// Struct
&nbsp;&nbsp;&nbsp;&nbsp;// The biggest struct member, rounded up to multiples of the size of `vec4` (behave like `vec4` slots).
&nbsp;&nbsp;&nbsp;&nbsp;// Struct members are effectively padded so that each member starts on a 16-byte boundary when necessary.
&nbsp;&nbsp;&nbsp;&nbsp;// The struct size will be the space needed by its members.
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> layout(std140) uniform U { float a[3]; }; // size = 3 * 16 = 48 bytes
</code></pre>
	</li>
</ul>
<h5
	id="base-alignment-std430" >
    Base Alignment (std430)
</h5>
<ul>
	<li>
		<p>
			<strong>
                Allowed usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    SSBOs, Push Constants.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#VK_KHR_uniform_buffer_standard_layout" 
						class="external-link" 
						target="_blank" >
                        <code>VK_KHR_uniform_buffer_standard_layout</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Core in Vulkan 1.2.
						</p>
					</li>
					<li>
						<p>
                            Allows the use of 
                            <code>std430</code>
                            &nbsp;memory layout in UBOs.
						</p>
					</li>
					<li>
						<p>
                            These memory layout changes are only applied to 
                            <code>Uniforms</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://docs.vulkan.org/guide/latest/shader_memory_layout.html#VK_KHR_relaxed_block_layout" 
						class="external-link" 
						target="_blank" >
                        <code>VK_KHR_relaxed_block_layout</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Core in Vulkan 1.1; all Vulkan 1.1+ devices support relaxed block layout.
						</p>
					</li>
					<li>
						<p>
                            This extension allows implementations to indicate they can support more variation in block 
                            <code>Offset</code>
                            &nbsp;decorations.
						</p>
					</li>
					<li>
						<p>
                            This comes up when using 
                            <code>std430</code>
                            &nbsp;memory layout where a 
                            <code>vec3</code>
                            &nbsp;(which is 12 bytes) is still defined as a 16 byte alignment.
						</p>
					</li>
					<li>
						<p>
                            With relaxed block layout an application can fit a 
                            <code>float</code>
                            &nbsp;on either side of the 
                            <code>vec3</code>
                            &nbsp;and maintain the 16 byte alignment between them.
						</p>
					</li>
					<li>
						<p>
                            Currently there is no way in GLSL to legally express relaxed block layout, but a developer can use the 
                            <code>--hlsl-offsets</code>
                            &nbsp;with 
                            <code>glslang</code>
                            &nbsp;to produce the desired offsets.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Relaxed layout used for shader-storage blocks and allows much tighter packing.
		</p>
	</li>
	<li>
		<p>
            Requires newer GLSL 4.3+ or equivalent support.
		</p>
	</li>
</ul>
<pre><code class="language-c" data-lang="c">// Scalars
&nbsp;&nbsp;&nbsp;&nbsp;float -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp; -&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;-&gt;&nbsp;&nbsp;4 bytes // for 32-bit IEEE-754
&nbsp;&nbsp;&nbsp;&nbsp;
// Vectors
&nbsp;&nbsp;&nbsp;&nbsp;// Base alignments
&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;&nbsp;-&gt;&nbsp;&nbsp;8 bytes&nbsp;&nbsp;// 2 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;&nbsp;-&gt; 16 bytes&nbsp;&nbsp;// 4 times the underlying scalar type.
&nbsp;&nbsp;&nbsp;&nbsp;
// Arrays
&nbsp;&nbsp;&nbsp;&nbsp;// array stride is the natural alignment of the element. 
&nbsp;&nbsp;&nbsp;&nbsp;// Ex: `float arr[N]` uses 4 bytes per element.

// Matrices
&nbsp;&nbsp;&nbsp;&nbsp;// Treated as arrays of vectors. 
&nbsp;&nbsp;&nbsp;&nbsp;// They are column-major by default; you can change it with `layout(row_major)` or `layout(column_major)`.
&nbsp;&nbsp;&nbsp;&nbsp;
// Struct
&nbsp;&nbsp;&nbsp;&nbsp;// Struct packing is tighter and follows natural alignments (less padding).
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Examples
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> layout(std430, binding=0) buffer B { float a[3]; }; // size = 3 * 4 = 12 bytes
</code></pre>
	</li>
</ul>
<h3
	id="comparisons" >
    Comparisons
</h3>
<ul>
	<li>
		<p>
			<strong>
                Input Attributes vs Uniform Buffers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;If you want a shader to access a resource that is 
					<em>
                        not
					</em>
                    &nbsp;on vertex buffers, they must go through a descriptor set&quot;.
				</p>
			</li>
			<li>
				<p>
                    With Vertex Buffers we can pass arbitrary attributes to the vertex shader for each vertex.
				</p>
			</li>
			<li>
				<p>
                    Including global variables as vertex data would be a waste of memory, and it would require us to update the vertex buffer whenever the transformation changes.
				</p>
			</li>
			<li>
				<p>
                    The right way to tackle this in Vulkan is to use Resource Descriptors
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Uniform Buffers vs Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    ChatGPT...
				</p>
			</li>
			<li>
				<p>
                    &quot;Lets say I want to send the time, would it be optimal to send it as a ubo or a push constant? The time should not change between draw calls (it's irrelevant) in the same frame. Seems like a UBO I only need to set it once and every object would benefit from it, but a push constant needs to be send for every object?&quot;
				</p>
				<ul>
					<li>
						<p>
                            Exactly. For your “time” value, a Uniform Buffer is generally the more optimal choice in this scenario.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Push Constants
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You must call 
                                    <code>vkCmdPushConstants</code>
                                    &nbsp;for each command buffer section where shaders need it.
								</p>
							</li>
							<li>
								<p>
                                    Since push constants are set per draw/dispatch scope, if you have many objects, you’d be redundantly re-sending the same value (time) multiple times in the same frame.
								</p>
							</li>
							<li>
								<p>
                                    There’s no automatic “shared” state — every pipeline that uses it must get the value pushed explicitly.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Uniform Buffers
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    You can store the time in a uniform buffer once per frame, bind it once in a descriptor set, and then every draw call will see the same value without re-uploading.
								</p>
							</li>
							<li>
								<p>
                                    Works well for “global” frame data (view/proj matrices, time, frame index, etc.).
								</p>
							</li>
							<li>
								<p>
                                    Binding a pre-allocated UBO in a descriptor set has low overhead and avoids per-draw constant pushing.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Performance implication:
							</strong>
						</p>
						<ul>
							<li>
								<p>
                                    If the data is the same for all draws in a frame, a UBO avoids redundant driver calls and state changes, and makes it easier to keep the command buffer lean. Push constants are better suited for per-object or per-draw small data.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Storage Image vs. Storage Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    While both storage images and storage buffers allow for read-write access in shaders, they have different use cases:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Storage Images
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Ideal for 2D or 3D data that benefits from texture operations like filtering or addressing modes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Storage Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Better for arbitrary structured data or when you need to access data in a non-uniform pattern.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Texel Buffer vs. Storage Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Texel buffers and storage buffers also have different strengths:
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Texel Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Provide texture-like access to buffer data, allowing for operations like filtering.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Storage Buffers
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            More flexible for general-purpose data storage and manipulation.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Do keep constant data small, where 128 bytes is a good rule of thumb.
				</p>
			</li>
			<li>
				<p>
                    Do use push constants if you do not want to set up a descriptor set/UBO system.
				</p>
			</li>
			<li>
				<p>
                    Do make constant data directly available in the shader if it is pre-determinable, such as with the use of specialization constants.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Avoid
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Avoid indexing in the shader if possible, such as dynamically indexing into 
                    <code>buffer</code>
                    &nbsp;or 
                    <code>uniform</code>
                    &nbsp;arrays, as this can disable shader optimisations in some platforms.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Failing to use the correct method of constant data will negatively impact performance, causing either reduced FPS and/or increased BW and load/store activity.
				</p>
			</li>
			<li>
				<p>
                    On Mali, register mapped uniforms are effectively free. Any spilling to buffers in memory will increase load/store cache accesses to the per thread uniform fetches.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="input-attributes" >
    Input Attributes
</h3>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            The only shader stage in core Vulkan that has an input attribute controlled by Vulkan is the vertex shader stage (
            <code>VK_SHADER_STAGE_VERTEX_BIT</code>
            ).
		</p>
<pre><code class="language-glsl" data-lang="glsl"> #version 450
 layout(location = 0) in vec3 inPosition;
 
 void main() {
&nbsp;&nbsp;&nbsp;&nbsp; gl_Position = vec4(inPosition, 1.0);
 }
</code></pre>
	</li>
	<li>
		<p>
            Other shader stages, such as a fragment shader stage, have input attributes, but the values are determined from the output of the previous stages run before it.
		</p>
	</li>
	<li>
		<p>
            This involves declaring the interface slots when creating the 
            <code>VkPipeline</code>
            &nbsp;and then binding the 
            <code>VkBuffer</code>
            &nbsp;before draw time with the data to map.
		</p>
	</li>
	<li>
		<p>
            Before calling 
            <code>vkCreateGraphicsPipelines</code>
            &nbsp;a 
            <code>VkPipelineVertexInputStateCreateInfo</code>
            &nbsp;struct will need to be filled out with a list of 
            <code>VkVertexInputAttributeDescription</code>
            &nbsp;mappings to the shader.
		</p>
<pre><code class="language-c" data-lang="c"> VkVertexInputAttributeDescription input = {};
 input.location = 0;
 input.binding&nbsp;&nbsp;= 0;
 input.format&nbsp;&nbsp; = VK_FORMAT_R32G32B32_SFLOAT; // maps to vec3
 input.offset&nbsp;&nbsp; = 0;
</code></pre>
	</li>
	<li>
		<p>
            The only thing left to do is bind the vertex buffer and optional index buffer prior to the draw call.
		</p>
<pre><code class="language-c" data-lang="c"> vkBeginCommandBuffer();
 // ...
 vkCmdBindVertexBuffer();
 vkCmdDraw();
 // ...
 vkCmdBindVertexBuffer();
 vkCmdBindIndexBuffer();
 vkCmdDrawIndexed();
 // ...
 vkEndCommandBuffer();
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxVertexInputAttributes</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxVertexInputAttributeOffset</code>
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="memory-layout" >
    Memory Layout
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250908081102.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081144.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081235.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    Single binding.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250908081301.png" width="500" >
            .
		</p>
		<ul>
			<li>
				<p>
                    One binding per attribute.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            One binding or many bindings? It doesn't matter that much. In some cases one is better, etc, don't worry too much about it.
		</p>
	</li>
</ul>
<h5
	id="vertex-input-binding-vertex-buffer" >
    Vertex Input Binding / Vertex Buffer
</h5>
<ul>
	<li>
		<p>
            Tell Vulkan how to pass this data format to the vertex shader once it's been uploaded into GPU memory
		</p>
	</li>
	<li>
		<p>
            A vertex binding describes at which rate to load data from memory throughout the vertices.
		</p>
	</li>
	<li>
		<p>
            It specifies the number of bytes between data entries and whether to move to the next data entry after each vertex or after each instance.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputBindingDescription.html" 
				class="external-link" 
				target="_blank" >
                <code>VkVertexInputBindingDescription</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>binding</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the index of the binding in the array of bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>stride</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the number of bytes from one entry to the next.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>inputRate</code>
				</p>
				<ul>
					<li>
						<p>
                            <code>VK_VERTEX_INPUT_RATE_VERTEX</code>
						</p>
						<ul>
							<li>
								<p>
                                    Move to the next data entry after each vertex.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>VK_VERTEX_INPUT_RATE_INSTANCE</code>
						</p>
						<ul>
							<li>
								<p>
                                    Move to the next data entry after each instance.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            We're not going to use instanced rendering, so we'll stick to per-vertex data.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputAttributeDescription.html" 
				class="external-link" 
				target="_blank" >
                <code>VkVertexInputAttributeDescription</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    Describes how to handle vertex input.
				</p>
			</li>
			<li>
				<p>
                    An attribute description struct describes how to extract a vertex attribute from a chunk of vertex data originating from a binding description.
				</p>
			</li>
			<li>
				<p>
                    We have two attributes, position and color, so we need two attribute description structs.
				</p>
			</li>
			<li>
				<p>
                    <code>binding</code>
				</p>
				<ul>
					<li>
						<p>
                            Tells Vulkan from which binding the per-vertex data comes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>location</code>
				</p>
				<ul>
					<li>
						<p>
                            References the 
                            <code>location</code>
                            &nbsp;directive of the input in the vertex shader.
						</p>
						<ul>
							<li>
								<p>
                                    The input in the vertex shader with location 
                                    <code>0</code>
                                    &nbsp;is the position, which has two 32-bit float components.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>format</code>
				</p>
				<ul>
					<li>
						<p>
                            Describes the type of data for the attribute.
						</p>
					</li>
					<li>
						<p>
                            Implicitly defines the byte size of attribute data.
						</p>
					</li>
					<li>
						<p>
                            A bit confusingly, the formats are specified using the same enumeration as color formats.
						</p>
					</li>
					<li>
						<p>
                            The following shader types and formats are commonly used together:
						</p>
						<ul>
							<li>
								<p>
                                    <code>float</code>
                                    : 
                                    <code>VK_FORMAT_R32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec2</code>
                                    : 
                                    <code>VK_FORMAT_R32G32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec3</code>
                                    : 
                                    <code>VK_FORMAT_R32G32B32_SFLOAT</code>
								</p>
							</li>
							<li>
								<p>
                                    <code>vec4</code>
                                    : 
                                    <code>VK_FORMAT_R32G32B32A32_SFLOAT</code>
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            As you can see, you should use the format where the amount of color channels matches the number of components in the shader data type.
						</p>
					</li>
					<li>
						<p>
                            It is allowed to use more channels than the number of components in the shader, but they will be silently discarded.
						</p>
						<ul>
							<li>
								<p>
                                    If the number of channels is lower than the number of components, then the BGA components will use default values of 
                                    <code>(0, 0, 1)</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            The color type (
                            <code>SFLOAT</code>
                            , 
                            <code>UINT</code>
                            , 
                            <code>SINT</code>
                            ) and bit width should also match the type of the shader input. See the following examples:
						</p>
						<ul>
							<li>
								<p>
                                    <code>ivec2</code>
                                    : 
                                    <code>VK_FORMAT_R32G32_SINT</code>
                                    , a 2-component vector of 32-bit signed integers
								</p>
							</li>
							<li>
								<p>
                                    <code>uvec4</code>
                                    : 
                                    <code>VK_FORMAT_R32G32B32A32_UINT</code>
                                    , a 4-component vector of 32-bit unsigned integers
								</p>
							</li>
							<li>
								<p>
                                    <code>double</code>
                                    : 
                                    <code>VK_FORMAT_R64_SFLOAT</code>
                                    , a double-precision (64-bit) float
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>offset</code>
				</p>
				<ul>
					<li>
						<p>
                            Specifies the number of bytes since the start of the per-vertex data to read from.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Graphics Pipeline Vertex Input Binding
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    For the following vertices:
				</p>
<pre><code class="language-odin" data-lang="odin"> Vertex :: struct {
     pos:   eng.Vec2,
     color: eng.Vec3,
 }
 
 vertices := [?]Vertex{
     { {  0.0, -0.5 }, { 1.0, 0.0, 0.0 } },
     { {  0.5,  0.5 }, { 0.0, 1.0, 0.0 } },
     { { -0.5,  0.5 }, { 0.0, 0.0, 1.0 } },
 }
</code></pre>
			</li>
			<li>
				<p>
                    We setup this in the Graphics Pipeline creation:
				</p>
<pre><code class="language-odin" data-lang="odin"> vertex_binding_descriptor := vk.VertexInputBindingDescription{
&nbsp;&nbsp;&nbsp;&nbsp; binding   = 0,
&nbsp;&nbsp;&nbsp;&nbsp; stride    = size_of(Vertex),
&nbsp;&nbsp;&nbsp;&nbsp; inputRate = .VERTEX,
 }
 vertex_attribute_descriptor := [?]vk.VertexInputAttributeDescription{
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; binding  = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format   = .R32G32_SFLOAT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset   = cast(u32)offset_of(Vertex, pos),
&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; binding  = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format   = .R32G32B32_SFLOAT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset   = cast(u32)offset_of(Vertex, color),
&nbsp;&nbsp;&nbsp;&nbsp; },
 }
 vertex_input_create_info := vk.PipelineVertexInputStateCreateInfo {
&nbsp;&nbsp;&nbsp;&nbsp; sType                           = .PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
&nbsp;&nbsp;&nbsp;&nbsp; vertexBindingDescriptionCount   = 1,
&nbsp;&nbsp;&nbsp;&nbsp; pVertexBindingDescriptions      = &vertex_binding_descriptor,
&nbsp;&nbsp;&nbsp;&nbsp; vertexAttributeDescriptionCount = len(vertex_attribute_descriptor),
&nbsp;&nbsp;&nbsp;&nbsp; pVertexAttributeDescriptions    = &vertex_attribute_descriptor[0],
 }
</code></pre>
			</li>
			<li>
				<p>
                    The pipeline is now ready to accept vertex data in the format of the 
                    <code>vertices</code>
                    &nbsp;container and pass it on to our vertex shader.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Vertex Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    If you run the program now with validation layers enabled, you'll see that it complains that there is no vertex buffer bound to the binding.
				</p>
			</li>
			<li>
				<p>
                    The next step is to create a vertex buffer and move the vertex data to it so the GPU is able to access it.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Creating
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Follow the tutorial for creating a buffer, specifying 
                            <code>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code>
                            &nbsp;as the 
                            <code>BufferCreateInfo</code>
                            &nbsp;
                            <code>usage</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="index-buffer" >
    Index Buffer
</h5>
<ul>
	<li>
		<p>
			<strong>
                Motivation
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Drawing a rectangle takes two triangles, which means that we need a vertex buffer with six vertices. The problem is that the data of two vertices needs to be duplicated, resulting in redundancies.
				</p>
			</li>
			<li>
				<p>
                    The solution to this problem is to use an index buffer.
				</p>
			</li>
			<li>
				<p>
                    An index buffer is essentially an array of pointers into the vertex buffer.
				</p>
			</li>
			<li>
				<p>
                    It allows you to reorder the vertex data, and reuse existing data for multiple vertices.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250806072114.png" width="350" >
                    .
				</p>
				<ul>
					<li>
						<p>
                            The first three indices define the upper-right triangle, and the last three indices define the vertices for the bottom-left triangle.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It is possible to use either 
                    <code>uint16_t</code>
                    &nbsp;or 
                    <code>uint32_t</code>
                    &nbsp;for your index buffer depending on the number of entries in 
                    <code>vertices</code>
                    . We can stick to 
                    <code>uint16_t</code>
                    &nbsp;for now because we’re using less than 65535 unique vertices.
				</p>
			</li>
			<li>
				<p>
                    Just like the vertex data, the indices need to be uploaded into a 
                    <code>VkBuffer</code>
                    &nbsp;for the GPU to be able to access them.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Creating
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Follow the tutorial for creating a buffer, specifying 
                    <code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code>
                    &nbsp;as the 
                    <code>BufferCreateInfo</code>
                    &nbsp;
                    <code>usage</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Using
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We first need to bind the index buffer, just like we did for the vertex buffer.
				</p>
			</li>
			<li>
				<p>
                    The difference is that you can only have a 
					<strong>
                        single
					</strong>
                    &nbsp;index buffer. It’s unfortunately not possible to use different indices for each vertex attribute, so we do still have to completely duplicate vertex data even if just one attribute varies.
				</p>
			</li>
			<li>
				<p>
                    An index buffer is bound with 
                    <code>vkCmdBindIndexBuffer</code>
                    &nbsp;which has the index buffer, a byte offset into it, and the type of index data as parameters.
				</p>
				<ul>
					<li>
						<p>
                            As mentioned before, the possible types are 
                            <code>VK_INDEX_TYPE_UINT16</code>
                            &nbsp;and 
                            <code>VK_INDEX_TYPE_UINT32</code>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Just binding an index buffer doesn’t change anything yet, we also need to change the drawing command to tell Vulkan to use the index buffer.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Remove
					</em>
                    &nbsp;the 
                    <code>vkCmdDraw</code>
                    &nbsp;line and replace it with 
                    <code>vkCmdDrawIndexed</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexed.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCmdDrawIndexed</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>indexCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    The number of vertices to draw.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>instanceCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    The number of instances to draw.
								</p>
							</li>
							<li>
								<p>
                                    We’re not using instancing, so just specify 
                                    <code>1</code>
                                    &nbsp;instance.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>firstIndex</code>
						</p>
						<ul>
							<li>
								<p>
                                    The base index within the index buffer.
								</p>
							</li>
							<li>
								<p>
                                    Specifies an offset into the index buffer, using a value of 
                                    <code>1</code>
                                    &nbsp;would cause the graphics card to start reading at the second index.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>vertexOffset</code>
						</p>
						<ul>
							<li>
								<p>
                                    The value added to the vertex index before indexing into the vertex buffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>firstInstance</code>
						</p>
						<ul>
							<li>
								<p>
                                    The instance ID of the first instance to draw.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="push-constants" >
    Push Constants
</h3>
<ul>
	<li>
		<p>
            A Push Constant is a small bank of values accessible in shaders.
		</p>
	</li>
	<li>
		<p>
            These are designed for small amount (a few dwords) of high frequency data to be updated per-recording of the command buffer.
		</p>
	</li>
	<li>
		<p>
            So that the shader can understand where this data will be sent, we specify a special push constants 
            <code>&lt;layout&gt;</code>
            &nbsp;in our shader code.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(push_constant) uniform MeshData {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 model;
} mesh_data;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Choosing to use Push Constants
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In early implementations of Vulkan on Arm Mali, this was usually the fastest way of pushing data to your shaders. In more recent times, we have observed on Mali devices that 
					<em>
                        overall
					</em>
                    &nbsp;they can be slower. If performance is something you are trying to maximise on Mali devices, descriptor sets may be the way to go. However, other devices may still favour push constants.
				</p>
			</li>
			<li>
				<p>
                    Having said this, descriptor sets are one of the more complex features of Vulkan, making the convenience of push constants still worth considering as a go-to method, especially if working with trivial data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxPushConstantsSize</code>
				</p>
				<ul>
					<li>
						<p>
                            guaranteed at least 
                            <code>128</code>
                            &nbsp;bytes on all devices.
						</p>
					</li>
					<li>
						<p
							class="line-emphasis" >
                            If you're using Vulkan 1.4 the minimum was increased to 256.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/push_constants.html#push-constants" 
				class="external-link" 
				target="_blank" >
                Push Constants
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="offsets" >
    Offsets
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250829073932.png" width="525" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> layout(push_constant, std430) uniform pc {
&nbsp;&nbsp;&nbsp;&nbsp; layout(offset = 32) vec4 data;
 };
 
 layout(location = 0) out vec4 outColor;
 
 void main() {
&nbsp;&nbsp;&nbsp;&nbsp;outColor = data;
 }
</code></pre>
<pre><code class="language-c" data-lang="c"> VkPushConstantRange range = {};
 range.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
 range.offset = 32;
 range.size = 16;
</code></pre>
	</li>
</ul>
<h5
	id="updating" >
    Updating
</h5>
<ul>
	<li>
		<p>
			<strong>
                Ex1
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Push constants can be incrementally updated over the course of a command buffer.
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c"> // vkBeginCommandBuffer()
 vkCmdBindPipeline();
 vkCmdPushConstants(offset: 0, size: 16, value = [0, 0, 0, 0]);
 vkCmdDraw(); // values = [0, 0, 0, 0]
 
 vkCmdPushConstants(offset: 4, size: 8, value = [1 ,1]);
 vkCmdDraw(); // values = [0, 1, 1, 0]
 
 vkCmdPushConstants(offset: 8, size: 8, value = [2, 2]);
 vkCmdDraw(); // values = [0, 1, 2, 2]
 // vkEndCommandBuffer()
</code></pre>
		<ul>
			<li>
				<p>
                    Interesting how old values are kept. Values that were not changed are preserved.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="lifetime" >
    Lifetime
</h5>
<ul>
	<li>
		<p>
            <code>vkCmdPushConstants</code>
            &nbsp;is tied to the 
            <code>VkPipelineLayout</code>
            &nbsp;usage and therefore why they must match before a call to a command such as 
            <code>vkCmdDraw()</code>
            .
		</p>
	</li>
	<li>
		<p>
            Because push constants are not tied to descriptors, the use of 
            <code>vkCmdBindDescriptorSets</code>
            &nbsp;has no effect on the lifetime or 
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#descriptorsets-compatibility" 
				class="external-link" 
				target="_blank" >
                pipeline layout compatibility
			</a>
            &nbsp;of push constants.
		</p>
	</li>
	<li>
		<p>
            The same way it is possible to bind descriptor sets that are never used by the shader, the same is true for push constants.
		</p>
	</li>
</ul>
<h3
	id="descriptors-sets" >
    Descriptors Sets
</h3>
<h5
	id="about" >
    About
</h5>
<ul>
	<li>
		<p>
            <code>VkDescriptorSet</code>
		</p>
	</li>
	<li>
		<p>
            One Descriptor -&gt; One Resource.
		</p>
	</li>
	<li>
		<p>
            They are always organized in Descriptor Sets.
		</p>
		<ul>
			<li>
				<p>
                    One or more descriptors contained.
				</p>
			</li>
			<li>
				<p>
                    Combine descriptors which are used in conjunction.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A handle or pointer into a resource.
		</p>
		<ul>
			<li>
				<p>
                    Note that is not just a pointer, but a pointer + metadata.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A core mechanism used to bind resources to shaders.
		</p>
	</li>
	<li>
		<p>
            Holds the binding information that connects shader inputs to data such as 
            <code>VkBuffer</code>
            &nbsp;resources and 
            <code>VkImage</code>
            &nbsp;textures.
		</p>
	</li>
	<li>
		<p>
            Think of it as a set of GPU-side pointers that you bind once.
		</p>
	</li>
	<li>
		<p>
            The internal representation of a descriptor set is whatever the driver wants it to be.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Content
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Where to find a Resource.
				</p>
			</li>
			<li>
				<p>
                    Usage type of a Resource.
				</p>
			</li>
			<li>
				<p>
                    Offsets, sometimes.
				</p>
			</li>
			<li>
				<p>
                    Some metadata, sometimes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250813080426.png" width="500" >
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // Note - only set 0 and 2 are used in this shader
 layout(set = 0, binding = 0) uniform sampler2D myTextureSampler;
 
 layout(set = 0, binding = 2) uniform uniformBuffer0 {
&nbsp;&nbsp;&nbsp;&nbsp; float someData;
 } ubo_0;
 
 layout(set = 0, binding = 3) uniform uniformBuffer1 {
&nbsp;&nbsp;&nbsp;&nbsp; float moreData;
 } ubo_1;
 
 layout(set = 2, binding = 0) buffer storageBuffer {
&nbsp;&nbsp;&nbsp;&nbsp; float myResults;
 } ssbo;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                API
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/screenshot_2025-08-06_162739.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250807073221.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>maxBoundDescriptorSets</code>
				</p>
			</li>
			<li>
				<p>
                    Per stage limit
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorSamplers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorUniformBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorStorageBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorSampledImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorStorageImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageDescriptorInputAttachments</code>
				</p>
			</li>
			<li>
				<p>
                    Per type limit
				</p>
			</li>
			<li>
				<p>
                    <code>maxPerStageResources</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetSamplers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetUniformBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetUniformBuffersDynamic</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageBuffers</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageBuffersDynamic</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetSampledImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetStorageImages</code>
				</p>
			</li>
			<li>
				<p>
                    <code>maxDescriptorSetInputAttachments</code>
				</p>
			</li>
			<li>
				<p>
                    <code>VkPhysicalDeviceDescriptorIndexingProperties</code>
                    &nbsp;if using 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/VK_EXT_descriptor_indexing.html#VK_EXT_descriptor_indexing" 
						class="external-link" 
						target="_blank" >
                        Descriptor Indexing
					</a>
				</p>
			</li>
			<li>
				<p>
                    <code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>
                    &nbsp;if using 
					<a
						href="https://docs.vulkan.org/guide/latest/extensions/VK_EXT_inline_uniform_block.html#VK_EXT_inline_uniform_block" 
						class="external-link" 
						target="_blank" >
                        Inline Uniform Block
					</a>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=d5p44idnZLQ" 
				class="external-link" 
				target="_blank" >
                Visual explanation {0:00 -&gt; 5:35}
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Nice.
				</p>
			</li>
			<li>
				<p>
                    The rest of the video is meh.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="difficulties" >
    Difficulties
</h5>
<ul>
	<li>
		<p>
			<strong>
                Problems
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;They are not bad but they very much force a specific rendering style: you have triple / quadrupled nested for loops, binding your things based on usage and then rebind descriptor sets as needed.&quot;
				</p>
			</li>
			<li>
				<p>
                    &quot;Many of us are moving towards bindless rendering, where you just bind everything once in one big descriptor set, and then index into it at will; tho, Vulkan 1.0 does not greatly support, and also the descriptor count for it was quite low&quot;.
				</p>
			</li>
			<li>
				<p>
                    Cannot update descriptors after binding in a command buffer.
				</p>
			</li>
			<li>
				<p>
                    All descriptors must be valid, even if not used.
				</p>
			</li>
			<li>
				<p>
                    Descriptor arrays must be sampled uniformly.
				</p>
				<ul>
					<li>
						<p>
                            Different invocations can’t use different indices.
						</p>
					</li>
					<li>
						<p>
                            Can sample “dynamically uniform”, e.g. runtime-based index.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Upper limit on descriptor counts.
				</p>
			</li>
			<li>
				<p>
                    Discourages GPU-driven rendering architectures.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solutions
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Descriptor Indexing
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Available in 1.3, optional in 1.2, or 
                            <code>VK_EXT_descriptor_indexing</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Update descriptors after binding.
						</p>
					</li>
					<li>
						<p>
                            Update unused descriptors.
						</p>
					</li>
					<li>
						<p>
                            Relax requirement that all descriptors must be valid, even if unused.
						</p>
					</li>
					<li>
						<p>
                            Non-uniform array indexing.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Buffer Device Address
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Available in 1.3, optional in 1.2, or 
                            <code>VK_KHR_buffer_device_address</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Directly access buffers through addresses without a descriptor.
						</p>
					</li>
					<li>
						<p>
                            See [[#Physical Storage Buffer]] below.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Descriptor Buffers – VK_EXT_descriptor_buffer
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Manage descriptors directly.
						</p>
					</li>
					<li>
						<p>
                            <s>Similar to D3D12’s descriptor model </s>.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="descriptor-types" >
    Descriptor Types
</h4>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#descriptorsets-types" 
				class="external-link" 
				target="_blank" >
                Descriptor Types
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="storage-images" >
    Storage Images
</h5>
<ul>
	<li>
		<p>
            <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
		</p>
	</li>
	<li>
		<p>
            Is a descriptor type that allows shaders to read from and write to an image without using a fixed-function graphics pipeline.
		</p>
	</li>
	<li>
		<p>
            This is particularly useful for compute shaders and advanced rendering techniques.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_storage_images" 
				class="external-link" 
				target="_blank" >
                Storage Images and Implementation
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">// VK_FORMAT_R32_UINT
layout(set = 0, binding = 0, r32ui) uniform uimage2D storageImage;

// example usage for reading and writing in GLSL
const uvec4 texel = imageLoad(storageImage, ivec2(0, 0));
imageStore(storageImage, ivec2(1, 1), texel);
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                Use cases
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Image Processing
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Storage images are ideal for image processing tasks like filters, blurs, and other post-processing effects.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="sampler" >
    Sampler
</h5>
<ul>
	<li>
		<p>
            <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>
            &nbsp;and 
            <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler samplerDescriptor;
layout(set = 0, binding = 1) uniform texture2D sampledImage;

// example usage of using texture() in GLSL
vec4 data = texture(sampler2D(sampledImage,&nbsp;&nbsp;samplerDescriptor), vec2(0.0, 0.0));
</code></pre>
<h5
	id="combined-image-sampler" >
    Combined Image Sampler
</h5>
<ul>
	<li>
		<p>
            <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
		</p>
	</li>
	<li>
		<p>
            On some implementations, it 
			<em>
                may
			</em>
            &nbsp;be more efficient to sample from an image using a combination of sampler and sampled image that are stored together in the descriptor set in a combined descriptor.
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D combinedImageSampler;

// example usage of using texture() in GLSL
vec4 data = texture(combinedImageSampler, vec2(0.0, 0.0));
</code></pre>
<h5
	id="uniform-buffer-ubo-uniform-buffer-object" >
    Uniform Buffer / UBO (Uniform Buffer Object)
</h5>
<ul>
	<li>
		<p>
            <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
		</p>
	</li>
	<li>
		<p>
            Uniform buffers can also have 
			<a
				href="https://docs.vulkan.org/guide/latest/descriptor_dynamic_offset.html" 
				class="external-link" 
				target="_blank" >
                dynamic offsets at bind time
			</a>
            &nbsp;(
            <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
            ).
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) uniform uniformBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float a;
&nbsp;&nbsp;&nbsp;&nbsp;int b;
} ubo;

// example of reading from UBO in GLSL
int x = ubo.b + 1;
vec3 y = vec3(ubo.a);
</code></pre>
<ul>
	<li>
		<p>
            Uniform Buffers commonly use 
            <code>std140</code>
            &nbsp;layout (strict alignment rules, predictable padding).
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Source: ChatGPT. I want to confirm.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">/* UBO: small read-only data (std140) */
layout(set = 0, binding = 0, std140) uniform SceneParams {
&nbsp;&nbsp;&nbsp;&nbsp;mat4 viewProj;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 lightPos;
&nbsp;&nbsp;&nbsp;&nbsp;float time;
} scene;
</code></pre>
<ul>
	<li>
		<p>
			<strong>
                UBO (Uniform Buffer Object)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    “Uniform buffer object” is more of an OpenGL-era name, but some Vulkan tutorials and developers still use it informally to mean the same thing — the buffer that holds uniform data.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="storage-buffer-ssbo-shader-storage-buffer-object" >
    Storage Buffer / SSBO (Shader Storage Buffer Object)
</h5>
<ul>
	<li>
		<p>
            <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
		</p>
	</li>
	<li>
		<p>
            Storage buffers can also have 
			<a
				href="https://docs.vulkan.org/guide/latest/descriptor_dynamic_offset.html" 
				class="external-link" 
				target="_blank" >
                dynamic offsets at bind time
			</a>
            &nbsp;(
            <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
            ).
		</p>
	</li>
	<li>
		<p>
            <code>BufferBlock</code>
            &nbsp;and 
            <code>Uniform</code>
            &nbsp;would have been seen prior to 
			<a
				href="https://docs.vulkan.org/guide/latest/extensions/shader_features.html#VK_KHR_storage_buffer_storage_class" 
				class="external-link" 
				target="_blank" >
                VK_KHR_storage_buffer_storage_class
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout(set = 0, binding = 0) buffer storageBuffer {
&nbsp;&nbsp;&nbsp;&nbsp;float a;
&nbsp;&nbsp;&nbsp;&nbsp;int b;
} ssbo;

// example of reading and writing SSBO in GLSL
ssbo.a = ssbo.a + 1.0;
ssbo.b = ssbo.b + 1;
</code></pre>
<ul>
	<li>
		<p>
            Storage Buffers commonly use 
            <code>std430</code>
            &nbsp;layout (tighter packing, fewer padding requirements).
		</p>
		<ul>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
>
                    Source: ChatGPT. I want to confirm.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">/* SSBO: large or writable data (std430) */
layout(set = 0, binding = 1, std430) buffer ParticleData {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 pos[];
} particles;

</code></pre>
<ul>
	<li>
		<p>
			<strong>
                SSBO (Shader Storage Buffer Object)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    OpenGL term.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="texel-buffer" >
    Texel Buffer
</h5>
<ul>
	<li>
		<p>
            Texel buffers are a way to access buffer data with texture-like operations in shaders.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_texel_buffers" 
				class="external-link" 
				target="_blank" >
                Texel Buffers and Implementation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_format_compatibility_requirements" 
				class="external-link" 
				target="_blank" >
                Compatibility Requirements
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The format specified in the shader (SPIR-V Image Format) must 
					<strong>
                        exactly match
					</strong>
                    &nbsp;the format used when creating the VkImageView (Vulkan Format).
				</p>
			</li>
			<li>
				<p>
                    Require exact format matching between the shader and the view. The views must always match the shader exactly.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/storage_image_and_texel_buffers.html#_best_practices" 
				class="external-link" 
				target="_blank" >
                Best Practices
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Uniform Texel Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>
				</p>
			</li>
			<li>
				<p>
                    Read-only access.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> layout(set = 0, binding = 0) uniform textureBuffer uniformTexelBuffer;
 
 // example of reading texel buffer in GLSL
 vec4 data = texelFetch(uniformTexelBuffer, 0);
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Use cases
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Lookup Tables
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Uniform texel buffers are useful for implementing lookup tables that need to be accessed with texture-like operations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Storage Texel Buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>
				</p>
			</li>
			<li>
				<p>
                    Read-write access.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> // VK_FORMAT_R8G8B8A8_UINT
 layout(set = 0, binding = 0, rgba8ui) uniform uimageBuffer storageTexelBuffer;
 
 // example of reading and writing texel buffer in GLSL
 int offset = int(gl_GlobalInvocationID.x);
 vec4 data = imageLoad(storageTexelBuffer, offset);
 imageStore(storageTexelBuffer, offset, uvec4(0));
</code></pre>
		<ul>
			<li>
				<p>
					<strong>
                        Use cases
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Particle Systems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Storage texel buffers can be used to store and update particle data in a compute shader, which can then be read by a vertex shader for rendering.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="input-attachment" >
    Input Attachment
</h5>
<ul>
	<li>
		<p>
            <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
		</p>
	</li>
</ul>
<pre><code class="language-glsl" data-lang="glsl">layout (input_attachment_index = 0, set = 0, binding = 0) uniform subpassInput inputAttachment;

// example loading the attachment data in GLSL
vec4 data = subpassLoad(inputAttachment);
</code></pre>
<h4
	id="implementation" >
    Implementation
</h4>
<h5
	id="descriptor-set-layout" >
    Descriptor Set Layout
</h5>
<ul>
	<li>
		<p>
            Contains the information about what that descriptor set holds.
		</p>
	</li>
	<li>
		<p>
            Specifies the types of resources that are going to be accessed by the pipeline, just like a render pass specifies the types of attachments that will be accessed.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How many
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You need to specify a descriptor set layout for each descriptor set when creating the pipeline layout.
				</p>
				<ul>
					<li>
						<p>
                            You can use this feature to put descriptors that vary per-object and descriptors that are shared into separate descriptor sets.
						</p>
					</li>
					<li>
						<p>
                            In that case, you avoid rebinding most of the descriptors across draw calls which are potentially more efficient.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Since the buffer structure is identical across frames, one layout suffices.
				</p>
				<ul>
					<li>
						<p>
                            Create only 1 descriptor set layout, regardless of frames in-flight.
						</p>
					</li>
					<li>
						<p>
                            This layout defines the type of resource (e.g., 
                            <code>VKDESCRIPTORTYPEUNIFORMBUFFER</code>
                            ) and its binding point.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetLayout</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Opaque handle to a descriptor set layout object.
				</p>
			</li>
			<li>
				<p>
                    Is defined by an array of zero or more descriptor bindings.
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Where it's used
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkPipelineLayoutCreateInfo</code>
							</a>
                            .
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>vkDescriptorSetAllocateInfo</code>
							</a>
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorSetLayoutBinding</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Structure specifying a descriptor set layout binding.
						</p>
					</li>
					<li>
						<p>
                            Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that can access the binding, and (if using immutable samplers) an array of sampler descriptors.
						</p>
					</li>
					<li>
						<p>
                            Bindings that are not specified have a 
                            <code>descriptorCount</code>
                            &nbsp;and 
                            <code>stageFlags</code>
                            &nbsp;of zero, and the value of 
                            <code>descriptorType</code>
                            &nbsp;is undefined.
						</p>
					</li>
					<li>
						<p>
                            <code>binding</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
								</p>
							</li>
							<li>
								<p>
                                    Used in the shader and the type of descriptor, which is a uniform buffer object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>descriptorType</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorType.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorType
									</a>
                                    &nbsp;specifying which type of resource descriptors are used for this binding.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>descriptorCount</code>
						</p>
						<ul>
							<li>
								<p>
									<strong>
                                        Insight
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            It's a descriptor count, 
											<strong>
                                                not a descriptor SET count
											</strong>
                                            !! It's just to specify how many resources is expected to be in that binding.
										</p>
									</li>
									<li>
										<p>
                                            It makes complete sense to be used for arrays.
										</p>
									</li>
									<li>
										<p>
                                            Caio:
										</p>
										<ul>
											<li>
												<p>
                                                    What happens if the values don't match? For example, trying to get the index 5 of the array, when the binding was described having 
                                                    <code>descriptorCount = 1</code>
                                                    &nbsp;?
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Oni:
										</p>
										<ul>
											<li>
												<p>
                                                    I don't know if this is specified. I guess it's only going to update the first element. So you're going to read bogus data. Maybe it changes between different drivers, no idea.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<strong>
                                        What value to use
									</strong>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            A MVP transformation is in a single uniform buffer, so we using a 
                                            <code>descriptorCount</code>
                                            &nbsp;of 
                                            <code>1</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            In other words, a whole struct counts as 
                                            <code>1</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Is the number of descriptors contained in the binding, accessed in a shader as an array.
								</p>
								<ul>
									<li>
										<p>
                                            Except if 
                                            <code>descriptorType</code>
                                            &nbsp;is 
                                            <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                            &nbsp;in which case 
                                            <code>descriptorCount</code>
                                            &nbsp;is the size in bytes of the inline uniform block.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorCount</code>
                                    &nbsp;is zero this binding entry is reserved and the resource 
									<em>
                                        must
									</em>
                                    &nbsp;not be accessed from any stage via this binding within any pipeline using the set layout.
								</p>
							</li>
							<li>
								<p>
                                    It is possible for the shader variable to represent an array of uniform buffer objects, and this property specifies the number of values in the array.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Examples
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            This could be used to specify a transformation for each of the bones in a skeleton for skeletal animation.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>stageFlags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderStageFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkShaderStageFlagBits
									</a>
                                    &nbsp;specifying which pipeline shader stages 
									<strong>
                                        can
									</strong>
                                    &nbsp;access a resource for this binding.
								</p>
								<ul>
									<li>
										<p>
                                            <code>VK_SHADER_STAGE_ALL</code>
                                            &nbsp;is a shorthand specifying all defined shader stages, including any additional stages defined by extensions.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    If a shader stage is not included in 
                                    <code>stageFlags</code>
                                    , then a resource 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be accessed from that stage via this binding within any pipeline using the set layout.
								</p>
							</li>
							<li>
								<p>
                                    Other than input attachments which are limited to the fragment shader, there are no limitations on what combinations of stages 
									<strong>
                                        can
									</strong>
                                    &nbsp;use a descriptor binding, and in particular a binding 
									<strong>
                                        can
									</strong>
                                    &nbsp;be used by both graphics stages and the compute stage.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pImmutableSamplers</code>
						</p>
						<ul>
							<li>
								<p>
                                    Affects initialization of samplers.
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorType</code>
                                    &nbsp;specifies a 
                                    <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>
                                    &nbsp;or 
                                    <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                    &nbsp;type descriptor, then 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;
									<strong>
                                        can
									</strong>
                                    &nbsp;be used to initialize a set of 
									<em>
                                        immutable samplers
									</em>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>descriptorType</code>
                                    &nbsp;is not one of these descriptor types, then 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is 
									<strong>
                                        ignored
									</strong>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    Immutable samplers are permanently bound into the set layout and 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be changed; updating a 
                                    <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>
                                    &nbsp;descriptor with immutable samplers is not allowed and updates to a 
                                    <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                    &nbsp;descriptor with immutable samplers does not modify the samplers (the image views are updated, but the sampler updates are ignored).
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is not 
                                    <code>NULL</code>
                                    , then it is a pointer to an array of sampler handles that will be copied into the set layout and used for the corresponding binding. Only the sampler handles are copied; the sampler objects 
									<strong>
                                        must
									</strong>
                                    &nbsp;not be destroyed before the final use of the set layout and any descriptor pools and sets created using it.
								</p>
							</li>
							<li>
								<p>
                                    If 
                                    <code>pImmutableSamplers</code>
                                    &nbsp;is 
                                    <code>NULL</code>
                                    , then the sampler slots are dynamic and sampler handles 
									<strong>
                                        must
									</strong>
                                    &nbsp;be bound into descriptor sets using this layout. ]
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorSetLayoutCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            <code>pBindings</code>
						</p>
						<ul>
							<li>
								<p>
                                    A pointer to an array of 
                                    <code>VkDescriptorSetLayoutBinding</code>
                                    &nbsp;structures.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>bindingCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of elements in 
                                    <code>pBindings</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>flags</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayoutCreateFlagBits
									</a>
                                    &nbsp;specifying options for descriptor set layout creation.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html" 
						class="external-link" 
						target="_blank" >
                        <code>vkCreateDescriptorSetLayout()</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Create a new descriptor set layout.
						</p>
					</li>
					<li>
						<p>
                            <code>pCreateInfo</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayoutCreateInfo
									</a>
                                    &nbsp;structure specifying the state of the descriptor set layout object.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pAllocator</code>
						</p>
						<ul>
							<li>
								<p>
                                    Controls host memory allocation as described in the 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#memory-allocation" 
										class="external-link" 
										target="_blank" >
                                        Memory Allocation
									</a>
                                    &nbsp;chapter.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pSetLayout</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorSetLayout
									</a>
                                    &nbsp;handle in which the resulting descriptor set layout object is returned.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkPipelineLayoutCreateInfo</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Structure specifying the parameters of a newly created pipeline layout object
				</p>
			</li>
			<li>
				<p>
                    <code>setLayoutCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of descriptor sets included in the pipeline layout.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                How it works
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It's possible to have multiple descriptor sets (
                                    <code>set = 0</code>
                                    , 
                                    <code>set = 1</code>
                                    , etc).
								</p>
							</li>
							<li>
								<p>
                                    &quot;You can have set = 0 being a set that is always bound and never changes, set = 1 is something specific to the current object being rendered, etc.&quot;
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSetLayouts</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>VkDescriptorSetLayout</code>
                            &nbsp;objects.
						</p>
					</li>
					<li>
						<p>
                            The implementation 
							<em>
                                must
							</em>
                            &nbsp;not access these objects outside of the duration of the command this structure is passed to.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="allocation-descriptor-pool" >
    Allocation / Descriptor Pool
</h5>
<ul>
	<li>
		<p>
            Descriptors are like pointers, so as any pointer they need to allocate space to live ahead of time.
		</p>
	</li>
	<li>
		<p>
			<strong>
                How many
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Its possible to have 1 very big descriptor pool that handles the entire engine, but that means we need to know what descriptors we will be using for everything ahead of time.
				</p>
			</li>
			<li>
				<p>
                    That can be very tricky to do at scale. Instead, we will keep it simpler, and we will have 
					<em>
                        multiple descriptor pools for different parts of the project
					</em>
                    , and try to be more accurate with them.
				</p>
				<ul>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            I don't know what that actually means in practice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPool.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorPool</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Maintains a pool of descriptors, from which descriptor sets are allocated.
				</p>
			</li>
			<li>
				<p>
                    Descriptor pools are externally synchronized, meaning that the application 
					<strong>
                        must
					</strong>
                    &nbsp;not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.
				</p>
			</li>
			<li>
				<p>
                    They are very opaque.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateInfo.html" 
						class="external-link" 
						target="_blank" >
                        <code>VkDescriptorPoolCreateInfo</code>
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            Contains a type of descriptor (same 
                            <code>VkDescriptorType</code>
                            &nbsp;as on the bindings above ), alongside a ratio to multiply the 
                            <code>maxSets</code>
                            &nbsp;parameter is.
						</p>
					</li>
					<li>
						<p>
                            This lets us directly control how big the pool is going to be. 
                            <code>maxSets</code>
                            &nbsp;controls how many 
                            <code>VkDescriptorSets</code>
                            &nbsp;we can create from the pool in total, and the pool sizes give how many individual bindings of a given type are owned.
						</p>
					</li>
					<li>
						<p>
                            <code>flags</code>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Is a bitmask of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateFlagBits.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorPoolCreateFlagBits
									</a>
                                    &nbsp;specifying certain supported operations on the pool.
								</p>
							</li>
							<li>
								<p>
                                    <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Determines if individual descriptor sets can be freed or not:
										</p>
									</li>
									<li>
										<p>
                                            We're not going to touch the descriptor set after creating it, so we don't need this flag. You can leave 
                                            <code>flags</code>
                                            &nbsp;to its default value of 
                                            <code>0</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code>
								</p>
								<ul>
									<li>
										<p>
                                            Descriptor pool creation 
											<strong>
                                                may
											</strong>
                                            &nbsp;fail with the error 
                                            <code>VK_ERROR_FRAGMENTATION</code>
                                            &nbsp;if the total number of descriptors across all pools (including this one) created with this bit set exceeds 
                                            <code>maxUpdateAfterBindDescriptorsInAllPools</code>
                                            , or if fragmentation of the underlying hardware resources occurs.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>maxSets</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the maximum number of descriptor sets that 
									<strong>
                                        can
									</strong>
                                    &nbsp;be allocated from the pool.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>poolSizeCount</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is the number of elements in 
                                    <code>pPoolSizes</code>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>pPoolSizes</code>
						</p>
						<ul>
							<li>
								<p>
                                    Is a pointer to an array of 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html" 
										class="external-link" 
										target="_blank" >
                                        VkDescriptorPoolSize
									</a>
                                    &nbsp;structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
								</p>
							</li>
							<li>
								<p>
                                    If multiple 
                                    <code>VkDescriptorPoolSize</code>
                                    &nbsp;structures containing the same descriptor type appear in the 
                                    <code>pPoolSizes</code>
                                    &nbsp;array then the pool will be created with enough storage for the total number of descriptors of each type.
								</p>
							</li>
							<li>
								<p>
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html" 
										class="external-link" 
										target="_blank" >
                                        <code>VkDescriptorPoolSize</code>
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            <code>type</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is the type of descriptor.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <code>descriptorCount</code>
										</p>
										<ul>
											<li>
												<p>
                                                    Is the number of descriptors of that type to allocate. If 
                                                    <code>type</code>
                                                    &nbsp;is 
                                                    <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                                                    &nbsp;then 
                                                    <code>descriptorCount</code>
                                                    &nbsp;is the number of bytes to allocate for descriptors of this type.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
				class="external-link" 
				target="_blank" >
                <code>VkDescriptorSetAllocateInfo</code>
			</a>
		</p>
		<ul>
			<li>
				<p>
                    <code>descriptorPool</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the pool which the sets will be allocated from.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorSetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Determines the number of descriptor sets to be allocated from the pool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pSetLayouts</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkAllocateDescriptorSets()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    The allocated descriptor sets are returned in 
                    <code>pDescriptorSets</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    When a descriptor set is allocated, the initial state is largely uninitialized and all descriptors are undefined, with the exception that samplers with a non-null 
                    <code>pImmutableSamplers</code>
                    &nbsp;are initialized on allocation.
				</p>
			</li>
			<li>
				<p>
                    Descriptors also become undefined if the underlying resource or view object is destroyed.
				</p>
			</li>
			<li>
				<p>
                    Descriptor sets containing undefined descriptors 
					<strong>
                        can
					</strong>
                    &nbsp;still be bound and used, subject to the following conditions:
				</p>
				<ul>
					<li>
						<p>
                            For descriptor set bindings created with the 
                            <code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code>
                            &nbsp;bit set:
						</p>
						<ul>
							<li>
								<p>
                                    All descriptors in that binding that are dynamically used 
									<strong>
                                        must
									</strong>
                                    &nbsp;have been populated before the descriptor set is 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
										class="external-link" 
										target="_blank" >
                                        consumed
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            For descriptor set bindings created without the 
                            <code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code>
                            &nbsp;bit set:
						</p>
						<ul>
							<li>
								<p>
                                    All descriptors in that binding that are statically used 
									<strong>
                                        must
									</strong>
                                    &nbsp;have been populated before the descriptor set is 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
										class="external-link" 
										target="_blank" >
                                        consumed
									</a>
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Descriptor bindings with descriptor type of 
                            <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            &nbsp;
							<strong>
                                can
							</strong>
                            &nbsp;be undefined when the descriptor set is 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#descriptorsets-binding" 
								class="external-link" 
								target="_blank" >
                                consumed
							</a>
                            ; though values in that block will be undefined.
						</p>
					</li>
					<li>
						<p>
                            Entries that are not used by a pipeline 
							<strong>
                                can
							</strong>
                            &nbsp;have undefined descriptors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pAllocateInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSetAllocateInfo
							</a>
                            &nbsp;structure describing parameters of the allocation.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorSets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSet
							</a>
                            &nbsp;handles in which the resulting descriptor set objects are returned.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="update-write" >
    Update / Write
</h5>
<ul>
	<li>
		<p>
            A Descriptor Set, even though created and allocated, is still empty. We need to fill it up with data.
		</p>
	</li>
	<li>
		<p>
            Updates 
			<strong>
                must
			</strong>
            &nbsp;happen outside of a command record and execution.
		</p>
		<ul>
			<li>
				<p>
                    No update after 
                    <code>vkCmdBindDescriptorSets()</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Usually you update before 
                    <code>vkBeginCommandBuffer()</code>
                    &nbsp;or after the 
                    <code>vkQueueSubmit()</code>
                    &nbsp;(if we know the sync is done for cmd).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                If using Descriptor Indexing
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptors can be updated after binding in command buffers.
				</p>
				<ul>
					<li>
						<p>
                            Command buffer execution will use most recent updates.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250807094326.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSet.html" 
				class="external-link" 
				target="_blank" >
                <code>VkWriteDescriptorSet</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>dstSet</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the destination descriptor set to update.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dstBinding</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the descriptor binding within that set.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dstArrayElement</code>
				</p>
				<ul>
					<li>
						<p>
                            Remember that descriptors can be arrays, so we also need to specify the first index in the array that we want to update.
						</p>
					</li>
					<li>
						<p>
                            If not using an array, the index is simply 
                            <code>0</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            Is the starting element in that array.
						</p>
					</li>
					<li>
						<p>
                            If the descriptor binding identified by 
                            <code>dstSet</code>
                            &nbsp;and 
                            <code>dstBinding</code>
                            &nbsp;has a descriptor type of 
                            <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            &nbsp;then 
                            <code>dstArrayElement</code>
                            &nbsp;specifies the starting byte offset within the binding.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorCount</code>
				</p>
				<ul>
					<li>
						<p>
                            It's a descriptor count, 
							<strong>
                                not
							</strong>
                            &nbsp;a descriptor SET count!!
						</p>
					</li>
					<li>
						<p>
                            Is the number of descriptors to update.
						</p>
					</li>
					<li>
						<p>
                            If the descriptor binding identified by 
                            <code>dstSet</code>
                            &nbsp;and 
                            <code>dstBinding</code>
                            &nbsp;has a descriptor type of 
                            <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>
                            , then 
                            <code>descriptorCount</code>
                            &nbsp;specifies the number of bytes to update.
						</p>
					</li>
					<li>
						<p>
                            Otherwise, 
                            <code>descriptorCount</code>
                            &nbsp;is one of
						</p>
						<ul>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pImageInfo</code>
								</p>
							</li>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pBufferInfo</code>
								</p>
							</li>
							<li>
								<p>
                                    the number of elements in 
                                    <code>pTexelBufferView</code>
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>dataSize</code>
                                    &nbsp;member of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetInlineUniformBlock.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetInlineUniformBlock
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>accelerationStructureCount</code>
                                    &nbsp;of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetAccelerationStructureKHR
									</a>
                                    &nbsp;or 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureNV.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetAccelerationStructureNV
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
							<li>
								<p>
                                    a value matching the 
                                    <code>descriptorCount</code>
                                    &nbsp;of a 
									<a
										href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetTensorARM.html" 
										class="external-link" 
										target="_blank" >
                                        VkWriteDescriptorSetTensorARM
									</a>
                                    &nbsp;structure in the 
                                    <code>pNext</code>
                                    &nbsp;chain
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorType</code>
				</p>
				<ul>
					<li>
						<p>
                            We need to specify the type of descriptor again
						</p>
					</li>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorType.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorType
							</a>
                            &nbsp;specifying the type of each descriptor in 
                            <code>pImageInfo</code>
                            , 
                            <code>pBufferInfo</code>
                            , or 
                            <code>pTexelBufferView</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            It 
							<strong>
                                must
							</strong>
                            &nbsp;be the same type as the 
                            <code>descriptorType</code>
                            &nbsp;specified in 
                            <code>VkDescriptorSetLayoutBinding</code>
                            &nbsp;for 
                            <code>dstSet</code>
                            &nbsp;at 
                            <code>dstBinding</code>
                            , 
							<strong>
                                except
							</strong>
                            &nbsp;if 
                            <code>VkDescriptorSetLayoutBinding</code>
                            &nbsp;for 
                            <code>dstSet</code>
                            &nbsp;at 
                            <code>dstBinding</code>
                            &nbsp;is equal to 
                            <code>VK_DESCRIPTOR_TYPE_MUTABLE_EXT</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The type of the descriptor also controls which array the descriptors are taken from.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pBufferInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorBufferInfo
							</a>
                            &nbsp;structures or is ignored, as described below.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDescriptorBufferInfo</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    Structure specifying descriptor buffer information
								</p>
							</li>
							<li>
								<p>
                                    Specifies the buffer and the region within it that contains the data for the descriptor.
								</p>
							</li>
							<li>
								<p>
                                    <code>buffer</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the buffer resource or 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NULL_HANDLE.html" 
												class="external-link" 
												target="_blank" >
                                                VK_NULL_HANDLE
											</a>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>offset</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the offset in bytes from the start of 
                                            <code>buffer</code>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.
										</p>
									</li>
									<li>
										<p>
                                            For 
                                            <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                            &nbsp;and 
                                            <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                            &nbsp;descriptor types:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>offset</code>
                                                    &nbsp;is the base offset from which the dynamic offset is applied.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>range</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the size in bytes that is used for this descriptor update, or 
                                            <code>VK_WHOLE_SIZE</code>
                                            &nbsp;to use the range from 
                                            <code>offset</code>
                                            &nbsp;to the end of the buffer.
										</p>
										<ul>
											<li>
												<p>
                                                    When 
                                                    <code>range</code>
                                                    &nbsp;is 
                                                    <code>VK_WHOLE_SIZE</code>
                                                    &nbsp;the effective range is calculated at 
													<a
														href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html" 
														class="external-link" 
														target="_blank" >
                                                        vkUpdateDescriptorSets
													</a>
                                                    &nbsp;by taking the size of 
                                                    <code>buffer</code>
                                                    &nbsp;minus the 
                                                    <code>offset</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            For 
                                            <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>
                                            &nbsp;and 
                                            <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>
                                            &nbsp;descriptor types:
										</p>
										<ul>
											<li>
												<p>
                                                    <code>range</code>
                                                    &nbsp;is the static size used for all dynamic offsets.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pImageInfo</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorImageInfo.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorImageInfo
							</a>
                            &nbsp;structures or is ignored, as described below.
						</p>
					</li>
					<li>
						<p>
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorImageInfo.html" 
								class="external-link" 
								target="_blank" >
                                <code>VkDescriptorImageInfo</code>
							</a>
                            .
						</p>
						<ul>
							<li>
								<p>
                                    <code>imageLayout</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is the layout that the image subresources accessible from 
                                            <code>imageView</code>
                                            &nbsp;will be in at the time this descriptor is accessed.
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
                                            , 
                                            <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
                                            , 
                                            <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            , and 
                                            <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>imageView</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is an image view handle or 
											<a
												href="https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NULL_HANDLE.html" 
												class="external-link" 
												target="_blank" >
                                                VK_NULL_HANDLE
											</a>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>
                                            , 
                                            <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>
                                            , 
                                            <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            , and 
                                            <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <code>sampler</code>
								</p>
								<ul>
									<li>
										<p>
                                            Is a sampler handle.
										</p>
									</li>
									<li>
										<p>
                                            Is used in descriptor updates for types 
                                            <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>
                                            &nbsp;and 
                                            <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>
                                            &nbsp;if the binding being updated does not use immutable samplers.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pTexelBufferView</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferView.html" 
								class="external-link" 
								target="_blank" >
                                VkBufferView
							</a>
                            &nbsp;handles as described in the 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#resources-buffer-views" 
								class="external-link" 
								target="_blank" >
                                Buffer Views
							</a>
                            &nbsp;section or is ignored, as described below.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkUpdateDescriptorSets()</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <code>descriptorWriteCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorWrites</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorWrites</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkWriteDescriptorSet
							</a>
                            &nbsp;structures describing the descriptor sets to write to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorCopyCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorCopies</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorCopies</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkCopyDescriptorSet
							</a>
                            &nbsp;structures describing the descriptor sets to copy between.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="binding" >
    Binding
</h5>
<ul>
	<li>
		<p>
            A Descriptor state is tracked only inside a command buffer; they are always bound at command buffer level; their state is local to command buffers.
		</p>
		<ul>
			<li>
				<p>
                    They are not bound at queue level or global level, only to command buffers.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250806153655.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Which set index to choose
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    According to GPU vendors, each descriptor set slot has a cost, so the fewer we have, the better.
				</p>
			</li>
			<li>
				<p>
                    &quot;Organize shader inputs into &quot;sets&quot; by update frequency.&quot;
				</p>
			</li>
			<li>
				<p>
                    Rarely changes -&gt; low index.
				</p>
			</li>
			<li>
				<p>
                    Changes frequently -&gt; high index.
				</p>
			</li>
			<li>
				<p>
                    Usually Descriptor Set 0 is used to always bind some global scene data, which will contain some uniform buffers and some special textures, and Descriptor Set 1 will be used for per-object data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets.html" 
				class="external-link" 
				target="_blank" >
                <code>vkCmdBindDescriptorSets</code>
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It needs to be done before the 
                    <code>vkCmdDrawIndexed()</code>
                    &nbsp;calls, for example.
				</p>
			</li>
			<li>
				<p>
                    <code>commandBuffer</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the command buffer that the descriptor sets will be bound to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pipelineBindPoint</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBindPoint.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineBindPoint
							</a>
                            &nbsp;indicating the type of the pipeline that will use the descriptors. There is a separate set of bind points for each pipeline type, so binding one does not disturb the others.
						</p>
					</li>
					<li>
						<p>
                            Unlike vertex and index buffers, descriptor sets are not unique to graphics pipelines, therefore, we need to specify if we want to bind descriptor sets to the graphics or compute pipeline.
						</p>
					</li>
					<li>
						<p>
                            Indicates the type of the pipeline that will use the descriptor.
						</p>
					</li>
					<li>
						<p>
                            There is a separate set of bind points for each pipeline type, so binding one does not disturb the others.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250806154129.png" width="425" >
                            .
						</p>
						<ul>
							<li>
								<p>
                                    A raytracing command takes the currently bound descriptors from the raytracing bind point.
								</p>
							</li>
							<li>
								<p>
                                    A draw command takes the currently bound descriptors from the graphics bind point.
								</p>
							</li>
							<li>
								<p>
                                    The two don't interfere with each other.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>layout</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayout.html" 
								class="external-link" 
								target="_blank" >
                                VkPipelineLayout
							</a>
                            &nbsp;object used to program the bindings.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>firstSet</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the 
							<em>
                                set number
							</em>
                            &nbsp;of the 
							<em>
                                first descriptor set
							</em>
                            &nbsp;to be bound.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>descriptorSetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of elements in the 
                            <code>pDescriptorSets</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDescriptorSets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of handles to 
							<a
								href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html" 
								class="external-link" 
								target="_blank" >
                                VkDescriptorSet
							</a>
                            &nbsp;objects describing the descriptor sets to bind to.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>dynamicOffsetCount</code>
				</p>
				<ul>
					<li>
						<p>
                            Is the number of dynamic offsets in the 
                            <code>pDynamicOffsets</code>
                            &nbsp;array.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>pDynamicOffsets</code>
				</p>
				<ul>
					<li>
						<p>
                            Is a pointer to an array of 
                            <code>uint32_t</code>
                            &nbsp;values specifying dynamic offsets.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="performance-improvements" >
    Performance Improvements
</h4>
<ul>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/descriptor_management/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                The issue: Many descriptor sets changing on the fly
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    When rendering dynamic objects the application will need to push some amount of per-object data to the GPU, such as the MVP matrix. This data may not fit into the push constant limit for the device, so it becomes necessary to send it to the GPU by putting it into a 
                    <code>VkBuffer</code>
                    &nbsp;and binding a descriptor set that points to it.
				</p>
			</li>
			<li>
				<p>
                    Materials also need their own descriptor sets, which point to the textures they use. We can either bind per-material and per-object descriptor sets separately or collate them into a single set. Either way, complex applications will have a large amount of descriptor sets that may need to change on the fly, for example due to textures being streamed in or out.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Not-good Solution: One or more pools per-frame, resetting the pool
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    The simplest approach to circumvent the issue is to have one or more 
                    <code>VkDescriptorPool</code>
                    s per frame, reset them at the beginning of the frame and allocate the required descriptor sets from it. This approach will consist of a 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkResetDescriptorPool.html" 
						class="external-link" 
						target="_blank" >
                        vkResetDescriptorPool()
					</a>
                    &nbsp;call at the beginning, followed by a series of 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkAllocateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkAllocateDescriptorSets()
					</a>
                    &nbsp;and 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkUpdateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkUpdateDescriptorSets()
					</a>
                    &nbsp;to fill them with data.
				</p>
			</li>
			<li>
				<p>
                    This is very useful for things like per-frame descriptors. That way we can have descriptors that are used just for one frame, allocated dynamically, and then before we start the frame we completely delete all of them in one go.
				</p>
			</li>
			<li>
				<p>
                    This is confirmed to be a fast path by GPU vendors, and recommended to use when you need to handle per-frame descriptor sets.
				</p>
			</li>
			<li>
				<p>
                    The issue is that these calls can add a significant overhead to the CPU frame time, especially on mobile. In the worst cases, for example calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkUpdateDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkUpdateDescriptorSets()
					</a>
                    &nbsp;for each draw call, the time it takes to update descriptors can be longer than the time of the draws themselves.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution: Caching descriptor sets
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A major way to reduce descriptor set updates is to re-use them as much as possible. Instead of calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkResetDescriptorPool.html" 
						class="external-link" 
						target="_blank" >
                        vkResetDescriptorPool()
					</a>
                    &nbsp;every frame, the app will keep the 
                    <code>VkDescriptorSet</code>
                    &nbsp;handles stored with some caching mechanism to access them.
				</p>
			</li>
			<li>
				<p>
                    The cache could be a hashmap with the contents of the descriptor set (images, buffers) as key. This approach is used in our framework by default. It is possible to remove another level of indirection by storing descriptor set handles directly in the materials and/or meshes.
				</p>
			</li>
			<li>
				<p>
                    Caching descriptor sets has a dramatic effect on frame time for our CPU-heavy scene.
				</p>
			</li>
			<li>
				<p>
                    In this game on a 2019 mobile phone it went from 44ms (23fps) to 27ms (37fps). This is a 38% decrease in frame time.
				</p>
			</li>
			<li>
				<p>
                    This system is reasonably easy to implement for a static scene, but it becomes harder when you need to delete descriptor sets. Complex engines may implement techniques to figure out which descriptor sets have not been accessed for a certain number of frames, so they can be removed from the map.
				</p>
			</li>
			<li>
				<p>
                    This may correspond to calling 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkFreeDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkFreeDescriptorSets()
					</a>
                    , but this solution poses another issue: in order to free individual descriptor sets the pool has to be created with the 
                    <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code>
                    &nbsp;flag. Mobile implementations may use a simpler allocator if that flag is not set, relying on the fact that pool memory will only be recycled in block.
				</p>
			</li>
			<li>
				<p>
                    It is possible to avoid using that flag by updating descriptor sets instead of deleting them. The application can keep track of recycled descriptor sets and re-use one of them when a new one is requested.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Solution: One buffer per-frame
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We will now explore an alternative approach, that is complementary to descriptor caching in some way. Especially for applications in which descriptor caching is not quite feasible, buffer management is another lever for optimizing performance.
				</p>
			</li>
			<li>
				<p>
                    As discussed at the beginning, each rendered object will typically need some uniform data along with it, that needs to be pushed to the GPU somehow. A straightforward approach is to store a 
                    <code>VkBuffer</code>
                    &nbsp;per object and update that data for each frame.
				</p>
			</li>
			<li>
				<p>
                    This already poses an interesting question: is one buffer enough? The problem is that this data will change dynamically and will be in use by the GPU while the frame is in flight.
				</p>
			</li>
			<li>
				<p>
                    Since we do not want to flush the GPU pipeline between each frame, we will need to keep several copies of each buffer, one for each frame in flight.
				</p>
			</li>
			<li>
				<p>
                    Another similar option is to use just one buffer per object, but with a size equal to 
                    <code>num_frames * buffer_size</code>
                    , then offset it dynamically based on the frame index.
				</p>
				<ul>
					<li>
						<p>
                            For each frame, one buffer per object is created and filled with data. This means that we will have many descriptor sets to create, since every object will need one that points to its 
                            <code>VkBuffer</code>
                            . Furthermore, we will have to update many buffers separately, meaning we cannot control their memory layout and we might lose some optimization opportunities with caching.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    We can address both problems by reverting the approach: instead of having a 
                    <code>VkBuffer</code>
                    &nbsp;per object containing per-frame data, we will have a 
                    <code>VkBuffer</code>
                    &nbsp;per frame containing per-object data. The buffer will be cleared at the beginning of the frame, then each object will record its data and will receive a dynamic offset to be used at 
					<a
						href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCmdBindDescriptorSets.html" 
						class="external-link" 
						target="_blank" >
                        vkCmdBindDescriptorSets()
					</a>
                    &nbsp;time.
				</p>
			</li>
			<li>
				<p>
                    With this approach we will need fewer descriptor sets, as more objects can share the same one: they will all reference the same 
                    <code>VkBuffer</code>
                    , but at different dynamic offsets. Furthermore, we can control the memory layout within the buffer.
				</p>
			</li>
			<li>
				<p>
                    Using a single large 
                    <code>VkBuffer</code>
                    &nbsp;in this case shows a performance improvement similar to descriptor set caching.
				</p>
			</li>
			<li>
				<p>
                    For this relatively simple scene stacking the two approaches does not provide a further performance boost, but for a more complex case they do stack nicely:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor caching is necessary when the number of descriptor sets is not just due to 
                            <code>VkBuffer</code>
                            s with uniform data, for example if the scene uses a large amount of materials/textures.
						</p>
					</li>
					<li>
						<p>
                            Buffer management will help reduce the overall number of descriptor sets, thus cache pressure will be reduced and the cache itself will be smaller.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    [2025/09/08]
				</p>
				<ul>
					<li>
						<p>
                            I personally liked this technique much more than descriptor caching.
						</p>
					</li>
					<li>
						<p>
                            It sounds more concrete than fiddling with descriptor sets.
						</p>
					</li>
					<li>
						<p>
                            Reminds me of Buffer Device Address.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Update already allocated but no longer referenced descriptor sets, instead of resetting descriptor pools and reallocating new descriptor sets.
				</p>
			</li>
			<li>
				<p>
                    Prefer reusing already allocated descriptor sets, and not updating them with the same information every time.
				</p>
			</li>
			<li>
				<p>
                    Consider caching your descriptor sets when feasible.
				</p>
			</li>
			<li>
				<p>
                    Consider using a single (or few) 
                    <code>VkBuffer</code>
                    &nbsp;per frame with dynamic offsets.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Don’t
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Allocate descriptor sets from descriptor pools on performance critical code paths.
				</p>
			</li>
			<li>
				<p>
                    Allocate, free or update descriptor sets every frame, unless it is necessary.
				</p>
			</li>
			<li>
				<p>
                    Set 
                    <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code>
                    &nbsp;if you do not need to free individual descriptor sets.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Increased CPU load for draw calls.
				</p>
			</li>
			<li>
				<p>
                    Setting 
                    <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code>
                    &nbsp;may prevent the implementation from using a simpler (and faster) allocator.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h4
	id="strategies-for-selecting-resources" >
    Strategies for selecting Resources
</h4>
<h5
	id="bindless-and-descriptor-indexing" >
    Bindless and Descriptor Indexing
</h5>
<ul>
	<li>
		<p>
            Descriptor indexing is an extension which adds a 
			<strong>
                lot
			</strong>
            &nbsp;of flexibility to how resources are accessed.
		</p>
	</li>
	<li>
		<p>
            The core functionality of this extension is that we can treat descriptor memory as one massive array, and we can freely access any resource we want at any time, by indexing.
		</p>
	</li>
	<li>
		<p>
            The main insight is that if an array is large enough, an index into that array is indistinguishable from a pointer.
		</p>
	</li>
	<li>
		<p>
            Descriptor indexing is also known by the term &quot;bindless&quot;, which refers to the fact that binding individual descriptor sets and descriptors is no longer the primary way we keep shader pipelines fed. Instead, we can bind a huge descriptor set once and just index into a large number of descriptors.
		</p>
	</li>
	<li>
		<p>
            &quot;Bindless algorithms&quot; are generally built around this flexibility where we either index freely into a lot of descriptors at once, or update descriptors where we please. In this model, &quot;binding&quot; descriptors is not a concern anymore.
		</p>
	</li>
	<li>
		<p>
            At most, we need to write/copy descriptors to where we need them and we can now consider descriptors more like memory blobs rather than highly structured API objects.
		</p>
	</li>
	<li>
		<p>
            The introduction of descriptor indexing revealed that the descriptor model is all just smoke and mirrors.
		</p>
		<ul>
			<li>
				<p>
                    A descriptor is just a blob of binary data that the GPU can interpret in some meaningful way. The API calls to manage descriptors really just boils down to “copy magic bits here.”
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/descriptor_indexing/README.html#_the_sample" 
				class="external-link" 
				target="_blank" >
                Descriptor Indexing Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor Indexing was created in 2018, so all hardware 2018+ should support it.
				</p>
			</li>
			<li>
				<p>
                    Core in Vulkan 1.2+
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250814165333.png" width="475" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Advantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250810212139.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250810212315.png" width="300" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Disadvantages
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250810212531.png" width="300" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Features
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Update-after-bind
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            In Vulkan, you generally have to create a 
                            <code>VkDescriptorSet</code>
                            &nbsp;and update it with all descriptors before you call 
                            <code>vkCmdBindDescriptorSets</code>
                            . After a set is bound, the descriptor set cannot be updated again until the GPU is done using it. This gives drivers a lot of flexibility in how they access the descriptors. They are free to copy the descriptors and pack them somewhere else, promote them to hardware registers, the list goes on.
						</p>
					</li>
					<li>
						<p>
                            Update-After-Bind gives flexibility to applications instead. Descriptors can be updated at any time as long as they are not actually accessed by the GPU. Descriptors can also be updated while the descriptor set is bound to a command buffer, which enables a &quot;streaming&quot; use case.
						</p>
						<ul>
							<li>
								<p>
                                    This means the application doesn’t have to unbind or re-record command buffers just to change descriptors—reducing CPU overhead in some streaming-resource scenarios.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Concurrent Updates
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Another &quot;hidden&quot; feature of update-after-bind is that it is possible to update the descriptor set from multiple threads. This is very useful for true &quot;bindless&quot; since unrelated tasks might want to update descriptors in different parts of the streamed/bindless descriptor set.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                After and after
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <img src="assets/image_20250816104712.png" width="275" >
                                    .
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Non-uniform indexing, enabling advanced algorithms
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            While update-after-bind adds flexibility to descriptor management, non-uniform indexing adds great flexibility for shaders.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Different levels of indexing resources
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <img src="assets/image_20250814083757.png" width="400" >
                                    .
								</p>
							</li>
							<li>
								<p>
									<a
										href="https://chunkstories.xyz/blog/a-note-on-descriptor-indexing/" 
										class="external-link" 
										target="_blank" >
                                        Descriptor Indexing, explanation of &quot;dynamic non-uniform&quot;
									</a>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Good read.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Constant Indexing
									</em>
                                    :
								</p>
<pre><code class="language-glsl" data-lang="glsl"> layout(set = 0, binding = 0) uniform sampler2D Tex[4];
 
 texture(Tex[0], ...);
 texture(Tex[2], ...);
 
 // We can trivially flatten a constant-indexed array into individual resources,
 // so, constant indexing requires no fancy hardware indexing support.
 layout(set = 0, binding = 0) uniform sampler2D Tex0;
 layout(set = 0, binding = 1) uniform sampler2D Tex1;
 layout(set = 0, binding = 2) uniform sampler2D Tex2;
 layout(set = 0, binding = 3) uniform sampler2D Tex3;
</code></pre>
							</li>
							<li>
								<p>
									<em>
                                        Dynamic Indexing
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            The dynamic indexing features allow us to use a non-constant expression to index an array.
										</p>
										<ul>
											<li>
												<p>
                                                    This has been supported since Vulkan 1.0.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            The restriction is that the index must be 
											<em>
                                                dynamically uniform
											</em>
                                            .
										</p>
									</li>
								</ul>
<pre><code class="language-glsl" data-lang="glsl"> layout(set = 0, binding = 0) uniform sampler2D Tex[4];
 
 texture(Tex[dynamically_uniform_expression], ...);
</code></pre>
							</li>
							<li>
								<p>
									<em>
                                        Non-uniform Indexing
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            It completely removes all restrictions on how we index into arrays, but we must notify our intent to the compiler.
										</p>
									</li>
									<li>
										<p>
                                            Normally, drivers and hardware can assume that the dynamically uniform guarantee holds, and optimize for that case. If we use the 
                                            <code>nonuniformEXT</code>
                                            &nbsp;decoration in 
                                            <code>GL_EXT_nonuniform_qualifier</code>
                                            &nbsp;we can let the compiler know that the guarantee does not necessarily hold, and the compiler will deal with it in the most efficient way possible for the target hardware.
										</p>
									</li>
									<li>
										<p>
                                            The rationale for having to annotate like this is that driver compiler backends would be forced to be more conservative than necessary if applications were not required to use 
                                            <code>nonuniformEXT</code>
                                            .
										</p>
									</li>
								</ul>
<pre><code class="language-c" data-lang="c"> // Unsized arrays, nice!
 layout(set = 0, binding = 0) uniform sampler2D Tex[];
 texture(Tex[nonuniformEXT(arbitrary_expression)], ...);
</code></pre>
<pre><code class="language-glsl" data-lang="glsl"> #version 450
 #extension GL_EXT_nonuniform_qualifier : require
 layout(local_size_x = 64) in;
 
 layout(set = 0, binding = 0) uniform sampler2D Combined[];
 layout(set = 1, binding = 0) uniform texture2D Tex[];
 layout(set = 2, binding = 0) uniform sampler Samp[];
 layout(set = 3, binding = 0) uniform U { vec4 v; } UBO[];
 layout(set = 4, binding = 0) buffer S { vec4 v; } SSBO[];
 layout(set = 5, binding = 0, r32ui) uniform uimage2D Img[];
 
 void main()
 {
&nbsp;&nbsp;&nbsp;&nbsp; uint index = gl_GlobalInvocationID.x;
&nbsp;&nbsp;&nbsp;&nbsp; vec2 uv = vec2(gl_GlobalInvocationID.yz) / 1024.0;
 
&nbsp;&nbsp;&nbsp;&nbsp; vec4 a = textureLod(Combined[nonuniformEXT(index)], uv, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp; vec4 b = textureLod(nonuniformEXT(sampler2D(Tex[index], Samp[index])), uv, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp; vec4 c = UBO[nonuniformEXT(index)].v;
&nbsp;&nbsp;&nbsp;&nbsp; vec4 d = SSBO[nonuniformEXT(index)].v;
 
&nbsp;&nbsp;&nbsp;&nbsp; imageAtomicAdd(Img[nonuniformEXT(index)], ivec2(0), floatBitsToUint(a.x + b.y + c.z + d.w));
 }
</code></pre>
								<ul>
									<li>
										<p>
											<em>
                                                Non-uniform vs Texture Atlas vs Texture Array
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    Accessing arbitrary textures in a draw call is not a new problem, and graphics programmers have found ways over the years to workaround restrictions in older APIs. Rather than having multiple textures, it is technically possible to pack multiple textures into one texture resource, and sample from the correct part of the texture. This kind of technique is typically referred to as &quot;texture atlas&quot;. Texture arrays (e.g. sampler2DArray) is another feature which can be used for similar purposes.
												</p>
											</li>
											<li>
												<p>
                                                    Problems with atlas:
												</p>
												<ul>
													<li>
														<p>
                                                            Mip-mapping is hard to implement, and must likely be done manually with derivatives and math.
														</p>
													</li>
													<li>
														<p>
                                                            Anisotropic filtering is basically impossible.
														</p>
													</li>
													<li>
														<p>
                                                            Any other sampler addressing than 
                                                            <code>CLAMP_TO_EDGE</code>
                                                            &nbsp;is very awkward to implement.
														</p>
													</li>
													<li>
														<p>
                                                            Cannot use different texture formats.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    Problems with texture array:
												</p>
												<ul>
													<li>
														<p>
                                                            All resolutions must match.
														</p>
													</li>
													<li>
														<p>
                                                            Number of array layers is limited (just 256 in min-spec).
														</p>
													</li>
													<li>
														<p>
                                                            Cannot use different texture formats.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    Non-uniform indexing solves these issues since we can freely use multiple sampled image descriptors instead. Atlases and texture arrays still have their place. There are many use cases where these restrictions do not cause problems.
												</p>
											</li>
											<li>
												<p>
                                                    Non-uniform indexing is not just limited to textures (although that is the most relevant use case). Any descriptor type can be used as long as the device supports it.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<em>
                                                When to use Non-uniform Indexing
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
													<em>
                                                        The invocation group
													</em>
                                                    :
												</p>
												<ul>
													<li>
														<p>
                                                            The invocation group is a set of threads (invocations) which work together to perform a task.
														</p>
													</li>
													<li>
														<p>
                                                            In graphics pipelines, the invocation group is all threads which are spawned as part of a single draw command. This includes multiple instances, and for multi-draw-indirect it is limited to a single 
                                                            <code>gl_DrawID</code>
                                                            .
														</p>
													</li>
													<li>
														<p>
                                                            In compute pipelines, the invocation group is a single workgroup, so it’s very easy to know when it is safe to avoid nonuniformEXT.
														</p>
													</li>
													<li>
														<p>
                                                            An expression is considered 
															<strong>
                                                                dynamically uniform
															</strong>
                                                            &nbsp;if all invocations in an invocation group have the same value.
														</p>
														<ul>
															<li>
																<p>
                                                                    In other words, 
																	<strong>
                                                                        dynamically uniform
																	</strong>
                                                                    &nbsp;means that the index is the same across all threads spawned by a draw command.
																</p>
															</li>
														</ul>
													</li>
												</ul>
											</li>
											<li>
												<p>
													<em>
                                                        Interaction with Subgroups
													</em>
                                                    :
												</p>
												<ul>
													<li>
														<p>
                                                            It is very easy to think that dynamically uniform just means &quot;as long as the index is uniform in the subgroup, it’s fine!&quot;. This is certainly true for most (desktop) architectures, but not all.
														</p>
													</li>
													<li>
														<p>
                                                            It is technically possible that a value can be subgroup uniform, but still not dynamically uniform. Consider a case where we have a workgroup size of 128 threads, with a subgroup size of 32. Even if each subgroup does 
                                                            <code>subgroupBroadcastFirst()</code>
                                                            &nbsp;on the index, each subgroup might have different values, and thus, we still technically need 
                                                            <code>nonuniformEXT</code>
                                                            &nbsp;here. If you know that you have only one subgroup per workgroup however, 
                                                            <code>subgroupBroadcastFirst()</code>
                                                            &nbsp;is good enough.
														</p>
													</li>
													<li>
														<p>
                                                            The safe thing to do is to just add 
                                                            <code>nonuniformEXT</code>
                                                            &nbsp;if you cannot prove the dynamically uniform property. If the compiler knows that it only really cares about subgroup uniformity, it could trivially optimize away 
                                                            <code>nonuniformEXT(subgroupBroadcastFirst())</code>
                                                            &nbsp;anyways.
														</p>
													</li>
													<li>
														<p>
                                                            The common reason to use subgroups in the first place, is that it was an old workaround for lack of true non-uniform indexing, especially for desktop GPUs. A common pattern would be something like:
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How to use it
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Enabling 
                    <code>UPDATE_AFTER_BIND_BIT</code>
                    &nbsp;features for a descriptor binding:
				</p>
				<ul>
					<li>
						<p>
                            In 
                            <code>VkDescriptorSetLayoutCreateInfo</code>
                            &nbsp;we must pass down binding flags in a separate struct with 
                            <code>pNext</code>
                            .
						</p>
					</li>
				</ul>
<pre><code class="language-c" data-lang="c"> // VkDescriptorSetLayoutBindingFlagsCreateInfoEXT + VkDescriptorBindingFlagsEXT
 const VkDescriptorBindingFlagsEXT flags =
&nbsp;&nbsp;&nbsp;&nbsp; VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT |
&nbsp;&nbsp;&nbsp;&nbsp; VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT |
&nbsp;&nbsp;&nbsp;&nbsp; VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT |
&nbsp;&nbsp;&nbsp;&nbsp; VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT;
 VkDescriptorSetLayoutBindingFlagsCreateInfoEXT binding_flags{};
 binding_flags.sType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT;
 binding_flags.bindingCount&nbsp;&nbsp; = 1;
 binding_flags.pBindingFlags&nbsp;&nbsp;= &flags;

 // VkDescriptorSetLayoutCreateInfo
 VkDescriptorSetLayoutCreateInfo set_layout_create_info{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO};
 set_layout_create_info.flags = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
 set_layout_create_info.pNext = &binding_flags;

 // vkCreateDescriptorSetLayout
 VK_CHECK(vkCreateDescriptorSetLayout(get_device().get_handle(), &set_layout_create_info, nullptr, &descriptors.set_layout));
</code></pre>
				<ul>
					<li>
						<p>
                            The 
                            <code>VkDescriptorPool</code>
                            &nbsp;must also be created with 
                            <code>UPDATE_AFTER_BIND_BIT</code>
                            . Note that there is global limit to how many UPDATE_AFTER_BIND_BIT descriptors can be allocated at any point. The min-spec here is 500k, which should be good enough.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="descriptor-buffers" >
    Descriptor Buffers
</h5>
<ul>
	<li>
		<p>
			<a
				href="https://www.khronos.org/blog/vk-ext-descriptor-buffer" 
				class="external-link" 
				target="_blank" >
                VK_EXT_descriptor_buffer
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/features/latest/features/proposals/VK_EXT_descriptor_buffer.html?utm_source=chatgpt.com" 
				class="external-link" 
				target="_blank" >
                VK_EXT_descriptor_buffer
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Released on [2022/11/21].
		</p>
	</li>
	<li>
		<p>
			<em>
                TLDR
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor sets are now backed by 
                    <code>VkBuffer</code>
                    &nbsp;objects where you memcpy in descriptors. Delete 
                    <code>VkDescriptorPool</code>
                    &nbsp;and 
                    <code>VkDescriptorSet</code>
                    &nbsp;from the API, and have fun!
				</p>
			</li>
			<li>
				<p>
                    Performance is either equal or better.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Coming from Descriptor Indexing, we use plain uints instead of actual descriptor sets, there are some design questions that come up.
		</p>
	</li>
	<li>
		<p>
            Do we assign one uint per descriptor, or do we try to group them together such that we only need to push one base offset?
		</p>
	</li>
	<li>
		<p>
            If we go with the latter, we might end up having to copy descriptors around. If we go with one uint per descriptor, we just added extra indirection on the GPU. GPU throughput might suffer with the added latency.
		</p>
	</li>
	<li>
		<p>
            On the other hand, having to group descriptors linearly one after the other can easily lead to copy hell. Copying descriptors is still an abstracted operation that requires API calls to perform, and we cannot perform it on the GPU. The overhead of all these calls in the driver can be quite significant, especially in API layering. I’ve seen up to 10 million calls to “copy descriptor” per second which adds up.
		</p>
	</li>
	<li>
		<p>
            Managing descriptors really starts looking more and more like just any other memory management problem. Let’s try translating existing API concepts into what they really are under the hood.
		</p>
	</li>
	<li>
		<p>
            <code>vkCreateDescriptorPool</code>
            <br>
            <code>vkAllocateMemory</code>
            . Memory type unknown, but likely 
            <code>HOST_VISIBLE</code>
            &nbsp;and 
            <code>DEVICE_LOCAL</code>
            . Size of pool computed from pool entries.
		</p>
	</li>
	<li>
		<p>
            <code>vkAllocateDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Linear or arena allocation from pool. Size and alignment computed from 
                    <code>VkDescriptorSetLayout</code>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkUpdateDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Writes raw descriptor data by copying payload from 
                    <code>VkImageView</code>
                    &nbsp;/ 
                    <code>VkSampler</code>
                    &nbsp;/ 
                    <code>VkBufferView</code>
                    . Write offset is deduced from 
                    <code>VkDescriptorSetLayout</code>
                    &nbsp;and binding. The 
                    <code>VkDescriptorSet</code>
                    &nbsp;contains a pointer to 
                    <code>HOST_VISIBLE</code>
                    &nbsp;mapped CPU memory. Copies are similar.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>vkCmdBindDescriptorSets</code>
		</p>
		<ul>
			<li>
				<p>
                    Binds the GPU VA of the 
                    <code>VkDescriptorSet</code>
                    &nbsp;somehow.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The descriptor buffer API effectively removes 
            <code>VkDescriptorPool</code>
            &nbsp;and 
            <code>VkDescriptorSet</code>
            . The APIs now expose lower level detail.
		</p>
	</li>
	<li>
		<p>
            For example, there’s now a bunch of properties to query:
		</p>
<pre><code class="language-c" data-lang="c"> typedef struct VkPhysicalDeviceDescriptorBufferPropertiesEXT {
&nbsp;&nbsp;&nbsp;&nbsp; …
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; samplerDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; combinedImageSamplerDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sampledImageDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageImageDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniformTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustUniformTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustStorageTexelBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniformBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustUniformBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storageBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; robustStorageBufferDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputAttachmentDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accelerationStructureDescriptorSize;
&nbsp;&nbsp;&nbsp;&nbsp; …
 } VkPhysicalDeviceDescriptorBufferPropertiesEXT;
</code></pre>
	</li>
</ul>
<h5
	id="bindful-slot-based-frequency-based" >
    Bindful (Slot-based / Frequency-based)
</h5>
<ul>
	<li>
		<p>
            mna (midmidmid):
		</p>
		<ul>
			<li>
				<p>
                    The reason you split up resources into multiple sets is actually to 
					<em>
                        reduce
					</em>
                    &nbsp;the cost of 
                    <code>vkCmdBindDescriptorSets</code>
                    . The idea being that if you've got one set that holds scene-wide data and a different set that holds object-specific data, you only bind the scene stuff 
					<em>
                        once
					</em>
                    &nbsp;and then just leave it bound. Then the per-object updates go faster because you're pushing much smaller descriptor sets into whatever special silicon descriptor sets map to on your particular GPU. Note: there are rules about how you have to arrange your sets (so like the scene-wide one has to be at a lower index than the per-object one), and all of the pipelines you use must have 
					<em>
                        compatible
					</em>
                    &nbsp;layouts for the sets you aren't rebinding every time you switch to a different pipeline. Someone can correct me if I'm wrong, but if you switch to a pipeline that's got an incompatible layout for some descriptor set at index 
					<em>
                        n
					</em>
                    &nbsp;then 
					<em>
                        all
					</em>
                    &nbsp;descriptor sets at indices 
					<em>
                        &gt;= n
					</em>
                    &nbsp;need to be rebound.
				</p>
			</li>
			<li>
				<p>
                    I think the only reason I'd change any of my stuff to bindless is if I hit however many hundreds of thousands of calls to 
                    <code>vkCmdBindDescriptorSets</code>
                    &nbsp;it takes for descriptors to be a per-frame bottleneck.
				</p>
			</li>
			<li>
				<p>
                    But I find descriptors pretty intuitive and easy to work with.
				</p>
			</li>
			<li>
				<p>
                    I 
					<em>
                        didn't
					</em>
                    &nbsp;find them easy to work with when I 
					<em>
                        first
					</em>
                    &nbsp;came to VK (from GL/D3D11-world), but now that I've got some scaffolding set up to manage them, they're easy sauce.
				</p>
			</li>
			<li>
				<p>
                    (They actually map pretty well to having worked with 
					<em>
                        old
					</em>
                    &nbsp;console GPUs where you manage the command queue directly and have to think about resource bindings in terms of physical registers on the GPU. It was helpful to have that background.)
				</p>
			</li>
			<li>
				<p>
                    If you're working with descriptor sets, then you have lots of little objects whose lifetimes you need to track and manage. Getting them grouped into the appropriate set of 
					<em>
                        pools
					</em>
                    &nbsp;cuts that number down to something that's not hard to manage. So, for me, I've got a dynamically allocated and recycled set of descriptor pools for stuff that changes every frame, and then I've got my materials grouped into pack files (for fast content loading) and each of those has one descriptor pool for all the sets for all of its materials. Easy peasy. For bindless, you need to figure out how you're going to divide up the big array of descriptors in your one mega set. There's different strategies for doing that. But you'll get a better description of them out of the bindless fans on the server.
				</p>
			</li>
			<li>
				<p>
                    Implementation-wise, 
					<em>
                        I
					</em>
                    &nbsp;don't think there's a huge complexity difference between the two approaches. Bindless might be 
					<em>
                        conceptually
					</em>
                    &nbsp;simpler since &quot;it's just a big array&quot; doesn't require as big of a mental shift as dividing resources up by usage and update frequency and thinking in 
					<em>
                        those
					</em>
                    &nbsp;terms.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In the “classic” model, before you draw or dispatch, you must bind each resource to a specific descriptor binding or slot.
		</p>
	</li>
	<li>
		<p>
            Example:
		</p>
		<ul>
			<li>
				<p>
                    <code>vkCmdBindDescriptorSets(...)</code>
				</p>
			</li>
			<li>
				<p>
                    Binding texture #0 for this draw, texture #1 for that draw, etc.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            The shader uses a fixed binding index:
		</p>
		<ul>
			<li>
				<p>
                    <code>layout(set = 0, binding = 3) uniform sampler2D tex;</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If you want to change which texture is used, you re-bind that descriptor.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250806171334.png" width="475" >
            .
		</p>
	</li>
</ul>
<h4
	id="strategies-for-dealing-with-selected-resources" >
    Strategies for dealing with selected Resources
</h4>
<h6
	id="options" >
    Options
</h6>
<ul>
	<li>
		<p>
			<strong>
                Bindless + Fully Bound
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor array is large, every index is valid.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bindless + Partially Bound (Unbound)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Descriptor array is large, some slots are empty.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Not Bindless + Fully Bound
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Fixed bindings, all set.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Not Bindless + Partially Bound
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Less common, but possible with descriptor indexing.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="quotunboundquot-quotpartially-boundquot" >
    &quot;Unbound&quot; / &quot;Partially Bound&quot;
</h5>
<ul>
	<li>
		<p>
            It is about whether the selected resources are fully populated.
		</p>
	</li>
	<li>
		<p>
            Means the descriptor array doesn’t have all elements populated.
		</p>
	</li>
	<li>
		<p>
            With 
            <code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code>
            &nbsp;you can leave some descriptors in the array unset.
		</p>
	</li>
	<li>
		<p>
            The shader must ensure it never accesses those unset indices — doing so is undefined behavior.
		</p>
	</li>
	<li>
		<p>
            This is different from traditional Vulkan, where all bound descriptors had to be valid before use.
		</p>
	</li>
	<li>
		<p>
			<em>
                Unbounded
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Unbounded is called 
					<em>
                        variable size
					</em>
                    &nbsp;in Vulkan.
				</p>
			</li>
			<li>
				<p>
                    Use 
                    <code>VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT</code>
                    &nbsp;to indicate a descriptor has a variable size.
				</p>
				<ul>
					<li>
						<p>
                            <code>VkDescriptorSetLayoutBinding:descriptorCount</code>
                            &nbsp;is an upper bound on the size of the binding.
						</p>
					</li>
					<li>
						<p>
                            Variable count is restricted to the last binding in the set.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="specialization-constants" >
    Specialization Constants
</h3>
<ul>
	<li>
		<p>
            Allows a constant value in SPIR-V to be specified at 
            <code>VkPipeline</code>
            &nbsp;creation time.
		</p>
	</li>
	<li>
		<p>
            This is powerful as it replaces the idea of doing preprocessor macros in the high level shading language (GLSL, HLSL, etc).
		</p>
	</li>
	<li>
		<p>
            A way to provide constant values to a SPIR-V shader at pipeline creation time so the compiler can constant-fold, inline, and eliminate branches.
		</p>
		<ul>
			<li>
				<p>
                    This yields code equivalent to having compiled separate shader variants with those constant values baked in.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This is not Vulkan exclusive, but an optimization from SPIR-V. OpenGL 4.6 can also use this feature.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/performance/specialization_constants/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            UBOs and Push Constants suffer from limited optimizations during shader compilation. Specialization Constants can provide those optimizations:
		</p>
		<ul>
			<li>
				<p>
                    Uniform buffer objects (UBOs) are one of the most common approaches when it is necessary to set values within a shader at run-time and are used in many tutorials. UBOs are pushed to the shader just prior to its execution, this is after shader compilation which occurs during 
                    <code>vkCreateGraphicsPipelines</code>
                    . As these values are set after the shader has been compiled, the driver’s shader compiler has limited scope to perform optimizations to the shader during its compilation. This is because optimizations such as loop unrolling or unused code removal require the compiler to have knowledge of the values controlling them which is not possible with UBOs. Push constants also suffer from the same problems as UBOs, as they are also provided after the shader has been compiled.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Specialization Constants
					</em>
                    &nbsp;are set before pipeline creation meaning these values are known during shader compilation, this allows the driver’s shader compiler to perform optimizations. In this optimisation process the compiler has the ability to remove unused code blocks and statically unroll which reduces the fragment cycles required by the shader which results in increased performance.
				</p>
			</li>
			<li>
				<p>
                    While specialization constants rely on knowing the required values before pipeline creation occurs, by trading off this flexibility and allowing the compiler to perform these optimizations you can increase the performance of your application easily and reduce shader code size.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Do
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use compile-time specialization constants for all control flow. This allows compilation to completely remove unused code blocks and statically unroll loops.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Don’t
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Use control-flow which is parameterized by uniform values; specialize shaders for each control path needed instead.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Impact
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Reduced performance due to less efficient shader programs.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Example
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl"> #version 450
 layout (constant_id = 0) const float myColor = 1.0;
 layout(location = 0) out vec4 outColor;
 
 void main() {
&nbsp;&nbsp;&nbsp;&nbsp; outColor = vec4(myColor);
 }
</code></pre>
<pre><code class="language-c" data-lang="c"> struct myData {
&nbsp;&nbsp;&nbsp;&nbsp; float myColor = 1.0f;
 } myData;
 
 VkSpecializationMapEntry mapEntry = {};
 mapEntry.constantID = 0; // matches constant_id in GLSL and SpecId in SPIR-V
 mapEntry.offset&nbsp;&nbsp;&nbsp;&nbsp; = 0;
 mapEntry.size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sizeof(float);
 
 VkSpecializationInfo specializationInfo = {};
 specializationInfo.mapEntryCount = 1;
 specializationInfo.pMapEntries&nbsp;&nbsp; = &mapEntry;
 specializationInfo.dataSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= sizeof(myData);
 specializationInfo.pData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &myData;
 
 VkGraphicsPipelineCreateInfo pipelineInfo = {};
 pipelineInfo.pStages[fragIndex].pSpecializationInfo = &specializationInfo;
 
 // Create first pipeline with myColor as 1.0
 vkCreateGraphicsPipelines(&pipelineInfo);
 
 // Create second pipeline with same shader, but sets different value
 myData.myColor = 0.5f;
 vkCreateGraphicsPipelines(&pipelineInfo);
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Use cases
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Toggling features:
				</p>
				<ul>
					<li>
						<p>
                            Support for a feature in Vulkan isn’t known until runtime. This usage of specialization constants is to prevent writing two separate shaders, but instead embedding a constant runtime decision.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Improving backend optimizations:
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Optimizing shader compilation
							</em>
                            &nbsp;from SPIR-V to GPU.
						</p>
					</li>
					<li>
						<p>
                            The “backend” here refers to the implementation’s compiler that takes the resulting SPIR-V and lowers it down to some ISA to run on the device.
						</p>
					</li>
					<li>
						<p>
                            Constant values allow a set of optimizations such as 
							<a
								href="https://en.wikipedia.org/wiki/Constant_folding" 
								class="external-link" 
								target="_blank" >
                                constant folding
							</a>
                            , 
							<a
								href="https://en.wikipedia.org/wiki/Dead_code_elimination" 
								class="external-link" 
								target="_blank" >
                                dead code elimination
							</a>
                            , etc. to occur.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Affecting types and memory sizes:
				</p>
				<ul>
					<li>
						<p>
                            It is possible to set the length of an array or a variable type used through a specialization constant.
						</p>
					</li>
					<li>
						<p>
                            It is important to notice that a compiler will need to allocate registers depending on these types and sizes. This means it is likely that a pipeline cache will fail if the difference is significant in registers allocated.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How they work
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The values are supplied using 
                    <code>VkSpecializationInfo</code>
                    &nbsp;attached to the 
                    <code>VkPipelineShaderStageCreateInfo</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    In GLSL (or HLSL → SPIR-V) mark a constant with a constant id, e.g. 
                    <code>layout(constant_id = 0) const int MATERIAL_MODE = 0;</code>
				</p>
			</li>
			<li>
				<p>
                    Create 
                    <code>VkSpecializationMapEntry</code>
                    &nbsp;entries mapping 
                    <code>constantID</code>
                    &nbsp;→ offset/size in your data block.
				</p>
			</li>
			<li>
				<p>
                    Fill a contiguous data buffer with the specialization values and set up 
                    <code>VkSpecializationInfo</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Put the 
                    <code>VkSpecializationInfo*</code>
                    &nbsp;into the shader stage 
                    <code>VkPipelineShaderStageCreateInfo</code>
                    &nbsp;before calling 
                    <code>vkCreateGraphicsPipelines</code>
                    . The backend finalizes (specializes/compiles) the shader at pipeline creation time.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                How it affects the pipeline workflow
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            It does not solve the pipeline workflow problem. It provides a system for shader optimization at SPIR-V→GPU compile time.
						</p>
					</li>
					<li>
						<p>
                            Specialization lets you get near-compile-time optimizations while still selecting variants at runtime, but it does not avoid having multiple created pipelines if you need multiple different specialized behaviors.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    They do not, by themselves, precompile every possible branch permutation and keep them all resident for you. Each distinct set of specialization values that you want available at runtime normally corresponds to a separately created pipeline (the specialization values are applied during pipeline creation).
				</p>
			</li>
			<li>
				<p>
                    If you need multiple variants you must create (or reuse) the pipelines for those values.
				</p>
			</li>
			<li>
				<p>
                    If you have N independent boolean specialization choices, the number of possible specialized pipelines is 2^N (exponential growth). Creating many pipelines increases driver/state memory and creation time; use caching/derivatives/libraries if creation cost or count is a concern.
				</p>
			</li>
			<li>
				<p>
                    You cannot change a specialization constant per draw without binding a different pipeline: the specialization is fixed for the pipeline object, so per-draw changes require binding another pipeline or using a different strategy (uniforms, push constants, dynamic branching).
				</p>
			</li>
			<li>
				<p>
                    Different values mean different pipeline creation (driver work / memory).
				</p>
			</li>
			<li>
				<p>
                    &quot;Is this a way to precompile every branching of a shader?&quot;
				</p>
				<ul>
					<li>
						<p>
                            Yes, but only if you actually create a pipeline for each variant.
						</p>
					</li>
					<li>
						<p>
                            Specialization constants let the driver compile-away branches at pipeline-creation time, but they do not magically produce all variants for you at draw time.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Recommendations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://blogs.igalia.com/itoral/2018/03/20/improving-shader-performance-with-vulkans-specialization-constants/?utm_source=chatgpt.com" 
						class="external-link" 
						target="_blank" >
                        Improving shader performance with vulkan's specialization constants
					</a>
                    .
				</p>
				<ul>
					<li>
						<p>
                            When we create the Vulkan pipeline, we pass this specialization information using the 
                            <code>pSpecializationInfo</code>
                            &nbsp;field of 
                            <code>VkPipelineShaderStageCreateInfo</code>
                            . At that point, the driver will override the default value of the specialization constant with the value provided here before the shader code is optimized and native GPU code is generated, which allows the driver compiler backend to generate optimal code.
						</p>
					</li>
					<li>
						<p>
                            It is possible to compile the same shader with different constant values in different pipelines, so even if a value changes often, so long as we have a finite number of combinations, we can generate optimized pipelines for each one ahead of the start of the rendering loop and just swap pipelines as needed while rendering.
						</p>
					</li>
					<li>
						<p>
                            &quot;promote the UBO array to a push constant&quot;.
						</p>
					</li>
					<li>
						<p>
                            Applying specialization constants in a small number of shaders allowed me to benefit from loop unrolling and, most importantly, UBO promotion to push constants in the SSAO pass, obtaining performance improvements that ranged from 10% up to 20% depending on the configuration.
						</p>
					</li>
					<li>
						<p>
                            In other words:
						</p>
						<ul>
							<li>
								<p>
                                    The article shows how it's possible to pass a value to the shader during graphics pipeline creation so the shader is compiled from SPIR-V to GPU with that constant altered.
								</p>
							</li>
							<li>
								<p>
                                    This helps by allowing the SPIR-V→GPU compiler to make optimization choices such as unrolling loops and removing branches; it can also enable UBO promotion.
								</p>
							</li>
							<li>
								<p>
                                    The article does not suggest specialization constants solve the pipeline workflow problem. It focuses on compile-time shader optimizations.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="physical-storage-buffer-vk_khr_buffer_device_address" >
    Physical Storage Buffer (VK_KHR_buffer_device_address)
</h3>
<ul>
	<li>
		<p>
			<em>
                Impressions
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    [2025/09/08]
				</p>
			</li>
			<li>
				<p>
                    No descriptor sets.
				</p>
				<ul>
					<li>
						<p>
                            Cool.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Very easy to set up.
				</p>
			</li>
			<li>
				<p>
                    Shader usage is a bit tricky; push constants are required to access buffers in many patterns.
				</p>
			</li>
			<li>
				<p>
                    More prone to programmer errors because there is no automatic bounds checking.
				</p>
			</li>
			<li>
				<p>
                    Hmm, idk, for now not sure.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Adds the ability to have “pointers in the shader”.
		</p>
	</li>
	<li>
		<p>
            Buffer device address is a powerful and unique feature of Vulkan. It exposes GPU virtual addresses directly to the application, and the application can then use those addresses to access buffer data freely through pointers rather than descriptors.
		</p>
	</li>
	<li>
		<p>
            This feature lets you place addresses in buffers and load and store to them inside shaders, with full capability to perform pointer arithmetic and other tricks.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Support
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Core in Vulkan 1.3.
				</p>
			</li>
			<li>
				<p>
                    Submitted at [2019/01/06], core at [2019/11/25].
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://vulkan.gpuinfo.org/displayextensiondetail.php?extension=VK_KHR_buffer_device_address" 
						class="external-link" 
						target="_blank" >
                        Coverage
					</a>
                    :
				</p>
				<ul>
					<li>
						<p>
                            [2025/09/08] 71.6%
						</p>
					</li>
					<li>
						<p>
                            79.8% Windows
						</p>
					</li>
					<li>
						<p>
                            70.9% Linux
						</p>
					</li>
					<li>
						<p>
                            68.7% Android
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Lack of safety
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A critical thing to note is that a raw pointer has no idea of how much memory is safe to access. Unlike SSBOs when bounds-checking features are enabled, you must either do range checks yourself or avoid relying on out-of-bounds behavior.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Creating a buffer
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    To be able to grab a device address from a 
                    <code>VkBuffer</code>
                    , you must create the buffer with 
                    <code>SHADER_DEVICE_ADDRESS_BIT</code>
                    &nbsp;usage.
				</p>
			</li>
			<li>
				<p>
                    The memory you bind that buffer to must be allocated with the corresponding flag via 
                    <code>pNext</code>
                    .
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c"> VkMemoryAllocateFlagsInfoKHR flags_info{VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR};
 flags_info.flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;
 memory_allocation_info.pNext = &flags_info;
</code></pre>
		<ul>
			<li>
				<p>
                    After allocating and binding the buffer, query the address:
				</p>
			</li>
		</ul>
<pre><code class="language-c" data-lang="c"> VkBufferDeviceAddressInfoKHR address_info{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR};
 address_info.buffer = buffer.buffer;
 buffer.gpu_address&nbsp;&nbsp;= vkGetBufferDeviceAddressKHR(device, &address_info);
</code></pre>
		<ul>
			<li>
				<p>
                    This address behaves like a normal address; you can offset the 
                    <code>VkDeviceAddress</code>
                    &nbsp;value as you see fit since it is a 
                    <code>uint64_t</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    There is no host-side alignment requirement enforced by the API for this value.
				</p>
			</li>
			<li>
				<p>
                    When using this pointer in shaders, you must provide and respect alignment semantics yourself, because the shader compiler cannot infer anything about a raw pointer loaded from memory.
				</p>
			</li>
			<li>
				<p>
                    You can place this pointer inside another buffer and use it as an indirection.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                <code>GL_EXT_buffer_reference</code>
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In Vulkan GLSL, the 
                    <code>GL_EXT_buffer_reference</code>
                    &nbsp;extension allows declaring buffer blocks as pointer-like types rather than SSBOs. GLSL lacks true pointer types, so this extension exposes pointer-like behavior.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #extension GL_EXT_buffer_reference : require
</code></pre>
		<ul>
			<li>
				<p>
                    You can forward-declare types. Useful for linked lists and similar structures.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> layout(buffer_reference) buffer Position;
</code></pre>
		<ul>
			<li>
				<p>
                    You can declare a buffer reference type. This is not an SSBO declaration, but effectively a pointer-to-struct.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> layout(std430, buffer_reference, buffer_reference_align = 8) writeonly buffer Position {
&nbsp;&nbsp;&nbsp;&nbsp; vec2 positions[];
 };
</code></pre>
		<ul>
			<li>
				<p>
                    <code>buffer_reference</code>
                    &nbsp;tags the type accordingly. 
                    <code>buffer_reference_align</code>
                    &nbsp;marks the minimum alignment for pointers of this type.
				</p>
			</li>
			<li>
				<p>
                    You can place the 
                    <code>Position</code>
                    &nbsp;type inside another buffer or another buffer reference type:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer PositionReferences {
&nbsp;&nbsp;&nbsp;&nbsp; Position buffers[];
 };
</code></pre>
		<ul>
			<li>
				<p>
                    Now you have an array of pointers.
				</p>
			</li>
			<li>
				<p>
                    You can also place a buffer reference inside push constants, an SSBO, or a UBO.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> layout(std430, set = 0, binding = 0) readonly buffer Pointers {
&nbsp;&nbsp;&nbsp;&nbsp; Positions positions[];
 };
 
 layout(std430, push_constant) uniform Registers {
&nbsp;&nbsp;&nbsp;&nbsp; PositionReferences references;
 } registers;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Casting pointers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    A key aspect of buffer device address is that we gain the capability to cast pointers freely.
				</p>
			</li>
			<li>
				<p>
                    While it is technically possible (and useful in some cases!) to &quot;cast pointers&quot; with SSBOs with clever use of aliased declarations like so:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> layout(set = 0, binding = 0) buffer SSBO { float v1[]; };
 layout(set = 0, binding = 0) buffer SSBO2 { vec4 v4[]; };
</code></pre>
		<ul>
			<li>
				<p>
                    It gets kind of hairy quickly, and not as flexible when dealing with composite types.
				</p>
			</li>
			<li>
				<p>
                    When we have casts between integers and pointers, we get the full 
					<strong>
                        madness
					</strong>
                    &nbsp;that is pointer arithmetic. Nothing stops us from doing:
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #extension GL_EXT_buffer_reference : require
 layout(buffer_reference) buffer PointerToFloat { float v; };
 
 PointerToFloat pointer = load_pointer();
 uint64_t int_pointer = uint64_t(pointer);
 int_pointer += offset;
 pointer = PointerToFloat(int_pointer);
 pointer.v = 42.0;
</code></pre>
		<ul>
			<li>
				<p>
                    Not all GPUs support 64-bit integers, so it is also possible to use 
                    <code>uvec2</code>
                    &nbsp;to represent pointers. This way, we can do raw pointer arithmetic in 32-bit, which might be more optimal anyways.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl"> #extension GL_EXT_buffer_reference_uvec2 : require
 layout(buffer_reference) buffer PointerToFloat { float v; };
 PointerToFloat pointer = load_pointer();
 uvec2 int_pointer = uvec2(pointer);
 uint carry;
 uint lo = uaddCarry(int_pointer.x, offset, carry);
 uint hi = int_pointer.y + carry;
 pointer = PointerToFloat(uvec2(lo, hi));
 pointer.v = 42.0;
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Debugging
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    When debugging or capturing an application that uses buffer device addresses, there are some special driver requirements that are not universally supported. Essentially, to be able to capture application buffers which contain raw pointers, we must ensure that the device address for a given buffer remains stable when the capture is replayed in a new process. Applications do not have to do anything here, since tools like RenderDoc will enable the 
                    <code>bufferDeviceAddressCaptureReplay</code>
                    &nbsp;feature for you, and deal with all the magic associated with address capture behind the scenes. If the 
                    <code>bufferDeviceAddressCaptureReplay</code>
                    &nbsp;is not present however, tools like RenderDoc will mask out the 
                    <code>bufferDeviceAddress</code>
                    &nbsp;feature, so beware.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/samples/latest/samples/extensions/buffer_device_address/README.html" 
				class="external-link" 
				target="_blank" >
                Sample
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250813093236.png" width="500" >
            .
		</p>
	</li>
</ul>
<h2
	id="memory-allocation" >
    Memory Allocation
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=rXSdDE7NWmA" 
				class="external-link" 
				target="_blank" >
                Memory Management
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Talk by AMD.
				</p>
			</li>
			<li>
				<p>
                    Shows no code.
				</p>
			</li>
			<li>
				<p>
                    The video is useful.
				</p>
			</li>
			<li>
				<p>
                    Memory Heaps, Memory Types.
				</p>
			</li>
			<li>
				<p>
                    Memory Blocks.
				</p>
			</li>
			<li>
				<p>
                    Suballocations.
				</p>
			</li>
			<li>
				<p>
                    Dos and Don'ts.
				</p>
			</li>
			<li>
				<p>
                    VMA.
				</p>
			</li>
			<li>
				<p>
                    VmaDumpVis.py to visualize the json file dumped by VMA.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=zSG6dPq57P8" 
				class="external-link" 
				target="_blank" >
                Memory Management
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Sounds more technical; I only saw parts of the talk.
				</p>
			</li>
			<li>
				<p>
                    Talk by AMD.
				</p>
			</li>
			<li>
				<p>
                    Shows code.
				</p>
			</li>
			<li>
				<p>
                    Memory Heaps, Memory Types.
				</p>
			</li>
			<li>
				<p>
                    Dos and Don'ts.
				</p>
			</li>
			<li>
				<p>
                    VMA.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/memory.html" 
				class="external-link" 
				target="_blank" >
                Memory Allocation
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250813101917.png" width="475" >
            .
		</p>
	</li>
</ul>
<h5
	id="problem-as-described-by-the-vma" >
    Problem, as described by the VMA
</h5>
<ul>
	<li>
		<p>
            Memory allocation and resource (buffer and image) creation in Vulkan is difficult (comparing to older graphics APIs, like D3D11 or OpenGL).
		</p>
	</li>
	<li>
		<p>
            It requires a lot of boilerplate code, just like everything else in Vulkan, because it is a low-level and high-performance API.
		</p>
	</li>
	<li>
		<p>
            There is additional level of indirection: 
            <code>VkDeviceMemory</code>
            &nbsp;is allocated separately from creating 
            <code>VkBuffer</code>
            /
            <code>VkImage</code>
            &nbsp;and they must be bound together.
		</p>
	</li>
	<li>
		<p>
            Driver must be queried for supported memory heaps and memory types. Different GPU vendors provide different types of it.
		</p>
	</li>
	<li>
		<p>
            It is recommended to allocate bigger chunks of memory and assign parts of them to particular resources, as there is a limit on maximum number of memory blocks that can be allocated.
		</p>
	</li>
</ul>
<h5
	id="sub-allocation" >
    Sub-allocation
</h5>
<ul>
	<li>
		<p>
            Sub-allocation is a first-class approach when working in Vulkan.
		</p>
	</li>
	<li>
		<p>
            Memory is allocated in pages with a fixed size; sub-allocation reduces the number of OS-level allocations.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Why you should use it
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    You should use memory sub-allocation.
				</p>
			</li>
			<li>
				<p>
                    Memory allocation and deallocation at OS/driver level is expensive.
				</p>
				<ul>
					<li>
						<p>
                            <code>vkAllocateMemory()</code>
                            &nbsp;is costly on the CPU.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Cost can be reduced by suballocating from a large memory object.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Also note the 
            <code>maxMemoryAllocationCount</code>
            &nbsp;limit which constrains the number of simultaneous allocations an application can have.
		</p>
	</li>
	<li>
		<p>
            A Vulkan app should aim to create large allocations and then manage them itself.
		</p>
	</li>
	<li>
        <img src="assets/image_20250813094009.png" width="400" >

	</li>
</ul>
<h5
	id="sparse-resources" >
    Sparse Resources
</h5>
<ul>
	<li>
		<p>
            Sparse resources let you create 
            <code>VkBuffer</code>
            &nbsp;and 
            <code>VkImage</code>
            &nbsp;objects which are bound non-contiguously to one or more 
            <code>VkDeviceMemory</code>
            &nbsp;allocations.
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/sparse_resources.html" 
				class="external-link" 
				target="_blank" >
                Sparse Resources
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/spec/latest/chapters/sparsemem.html" 
				class="external-link" 
				target="_blank" >
                Sparse Resources
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="protected-memory" >
    Protected Memory
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://docs.vulkan.org/guide/latest/protected.html" 
				class="external-link" 
				target="_blank" >
                Protected Memory
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="other-good-practices" >
    Other Good Practices
</h5>
<ul>
	<li>
		<p>
            Use 
            <code>VK_EXT_memory_budget</code>
            &nbsp;to query video memory budget for the process from the OS memory manager.
		</p>
		<ul>
			<li>
				<p>
                    It’s important to keep usage below the budget to avoid stutters caused by demotion of videomemory allocations.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            When memory is over-committed on Windows, the OS memory manager may move allocations from video memory to system memory, the OS also may temporarily suspend a process from the GPU runlist in order to page out its allocations to make room for a different process’ allocations. There is no OS memory manager on Linux that mitigates over-commitment by automatically performing paging operations on memory objects.
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>VK_EXT_pageable_device_local_memory</code>
            &nbsp;to avoid demotion of critical resources by assigning memory priority. It’s also a good idea to set low priority to non-critical resources such as vertex and index buffers; the app can verify the performance impact by placing the resources in system memory. 
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>VK_EXT_pageable_device_local_memory</code>
            &nbsp;to also disable automatic promotion of allocations from system memory to video memory.
		</p>
	</li>
	<li>
		<p>
            Use dedicated memory allocations (
            <code>VK_KHR_dedicated_allocation</code>
            , core in VK 1.1) when appropriate.
		</p>
	</li>
	<li>
		<p>
            Using dedicated memory may improve performance for color and depth attachments, especially on pre-Turing GPUs.
		</p>
	</li>
	<li>
		<p>
            Use 
            <code>VK_KHR_get_memory_requirements2</code>
            &nbsp;(core in VK 1.1) to check whether an image/buffer requires dedicated allocation.
		</p>
	</li>
	<li>
		<p>
            Use host visible video memory to write data directly to video memory from the CPU. Such heap can be detected using 
            <code>DEVICE_LOCAL_BIT | HOST_VISIBLE_BIT</code>
            . Take into account that CPU writes to such memory may be slower compared to normal memory. CPU reads are significantly slower. Check BAR1 traffic using Nsight Systems for possible issues.
		</p>
	</li>
	<li>
		<p>
            Explicitly look for the 
            <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>
            &nbsp;when picking a memory type for resources, which should be stored in video memory.
		</p>
	</li>
</ul>
<h5
	id="bad-practices" >
    Bad Practices
</h5>
<ul>
	<li>
		<p>
            Don’t assume fixed heap configuration, always query and use the memory properties using 
            <code>vkGetPhysicalDeviceMemoryProperties()</code>
            .
		</p>
	</li>
	<li>
		<p>
            Don’t assume memory requirements of an image/buffer, use 
            <code>vkGet*MemoryRequirements()</code>
            . 
		</p>
	</li>
	<li>
		<p>
            Don’t put every resource into a Dedicated Allocation.
		</p>
	</li>
	<li>
		<p>
            For memory objects that are intended to be in device-local, do not just pick the first memory type. Pick one that is actually device-local.
		</p>
	</li>
</ul>
<h5
	id="limitations-and-tips" >
    Limitations and Tips
</h5>
<ul>
	<li>
		<p>
            In a real world application, you’re not supposed to actually call 
            <code>vkAllocateMemory</code>
            &nbsp;for every individual buffer.
		</p>
	</li>
	<li>
		<p>
            The maximum number of simultaneous memory allocations is limited by the 
            <code>maxMemoryAllocationCount</code>
            &nbsp;physical device limit, which may be as low as 
            <code>4096</code>
            &nbsp;even on high end hardware like an NVIDIA GTX 1080.
		</p>
	</li>
	<li>
		<p>
            The right way to allocate memory for a large number of objects at the same time is to create a custom allocator that splits up a single allocation among many different objects by using the 
            <code>offset</code>
            &nbsp;parameters that we’ve seen in many functions.
		</p>
	</li>
	<li>
		<p>
            You can either implement such an allocator yourself, or use the 
			<a
				href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator" 
				class="external-link" 
				target="_blank" >
                VMA
			</a>
            &nbsp;library provided by the GPUOpen initiative.
		</p>
	</li>
	<li>
		<p>
            However, for this tutorial, it’s okay to use a separate allocation for every resource, because we won’t come close to hitting any of these limits for now.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://developer.nvidia.com/vulkan-memory-management" 
				class="external-link" 
				target="_blank" >
                Driver developers recommend
			</a>
            &nbsp;that you also store multiple buffers, like the vertex and index buffer, into a single 
            <code>VkBuffer</code>
            &nbsp;and use offsets in commands like 
            <code>vkCmdBindVertexBuffers</code>
            .
		</p>
		<ul>
			<li>
				<p>
                    The advantage is that your data is more cache friendly in that case, because it’s closer together. It is even possible to reuse the same chunk of memory for multiple resources if they are not used during the same render operations, provided that their data is refreshed, of course.
				</p>
			</li>
			<li>
				<p>
                    This is known as 
					<em>
                        aliasing
					</em>
                    &nbsp;and some Vulkan functions have explicit flags to specify that you want to do this.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="vulkan-memory-allocator-vma" >
    Vulkan Memory Allocator (VMA)
</h5>
<ul>
	<li>
		<p
			class="line-emphasis" >
            
			<a
				href="https://github.com/Capati/odin-vma?utm_source=chatgpt.com" 
				class="external-link" 
				target="_blank" >
                VMA in Odin
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator" 
				class="external-link" 
				target="_blank" >
                VMA (vulkan memory allocator)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Implements memory allocators for Vulkan, header only. In Vulkan, the user has to deal with the memory allocation of buffers, images, and other resources on their own. This can be very difficult to get right in a performant and safe way. Vulkan Memory Allocator does it for us and allows us to simplify the creation of images and other resources. Widely used in personal Vulkan engines or smaller scale projects like emulators. Very high end projects like Unreal Engine or AAA engines write their own memory allocators.
		</p>
	</li>
	<li>
		<p>
            There are cases like the PCSX3 emulator project, where they replaced their attempt at allocation to VMA, and won 20% extra framerate.
		</p>
	</li>
	<li>
		<p>
			<em>
                Críticas
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250907092003.png" width="425" >
                    .
				</p>
			</li>
			<li>
				<p>
                    The person who said that seems like a jerk, but it's interesting to consider.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="hdr-support" >
    HDR Support
</h2>
<ul>
	<li>
		<p>
            Shader code converts high-dynamic-range (HDR) linear color values (often stored in floating formats like 
            <code>R16G16B16A16_SFLOAT</code>
            ) into display-referred low-dynamic-range (LDR) values (sRGB or the swapchain format).
		</p>
	</li>
	<li>
		<p>
            Operations include exposure, clamping, tone curve (Reinhard, ACES, filmic), and gamma or sRGB conversion.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/shorts/0M7INvSHSRk" 
				class="external-link" 
				target="_blank" >
                Each monitor manufacturer does this differently; it's not standardized
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Inputs:
		</p>
		<ul>
			<li>
				<p>
                    HDR color (linear), optionally exposure/exposure texture, bloom, eye adaptation.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Steps (example minimal):
		</p>
		<ol>
			<li>
				<p>
                    Multiply by exposure.
				</p>
			</li>
			<li>
				<p>
                    Apply curve (e.g. Reinhard: 
                    <code>c/(1+c)</code>
                    , or ACES approximation).
				</p>
			</li>
			<li>
				<p>
                    Convert to sRGB/gamma (
                    <code>pow(color, 1.0/2.2)</code>
                    ) or use proper sRGB conversion.
				</p>
			</li>
			<li>
				<p>
                    Output 
                    <code>vec4</code>
                    &nbsp;clamped to 
                    <code>[0,1]</code>
                    &nbsp;into swapchain format (e.g. 
                    <code>VK_FORMAT_B8G8R8A8_UNORM</code>
                    ).
				</p>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="drawing-to-a-high-precision-image-coder16g16b16a16_sfloat-code" >
    Drawing to a High Precision Image (
    <code>R16G16B16A16_SFLOAT</code>
    )
</h5>
<ul>
	<li>
		<p>
            Rendering into an 
            <code>R16G16B16A16_SFLOAT</code>
            &nbsp;(FP16) image provides:
		</p>
		<ul>
			<li>
				<p>
                    Higher dynamic range and precision (light accumulation &gt; 1.0, less banding, better tone mapping).
				</p>
			</li>
			<li>
				<p>
                    Freedom to tone-map and convert later.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This is the 
			<em>
                engine-side HDR pipeline
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://vkguide.dev/docs/new_chapter_2/vulkan_new_rendering/#new-draw-loop" 
				class="external-link" 
				target="_blank" >
                Described technique
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    From &quot;New draw loop&quot; until the end.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Rendering into a separate high-precision offscreen target and then copying/blitting/tonemapping into the swapchain is the standard approach when you need arbitrary internal resolution, higher precision, HDR processing, or when the swapchain does not expose desired formats/usages. The trade-off is the extra memory and an explicit copy/blit or import step; the benefit is control over precision and size. The Vulkan command 
            <code>vkCmdBlitImage</code>
            &nbsp;/ transfer usage or a shader-based blit/resolve are the usual mechanisms to move from the internal target to the presentable image.
		</p>
	</li>
	<li>
		<p>
            The image we will be using is going to be in the RGBA 16-bit float format.
		</p>
		<ul>
			<li>
				<p>
                    <code>R16G16B16A16_SFLOAT</code>
                    &nbsp;is a common intermediate HDR format (16-bit float per channel). It increases memory and bandwidth (roughly 2× vs 8-bit RGBA) and may affect GPU/VRAM usage and upload/download costs; it also reduces quantization/banding and supports HDR/light-accumulation workflows without clamping at 1.0. The choice is an explicit trade-off: more precision (and headroom for lighting) vs more memory/bandwidth. The format is widely supported for offscreen images but may not be available as a swapchain format on all platforms, which reinforces the decision to render offscreen then convert/tonemap for presentation.
				</p>
			</li>
			<li>
				<p>
                    This is slightly overkill, but will provide us with a lot of extra pixel precision that will come in handy when doing lighting calculations and better rendering.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            It's possible to apply low-latency techniques where we could be rendering into a different image from the swapchain image, and then directly push that image to the swapchain with very low latency.
		</p>
		<ul>
			<li>
				<p>
                    Techniques like NVIDIA's &quot;Latency Markers&quot; / Reflex or AMD's Anti-Lag rely on starting rendering work as early as possible, often 
					<em>
                        before
					</em>
                    &nbsp;the presentation engine signals readiness for the next frame via 
                    <code>vkAcquireNextImageKHR</code>
                    &nbsp;(Vulkan) or 
                    <code>AcquireNextFrame</code>
                    &nbsp;(DXGI). This necessitates rendering into a separate, persistently available image. The swapchain image index is only provided at acquisition time, making pre-rendering impossible with direct swapchain targets. Documentation for these low-latency SDKs implicitly requires separate render targets.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Choosing the image tiling:
		</p>
		<ul>
			<li>
				<p>
                    We can then copy that image into the swapchain image and present it to the screen.
				</p>
			</li>
			<li>
				<p>
                    <code>VkCmdCopyImage</code>
				</p>
				<ul>
					<li>
						<p>
                            Is faster, but its much more restricted, for example the resolution on both images must match.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <code>VkCmdBlitImage</code>
				</p>
				<ul>
					<li>
						<p>
                            Lets you copy images of different formats and different sizes into one another.
						</p>
					</li>
					<li>
						<p>
                            You have a source rectangle and a target rectangle, and the system copies it into its position.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                New code for transitioning
			</em>
            :
		</p>
<pre><code class="language-cpp" data-lang="cpp"> _drawExtent.width = _drawImage.imageExtent.width;
 _drawExtent.height = _drawImage.imageExtent.height;
 
 VK_CHECK(vkBeginCommandBuffer(cmd, &cmdBeginInfo));&nbsp;&nbsp;&nbsp;&nbsp;
 
 // transition our main draw image into general layout so we can write into it
 // we will overwrite it all so we dont care about what was the older layout
 vkutil::transition_image(cmd, _drawImage.image, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_GENERAL);
 
 draw_background(cmd);
 
 //transition the draw image and the swapchain image into their correct transfer layouts
 vkutil::transition_image(cmd, _drawImage.image, VK_IMAGE_LAYOUT_GENERAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);
 vkutil::transition_image(cmd, _swapchainImages[swapchainImageIndex], VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
 
 // execute a copy from the draw image into the swapchain
 vkutil::copy_image_to_image(cmd, _drawImage.image, _swapchainImages[swapchainImageIndex], _drawExtent, _swapchainExtent);
 
 // set swapchain image layout to Present so we can show it on the screen
 vkutil::transition_image(cmd, _swapchainImages[swapchainImageIndex], VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);
 
 //finalize the command buffer (we can no longer add commands, but it can now be executed)
 VK_CHECK(vkEndCommandBuffer(cmd));
</code></pre>
		<ul>
			<li>
				<p>
                    The main difference we have in the render loop is that we no longer do the clear on the swapchain image. Instead, we do it on the 
                    <code>_drawImage.image</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    Once we have cleared the image, we transition both the swapchain and the draw image into their layouts for transfer, and we execute the copy command. Once we are done with the copy command, we transition the swapchain image into present layout for display. As we are always drawing on the same image, our draw_image does not need to access swapchain index, it just clears the draw image. We are also writing the 
                    <code>_drawExtent</code>
                    &nbsp;that we will use for our draw region.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="etc" >
    Etc
</h5>
<ul>
	<li>
		<p>
			<strong>
                But
			</strong>
            &nbsp;this image still has to be copied/tonemapped into the 
			<strong>
                swapchain format
			</strong>
            , which is typically limited to 8-bit UNORM unless the OS/driver supports HDR swapchain formats.
		</p>
	</li>
	<li>
		<p>
            To actually output HDR to the screen, all of the following conditions must be met:
		</p>
	</li>
</ul>
<ol>
	<li>
		<p>
			<strong>
                Swapchain format must support HDR bit depth
			</strong>
            .
		</p>
		<ul>
			<li>
				<p>
                    Example formats: 
                    <code>VK_FORMAT_A2B10G10R10_UNORM_PACK32</code>
                    , 
                    <code>VK_FORMAT_R16G16B16A16_SFLOAT</code>
                    , or platform-specific HDR surface formats.
				</p>
			</li>
			<li>
				<p>
                    You query available swapchain formats via 
                    <code>vkGetPhysicalDeviceSurfaceFormatsKHR</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    If only 8-bit formats are exposed, you cannot present HDR directly.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Swapchain color space must be HDR-capable
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Vulkan allows specifying a 
                    <code>VkColorSpaceKHR</code>
                    &nbsp;(e.g., 
                    <code>VK_COLOR_SPACE_HDR10_ST2084_EXT</code>
                    , 
                    <code>VK_COLOR_SPACE_HDR10_HLG_EXT</code>
                    ).
				</p>
			</li>
			<li>
				<p>
                    These correspond to HDR transfer functions (PQ/HLG).
				</p>
			</li>
			<li>
				<p>
                    If the driver/surface does not expose them, the system compositor won’t accept HDR content.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                OS and display pipeline must be HDR-enabled
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Windows: HDR toggle must be enabled in system settings, compositor configured for HDR10.
				</p>
			</li>
			<li>
				<p>
                    Linux/Wayland: requires HDR support in compositor + driver (still emerging).
				</p>
			</li>
			<li>
				<p>
                    Android: requires 
                    <code>AHardwareBuffer</code>
                    &nbsp;/ 
                    <code>SurfaceView</code>
                    &nbsp;with HDR formats.
				</p>
			</li>
			<li>
				<p>
                    macOS: Metal swapchains expose extended sRGB/PQ output modes.
				</p>
			</li>
			<li>
				<p>
                    (Platform docs confirm HDR availability is compositor-driven).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Application side tone mapping &amp; gamut mapping
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Even if swapchain supports HDR, you generally still render into FP16, then apply:
				</p>
				<ul>
					<li>
						<p>
                            Tone mapping (map wide dynamic range → HDR10/HLG range).
						</p>
					</li>
					<li>
						<p>
                            Color gamut conversion (usually Rec.709 → Rec.2020 for HDR10).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Only then write into the HDR swapchain image.
				</p>
			</li>
		</ul>
	</li>
</ol>
<h2
	id="mobile" >
    Mobile
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://developer.samsung.com/sdp/blog/en/2019/07/26/vulkan-mobile-best-practice-how-to-configure-your-vulkan-swapchain?utm_source=chatgpt.com" 
				class="external-link" 
				target="_blank" >
                Samsung - Mobile best practices
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<em>
                        TLDR
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>presentMode</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    FIFO &gt; MAILBOX.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>minImageCount</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Triple-buffer &gt; double-buffer.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <code>preTransform</code>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Not covered.
								</p>
							</li>
							<li>
								<p>
                                    &quot;Covered in a future post&quot;, but the link is broken.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=yIz4Jzk7bcs" 
				class="external-link" 
				target="_blank" >
                Arm - Mobile Best Practices
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    It's a more technical video.
				</p>
			</li>
			<li>
				<p>
                    Tiled-based GPUs, etc.
				</p>
			</li>
			<li>
				<p>
                    I haven't watched it yet.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            See pages 244 to 311 of 
			<a
				href="https://www.zora.uzh.ch/bitstreams/4c1658c5-19eb-41d2-87c2-c88dc52fb7d3/download" 
				class="external-link" 
				target="_blank" >
                Efficient Real-Time Shading with Many Lights - Ola Olsson, Emil Persson (Avalanche), Markus Billeter - 2014
			</a>
            &nbsp;for more details.
		</p>
		<ul>
			<li>
				<p>
                    &quot;Many Light Rendering on Mobile Hardware&quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=ch6161wvME8" 
				class="external-link" 
				target="_blank" >
                Live Long and Optimise - Samsung 2019
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/image_20250929150320.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250929151149.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Android ideas for fixing Present blocking
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250929151334.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            &quot;This is not going to change when the image is presented, we are just delaying the calling of the function that would display the image, to a point where the image is more likely to be available by the GPU&quot;.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250929151618.png" width="450" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    [2025/09/29] I watched it to study Pipeline Barriers, but the talk covers many mobile-specific topics.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="glfw" >
    GLFW
</h5>
<ul>
	<li>
		<p>
            An unfortunate disadvantage is GLFW doesn’t work in Android or iOS; it is a desktop-only solution.
		</p>
	</li>
	<li>
		<p>
            SDL does offer mobile support; however, mobile windowing support is best done by interfacing with the Operating system such as using the 
			<strong>
                JNI
			</strong>
            &nbsp;in Android.
		</p>
	</li>
	<li>
		<p>
            While mobile is beyond the scope of this initial tutorial, plans exist to eventually cover it in detail, and 
			<a
				href="https://developer.android.com/ndk/guides/graphics/getting-started" 
				class="external-link" 
				target="_blank" >
                Google has excellent documentation
			</a>
            .
		</p>
	</li>
</ul>
<h5
	id="pre-rotation" >
    Pre-Rotation
</h5>
<ul>
	<li>
		<p>
            <img src="assets/image_20250818173112.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818173229.png" width="475" >
            .
		</p>
		<ul>
			<li>
				<p>
                    You can only query 
                    <code>surfaceCapabilities.currentTransform</code>
                    , you cannot set it.
				</p>
			</li>
			<li>
				<p>
                    If they don't match, the presentation engine will have to do the pre-rotation for you, which has a performance cost.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Implementing a full pre-rotate system is reportedly difficult, so many engines avoid it.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818173635.png" width="475" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250818173712.png" width="450" >
            .
		</p>
		<ul>
			<li>
				<p>
                    This is a simpler option to implement.
				</p>
			</li>
			<li>
				<p>
                    &quot;Many engines already do a blit to the final image to the swapchain image, so this is the perfect place to do the pre-rotation&quot;.
				</p>
				<ul>
					<li>
						<p>
                            &quot;Basically free and you get performance benefits&quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="vr" >
    VR
</h2>
<ul>
	<li>
		<p>
            <a href="Graphics Programming, Shaders.html#Variable Rate Shading (VRS)">
            Graphics Programming, Shaders#Variable Rate Shading (VRS)
            </a>
            .
		</p>
	</li>
</ul>
<h2
	id="video-decoding" >
    Video Decoding
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2023/05/vulkan-video-decoding/" 
				class="external-link" 
				target="_blank" >
                Video Decoding - Wicked Engine
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="spir-v" >
    SPIR-V
</h2>
<ul>
	<li>
		<p>
			<em>
                Standard Portable Intermediate Representation V
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.vulkan.org/guide/latest/what_is_spirv.html" 
				class="external-link" 
				target="_blank" >
                SPIR-V
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Vulkan’s official shader format (portable, efficient).
		</p>
	</li>
	<li>
		<p>
            SPIR-V is a binary format.
		</p>
	</li>
	<li>
		<p>
            Works with Metal via MoltenVK.
		</p>
	</li>
</ul>
<h5
	id="compiling" >
    Compiling
</h5>
<ul>
	<li>
		<p>
            You can write GLSL or HLSL and compile to SPIR-V.
		</p>
		<ul>
			<li>
				<p>
                    GLSL to SPIR-V:
				</p>
				<ul>
					<li>
						<p>
                            glslangValidator (from Khronos)
						</p>
					</li>
				</ul>
<pre><code class="language-sh" data-lang="sh"> # Compile GLSL → SPIR-V (Vulkan)
 glslangValidator -V vertex_shader.vert -o vert.spv
 glslangValidator -V fragment_shader.frag -o frag.spv
</code></pre>
			</li>
			<li>
				<p>
                    HLSL to SPIR-V:
				</p>
				<ul>
					<li>
						<p>
                            DXC (DirectX Shader Compiler)
						</p>
					</li>
				</ul>
<pre><code class="language-sh" data-lang="sh"> dxc -T vs_6_0 -E VSMain -spirv shader.hlsl -Fo vert.spv
</code></pre>
				<ul>
					<li>
						<p>
                            Requires HLSL shaders with Vulkan-compatible semantics.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Convert SPIR-V to other formats:
				</p>
				<ul>
					<li>
						<p>
                            SPIRV-Cross (converts HLSL to GLSL/SPIR-V)
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Compiling shaders on the commandline is one of the most straightforward options and it's the one that we'll use in this tutorial, but it's also possible to compile shaders directly from your own code.
		</p>
		<ul>
			<li>
				<p>
                    The Vulkan SDK includes 
					<a
						href="https://github.com/google/shaderc" 
						class="external-link" 
						target="_blank" >
                        libshaderc
					</a>
                    , which is a library to compile GLSL code to SPIR-V from within your program.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="advantages" >
    Advantages
</h5>
<ul>
	<li>
		<p>
            The advantage of using a bytecode format is that the compilers written by GPU vendors to turn shader code into native code are significantly less complex. The past has shown that with human-readable syntax like GLSL, some GPU vendors were rather flexible with their interpretation of the standard. If you happen to write non-trivial shaders with a GPU from one of these vendors, then you’d risk another vendor’s drivers rejecting your code due to syntax errors, or worse, your shader running differently because of compiler bugs. With a straightforward bytecode format like SPIR-V that will hopefully be avoided.
		</p>
	</li>
</ul>
<h3
	id="tooling" >
    Tooling
</h3>
<h5
	id="spirv-cross" >
    spirv-cross
</h5>
<ul>
	<li>
		<p>
			<strong>
                Cross-compilation
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Converts SPIR-V shader binaries into high-level shading languages:
				</p>
				<ul>
					<li>
						<p>
                            GLSL (various versions)
						</p>
					</li>
					<li>
						<p>
                            HLSL
						</p>
					</li>
					<li>
						<p>
                            MSL (Metal Shading Language for Apple platforms)
						</p>
					</li>
					<li>
						<p>
                            WGSL (WebGPU shading language)
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    This lets you write shaders once (e.g. in GLSL or HLSL), compile to SPIR-V, then regenerate source for other backends.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Reflection
			</strong>
		</p>
		<ul>
			<li>
				<p>
                    Inspects SPIR-V binaries and reports metadata about:
				</p>
				<ul>
					<li>
						<p>
                            Descriptor sets and bindings
						</p>
					</li>
					<li>
						<p>
                            Push constants
						</p>
					</li>
					<li>
						<p>
                            Vertex input/output attributes
						</p>
					</li>
					<li>
						<p>
                            Specialization constants
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    With the 
                    <code>--reflect</code>
                    &nbsp;flag, it outputs this data as 
					<strong>
                        JSON
					</strong>
                    , making it easy to drive engine code-generation or runtime Vulkan setup.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Ex
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>spirv-cross scene_vert.spv --reflect &gt; scene_vert.json</code>
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="web" >
    Web
</h2>
<ul>
	<li>
		<p>
            No Vulkan support in browsers; you must port to WebGPU or use translation layers.
		</p>
	</li>
	<li>
		<p>
            <a href="WebAssembly (WASM).html">
            WebAssembly (WASM)
            </a>
            .
		</p>
	</li>
</ul>
<h3
	id="webgpu-wgpu" >
    WebGPU (wgpu)
</h3>
<ul>
	<li>
		<p>
            WebGPU is a cross-platform graphics API, aiming to unify GPU access across:
		</p>
		<ul>
			<li>
				<p>
                    Browsers (via native support)
				</p>
			</li>
			<li>
				<p>
                    Native apps (via libraries like wgpu, Dawn, etc.)
				</p>
			</li>
		</ul>
	</li>
</ul>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Electronics/Arduino.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                🧑‍💻 built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                📅 2025-10-21 .&nbsp;&nbsp;2025-10-30 🚀
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#about" >
                            About
						</a>
						<ul>
							<li>
								<a
									href="#compatibility" >
                                    Compatibility
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#tutorials" >
                            Tutorials
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#samples" >
                            Samples
						</a>
						<ul>
							<li>
								<a
									href="#api" >
                                    API
								</a>
							</li>
							<li>
								<a
									href="#extensions" >
                                    Extensions
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#core" >
                            Core
						</a>
						<ul>
							<li>
								<a
									href="#instance-extensions-validation-layers" >
                                    Instance / Extensions / Validation Layers
								</a>
							</li>
							<li>
								<a
									href="#window-surface-glfw" >
                                    Window / Surface / GLFW
								</a>
							</li>
							<li>
								<a
									href="#physical-device-logical-device" >
                                    Physical Device / Logical Device
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#render-loop" >
                            Render Loop
						</a>
						<ul>
							<li>
								<a
									href="#swapchain" >
                                    Swapchain
								</a>
							</li>
							<li>
								<a
									href="#swapchain-recreation" >
                                    Swapchain Recreation
								</a>
							</li>
							<li>
								<a
									href="#frames-in-flight" >
                                    Frames In-Flight
								</a>
							</li>
							<li>
								<a
									href="#acquire-next-image" >
                                    Acquire Next Image
								</a>
							</li>
							<li>
								<a
									href="#render-targets" >
                                    Render Targets
								</a>
							</li>
							<li>
								<a
									href="#dynamic-rendering" >
                                    Dynamic Rendering
								</a>
							</li>
							<li>
								<a
									href="#drawing-commands" >
                                    Drawing Commands
								</a>
							</li>
							<li>
								<a
									href="#multithreading-rendering" >
                                    <s>Multithreading Rendering</s>
								</a>
							</li>
							<li>
								<a
									href="#render-passes-and-framebuffers" >
                                    <s>Render Passes and Framebuffers</s>
								</a>
							</li>
							<li>
								<a
									href="#submit" >
                                    Submit
								</a>
							</li>
							<li>
								<a
									href="#presentation" >
                                    Presentation
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#synchronization-and-cache-control" >
                            Synchronization and Cache Control
						</a>
						<ul>
							<li>
								<a
									href="#queues" >
                                    Queues
								</a>
							</li>
							<li>
								<a
									href="#blocking-operations" >
                                    Blocking Operations
								</a>
							</li>
							<li>
								<a
									href="#examples" >
                                    Examples
								</a>
							</li>
							<li>
								<a
									href="#queues" >
                                    Queues
								</a>
							</li>
							<li>
								<a
									href="#execution-dependencies-memory-dependencies-memory-model" >
                                    Execution Dependencies, Memory Dependencies, Memory Model
								</a>
							</li>
							<li>
								<a
									href="#execution-stages" >
                                    Execution Stages
								</a>
							</li>
							<li>
								<a
									href="#memory-access" >
                                    Memory Access
								</a>
							</li>
							<li>
								<a
									href="#pipeline-barriers" >
                                    Pipeline Barriers
								</a>
							</li>
							<li>
								<a
									href="#events-quotsplit-barriersquot" >
                                    Events / &quot;Split Barriers&quot;
								</a>
							</li>
							<li>
								<a
									href="#semaphores-and-fences" >
                                    Semaphores and Fences
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#command-buffers" >
                            Command Buffers
						</a>
						<ul>
							<li>
								<a
									href="#command-pools" >
                                    Command Pools
								</a>
							</li>
							<li>
								<a
									href="#command-buffer" >
                                    Command Buffer
								</a>
							</li>
							<li>
								<a
									href="#command-buffer-recording" >
                                    Command Buffer Recording
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#pipelines" >
                            Pipelines
						</a>
						<ul>
							<li>
								<a
									href="#mesh-shaders" >
                                    Mesh Shaders
								</a>
							</li>
							<li>
								<a
									href="#cluster-culling-shader" >
                                    Cluster Culling Shader
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#graphics-pipeline" >
                            Graphics Pipeline
						</a>
						<ul>
							<li>
								<a
									href="#shader-compilation" >
                                    Shader Compilation
								</a>
							</li>
							<li>
								<a
									href="#input-assembly" >
                                    Input Assembly
								</a>
							</li>
							<li>
								<a
									href="#vertex-shader" >
                                    Vertex Shader
								</a>
							</li>
							<li>
								<a
									href="#tessellation-shader" >
                                    Tessellation Shader
								</a>
							</li>
							<li>
								<a
									href="#geometry-shader" >
                                    Geometry Shader
								</a>
							</li>
							<li>
								<a
									href="#rasterization" >
                                    Rasterization
								</a>
							</li>
							<li>
								<a
									href="#fragment-operations" >
                                    Fragment Operations
								</a>
							</li>
							<li>
								<a
									href="#fragment-shader" >
                                    Fragment Shader
								</a>
							</li>
							<li>
								<a
									href="#color-blending" >
                                    Color Blending
								</a>
							</li>
							<li>
								<a
									href="#creation" >
                                    Creation
								</a>
							</li>
							<li>
								<a
									href="#managing-pipelines-and-reducing-overhead" >
                                    Managing Pipelines and Reducing overhead
								</a>
							</li>
							<li>
								<a
									href="#optimizations" >
                                    Optimizations
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#strongsupport-strong" >
                            <strong>Support</strong>:
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#compute-pipeline" >
                            Compute Pipeline
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#resources" >
                            Resources
						</a>
						<ul>
							<li>
								<a
									href="#memory" >
                                    Memory
								</a>
							</li>
							<li>
								<a
									href="#buffers" >
                                    Buffers
								</a>
							</li>
							<li>
								<a
									href="#images" >
                                    Images
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#depth" >
                            Depth
						</a>
						<ul>
							<li>
								<a
									href="#depth-tests" >
                                    Depth Tests
								</a>
							</li>
							<li>
								<a
									href="#depth-attachment" >
                                    Depth Attachment
								</a>
							</li>
							<li>
								<a
									href="#depth-image" >
                                    Depth Image
								</a>
							</li>
							<li>
								<a
									href="#normal-reconstruction-from-depth" >
                                    Normal Reconstruction from Depth
								</a>
							</li>
							<li>
								<a
									href="#stencil" >
                                    Stencil
								</a>
							</li>
							<li>
								<a
									href="#stencil-attachment" >
                                    Stencil Attachment
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#mapping-data-to-shaders" >
                            Mapping Data to Shaders
						</a>
						<ul>
							<li>
								<a
									href="#shader-memory" >
                                    Shader Memory
								</a>
							</li>
							<li>
								<a
									href="#comparisons" >
                                    Comparisons
								</a>
							</li>
							<li>
								<a
									href="#input-attributes" >
                                    Input Attributes
								</a>
							</li>
							<li>
								<a
									href="#push-constants" >
                                    Push Constants
								</a>
							</li>
							<li>
								<a
									href="#descriptors-sets" >
                                    Descriptors Sets
								</a>
							</li>
							<li>
								<a
									href="#specialization-constants" >
                                    Specialization Constants
								</a>
							</li>
							<li>
								<a
									href="#physical-storage-buffer-vk_khr_buffer_device_address" >
                                    Physical Storage Buffer (VK_KHR_buffer_device_address)
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#memory-allocation" >
                            Memory Allocation
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#hdr-support" >
                            HDR Support
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#mobile" >
                            Mobile
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#vr" >
                            VR
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#video-decoding" >
                            Video Decoding
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#spir-v" >
                            SPIR-V
						</a>
						<ul>
							<li>
								<a
									href="#tooling" >
                                    Tooling
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#web" >
                            Web
						</a>
						<ul>
							<li>
								<a
									href="#webgpu-wgpu" >
                                    WebGPU (wgpu)
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.js" >
		</script>
	</body>
</html>
