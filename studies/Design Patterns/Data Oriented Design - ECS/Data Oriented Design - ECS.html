<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.01935.css" >
	</head>
	<body>
		<aside
			id="left-sidebar" >
			<a
				href="/" 
				class="site-logo" >
                Caio Raphael
			</a>
			<nav>
				<details
>
					<summary>
                        Graphics Programming
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Vulkan/Vulkan.html" >
                                Vulkan
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Render Engineering/Render Engineering.html" >
                                Render Engineering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders.html" >
                                Graphics and Shaders
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GLSL/GLSL.html" >
                                GLSL
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/GPU/GPU.html" >
                                GPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Slang.html" >
                                Slang
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/Font Rendering.html" >
                                Font Rendering
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Graphics Programming/OpenGL/OpenGL.html" >
                                OpenGL
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Low-Level Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Odin/Odin.html" >
                                Odin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Memory/Memory.html" >
                                Memory
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/CPU/CPU.html" >
                                CPU
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Multithreading/Multithreading.html" >
                                Multithreading
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Handmade Hero/Handmade Hero.html" >
                                Handmade Hero
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Profilers/Profilers.html" >
                                Profilers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/C.html" >
                                C
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Build Systems - Compilation - Linking/Build Systems - Compilation - Linking.html" >
                                Build Systems - Compilation - Linking
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Debuggers.html" >
                                Debuggers
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Assembly/Assembly - ASM.html" >
                                Assembly - ASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/Parsing.html" >
                                Parsing
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Low-Level Systems/JAI.html" >
                                JAI
							</a>
						</li>
					</ul>
				</details>
				<details
					open="">
					<summary>
                        Design Patterns
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design.html" >
                                Data Oriented Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="active" 
								href="/studies/Design Patterns/Data Oriented Design - ECS/Data Oriented Design - ECS.html" >
                                Data Oriented Design - ECS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Data Oriented Design - COP/Data Oriented Design - COP.html" >
                                Data Oriented Design - COP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Other Design Patterns/Other Design Patterns.html" >
                                Other Design Patterns
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Concepts and Terminology.html" >
                                Concepts and Terminology
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Rules of thumb - Laws - Guidelines and Principles/Rules of thumb - Laws - Guidelines and Principles.html" >
                                Rules of thumb - Laws - Guidelines and Principles
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Paradigms.html" >
                                Paradigms
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Design Patterns/Production Methodologies/Production Methodologies.html" >
                                Production Methodologies
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Network
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Backend/Network - Backend.html" >
                                Network - Backend
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Low Level e Etc/Network - Low Level e Etc.html" >
                                Network - Low Level e Etc
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - Netcode/Network - Netcode.html" >
                                Network - Netcode
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Network - HTTP/Network - HTTP.html" >
                                Network - HTTP
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Encryption.html" >
                                Encryption
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Security.html" >
                                Security
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/Serialization - Encoding/Serialization - Encoding.html" >
                                Serialization - Encoding
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Network/SSH.html" >
                                SSH
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Game Development
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game AI/Game AI.html" >
                                Game AI
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Procedural Animation/Procedural Animation.html" >
                                Procedural Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Game Design/Game Design.html" >
                                Game Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Level Design.html" >
                                Level Design
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Game Development/Scanning Algorithms.html" >
                                Scanning Algorithms
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Art
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing, Color Theory, Pixel Art/Drawing, Color Theory, Pixel Art.html" >
                                Drawing, Color Theory, Pixel Art
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Low-Poly, PSX.html" >
                                Low-Poly, PSX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Animation.html" >
                                Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Texel Density.html" >
                                Texel Density
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender.html" >
                                Blender
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blender/Blender - Rigging and Animation.html" >
                                Blender - Rigging and Animation
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench.html" >
                                Blockbench
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Blockbench/Blockbench - Source Code.html" >
                                Blockbench - Source Code
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Drawing Softwares.html" >
                                Drawing Softwares
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Aseprite/Aseprite.html" >
                                Aseprite
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Voxel Editors.html" >
                                Voxel Editors
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/MagicaVoxel.html" >
                                MagicaVoxel
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 2D/Level Editors 2D.html" >
                                Level Editors 2D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Level Editors 3D.html" >
                                Level Editors 3D
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/LDtk/LDtk.html" >
                                LDtk
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/TrenchBroom.html" >
                                TrenchBroom
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Art/Assets - Sources and References/Assets - Sources and References.html" >
                                Assets - Sources and References
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Frameworks - Libraries
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Frameworks - Libraries/Frameworks - Libraries.html" >
                                Frameworks - Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/RayLib/RayLib.html" >
                                RayLib
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Frameworks - Libraries/Clay/Clay.html" >
                                Clay
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Physics Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines.html" >
                                Physics Engines
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Physics Engines/Physics Engines - JoltPhysics/Physics Engines - JoltPhysics.html" >
                                Physics Engines - JoltPhysics
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Programming Languages
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Rust/Rust.html" >
                                Rust
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Zig/Zig.html" >
                                Zig
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Go.html" >
                                Go
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/C++/C++.html" >
                                C++
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/CSharp/CSharp.html" >
                                CSharp
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Lua.html" >
                                Lua
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Nim/Nim.html" >
                                Nim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Swift/Swift.html" >
                                Swift
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Python.html" >
                                Python
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Haxe.html" >
                                Haxe
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Kotlin.html" >
                                Kotlin
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Programming Languages/Java.html" >
                                Java
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        WebDev
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebDev/WebDev.html" >
                                WebDev
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTML/HTML.html" >
                                HTML
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/HTMX.html" >
                                HTMX
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/WebAssembly - WASM/WebAssembly - WASM.html" >
                                WebAssembly - WASM
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/CSS/CSS.html" >
                                CSS
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript/JavaScript.html" >
                                JavaScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Frameworks and Libraries/JavaScript - Frameworks and Libraries.html" >
                                JavaScript - Frameworks and Libraries
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/JavaScript - Runtime Environments.html" >
                                JavaScript - Runtime Environments
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/TypeScript.html" >
                                TypeScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Hugo/Hugo.html" >
                                Hugo
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/WebDev/Static Site Generators.html" >
                                Static Site Generators
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Databases
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - SQL - Relational/Databases - SQL - Relational.html" >
                                Databases - SQL - Relational
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - MongoDB.html" >
                                Databases - MongoDB
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Document Oriented.html" >
                                Databases - Document Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - Object Oriented.html" >
                                Databases - Object Oriented
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Databases/Databases - ORMs.html" >
                                Databases - ORMs
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Godot Engine
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot/Godot.html" >
                                Godot
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDScript/Godot - GDScript.html" >
                                Godot - GDScript
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - GDExtensions.html" >
                                Godot - GDExtensions
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Godot Engine/Godot - Source Code.html" >
                                Godot - Source Code
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Embedded Systems
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Sources and Studies.html" >
                                Electronics - Sources and Studies
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Electronics - Projects and Tutorials.html" >
                                Electronics - Projects and Tutorials
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Arduino.html" >
                                Arduino
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/RaspiberryPi.html" >
                                RaspiberryPi
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Embedded Systems/Embedded Systems.html" >
                                Embedded Systems
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Platforms
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Linux/Linux.html" >
                                Linux
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Windows/Windows.html" >
                                Windows
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Steam/Steam.html" >
                                Steam
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/Android/Android.html" >
                                Android
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Platforms/iOS/iOS.html" >
                                iOS
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Terminal
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Terminal/Terminal.html" >
                                Terminal
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Terminal/Shells/Shells.html" >
                                Shells
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Code Editors
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/VSCode - VSCodium.html" >
                                VSCode - VSCodium
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim/NeoVim.html" >
                                NeoVim
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/NeoVim - Setup/NeoVim - Setup.html" >
                                NeoVim - Setup
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Code Editors/Visual Studio/Visual Studio.html" >
                                Visual Studio
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Etc
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Git/Git.html" >
                                Git
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/RegEx.html" >
                                RegEx
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Etc/Licenses.html" >
                                Licenses
							</a>
						</li>
					</ul>
				</details>
				<details
>
					<summary>
                        Other Engines
					</summary>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Unity/Unity.html" >
                                Unity
							</a>
						</li>
					</ul>
					<ul>
						<li>
							<a
								class="" 
								href="/studies/Other Engines/Other Engines.html" >
                                Other Engines
							</a>
						</li>
					</ul>
				</details>
			</nav>
		</aside>
		<div
			id="central-wrapper" >
			<a
				href="/" 
				class="icon-home" >

                <svg version="1.1" id="Capa_1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 299.021 299.021" xml:space="preserve" style="color: whitesmoke;">
                    <g>
                        <g>
                            <path d="M292.866,254.432c-2.288,0-4.443-1.285-5.5-3.399c-0.354-0.684-28.541-52.949-146.169-54.727v51.977
                                c0,2.342-1.333,4.48-3.432,5.513c-2.096,1.033-4.594,0.793-6.461-0.63L2.417,154.392C0.898,153.227,0,151.425,0,149.516
                                c0-1.919,0.898-3.72,2.417-4.888l128.893-98.77c1.87-1.426,4.365-1.667,6.461-0.639c2.099,1.026,3.432,3.173,3.432,5.509v54.776
                                c3.111-0.198,7.164-0.37,11.947-0.37c43.861,0,145.871,13.952,145.871,143.136c0,2.858-1.964,5.344-4.75,5.993
                                C293.802,254.384,293.34,254.432,292.866,254.432z"></path>
                        </g>
                    </g>
                </svg>
                    
			</a>
			<main>
				<article
					id="note-article" >
					<header>
						<h1>
                            Data Oriented Design - ECS
						</h1>
						<p>
							<time
								datetime="2025-03-11" >
                                ðŸ•’ Created: 2025-03-11
							</time>
							<time
								datetime="2026-01-20" >
                                | Updated: 2026-01-20
							</time>
						</p>
					</header>
					<div
						id="note-content" >
<h2
	id="discussion" >
    Discussion
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://www.dataorienteddesign.com/dodbook/node1.html" 
				class="external-link" 
				target="_blank" >
                Data Oriented Design
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Very very interesting read.
				</p>
			</li>
			<li>
				<p>
                    There's quite a lot of yapping about things that don't quite correlate to the problem, but even so, it's a great read.
				</p>
			</li>
			<li>
				<p>
                    I stopped at &quot;Searching&quot; (node7); I haven't read it yet.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="critiques" >
    Critiques
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=UolgW-Ff4bA" 
				class="external-link" 
				target="_blank" >
                Ryan Fleury - Mega-Struct as an alternative to ECS
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=VWC9RT5u8gQ" 
				class="external-link" 
				target="_blank" >
                Jonathan Blow - Mega-Struct as an alternative to ECS
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            What I've heard:
		</p>
		<ul>
			<li>
				<p>
                    Performance:
				</p>
				<ul>
					<li>
						<p>
                            Unnecessary:
						</p>
						<ul>
							<li>
								<p>
                                    Entity update is usually a very miniscule thing in the frame, and if you separate the world into chunks, the goes down even harder.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Particles:
						</p>
						<ul>
							<li>
								<p>
                                    It's usually a complete separate thing than entities.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Flexibility:
				</p>
				<ul>
					<li>
						<p>
                            If you put everything an entity might possibly have into a mega-struct (CoP), you get the flexibility.
						</p>
					</li>
					<li>
						<p>
                            Use a big table of flags, explicitly turn on/off paths of execution.
						</p>
					</li>
					<li>
						<p>
                            &quot;streams of execution, instead of streams of data&quot;.
						</p>
					</li>
					<li>
						<p>
                            Don't think of &quot;doors&quot;, &quot;levers&quot;, &quot;guns&quot;, etc; do put things inside this mental model, just think of paths of execution.
						</p>
						<ul>
							<li>
								<p>
                                    ECS already does that by default, but his suggestion is do that while using a mega-struct, thinking in terms of paths of execution.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            (2026-01-12) Caio
		</p>
		<ul>
			<li>
				<p>
                    Performance.
				</p>
				<ul>
					<li>
						<p>
                            Indeed not an actual concern by looking at Tracy; most of the frame is spent doing other things.
						</p>
					</li>
					<li>
						<p>
                            And indeed, many games will not hit the entity count where having an ECS model makes a difference.
						</p>
					</li>
					<li>
						<p>
                            It's sure good having the option for easy optimization with parallelism/SIMD, but if you are trying to be efficient with your time, probably entity updates will not be this first thing in your code you'll be optimizing.
						</p>
					</li>
					<li>
						<p>
                            Tho, simply just having a dense packed array with your data in it, simple gives you the benefit of faster code due to less cache misses &quot;basically for free&quot;; sure you have to interact with the component system and there's a little bit of wasted memory, but I don't think both of these compare to how wasteful and convoluted a Mega-struct can be. My point is: coding like the processor want us to code and thus making performant code being the base line is sure great.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Flexibility:
				</p>
				<ul>
					<li>
						<p>
                            I disagree. After working with Mega-struct for some months, I see a lot of annoying things happening for having an insane branched-out code: having to manage a lot of different states and code paths, separating behavior based on some enums, or simply holding to SO MUCH DATA that will 
							<strong>
                                never
							</strong>
                            &nbsp;be used by that specific entity at any point during the whole game. All of this creates a lot of operational error, literally me just doing wrong things just by how convoluted the branched out code can be; forgetting to initialize vital structs, forgetting to turn on some behavior or turn off other behavior, etc. As there's a lot of different paths of execution, is not trivial to change the behavior of one entity. Adding new behavior or data in a specific can be quite demotivated, as now you have to go through a gigantic file, going through the scope of a bunch of things and have to constantly think whether you forgot to set up something inside that big pool of random code. One way to think about these issues is by considering how similar having to manage so many branches and states is to a State Machine; if you have worked with a complex State Machine before, you know how easily things can get out of hand and how maintenance complexity grows.
						</p>
					</li>
					<li>
						<p>
                            I'm currently implementing ECS in my engine, and I laugh at how easily it was to make the main character behave like an NPC: I commented 1 line that added a specific input move component, and added 1 line to add an AI move component, that's it.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    In conclusion, having the option for easy optimization is sure great but probably not very useful in most common games, but when it comes to flexibility I don't think a Mega-struct beats the clarity and peace of mind an ECS code brings.
				</p>
			</li>
			<li>
				<p>
                    Obviously, Mega-struct is the 
					<strong>
                        absolute
					</strong>
                    &nbsp;winner when comparing with OOP; I just thought I mentioned.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="philosophy" >
    Philosophy
</h3>
<ul>
	<li>
        <img src="assets/2026-01-07_13-45-11.png" width="400" >

	</li>
	<li>
		<p>
            This example class includes many of the types of things found in games, where the codebase has grown organically. It's common for the Player class to have lots of helper functions to make writing game code easier. Helper functions typically consider the Player as an instance in itself, from data in save through to rendering on screen. It's not unusual for the Player class to touch nearly every aspect of a game, as the human player is the target of the code in the first place, the Player class is going to reference nearly everything too.
		</p>
	</li>
	<li>
		<p>
            AI characters will have similarly gnarly looking classes if they are generalized rather than specialized. Specializing AI was more commonplace when games needed to fit in smaller machines, but now, because the Player class has to interact with many of them over the course of the game, they tend to be unified into one type just like the player, if not the same as the player, to help simplify the code that allows them to interact. As of writing, the way in which AI is differentiated is mostly by data, with behavior trees taking the main stage for driving how AI thinks about its world. Behavior trees are another concept subject to various interpretations, so some forms are data-oriented design friendly, and others are not.
		</p>
	</li>
	<li>
		<p>
            A recurring theme in articles and post-mortems from people moving from object-oriented hierarchies of gameplay classes to a component based approach is the transitional states of turning their classes into containers of smaller objects, an approach often called composition. This transitional form takes an existing class and finds the boundaries between concepts internal to the class and attempts to refactor them out into new classes which can be owned or pointed to by the original class. From our monolithic player class, we can see there are lots of things that are not directly related, but that does not mean they are not linked together.
		</p>
	</li>
	<li>
		<p>
            Object-oriented hierarchies are is-a relationships, and components and composition oriented designs are traditionally thought of as has-a relationships. Moving from one to the other can be thought of as delegating responsibility or moving away from being locked into what you are, but having a looser role and keeping the specialization until further down the tree. Composition clears up most of the common cases of diamond inheritance issues, as capabilities of the classes are added by accretion as much as they are added by overriding.
		</p>
	</li>
	<li>
		<p>
            The first move we need to make will be to take related pieces of our monolithic class and move them into their own classes, along the lines of composing, changing the class from owning all the data and the actions that modify the data into having instances which contain data and delegating actions down into those specialized structures where possible. We move the data out into separate structures so they can be more easily combined into new classes later. We will initially only separate by categories we perceive as being the boundaries between systems. For example, we separate rendering from controller input, from gameplay details such as inventory, and we split out animation from all.
		</p>
	</li>
	<li>
		<p>
            Taking a look at the results of splitting the player class up, such as in listing [*], it's possible to make some initial assessments of how this may turn out. We can see how a first pass of building a class out of smaller classes can help organize the data into distinct, purpose oriented collections, but we can also see the reason why a class ends up being a tangled mess. When you think about the needs of each of the pieces, what their data requirements are, the coupling can become evident. The rendering functions need access to the player's position as well as the model, and the gameplay functions such as Shoot(Vec target) need access to the inventory as well as setting animations and dealing damage. Taking damage will need access to the animations and health. Things are already seeming more difficult to handle than expected, but what's really happening here is that it's becoming clear that code needs to cut across different pieces of data. With just this first pass, we can start to see that functionality and data don't belong together.
		</p>
	</li>
	<li>
		<p>
            In this first step, we made the player class a container for the components. Currently, the player has the components, and the player class has to be instantiated to make a player exist. To allow for the cleanest separation into components in the most reusable way, it's worth attempting to move components into being managed by managers, and not handled or updated by their entities. In doing this, there will also be a benefit of cache locality when we're iterating over multiple entities doing related tasks when we move them away from their owners.
		</p>
	</li>
	<li>
		<p>
			<strong>
                This is where it gets a bit philosophical
			</strong>
            . Each system has an idea of the data it needs in order to function, and even though they will overlap, they will not share all data. Consider what it is that a serialization system needs to know about a character. It is unlikely to care about the current state of the animation system, but it will care about inventory. The rendering system will care about position and animation, but won't care about the current amount of ammo. The UI rendering code won't even care about where the player is, but will care about inventory and their health and damage. This difference of interest is at the heart of why 
			<strong>
                putting all the data in one class isn't a good long-term solution
			</strong>
            .
		</p>
	</li>
	<li>
		<p>
            The functionality of a class, or an object, comes from how the internal state is interpreted, and how the changes to state over time are interpreted too. 
			<strong>
                The relationship between facts is part of the problem domain and could be called meaning, but the facts are only raw data
			</strong>
            . This separation of fact from meaning is not possible with an object-oriented approach, which is why every time a fact acquires a new meaning, the meaning has to be implemented as part of the class containing the fact. Dissolving the class, extracting the facts and keeping them as separate components, has given us the chance to move away from classes that instill permanent meaning at the expense of occasionally having to look up facts via less direct methods. Rather than store all the possibly associated data by meaning, we choose to only add meaning when necessary. We add meaning when it is part of the immediate problem we are trying to solve.
		</p>
	</li>
</ul>
<h3
	id="relational-databases" >
    Relational Databases
</h3>
<ul>
	<li>
		<p>
            You certainly don't have to move your data to a database style to do data-oriented design, but there are many places where you will wish you had a simple array to work with.
		</p>
	</li>
	<li>
		<p>
            Edgar F. Codd proposed the relational model to handle the current and future needs of agents interacting with data. He proposed a solution to structuring data for insert, update, delete, and query operations. His proposal claimed to reduce the need to maintain a deep understanding of how the data was laid out to use it well. His proposal also claimed to reduce the likelihood of introducing internal inconsistencies. He introduced the fundamental terms of normalization we use to this day in a systematic approach to reducing the most complex of interconnected state information to linear lists of unique independent tuples.
		</p>
	</li>
	<li>
		<p>
            What we see here as we normalize our data is a tendency to split data by dependency. Looking at many third party engines and APIs, you can see some parallels with the results of these normalization. It's unlikely that the people involved in the design and evolution of these engines took their data and applied database normalization techniques,&nbsp;&nbsp;but sometimes the separations between object and components of objects can be obvious enough that you don't need a formal technique in order to realize some positive structural changes.
		</p>
	</li>
	<li>
		<p>
            In some games, the entity object is not just an object that can be anything, but is instead a specific subset of the types of entity involved in the game. For example, in one game there might be a class for the player character, and one for each major type of enemy character, and another for vehicles. The player may have different attributes to other entities, such as lacking AI controls, or having player controls, or having regenerating health, or having ammo. This object-oriented approach puts a line, invisible to the user, but intrusive to the developer, between classes of object and their instances. It is intrusive because when classes touch, they have to adapt to each other. When they don't reside in the same hierarchy, they have to work through abstraction layers to message each other. The amount of code required to bridge these gaps can be small, but they always introduce complexity.
		</p>
	</li>
	<li>
		<p>
            When developing software, this usually manifests as time spent writing out templated code that can operate on multiple classes rather than refactoring the classes involved into more discrete components. This could be considered wasted time as the likelihood of other operations needing to operate on all the objects is greater than zero,&nbsp;&nbsp;and the effort to refactor into components is usually similar to the effort to create a working templated operation.
		</p>
	</li>
	<li>
		<p>
            Without classes to define boundaries, the table-based approach levels the playing field for data to be manipulated together. In all cases on our journey through normalizing the level data, we have made it so changes to the design require fewer changes to the data, and made it so data changes are less likely to cause the state to become inconsistent. In many cases, it would seem we have added complexity when it wasn't necessary, and that's up to experimentation and experience to help you decide how far to go.
		</p>
	</li>
	<li>
		<p>
            We saw that sometimes adding new features required nothing more than adding a new table, or a new column to an existing table. That's a non-intrusive modification if you are using a database style of storage, but a significant change if you're adding a new member to a class.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-06_08-14-51.png" width="450" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-06_08-18-46.png" width="450" >
            .
		</p>
	</li>
</ul>
<h5
	id="what-should-be-a-column-what-should-be-a-component" >
    What should be a column / What should be a component
</h5>
<ul>
	<li>
		<p>
            It's not about the TYPE of the data, but how this data is PROCESSED.
		</p>
	</li>
	<li>
		<p>
            The granularity can be rooted in considering the data from the perspective of human perception.
		</p>
	</li>
	<li>
		<p>
            We use 
			<strong>
                meaningful boundary
			</strong>
            &nbsp;that gives us the our definition of atomicity for software developed for humans.
		</p>
	</li>
	<li>
		<p>
            Try to stay at the level of nouns, the nameable pieces.
		</p>
	</li>
	<li>
		<p>
			<em>
                Examples
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Grouping 
                    <code>timer.Timer</code>
                    &nbsp;might make sense, as all timers are processed the same, by just calling 
                    <code>timer.update(&t)</code>
                    &nbsp;on it.
				</p>
			</li>
			<li>
				<p>
                    Grouping 
                    <code>rd.Sprite</code>
                    &nbsp;might not make sense, as one sprite might not be &quot;processed&quot; with another sprite; in this case processed could mean changing it's position or drawing (the draw order can vary if applying Y-Sort).
				</p>
			</li>
			<li>
				<p>
                    Grouping 
                    <code>f32</code>
                    &nbsp;doesn't make sense, as the data is 
					<em>
                        so
					</em>
                    &nbsp;generic that doesn't tell us anything about how it should be processed.
				</p>
			</li>
			<li>
				<p>
                    A whole song can be an atom, but so is a single tick sound of a clock. A whole page of text is an atom, but so is the player's gamer-tag.
				</p>
			</li>
			<li>
				<p>
                    Adding sounds, textures, and meshes to this seems quite natural once you realize all these things are resources which if cut into smaller pieces begin to lose what it is that makes them what they are.
				</p>
			</li>
			<li>
				<p>
                    Half of a sentence is a lot less useful than a whole one, and loses integrity by disassociation. A slice of a sentence is clearly not reusable in any meaningful way with another random slice of a different sentence.
				</p>
			</li>
			<li>
				<p>
                    Think of raw assets (sounds, textures, vertex buffers, etc.) as primitives, much like the integers, floating point numbers, strings and boolean values.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="operations" >
    Operations
</h5>
<ul>
	<li>
		<p>
            When you use objects, you call methods on them, so how do you unlock a door in this table-based approach? Actions are always going to be insert, delete, or updates. These were clearly specified in Edgar F. Codd's works, and they are all you need to manipulate a relational model.
		</p>
	</li>
	<li>
		<p>
            In a real database, finding what mesh to load, or whether a door is locked would normally require a join between tables. A real database would also attempt to optimize the join by changing the sequence of operations until it had made the smallest possible expected workload. We can do better than that because we can take absolute charge of how we look at and request data from our tables. To find out if a door is locked, we don't need to join tables, we know we can look up into the locked doors table directly. Just because the data is laid out like a database, doesn't mean we have to use a query language to access it.
		</p>
	</li>
	<li>
		<p>
            When it comes to operations that change state, it's best to try to stick to the kind of operation you would normally find in a DBMS, as doing unexpected operations brings unexpected state complexity. For example, imagine you have a table of doors that are open, and a table of doors that are closed. Moving a door from one table might be considered wasteful, so you may consider changing the representation to a single table, but with all closed doors at one end, and all open at the other. By having both tables represented as a single table, and having the isClosed attribute defined implicitly by a cut-off point in the array, such as in listing [*], leads to the table being somewhat ordered. This type of memory optimization comes at a price. Introducing order into a table makes the whole table inherently less parallelizable to operations, so beware the additional complexity introduced by making changes like this, and document them well.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-07_08-44-54.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            Unlocking a door can be a delete. A door is locked because there is an entry in the LockedDoors table that matches the Door you are interested in. Unlocking a door is a delete if door matches, and you have the right key.
		</p>
	</li>
	<li>
		<p>
            The player inventory would be a table with just PickupIDs. This is the idea that &quot;the primary key is also the data&quot; mentioned much earlier. If the player enters a room and picks up a Pickup, then the entry matching the room is deleted while the inventory is updated to include the new PickupID.
		</p>
	</li>
	<li>
		<p>
            Databases have the concept of triggers, where operations on a table can cause cascades of further operations. In the case of picking up a key, we would want a trigger on insert into the inventory that joins the new PickupID with the LockedDoors table. For each matching row, delete it, and now the door is unlocked.
		</p>
	</li>
</ul>
<h3
	id="stream-processing-no-global-memory" >
    Stream Processing (no global memory)
</h3>
<ul>
	<li>
		<p>
            Stream processing means to process data without writing to variables external to the process. This means not allowing things like global accumulators, or accessing global memory not set as a source for the process. This ensures the processes or transforms are trivially parallelizable.
		</p>
	</li>
	<li>
		<p>
            When you prepare a primitive render for a graphics card, you set up constants such as the transform matrix, the texture binding, any lighting values, or which shader you want to run. When you come to run the shader, each vertex and pixel may have its own scratchpad of local variables, but they never write to globals or refer to a global scratchpad. The concept of shared memory in general purpose GPU code, such as CUDA and OpenCL, allows the use of a kind of managed cache. None of the GPGPU techniques offer access to global memory, and thus maintain a clear separation of domains and continue to guarantee no side-effects caused by any kernels being run outside of their own sandboxed shared memory. By enforcing this lack of side-effects, we can guarantee trivial parallelism because the order of operations are assured to be irrelevant. If a shader was allowed to write to globals, there would be locking, or it would become an inherently serial operation. Neither of these are good for massive core count devices like graphics cards, so that has been a self imposed limit and an important factor in their design. Adding shared memory to the mix starts to inject some potential locking into the process, and hence is explicitly only used when writing compute shaders.
		</p>
	</li>
	<li>
		<p>
            Doing all processing this way, without globals / global scratchpads, gives you the rigidity of intention to highly parallelize your processing and make it easier to think about the system, inspect it, debug it, and extend it or interrupt it to hook in new features. If you know the order doesn't matter, it's very easy to rerun any tests or transforms that have caused bad state.
		</p>
	</li>
</ul>
<h3
	id="ownership" >
    Ownership
</h3>
<ul>
	<li>
		<p>
            Where once we would have an object instance for an area in a game, and we would interrogate it for exits that take us to other areas, now we look into a structure that only contains links between areas, and filter by the area we are in. This reversal of ownership can be a massive benefit in debugging, but can sometimes appear backward when all you want to do is find out what exits are available to get out of an area.
		</p>
	</li>
</ul>
<h3
	id="existential-processing" >
    Existential processing
</h3>
<ul>
	<li>
		<p>
            Attempts to provide a way to remove unnecessary querying about whether or not to process your data. In most software, there are checks for NULL and queries to make sure the objects are in a valid state before work is started. What if you could always guarantee your pointers were not null? What if you were able to trust that your objects were in a valid state, and should always be processed?
		</p>
	</li>
	<li>
		<p>
            If you use existential processing techniques, your classes defined by the tables they belong to, then you can switch between tables at runtime.
		</p>
	</li>
</ul>
<h3
	id="enums" >
    Enums
</h3>
<ul>
	<li>
		<p>
            The reason why you would put an enum in table form, is to reduce control flow impact. Given this, it's when we aren't using the enumerations to control instruction flow that it's fine to leave them alone. Another possibility is when the value of the enum changes with great frequency, as moving objects from table to table has a cost too.
		</p>
	</li>
	<li>
		<p>
            Enumerations are used to define sets of states. We could have had a state variable for the regenerating entity, one that had 
            <code>in_full_health</code>
            , 
            <code>is_hurt</code>
            , 
            <code>is_dead</code>
            &nbsp;as its three states. We could have had a team index variable for the avoidance entity enumerating all the available teams. Instead, we used tables to provide all the information we needed, as there were only two teams. Any enum can be emulated with a variety of tables. All you need is one table per enumerable value. Setting the enumeration is an insert into a table or a migration from one table to another.
		</p>
	</li>
	<li>
		<p>
            When using tables to replace enums, some things become more difficult: finding out the value of an enum in an entity is difficult as it requires checking all the tables which represent that state for the entity. However, the main reason for getting the value is either to do an operation based on an external state or to find out if an entity is in the right state to be considered for an operation. This is disallowed and unnecessary for the most part, as firstly, accessing external state is not valid in a pure function, and secondly, any dependent data should already be part of the table element.
		</p>
	</li>
	<li>
		<p>
            If the enum is a state or type enum previously handled by a switch or virtual call, then we don't need to look up the value, instead, we change the way we think about the problem. The solution is to run transforms taking the content of each of the switch cases or virtual methods as the operation to apply to the appropriate table, the table corresponding to the original enumeration value.
		</p>
	</li>
	<li>
		<p>
            If the enum is instead used to determine whether or not an entity can be operated upon, such as for reasons of compatibility, then consider an auxiliary table to represent being in a compatible state. If you're thinking about the case where you have an entity as the result of a query and need to know if it is in a certain state before deciding to commit some changes,&nbsp;&nbsp;consider that the compatibility you seek could have been part of the criteria for generating the output table in the first place, or a second filtering operation could be committed to create a table in the right form.
		</p>
	</li>
	<li>
		<p>
            Examples of enumerations that make sense are keybindings, enumerations of colors, or good names for small finite sets of values. Functions that return enums, such as collision responses (none, penetrating, through). Any kind of enumeration which is actually a lookup into data of another form is good, where the enum is being used to rationalize the access to those larger or harder to remember data tables. There is also a benefit to some enums in that they will help you trap unhandled cases in switches, and to some extent, they are a self-documenting feature in most languages.
		</p>
	</li>
</ul>
<h3
	id="polymorphism" >
    Polymorphism
</h3>
<ul>
	<li>
		<p>
            Let's consider now how we implement polymorphism. We know we don't have to use a virtual table pointer; we could use an enum as a type variable. That variable, the member of the structure that defines at runtime what that structure should be capable of and how it is meant to react. That variable will be used to direct the choice of functions called when methods are called on the object.
		</p>
	</li>
	<li>
		<p>
            When your type is defined by a member type variable, it's usual to implement virtual functions as switches based on that type, or as an array of functions. If we want to allow for runtime loaded libraries, then we would need a system to update which functions are called. The humble switch is unable to accommodate this, but the array of functions could be modified at runtime.
		</p>
	</li>
	<li>
		<p>
            We have a solution, but it's not elegant, or efficient. The data is still in charge of the instructions, and we suffer the same instruction cache misses and branch mispredictions as whenever a virtual function is unexpected. However, when we don't really use enums,&nbsp;&nbsp;but instead tables that represent each possible value of an enum,&nbsp;&nbsp;it is still possible to keep compatible with dynamic library loading the same as with pointer based polymorphism, but we also gain the efficiency of a data-flow processing approach to processing heterogeneous types.
		</p>
	</li>
	<li>
		<p>
            For each class, instead of a class declaration, we have a factory that produces the correct selection of table insert calls. Instead of a polymorphic method call, we utilize existential processing. Our elements in tables allow the characteristics of the class to be implicit. Creating your classes with factories can easily be extended by runtime loaded libraries. Registering a new factory should be simple as long as there is a data-driven factory method. The processing of the tables and their update() functions would also be added to the main loop.
		</p>
	</li>
	<li>
		<p>
            If you create your classes by composition, and you allow the state to change by inserting and removing from tables, then you also allow yourself access to dynamic runtime polymorphism. This is a feature normally only available when dynamically responding via a switch.
		</p>
	</li>
	<li>
		<p>
            Polymorphism is the ability for an instance in a program to react to a common entry point in different ways due only to the nature of the instance. In C++, compile-time polymorphism can be implemented through templates and overloading. Runtime polymorphism is the ability for a class to provide a different implementation for a common base operation with the class type unknown at compile-time. C++ handles this through virtual tables, calling the right function at runtime based on the type hidden in the virtual table pointer at the start of the memory pointed to by the this pointer. Dynamic runtime polymorphism is when a class can react to a common call signature in different ways based on its type, but its type can change at runtime. C++ doesn't implement this explicitly, but if a class allows the use of an internal state variable or variables, it can provide differing reactions based on the state as well as the core language runtime virtual table lookup. Other languages which define their classes more fluidly,&nbsp;&nbsp;such as Python, allow each instance to update how it responds to messages, but most of these languages have very poor general performance as the dispatch mechanism has been built on top of dynamic lookup.
		</p>
	</li>
</ul>
<h3
	id="events" >
    Events
</h3>
<ul>
	<li>
		<p>
            Using your existence in a table as the registration technique makes this simpler than before and lets you register and de-register with great pace. Subscription becomes an insert, and unsubscribing a delete. It's possible to have global tables for subscribing to global events. It would also be possible to have named tables. Named tables would allow a subscriber to subscribe to events before the publisher exists.
		</p>
	</li>
</ul>
<h3
	id="soa" >
    SOA
</h3>
<ul>
	<li>
		<p>
            It is okay to keep hot and cold data side by side in an SoA object as data is pulled into the cache by necessity rather than by accidental physical location.
		</p>
	</li>
	<li>
		<p>
            Database technology was here first. In DBMS terms, it's called column-oriented databases and they provide better throughput for data processing over traditional row-oriented relational databases simply because irrelevant data is not loaded when doing column aggregations or filtering.
		</p>
	</li>
	<li>
		<p>
            For getting the &quot;average age of a population&quot;:
		</p>
		<ul>
			<li>
                <img src="assets/2026-01-04_17-41-27.png" width="250" >

			</li>
			<li>
                <img src="assets/2026-01-04_17-42-03.png" width="250" >

			</li>
		</ul>
	</li>
	<li>
        <img src="assets/2026-01-04_17-40-22.png" width="250" >

	</li>
	<li>
		<p>
			<a
				href="https://odin-lang.org/docs/overview/#soa-data-types" 
				class="external-link" 
				target="_blank" >
                Odin - SOA Data Types
			</a>
            .
		</p>
	</li>
</ul>
<h2
	id="sources" >
    Sources
</h2>
<ul>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=SofC6c9xQv4" 
				class="external-link" 
				target="_blank" >
                Rust Auckland - Azriel: ECS: A Programming Paradigm
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Really good video for explaining the general theory behind ECS, but then falls short when it comes to implementation and Rust things.
				</p>
			</li>
			<li>
				<p>
                    I didn't like the video after {31:00}, as it went for an implementation with Rust and I though it was very confusing.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="bitsquid-engine-building-a-data-oriented-entity-system" >
    Bitsquid Engine - Building a Data-Oriented Entity System
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://bitsquid.blogspot.com/2014/08/building-data-oriented-entity-system.html" 
				class="external-link" 
				target="_blank" >
                pt1
			</a>
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://bitsquid.blogspot.com/2014/09/building-data-oriented-entity-system.html" 
				class="external-link" 
				target="_blank" >
                pt2
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://bitsquid.blogspot.com/2014/10/building-data-oriented-entity-system.html" 
				class="external-link" 
				target="_blank" >
                pt3
			</a>
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://bitsquid.blogspot.com/2014/10/building-data-oriented-entity-system_10.html" 
				class="external-link" 
				target="_blank" >
                pt4
			</a>
            .
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">const unsigned ENTITY_INDEX_BITS = 22;
const unsigned ENTITY_INDEX_MASK = (1&lt;&lt;ENTITY_INDEX_BITS)-1;

const unsigned ENTITY_GENERATION_BITS = 8;
const unsigned ENTITY_GENERATION_MASK = (1&lt;&lt;ENTITY_GENERATION_BITS)-1;

struct Entity
{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned id;

&nbsp;&nbsp;&nbsp;&nbsp;unsigned index() const {return id & ENTITY_INDEX_MASK;}
&nbsp;&nbsp;&nbsp;&nbsp;unsigned generation() const {return (id &gt;&gt; ENTITY_INDEX_BITS) & ENTITY_GENERATION_MASK;}
};

class EntityManager
{
&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;unsigned char&gt; _generation;
&nbsp;&nbsp;&nbsp;&nbsp;Deque&lt;unsigned&gt; _free_indices;

&nbsp;&nbsp;&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;&nbsp;Entity create() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned idx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (_free_indices.size() &gt; MINIMUM_FREE_INDICES) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx = _free_indices.front();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_free_indices.pop_front();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_generation.push_back(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx = _generation.size() - 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XENSURE(idx &lt; (1 &lt;&lt; ENTITY_INDEX_BITS));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return make_entity(idx, _generation[idx]);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;bool alive(Entity e) const {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _generation[e.index()] == e.generation();
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;void destroy(Entity e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned idx = e.index();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++_generation[idx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_free_indices.push_back(idx);
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
<ul>
	<li>
		<p>
            The idea here is that the index part directly gives us the index of the entity in a lookup array.
		</p>
		<ul>
			<li>
				<p>
                    The generation part is used to distinguish entities created at the same index slot. As we create and destroy entities we will at some point have to reuse an index in the array. By changing the generation value when that happens we ensure that we still get a unique ID.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In our system we are restricted to using 30 bits for the entity ID. We steal two bits from this pointer in order to distinguish it from other types of light userdata that we use in the engine.
		</p>
		<ul>
			<li>
				<p>
                    We've split up our 30 bits into 22 bits for the index and 8 bits for the generation. This means that we support a maximum of 4 million simultaneous entities. It also means that we can only distinguish between 256 different entities created at the same index slot. If more than 256 entities are created at the same index slot, the generation value will wrap around and our new entity will get the same ID as an old entity.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            A nice thing about only having 8 bits in generation is that we just need 8 bits per entity in our lookup array. This saves memory, but also gives us better performance, since we will fit more in the cache.
		</p>
	</li>
	<li>
		<p>
            Component:
		</p>
	</li>
	<li>
		<p>
            Components in our system are not individual objects, instead all components of a particular type are handled by a component manager for that type. The component manager has full control over how the component data is stored internally and how updates are applied.
		</p>
	</li>
	<li>
		<p>
            It is perhaps not self-evident why we want to store the entity that owns the component, but it will come in handy later.
		</p>
	</li>
	<li>
		<p>
            Component Manager:
		</p>
	</li>
	<li>
		<p>
            The task of a ComponentManager is to associate entities with components. It is up to the component manager to decide if it makes sense for an entity to have multiple components of its type.
		</p>
	</li>
	<li>
		<p>
            There is no place where we keep a list of all the components that an entity has. This is only defined by what has been registered with the different component managers in the game.
		</p>
	</li>
	<li>
		<p>
            When considering how we should layout the data in the component manager we have two goals:
		</p>
		<ul>
			<li>
				<p>
                    Given an entity we want to be able to quickly look up the component data for that entity.
				</p>
			</li>
			<li>
				<p>
                    We want the component data to be packed tightly in memory for good cache performance.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">class PointMassComponentManager {
&nbsp;&nbsp;&nbsp;&nbsp;struct InstanceData {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Entity&gt; entity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;float&gt; mass;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Vector3&gt; position;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Vector3&gt; velocity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&lt;Vector3&gt; acceleration;
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;InstanceData _data;
};
</code></pre>
<ul>
	<li>
		<p>
            That works well enough, but it does mean that the data gets stored in five separately allocated memory buffers.
		</p>
	</li>
	<li>
		<p>
            I use a different approach. I allocate the entire memory buffer as a single allocation and then just let entity, mass, etc, point to different parts of that buffer:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">class PointMassComponentManager {
&nbsp;&nbsp;&nbsp;&nbsp;struct InstanceData {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&lt; Number of used instances.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned allocated;&nbsp;&nbsp;///&lt; Number of allocated instances.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *buffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&lt; Buffer with instance data.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entity *entity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float *mass;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 *position;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 *velocity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 *acceleration;
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;InstanceData _data;

&nbsp;&nbsp;&nbsp;&nbsp;void allocate(unsigned sz)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(sz &gt; _data.n);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstanceData new_data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned bytes = sz * (sizeof(Entity) + sizeof(float) +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 * sizeof(Vector3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.buffer = _allocator.allocate(bytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.n = _data.n;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.allocated = sz;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.entity = (Entity *)(new_data.buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.mass = (float *)(new_data.entity + sz);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.position = (Vector3 *)(new_data.mass + sz);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.velocity = new_data.position + sz;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_data.acceleration = new_data.velocity + sz;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.entity, _data.entity, _data.n * sizeof(Entity));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.mass, _data.mass, _data.n * sizeof(float));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.position, _data.position, _data.n * sizeof(Vector3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.velocity, _data.velocity, _data.n * sizeof(Vector3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_data.acceleration, _data.acceleration,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data.n * sizeof(Vector3));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_allocator.deallocate(_data.buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data = new_data;
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre>
<ul>
	<li>
		<p>
            This avoids any hidden overheads that might exist in the Array class and we only have a single allocation to keep track of. This is better both for the cache and the memory allocation system`.
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">
Array&lt;unsigned&gt; _map;
</code></pre>
<ul>
	<li>
		<p>
            Here, the 
            <code>_map</code>
            &nbsp;allows us to look up a component index based on the entity index.
            <br>
            This is a lot better, because now it is just the _map array that has holes, not the _data array, which means that the holes are fewer and smaller. Still, I would only use this if I was certain that the component was almost universal and that lookups where performance critical. In most cases, I think a hash index is a better approach:
		</p>
	</li>
</ul>
<pre><code class="language-cpp" data-lang="cpp">HashMap&lt;Entity, unsigned&gt; _map;
</code></pre>
<ul>
	<li>
		<p>
            This uses less memory and lookups are still pretty fast.
		</p>
	</li>
	<li>
		<p>
            Update:
		</p>
		<ul>
			<li>
				<p>
                    Since the component data is laid out sequentially in memory, writing a function that simulates physics for all entities is simple:
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">void simulate(float dt)
{
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;_data.n; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data.velocity[i] += _data.acceleration[i] * dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data.position[i] += _data.velocity[i] * dt;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
		<ul>
			<li>
				<p>
                    This function traverses memory in-order which gives us good cache performance. Itâ€™s also easy to profile, vectorize and parallelize, should the need arise.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Destroy:
		</p>
		<ul>
			<li>
				<p>
                    When destroying components, we want to make sure that we keep the 
                    <code>_data</code>
                    &nbsp;array tightly packed. We can achieve that by moving the last element to the position of the component we want to remove. We must also update the 
                    <code>_map</code>
                    &nbsp;entry for the corresponding entity.
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">void destroy(unsigned i)
{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned last = _data.n - 1;
&nbsp;&nbsp;&nbsp;&nbsp;Entity e = _data.entity[i];
&nbsp;&nbsp;&nbsp;&nbsp;Entity last_e = _data.entity[last];

&nbsp;&nbsp;&nbsp;&nbsp;_data.entity[i] = _data.entity[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.mass[i] = _data.mass[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.position[i] = _data.position[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.velocity[i] = _data.velocity[last];
&nbsp;&nbsp;&nbsp;&nbsp;_data.acceleration[i] = _data.acceleration[last];

&nbsp;&nbsp;&nbsp;&nbsp;_map[last_e] =&nbsp;&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;_map.erase(e);

&nbsp;&nbsp;&nbsp;&nbsp;--_n;
}
</code></pre>
		<ul>
			<li>
				<p>
                    Another question is how we handle destruction of components when an entity is destroyed. As you may recall, the entity does not have an explicit list of components that it owns. Also, it seems onerous to require of the user of the API to manually destroy the right components when the entity dies.
				</p>
			</li>
			<li>
				<p>
                    Components that need to be destroyed immediately (perhaps because they hold external resources) can register a destruction callback with the EntityManager and that callback will be called when the entity is destroyed.
				</p>
			</li>
			<li>
				<p>
                    However, for simpler components, like the point mass component, there is nothing that require components to be destroyed at exactly the same time as the entity. We can take advantage of that and use garbage collection to lazily destroy components instead of spending memory and effort on storing callback lists:
				</p>
			</li>
		</ul>
<pre><code class="language-cpp" data-lang="cpp">void gc(const EntityManager &em)
{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned alive_in_row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while (_data.n &gt; 0 && alive_in_row &lt; 4) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned i = random_in_range(0, _data.n - 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (em.alive(_data.entity[i])) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++alive_in_row;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alive_in_row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy(i);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
	</li>
</ul>
<h5
	id="mach-engine-lets-build-ecs-in-zig" >
    <s>Mach Engine - Let's Build ECS in Zig</s>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://devlog.hexops.com/2022/lets-build-ecs-part-1/" 
				class="external-link" 
				target="_blank" >
                pt1
			</a>
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://devlog.hexops.com/2022/lets-build-ecs-part-2-databases/" 
				class="external-link" 
				target="_blank" >
                pt2
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Mentioned ECS in Bevy as a great source, but now &quot;further simplified&quot;.
		</p>
	</li>
	<li>
		<p>
            There's a lot of 'method' usage, classes, etc. Not a pretty code.
		</p>
	</li>
	<li>
		<p>
            Seems to have used solely archetypes.
		</p>
	</li>
	<li>
		<p>
            Zig code is not great to look at; very OOP-ed.
		</p>
	</li>
</ul>
<pre><code class="language-zig" data-lang="zig">pub const Entities = struct {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;// Returns a new entity.
&nbsp;&nbsp;&nbsp;&nbsp;pub fn new(entities: *Entities) !EntityID {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const new_id = entities.counter;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entities.counter += 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new_id;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub inline fn archetypeByID(entities: *Entities, entity: EntityID) *ArchetypeStorage {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ptr = entities.entities.get(entity).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &entities.archetypes.values()[ptr.archetype_index];
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn getComponent(entities: *Entities, entity: EntityID, name: []const u8, comptime Component: type) ?Component {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var archetype = entities.archetypeByID(entity);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var component_storage_erased = archetype.components.get(name) orelse return null;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ptr = entities.entities.get(entity).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var component_storage = ErasedComponentStorage.cast(component_storage_erased.ptr, Component);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return component_storage.get(ptr.row_index);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;pub fn setComponent(entities: *Entities, entity: EntityID, name: []const u8, component: anytype) !void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var archetype = entities.archetypeByID(entity);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const old_hash = archetype.hash;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var have_already = archetype.components.contains(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const new_hash = if (have_already) old_hash else old_hash ^ std.hash_map.hashString(name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var archetype_entry = try entities.archetypes.getOrPut(entities.allocator, new_hash);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!archetype_entry.found_existing) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;archetype_entry.value_ptr.* = ArchetypeStorage{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.allocator = entities.allocator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.components = .{},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.hash = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var new_archetype = archetype_entry.value_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var column_iter = archetype.components.iterator();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (column_iter.next()) |entry| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var erased: ErasedComponentStorage = undefined;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry.value_ptr.cloneType(entry.value_ptr.*, &new_archetype.entity_ids.items.len, entities.allocator, &erased) catch ...;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_archetype.components.put(entities.allocator, entry.key_ptr.*, erased) catch ...;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create storage/column for the new component.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const erased = entities.initErasedStorage(&new_archetype.entity_ids.items.len, @TypeOf(component)) catch ...;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_archetype.components.put(entities.allocator, name, erased) catch ...;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_archetype.calculateHash();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var current_archetype_storage = archetype_entry.value_ptr;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_hash == old_hash) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ptr = entities.entities.get(entity).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try current_archetype_storage.set(ptr.row_index, name, component);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const new_row = try current_archetype_storage.new(entity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const old_ptr = entities.entities.get(entity).?;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var column_iter = archetype.components.iterator();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (column_iter.next()) |entry| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var old_component_storage = entry.value_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var new_component_storage = current_archetype_storage.components.get(entry.key_ptr.*).?;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_component_storage.copy(new_component_storage.ptr, entities.allocator, new_row, old_ptr.row_index, old_component_storage.ptr) catch |err| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.undoNew();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.entity_ids.items[new_row] = entity;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.set(new_row, name, component) catch |err| {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_archetype_storage.undoNew();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;};
};

// Represents the storage for a single type of component within a single type of entity.
// Database equivalent: a column within a table.
pub fn ComponentStorage(comptime Component: type) type {
&nbsp;&nbsp;&nbsp;&nbsp;return struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A reference to the total number of entities with the same type as is being stored here.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_rows: *usize,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The actual densely stored component data.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: std.ArrayListUnmanaged(Component) = .{},

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Self = @This();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pub fn deinit(storage: *Self, allocator: Allocator) void {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage.data.deinit(allocator);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;};
}

const ptr: Pointer = entities.entities.get(entity_id).?;
var archetype = entities.archetypes.entries.get(ptr.archetype_index);

test "ecs" {
&nbsp;&nbsp;&nbsp;&nbsp;...

&nbsp;&nbsp;&nbsp;&nbsp;const Location = struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x: f32 = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y: f32 = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z: f32 = 0,
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;try world.setComponent(player, "Name", "jane"); // add Name component
&nbsp;&nbsp;&nbsp;&nbsp;try world.setComponent(player, "Location", Location{}); // add Location component
&nbsp;&nbsp;&nbsp;&nbsp;try world.setComponent(player, "Name", "joe"); // update Name component
}
</code></pre>
<h5
	id="bevy-engine-ecs" >
    <s>Bevy Engine - ECS</s>
</h5>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            https://bevy.org/learn/quick-start/getting-started/ecs/
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<a
				href="https://github.com/bevyengine/bevy/blob/v0.14.0/examples/ecs/ecs_guide.rs" 
				class="external-link" 
				target="_blank" >
                ECS demo in Bevy
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            it's terrible trying to understand anything inside a rust code....
		</p>
	</li>
</ul>
<h5
	id="godot-why-isnt-ecs-based" >
    Godot - Why isn't ECS-based?
</h5>
<ul>
	<li>
		<p>
            TLDR:
		</p>
		<ul>
			<li>
				<p>
                    &quot;Godot as an engine tries to take the burden of 
					<em>
                        processing
					</em>
                    &nbsp;away from the user, and instead places the focus on 
					<em>
                        deciding
					</em>
                    &nbsp;what to do in case of an event. This ensures users have to optimize 
					<em>
                        less
					</em>
                    &nbsp;in order to write much of the game code, and is part of the vision Godot conveys about what should constitute an 
					<em>
                        easy to use game engine
					</em>
                    &quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://godotengine.org/article/why-isnt-godot-ecs-based-game-engine/" 
				class="external-link" 
				target="_blank" >
                Why isn't Godot an ECS-based game engine?
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            ECS is a design pattern commonly used in video games (although not very common in the rest of the software industry) which consists of having a base Entity (a container object) and Components that can be added upon it. Components provide data and the means to interact with the whole world. Finally, Systems work independently and act on every similar component.
		</p>
	</li>
	<li>
		<p>
            This design became common in game engines and libraries in the early 2010s. The main appeal (besides architecture) is that component data can be placed in contiguous memory, improving cache access.
		</p>
	</li>
	<li>
		<p>
            This is a common form of 
			<a
				href="https://en.wikipedia.org/wiki/Data-oriented_design" 
				class="external-link" 
				target="_blank" >
                data-oriented
			</a>
            &nbsp;optimization.
		</p>
	</li>
	<li>
		<p>
            Architecturally, ECS aims to replace 
			<a
				href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" 
				class="external-link" 
				target="_blank" >
                inheritance
			</a>
            , by favoring composition, similar to how 
			<em>
                interfaces
			</em>
            &nbsp;or 
			<em>
                multiple inheritance
			</em>
            &nbsp;works in OOP.
		</p>
	</li>
	<li>
		<p>
            The key advantage in ECS is that components are 
			<em>
                dynamic
			</em>
            &nbsp;(can be added or removed at runtime).
		</p>
	</li>
	<li>
		<p>
            Godot does composition at a higher level than in a traditional ECS.
		</p>
	</li>
	<li>
		<p>
            One of the biggest advantages of ECS is the Systems (data-oriented) part, which allows running through a lot of similar components' data organized in linear memory.
		</p>
		<ul>
			<li>
				<p>
                    This brings huge performance improvements over the way Godot works with nodes.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Most (if not all) technologies that utilize ECS do it at the core engine level, by serving as the base architecture and building everything else (physics, rendering, audio, etc.) over it.
		</p>
	</li>
	<li>
		<p>
            Godot instead keeps those subsystems separate and isolated (and they fit inside of 
			<a
				href="https://godotengine.org/article/why-does-godot-use-servers-and-rids" 
				class="external-link" 
				target="_blank" >
				<em>
                    Servers
				</em>
			</a>
            ).
		</p>
		<ul>
			<li>
				<p>
                    I find this makes code simpler and easier to maintain and optimize.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            To put it simply, nodes are just interfaces to the actual data being processed inside servers, while in ECS the actual entities are what gets processed by the systems.
		</p>
		<ul>
			<li>
				<p>
                    As I understood it: Nodes seem to create a layer of abstraction over Systems, because they are very low-level.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In other words, Godot as an engine tries to take the burden of 
			<em>
                processing
			</em>
            &nbsp;away from the user, and instead places the focus on 
			<em>
                deciding
			</em>
            &nbsp;what to do in case of an event. This ensures users have to optimize 
			<em>
                less
			</em>
            &nbsp;in order to write much of the game code, and is part of the vision Godot conveys about what should constitute an 
			<em>
                easy to use game engine
			</em>
            .
		</p>
	</li>
	<li>
		<p>
            These are generally games that need to process game logic on dozens of thousands of objects, where data-oriented optimizations become necessary, as the amount of pages moved into CPU cache increases by several orders of magnitude, severely affecting performance (and battery usage on mobile devices).
		</p>
		<ul>
			<li>
				<p>
                    City builders (lots of things going on).
				</p>
			</li>
			<li>
				<p>
                    Sandboxes (lots of tiny things need processing every frame).
				</p>
			</li>
			<li>
				<p>
                    Some strategy games (while not the majority, some can use thousands or tens of thousands of units at the same time).
				</p>
			</li>
			<li>
				<p>
                    Other AAA games with lots of content going on.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="entity" >
    Entity
</h2>
<ul>
	<li>
		<p>
            Mach:
		</p>
		<ul>
			<li>
				<p>
                    A unique integer
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Bevy:
		</p>
		<ul>
			<li>
				<p>
                    A collection of components with a unique id.
				</p>
			</li>
			<li>
				<p>
                    <code>Entity1 { Name("Alice"), Position(0, 0) }</code>
				</p>
			</li>
			<li>
				<p>
                    <code>Entity2 { Name("Bill"), Position(10, 5) }</code>
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            An entity is a unique identifier (usually a number or an ID) that represents a &quot;thing&quot; in the system, like a character, object, or actor in a game or simulation.
		</p>
	</li>
	<li>
		<p>
            Entities are simple identifiers and do not have behavior or data directly attached to them. They merely aggregate components.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Ex
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In a game, a player, an enemy, a bullet, or a tree can be represented as entities.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="component" >
    Component
</h2>
<ul>
	<li>
		<p>
            A truly component based object is nothing more than the sum of its parts. This means the definition of a component based object is also nothing more than an inventory with some construction arguments. This object or definition agnostic approach makes refactoring and redesigning a much simpler exercise.
		</p>
	</li>
	<li>
		<p>
            When you introduce component based entities, you have an opportunity to turn the idea of how you define an object on its head. The normal approach to defining an object in object-oriented design is to name it, then fill out the details as and when they become necessary. For example, your car object is defined as a Car,&nbsp;&nbsp;if not extending Vehicle, then at least including some data about what physics and meshes are needed, with construction arguments for wheels and body shell model assets etc, possibly changing class dependent on whether it's an AI or player car. In component-oriented design, objects aren't so rigidly defined, and don't so much become defined after they are named, as much as a definition is selected or compiled, and then tagged with a name if necessary. For example, instancing a physics component with four-wheel physics,&nbsp;&nbsp;instancing a renderable for each part (wheels,&nbsp;&nbsp;shell, suspension) adding an AI or player component to control the inputs for the physics component, all adds up to something which we can tag as a Car, or leave as is and it becomes something implicit rather than explicit and immutable.
		</p>
	</li>
</ul>
<h3
	id="storage-models" >
    Storage Models
</h3>
<ul>
	<li>
		<p>
			<em>
                Problem
			</em>
            :
		</p>
		<ul>
			<li>
                <img src="assets/2026-01-04_17-48-21.png" width="350" >

			</li>
			<li>
				<p>
                    In this case, it's used an 
                    <code>union</code>
                    , so the data can be either a value or nil.
				</p>
			</li>
			<li>
				<p>
                    There are a lot of empty spots inside those vectors, causing memory bloat; the data is not tightly packed.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Frameworks
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Entt uses a sparse set ECS, Flecs uses archetypes&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<p
	class="table" >
    | Strategy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Iteration | Removal | Complexity |
    <br>
    | -------------- | --------- | ------- | ---------- |
    <br>
    | Sparse Set&nbsp;&nbsp;&nbsp;&nbsp; | Fast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| O(1)&nbsp;&nbsp;&nbsp;&nbsp;| Medium&nbsp;&nbsp;&nbsp;&nbsp; |
    <br>
    | Archetype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Fastest&nbsp;&nbsp; | Medium&nbsp;&nbsp;| High&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
</p>
<h5
	id="sparse-set" >
    Sparse Set
</h5>
<ul>
	<li>
		<p>
            Sparse-sets organize data by component type (one dense array per component + a sparse entityâ†’index table).
		</p>
	</li>
	<li>
		<p>
            Make structural changes cheap and queries flexible.
		</p>
	</li>
	<li>
		<p>
            Manage components individually, using a dense array for each component type and a sparse array for existence checks. It's generally better in scenarios where components are added or removed frequently because you don't need to move all components an entity has, but iteration is more expensive as it requires checks to ensure each entity has the requested components.
		</p>
	</li>
	<li>
		<p>
            Splits one list into a Sparse List and a Dense List.
		</p>
	</li>
	<li>
		<p>
            We don't care about the cache friendliness of the Sparse List, only for the Dense List.
		</p>
	</li>
	<li>
		<p>
            Dense List:
		</p>
		<ul>
			<li>
				<p>
                    Contains the actual component data.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Sparse List:
		</p>
		<ul>
			<li>
				<p>
                    It's what maps its Entity ID to its corresponding Dense List index.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-08_09-05-11.png" width="500" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-04_18-02-35.png" width="300" >
            .
		</p>
	</li>
	<li>
        <img src="assets/2026-01-07_13-59-07.png" width="600" >

	</li>
	<li>
		<p>
            It's also possible to use the Sparse List as a HashMap:
		</p>
		<ul>
			<li>
				<p>
                    <img src="assets/2026-01-04_18-03-02.png" width="300" >
                    .
				</p>
			</li>
			<li>
				<p>
                    This has trade-offs in performance, depending on the amount of entities there are stored.
				</p>
			</li>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=yyZMoE1FAJ0" 
						class="external-link" 
						target="_blank" >
                        Cient video
					</a>
                    : &quot;For what I've seem, the HashMap is usually faster for fewer entities (100), but a sparse list with Pagination is faster with a higher entity count (100k)&quot;.
				</p>
			</li>
		</ul>
	</li>
</ul>
<pre><code class="language-odin" data-lang="odin">Component :: struct($T: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp;sparse: [COMPONENT_MAX_ENTITIES]Maybe(u32), // Maybe(dense_idx) = sparse[ent]
&nbsp;&nbsp;&nbsp;&nbsp;dense:&nbsp;&nbsp;[dynamic]Entity_ID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ent = dense[dense_idx]
&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;&nbsp; [dynamic]T,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // T = data[dense_idx]
}
</code></pre>
<ul>
	<li>
		<p>
			<em>
                Get
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>O(1)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/2026-01-08_09-06-12.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Add
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>O(1)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/2026-01-08_09-06-00.png" width="400" >
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Remove
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    <code>O(1)</code>
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/2026-01-08_09-10-22.png" width="400" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Swap the element we want to delete in the Dense List, with the last element of the Dense List.
				</p>
			</li>
			<li>
				<p>
                    Update the Sparse List, so the swapped elements from the Dense List point to the correct elements.
				</p>
			</li>
			<li>
				<p>
                    The deleted element from the Dense List should be set to a nil value, so it doesn't point to anything.
				</p>
			</li>
			<li>
				<p>
                    Pop the Dense List.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                For very large entity numbers
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<strong>
                        Pagination
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The Sparse Set can be divided into a &quot;array of arrays&quot;.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/2026-01-08_09-12-38.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/2026-01-08_09-14-29.png" width="400" >
                            .
						</p>
					</li>
					<li>
						<p>
                            &quot;Allocate pages only when needed&quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Entity ID Recycling
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Generation counter.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Bitmask
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Only answers â€œis the component present?â€; it does not give you the 
                    <code>dense_idx</code>
                    &nbsp;you need to locate the component 
                    <code>T</code>
                    &nbsp;in your data array.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Speeding multi-component queries
			</strong>
            :
		</p>
		<ol>
			<li>
				<p>
                    Archetypes is a way to get the speed up, at its costs.
				</p>
			</li>
			<li>
				<p>
                    Iterate the best order.
				</p>
				<ul>
					<li>
						<p>
                            Always drive the query with the smallest component set (sparse-set dense array with fewest entries).
						</p>
					</li>
					<li>
						<p>
                            Complexity: O(min_set_size) + O(1) membership checks for each candidate.
						</p>
					</li>
					<li>
						<p>
                            Cheap, no extra memory, often good enough if one component is small.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Etc, do it later.
				</p>
			</li>
		</ol>
	</li>
</ul>
<h5
	id="archetypes" >
    Archetypes
</h5>
<ul>
	<li>
		<p>
            An archetype is a grouping of entities that all share the exact same set of component types. Each archetype stores component data in contiguous, component-oriented arrays so that iteration over entities that have a particular set of components is very fast.
		</p>
	</li>
	<li>
		<p>
            Maximize per-system data locality and remove membership checks at the cost of entity migration bookkeeping.
		</p>
	</li>
	<li>
		<p>
            Archetypes seems like a specialization, just like oop is a specialization, so it comes at a cost of less flexibility.
		</p>
	</li>
	<li>
		<p>
            Group entities with identical sets of components together in memory, allowing for contiguous memory storage and fast access patterns during iteration.
		</p>
	</li>
	<li>
		<p>
            You don't need to check whether a given entity has certain components on each iteration.
		</p>
	</li>
	<li>
		<p>
            Adding or removing components is generally more expensive than with sparse sets, as you need to transfer all components for an entity from one pool to another.
		</p>
	</li>
	<li>
		<p>
            A chosen set of components that an entity of a certain type will have
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-08_14-40-19.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            Each archetype has one contiguous array per component type. Rows are entities.
		</p>
	</li>
</ul>
<pre><code class="language-txt" data-lang="txt">Entities:&nbsp;&nbsp;&nbsp;&nbsp; Pos.x&nbsp;&nbsp;Pos.y&nbsp;&nbsp;| Vel.x&nbsp;&nbsp;Vel.y&nbsp;&nbsp;| Health.hp
Entity 42&nbsp;&nbsp;&nbsp;&nbsp; [ 1.2 ] [ 3.4 ]| [ 0.1 ] [ 0.0 ]| [ 100 ]
Entity 73&nbsp;&nbsp;&nbsp;&nbsp; [ 5.6 ] [ 2.2 ]| [ -1. ] [ 0.3 ]| [&nbsp;&nbsp;80 ]
Entity 11&nbsp;&nbsp;&nbsp;&nbsp; [ ... ] [ ... ]| [ ... ] [ ... ]| [ 120 ]
</code></pre>
<ul>
	<li>
		<p>
            <img src="assets/2026-01-05_19-19-18.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
            <img src="assets/2026-01-08_14-36-17.png" width="400" >
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=71RSWVyOMEY" 
						class="external-link" 
						target="_blank" >
                        ECS Archetypes explanation {5:09}
					</a>
                    .
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Archetypes are created lazily, else we run into a combinatorial of creating new tables for each theoretical component combination, even tho that combination might not be useful as an entity type in the world.
		</p>
	</li>
	<li>
		<p>
            Because every entity in a table must have every component, there can't be any gaps.
		</p>
	</li>
	<li>
		<p>
			<em>
                Problem
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    If we want to loop over everything with a position and velocity components, we would have to loop over 2 different tables.
				</p>
			</li>
			<li>
				<p>
                    Solution:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/2026-01-08_14-41-07.png" width="500" >
                            .
						</p>
					</li>
					<li>
						<p>
                            Take the intersection of these arrays, giving us the final set of archetypes, where each archetype contains all of the requested components.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Add/Remove
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    Move entity from one archetype to another (copy component values to new archetype arrays, remove from old archetype).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                In Unity
			</em>
            :
		</p>
		<ul>
			<li>
				<p>
                    It's not a container for anything. It doesn't contain the entity or any data associated with them. It's just an unique identifier.
				</p>
			</li>
			<li>
				<p>
                    &quot;Unique combination of components types for an entity&quot;.
				</p>
			</li>
			<li>
				<p>
                    We can have multiple archetypes for an entity query.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="system" >
    System
</h2>
<ul>
	<li>
		<p>
            A normal function.
		</p>
	</li>
	<li>
		<p>
            Is logic or a process that operates on one or more components of entities to modify their states or perform some operation.
		</p>
	</li>
</ul>
<h3
	id="with-sparse-sets" >
    With Sparse Sets
</h3>
<h5
	id="intersection-into-an-array-of-entity" >
    Intersection into an array of Entity
</h5>
<ul>
	<li>
		<p>
            &quot;give me all entities that have both Name and Person component&quot;.
		</p>
	</li>
	<li>
		<p>
			<em>
                Pros
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Contiguous index buffer â†’ easy to split into chunks for parallel workers.
				</p>
			</li>
			<li>
				<p>
                    Great for data-local processing (pull components by index into tight loops).
				</p>
			</li>
			<li>
				<p>
                    Enables SIMD easily because you can iterate contiguous component arrays by index with known bounds.
				</p>
			</li>
			<li>
				<p>
                    Allows simple scheduling (divide vec into ranges, spawn jobs, no shared iterator state).
				</p>
			</li>
			<li>
				<p>
                    Good throughput when query result is large or will be iterated multiple times.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Cons
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Upfront cost to compute intersection (time) and memory for the vector.
				</p>
			</li>
			<li>
				<p>
                    Allocation overhead unless you reuse buffers or reserve capacity.
				</p>
			</li>
			<li>
				<p>
                    If the query result is small or you only need first few matches, cost may be wasted.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Giving windows for optimization
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Avoiding re-queries
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The entities rarely change, and so the query is mostly the the same every frame, but all the query is repeated every frame.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Solution
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Store the query upfront, re-querying on modification to the stored Components for that query, via a dirty flag.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Parallelization
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Threads:
						</p>
						<ul>
							<li>
								<p>
                                    Doesn't sound good, as the threads wouldn't be able to sleep, causing high cpu consumption.
								</p>
							</li>
							<li>
								<p>
                                    Without an iterator:
								</p>
								<ul>
									<li>
										<p>
                                            Use a 
                                            <code>parallel_for</code>
                                            , dividing the work into batches, sent to different threads; classic usage.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With an iterator:
								</p>
								<ul>
									<li>
										<p>
                                            Trick. The next operator is only gathered after the first one is finished, as it's a sequential operation.
										</p>
									</li>
									<li>
										<p>
                                            A 
                                            <code>pseudo-parallel_for</code>
                                            &nbsp;could be used, as a way to divide the work between threads; a 
                                            <code>parallel_iterator</code>
                                            , so to speak.
										</p>
										<ul>
											<li>
												<p>
                                                    The problem with this solution is that differently from the 
                                                    <code>parallel_for</code>
                                                    , who divides the work in a homogenous way, the 
                                                    <code>parallel_iterator</code>
                                                    &nbsp;would divide not the 
													<em>
                                                        result
													</em>
                                                    , but the 
													<em>
                                                        source
													</em>
                                                    &nbsp;of the iterator (the 
                                                    <code>.data</code>
                                                    &nbsp;array), which means that some threads might have more work to do if the results of the iterator are heterogenous across the source.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            SIMD operations.
						</p>
						<ul>
							<li>
								<p>
                                    The code idea seems to require that all elements be grouped together in a SIMD Vector (
                                    <code>#simd[N]T</code>
                                    ) and so intrinsics operations are performed.
								</p>
								<ul>
									<li>
										<p>
                                            Seems quite inconvenient.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    I'm not that worried about SIMD, as this seems a bit advanced and maybe too specific, meanwhile there's always the option to send this to the GPU, which is probably better than SIMD anyway.
								</p>
							</li>
							<li>
								<p>
                                    Without an iterator:
								</p>
								<ul>
									<li>
										<p>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With an iterator:
								</p>
								<ul>
									<li>
										<p>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            GPU Compute:
						</p>
						<ul>
							<li>
								<p>
                                    The data would have to previously exist in GPU memory, or be copied to it before the compute.
								</p>
							</li>
							<li>
								<p>
                                    If the data were to be sent to the GPU, ideally this data should be pretty small to avoid being bandwidth bound.
								</p>
							</li>
							<li>
								<p>
                                    One way would be to have the whole ECS on GPU.
								</p>
							</li>
							<li>
								<p>
                                    Without an iterator:
								</p>
								<ul>
									<li>
										<p>
                                            .
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    With an iterator:
								</p>
								<ul>
									<li>
										<p>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Solution
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Focus on a full packed loop, instead of getting the next 
                                    <code>.data</code>
                                    &nbsp;via an iterator.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Other optimization ideas
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Iterate the smallest componentâ€™s dense array and use sparse lookups for other components.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="iterator" >
    Iterator
</h5>
<ul>
	<li>
		<p>
            &quot;iterate over everyÂ NameÂ component for entities that also have aÂ PersonÂ component&quot;.
		</p>
	</li>
	<li>
		<p>
			<em>
                Pros
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Low memory overhead, no allocation when you only consume a subset or stream.
				</p>
			</li>
			<li>
				<p>
                    Lower latency to obtain first match(s).
				</p>
			</li>
			<li>
				<p>
                    Useful for low-cardinality queries or queries that short-circuit early.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<em>
                Cons
			</em>
		</p>
		<ul>
			<li>
				<p>
                    Harder to parallelize unless the iterator supports splitting.
				</p>
			</li>
			<li>
				<p>
                    Potentially worse cache behavior because membership checks may bounce between sparse maps.
				</p>
			</li>
			<li>
				<p>
                    Harder to vectorize because you donâ€™t have fixed contiguous ranges to operate on.
				</p>
			</li>
			<li>
				<p>
                    Iterator state may create contention if shared between threads.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Makes any type of parallelization harder (SIMD, threads or GPU Compute).
		</p>
	</li>
	<li>
		<p>
            I will consider this only if its API/Safety benefits are so large that it out-weights the lack of optimization options.
		</p>
	</li>
	<li>
		<p>
            Ideally, I'd prefer a different option because of that.
		</p>
	</li>
	<li>
		<p>
            <s>
			<a
				href="https://github.com/odin-engine/ode_ecs" 
				class="external-link" 
				target="_blank" >
                ode_ecs
			</a>
            </s>.
		</p>
<pre><code class="language-odin" data-lang="odin">view: ecs.View
ecs.view_init(&view, &my_ecs, {&ais, &positions})

it: ecs.Iterator
ecs.iterator_init(&it, &view)
for ecs.iterator_next(&it) {
&nbsp;&nbsp;&nbsp;&nbsp;eid = ecs.get_entity(&it)
&nbsp;&nbsp;&nbsp;&nbsp;pos1 = ecs.get_component(&positions, &it)
&nbsp;&nbsp;&nbsp;&nbsp;ai = ecs.get_component(&ais, &it)
&nbsp;&nbsp;&nbsp;&nbsp;fmt.println("Iterating over view: ", eid, pos1, ai)
}
</code></pre>
		<ul>
			<li>
				<p>
                    I don't love the pattern. The programmer still have to type the name of the component twice: once on 
                    <code>view_init</code>
                    &nbsp;and again when inside the loop.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            In Rust:
		</p>
<pre><code class="language-rust" data-lang="rust">for (pos, vel) in (&positions, &velocities).join() {
&nbsp;&nbsp;&nbsp;&nbsp;pos.x += vel.x
}
</code></pre>
		<ul>
			<li>
				<p>
                    <code>.join()</code>
                    &nbsp;here is just a method from some class. There's nothing special here; I believe it's somewhat equivalent to the Odin version.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ideas" >
    Ideas
</h5>
<ul>
	<li>
		<p>
			<strong>
                Small overview for solving the problems
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The existence of 
                    <code>_query_result: [COMPONENT_MAX_ENTITIES]Entity_ID</code>
                    &nbsp;is quite ugly.
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Solution
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Store the data inside a struct, instead of storing in global scope.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Fetching 
                    <code>component.sparse[entity]</code>
                    &nbsp;twice.
				</p>
				<ul>
					<li>
						<p>
                            This can have its ups and downs:
						</p>
						<ul>
							<li>
								<p>
                                    Having to fetch again the 
                                    <code>.sparse</code>
                                    &nbsp;array means that the operation is usually safer, as there's window for error handling in case of the entity not being found inside that array.
								</p>
							</li>
							<li>
								<p>
                                    Tho, having to handle this possibility of error is annoying from the API standpoint, also if you consider that if the query is still valid, the entity 
									<em>
                                        is
									</em>
                                    &nbsp;still be valid, so re-fetching the data through the 
                                    <code>.sparse</code>
                                    &nbsp;array just introduces an unnecessary error handling.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        So, when is it safe to avoid double fetching and storing the 
                                        <code>dense_idx</code>
                                        &nbsp;right away?
									</em>
                                    &nbsp;Only if you can ensure that the query is still valid. For that, it's only safe to store the 
                                    <code>dense_idx</code>
                                    &nbsp;if:
								</p>
								<ol>
									<li>
										<p>
                                            The query is constructed every frame.
										</p>
									</li>
									<li>
										<p>
                                            The query is constructed upfront, but with usage of dirty flags to invalidate the query and re-query when necessary.
										</p>
									</li>
								</ol>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Solution
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Store the 
                                    <code>[]dense_idx</code>
                                    , instead of storing the 
                                    <code>Entity_ID</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            Basically an &quot;Archetype&quot; as the result of a query, with the option to only change only when any of its components are dirty.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The programmer has to type the name of the component twice.
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Solution
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Store a pointer to the component inside a struct, so it can be referenced later.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                Idea 10: Return many 
                <code>[]^T</code>
                &nbsp;arrays
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">@(require_results)
intersect2 :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;c0: ^Component($T0),
&nbsp;&nbsp;&nbsp;&nbsp;c1: ^Component($T1),
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (
&nbsp;&nbsp;&nbsp;&nbsp;sa0: [COMPONENT_MAX_ENTITIES]^T0,
&nbsp;&nbsp;&nbsp;&nbsp;sa1: [COMPONENT_MAX_ENTITIES]^T1,
&nbsp;&nbsp;&nbsp;&nbsp;idx: int,
&nbsp;&nbsp;&nbsp;&nbsp;) {
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for entity, d0 in c0.dense {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1 := c1.sparse[entity].? or_continue

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa0[idx] = &c0.data[d0]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa1[idx] = &c1.data[d1]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx += 1
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return
}

@(require_results)
intersect3 :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;c0: ^Component($T0),
&nbsp;&nbsp;&nbsp;&nbsp;c1: ^Component($T1),
&nbsp;&nbsp;&nbsp;&nbsp;c2: ^Component($T2),
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (
&nbsp;&nbsp;&nbsp;&nbsp;sa0: [COMPONENT_MAX_ENTITIES]^T0,
&nbsp;&nbsp;&nbsp;&nbsp;sa1: [COMPONENT_MAX_ENTITIES]^T1,
&nbsp;&nbsp;&nbsp;&nbsp;sa2: [COMPONENT_MAX_ENTITIES]^T2,
&nbsp;&nbsp;&nbsp;&nbsp;idx: int,
&nbsp;&nbsp;&nbsp;&nbsp;) {
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for entity, d0 in c0.dense {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1 := c1.sparse[entity].? or_continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d2 := c2.sparse[entity].? or_continue

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa0[idx] = &c0.data[d0]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa1[idx] = &c1.data[d1]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa2[idx] = &c2.data[d2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx += 1
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return
}

intersect :: proc{
&nbsp;&nbsp;&nbsp;&nbsp;intersect2,
&nbsp;&nbsp;&nbsp;&nbsp;intersect3
}

intersect :: proc{
&nbsp;&nbsp;&nbsp;&nbsp;intersect2,
&nbsp;&nbsp;&nbsp;&nbsp;intersect3
}

{
&nbsp;&nbsp;&nbsp;&nbsp;health_bars, healths, size := ecs.intersect(&_health_bars, &_healths)
&nbsp;&nbsp;&nbsp;&nbsp;for i in 0..&lt;size {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_health_bar(cmd, health_bars[i], healths[i]^)
&nbsp;&nbsp;&nbsp;&nbsp;}
}

{
&nbsp;&nbsp;&nbsp;&nbsp;dyn_bodies, mov_dirs, velocities_max, velocities_max_base, healths, size := ecs.intersect(&_dynamic_bodies, &_movement_directions, &_velocities_max, &_velocities_max_base, &_healths)
&nbsp;&nbsp;&nbsp;&nbsp;for i in 0..&lt;size {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movement_direction_via_input_and_network_and_debug(dyn_bodies[i]^, mov_dirs[i], velocities_max[i], velocities_max_base[i]^, healths[i], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&_game.character_net, _game.fixed_cycle_physics.tick_count)
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
		<ul>
			<li>
				<p>
                    Explicit and direct.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Wastes memory for having to store some extra arrays; the memory is not 
							<em>
                                that
							</em>
                            &nbsp;big of a deal, as it's on the stack and the size is 
                            <code>uintptr * COMPONENT_MAX_ENTITIES</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            I'm not sure how I feel about having an array of pointers. How does the CPU cache compare to just having an array of indices? Also, the safety can be a little bit more annoying if I intent to store the query result with caching and dirty flags.
						</p>
					</li>
					<li>
						<p>
                            It's a lot of things to type from the API user side...
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
			<strong>
                Idea 4: Iterator with or without static idx
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">@(private="file") _iter_idx: u32

intersect2_next:: proc(
&nbsp;&nbsp;&nbsp;&nbsp;c0: ^Component($T0),
&nbsp;&nbsp;&nbsp;&nbsp;c1: ^Component($T1),
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (
&nbsp;&nbsp;&nbsp;&nbsp;t0:&nbsp;&nbsp;&nbsp;&nbsp;^T0,
&nbsp;&nbsp;&nbsp;&nbsp;t1:&nbsp;&nbsp;&nbsp;&nbsp;^T1,
&nbsp;&nbsp;&nbsp;&nbsp;found: bool,
&nbsp;&nbsp;&nbsp;&nbsp;) {
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* 
&nbsp;&nbsp;&nbsp;&nbsp;The last element in the `.dense` slice was a match, now the last iteration should be false.
&nbsp;&nbsp;&nbsp;&nbsp;This is a valid behavior.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if _iter_idx &gt;= u32(len(c0.dense) - 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_iter_idx = 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for entity, d0 in c0.dense[_iter_idx:] {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_iter_idx += 1

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1 := c1.sparse[entity].? or_continue

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t0&nbsp;&nbsp;&nbsp;&nbsp;= &c0.data[d0]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1&nbsp;&nbsp;&nbsp;&nbsp;= &c1.data[d1]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found = true
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;Looped over the whole `.dense` slice and didn't find a match; reset the _iter_idx. 
&nbsp;&nbsp;&nbsp;&nbsp;This is a valid behavior.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;_iter_idx = 0
&nbsp;&nbsp;&nbsp;&nbsp;return
}

for dyn_bodies, mov_dirs, velocities_max, velocities_max_base, healths in ecs.intersect_next(&_dynamic_bodies, &_movement_directions, &_velocities_max, &_velocities_max_base, &_healths) {
&nbsp;&nbsp;&nbsp;&nbsp;movement_direction_via_input_and_network_and_debug(dyn_bodies^, mov_dirs, velocities_max, velocities_max_base^, healths, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&_game.character_net, _game.fixed_cycle_physics.tick_count)
}
</code></pre>
		<ul>
			<li>
				<p>
                    See the Odin note for an explanation on this pattern.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Parallelization?
						</p>
						<ul>
							<li>
								<p>
                                    Just use an option different from iterators; this is not a good option for parallelization.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Idea 9: Query and Execute
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">query_and_execute :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;$FN: $F, 
&nbsp;&nbsp;&nbsp;&nbsp;c0: ^Component($T0),
&nbsp;&nbsp;&nbsp;&nbsp;c1: ^Component($T1),
&nbsp;&nbsp;&nbsp;&nbsp;c2: ^Component($T2) = nil,
&nbsp;&nbsp;&nbsp;&nbsp;c3: ^Component($T3) = nil,
&nbsp;&nbsp;&nbsp;&nbsp;c4: ^Component($T4) = nil,
&nbsp;&nbsp;&nbsp;&nbsp;c5: ^Component($T5) = nil,
&nbsp;&nbsp;&nbsp;&nbsp;c6: ^Component($T6) = nil,
&nbsp;&nbsp;&nbsp;&nbsp;) 
&nbsp;&nbsp;&nbsp;&nbsp;where
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intrinsics.type_proc_parameter_count(F) &gt;= 2
&nbsp;&nbsp;&nbsp;&nbsp;{
</code></pre>
		<ul>
			<li>
				<p>
                    Doesn't allow caching with dirty flags, but that's ok; Not a big deal.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                -&gt;
							</strong>
                            &nbsp;Procedures like 
                            <code>draw_health_bar :: proc(cmd: rd.Command_Buffer, health_bar: ^Health_Bar, health: Health) {</code>
                            &nbsp;are a problem, as they receive the result of a component, BUT also receive random data (in this case: 
                            <code>cmd</code>
                            ). This creates a much more complicated API, which I didn't went too much into.
						</p>
					</li>
					<li>
						<p>
                            The components should be constant for better comp-time checks, but they can't; this is not a big deal, but makes the comp-time error be more confusing.
						</p>
						<ul>
							<li>
								<p>
                                    &quot;Constant parameters cannot have a default value&quot;.
								</p>
							</li>
							<li>
								<p>
                                    &quot;Cannot determine polymorphic type from parameter: 'untyped nil' to '^Component($T)'&quot;.
								</p>
							</li>
							<li>
								<p>
                                    &quot;'c3' of type '^Component($T)' has no field 'sparse'&quot;.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Idea 6: A Query stores many 
                <code>[]dense_idx</code>
                &nbsp;arrays
			</strong>
            :
		</p>
<pre><code class="language-odin" data-lang="odin">Query3_Idea6 :: struct($A, $B, $C: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp;ca:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^Component(A),
&nbsp;&nbsp;&nbsp;&nbsp;cb:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^Component(B),
&nbsp;&nbsp;&nbsp;&nbsp;cc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^Component(C),

&nbsp;&nbsp;&nbsp;&nbsp;dense_a:&nbsp;&nbsp;sa.Small_Array(COMPONENT_MAX_ENTITIES, u32),
&nbsp;&nbsp;&nbsp;&nbsp;dense_b:&nbsp;&nbsp;sa.Small_Array(COMPONENT_MAX_ENTITIES, u32),
&nbsp;&nbsp;&nbsp;&nbsp;dense_c:&nbsp;&nbsp;sa.Small_Array(COMPONENT_MAX_ENTITIES, u32),
&nbsp;&nbsp;&nbsp;&nbsp;len:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int,

&nbsp;&nbsp;&nbsp;&nbsp;iter_idx: u32,
}

@(require_results)
query3_via_intersect_id6 :: proc(ca: ^Component($A), cb: ^Component($B), cc: ^Component($C)) -&gt; (query: Query3_Idea6(A, B, C)) {
&nbsp;&nbsp;&nbsp;&nbsp;query.ca = ca
&nbsp;&nbsp;&nbsp;&nbsp;query.cb = cb
&nbsp;&nbsp;&nbsp;&nbsp;query.cc = cc

&nbsp;&nbsp;&nbsp;&nbsp;for entity, dense_a in ca.dense {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dense_b, ok_cb := cb.sparse[entity].?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !ok_cb do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dense_c, ok_cc := cc.sparse[entity].?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !ok_cc do continue

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa.append(&query.dense_a, u32(dense_a))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa.append(&query.dense_b, dense_b)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa.append(&query.dense_c, dense_c)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;query.len = sa.len(query.dense_a)

&nbsp;&nbsp;&nbsp;&nbsp;return
}

query := query3_via_intersect_id6(&_dynamic_bodies, &_velocities_max, &_movement_directions)

for i in 0..&lt;query.len {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&query.ca.data[query.dense_a.data[i]], // dense_a.data here is so I get the actual thing inside the Small_Array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query.cb.data[query.dense_b.data[i]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query.cc.data[query.dense_c.data[i]],
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
                    This can be used as an iterator, for example; this was for an old code, but the principle is the same:
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">query3_next:: proc(q: ^Query3($A, $B, $C)) -&gt; (A, B, C, bool) {
&nbsp;&nbsp;&nbsp;&nbsp;if q.idx == len(q.queried_data_indices[0]) - 1 do return
&nbsp;&nbsp;&nbsp;&nbsp;q.idx += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&q.ca.dense[q.queried_data_indices[0][q.idx]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&q.cb.dense[q.queried_data_indices[1][q.idx]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&q.cc.dense[q.queried_data_indices[2][q.idx]], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true
}

for dynamic_body, vel_max, mov_direction in query3_next(&query) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(dynamic_body, vel_max, mov_direction)
}
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            More memory waste than Idea 1, as every Query has many 
                            <code>[]dense_idx</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 8: A Query stores a 
                <code>[]Entity_ID</code>
                &nbsp;array
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>query3_intersect :: proc(ca: Component($A), cb: Component($B), cc: Component($C)) -&gt; Query(A, B, C) {</code>
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">Query3_Idea8 :: struct($A, $B, $C: typeid) {
&nbsp;&nbsp;&nbsp;&nbsp;ca:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^Component(A),
&nbsp;&nbsp;&nbsp;&nbsp;cb:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^Component(B),
&nbsp;&nbsp;&nbsp;&nbsp;cc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^Component(C),
&nbsp;&nbsp;&nbsp;&nbsp;entities: sa.Small_Array(COMPONENT_MAX_ENTITIES, Entity_ID),

&nbsp;&nbsp;&nbsp;&nbsp;iter_idx: u32,
}

@(require_results)
query3_via_intersect_id8 :: proc(ca: ^Component($A), cb: ^Component($B), cc: ^Component($C)) -&gt; (query: Query3_Idea8(A, B, C)) {
&nbsp;&nbsp;&nbsp;&nbsp;query.ca = ca
&nbsp;&nbsp;&nbsp;&nbsp;query.cb = cb
&nbsp;&nbsp;&nbsp;&nbsp;query.cc = cc

&nbsp;&nbsp;&nbsp;&nbsp;for entity in ca.dense {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cb.sparse[entity] == nil || cc.sparse[entity] == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa.append(&query.entities, entity)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return
}

query := query3_via_intersect_id8(_dynamic_bodies, _velocities_max, _movement_directions)

for entity in sa.slice(&query.entities) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(query.ca, entity),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(query.cb, entity)^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(query.cc, entity)^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
                    Same extra memory from Idea 1.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>[]Entity_ID</code>
                    &nbsp;is a stack allocated array.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Advantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The query can be made upfront, caching the results with dirty flags.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Fetches 
                            <code>component.sparse[entity]</code>
                            &nbsp;twice.
						</p>
					</li>
					<li>
						<p>
                            Confusing API.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 1: Array of Entity with a global 
                <code>_query_result</code>
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; []Entity_ID {</code>
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">_query_result: [COMPONENT_MAX_ENTITIES]Entity_ID

@(require_results)
intersect3 :: proc(ca: Component($A), cb: Component($B), cc: Component($C)) -&gt; []Entity_ID {
&nbsp;&nbsp;&nbsp;&nbsp;idx := 0
&nbsp;&nbsp;&nbsp;&nbsp;for entity in ca.dense {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cb.sparse[entity] == nil || cc.sparse[entity] == nil do continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_query_result[idx] = entity
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx += 1
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return _query_result[:idx]
}

for entity in intersect3(_dynamic_bodies, _velocities_max, _movement_directions) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(&_dynamic_bodies,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(&_velocities_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity)^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get(&_movement_directions, entity)^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Advantages
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            No extra struct. Every thing is just a call to intersect.
						</p>
						<ul>
							<li>
								<p>
                                    This by it self can be an issue, as the query doesn't support caching upfront.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The existence of 
                            <code>_query_result: [COMPONENT_MAX_ENTITIES]Entity_ID</code>
                            &nbsp;is quite ugly.
						</p>
					</li>
					<li>
						<p>
                            Fetches 
                            <code>component.sparse[entity]</code>
                            &nbsp;twice.
						</p>
					</li>
					<li>
						<p>
                            The programmer has to type the name of the component twice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 2: Many 
                <code>[]dense_idx</code>
                &nbsp;arrays, using stack arrays from the global scope
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; (r1, r2: []u32) {</code>
				</p>
			</li>
			<li>
				<p>
                    Sort-of an extension from Idea 1.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">dyn_body_indices, vel_max_indices, mov_indices := intersect3(_dynamic_bodies, _velocities_max, _movement_directions)
for i in 0..&lt;len(dyn_body_indices) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_dynamic_bodies.dense[dyn_body_indices[i]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_velocities_max.dense[vel_max_indices[i]]^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_movement_directions.dense[mov_indices[i]]^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
                    Avoids fetching 
                    <code>component.sparse[entity]</code>
                    &nbsp;twice.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            ~There has to be lots of different arrays to store each one of 
                            <code>dyn_body_indices, vel_max_indices, mov_indices</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            The programmer has to type the name of the component twice.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 8: Each 
                <code>Component(T)</code>
                &nbsp;has a array of 
                <code>query_result</code>
                &nbsp;array of ^T
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; (count: int) {</code>
				</p>
			</li>
			<li>
				<p>
                    The query 
                    <code>intersect2</code>
                    &nbsp;function returns a length to be used inside the for loop.
				</p>
			</li>
		</ul>
<pre><code class="language-odin" data-lang="odin">component_get_query :: #force_inline proc(component: Component($T), idx: int) -&gt; ^T {
&nbsp;&nbsp;&nbsp;&nbsp;return component.query_result[idx]
}
for i in 0..&lt;intersect3(_dynamic_bodies, _velocities_max, _movement_directions) {
&nbsp;&nbsp;&nbsp;&nbsp;dynamic_body_velocity_with_movement_direction(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_dynamic_bodies,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_velocities_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i)^,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component_get_query(_movement_directions, i)^,
&nbsp;&nbsp;&nbsp;&nbsp;)
}
</code></pre>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            When comparing to Idea 4, it comes down to what's lighter, as the ideas are basically the same.
						</p>
						<ul>
							<li>
								<p>
                                    Idea 4 seems better, as a 
                                    <code>u32</code>
                                    &nbsp;is lighter than a 
                                    <code>uintptr</code>
                                    &nbsp;(size of 
                                    <code>int</code>
                                    /
                                    <code>uint</code>
                                    ).
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 3: Many arrays of 
                <code>T</code>
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
                    Pattern 
                    <code>intersect2 :: proc(ca: Component($T), cb: Component($W)) -&gt; (r1: []T, r2: []W) {</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The array being 
                            <code>[]T</code>
                            &nbsp;doesn't make sense, as I want a pointer to the element, but doing so would give me a pointer to a copy of the element.
						</p>
					</li>
					<li>
						<p>
                            It's necessary that the array be defined as 
                            <code>[]^T</code>
                            &nbsp;(same as Idea 6) or 
                            <code>[]u32</code>
                            &nbsp;(indices to 
                            <code>.data</code>
                            , which is exactly the same as Idea 4).
						</p>
					</li>
					<li>
						<p>
                            The generic nature of 
                            <code>T</code>
                            &nbsp;and 
                            <code>W</code>
                            &nbsp;makes this quite difficult.
						</p>
						<ol>
							<li>
								<p>
                                    Make a 
                                    <code>Component</code>
                                    &nbsp;be generic enough so it doesn't need 
                                    <code>T</code>
                                    &nbsp;or 
                                    <code>W</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <s>The returns are allocated</s>.
								</p>
								<ul>
									<li>
										<p>
                                            Seems very bad for performance.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <s>
			<strong>
                Idea 5: Each 
                <code>Component(T)</code>
                &nbsp;has a array of query_result array of 
                <code>T</code>
			</strong>
            </s>:
		</p>
		<ul>
			<li>
				<p>
					<em>
                        Problems
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            The array being 
                            <code>[]T</code>
                            &nbsp;doesn't make sense, as I want a pointer to the element, but doing so would give me a pointer to a copy of the element.
						</p>
					</li>
					<li>
						<p>
                            It's necessary that the array be defined as 
                            <code>[]^T</code>
                            &nbsp;(same as Idea 6) or 
                            <code>[]u32</code>
                            &nbsp;(indices to 
                            <code>.data</code>
                            , which is exactly the same as Idea 4).
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="with-archetypes" >
    With Archetypes
</h3>
<pre><code class="language-c" data-lang="c">void movement_system(float dt) {
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; a_pv.count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pv.pos[i].x += a_pv.vel[i].vx * dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pv.pos[i].y += a_pv.vel[i].vy * dt;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; a_pvh.count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pvh.pos[i].x += a_pvh.vel[i].vx * dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_pvh.pos[i].y += a_pvh.vel[i].vy * dt;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<ul>
	<li>
		<p>
            No 
            <code>has_component</code>
            &nbsp;checks.
		</p>
	</li>
</ul>
<h2
	id="design-n-gtn-relationship-differentiating-data-stable-handles-for-dealing-with-references-to-data-when-the-backing-storage-changes-add-remove-move-resize" >
    Design: N-&gt;N relationship, differentiating data, stable handles for dealing with references to data when the backing storage changes (add/remove/move/resize)
</h2>
<ul>
	<li>
		<p>
			<strong>
                Important Notes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Think in terms of storage structures (Sparse Sets), not in terms of ECS semantics.
				</p>
			</li>
			<li>
				<p>
                    Don't store pointers to data inside those data structures, as the data can be corrupted on add/remove/move/resize.
				</p>
				<ul>
					<li>
						<p>
                            &quot;Stable handles&quot;
						</p>
					</li>
					<li>
						<p>
							<em>
                                Ways to resolve this
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    Make that moving things inside this array doesn't corrupt the data:
								</p>
								<ol>
									<li>
										<p>
                                            The data is not stored inside this array, but a different array that doesn't move.
										</p>
										<ol>
											<li>
												<p>
													<input
														type="checkbox" 
														disabled=""
														checked="">
                                                    
                                                    <code>Handle_Map</code>
                                                    .
												</p>
												<ul>
													<li>
														<p>
                                                            Uses a 
                                                            <code>Handle</code>
                                                            &nbsp;to get the data.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>Simple Array</s>.
												</p>
												<ul>
													<li>
														<p>
                                                            Just uses an index to get the data.
														</p>
													</li>
													<li>
														<p>
                                                            No generational tracking.
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            The data is not stored inside this array, but on a data struct where the &quot;key&quot; is always valid regardless of the elements of the backing array move.
										</p>
										<ol>
											<li>
												<p>
													<input
														type="checkbox" 
														disabled=""
														checked="">
                                                    Sparse Set (id -&gt; T).
												</p>
												<ul>
													<li>
														<p>
                                                            A generational system can be implemented.
														</p>
													</li>
													<li>
														<p>
                                                            Differently from a handle map, it enforces data packing at the cost of more memory usage for the 
                                                            <code>.sparse</code>
                                                            &nbsp;and 
                                                            <code>.dense</code>
                                                            &nbsp;arrays.
														</p>
													</li>
													<li>
														<p>
                                                            This doesn't enforce the concept of Entity or ECS. It's just a storage structure, just like a 
                                                            <code>Handle_Map</code>
                                                            .
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>Sparse Set (Component: Entity -&gt; T)</s>.
												</p>
												<ul>
													<li>
														<p>
                                                            A generational system can be implemented.
														</p>
													</li>
													<li>
														<p>
                                                            Using an entity as the key is tricky in some cases, as it makes the design too involved into ECS and the whole concept of &quot;entity&quot;.
														</p>
													</li>
													<li>
														<p>
                                                            Enforcing the concept of &quot;entity&quot; when it doesn't actually fit, it's just weird.
														</p>
													</li>
												</ul>
												<ol>
													<li>
														<p>
                                                            <s>The 
                                                            <code>Body</code>
                                                            &nbsp;is an entity that 
                                                            <code>sparse.add(&_transforms, entity_body, spatial.Transform2_Node{})</code>
                                                            </s>
														</p>
														<ul>
															<li>
																<p>
                                                                    Makes the design too involved with the concept of components, making the 
                                                                    <code>Body</code>
                                                                    &nbsp;to be an entity. This can be weird as there's now a question of extra lifetime handling, etc.
																</p>
															</li>
															<li>
																<p>
                                                                    In a way, this creates extra complexity in the ECS design.
																</p>
															</li>
														</ul>
													</li>
													<li>
														<p>
                                                            The 
                                                            <code>Body</code>
                                                            &nbsp;holds into an entity id to fetch the 
                                                            <code>Transform2_Node</code>
														</p>
														<ul>
															<li>
																<p>
                                                                    This basically means that the 
                                                                    <code>Body</code>
                                                                    &nbsp;will hold to the &quot;key&quot; for the 
                                                                    <code>Transform2_Node</code>
                                                                    , but this is made in a way that the body seems to be holding into an entity inside of it, which is really weird. The &quot;&quot;entity_transform&quot;&quot; is not actually an entity semantically, but only a key to a transform storage structure.
																</p>
															</li>
															<li>
																<p>
                                                                    In the end, it makes more sense to simply use a 
                                                                    <code>Sparse Set (id -&gt; T)</code>
                                                                    &nbsp;as it doesn't make the design so confusing.
																</p>
															</li>
														</ul>
													</li>
												</ol>
											</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
								<p>
                                    <s>Make the content not be stored inside an array</s>.
                                    <br>
                                    This goes against the ECS/DoD design.
								</p>
							</li>
						</ol>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            If all data is stored sequentially in a data struct, I need an access key to get a specific entry, otherwise I'd have to iterate over the data struct to find a match.
		</p>
		<ul>
			<li>
				<p>
                    array: index
				</p>
			</li>
			<li>
				<p>
                    sparse set: entity
				</p>
			</li>
			<li>
				<p>
                    map: key
				</p>
			</li>
			<li>
				<p>
                    handle_map: handle
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Not using ECS had the advantage of the &quot;object type&quot; that had the timer indicate the &quot;timer type&quot;, for example: a timer inside an AI component is understandably an AI timer; a timer inside a hitbox is considered a Hitbox Timer. Now with ECS I lost this hint. I need a way to improve these queries.
		</p>
	</li>
	<li>
		<p>
            Major diferences between 
            <code>Handle_Map</code>
            &nbsp;and 
            <code>Sparse_Set</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    The 
                    <code>Handle_Map</code>
                    &nbsp;requires the 
                    <code>Handle</code>
                    &nbsp;to be stored.
				</p>
			</li>
			<li>
				<p>
                    The 
                    <code>Sparse_Set</code>
                    &nbsp;doesn't require the 
                    <code>entity_key</code>
                    &nbsp;to be stored, as it stored this 
                    <code>entity_key</code>
                    &nbsp;within itself.
				</p>
			</li>
			<li>
				<p>
                    It could go as far as:
				</p>
				<ul>
					<li>
						<p>
                            If it's directly stored: can be both 
                            <code>Handle_Map</code>
                            &nbsp;or 
                            <code>Sparse_Set</code>
                            .
						</p>
					</li>
					<li>
						<p>
                            If it's not directly stored: is a 
                            <code>Sparse_Set</code>
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="adding-one-extra-indirection" >
    Adding one extra indirection
</h3>
<ul>
	<li>
		<p>
            &quot;Sparse Set to Sparse Set&quot; / &quot;Handle to Handle&quot; / &quot;Pointer to Pointer&quot;.
		</p>
	</li>
	<li>
		<p>
            One way to think of it is a 
            <code>sparse.Sparse_Set(^T)</code>
            , as there's an extra indirection in the sparse set.
		</p>
	</li>
</ul>
<h5
	id="ss-gt-t" >
    SS -&gt; T
</h5>
<ul>
	<li>
		<p>
            The main ECS design is &quot;SS -&gt; T&quot;, where SS is a Sparse Set and T is the data.
            <br>
            | 
            <code>sparse.Key</code>
            &nbsp;(
            <code>Entity</code>
            ) | 
            <code>T</code>
            &nbsp;(
            <code>Sprite</code>
            ) |
            <br>
            |-------------------------|----------------|
            <br>
            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | sprite1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
            <br>
            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | sprite2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
            <br>
            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | sprite3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
		</p>
	</li>
	<li>
		<p>
			<strong>
                Remove
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    &quot;Remove 
                    <code>Entity</code>
                    &nbsp;from 
                    <code>SS(Sprite)</code>
                    &quot;.
				</p>
			</li>
			<li>
				<p>
                    &quot;Remove 
                    <code>sparse.Key</code>
                    &nbsp;from 
                    <code>SS(T)</code>
                    &quot;.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            This brings a lot of problems if you want a N:N relationship, etc.
		</p>
		<ul>
			<li>
				<p>
                    For example, one system my want to act on 
                    <code>sprite2</code>
                    &nbsp;in specific, but using &quot;SS -&gt; T&quot; doesn't give any information that could help differentiate 
                    <code>sprite2</code>
                    &nbsp;from the other sprites.
				</p>
			</li>
			<li>
				<p>
                    Adding an extra level of indirection helps with that, as a SS could hold into 
                    <code>sparse.key</code>
                    &nbsp;for 
                    <code>sprite2</code>
                    &nbsp;and I could use that to filter the data.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ss-gt-ss-gt-t" >
    SS -&gt; SS -&gt; T
</h5>
<ul>
	<li>
		<p>
            One way I like to think of this strategy is:
		</p>
		<ul>
			<li>
				<p>
                    The inner SS is what holds the raw data, requiring a key to access the data.
				</p>
			</li>
			<li>
				<p>
                    The outer SS holds a key to a key (akin to a pointer to a pointer), grouping keys based on specialization criteria.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Interpretation: Extra level of indirection
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Mapping Table (
                    <code>Entity</code>
                    &nbsp;-&gt; 
                    <code>Sprite_Key</code>
                    )
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Primary Key
							</em>
                            :
						</p>
						<ol>
							<li>
								<p>
                                    Composite PK (
                                    <code>Entity</code>
                                    , 
                                    <code>Sprite_Key</code>
                                    ) â€” each row is an association/ membership row; this is the usual pattern for an association table, and it allows multiple rows and prevents duplicate identical associations; recommended default.
								</p>
							</li>
							<li>
								<p>
                                    <s>If you insist each 
                                    <code>Sprite_Key</code>
                                    &nbsp;appears at most once in the mapping, then 
                                    <code>Sprite_Key</code>
                                    &nbsp;can be declared unique in the mapping table (making it effectively the PK there). This choice changes cardinality.</s>
								</p>
								<ul>
									<li>
										<p>
                                            This is not the case, as different 
                                            <code>Entity</code>
                                            &nbsp;can have the same 
                                            <code>Sprite</code>
                                            , sharing the resource.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
					<li>
						<p>
							<em>
                                Foreign Key
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <code>Sprite_Key</code>
                                    &nbsp;is a foreign key that references the 
                                    <code>Sprite_Key</code>
                                    &nbsp;primary key in the &quot;Sprite Table&quot;.
								</p>
							</li>
							<li>
								<p>
                                    <code>Entity</code>
                                    &nbsp;is a foreign key that references the entity identity (the &quot;Entity Table&quot;, if exists).
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Cardinality
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    1:N - one 
                                    <code>Entity</code>
                                    &nbsp;maps to many 
                                    <code>Sprite_Key</code>
                                    &nbsp;rows.
								</p>
							</li>
							<li>
								<p>
                                    N:N - if multiple 
                                    <code>Entity</code>
                                    &nbsp;may reference the same 
                                    <code>Sprite_Key</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            The &quot;Mapping Table&quot; is then a true association/join table.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The composed relationship 
                                    <code>Entity</code>
                                    &nbsp;â†’ 
                                    <code>Sprite</code>
                                    &nbsp;(through the mapping) is (1:N) (one 
                                    <code>Entity</code>
                                    &nbsp;has many 
                                    <code>Sprite</code>
                                    s).
								</p>
							</li>
							<li>
								<p>
                                    Whether a particular mapping behaves like 1:1, 1:N, N:1 or N:N is determined by additional uniqueness constraints you choose to add on Entity or Sprite_Key.
                                    <br>
                                    | 
                                    <code>sparse.Key</code>
                                    &nbsp;(
                                    <code>Entity</code>
                                    ) | 
                                    <code>sparse.Key</code>
                                    &nbsp;(
                                    <code>Sprite_Key</code>
                                    ) |
                                    <br>
                                    |-------------------------|-----------------------------|
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Sprite Table (
                    <code>Sprite_Key</code>
                    &nbsp;-&gt; 
                    <code>T</code>
                    )
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Primary Key
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    <code>Sprite_Key</code>
                                    ; each slot id uniquely identifies one sprite row.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Foreign Key
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    No FK.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Cardinality
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    1:1 - each 
                                    <code>Sprite_Key</code>
                                    &nbsp;maps to exactly one Sprite.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Typically 1:1: Slots.slot_id is the PK and Sprites.slot_id is a PK/FK pointing to Slots. Each slot holds exactly one dense row (or points to it).
						</p>
					</li>
					<li>
						<p>
                            You can make Sprites shared by multiple slots if you change the model (e.g., multiple slot_ids referencing a single sprite_data_id): that would be N:1 from Slot to Sprite (slots referencing a shared immutable resource).
                            <br>
                            | 
                            <code>sparse.Key</code>
                            &nbsp;(
                            <code>Sprite_Key</code>
                            ) | 
                            <code>T</code>
                            &nbsp;(
                            <code>Sprite</code>
                            ) |
                            <br>
                            |-----------------------------|----------------|
                            <br>
                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | sprite1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                            <br>
                            | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | sprite2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                            <br>
                            | 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | sprite3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Remove
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            &quot;Remove 
                            <code>Entity</code>
                            &nbsp;from 
                            <code>SS(Sprite_Key)</code>
                            &nbsp;and 
                            <code>Sprite_Key</code>
                            &nbsp;from 
                            <code>SS(Sprite)</code>
                            &quot;.
						</p>
					</li>
					<li>
						<p>
                            &quot;Remove 
                            <code>sparse.Key</code>
                            &nbsp;from 
                            <code>SS(sparse.Key)</code>
                            &nbsp;and 
                            <code>sparse.Key</code>
                            &nbsp;from 
                            <code>SS(T)</code>
                            &quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Interpretation: Hierarchical Structure
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Sprite is an &quot;Entity&quot;, in this scenario.
				</p>
			</li>
			<li>
				<p>
                    Children Table (
                    <code>Entity</code>
                    &nbsp;-&gt; 
                    <code>Sprite_Entity</code>
                    )
				</p>
				<ul>
					<li>
						<p>
                            Could be interpreted as table of &quot;children of 
                            <code>Entity</code>
                            &quot;.
                            <br>
                            | 
                            <code>sparse.Key</code>
                            &nbsp;(
                            <code>Entity</code>
                            ) | 
                            <code>sparse.Key</code>
                            &nbsp;(
                            <code>Sprite_Entity</code>
                            ) |
                            <br>
                            |-------------------------|-----------------------------|
                            <br>
                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                            <br>
                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                            <br>
                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Sprite Entity Table (
                    <code>Sprite_Entity</code>
                    &nbsp;-&gt; 
                    <code>T</code>
                    )
                    <br>
                    | 
                    <code>sparse.Key</code>
                    &nbsp;(
                    <code>Sprite_Entity</code>
                    ) | 
                    <code>T</code>
                    &nbsp;(
                    <code>Sprite</code>
                    ) |
                    <br>
                    |--------------------------------|----------------|
                    <br>
                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| sprite1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                    <br>
                    | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| sprite2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                    <br>
                    | 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| sprite3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
				</p>
			</li>
			<li>
				<p>
					<strong>
                        Remove
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            &quot;Remove 
                            <code>Entity</code>
                            &nbsp;from 
                            <code>SS(Sprite_Entity)</code>
                            &nbsp;and 
                            <code>Sprite_Entity</code>
                            &nbsp;from 
                            <code>SS(Sprite)</code>
                            &quot;.
						</p>
					</li>
					<li>
						<p>
                            &quot;Remove 
                            <code>sparse.Key</code>
                            &nbsp;from 
                            <code>SS(sparse.Key)</code>
                            &nbsp;and 
                            <code>sparse.Key</code>
                            &nbsp;from 
                            <code>SS(T)</code>
                            &quot;.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<strong>
                        Discussion
					</strong>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Funny enough, a hierarchical structure like this has the exact same layout as the strategy shown just above.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Discussion with ChatGPT
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    It is exactly the same pattern as a normalized SQL schema: one table (Sprite_Key) of stable keys/slots and a separate table of actual data (Sprite). Entities reference keys (foreign keys); keys point to rows of Sprite.
				</p>
			</li>
			<li>
				<p>
                    That indirection gives you stable handles that survive reallocation/moves of the dense backing store, and it gives you a place to put per-key metadata (generation, refcount, tags, indices) so references remain valid or can be detected stale.
				</p>
			</li>
			<li>
				<p>
                    Referential integrity is enforced by generation checks and by explicit refcount or cascade-delete semantics.
				</p>
			</li>
			<li>
				<p>
                    Use single-level (Entity -&gt; index into dense T) when:
				</p>
				<ul>
					<li>
						<p>
                            There is one owner per data row.
						</p>
					</li>
					<li>
						<p>
                            You don't need stable external references to rows.
						</p>
					</li>
					<li>
						<p>
                            You can avoid moving rows (or you accept updating entity-&gt;index on swap).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Use two-level when:
				</p>
				<ul>
					<li>
						<p>
                            You need stable handles that persist across moves/resizes.
						</p>
					</li>
					<li>
						<p>
                            Multiple owners or external references must remain valid.
						</p>
					</li>
					<li>
						<p>
                            You want to store metadata per-slot (generation, tags, refcount) separate from data.
						</p>
					</li>
					<li>
						<p>
                            You want to model shared resources (textures, meshes) and have many lightweight references.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    The 
                    <code>SS -&gt; SS -&gt; T</code>
                    &nbsp;pattern with a small slot/meta table and a dense data array is the pragmatic, normalized approach that gives stable external references, safe lifetime semantics (via generation) and the flexibility to group/filter/share data.
				</p>
			</li>
			<li>
				<p>
                    If you need absolute highest throughput for iteration and you never need external stable handles, the simpler SS -&gt; T (entity-&gt;index) is slightly faster, but it complicates external references and reuse handling.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Discussion with ChatGPT on N:N
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    N:N join/association tables are standard for modelling many-to-many relationships. Theyâ€™re expected and correct when multiple owners reference the same target and vice-versa.
				</p>
			</li>
			<li>
				<p>
                    Table size grows with number of associations; queries that join through the mapping require index lookups or scans; indexes (on entity and sprite_key) are required for efficient lookups in both directions.
				</p>
			</li>
			<li>
				<p>
                    N:N gets a bad reputation because it introduces an extra layer of indirection and operational cost (joins, indexes, churn), and because beginners sometimes model multivalued attributes directly instead of normalizing. Itâ€™s not inherently wrong â€” itâ€™s the correct, normalized representation for many real relationships â€” but it does demand deliberate engineering for performance and lifecycle.
				</p>
			</li>
			<li>
				<p>
                    Canonical ways to break down and manage N:N in SQL:
				</p>
				<ul>
					<li>
						<p>
                            Normalize with a junction (association) table.
						</p>
						<ul>
							<li>
								<p>
                                    That is the standard decomposition: represent the many-to-many as two 1:N relationships with an explicit mapping table. (In your ECS this is already the Mapping table.) This is the correct, normalized model.
								</p>
							</li>
							<li>
								<p>
                                    A mapping (junction/association) table is a dedicated table whose only job is to record pairs (or tuples) that link rows from two other tables.
								</p>
							</li>
							<li>
								<p>
                                    Conceptually it turns a many-to-many relationship into two one-to-many relationships: 'A â†’ mapping' and 'mapping â†’ B'.
								</p>
							</li>
							<li>
								<p>
                                    In your ECS terms: the mapping table holds pairs (
                                    <code>Entity</code>
                                    , 
                                    <code>Sprite_Key</code>
                                    ); each row says â€œthis entity has (or references) this sprite slot.â€
								</p>
							</li>
							<li>
								<p>
                                    Why use it (the normalization reason):
								</p>
								<ul>
									<li>
										<p>
                                            It avoids embedding multiple values in a single column (no lists in one field).
										</p>
									</li>
									<li>
										<p>
                                            It prevents duplication of the sprite rows while allowing many entities to share the same sprite slot.
										</p>
									</li>
									<li>
										<p>
                                            It makes the relationship explicit and enforces integrity via keys and constraints, so you donâ€™t get orphaned or inconsistent references.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Caio: The whole point is that if I were to do &quot;
                                    <code>Entity</code>
                                    &nbsp;-&gt; 
                                    <code>Sprite</code>
                                    &quot; directly, while I want to preserve a N:N relationship, I would have duplicated sprites which is not acceptable.
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                Yes. In a situation like this you have two choices
											</strong>
                                            :
										</p>
										<ol>
											<li>
												<p>
                                                    Duplicate the sprite data for every entity that needs it (store by-value on the entity).
												</p>
												<ul>
													<li>
														<p>
                                                            Consequences: more memory, slower writes when you want to change the sprite globally, and risk of inconsistent copies if you forget to update every duplicate.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
													<strong>
                                                        Introduce indirection so entities point to a single canonical sprite record instead of embedding the data
													</strong>
                                                    :
												</p>
												<ul>
													<li>
														<p>
															<strong>
                                                                That indirection is precisely what the mapping (junction) table or slot/handle layer provides
															</strong>
                                                            .
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            Caio: Cool =)
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Add constraints.
						</p>
					</li>
					<li>
						<p>
                            Promote the association to a first-class entity.
						</p>
						<ul>
							<li>
								<p>
                                    Instead of treating the mapping row as â€œjust a pairâ€, give it its own identity and metadata (a slot row). That lets you store lifecycle fields (generation, refcount, timestamps) on the association and treat changes atomically.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    For ECS, this enables sharing component instances or resources across entities (many entities â†’ same slot) and allowing entities to hold multiple component instances of that type (the mapping table holds many rows per entity). Useful for shared meshes, shared sprite resources, decals, or when an entity can legitimately have multiple components of the same type.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h5
	id="ss-gt-hm-gt-t-" >
    <s>SS -&gt; HM -&gt; T </s>
</h5>
<ul>
	<li>
		<p>
            <code>Sparse_Set</code>
            &nbsp;to a 
            <code>Handle</code>
            &nbsp;to a 
            <code>Handle_Map</code>
            .
            <br>
			<strong>
                Problems
			</strong>
            :
            <br>
            The data 
            <code>T</code>
            &nbsp;is not packed, as 
            <code>HM</code>
            &nbsp;purposely doesn't pack the data to avoid breaking the handles.
            <br>
            This defeats a bit of the performance improvements with ECS.
            <br>
			<strong>
                Layout
			</strong>
            :
            <br>
            <code>Handle_Map</code>
            :
            <br>
            Stores the data.
            <br>
            <code>hm.Handle_Map(T, Handle_To_T, SIZE)</code>
            <br>
            <code>Handle</code>
            :
            <br>
            Access to the data.
            <br>
            <code>Sparse_Set</code>
            <br>
            Storage of the Handle.
            <br>
            <code>sparse.Sparse_Set(Handle_To_T)</code>
            <br>
			<strong>
                Usages as a 
                <code>Handle</code>
			</strong>
            :
            <br>
            <code>Damage_Indicator</code>
            :
            <br>
            <code>odin Damage_Indicator :: struct { sprite: rd.Sprite_Handle, timer:&nbsp;&nbsp;timer.Timer_Handle, } </code>
            <br>
            <code>AI_State_Machine</code>
            :
            <br>
            <code>odin AI_State_Machine :: struct { timer_ptr:&nbsp;&nbsp;timer.Timer_Handle, is_stopped: bool, } </code>
            <br>
			<strong>
                Usages as a 
                <code>Sparse_Set</code>
                &nbsp;to a 
                <code>Handle</code>
			</strong>
            :
            <br>
            Projectile:
            <br>
            <code>odin _projectiles_trans: sparse.Sparse_Set(spatial.Transform2_Node_Handle) </code>
            <br>
            <code>Sprite</code>
            :
            <br>
            <code>odin _sprites_bouncy: sparse.Sparse_Set(rd.Sprite_Handle) </code>
            <br>
            <code>Sprite</code>
            &nbsp;is stored inside a 
            <code>Handle_Map</code>
            .
            <br>
            The 
            <code>sprite_component</code>
            &nbsp;is a Sparse Set for 
            <code>Sprite_Handle</code>
            s.
		</p>
	</li>
</ul>
<h5
	id="hm-gt-ss-gt-t" >
    <s>HM -&gt; SS -&gt; T</s>
</h5>
<ul>
	<li>
		<p>
			<strong>
                Problems
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    In this case the concept of an &quot;entity&quot; with SS doesn't exist anymore and you only work with handles to HM.
				</p>
				<ul>
					<li>
						<p>
                            This can be bad, as some &quot;sparse sets&quot;/&quot;components&quot; might not care for this extra indirection level.
						</p>
					</li>
					<li>
						<p>
                            This simply goes against the main design. &quot;If you have SS -&gt; T, the entity is a 
                            <code>sparse.Key</code>
                            , but if you have an extra indirection, the entity becomes a 
                            <code>hm.Handle</code>
                            &quot;.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<h2
	id="discarded-ideas" >
    Discarded Ideas
</h2>
<h3
	id="handle_map-inside-a-sparse_set" >
    <s>Handle_Map inside a Sparse_Set</s>
</h3>
<pre><code class="language-odin" data-lang="odin">Sparse_Set :: struct($T: typeid, $HANDLE_TYPE: typeid, $LEN: u64 = 10) {
&nbsp;&nbsp;&nbsp;&nbsp;sparse: [LEN]HANDLE_TYPE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ent_handle = sparse[ent]
&nbsp;&nbsp;&nbsp;&nbsp;dense:&nbsp;&nbsp;[dynamic]Key,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ent = dense[ent_handle]
&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;&nbsp; hm.Handle_Map(T, HANDLE_TYPE), // T = hm.get(&sparse_set.data, ent_handle)
}
</code></pre>
<ul>
	<li>
		<p>
            <code>E -&gt; Handle -&gt; T</code>
            &nbsp;is slower than 
            <code>E -&gt; dense_idx -&gt; T</code>
            .
		</p>
	</li>
	<li>
		<p>
            Gives more safety, I think, for having something like generations.
		</p>
	</li>
	<li>
		<p>
            This is a bad idea, as it defeats the whole purpose of having the data packed with a 
            <code>Sparse_Set</code>
            ...
		</p>
	</li>
	<li>
		<p>
            There's no reason to use this.
		</p>
	</li>
</ul>
<h3
	id="thinking-in-terms-of-valid-data-when-the-backing-storage-changes-add-remove-move-resize" >
    Thinking in terms of valid data when the backing storage changes (add/remove/move/resize)
</h3>
<ul>
	<li>
		<p>
            For 
            <code>Timer</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
                    <code>Timer</code>
                    &nbsp;is equivalent to 
                    <code>f32</code>
                    ; it's atomic.
				</p>
			</li>
			<li>
				<p>
                    All timers could share a system: they are all updated via calling 
                    <code>update</code>
                    &nbsp;on them. This means that I have reasons to store them together, even tho this is not a requirement.
				</p>
				<ul>
					<li>
						<p>
                            After further thought, maybe not all timers should be updated equally, as some might want high update precision for visuals, while others are for network or physics.
						</p>
					</li>
					<li>
						<p>
                            Considering the division between processing of data, there could be 
                            <code>_timers_visuals</code>
                            &nbsp;/ 
                            <code>_timers_physics</code>
                            , symbolizing the moment when each of these components should have the system update called.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    No timers are equal: a specific timer is wanted for a system; there's a concept of &quot;timer types&quot;, where a timer is used for AI, or UI, or visuals, etc. Every timer can have a completely different purpose.
				</p>
			</li>
			<li>
				<p>
                    An entity could &quot;have&quot; many timers, and a system wants a specific timer from all timers available.
				</p>
			</li>
			<li>
				<p>
                    &quot;This timer belongs to who/what?&quot;
				</p>
			</li>
			<li>
				<p>
					<em>
                        Used for
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>Damage_Indicator</code>
						</p>
					</li>
					<li>
						<p>
                            <code>AI_State_Machine</code>
						</p>
						<ul>
							<li>
								<p>
                                    This would not be how the AI is used. Utility AI would evaluate the next decision based on the aggregated scores.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            For 
            <code>Sprite</code>
            :
		</p>
		<ul>
			<li>
				<p>
                    A 
                    <code>Sprite</code>
                    &nbsp;is equivalent to 
                    <code>f32</code>
                    ; it's atomic.
				</p>
			</li>
			<li>
				<p>
                    Thinking in terms of shared processing:
				</p>
				<ul>
					<li>
						<p>
                            All timers do not share a system.
						</p>
					</li>
					<li>
						<p>
                            The sources say that storing atomic data inside an array doesn't make sense, as grouping things together should have semantic meaning. I go a step further and say it should indicate data that is processed together.
						</p>
					</li>
					<li>
						<p>
                            This indicates that a 
                            <code>[]Sprite</code>
                            &nbsp;or 
                            <code>_sprites: Component(Sprite)</code>
                            &nbsp;doesn't make sense, as all sprites are not processed together.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    There should have specialization in these arrays/components, such as creating new arrays or components for each diference in semantic/processing.
				</p>
			</li>
			<li>
				<p>
                    &quot;This sprite belongs to who/what?&quot;
				</p>
			</li>
			<li>
				<p>
                    Is more about having a reference to a 
                    <code>Sprite</code>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Used for
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            <code>Damage_Indicator</code>
						</p>
					</li>
					<li>
						<p>
                            shadows sprites.
						</p>
					</li>
					<li>
						<p>
                            projectile sprite.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <code>Sprite</code>
		</p>
		<ul>
			<li>
				<p>
                    The projectile's sprite could be the &quot;main transform&quot; for that object, but currently I have no good way to query for the sprite.
				</p>
			</li>
			<li>
				<p>
                    Maybe sprites should be a 
                    <code>Sparse_Set</code>
                    , just like 
                    <code>Dynamic_Body</code>
                    , 
                    <code>Area</code>
                    &nbsp;and 
                    <code>Transform2_Node</code>
                    &nbsp;(potentially).
				</p>
			</li>
			<li>
				<p>
                    <code>Damage_Indicator</code>
				</p>
				<ul>
					<li>
						<p>
                            Wants a &quot;pointer&quot; to a Sprite.
						</p>
					</li>
				</ul>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    <s>The 
                    <code>Sprite</code>
                    &nbsp;is an entity</s>.
				</p>
				<ul>
					<li>
						<p>
							<em>
                                Problem
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Queries:
								</p>
								<ul>
									<li>
										<p>
                                            The sprite would be an entity it self, so queries like this wouldn't be possible:
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">for entity, sprite, vel_max, entity_target, damage in sparse.intersect_next(&rd.sprites, &_velocities_max, &_entities_target, &_damages) {
&nbsp;&nbsp;&nbsp;&nbsp;move_to_target_or_damage_target_and_self_destroy(entity, sprite, vel_max^, entity_target^, damage^, world, dt)
} 
</code></pre>
								<ul>
									<li>
										<p>
                                            The entity that has 
                                            <code>&_velocities_max, &_entities_target, &_damages</code>
                                            &nbsp;is not the same that has a 
                                            <code>&rd.sprite</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    A ENTITY_SPRITE uses the 
                                                    <code>rd.sprite</code>
                                                    , while the ENTITY_CHARACTER/ENTITY_CREATURE/ENTITY_PROJECTILE uses the other components.
												</p>
											</li>
											<li>
												<p>
                                                    So, what I mean is, this is a data anomaly: the sprite used will be incorrect.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            &quot;If a 'thing' is an entity, it cannot be considered a 'component' for another entity&quot;.
										</p>
										<ul>
											<li>
												<p>
                                                    The only way for an entity to also be considered a component, would be if when querying for the components, the 
                                                    <code>_children</code>
                                                    &nbsp;component is checked. This would require a recursive check, where not only the entities from 
                                                    <code>c0.dense</code>
                                                    &nbsp;would have to be checked, but also the children of all these entities, recursively.
												</p>
											</li>
											<li>
												<p>
                                                    If I don't want this behavior, I'd have to not use the 
                                                    <code>_children</code>
                                                    &nbsp;sparse set, ensuring that &quot;a 'thing' is either a component OR a entity, not both&quot;.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
				<ol>
					<li>
						<p>
                            Only 
                            <code>Transform2_Node</code>
                            &nbsp;is a component.
						</p>
<pre><code class="language-odin" data-lang="odin">Sprite_Data :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;debug_name:&nbsp;&nbsp; string,

&nbsp;&nbsp;&nbsp;&nbsp;// Tex
&nbsp;&nbsp;&nbsp;&nbsp;tex_path:&nbsp;&nbsp;&nbsp;&nbsp; string,
&nbsp;&nbsp;&nbsp;&nbsp;tex_extent:&nbsp;&nbsp; spatial.Extent,
&nbsp;&nbsp;&nbsp;&nbsp;tex_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u32,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Mesh
&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mesh,

&nbsp;&nbsp;&nbsp;&nbsp;model_matrix: matrix[4, 4]f32,

&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatial.Recti,
&nbsp;&nbsp;&nbsp;&nbsp;flip_x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,
&nbsp;&nbsp;&nbsp;&nbsp;flip_y:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,

&nbsp;&nbsp;&nbsp;&nbsp;tile_size:&nbsp;&nbsp;&nbsp;&nbsp;[2]int,
&nbsp;&nbsp;&nbsp;&nbsp;tile_idx:&nbsp;&nbsp;&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp;_total_tiles: int,

&nbsp;&nbsp;&nbsp;&nbsp;color_mult:&nbsp;&nbsp; [4]f32, // 0 to 1.
&nbsp;&nbsp;&nbsp;&nbsp;color_add:&nbsp;&nbsp;&nbsp;&nbsp;[4]f32, // 0 to 1.
}

sprite_add :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;&nbsp;&nbsp;&nbsp;[2]f32 = {},
&nbsp;&nbsp;&nbsp;&nbsp;rot:&nbsp;&nbsp;&nbsp;&nbsp;f32&nbsp;&nbsp;&nbsp;&nbsp;= 0, 
&nbsp;&nbsp;&nbsp;&nbsp;scale:&nbsp;&nbsp;[2]f32 = { 1, 1 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent: sparse.Key = {},
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (sprite: Sprite) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)
}

tex, tex_idx := rd.texture_get_from_cache_or_append(cmd, &level.textures, "assets/char.png", arena)
sprite_entity := rd.sprite_add(
&nbsp;&nbsp;&nbsp;&nbsp;cmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = cmd,
&nbsp;&nbsp;&nbsp;&nbsp;debug_name&nbsp;&nbsp;= "char",
&nbsp;&nbsp;&nbsp;&nbsp;texture&nbsp;&nbsp;&nbsp;&nbsp; = tex, 
&nbsp;&nbsp;&nbsp;&nbsp;texture_idx = tex_idx,
&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = { 0, 0 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= dynamic_body.trans,
&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= { 16, 31 },
&nbsp;&nbsp;&nbsp;&nbsp;arena&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = arena,
)
sparse.add_as_child(&_children, entity, sprite_entity)
rd.layers_add_draw_option(&level.layers, sprite_entity, 10, true, arena.cpu_alloc)
</code></pre>
					</li>
					<li>
						<p>
                            Everything is a component: 
                            <code>Transform2_Node</code>
                            &nbsp;+ 
                            <code>Texture</code>
                            &nbsp;+ 
                            <code>Mesh</code>
                            &nbsp;+ 
                            <code>Material2D</code>
                            &nbsp;are components.
						</p>
						<ul>
							<li>
								<p>
                                    <code>Mesh</code>
                                    :
								</p>
							</li>
							<li>
								<p>
                                    <code>Material2D</code>
                                    :
								</p>
							</li>
						</ul>
<pre><code class="language-odin" data-lang="odin">Material2D :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;// Tex thing
&nbsp;&nbsp;&nbsp;&nbsp;tex_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u32,

&nbsp;&nbsp;&nbsp;&nbsp;// UV
&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatial.Recti,
&nbsp;&nbsp;&nbsp;&nbsp;flip_x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,
&nbsp;&nbsp;&nbsp;&nbsp;flip_y:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,

&nbsp;&nbsp;&nbsp;&nbsp;tile_size:&nbsp;&nbsp;&nbsp;&nbsp;[2]int,
&nbsp;&nbsp;&nbsp;&nbsp;tile_idx:&nbsp;&nbsp;&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp;_total_tiles: int,

&nbsp;&nbsp;&nbsp;&nbsp;// Frag
&nbsp;&nbsp;&nbsp;&nbsp;color_mult:&nbsp;&nbsp; [4]f32, // 0 to 1.
&nbsp;&nbsp;&nbsp;&nbsp;color_add:&nbsp;&nbsp;&nbsp;&nbsp;[4]f32, // 0 to 1.
}

sprite_create :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;&nbsp;&nbsp;&nbsp;[2]f32 = {},
&nbsp;&nbsp;&nbsp;&nbsp;rot:&nbsp;&nbsp;&nbsp;&nbsp;f32&nbsp;&nbsp;&nbsp;&nbsp;= 0, 
&nbsp;&nbsp;&nbsp;&nbsp;scale:&nbsp;&nbsp;[2]f32 = { 1, 1 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent: sparse.Key = {},
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (sprite: Sprite) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&rd.meshes, entity, /* mesh info */)

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&rd.textures, entity, /* texture info */)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If using an existing texture, this has to be implemented in a sparse set so this is allowed.

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&rd.material2d, entity, /* material2d info */)
}
</code></pre>
					</li>
				</ol>
			</li>
			<li>
				<p>
					<input
						type="checkbox" 
						disabled=""
						checked="">
                    The data is stored in an 
                    <code>Handle_Map(T)</code>
                    , using 
                    <code>.handle: Handle</code>
                    &nbsp;to access the data, without any components.
				</p>
				<ul>
					<li>
						<p>
                            This requires the handle to be stored.
						</p>
						<ul>
							<li>
								<p>
                                    Check the strategy &quot;
                                    <code>Sparse_Set</code>
                                    &nbsp;to a 
                                    <code>Handle</code>
                                    &nbsp;to a 
                                    <code>Handle_Map</code>
                                    : &quot;Handle to Handle&quot; / &quot;Pointer to Pointer&quot;&quot;.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>The data is stored in a single 
                    <code>Component(T)</code>
                    , using other components to help differentiate the &quot;type of 
                    <code>T</code>
                    &quot;</s>
				</p>
				<ul>
					<li>
						<p>
                            How would I differentiate &quot;bounciness&quot;?
						</p>
						<ul>
							<li>
								<p>
                                    Maybe there's a &quot;Bounce component&quot;, specifying the &quot;max angle&quot; and &quot;base speed&quot;.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Problems
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    If an entity has a &quot;shadow sprite&quot; and a &quot;main sprite&quot;, there's no way to distinguish between them while using a single data structure. Adding extra components to the same entity, for example, &quot;bouncy component&quot; doesn't help differentiate the sprites while querying.
								</p>
							</li>
							<li>
								<p>
                                    This is where these ideas come from:
								</p>
								<ul>
									<li>
										<p>
                                            &quot;Many 
                                            <code>[]T</code>
                                            /
                                            <code>map[]T</code>
                                            /
                                            <code>Handle_Map</code>
                                            /
                                            <code>Component</code>
                                            &quot;
										</p>
									</li>
									<li>
										<p>
                                            &quot;The 
                                            <code>Sprite</code>
                                            &nbsp;is an entity&quot;
										</p>
									</li>
									<li>
										<p>
                                            &quot;What makes 
                                            <code>T</code>
                                            &nbsp;different from one another is stored inside 
                                            <code>T</code>
                                            , and not related to the data structure&quot;
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>Many 
                    <code>[]T</code>
                    /
                    <code>map[]T</code>
                    /
                    <code>Handle_Map</code>
                    /
                    <code>Component</code>
                    </s>.
				</p>
				<ul>
					<li>
						<p>
                            This is a way to tackle specialization; having many storage structures doesn't solve the issue of things changing inside these backing structures.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                Killer Problem
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    This is really weird for trying to hold onto a reference of 
                                    <code>T</code>
                                    , as you don't know which of many data structures the data is in.
								</p>
								<ul>
									<li>
										<p>
                                            This is where the main problem of 
                                            <code>Sprite</code>
                                            &nbsp;originated.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>What makes 
                    <code>T</code>
                    &nbsp;different from one another is stored inside 
                    <code>T</code>
                    , and not related to the data structure</s>.
				</p>
				<ul>
					<li>
						<p>
                            This is reaaaally weird, as one could argue that I could have an array of 
                            <code>f32</code>
                            &nbsp;and that it's the job of the 
                            <code>f32</code>
                            &nbsp;to indicate how it should be used.
						</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
				checked="">
            
            <code>Transform2_Node</code>
		</p>
		<ul>
			<li>
				<p>
                    Before the changes to 
                    <code>Transform2_Node</code>
                    , I could store the 
                    <code>spatial.Transform2_Node</code>
                    &nbsp;inside a 
                    <code>Sparse_Set</code>
                    , but now this is no longer possible as the transforms are stored inside a 
                    <code>Handle_Map</code>
                    &nbsp;inside the spatial library.
				</p>
			</li>
			<li>
				<p>
                    I'd like to reconsider that maybe instead of a 
                    <code>Handle_Map</code>
                    , I could use a 
                    <code>Sparse_Set</code>
                    .
				</p>
				<ul>
					<li>
						<p>
                            If I want to query this component with other things, I'd have to store the transform with the entity_key.
						</p>
					</li>
					<li>
						<p>
							<strong>
                                -&gt;
							</strong>
                            &nbsp;If you think about it, it's kinda weird that 
                            <code>Transform2_Node</code>
                            &nbsp;is not a component....
						</p>
					</li>
					<li>
						<p>
                            Well for what I revised, it doesn't really seem to be room for letting the 
                            <code>Transform2_Node</code>
                            &nbsp;be a component, even tho it probably should...
						</p>
						<ol>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;is an entity, storing the 
                                    <code>Transform2_Node</code>
                                    &nbsp;as a 
                                    <code>Sparse_Set</code>
                                    </s>.
								</p>
								<ul>
									<li>
										<p>
                                            This is probably the only option.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;stores an 
                                    <code>entity_key</code>
                                    &nbsp;for a 
                                    <code>Transform2_Node</code>
                                    ; the 
                                    <code>Transform2_Node</code>
                                    &nbsp;is stored in a 
                                    <code>Sparse_Set</code>
                                    &nbsp;but the key is not provided; used just like a 
                                    <code>hm.add</code>
                                    .</s>
								</p>
								<ul>
									<li>
										<p>
                                            This doesn't allow for queries and creates unsafer code.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;receives a foreign 
                                    <code>entity_key</code>
                                    &nbsp;to add data to the 
                                    <code>Transform2_Node</code>
                                    &nbsp;sparse set</s>.
								</p>
								<ul>
									<li>
										<p>
                                            This shots it self in the foot, basically.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    It's about having a reference to a 
                    <code>Transform2_Node</code>
                    , used by parent/children relationships.
				</p>
			</li>
			<li>
				<p>
                    Currently it uses pointers.
				</p>
			</li>
		</ul>
		<ol>
			<li>
				<p>
                    There's other keys available, besides the Entity, via:
				</p>
				<ol>
					<li>
						<p>
                            <s>Wherever specialization is needed, a new Entity is used</s>.
						</p>
						<ul>
							<li>
								<p>
                                    This possibility was explored in the &quot;The data is stored in an 
                                    <code>Component(T)</code>
                                    , using 
                                    <code>entity</code>
                                    &nbsp;to access the data&quot; idea below, and discarded as not being good.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            A 
                            <code>struct</code>
                            &nbsp;stores a key to the data:
						</p>
						<ol>
							<li>
								<p>
									<input
										type="checkbox" 
										disabled=""
										checked="">
                                    The data is stored in an 
                                    <code>Handle_Map(T)</code>
                                    , using 
                                    <code>.handle: Handle</code>
                                    &nbsp;to access the data, without any components
								</p>
								<ul>
									<li>
										<p>
											<strong>
                                                This is just a way to have 
                                                <code>transforms[idx]</code>
                                                , but with a generational system
											</strong>
                                            .
										</p>
									</li>
									<li>
										<p>
                                            When something is deleted or removed from the 
                                            <code>Handle_Map</code>
                                            , the elements in the internal array are not moved, so other handles are not invalidated.
										</p>
									</li>
									<li>
										<p>
                                            A 
                                            <code>Handle_Map</code>
                                            &nbsp;is a way to have a generic array (stack or heap) with ways to check if the entry in the array is valid. It does not care much about cache efficiency.
										</p>
									</li>
									<li>
										<p>
                                            It's possible to remove the necessity of having a handle inside of 
                                            <code>T</code>
                                            .
										</p>
										<ol>
											<li>
												<p>
                                                    The 
                                                    <code>Handle_Map</code>
                                                    &nbsp;stores an array of handles that match the required handle for a get.
												</p>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            How does this solve the current issue:
										</p>
										<ul>
											<li>
												<p>
                                                    In summary, the 
                                                    <code>Sprite</code>
                                                    &nbsp;doesn't hold a POINTER to a transform anymore, but a HANDLE.
												</p>
											</li>
											<li>
												<p>
                                                    When a 
                                                    <code>Dynamic_Body</code>
                                                    &nbsp;moves inside the 
                                                    <code>_dynamic_bodies</code>
                                                    &nbsp;component:
												</p>
												<ul>
													<li>
														<p>
                                                            Previously that would move that Transform2_Node as well, as 
                                                            <code>Body :: struct { using trans: Transform2_Node }</code>
                                                            , and as 
                                                            <code>Sprite.parent</code>
                                                            &nbsp;stores a pointer to that, moving the source would cause corrupted behavior.
														</p>
													</li>
													<li>
														<p>
                                                            Now, the data is no longer inside the 
                                                            <code>Body</code>
                                                            , but inside a 
                                                            <code>spatial.transforms</code>
                                                            , which makes so that when the 
                                                            <code>Body</code>
                                                            &nbsp;moves, the 
                                                            <code>Sprite.parent</code>
                                                            &nbsp;doesn't care.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in an 
                                    <code>[]T</code>
                                    &nbsp;or 
                                    <code>Component(T)</code>
                                    , using 
                                    <code>.ptr_to_t: ^T</code>
                                    &nbsp;to access the data, with or without using components</s>
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in an 
                                    <code>[]T</code>
                                    , using 
                                    <code>.idx_to_t: u32</code>
                                    &nbsp;to access the data, without any components</s>.
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
									<li>
										<p>
                                            It's just like handles, but without a generational index and some useful features that remember a 
                                            <code>Small_Array</code>
                                            ; there's no tracking of available slots.
										</p>
									</li>
									<li>
										<p>
                                            Seems like the handle idea is better.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in an 
                                    <code>[]T</code>
                                    , using 
                                    <code>.idx_to_t: u32</code>
                                    &nbsp;and 
                                    <code>_indices_to_t: Component(u32)</code>
                                    &nbsp;to access the data</s>
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The data is stored in a 
                                    <code>Component(T)</code>
                                    , using 
                                    <code>.dense_idx: u32</code>
                                    &nbsp;to access the data</s>
								</p>
								<ul>
									<li>
										<p>
                                            Immediate killer problem when the underlying storage structure changes.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>map: 
                                    <code>key</code>
                                    </s>
								</p>
								<ul>
									<li>
										<p>
                                            I prefer Sparse Sets (Components).
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
					<li>
						<p>
                            <s>The data is indirectly stored inside a manager</s>:
						</p>
						<ol>
							<li>
								<p>
                                    <s>Stored inside a 
                                    <code>Component(Transform_Storage)</code>
                                    </s>.
								</p>
								<ul>
									<li>
										<p>
                                            This doesn't solve the original problem of getting valid data; it only groups similar things together.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>Through a 
                                    <code>Transform_System</code>
                                    </s>
								</p>
								<ul>
									<li>
										<p>
                                            I would need a specific transform, and that I cannot get when all data is inside the 
                                            <code>Transform_System</code>
                                            . This doesn't solve the problem at all, only creates an extra layer of indirection.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    <s>If the only ACTUAL key available is the Entity, and I don't store this key anywhere</s>:
				</p>
				<ol>
					<li>
						<p>
                            <s>Many Array/Map/Handle_Map/Component</s>
						</p>
						<ul>
							<li>
								<p>
                                    This is a way to tackle specialization; having many storage structures doesn't solve the issue of things changing inside these backing structures.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>A 
                            <code>struct</code>
                            &nbsp;stores the data itself</s>:
						</p>
						<ul>
							<li>
								<p>
                                    I'd have to store pointers to the transform of other entities, while their transform for sure is being stored inside an array which changes. This is not possible.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>Component(T)</code>
                            , using 
                            <code>entity</code>
                            &nbsp;to access the data.</s>
						</p>
						<ul>
							<li>
								<p>
                                    The original sparse set design.
								</p>
							</li>
							<li>
								<p>
                                    This allows for all cache being updated on a single system.
								</p>
								<ul>
									<li>
										<p>
                                            This could be weird if the parent changes between updates, for sure.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Indirection: <s>There's an extra level of indirection where you have to go through the entity and check if it exists, and then check if this entity has a transform component</s>.
								</p>
								<ul>
									<li>
										<p>
                                            This is true, BUT this is also true for 
                                            <code>Handle_Map</code>
                                            :
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">trans2_node :: proc(trans: Transform2_Node_Handle) -&gt; (trans_node: ^Transform2_Node) {
&nbsp;&nbsp;&nbsp;&nbsp;trans_node = hm.get(&transforms2, trans)
&nbsp;&nbsp;&nbsp;&nbsp;if trans_node == nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error: not found
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return trans_node
}
</code></pre>
								<ul>
									<li>
										<p>
                                            For 
                                            <code>Sparse_Set</code>
                                            &nbsp;that would be:
										</p>
									</li>
								</ul>
<pre><code class="language-odin" data-lang="odin">trans2_node :: proc(trans: sparse.Key) -&gt; (trans_node: ^Transform2_Node) {
&nbsp;&nbsp;&nbsp;&nbsp;trans_node, found := sparse.get(&transforms, trans)
&nbsp;&nbsp;&nbsp;&nbsp;if !found {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error: not found
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return trans_node
}
</code></pre>
								<ul>
									<li>
										<p>
                                            It's the same level of indirection.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Problem
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            &quot;If a 'thing' is an entity, it cannot be considered a 'component' for another entity&quot;.
										</p>
									</li>
									<li>
										<p>
                                            Check the explanation for 
                                            <code>Sprite</code>
                                            .
										</p>
									</li>
								</ul>
							</li>
						</ul>
						<ol>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;is an entity, storing the 
                                    <code>Transform2_Node</code>
                                    &nbsp;as a 
                                    <code>Sparse_Set</code>
                                    </s>.
								</p>
<pre><code class="language-odin" data-lang="odin">transforms: ecs.Component(Transform2_Node)
Transform2_Node :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;using local:&nbsp;&nbsp; Transform2,
&nbsp;&nbsp;&nbsp;&nbsp;parent_entity: sparse.Key,
}

trans2_add :: proc(entity: sparse.Key, pos: [2]f32 = {}, rot: f32 = 0, scale: [2]f32 = { 1.0, 1.0 }, parent: sparse.Key = {}) {
&nbsp;&nbsp;&nbsp;&nbsp;assert(scale != 0)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;trans_node: Transform2_Node
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.pos&nbsp;&nbsp;&nbsp;&nbsp;= pos
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.rot&nbsp;&nbsp;&nbsp;&nbsp;= rot
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.scale&nbsp;&nbsp;= scale
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.parent = parent
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&transforms, entity, trans_node)
}
</code></pre>
								<ul>
									<li>
										<p>
                                            For 
                                            <code>Body</code>
                                            :
										</p>
<pre><code class="language-odin" data-lang="odin">Body_Data :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;handle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^jolt.Body,
&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jolt.Body_ID,

&nbsp;&nbsp;&nbsp;&nbsp;layers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32,
&nbsp;&nbsp;&nbsp;&nbsp;is_sensor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool,
&nbsp;&nbsp;&nbsp;&nbsp;shape:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape,

&nbsp;&nbsp;&nbsp;&nbsp;queued_changes: [dynamic]Body_Queue_Change,
}

// this body has the components: 'trans2', 'Body_Data'
_body_create :: proc(pos: [2]f32, parent: sparse.Key) -&gt; (entity: sparse.Key) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&bodies_data, entity, Body_Data{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// usual things here
&nbsp;&nbsp;&nbsp;&nbsp;})

&nbsp;&nbsp;&nbsp;&nbsp;return
}
</code></pre>
										<ul>
											<li>
												<p>
                                                    Atomicity:
												</p>
												<ul>
													<li>
														<p>
                                                            Body is ALREADY ATOMIC, so breaking it apart might give meaningless queries.
														</p>
													</li>
													<li>
														<p>
                                                            &quot;A body is an entity that has a 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;component and a 
                                                            <code>Body_Data</code>
                                                            &nbsp;component&quot;.
														</p>
													</li>
													<li>
														<p>
                                                            Other components 
															<em>
                                                                could
															</em>
                                                            &nbsp;make sense for a body, such as 
                                                            <code>velocity</code>
                                                            , which would define a &quot;dynamic body&quot;. Those might not actually be &quot;components&quot;, but the ACTUAL DEFINITION of a body.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            For 
                                            <code>Sprite</code>
                                            :
										</p>
<pre><code class="language-odin" data-lang="odin">Sprite_Data :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;debug_name:&nbsp;&nbsp; string,

&nbsp;&nbsp;&nbsp;&nbsp;// Tex
&nbsp;&nbsp;&nbsp;&nbsp;tex_path:&nbsp;&nbsp;&nbsp;&nbsp; string,
&nbsp;&nbsp;&nbsp;&nbsp;tex_extent:&nbsp;&nbsp; spatial.Extent,
&nbsp;&nbsp;&nbsp;&nbsp;tex_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u32,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// Mesh
&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mesh,

&nbsp;&nbsp;&nbsp;&nbsp;model_matrix: matrix[4, 4]f32,

&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatial.Recti,
&nbsp;&nbsp;&nbsp;&nbsp;flip_x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,
&nbsp;&nbsp;&nbsp;&nbsp;flip_y:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,

&nbsp;&nbsp;&nbsp;&nbsp;tile_size:&nbsp;&nbsp;&nbsp;&nbsp;[2]int,
&nbsp;&nbsp;&nbsp;&nbsp;tile_idx:&nbsp;&nbsp;&nbsp;&nbsp; int,
&nbsp;&nbsp;&nbsp;&nbsp;_total_tiles: int,

&nbsp;&nbsp;&nbsp;&nbsp;color_mult:&nbsp;&nbsp; [4]f32, // 0 to 1.
&nbsp;&nbsp;&nbsp;&nbsp;color_add:&nbsp;&nbsp;&nbsp;&nbsp;[4]f32, // 0 to 1.
}

sprite_create :: proc(
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [2]f32 = {},
&nbsp;&nbsp;&nbsp;&nbsp;rot:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f32&nbsp;&nbsp;&nbsp;&nbsp;= 0, 
&nbsp;&nbsp;&nbsp;&nbsp;scale:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [2]f32 = { 1, 1 }, 
&nbsp;&nbsp;&nbsp;&nbsp;parent:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sparse.Key = {},
&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; (sprite: Sprite) {
&nbsp;&nbsp;&nbsp;&nbsp;entity = _entity_count
&nbsp;&nbsp;&nbsp;&nbsp;_entity_count += 1
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity, pos, parent = parent)
}
</code></pre>
										<ul>
											<li>
												<p>
                                                    Atomicity:
												</p>
												<ul>
													<li>
														<p>
                                                            It doesn't make sense to separate the 
                                                            <code>Texture</code>
                                                            &nbsp;or 
                                                            <code>Mesh</code>
                                                            , as the sprite loses all its meaning without both of them. The rest also only has meaning if in the context of a sprite.
														</p>
													</li>
													<li>
														<p>
                                                            &quot;A sprite is an entity that has a 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;component and a 
                                                            <code>Sprite_Data</code>
                                                            &nbsp;component&quot;.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;stores an 
                                    <code>entity_key</code>
                                    &nbsp;for a 
                                    <code>Transform2_Node</code>
                                    ; the 
                                    <code>Transform2_Node</code>
                                    &nbsp;is stored in a 
                                    <code>Sparse_Set</code>
                                    &nbsp;but the key is not provided; used just like a 
                                    <code>hm.add</code>
                                    .</s>
								</p>
								<ul>
									<li>
										<p>
                                            Rationale
										</p>
										<ul>
											<li>
												<p>
                                                    I could query for 
                                                    <code>Transform2_Node</code>
                                                    &nbsp;data, I think.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
											<em>
                                                Problem
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    Queries:
												</p>
												<ul>
													<li>
														<p>
                                                            The query will use an &quot;Entity Key&quot; for intersecting 
                                                            <code>Sparse_Set</code>
                                                            s, BUT, in this circumstance, the 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;uses a &quot;Transform Key&quot;, as this key is not one from an entity, but one generated on 
                                                            <code>sparse.add</code>
                                                            /&quot;
                                                            <code>sparse.append</code>
                                                            &quot;. Any query performed with different &quot;keys&quot; are incompatible.
														</p>
														<ul>
															<li>
																<p>
                                                                    Example:
																</p>
																<ul>
																	<li>
																		<p>
                                                                            An entity 
                                                                            <code>5</code>
                                                                            &nbsp;might have a sprite sparse set, and this sprite has the &quot;transform_key&quot; 
                                                                            <code>8</code>
                                                                            ; when querying 
                                                                            <code>(&_sprites, &spatial.transforms)</code>
                                                                            , this will be highly incorrect, as the query will return the &quot;sprite 5&quot; and &quot;transform 5&quot;. This query gives incorrect information.
																		</p>
																	</li>
																</ul>
															</li>
														</ul>
													</li>
													<li>
														<p>
                                                            So: if using 
                                                            <code>Sparse Set</code>
                                                            s this way doesn't give me the query benefit, this strategy gives me nothing.
														</p>
													</li>
													<li>
														<p>
                                                            Sure, the data is more &quot;packed&quot;, but at the cost of confusion in the design, as I 
															<strong>
                                                                could
															</strong>
                                                            &nbsp;perform a query, but that would be incorrect, enabling mistakes if I'm not very aware of what the &quot;transform_key&quot; means.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    <s>The 
                                    <code>Body</code>
                                    /
                                    <code>Sprite</code>
                                    &nbsp;receives a foreign 
                                    <code>entity_key</code>
                                    &nbsp;to add data to the 
                                    <code>Transform2_Node</code>
                                    &nbsp;sparse set</s>.
								</p>
<pre><code class="language-odin" data-lang="odin">transforms: ecs.Component(Transform2_Node)

Transform2_Node :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;using local:&nbsp;&nbsp; Transform2,
&nbsp;&nbsp;&nbsp;&nbsp;parent_entity: sparse.Key,
}

trans2_add :: proc(entity: sparse.Key, pos: [2]f32 = {}, rot: f32 = 0, scale: [2]f32 = { 1.0, 1.0 }, parent: sparse.Key = {}) {
&nbsp;&nbsp;&nbsp;&nbsp;assert(scale != 0)

&nbsp;&nbsp;&nbsp;&nbsp;trans_node: Transform2_Node
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.pos&nbsp;&nbsp;&nbsp;&nbsp;= pos
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.rot&nbsp;&nbsp;&nbsp;&nbsp;= rot
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.scale&nbsp;&nbsp;= scale
&nbsp;&nbsp;&nbsp;&nbsp;trans_node.parent = parent

&nbsp;&nbsp;&nbsp;&nbsp;sparse.add(&transforms, entity, trans_node)
}
</code></pre>
<pre><code class="language-odin" data-lang="odin">Body :: struct {
&nbsp;&nbsp;&nbsp;&nbsp;using trans:&nbsp;&nbsp;&nbsp;&nbsp;sparse.Key,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;handle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^jolt.Body,

&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jolt.Body_ID,
&nbsp;&nbsp;&nbsp;&nbsp;layers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32,
&nbsp;&nbsp;&nbsp;&nbsp;is_sensor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool,
&nbsp;&nbsp;&nbsp;&nbsp;shape:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape,
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;queued_changes: [dynamic]Body_Queue_Change,
}

// TODO: what would this look like?
_body_create :: proc(entity_key: sparse.Key, pos: [2]f32, parent: spatial.Transform2_Node_Handle) -&gt; (body: Body) {
&nbsp;&nbsp;&nbsp;&nbsp;spatial.trans2_add(entity_key, pos, parent = parent)
}
</code></pre>
								<ul>
									<li>
										<p>
											<em>
                                                Problem
											</em>
                                            :
										</p>
										<ul>
											<li>
												<p>
                                                    The key received for 
                                                    <code>_body_create</code>
                                                    &nbsp;is most likely a key used for some other entity (if this is not the case, then this falls within the idea &quot;The 
                                                    <code>Body</code>
                                                    /
                                                    <code>Sprite</code>
                                                    &nbsp;is an entity, storing the 
                                                    <code>Transform2_Node</code>
                                                    &nbsp;as a 
                                                    <code>Sparse_Set</code>
                                                    &quot;), but this means that some problems emerge from the same entity having many things added to a sparse set using the same key.
												</p>
												<ul>
													<li>
														<p>
                                                            The solutions investigated were:
														</p>
														<ol>
															<li>
																<p>
                                                                    Wherever specialization is needed, a new Entity is used.
                                                                    <br>
                                                                    That's all...
																</p>
															</li>
														</ol>
													</li>
													<li>
														<p>
                                                            So this means that it all falls down to the idea &quot;The 
                                                            <code>Body</code>
                                                            /
                                                            <code>Sprite</code>
                                                            &nbsp;is an entity, storing the 
                                                            <code>Transform2_Node</code>
                                                            &nbsp;as a 
                                                            <code>Sparse_Set</code>
                                                            &quot;, and so this current idea is discarded.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
</ul>
<h3
	id="thinking-in-terms-of-specialization-and-shared-data" >
    Thinking in terms of specialization and shared data
</h3>
<ol>
	<li>
		<p>
            There's other keys available, besides the Entity, via:
		</p>
		<ol>
			<li>
				<p>
                    Wherever specialization is needed, a new Entity is used.
				</p>
				<ul>
					<li>
						<p>
                            This is a way to keep using Entity as the ONLY available key.
						</p>
					</li>
					<li>
						<p>
                            It's quite straight forward: need a new key -&gt; create a new entity, which is equivalent to creating a new key.
						</p>
					</li>
					<li>
						<p>
                            Works well when subobjects have independent lifecycles or lots of data/behavior.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    larger entity count and more queries for parent-child walking.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                Considerations
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The 
                                    <code>Damage_Indicator</code>
                                    &nbsp;doesn't OWN the sprite; it's just a reference from the entity's sprite.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Use this when the subobject has identity or can exist independently (or if it carries many other components). For small, ephemeral timers itâ€™s overkill.
						</p>
					</li>
					<li>
						<p>
                            Promoting AI and Hitbox to entities is a valid and common approach when those subsystems need identity, separate lifetime, or many components (including timers). It restores the â€œhintâ€ you miss and fits ECS philosophy (composition). Do it selectively: only promote when the subobject has independent behavior; otherwise keep a TimerStorage to avoid entity bloat.
						</p>
					</li>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            What are the possible advantages of having a system like this?
                            <br>
                            &quot;the entity dies, but the health bar or AI Controller stays behind&quot;.
						</p>
						<ul>
							<li>
								<p>
                                    Is there advantages for having data like this separate?
								</p>
								<ul>
									<li>
										<p>
                                            Thing for example, what if many entities use the same AI Controller or Health? (I don't know why, probably doesn't make sense); think of Shaco's Boxes.
                                            <br>
                                            this would mean:
                                            <br>
                                            | entity (entity_id) | health (entity_id) |
                                            <br>
                                            |--------------------|--------------------|
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                            <br>
                                            | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                            <br>
                                            | 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
										</p>
									</li>
									<li>
										<p>
                                            Is this currently possible?
										</p>
										<ul>
											<li>
												<p>
                                                    For add:
												</p>
												<ul>
													<li>
														<p>
                                                            <code>component.dense</code>
                                                            &nbsp;would have to increase.
														</p>
													</li>
													<li>
														<p>
                                                            <code>component.data</code>
                                                            &nbsp;stays the same.
														</p>
													</li>
													<li>
														<p>
                                                            <code>component.sparse[new_entity] = component.sparse[existing_entity]</code>
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    For remove:
												</p>
												<ul>
													<li>
														<p>
                                                            It would have to use the dense_idx from one entity and iterate over the whole array trying to find other entries that also use this dense_idx to remove them; something like that.
														</p>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<em>
                                How to kill sub-entities when the main entity dies?
							</em>
						</p>
						<ul>
							<li>
								<p>
                                    Use children / parent.
								</p>
							</li>
						</ul>
						<ol>
							<li>
								<p>
                                    There could be a component
								</p>
								<ul>
									<li>
										<p>
                                            If a component, I would do something like:
                                            <br>
                                            | entity (entity_id) | child (entity_id) |
                                            <br>
                                            |--------------------|-------------------|
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
                                            <br>
                                            | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
										</p>
									</li>
									<li>
										<p>
                                            So I use something like &quot;component_get_all&quot;, for example.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    Other data struct that maps one to another.
								</p>
								<ul>
									<li>
										<p>
                                            Using a map is basically the same as a component, but less efficient for huge amounts of entities, and incoherent with the current design.
										</p>
									</li>
									<li>
										<p>
                                            Remember, a Component is just a Sparse Set for Entities -&gt; T.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    The entity could be a struct, instead of a 
                                    <code>u32</code>
                                    .
								</p>
								<ul>
									<li>
										<p>
                                            This makes the 
                                            <code>Entity</code>
                                            &nbsp;and every Entity array fatter; it could be a problem, maybe.
										</p>
									</li>
									<li>
										<p>
                                            Also, children would require a heap allocated array, or a limit on how many children an entity can have by using a stack array.
										</p>
									</li>
								</ul>
							</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>A 
                    <code>struct</code>
                    &nbsp;stores a key to the data</s>:
				</p>
				<ul>
					<li>
						<p>
                            Wherever this struct is used, it basically indicates a little bit of OOP in this part of the code.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Core problem
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    Exposing direct references (raw pointers or dense indices) into component storage is unsafe because storage can move or be freed.
								</p>
							</li>
						</ul>
					</li>
				</ul>
				<ol>
					<li>
						<p>
							<input
								type="checkbox" 
								disabled=""
>
                            The data is stored in an 
                            <code>Handle_Map(T)</code>
                            , using 
                            <code>.handle: Handle</code>
                            &nbsp;to access the data, without any components.
						</p>
						<ul>
							<li>
								<p>
                                    A little bit better than an index, as:
								</p>
								<ul>
									<li>
										<p>
                                            if something moves inside the array, the index could be referencing something incoherent.
										</p>
									</li>
									<li>
										<p>
                                            Now, at least, you get notified on 
                                            <code>get()</code>
                                            &nbsp;that the handle used is invalid.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    A little bit better than a pointer, as:
								</p>
								<ul>
									<li>
										<p>
                                            If the object origin is freed, accessing or dereferencing the pointer would result in a crash
										</p>
									</li>
									<li>
										<p>
                                            Now, at least, the crash won't happen and you get notified that the handle is invalid.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Other Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            A handle has to be stored. Where?
										</p>
										<ol>
											<li>
												<p>
                                                    A Sparse_Set stores the Handle.
												</p>
												<ul>
													<li>
														<p>
                                                            This gives the impression of: &quot;Handle to Handle&quot; or &quot;Pointer to Pointer&quot;.
														</p>
													</li>
												</ul>
											</li>
										</ol>
									</li>
									<li>
										<p>
                                            Also, not using components make this data not compatible with queries/systems.
										</p>
										<ul>
											<li>
												<p>
                                                    This is a problem when you consider that querying the components is a way to update all data with same purpose together, improving performance and avoiding coupling data to objects. Not using components makes that the data is coupled with the struct storing the index.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            A 
                                            <code>Timer</code>
                                            &nbsp;would have to have a 
                                            <code>.handle</code>
                                            &nbsp;entry, as for the spec of the handle map library, so the handles can be compared.
										</p>
									</li>
									<li>
										<p>
                                            Extra complexity for each fetch.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Remove
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Not using components would cause to lose the notion of lifetime coupling with the entity.
										</p>
										<ul>
											<li>
												<p>
                                                    The handle has to manually be removed from the handle_map via using its handle.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>[]T</code>
                            , using 
                            <code>.idx_to_t: u32</code>
                            &nbsp;to access the data</s>.
						</p>
						<ul>
							<li>
								<p>
                                    This creates an extra indirection, with the sole purpose so the 
                                    <code>Damage_Indicator</code>
                                    &nbsp;have an index to the 
                                    <code>[]Sprite</code>
                                    &nbsp;via 
                                    <code>Damage_Indicator.sprite_idx: u32</code>
                                    .
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If something moves inside the array, the index could be referencing something incoherent.
										</p>
										<ul>
											<li>
												<p>
                                                    Things WILL move as soon as some entity is destroyed, etc; this happens a lot.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Other Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Not using components make this data not compatible with queries/systems. This is a problem when you consider that querying the components is a way to update all data with same purpose together, improving performance and avoiding coupling data to objects. Not using components makes that the data is coupled with the struct storing the index.
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Stored inside
									</em>
                                    :
								</p>
								<ol>
									<li>
										<p>
                                            Timer library.
										</p>
									</li>
									<li>
										<p>
                                            <s>Level</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    A bit annoying. There could be timers outside the level boundaries, for level transitions, etc.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Game</s>
										</p>
										<ul>
											<li>
												<p>
                                                    Sure, but timer library might be basically the same thing, while this would have to happen for every game.
												</p>
											</li>
											<li>
												<p>
                                                    Letting the library store this is more intuitive.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Global scope</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    Ugly. Timer library is better.
												</p>
											</li>
										</ul>
									</li>
								</ol>
							</li>
							<li>
								<p>
									<em>
                                        Remove
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Not using components would cause to lose the notion of lifetime coupling with the entity.
										</p>
										<ul>
											<li>
												<p>
                                                    The element inside that index has to manually be removed from the array via using its index.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>[]T</code>
                            , using 
                            <code>.idx_to_t: u32</code>
                            &nbsp;and 
                            <code>_indices_to_t: Component(u32)</code>
                            &nbsp;to access the data</s>.
						</p>
						<ul>
							<li>
								<p>
                                    This creates an extra indirection, with the sole purpose to allow the 
                                    <code>Damage_Indicator</code>
                                    &nbsp;to also have an index to the 
                                    <code>[]Sprite</code>
                                    &nbsp;via 
                                    <code>Damage_Indicator.sprite_idx: u32</code>
                                    . So both &quot;character&quot; and 
                                    <code>Damage_Indicator</code>
                                    &nbsp;hold into the same 
                                    <code>u32</code>
                                    .
                                    <br>
									<em>
                                        Stored inside
									</em>
                                    :
								</p>
								<ol>
									<li>
										<p>
                                            Timer library.
										</p>
									</li>
									<li>
										<p>
                                            <s>Level</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    A bit annoying. There could be timers outside the level boundaries, for level transitions, etc.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Game</s>
										</p>
										<ul>
											<li>
												<p>
                                                    Sure, but timer library might be basically the same thing, while this would have to happen for every game.
                                                    <br>
                                                    Letting the library store this is more intuitive.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            <s>Global scope</s>.
										</p>
										<ul>
											<li>
												<p>
                                                    Ugly. Timer library is better.
												</p>
											</li>
										</ul>
									</li>
								</ol>
							</li>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            While the &quot;character&quot; uses its 
                                            <code>Entity</code>
                                            &nbsp;id to access the u32, the 
                                            <code>Damage_Indicator</code>
                                            &nbsp;uses 
                                            <code>sprite_idx: u32</code>
                                            &nbsp;to get the data.
										</p>
										<ul>
											<li>
												<p>
                                                    This creates incoherences between these two methods of accessing the data. The 
                                                    <code>Entity</code>
                                                    &nbsp;method allows for entities to be moved, removed, etc, while the 
                                                    <code>Damage_Indicator</code>
                                                    &nbsp;is stuck with a 
                                                    <code>u32</code>
                                                    &nbsp;giving it direct access to the 
                                                    <code>[]Sprite</code>
                                                    . In a way, this is a worse/similar version of 
                                                    <code>Damage_Indicator.sprite_dense_idx: u32</code>
                                                    .
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            If something moves inside the array, the index could be referencing something incoherent.
										</p>
										<ul>
											<li>
												<p>
                                                    Things WILL move as soon as some entity is destroyed, etc; this happens a lot.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in a 
                            <code>Component(T)</code>
                            , using 
                            <code>.dense_idx: u32</code>
                            &nbsp;to access the data</s>.
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Storing the 
                                            <code>dense_idx</code>
                                            &nbsp;alone doesn't tell the whole story, as it's not clear WHICH component this 
                                            <code>dense_idx</code>
                                            &nbsp;refers to; this is unsafe.
										</p>
									</li>
									<li>
										<p>
                                            If components are removed, the 
                                            <code>dense_idx</code>
                                            &nbsp;could point to:
										</p>
										<ul>
											<li>
												<p>
                                                    something outside the boundaries of the 
                                                    <code>.data</code>
                                                    &nbsp;array;
												</p>
											</li>
											<li>
												<p>
                                                    or something completely different, unexpected.
												</p>
											</li>
											<li>
												<p>
                                                    In a way, this manages to have both issues of 'pointer invalidation through a free' AND 'idx invalidation for an array through moving the elements'.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>The data is stored in an 
                            <code>[]T</code>
                            &nbsp;or 
                            <code>Component(T)</code>
                            , using 
                            <code>.ptr_to_t: ^T</code>
                            &nbsp;to access the data, with or without using components</s>.
						</p>
						<ul>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            Pointers to data inside a 
                                            <code>Component(T)</code>
                                            &nbsp;should not be stored; which is the case for the return of 
                                            <code>sparse.add</code>
                                            .
										</p>
										<ul>
											<li>
												<p>
                                                    This pointer is a pointer to a SLOT on the 
                                                    <code>component.data</code>
                                                    &nbsp;array. If this array is resized, or any other thing happens to the contents of this array, the pointer will keep pointing to the same place, but now the data that was previously there might have changed causing random behavior, or might be invalid, causing a crash.
												</p>
											</li>
											<li>
												<p>
                                                    This is the same limitation for when using 
                                                    <code>Handle_Maps</code>
                                                    .
												</p>
											</li>
											<li>
												<p>
                                                    This completely prohibits the usage of this strategy.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
									<em>
                                        Annoyances
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If the object origin is freed, accessing or dereferencing the pointer would result in a crash.
										</p>
										<ul>
											<li>
												<p>
                                                    This is not really a problem if coupling the lifetimes of everything.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>map: 
                            <code>key</code>
                            </s>
						</p>
						<ul>
							<li>
								<p>
                                    I prefer Sparse Sets (Components).
								</p>
							</li>
							<li>
								<p>
                                    Shares the same problems as other storage structures.
								</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
				<p>
                    <s>The data is indirectly stored inside a manager</s>:
				</p>
				<ol>
					<li>
						<p>
                            <s>Stored inside a 
                            <code>Component(Timer_Storage)</code>
                            </s>.
						</p>
						<ul>
							<li>
								<p>
                                    This is better interpreted as a 
                                    <code>Component([]Timer)</code>
                                    .
								</p>
							</li>
							<li>
								<p>
                                    This is a way to avoid this:
                                    <br>
                                    | entity | health |
                                    <br>
                                    |--------|--------|
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                    <br>
                                    | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Wrong problem
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            This doesn't solve the original problem of fetching a specific data, it only groups similar things together. If you want a specific data inside that array, the original problem arises again.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            <s>Through a 
                            <code>Timer_System</code>
                            </s>
						</p>
						<ul>
							<li>
								<p>
                                    This follows up the design from a Tween.
								</p>
							</li>
							<li>
								<p>
                                    The timer would be added to the timer system, which could be all an entity needs for all its timers.
								</p>
							</li>
							<li>
								<p>
									<em>
                                        Killer Problems
									</em>
                                    :
								</p>
								<ul>
									<li>
										<p>
                                            If the same effect happens very frequently, the timer would not reset, but new ones are created instead and accumulating a lot of 
                                            <code>on_end</code>
                                            &nbsp;callbacks.
										</p>
									</li>
									<li>
										<p>
                                            In the same topic, a timer cannot be reset or stopped once it has started.
										</p>
									</li>
									<li>
										<p>
                                            This is just a way to avoid the referencing problem by delegating it to a system. It doesn't solve the problem for 
                                            <code>Sprite</code>
                                            &nbsp;for example. It avoids the &quot;timer type&quot; necessity, it does not solve it.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
		<p>
            <s>If the only ACTUAL key available is the Entity, and I don't store this key anywhere</s>:
		</p>
		<ol>
			<li>
				<p>
                    ~Many Array/Map/Handle_Map/Component
				</p>
				<ul>
					<li>
						<p>
                            Each new data struct represents semantic and intent, so that way I can specialize the data based on which &quot;array&quot; this is stored.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    I think this is a really bad solution, as if I have many specializations, I'd have to have many arrays, with permutations for each specialization.
								</p>
							</li>
							<li>
								<p>
                                    Ex:
								</p>
								<ul>
									<li>
										<p>
                                            sprite_bouncy
										</p>
									</li>
									<li>
										<p>
                                            sprite_bouncy_blinkable
										</p>
									</li>
									<li>
										<p>
                                            sprite_blinkable
										</p>
									</li>
									<li>
										<p>
                                            sprite_shadow
										</p>
									</li>
									<li>
										<p>
                                            etc
										</p>
									</li>
									<li>
										<p>
                                            timers_with_type1: Component(Timer)
										</p>
									</li>
									<li>
										<p>
                                            timers_with_type2: Component(Timer)
										</p>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    For Timers in specific, this seems like a huge waste, as every timer is different from another. I would end up having A LOT of different timer components, where most of them are basically empty, as it might be a very specific timer.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>A 
                    <code>struct</code>
                    &nbsp;stores the data itself</s>:
				</p>
				<ul>
					<li>
						<p>
                            This is basically OOPing this part of the code.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Killer Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    The MAIN problem of this strategy is &quot;shared data&quot;:
								</p>
								<ul>
									<li>
										<p>
                                            For example, the case of a 
                                            <code>Sprite</code>
                                            &nbsp;for 
                                            <code>Damage_Indicator</code>
                                            , as the sprite is a component from the entity.
										</p>
									</li>
									<li>
										<p>
                                            Every attempt to solve this would fall in one of these 2 ideas discussed:
										</p>
										<ol>
											<li>
												<p>
                                                    <s>&quot;The data is stored in an 
                                                    <code>[]T</code>
                                                    , while 
                                                    <code>_indices_to_t: Component(u32)</code>
                                                    &quot;</s>
												</p>
												<ul>
													<li>
														<p>
                                                            It was argued to be a bad idea.
														</p>
													</li>
												</ul>
											</li>
											<li>
												<p>
                                                    <s>A 
                                                    <code>struct</code>
                                                    &nbsp;stores a key to the data</s>
												</p>
											</li>
										</ol>
										<ul>
											<li>
												<p>
                                                    Both ideas are simply a DIFFERENT idea. Trying to solve the sharable problem requires a different design to be implemented. This idea cannot be saved when it comes to shared data, it's a problem from the design: something has ownership to the data and others want to access this data.
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<p>
                                    This breaks the idea of storing all data inside the same data struct, which breaks the idea of all Timers being updated together.
								</p>
								<ul>
									<li>
										<p>
                                            For timers, this requires 
                                            <code>update</code>
                                            &nbsp;to be called for each of them.
										</p>
										<ul>
											<li>
												<p>
                                                    As a way to avoid this, when initing a timer, it would be added to a:
												</p>
												<ol>
													<li>
														<p>
                                                            <code>Timer_System</code>
                                                            , passed as a parameter.
														</p>
													</li>
													<li>
														<p>
                                                            global process array, inside the 
                                                            <code>import "shared:eng/timer</code>
                                                            .
														</p>
													</li>
												</ol>
											</li>
											<li>
												<p>
                                                    Regardless, this is not the main problem.
												</p>
											</li>
										</ul>
									</li>
									<li>
										<p>
                                            Not so good of a system, as updating a timer is impossible to enforce, so you end up forgetting sometimes.
										</p>
									</li>
									<li>
										<p>
                                            Not so cache efficient for updates.
										</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    <s>The data is stored in an 
                    <code>Component(T)</code>
                    , using 
                    <code>entity</code>
                    &nbsp;to access the data</s>.
				</p>
				<ul>
					<li>
						<p>
                            The original sparse set design.
						</p>
					</li>
					<li>
						<p>
							<em>
                                Problems
							</em>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    It was from here that the specialization problem was originated.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</li>
</ol>

					</div>
					<footer
						id="previous-next" >
						<a
							href="/studies/Design Patterns/Data Oriented Design/Data Oriented Design.html" >
                            &nbsp;&lsaquo; Previous
						</a>
						<a
							href="/studies/Design Patterns/Data Oriented Design - COP/Data Oriented Design - COP.html" >
                            Next &rsaquo; 
						</a>
					</footer>
				</article>
			</main>
			<footer
				id="central-footer" >
                ðŸ§‘â€ðŸ’» built by and copyright
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                ðŸ“… 2025-10-21 .&nbsp;&nbsp;2026-01-21 ðŸš€
			</footer>
		</div>
		<aside
			id="right-sidebar" >
			<nav
				id="table-of-contents" >
				<strong>
                    On this page
				</strong>
				<ul>
					<li>
						<a
							href="#discussion" >
                            Discussion
						</a>
						<ul>
							<li>
								<a
									href="#critiques" >
                                    Critiques
								</a>
							</li>
							<li>
								<a
									href="#philosophy" >
                                    Philosophy
								</a>
							</li>
							<li>
								<a
									href="#relational-databases" >
                                    Relational Databases
								</a>
							</li>
							<li>
								<a
									href="#stream-processing-no-global-memory" >
                                    Stream Processing (no global memory)
								</a>
							</li>
							<li>
								<a
									href="#ownership" >
                                    Ownership
								</a>
							</li>
							<li>
								<a
									href="#existential-processing" >
                                    Existential processing
								</a>
							</li>
							<li>
								<a
									href="#enums" >
                                    Enums
								</a>
							</li>
							<li>
								<a
									href="#polymorphism" >
                                    Polymorphism
								</a>
							</li>
							<li>
								<a
									href="#events" >
                                    Events
								</a>
							</li>
							<li>
								<a
									href="#soa" >
                                    SOA
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#sources" >
                            Sources
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#entity" >
                            Entity
						</a>
						<ul>
						</ul>
					</li>
					<li>
						<a
							href="#component" >
                            Component
						</a>
						<ul>
							<li>
								<a
									href="#storage-models" >
                                    Storage Models
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#system" >
                            System
						</a>
						<ul>
							<li>
								<a
									href="#with-sparse-sets" >
                                    With Sparse Sets
								</a>
							</li>
							<li>
								<a
									href="#with-archetypes" >
                                    With Archetypes
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#design-n-gtn-relationship-differentiating-data-stable-handles-for-dealing-with-references-to-data-when-the-backing-storage-changes-add-remove-move-resize" >
                            Design: N-&gt;N relationship, differentiating data, stable handles for dealing with references to data when the backing storage changes (add/remove/move/resize)
						</a>
						<ul>
							<li>
								<a
									href="#adding-one-extra-indirection" >
                                    Adding one extra indirection
								</a>
							</li>
						</ul>
					</li>
					<li>
						<a
							href="#discarded-ideas" >
                            Discarded Ideas
						</a>
						<ul>
							<li>
								<a
									href="#handle_map-inside-a-sparse_set" >
                                    <s>Handle_Map inside a Sparse_Set</s>
								</a>
							</li>
							<li>
								<a
									href="#thinking-in-terms-of-valid-data-when-the-backing-storage-changes-add-remove-move-resize" >
                                    Thinking in terms of valid data when the backing storage changes (add/remove/move/resize)
								</a>
							</li>
							<li>
								<a
									href="#thinking-in-terms-of-specialization-and-shared-data" >
                                    Thinking in terms of specialization and shared data
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</aside>
		<script
			src="/static/studies.01935.js" >
		</script>
	</body>
</html>
