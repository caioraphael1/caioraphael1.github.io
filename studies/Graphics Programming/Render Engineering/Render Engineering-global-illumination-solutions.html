<!doctype html>
<html
	lang="en" >
	<head>
		<title>
            Caio Raphael
		</title>
		<meta
			charset="utf-8" >
		<meta
			name="viewport" 
			content="width=device-width, initial-scale=1" >
		<meta
			name="description" 
			content="Senior Game Developer, Engine Developer, Low-Level Network, Low-Level Systems, Physicist" >
		<meta
			name="author" 
			content="Caio Raphael" >
		<meta
			name="theme-color" 
			content="#ffffff" 
			media="(prefers-color-scheme: light)" >
		<meta
			name="theme-color" 
			content="#101010" 
			media="(prefers-color-scheme: dark)" >
		<link
			rel="icon" 
			href="/assets/icon.ico" >
		<link
			rel="icon" 
			href="/assets/icon-16x16.png" 
			sizes="16x16" 
			type="image/png" >
		<link
			rel="icon" 
			href="/assets/icon-32x32.png" 
			sizes="32x32" 
			type="image/png" >
		<script>
window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']]
                }
                };
		</script>
		<script
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" >
		</script>
		<script
			type="module" >

                    import hljs from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/highlight.min.js';
                    import hljs_odin from 'https://unpkg.com/highlightjs-odinlang@1.4.0/dist/odin.es.min.js';
                    import hljs_glsl from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/glsl.min.js';
                    import hljs_swift  from 'https://unpkg.com/@highlightjs/cdn-assets@11.11.1/es/languages/swift.min.js';
                    hljs.registerLanguage('odin', hljs_odin);
                    hljs.registerLanguage('glsl', hljs_glsl);
                    hljs.registerLanguage('gdscript', hljs_swift);
                    hljs.highlightAll();
                
		</script>
		<link
			rel="stylesheet" 
			href="/static/studies.70566.css" >
	</head>
	<body>
		<aside
			id="left-sidebar-wrapper" >
			<div
				id="left-sidebar" >
				<header>
					<a
						href="/" 
						class="site-logo" >
                        Caio Raphael
					</a>
					<p
						class="breadcrums-division" >
                        /
					</p>
					<a
						href="/studies/_index.html" 
						class="breadcrumbs-studies" >
                        Studies
					</a>
				</header>
				<nav>
					<details
>
						<summary>
                            Vulkan
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-samples.html" >
                                    Samples
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-core.html" >
                                    Core
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-render-loop.html" >
                                    Render Loop
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-synchronization-and-cache-control.html" >
                                    Synchronization and Cache Control
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-command-buffers.html" >
                                    Command Buffers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-pipelines.html" >
                                    Pipelines
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-graphics-pipeline.html" >
                                    Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-compute-pipeline.html" >
                                    Compute Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-resources.html" >
                                    Resources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-depth.html" >
                                    Depth
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mapping-data-to-shaders.html" >
                                    Mapping Data to Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-memory-allocation.html" >
                                    Memory Allocation
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-hdr-support.html" >
                                    HDR Support
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-profiling.html" >
                                    Profiling
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-mobile.html" >
                                    Mobile
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-vr.html" >
                                    VR
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-video-decoding.html" >
                                    Video Decoding
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-spir-v.html" >
                                    SPIR-V
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Vulkan/Vulkan-web.html" >
                                    Web
								</a>
							</li>
						</ul>
					</details>
					<details
						open="">
						<summary>
                            Render Engineering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-graphics-apis.html" >
                                    Graphics APIs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shader-languages.html" >
                                    Shader Languages
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-choosing-the-space-to-compute-lighting.html" >
                                    Choosing the Space to compute Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-bsdf-bidirectional-scattering-distribution-function.html" >
                                    BSDF (Bidirectional Scattering Distribution Function)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-material.html" >
                                    Material
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-direct-lighting.html" >
                                    Direct Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-shadows.html" >
                                    Shadows
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-skybox-skydome.html" >
                                    Skybox / Skydome
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-transparency.html" >
                                    Transparency
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-indirect-lighting.html" >
                                    Global Illumination / Indirect Lighting
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="active" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-solutions.html" >
                                    Global Illumination - Solutions
								</a>
								<ul>
									<li>
										<a
											href="#restir-gi" >
                                            ReSTIR GI
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#lumen" >
                                            Lumen
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#screen-space-radiance-caching" >
                                            Screen Space Radiance Caching
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#radiance-cascades-rc" >
                                            Radiance Cascades (RC)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#dynamic-diffuse-global-illumination-ddgi-ray-traced-irradiance-fields" >
                                            Dynamic Diffuse Global Illumination (DDGI) / Ray-Traced Irradiance Fields
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#screen-space-indirect-lighting-with-visibility-bitmask-vbao-ssilvb" >
                                            Screen Space Indirect Lighting with Visibility Bitmask (VBAO) (SSILVB)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#horizon-based-indirect-lighting" >
                                            Horizon-Based Indirect Lighting
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#multi-scale-ambient-occlusion-msao" >
                                            Multi-Scale Ambient Occlusion (MSAO)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#screen-space-reflection-ssr" >
                                            Screen Space Reflection (SSR)
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#distant-environment-probes-cube-map-ibl" >
                                            Distant Environment Probes / Cube Map IBL
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#reflection-probes-cube-map-reflections" >
                                            Reflection Probes / Cube Map Reflections
										</a>
										<ul>
										</ul>
									</li>
									<li>
										<a
											href="#planar-reflections-flat-mirror" >
                                            Planar Reflections / Flat Mirror
										</a>
									</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-global-illumination-discarded-solutions.html" >
                                    Global Illumination - Discarded Solutions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-lightmaps.html" >
                                    Lightmaps
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-post-processing.html" >
                                    Post-Processing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-anti-aliasing.html" >
                                    Anti-Aliasing
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-light-path-rendering-method.html" >
                                    Light Path / Rendering Method
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Render Engineering/Render Engineering-optimization-techniques.html" >
                                    Optimization Techniques
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Graphics and Shaders
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sources.html" >
                                    Sources
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-math-linear-algebra.html" >
                                    Math, Linear Algebra
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-spaces-transformations-and-graphics-pipeline.html" >
                                    Spaces, Transformations and Graphics Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-sizes.html" >
                                    Sizes
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-common-techniques.html" >
                                    Common Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-shaders.html" >
                                    Shaders
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Graphics and Shaders/Graphics and Shaders-fixing-artifacts.html" >
                                    Fixing Artifacts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GLSL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-basic.html" >
                                    Basic
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-storage-qualifiers.html" >
                                    Storage Qualifiers
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GLSL/GLSL-layout-qualifiers.html" >
                                    Layout Qualifiers
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            GPU
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-execution-building-blocks.html" >
                                    Execution Building Blocks
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-specialized-units-and-instructions.html" >
                                    Specialized units &amp; instructions
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-memory.html" >
                                    Memory
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-cache.html" >
                                    Cache
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-gpu-va-virtual-address.html" >
                                    GPU VA (Virtual Address)
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/GPU/GPU-tiled-gpus.html" >
                                    Tiled-GPUs
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Slang
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Slang-slang.html" >
                                    Slang
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            Font Rendering
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-techniques.html" >
                                    Techniques
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-text-processing-pipeline.html" >
                                    Text Processing Pipeline
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-concepts.html" >
                                    Concepts
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-formats.html" >
                                    Formats
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-libs.html" >
                                    Libs
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-tools.html" >
                                    Tools
								</a>
							</li>
						</ul>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/Font Rendering-fonts.html" >
                                    Fonts
								</a>
							</li>
						</ul>
					</details>
					<details
>
						<summary>
                            OpenGL
						</summary>
						<ul>
							<li>
								<a
									class="" 
									href="/studies/Graphics Programming/OpenGL/OpenGL-about.html" >
                                    About
								</a>
							</li>
						</ul>
					</details>
				</nav>
			</div>
		</aside>
		<main
			id="central-wrapper" >
			<main
				id="note-wrapper" >
				<header
					id="note-header" >
					<h1>
                        Global Illumination - Solutions
					</h1>
					<p>
						<time
							datetime="2025-07-03" >
                            üïí Created: 2025-07-03
						</time>
						<time
							datetime="2026-02-15" >
                            | Updated: 2026-02-15
						</time>
					</p>
				</header>
				<article
					id="note-content" >
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=Qz0KTGYJtUk" 
				class="external-link" 
				target="_blank" >
                Coding Adventure: Ray Tracing
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=C1H4zIiCOaI" 
				class="external-link" 
				target="_blank" >
                Coding Adventure: More Ray Tracing!
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="restir-gi" >
    ReSTIR GI
</h3>
<ul>
	<li>
		<p>
            ReSTIR GI is a spatio-temporal resampling algorithm for path/path-sample reuse (improving sampling of indirect lighting), i.e., a sampling/resampling approach for path/path-trace-based GI rather than a probe or voxel store.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://research.nvidia.com/publication/2021-06_restir-gi-path-resampling-real-time-path-tracing" 
				class="external-link" 
				target="_blank" >
                ReSTIR GI
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_1g-XhlI_5A" 
				class="external-link" 
				target="_blank" >
                ReSTIR GI Demo - Kajiya
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/EmbarkStudios/kajiya" 
				class="external-link" 
				target="_blank" >
                Kajiya
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/EmbarkStudios/kajiya/blob/main/docs/gi-overview.html" 
				class="internal-link" 
				target="_self" >
                ReSTIR GI - How it was implemented on Kajiya
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://cs.dartmouth.edu/~wjarosz/publications/bitterli20spatiotemporal.html" 
				class="external-link" 
				target="_blank" >
                Siggraph 2020 - Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="lumen" >
    Lumen
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://dev.epicgames.com/documentation/en-us/unreal-engine/lumen-global-illumination-and-reflections-in-unreal-engine" 
				class="external-link" 
				target="_blank" >
                Lumen - Unreal Engine 5
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    We settled on Mesh Signed Distance Fields for our Software Ray Tracing geometry representation. These give reliable occlusion, all areas have coverage, and we still get fast software ray tracing through sphere tracing, which skips through empty space. The intersection with the distance field surface only gives us the hit position and normal, we can‚Äôt find the material attributes or the lighting.
				</p>
			</li>
			<li>
				<p>
                    We tried runtime voxelization and voxel cone tracing, but merging geometry properties into a volume causes lots of leaking, especially in the lower mip maps.
				</p>
			</li>
			<li>
				<p>
                    We also tried voxel bit bricks, where we stored 1 bit per voxel to mark whether it contains geometry or not. Simple ray marching of bit bricks was surprisingly slow and after adding a proximity map for acceleration, we just decided to drop voxels and arrived at a Global Distance Field
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=2GYXuM10riw" 
				class="external-link" 
				target="_blank" >
                Radiance Caching for Real-time Global Illumination - 2021
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I watched the first 10 minutes of the video.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Keywords:
		</p>
		<ul>
			<li>
				<p>
                    Downsample incoming radiance.
				</p>
			</li>
		</ul>
	</li>
	<li>
        <img src="assets/image_20250919103905.png" width="350" >

	</li>
	<li>
		<p>
            Probes:
		</p>
		<ul>
			<li>
				<p>
                    Octahedral atlas with border.
				</p>
			</li>
			<li>
				<p>
                    8x8 per probe, resulting in 64 traces per probe.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919104113.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919104206.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919104235.png" width="450" >
                    .
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="screen-space-radiance-caching" >
    Screen Space Radiance Caching
</h3>
<ul>
	<li>
		<ol>
			<li>
			</li>
		</ol>
	</li>
	<li>
		<p>
            UE5 - Instead of tracing for every single pixel on screen, we bundle up our rays and we trace from a much smaller set of pixels.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=oJDonbFZbHk" 
				class="external-link" 
				target="_blank" >
                Two-Level Radiance Caching - AMD - GDC 2023
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Instead tradeoff between pathtracing and probes.
				</p>
			</li>
			<li>
				<p>
                    Less noise with less samples, sounds like a good idea.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/watch?v=57F1ezwH7Mk" 
				class="external-link" 
				target="_blank" >
                Enshourded - 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    SDF Rays.
				</p>
			</li>
			<li>
				<p>
                    Spatial Cascaded Cache.
				</p>
			</li>
			<li>
				<p>
                    Froxel Volumes.
				</p>
			</li>
			<li>
				<p>
                    Etc.
				</p>
			</li>
			<li>
				<p>
                    Intense.
				</p>
			</li>
			<li>
				<p>
                    I don't know if it is Forward+ or Deferred Rendering...
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="radiance-cascades-rc" >
    Radiance Cascades (RC)
</h3>
<ul>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://www.youtube.com/@Alexander_Sannikov/videos" 
				class="external-link" 
				target="_blank" >
                Author's channel
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://drive.google.com/file/d/1L6v1_7HY2X-LV3Ofb6oyTIxgEaP4LOI6/view" 
				class="external-link" 
				target="_blank" >
                Radiance Cascades: A Novel Approach to Calculating Global Illumination - August 2023
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=TrHHTQqmAaM" 
				class="external-link" 
				target="_blank" >
                Radiance Cascades - ExileCon 2023
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://youtu.be/TrHHTQqmAaM?feature=shared&t=2246" 
				class="external-link" 
				target="_blank" >
                Implementation of Radiance Cascades in World Space, purely
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=3so7xdZHKxw" 
				class="external-link" 
				target="_blank" >
                Exploring Radiance Cascades; soft-shadows, etc
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=6O9-BUDk_-c" 
				class="external-link" 
				target="_blank" >
                2D Global Illumination with Radiance Cascades
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://x.com/mxacop/status/1822851233708732579" 
				class="external-link" 
				target="_blank" >
                3D Demo
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Raikiri/LegitEngine" 
				class="external-link" 
				target="_blank" >
                Legit Engine
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    A rendergraph-based graphical framework for Vulkan, in C++.
				</p>
			</li>
			<li>
				<p>
                    The author of Radiance Cascades contributed to this engine.
				</p>
			</li>
			<li>
				<p>
                    Radiance Cascades is not implemented in this engine.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            They require a lot of compute and memory in 3D space.
		</p>
	</li>
	<li>
		<p>
            For 2D and screen-space 3D (like in Path of Exile 2) the amount of data you store is small enough that RC is an efficient solution, but it doesn't scale well for large 3D worlds.
		</p>
	</li>
	<li>
		<p>
            Path of Exile 2.
		</p>
	</li>
	<li>
		<p>
            Godot Discussion:
		</p>
		<ul>
			<li>
				<p>
                    Juan (against):
				</p>
				<ul>
					<li>
						<p>
                            Despite the hype, radiance cascades actually aren't all that practical, or at least aren't any more practical than competing techniques, in world space mode.
						</p>
					</li>
					<li>
						<p>
                            Radiance cascades shine in screen space mode (which is why they work excellently for Path of Exile), so they're less an alternative to Lumen/SDFGI and more an alternative to SSGI.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    fakhraldin (in favor):
				</p>
				<ul>
					<li>
						<p>
                            Suggested Radiance Cascades.
						</p>
					</li>
					<li>
						<p>
                            This GI solution is not restricted to 2D. Why should a probe based GI be restricted to only 2D in the first place? This doesn't make any sense for every graphics developer who got experience with probe based GI techniques, strange.
						</p>
					</li>
					<li>
						<p>
                            Radiance Cascades are not restricted to screen space but can be expanded to polygonal hardware ray tracing as well. Alexander clearly confirms this 
							<a
								href="https://youtu.be/bYTw3ISxgUw?feature=shared&t=74" 
								class="external-link" 
								target="_blank" >
                                here
							</a>
                            . And again it is strange to claim the opposite to every experienced graphics developer. In fact there are several released triple A titles, which use probe based GI with polygonal hardware ray tracing instead of screen space.
						</p>
					</li>
					<li>
						<p>
                            Screen Space is still being used even by triple A studios. Even Software Lumen itself does partially use SSGI for details of close objects among other techniques. Remember, Lumen is composed of several GI techniques. Million dollar game productions do rely on Screen Space. You don't come around using screen space for high frequency details in cross-gen graphics. Signed distance fields and voxel solutions are missing high frequency details.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Other people against:
				</p>
				<ul>
					<li>
						<p>
                            We both very explicitly say that yes, radiance cascades can be used in world space. Their limitations just don't make them a better or more practical alternative to SDFGI/HDDAGI. We both very explicitly say that radiance cascades could be a great alternative to SSGI.
						</p>
					</li>
					<li>
						<p>
                            I would like to see someone create a 3D radiance cascades solution (open-world would be even better). I'm a bit skeptical about its performance since, even in screen space, it's not that impressive compared to other screen space solutions, though it does look better.
						</p>
					</li>
					<li>
						<p>
                            Juan stated in his thread, open-world is actually radiance cascade's greatest weakness as a world space effect.
						</p>
					</li>
					<li>
						<p>
                            This is actually what makes radiance cascades (as a screen space effect) really good and why it's used in production in Path of Exile: the cost is the same as other SSGI approaches, but the quality is much higher.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Neither SDFGI nor HDDAGI are proven as practical solutions. SDFGI is being replaced by HDDAGI due to its inefficacy, and HDDAGI isn't released yet. Neither have effective parity with production-proven GI techniques and are ultimately experimental.
				</p>
			</li>
			<li>
				<p>
                    Take Avatar Frontiers of Pandora for example. Their technique is currently seen as the most sophisticated dynamic GI solution for cross-gen and next-gen realtime video games.
				</p>
			</li>
			<li>
				<p>
                    But it may surprise many people that their solution actually shares a similar ground concept of &quot;radiance cascades&quot;. They also use a probe based system. Instead of using radiance cascades, they combine different techniques like world space, screen space for high frequency details and ray tracing per hardware RT or compute shaders RT as a fallback. Similar to radiance cascades they implement additional different layers to achieve a wider spectrum of GI. They capture the world's details by &quot;different grades of detection&quot; so to speak.
				</p>
			</li>
			<li>
				<p>
                    The solution with &quot;radiance cascades&quot; is way less complicated, more performant and more scalable for hardware. Just like with SDFGI and HDDAGI we already use a probe grid. &quot;Radiance Cascades&quot; is just adding hierarchical probe grids with different resolutions to the existing one. This step increases detail capture and quality tremendously at cheap costs even with ray tracing.
				</p>
			</li>
			<li>
				<p>
                    We don't even need to make additional probe grids mandatory. It could be optional in the editor and even be offered as an in-game option. The more grid levels you can add, the more quality you can achieve according to your liking and machine. It is highly flexible.
				</p>
			</li>
			<li>
				<p>
                    From a technical standpoint i really don't see insurmountable objections against this solution, as it doesn't even interfere dramatically with the existing one. Rather it can serve as an additional, supportive and optional layer to the basic probe grid. If you don't want to apply it for world space, than don't do it. There are many another ways.
				</p>
			</li>
			<li>
				<p>
                    &quot;Radiance Cascades&quot; can be combined with world space and hardware rt or compute shaders rt to achieve similar results to ubisoft's GI solution, if not even better. Many features in godot turned out to be short-lived obsolete code. But i really don't see &quot;Radiance Cascades&quot; as such. It rather could serve as a basis for further development and options, which build upon it.
				</p>
			</li>
			<li>
				<p>
                    Our resources are limited and it would truly be a missed opportunity not to take advantage of this low-hanging fruit from which a great tree could grow.
				</p>
			</li>
			<li>
				<p>
                    World space radiance cascades has occlusion challenges (sound familiar?) and memory consumption challenges - just like pretty much all real time GI solutions.
				</p>
			</li>
			<li>
				<p>
                    However due to the specific nature of these challenges for radiance cascades, any practical implementation of world space radiance cascades will be limited to 3, at most 4, cascades.
				</p>
			</li>
			<li>
				<p>
                    What if you need GI for an open world map, for example? You might be able to make it work beyond that range, but most potential approaches are challenging to implement, and will likely be expensive to run.
				</p>
			</li>
			<li>
				<p>
                    For example, one potential approach is a cascade of radiance cascades. Literally running the entire thing multiple times at multiple sizes, and interpolating between them.
				</p>
			</li>
			<li>
				<p>
                    So, you might say: &quot;well maybe it can just be a higher quality short range alternative to SDFGI/HDDAGI?&quot; You may have some misconceptions about the level of quality of world space radiance cascades, compared to its much more impressive screen space counterpart.
				</p>
			</li>
			<li>
				<p>
                    Watch 
					<a
						href="https://www.youtube.com/watch?v=5Ua-h1pg6yM" 
						class="external-link" 
						target="_blank" >
                        this video that Sannikov himself posted
					</a>
                    . Does the blockiness and crawliness of the lighting look familiar to you? Does the volume representation look familiar to you? The quality tradeoffs of world space radiance cascades are very similar to the quality tradeoffs of SDFGI/HDDAGI. By replacing SDFGI/HDDAGI with world space radiance cascades, you are literally swapping it out with a technique that has practically the same quality, but much more limited range. You're gaining nothing, and losing something.
				</p>
			</li>
			<li>
				<p>
                    For screen space radiance cascades however, that's a different story. Pretty much everyone agrees it's incredible - probably the best screen space GI the industry has to offer right now, both in terms of performance and quality.
				</p>
			</li>
			<li>
				<p>
                    Author of Radiance Cascades, commenting on the HDDAGI PR:
				</p>
				<ul>
					<li>
						<p>
                            First, I never pitched 3d RC as the ultimate GI solution. I never even pitched it as a good GI solution. I wouldn't even call it practically viable by my standards, to be honest. I'm just saying that it's a direct improvement (in pretty much all parameters) over anything that has a regular grid (or nested grids) of radiance probes. DDGI for example.
						</p>
					</li>
					<li>
						<p>
                            Second, the screenspace version of RC is only limited to on-screen occluders and light sources if screenspace raymarching is used. However, screenspace cascades can store worldspace radiance intervals (including offscreen geometry) if you have a way of casting worldspace rays, using either a BVH, an SDM or a voxel raymarcher of some sort. The main limitation of this approach is that it only allows storing radiance on the surface of the depth buffer and you can't use it for example for volumetric lighting.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Juan apparently thought of an approach that's even better than HDDAGI, and will eventually work on that instead of continuing HDDAGI.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="dynamic-diffuse-global-illumination-ddgi-ray-traced-irradiance-fields" >
    Dynamic Diffuse Global Illumination (DDGI) / Ray-Traced Irradiance Fields
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.gdcvault.com/play/1026182/" 
				class="external-link" 
				target="_blank" >
                &quot;Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields&quot; - Majercik 2019
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
					<a
						href="https://www.youtube.com/watch?v=KufJBCTdn_o" 
						class="external-link" 
						target="_blank" >
                        Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields - Majercik 2019
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
                    Much of the talk is about:
				</p>
				<ul>
					<li>
						<p>
                            Fixing very common light leaks in techniques involving light probes.
						</p>
						<ul>
							<li>
								<p>
                                    <img src="assets/image_20250919095820.png" width="350" >
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250919095845.png" width="350" >
                                    .
								</p>
							</li>
							<li>
								<p>
                                    <img src="assets/image_20250919095750.png" width="350" >
                                    .
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            Better automatic placing of Light Probes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    &quot;Up to 256 rays per probe per frame, scaled down in some cases&quot;.
				</p>
			</li>
			<li>
				<p>
					<em>
                        Limitations
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            Don't sample on the surface, as it's really unstable.
						</p>
						<ul>
							<li>
								<p>
                                    1mm up and you are ok, 1mm down and you are inside the surface, where everything is black.
								</p>
							</li>
							<li>
								<p>
                                    Use a bias to improve this.
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjSgIuTlZ_vAhXxKX0KHeo-BNEQFjAEegQICRAD&url=http%3A%2F%2Fjcgt.org%2Fpublished%2F0008%2F02%2F01%2Fpaper-lowres.pdf&usg=AOvVaw2vJzwNmZPF7b5pjAf4Vtv8" 
				class="external-link" 
				target="_blank" >
                &quot;Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields&quot; - Majercik 2019
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://jcgt.org/published/0010/02/01/paper-lowres.pdf" 
				class="external-link" 
				target="_blank" >
                &quot;Scaling Probe-Based Real-Time Dynamic Global Illumination for Production&quot; - Majercik 2021
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://cescg.org/wp-content/uploads/2022/04/Rohacek-Improving-Probes-in-Dynamic-Diffuse-Global-Illumination.pdf" 
				class="external-link" 
				target="_blank" >
                &quot;Improving Probes in Dynamic Diffuse Global Illumination&quot; - Rohacek 2022
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            DDGI isn't an alternative to RTXGI, but a way to implement it using light probes.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=L1vhle74AEU" 
				class="external-link" 
				target="_blank" >
                Voxel engine with DDGI
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Probes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Uses probe volumes (a set of points in space storing irradiance + visibility).
				</p>
			</li>
			<li>
				<p>
                    A probe typically holds an estimate of 
					<em>
                        irradiance
					</em>
                    &nbsp;or sometimes 
					<em>
                        radiance distribution
					</em>
                    &nbsp;directly (often SH coefficients).
				</p>
				<ul>
					<li>
						<p>
                            Comparing to PRT, the DDGI Probes represent the current lighting, not a precomputed transfer.
						</p>
					</li>
					<li>
						<p>
                            PRT probe = precomputed transfer.
						</p>
						<ul>
							<li>
								<p>
                                    ‚ÄúThis is how light at this spot responds to any lighting, given the static scene geometry.‚Äù
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            DDGI probe = runtime-sampled irradiance.
						</p>
						<ul>
							<li>
								<p>
                                    ‚ÄúThis is the actual indirect lighting at this spot right now, given whatever is in the scene.‚Äù
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Probes store the incoming light in every single direction for rays passing through their center.
				</p>
			</li>
			<li>
				<p>
                    It may also store depth/visibility information (to reduce light leakage).
				</p>
			</li>
			<li>
				<p>
                    Each probe gathers lighting from the environment using ray tracing (usually hardware-accelerated).
				</p>
			</li>
			<li>
				<p>
                    Lighting between probes is interpolated at runtime.
				</p>
			</li>
			<li>
				<p>
                    When shading a point on a surface we sample the probes that are nearby, and blend for smooth lighting.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Requires a set of probes, each storing low-frequency irradiance (spherical harmonics, octahedral maps, or similar).
		</p>
	</li>
	<li>
		<p>
            Probes can be updated progressively with ray tracing, amortizing cost across frames.
		</p>
	</li>
	<li>
		<p>
            Usually only practical for low-frequency GI (no fine detail).
		</p>
	</li>
	<li>
		<p>
            Bias samples for probes that just had changes in irradiance, like importance sampling, could speed convergence after edits.
		</p>
	</li>
</ul>
<h3
	id="screen-space-indirect-lighting-with-visibility-bitmask-vbao-ssilvb" >
    Screen Space Indirect Lighting with Visibility Bitmask (VBAO) (SSILVB)
</h3>
<ul>
	<li>
		<p>
            The technique is essentially an extension to ground-truth ambient occlusion (GTAO).
		</p>
	</li>
	<li>
		<p>
            Huge performance gain from GTAO.
		</p>
	</li>
	<li>
		<p>
            Quality visuals of near raytracing ambient occlusion.
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://arxiv.org/pdf/2301.11376" 
				class="external-link" 
				target="_blank" >
                Screen Space Indirect Lighting with Visibility Bitmask - 2023
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<input
				type="checkbox" 
				disabled=""
>
            
			<a
				href="https://cybereality.com/screen-space-indirect-lighting-with-visibility-bitmask-improvement-to-gtao-ssao-real-time-ambient-occlusion-algorithm-glsl-shader-implementation/" 
				class="external-link" 
				target="_blank" >
                SSAO vs GTAO vs SSILVB and implementation of SSILVB
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I didn't read it properly.
				</p>
			</li>
			<li>
				<p>
                    The implementation is adapted from &quot;Screen Space Indirect Lighting with Visibility Bitmask&quot; by Olivier Therrien https://cdrinmatane.github.io/posts/cgspotlight-slides/.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=_RhsLkQRoi4" 
				class="external-link" 
				target="_blank" >
                SSILVB - Demo
			</a>
            .
		</p>
	</li>
</ul>
<h3
	id="horizon-based-indirect-lighting" >
    Horizon-Based Indirect Lighting
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf" 
				class="external-link" 
				target="_blank" >
                Horizon-Based Indirect Lighting - Benoit Patapom Mayoux 2018
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://github.com/Patapom/GodComplex/tree/master/Tests/TestHBIL" 
				class="external-link" 
				target="_blank" >
                HBIL Demo by Patapom (the author)
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            &quot;The ideal companion for your far-field indirect lighting solution&quot;.
		</p>
	</li>
	<li>
		<p>
            Treat the depth buffer as sort of a height field and march across that in slices.
		</p>
	</li>
	<li>
		<p>
            A horizon tells if new samples are hidden behind old samples.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918121447.png" width="300" >
            &nbsp;
            <img src="assets/image_20250918121534.png" width="300" >
            .
		</p>
	</li>
</ul>
<h3
	id="multi-scale-ambient-occlusion-msao" >
    Multi-Scale Ambient Occlusion (MSAO)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://www.comp.nus.edu.sg/~lowkl/publications/mssao_visual_computer_2012.pdf" 
				class="external-link" 
				target="_blank" >
                Efficient screen-space approach to high-quality multiscale ambient occlusion - 2012
			</a>
		</p>
	</li>
	<li>
		<p>
            &quot;I know HBAO+ is released but this method is far cheaper as you can see on that table in the end of the paper (They tested on GTX 460M! and it is 23ms average). I believe this method will give us far superior visuals than just SSAO.&quot;
		</p>
	</li>
	<li>
		<p>
			<strong>
                Wicked Engine 2024
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    This was my favourite SSAO so far because it handles large areas and small detail alike without any noise or temporal issues. It works by computing the AO in a deinterleaved version of the depth buffer that is contained in a Texture2DArray. It computes the AO in multiple resolutions, then upsamples and combines all of them into a final texture with bilateral blurring.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="screen-space-reflection-ssr" >
    Screen Space Reflection (SSR)
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://josselinsomervilleroberts.github.io/papers/Report_INF584.pdf" 
				class="external-link" 
				target="_blank" >
                Screen Space Reflections - 
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Used to capture reflections based on the rendered scene (using the previous frame for instance) by ray-marching in the depth buffer.
		</p>
	</li>
	<li>
		<p>
            SSR gives great results but can be very 
			<em>
                expensive
			</em>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/environment_and_post_processing.html#screen-space-reflections-ssr" 
				class="external-link" 
				target="_blank" >
                SSR - Godot
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=AHrG-rur3nQ" 
				class="external-link" 
				target="_blank" >
                SSR - Wicked Engine 2017 Demo
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I implemented screen space reflections around two years ago but never showed it off so here you go.
				</p>
			</li>
			<li>
				<p>
                    This is the simplest technique that I know of. It is using binary search when raymarching in view space.
				</p>
			</li>
		</ul>
	</li>
</ul>
<h3
	id="distant-environment-probes-cube-map-ibl" >
    Distant Environment Probes / Cube Map IBL
</h3>
<ul>
	<li>
		<p>
			<a
				href="https://google.github.io/filament/Filament.html.html#lighting/imagebasedlights" 
				class="internal-link" 
				target="_self" >
                IBL with Cube Maps - Filament
			</a>
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://www.youtube.com/watch?v=yEkryaaAsBU" 
				class="external-link" 
				target="_blank" >
                Lightmaps, Ambient Color, IBL with CubeMaps, Probe-based Lighting
			</a>
            .
		</p>
	</li>
	<li>
		<p>
            Used to capture lighting information at ‚Äúinfinity‚Äù, where parallax can be ignored. Distant probes typically contain the sky, distant landscape features or buildings, etc.
		</p>
	</li>
	<li>
		<p>
            The light is assumed to come from infinitely far away (which means every point on the object's surface uses the same environment map).
		</p>
	</li>
	<li>
		<p>
            They are either captured by the engine or acquired from a camera as high dynamic range images (HDRI).
		</p>
	</li>
	<li>
		<p>
			<strong>
                Irradiance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The whole environment contributes light to a given point on the object's surface.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Radiance
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The resulting light bouncing off of the object.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Incident lighting must be applied consistently to the diffuse and specular parts of the BRDF.
		</p>
	</li>
	<li>
		<p>
            Typically, the environment image is acquired offline in the real world, or generated by the engine either offline or at run time; either way, local or distant probes are used.
		</p>
	</li>
	<li>
		<p>
            Obviously the environment image must be acquired somehow and as we'll see below it needs to be pre-processed before it can be used for lighting.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250911114146.png" width="400" >
            .
		</p>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Implementing a fully dynamic day/night cycle requires for instance to recompute the distant light probes dynamically.
				</p>
			</li>
			<li>
				<p>
                    As probes only capture basic color information and direction, very shiny surfaces are not very doable.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918205514.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Far Cry 3 used probes. In that game you wouldn't find any shiny metallic object, as the probes cannot represent that type of lighting very easily.
				</p>
			</li>
			<li>
				<p>
                    IBL Cube Maps, on the other hand, could represent metals much better.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918205618.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    Images, in particular cubemaps, are a great way to encode such an ‚Äúenvironment light‚Äù.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Processing Light Probes
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    We saw previously that the radiance of an IBL is computed by integrating over the surface's hemisphere.
				</p>
			</li>
			<li>
				<p>
                    Since this would obviously be too expensive to do in real-time, we must first pre-process our light probes to convert them into a format better suited for real-time interactions.
				</p>
			</li>
			<li>
				<p>
                    The sections below will discuss the techniques used to accelerate the evaluation of light probes:
				</p>
				<ul>
					<li>
						<p>
							<strong>
                                Specular reflectance
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    pre-filtered importance sampling and split-sum approximation
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
							<strong>
                                Diffuse reflectance
							</strong>
                            :
						</p>
						<ul>
							<li>
								<p>
                                    irradiance map and spherical harmonics
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Implementation (Filament)
			</strong>
            :
		</p>
<pre><code class="language-glsl" data-lang="glsl">vec3 irradianceSH(vec3 n) {
&nbsp;&nbsp;&nbsp;&nbsp;// uniform vec3 sphericalHarmonics[9]
&nbsp;&nbsp;&nbsp;&nbsp;// We can use only the first 2 bands for better performance
&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sphericalHarmonics[0]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[1] * (n.y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[2] * (n.z)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[3] * (n.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[4] * (n.y * n.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[5] * (n.y * n.z)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[6] * (3.0 * n.z * n.z - 1.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[7] * (n.z * n.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sphericalHarmonics[8] * (n.x * n.x - n.y * n.y);
}

// NOTE: this is the DFG LUT implementation of the function above
vec2 prefilteredDFG_LUT(float coord, float NoV) {
&nbsp;&nbsp;&nbsp;&nbsp;// coord = sqrt(roughness), which is the mapping used by the
&nbsp;&nbsp;&nbsp;&nbsp;// IBL prefiltering code when computing the mipmaps
&nbsp;&nbsp;&nbsp;&nbsp;return textureLod(dfgLut, vec2(NoV, coord), 0.0).rg;
}

vec3 evaluateSpecularIBL(vec3 r, float perceptualRoughness) {
&nbsp;&nbsp;&nbsp;&nbsp;// This assumes a 256x256 cubemap, with 9 mip levels
&nbsp;&nbsp;&nbsp;&nbsp;float lod = 8.0 * perceptualRoughness;
&nbsp;&nbsp;&nbsp;&nbsp;// decodeEnvironmentMap() either decodes RGBM or is a no-op if the
&nbsp;&nbsp;&nbsp;&nbsp;// cubemap is stored in a float texture
&nbsp;&nbsp;&nbsp;&nbsp;return decodeEnvironmentMap(textureCubeLodEXT(environmentMap, r, lod));
}

vec3 evaluateIBL(vec3 n, vec3 v, vec3 diffuseColor, vec3 f0, vec3 f90, float perceptualRoughness) {
&nbsp;&nbsp;&nbsp;&nbsp;float NoV = max(dot(n, v), 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 r = reflect(-v, n);

&nbsp;&nbsp;&nbsp;&nbsp;// Specular indirect
&nbsp;&nbsp;&nbsp;&nbsp;vec3 indirectSpecular = evaluateSpecularIBL(r, perceptualRoughness);
&nbsp;&nbsp;&nbsp;&nbsp;vec2 env = prefilteredDFG_LUT(perceptualRoughness, NoV);
&nbsp;&nbsp;&nbsp;&nbsp;vec3 specularColor = f0 * env.x + f90 * env.y;

&nbsp;&nbsp;&nbsp;&nbsp;// Diffuse indirect
&nbsp;&nbsp;&nbsp;&nbsp;// We multiply by the Lambertian BRDF to compute radiance from irradiance
&nbsp;&nbsp;&nbsp;&nbsp;// With the Disney BRDF we would have to remove the Fresnel term that
&nbsp;&nbsp;&nbsp;&nbsp;// depends on NoL (it would be rolled into the SH). The Lambertian BRDF
&nbsp;&nbsp;&nbsp;&nbsp;// can be baked directly in the SH to save a multiplication here
&nbsp;&nbsp;&nbsp;&nbsp;vec3 indirectDiffuse = max(irradianceSH(n), 0.0) * Fd_Lambert();


&nbsp;&nbsp;&nbsp;&nbsp;// Indirect contribution
&nbsp;&nbsp;&nbsp;&nbsp;return diffuseColor * indirectDiffuse + indirectSpecular * specularColor;
}
</code></pre>
	</li>
	<li>
		<p>
			<strong>
                Implementation (Vulkan-glTF-PBR)
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    The snippets below come from 
                    <code>material_pbr.frag</code>
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
&nbsp;&nbsp;&nbsp;&nbsp;float lod = (pbrInputs.perceptualRoughness * uboParams.prefilteredCubeMipLevels);
&nbsp;&nbsp;&nbsp;&nbsp;// retrieve a scale and bias to F0. See [1], Figure 3
&nbsp;&nbsp;&nbsp;&nbsp;vec3 brdf = (texture(samplerBRDFLUT, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 diffuseLight = SRGBtoLINEAR(tonemap(texture(samplerIrradiance, n))).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 specularLight = SRGBtoLINEAR(tonemap(textureLod(prefilteredMap, reflection, lod))).rgb;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
&nbsp;&nbsp;&nbsp;&nbsp;vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
&nbsp;&nbsp;&nbsp;&nbsp;// For presentation, this allows us to disable IBL terms
&nbsp;&nbsp;&nbsp;&nbsp;// For presentation, this allows us to disable IBL terms
&nbsp;&nbsp;&nbsp;&nbsp;diffuse *= uboParams.scaleIBLAmbient;
&nbsp;&nbsp;&nbsp;&nbsp;specular *= uboParams.scaleIBLAmbient;
&nbsp;&nbsp;&nbsp;&nbsp;return diffuse + specular;
}
</code></pre>
		<ul>
			<li>
				<p>
                    Code where the IBL is calculated and used.
				</p>
			</li>
		</ul>
<pre><code class="language-glsl" data-lang="glsl">// Bla bla bla, basic lighting.
vec3 F = specularReflection(pbrInputs);
float G = geometricOcclusion(pbrInputs);
float D = microfacetDistribution(pbrInputs);
const vec3 u_LightColor = vec3(1.0);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

// Calculate lighting contribution from image based lighting source (IBL)
color += getIBLContribution(pbrInputs, n, reflection);
const float u_OcclusionStrength = 1.0f;

// -&gt; Ambient Occlusion
// Apply optional PBR terms for additional (optional) shading
if (material.occlusionTextureSet &gt; -1) {
&nbsp;&nbsp;&nbsp;&nbsp;float ao = texture(aoMap, (material.occlusionTextureSet == 0 ? inUV0 : inUV1)).r;
&nbsp;&nbsp;&nbsp;&nbsp;color = mix(color, color * ao, u_OcclusionStrength);
}

// Emissive
vec3 emissive = material.emissiveFactor.rgb * material.emissiveStrength;
if (material.emissiveTextureSet &gt; -1) {
&nbsp;&nbsp;&nbsp;&nbsp;emissive *= SRGBtoLINEAR(texture(emissiveMap, material.emissiveTextureSet == 0 ? inUV0 : inUV1)).rgb;
};
color += emissive;
outColor = vec4(color, baseColor.a);
</code></pre>
	</li>
</ul>
<h3
	id="reflection-probes-cube-map-reflections" >
    Reflection Probes / Cube Map Reflections
</h3>
<ul>
	<li>
		<p>
            Store environment 
			<em>
                radiance
			</em>
            &nbsp;(not just 
			<em>
                irradiance
			</em>
            ).
		</p>
	</li>
	<li>
		<p>
            Stores a cube map texture of the surroundings, representing light incoming from all directions.
		</p>
	</li>
	<li>
		<p>
			<strong>
                Usage
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Used for specular reflections (environment mapping).
				</p>
			</li>
			<li>
				<p>
                    Mipmapped cube maps can be used with roughness filtering (for PBR specular).
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Good fits
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    Games with a lot of metals, as that's where cube maps &quot;shine&quot; (literally).
				</p>
			</li>
			<li>
				<p>
                    Racing games are a good fit.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<strong>
                Limitations
			</strong>
            :
		</p>
		<ul>
			<li>
				<p>
                    They are static; if the scene changes, the cubemap needs to be regenerated, and that's expensive.
				</p>
			</li>
			<li>
				<p>
                    Doesn't handle self-reflections.
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250918204816.png" width="300" >
                            .
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
			<a
				href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/reflection_probes.html#doc-reflection-probes" 
				class="external-link" 
				target="_blank" >
                Reflection Probes - Godot
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    Reflection probes are used as a source of reflected and ambient light for objects inside their area of influence.
				</p>
			</li>
			<li>
				<p>
                    They can be used to provide more accurate reflections than VoxelGI and SDFGI while being fairly cheap on system resources.
				</p>
			</li>
			<li>
				<p>
                    Since reflection probes can also store ambient light, they can be used as a low-end alternative to VoxelGI and SDFGI when baked lightmaps aren't viable (e.g. in procedurally generated levels).
				</p>
			</li>
			<li>
				<p>
                    Good reflections, but poor indirect lighting.
				</p>
			</li>
			<li>
				<p>
                    Indirect lighting can be disabled, set to a constant color spread throughout the probe, or automatically read from the probe's environment (and applied as a cubemap). This essentially acts as local ambient lighting. Reflections and indirect lighting are blended with other nearby probes.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250918153234.png" width="350" >
                    &nbsp;
                    <img src="assets/image_20250918153250.png" width="350" >
                    .
				</p>
			</li>
			<li>
				<p>
                    It interacts with LightmapGI:
				</p>
				<ul>
					<li>
						<p>
                            <img src="assets/image_20250918153218.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    Reflection probes can also be used at the same time as SSR to provide reflections for off-screen objects.
				</p>
				<ul>
					<li>
						<p>
                            Godot will blend together the SSRs and reflections from reflection probes.
						</p>
					</li>
					<li>
						<p>
                            This way you can get the best of both worlds: high-quality reflections for general room structure (that remain present when off-screen), while also having real-time reflections for small details.
						</p>
					</li>
					<li>
						<p>
                            <img src="assets/image_20250918153004.png" width="350" >
                            .
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
                    To get reasonably accurate reflections, you should generally have one ReflectionProbe node per room (sometimes more for large rooms).
				</p>
			</li>
			<li>
				<p>
                    The extents don't have to be square, and you can even rotate the ReflectionProbe node to fit rooms that aren't aligned with the X/Z grid.
				</p>
				<ul>
					<li>
						<p>
                            Use this to your advantage to better cover rooms without having to place too many ReflectionProbe nodes.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<a
						href="https://docs.godotengine.org/en/4.4/tutorials/3d/global_illumination/reflection_probes.html#reflectionprobe-properties" 
						class="external-link" 
						target="_blank" >
                        Properties
					</a>
                    .
				</p>
			</li>
			<li>
				<p>
					<em>
                        Blending
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            To make transitions between reflection sources smoother, Godot supports automatic probe blending:
						</p>
						<ul>
							<li>
								<p>
                                    Up to 4 ReflectionProbes can be blended together at a given location. A ReflectionProbe will also fade out smoothly back to environment lighting when it isn't touching any other ReflectionProbe node.
								</p>
							</li>
							<li>
								<p>
                                    SDFGI and VoxelGI will blend in smoothly with ReflectionProbes if used. This allows placing ReflectionProbes strategically to get more accurate (or fully real-time) reflections where needed, while still having rough reflections available in the VoxelGI or SDFGI's area of influence.
								</p>
							</li>
						</ul>
					</li>
					<li>
						<p>
                            To make several ReflectionProbes blend with each other, you need to have part of each ReflectionProbe overlap each other's area. The extents should only overlap as little as possible with other reflection probes to improve rendering performance (typically a few units in 3D space).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p>
					<em>
                        Performance
					</em>
                    :
				</p>
				<ul>
					<li>
						<p>
                            ReflectionProbes with their update mode set to 
							<em>
                                Always
							</em>
                            &nbsp;are much more expensive than probes with their update mode set to 
							<em>
                                Once
							</em>
                            &nbsp;(the default). Suited for integrated graphics when using the Once update mode.
						</p>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
		<p>
            Rotate the camera 6 times to render the 6 faces of the cube.
		</p>
	</li>
	<li>
		<p>
            You only render the plane, not the Tea Pot.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918101524.png" width="250" >
            &nbsp;
            <img src="assets/image_20250918101708.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
            Instead of using the environment map loaded, you use the cubemap generated. So the reflection ON the Tea Pot only comes from this Cube Map.
		</p>
	</li>
	<li>
		<p>
            You should also use the Cube Map on the mirror image of the Tea Pot (made when using Planar Reflections).
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918102206.png" width="350" >
            .
		</p>
		<ul>
			<li>
				<p>
                    The mirror image is clearer now.
				</p>
			</li>
		</ul>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918095737.png" width="400" >
            .
		</p>
	</li>
</ul>
<h3
	id="planar-reflections-flat-mirror" >
    Planar Reflections / Flat Mirror
</h3>
<ul>
	<li>
		<p>
            Used to capture reflections by rendering the scene mirrored by a plane. This technique works only for flat surfaces such as building floors, roads and water.
		</p>
	</li>
	<li>
		<p>
            Instead of reflecting the entire world, we reflect the camera; it's the same thing.
		</p>
	</li>
	<li>
		<p>
            <img src="assets/image_20250918101612.png" width="300" >
            .
		</p>
	</li>
	<li>
		<p>
			<a
				href="https://wickedengine.net/2024/12/wicked-engines-graphics-in-2024/" 
				class="external-link" 
				target="_blank" >
                Wicked Engine 2024
			</a>
            .
		</p>
		<ul>
			<li>
				<p>
                    I‚Äôm disappointed whenever I see a modern game not supporting proper mirror reflections or if it has screen space reflection (SSR) on flat water. That‚Äôs why in Wicked Engine I‚Äôd like to show that planar reflection is still relevant and it should be one of the first choices of a game when a reflection needs to be rendered. The planar reflection is the perfect solution for a mirror because that‚Äôs what it was made for, and it‚Äôs good enough to use even on a large water surface with waves, like an ocean or a lake. Even though the waves are not totally accurate to be represented, it‚Äôs still a lot better than noisy SSR that cuts of abruptly.
				</p>
			</li>
			<li>
				<p>
                    <img src="assets/image_20250919090214.png" width="450" >
                    .
				</p>
			</li>
			<li>
				<p>
                    In Wicked Engine, the planar reflections are using a second full depth prepass + color pass with all the forward rendering pipeline capabilities. Although most of the secondary effects are turned off for them, simply by not running those passes for planar reflections. Also they don‚Äôt generate visibility buffer, only depth buffer in the prepass. Planar reflections rendering is also scheduled in the frame asynchronously to the main camera‚Äôs compute effects, so there is also room to utilize the modern graphics API to render them. Compared to the main camera, planar reflections are rendered in quarter of the main camera resolution in both axes so they become less dependent on the pixel shader performance, but more geometry heavy, which helps a bit with async compute passes at the same time. To combat the low resolution look, I choose to render them at 4x MSAA right now for some additional anti-aliasing. Quarter resolution means that the resolution is 1/16 compared to the main camera, and adding 4x MSAA on top doesn‚Äôt bring back the full detail, but I found it quite nice, for now, although it can be tweaked easily if needed.
				</p>
			</li>
		</ul>
	</li>
</ul>

				</article>
			</main>
			<footer
				id="central-footer" >
                üßë‚Äçüíª built and copyrighted by
				<a
					href="https://github.com/caioraphael1" 
					target="_blank" >
                    Caio Raphael
				</a>
                üìÖ 2025-2026 üöÄ
			</footer>
		</main>
		<script
			src="/static/studies.70566.js" >
		</script>
	</body>
</html>
